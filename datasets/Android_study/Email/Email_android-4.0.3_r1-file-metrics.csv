,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,com.android.email.StopWatch.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.Logging;

import android.os.SystemClock;
import android.util.Log;

/**
 * A simple class to measure elapsed time.
 *
 * <code>
 *   StopWatch s = StopWatch.start();
 *   // Do your stuff
 *   s.split();
 *   // More stuff
 *   s.split();
 *   // More stuff
 *   s.stop();
 * </code>
 */
public class StopWatch {
    private final String mName;
    private final long mStart;
    private long mLastSplit;

    private StopWatch(String name) {
        mName = name;
        mStart = getCurrentTime();
        mLastSplit = mStart;
        Log.w(Logging.LOG_TAG, ""StopWatch("" + mName + "") start"");
    }

    public static StopWatch start(String name) {
        return new StopWatch(name);
    }

    public void split(String label) {
        long now = getCurrentTime() ;
        long elapse = now - mLastSplit;
        Log.w(Logging.LOG_TAG, ""StopWatch("" + mName + "") split("" + label + "") "" + elapse);
        mLastSplit = now;
    }

    public void stop() {
        long now = getCurrentTime();
        long elapse = now - mLastSplit;
        Log.w(Logging.LOG_TAG, ""StopWatch("" + mName + "") stop: ""
                + (now - mLastSplit)
                + ""  (total "" + (now - mStart) + "")"");
    }

    private static long getCurrentTime() {
        // We might want to use other counters, such as currentThreadTimeMillis().
        // TODO add option for that?
        return SystemClock.elapsedRealtime();
    }
}
",True,2,0,0,1,1,0,1,L8
1,com.android.email.RecipientAdapter.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.ex.chips.BaseRecipientAdapter;
import com.android.ex.chips.RecipientEditTextView;

import android.accounts.Account;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;

public class RecipientAdapter extends BaseRecipientAdapter {
    public RecipientAdapter(Context context, RecipientEditTextView list) {
        super(context);
        Resources r = context.getResources();
        Bitmap def = BitmapFactory.decodeResource(r, R.drawable.ic_contact_picture);
        list.setChipDimensions(
                r.getDrawable(R.drawable.chip_background),
                r.getDrawable(R.drawable.chip_background_selected),
                r.getDrawable(R.drawable.chip_background_invalid),
                r.getDrawable(R.drawable.chip_delete), def, R.layout.more_item,
                R.layout.chips_alternate_item,
                        r.getDimension(R.dimen.chip_height),
                        r.getDimension(R.dimen.chip_padding),
                        r.getDimension(R.dimen.chip_text_size),
                        R.layout.copy_chip_dialog_layout);
    }

    /**
     * Set the account when known. Causes the search to prioritize contacts from
     * that account.
     */
    public void setAccount(Account account) {
        if (account != null) {
            // TODO: figure out how to infer the contacts account
            // type from the email account
            super.setAccount(new android.accounts.Account(account.name, ""unknown""));
        }
    }

    @Override
    protected int getDefaultPhotoResource() {
        return R.drawable.ic_contact_picture;
    }

    @Override
    protected int getItemLayout() {
        return R.layout.chips_recipient_dropdown_item;
    }

    @Override
    protected int getWaitingForDirectorySearchLayout() {
        return R.layout.chips_waiting_for_directory_search;
    }
}
",False,147,7,63,0,0,1,0,L6
2,com.android.email.Preferences.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.content.Context;
import android.content.SharedPreferences;
import android.text.TextUtils;
import android.util.Log;

import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;

import org.json.JSONArray;
import org.json.JSONException;

import java.util.HashSet;
import java.util.UUID;

public class Preferences {

    // Preferences file
    public static final String PREFERENCES_FILE = ""AndroidMail.Main"";

    // Preferences field names
    private static final String ACCOUNT_UUIDS = ""accountUuids"";
    private static final String ENABLE_DEBUG_LOGGING = ""enableDebugLogging"";
    private static final String ENABLE_EXCHANGE_LOGGING = ""enableExchangeLogging"";
    private static final String ENABLE_EXCHANGE_FILE_LOGGING = ""enableExchangeFileLogging"";
    private static final String INHIBIT_GRAPHICS_ACCELERATION = ""inhibitGraphicsAcceleration"";
    private static final String FORCE_ONE_MINUTE_REFRESH = ""forceOneMinuteRefresh"";
    private static final String ENABLE_STRICT_MODE = ""enableStrictMode"";
    private static final String DEVICE_UID = ""deviceUID"";
    private static final String ONE_TIME_INITIALIZATION_PROGRESS = ""oneTimeInitializationProgress"";
    private static final String AUTO_ADVANCE_DIRECTION = ""autoAdvance"";
    private static final String TEXT_ZOOM = ""textZoom"";
    private static final String BACKGROUND_ATTACHMENTS = ""backgroundAttachments"";
    private static final String TRUSTED_SENDERS = ""trustedSenders"";
    private static final String LAST_ACCOUNT_USED = ""lastAccountUsed"";
    private static final String REQUIRE_MANUAL_SYNC_DIALOG_SHOWN = ""requireManualSyncDialogShown"";

    public static final int AUTO_ADVANCE_NEWER = 0;
    public static final int AUTO_ADVANCE_OLDER = 1;
    public static final int AUTO_ADVANCE_MESSAGE_LIST = 2;
    // ""move to older"" was the behavior on older versions.
    private static final int AUTO_ADVANCE_DEFAULT = AUTO_ADVANCE_OLDER;

    // The following constants are used as offsets into R.array.general_preference_text_zoom_size.
    public static final int TEXT_ZOOM_TINY = 0;
    public static final int TEXT_ZOOM_SMALL = 1;
    public static final int TEXT_ZOOM_NORMAL = 2;
    public static final int TEXT_ZOOM_LARGE = 3;
    public static final int TEXT_ZOOM_HUGE = 4;
    // ""normal"" will be the default
    public static final int TEXT_ZOOM_DEFAULT = TEXT_ZOOM_NORMAL;

    // Starting something new here:
    // REPLY_ALL is saved by the framework (CheckBoxPreference's parent, Preference).
    // i.e. android:persistent=true in general_preferences.xml
    public static final String REPLY_ALL = ""reply_all"";
    // Reply All Default - when changing this, be sure to update general_preferences.xml
    public static final boolean REPLY_ALL_DEFAULT = false;

    private static Preferences sPreferences;

    private final SharedPreferences mSharedPreferences;

    /**
     * A set of trusted senders for whom images and external resources should automatically be
     * loaded for.
     * Lazilly created.
     */
    private HashSet<String> mTrustedSenders = null;

    private Preferences(Context context) {
        mSharedPreferences = context.getSharedPreferences(PREFERENCES_FILE, Context.MODE_PRIVATE);
    }

    /**
     * TODO need to think about what happens if this gets GCed along with the
     * Activity that initialized it. Do we lose ability to read Preferences in
     * further Activities? Maybe this should be stored in the Application
     * context.
     */
    public static synchronized Preferences getPreferences(Context context) {
        if (sPreferences == null) {
            sPreferences = new Preferences(context);
        }
        return sPreferences;
    }

    public static SharedPreferences getSharedPreferences(Context context) {
        return getPreferences(context).mSharedPreferences;
    }

    public static String getLegacyBackupPreference(Context context) {
        return getPreferences(context).mSharedPreferences.getString(ACCOUNT_UUIDS, null);
    }

    public static void clearLegacyBackupPreference(Context context) {
        getPreferences(context).mSharedPreferences.edit().remove(ACCOUNT_UUIDS).apply();
    }

    public void setEnableDebugLogging(boolean value) {
        mSharedPreferences.edit().putBoolean(ENABLE_DEBUG_LOGGING, value).apply();
    }

    public boolean getEnableDebugLogging() {
        return mSharedPreferences.getBoolean(ENABLE_DEBUG_LOGGING, false);
    }

    public void setEnableExchangeLogging(boolean value) {
        mSharedPreferences.edit().putBoolean(ENABLE_EXCHANGE_LOGGING, value).apply();
    }

    public boolean getEnableExchangeLogging() {
        return mSharedPreferences.getBoolean(ENABLE_EXCHANGE_LOGGING, false);
    }

    public void setEnableExchangeFileLogging(boolean value) {
        mSharedPreferences.edit().putBoolean(ENABLE_EXCHANGE_FILE_LOGGING, value).apply();
    }

    public boolean getEnableExchangeFileLogging() {
        return mSharedPreferences.getBoolean(ENABLE_EXCHANGE_FILE_LOGGING, false);
    }

    public void setInhibitGraphicsAcceleration(boolean value) {
        mSharedPreferences.edit().putBoolean(INHIBIT_GRAPHICS_ACCELERATION, value).apply();
    }

    public boolean getInhibitGraphicsAcceleration() {
        return mSharedPreferences.getBoolean(INHIBIT_GRAPHICS_ACCELERATION, false);
    }

    public void setForceOneMinuteRefresh(boolean value) {
        mSharedPreferences.edit().putBoolean(FORCE_ONE_MINUTE_REFRESH, value).apply();
    }

    public boolean getForceOneMinuteRefresh() {
        return mSharedPreferences.getBoolean(FORCE_ONE_MINUTE_REFRESH, false);
    }

    public void setEnableStrictMode(boolean value) {
        mSharedPreferences.edit().putBoolean(ENABLE_STRICT_MODE, value).apply();
    }

    public boolean getEnableStrictMode() {
        return mSharedPreferences.getBoolean(ENABLE_STRICT_MODE, false);
    }

    /**
     * Generate a new ""device UID"".  This is local to Email app only, to prevent possibility
     * of correlation with any other user activities in any other apps.
     * @return a persistent, unique ID
     */
    public synchronized String getDeviceUID() {
         String result = mSharedPreferences.getString(DEVICE_UID, null);
         if (result == null) {
             result = UUID.randomUUID().toString();
             mSharedPreferences.edit().putString(DEVICE_UID, result).apply();
         }
         return result;
    }

    public int getOneTimeInitializationProgress() {
        return mSharedPreferences.getInt(ONE_TIME_INITIALIZATION_PROGRESS, 0);
    }

    public void setOneTimeInitializationProgress(int progress) {
        mSharedPreferences.edit().putInt(ONE_TIME_INITIALIZATION_PROGRESS, progress).apply();
    }

    public int getAutoAdvanceDirection() {
        return mSharedPreferences.getInt(AUTO_ADVANCE_DIRECTION, AUTO_ADVANCE_DEFAULT);
    }

    public void setAutoAdvanceDirection(int direction) {
        mSharedPreferences.edit().putInt(AUTO_ADVANCE_DIRECTION, direction).apply();
    }

    public int getTextZoom() {
        return mSharedPreferences.getInt(TEXT_ZOOM, TEXT_ZOOM_DEFAULT);
    }

    public void setTextZoom(int zoom) {
        mSharedPreferences.edit().putInt(TEXT_ZOOM, zoom).apply();
    }

    public boolean getBackgroundAttachments() {
        return mSharedPreferences.getBoolean(BACKGROUND_ATTACHMENTS, false);
    }

    public void setBackgroundAttachments(boolean allowed) {
        mSharedPreferences.edit().putBoolean(BACKGROUND_ATTACHMENTS, allowed).apply();
    }

    /**
     * Determines whether or not a sender should be trusted and images should automatically be
     * shown for messages by that sender.
     */
    public boolean shouldShowImagesFor(String email) {
        if (mTrustedSenders == null) {
            try {
                mTrustedSenders = parseEmailSet(mSharedPreferences.getString(TRUSTED_SENDERS, """"));
            } catch (JSONException e) {
                // Something went wrong, and the data is corrupt. Just clear it to be safe.
                Log.w(Logging.LOG_TAG, ""Trusted sender set corrupted. Clearing"");
                mSharedPreferences.edit().putString(TRUSTED_SENDERS, """").apply();
                mTrustedSenders = new HashSet<String>();
            }
        }
        return mTrustedSenders.contains(email);
    }

    /**
     * Marks a sender as trusted so that images from that sender will automatically be shown.
     */
    public void setSenderAsTrusted(String email) {
        if (!mTrustedSenders.contains(email)) {
            mTrustedSenders.add(email);
            mSharedPreferences
                    .edit()
                    .putString(TRUSTED_SENDERS, packEmailSet(mTrustedSenders))
                    .apply();
        }
    }

    /**
     * Clears all trusted senders asynchronously.
     */
    public void clearTrustedSenders() {
        mTrustedSenders = new HashSet<String>();
        mSharedPreferences
                .edit()
                .putString(TRUSTED_SENDERS, packEmailSet(mTrustedSenders))
                .apply();
    }

    HashSet<String> parseEmailSet(String serialized) throws JSONException {
        HashSet<String> result = new HashSet<String>();
        if (!TextUtils.isEmpty(serialized)) {
            JSONArray arr = new JSONArray(serialized);
            for (int i = 0, len = arr.length(); i < len; i++) {
                result.add((String) arr.get(i));
            }
        }
        return result;
    }

    String packEmailSet(HashSet<String> set) {
        return new JSONArray(set).toString();
    }

    /**
     * Returns the last used account ID as set by {@link #setLastUsedAccountId}.
     * The system makes no attempt to automatically track what is considered a ""use"" - clients
     * are expected to call {@link #setLastUsedAccountId} manually.
     *
     * Note that the last used account may have been deleted in the background so there is also
     * no guarantee that the account exists.
     */
    public long getLastUsedAccountId() {
        return mSharedPreferences.getLong(LAST_ACCOUNT_USED, Account.NO_ACCOUNT);
    }

    /**
     * Sets the specified ID of the last account used. Treated as an opaque ID and does not
     * validate the value. Value is saved asynchronously.
     */
    public void setLastUsedAccountId(long accountId) {
        mSharedPreferences
                .edit()
                .putLong(LAST_ACCOUNT_USED, accountId)
                .apply();
    }

    /**
     * Gets whether the require manual sync dialog has been shown for the specified account.
     * It should only be shown once per account.
     */
    public boolean getHasShownRequireManualSync(Context context, Account account) {
        return getBoolean(context, account.getEmailAddress(), REQUIRE_MANUAL_SYNC_DIALOG_SHOWN,
                false);
    }

    /**
     * Sets whether the require manual sync dialog has been shown for the specified account.
     * It should only be shown once per account.
     */
    public void setHasShownRequireManualSync(Context context, Account account, boolean value) {
        setBoolean(context, account.getEmailAddress(), REQUIRE_MANUAL_SYNC_DIALOG_SHOWN, value);
    }


    /**
     * Get whether to show the manual sync dialog. This dialog is shown when the user is roaming,
     * connected to a mobile network, the administrator has set the RequireManualSyncWhenRoaming
     * flag to true, and the dialog has not been shown before for the supplied account.
     */
    public boolean shouldShowRequireManualSync(Context context, Account account) {
        return Account.isAutomaticSyncDisabledByRoaming(context, account.mId)
                && !getHasShownRequireManualSync(context, account);
    }

    public void clear() {
        mSharedPreferences.edit().clear().apply();
    }

    public void dump() {
        if (Logging.LOGD) {
            for (String key : mSharedPreferences.getAll().keySet()) {
                Log.v(Logging.LOG_TAG, key + "" = "" + mSharedPreferences.getAll().get(key));
            }
        }
    }

    /**
     * Utility method for setting a boolean value on a per-account preference.
     */
    private void setBoolean(Context context, String account, String key, Boolean value) {
        mSharedPreferences.edit().putBoolean(makeKey(account, key), value).apply();
    }

    /**
     * Utility method for getting a boolean value from a per-account preference.
     */
    private boolean getBoolean(Context context, String account, String key, boolean def) {
        return mSharedPreferences.getBoolean(makeKey(account, key), def);
    }

    /**
     * Utility method for creating a per account preference key.
     */
    private String makeKey(String account, String key) {
        return account != null ? account + ""-"" + key : key;
    }
}
",False,161,5,74,4,6,14,3,L6
3,com.android.email.NotificationController.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.app.Notification;
import android.app.Notification.Builder;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.database.ContentObserver;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.media.AudioManager;
import android.net.Uri;
import android.os.Handler;
import android.os.Looper;
import android.os.Process;
import android.text.SpannableString;
import android.text.TextUtils;
import android.util.Log;

import com.android.email.activity.ContactStatusLoader;
import com.android.email.activity.Welcome;
import com.android.email.activity.setup.AccountSecurity;
import com.android.email.activity.setup.AccountSettings;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.Address;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.util.HashMap;
import java.util.HashSet;

/**
 * Class that manages notifications.
 */
public class NotificationController {
    private static final int NOTIFICATION_ID_SECURITY_NEEDED = 1;
    /** Reserved for {@link com.android.exchange.CalendarSyncEnabler} */
    @SuppressWarnings(""unused"")
    private static final int NOTIFICATION_ID_EXCHANGE_CALENDAR_ADDED = 2;
    private static final int NOTIFICATION_ID_ATTACHMENT_WARNING = 3;
    private static final int NOTIFICATION_ID_PASSWORD_EXPIRING = 4;
    private static final int NOTIFICATION_ID_PASSWORD_EXPIRED = 5;

    private static final int NOTIFICATION_ID_BASE_NEW_MESSAGES = 0x10000000;
    private static final int NOTIFICATION_ID_BASE_LOGIN_WARNING = 0x20000000;

    /** Selection to retrieve accounts that should we notify user for changes */
    private final static String NOTIFIED_ACCOUNT_SELECTION =
        Account.FLAGS + ""&"" + Account.FLAGS_NOTIFY_NEW_MAIL + "" != 0"";

    private static NotificationThread sNotificationThread;
    private static Handler sNotificationHandler;
    private static NotificationController sInstance;
    private final Context mContext;
    private final NotificationManager mNotificationManager;
    private final AudioManager mAudioManager;
    private final Bitmap mGenericSenderIcon;
    private final Bitmap mGenericMultipleSenderIcon;
    private final Clock mClock;
    // TODO We're maintaining all of our structures based upon the account ID. This is fine
    // for now since the assumption is that we only ever look for changes in an account's
    // INBOX. We should adjust our logic to use the mailbox ID instead.
    /** Maps account id to the message data */
    private final HashMap<Long, ContentObserver> mNotificationMap;
    private ContentObserver mAccountObserver;
    /**
     * Suspend notifications for this account. If {@link Account#NO_ACCOUNT}, no
     * account notifications are suspended. If {@link Account#ACCOUNT_ID_COMBINED_VIEW},
     * notifications for all accounts are suspended.
     */
    private long mSuspendAccountId = Account.NO_ACCOUNT;

    /**
     * Timestamp indicating when the last message notification sound was played.
     * Used for throttling.
     */
    private long mLastMessageNotifyTime;

    /**
     * Minimum interval between notification sounds.
     * Since a long sync (either on account setup or after a long period of being offline) can cause
     * several notifications consecutively, it can be pretty overwhelming to get a barrage of
     * notification sounds. Throttle them using this value.
     */
    private static final long MIN_SOUND_INTERVAL_MS = 15 * 1000; // 15 seconds

    /** Constructor */
    @VisibleForTesting
    NotificationController(Context context, Clock clock) {
        mContext = context.getApplicationContext();
        mNotificationManager = (NotificationManager) context.getSystemService(
                Context.NOTIFICATION_SERVICE);
        mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
        mGenericSenderIcon = BitmapFactory.decodeResource(mContext.getResources(),
                R.drawable.ic_contact_picture);
        mGenericMultipleSenderIcon = BitmapFactory.decodeResource(mContext.getResources(),
                R.drawable.ic_notification_multiple_mail_holo_dark);
        mClock = clock;
        mNotificationMap = new HashMap<Long, ContentObserver>();
    }

    /** Singleton access */
    public static synchronized NotificationController getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new NotificationController(context, Clock.INSTANCE);
        }
        return sInstance;
    }

    /**
     * Return whether or not a notification, based on the passed-in id, needs to be ""ongoing""
     * @param notificationId the notification id to check
     * @return whether or not the notification must be ""ongoing""
     */
    private boolean needsOngoingNotification(int notificationId) {
        // ""Security needed"" must be ongoing so that the user doesn't close it; otherwise, sync will
        // be prevented until a reboot.  Consider also doing this for password expired.
        return notificationId == NOTIFICATION_ID_SECURITY_NEEDED;
    }

    /**
     * Returns a {@link Notification} for an event with the given account. The account contains
     * specific rules on ring tone usage and these will be used to modify the notification
     * behaviour.
     *
     * @param account The account this notification is being built for.
     * @param ticker Text displayed when the notification is first shown. May be {@code null}.
     * @param title The first line of text. May NOT be {@code null}.
     * @param contentText The second line of text. May NOT be {@code null}.
     * @param intent The intent to start if the user clicks on the notification.
     * @param largeIcon A large icon. May be {@code null}
     * @param number A number to display using {@link Builder#setNumber(int)}. May
     *        be {@code null}.
     * @param enableAudio If {@code false}, do not play any sound. Otherwise, play sound according
     *        to the settings for the given account.
     * @return A {@link Notification} that can be sent to the notification service.
     */
    private Notification createAccountNotification(Account account, String ticker,
            CharSequence title, String contentText, Intent intent, Bitmap largeIcon,
            Integer number, boolean enableAudio, boolean ongoing) {
        // Pending Intent
        PendingIntent pending = null;
        if (intent != null) {
            pending = PendingIntent.getActivity(
                    mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
        }

        // NOTE: the ticker is not shown for notifications in the Holo UX
        Notification.Builder builder = new Notification.Builder(mContext)
                .setContentTitle(title)
                .setContentText(contentText)
                .setContentIntent(pending)
                .setLargeIcon(largeIcon)
                .setNumber(number == null ? 0 : number)
                .setSmallIcon(R.drawable.stat_notify_email_generic)
                .setWhen(mClock.getTime())
                .setTicker(ticker)
                .setOngoing(ongoing);

        if (enableAudio) {
            setupSoundAndVibration(builder, account);
        }

        Notification notification = builder.getNotification();
        return notification;
    }

    /**
     * Generic notifier for any account.  Uses notification rules from account.
     *
     * @param account The account this notification is being built for.
     * @param ticker Text displayed when the notification is first shown. May be {@code null}.
     * @param title The first line of text. May NOT be {@code null}.
     * @param contentText The second line of text. May NOT be {@code null}.
     * @param intent The intent to start if the user clicks on the notification.
     * @param notificationId The ID of the notification to register with the service.
     */
    private void showAccountNotification(Account account, String ticker, String title,
            String contentText, Intent intent, int notificationId) {
        Notification notification = createAccountNotification(account, ticker, title, contentText,
                intent, null, null, true, needsOngoingNotification(notificationId));
        mNotificationManager.notify(notificationId, notification);
    }

    /**
     * Returns a notification ID for new message notifications for the given account.
     */
    private int getNewMessageNotificationId(long accountId) {
        // We assume accountId will always be less than 0x0FFFFFFF; is there a better way?
        return (int) (NOTIFICATION_ID_BASE_NEW_MESSAGES + accountId);
    }

    /**
     * Tells the notification controller if it should be watching for changes to the message table.
     * This is the main life cycle method for message notifications. When we stop observing
     * database changes, we save the state [e.g. message ID and count] of the most recent
     * notification shown to the user. And, when we start observing database changes, we restore
     * the saved state.
     * @param watch If {@code true}, we register observers for all accounts whose settings have
     *              notifications enabled. Otherwise, all observers are unregistered.
     */
    public void watchForMessages(final boolean watch) {
        if (Email.DEBUG) {
            Log.i(Logging.LOG_TAG, ""Notifications being toggled: "" + watch);
        }
        // Don't create the thread if we're only going to stop watching
        if (!watch && sNotificationThread == null) return;

        ensureHandlerExists();
        // Run this on the message notification handler
        sNotificationHandler.post(new Runnable() {
            @Override
            public void run() {
                ContentResolver resolver = mContext.getContentResolver();
                if (!watch) {
                    unregisterMessageNotification(Account.ACCOUNT_ID_COMBINED_VIEW);
                    if (mAccountObserver != null) {
                        resolver.unregisterContentObserver(mAccountObserver);
                        mAccountObserver = null;
                    }

                    // tear down the event loop
                    sNotificationThread.quit();
                    sNotificationThread = null;
                    return;
                }

                // otherwise, start new observers for all notified accounts
                registerMessageNotification(Account.ACCOUNT_ID_COMBINED_VIEW);
                // If we're already observing account changes, don't do anything else
                if (mAccountObserver == null) {
                    if (Email.DEBUG) {
                        Log.i(Logging.LOG_TAG, ""Observing account changes for notifications"");
                    }
                    mAccountObserver = new AccountContentObserver(sNotificationHandler, mContext);
                    resolver.registerContentObserver(Account.NOTIFIER_URI, true, mAccountObserver);
                }
            }
        });
    }

    /**
     * Temporarily suspend a single account from receiving notifications. NOTE: only a single
     * account may ever be suspended at a time. So, if this method is invoked a second time,
     * notifications for the previously suspended account will automatically be re-activated.
     * @param suspend If {@code true}, suspend notifications for the given account. Otherwise,
     *              re-activate notifications for the previously suspended account.
     * @param accountId The ID of the account. If this is the special account ID
     *              {@link Account#ACCOUNT_ID_COMBINED_VIEW},  notifications for all accounts are
     *              suspended. If {@code suspend} is {@code false}, the account ID is ignored.
     */
    public void suspendMessageNotification(boolean suspend, long accountId) {
        if (mSuspendAccountId != Account.NO_ACCOUNT) {
            // we're already suspending an account; un-suspend it
            mSuspendAccountId = Account.NO_ACCOUNT;
        }
        if (suspend && accountId != Account.NO_ACCOUNT && accountId > 0L) {
            mSuspendAccountId = accountId;
            if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                // Only go onto the notification handler if we really, absolutely need to
                ensureHandlerExists();
                sNotificationHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        for (long accountId : mNotificationMap.keySet()) {
                            mNotificationManager.cancel(getNewMessageNotificationId(accountId));
                        }
                    }
                });
            } else {
                mNotificationManager.cancel(getNewMessageNotificationId(accountId));
            }
        }
    }

    /**
     * Ensures the notification handler exists and is ready to handle requests.
     */
    private static synchronized void ensureHandlerExists() {
        if (sNotificationThread == null) {
            sNotificationThread = new NotificationThread();
            sNotificationHandler = new Handler(sNotificationThread.getLooper());
        }
    }

    /**
     * Registers an observer for changes to the INBOX for the given account. Since accounts
     * may only have a single INBOX, we will never have more than one observer for an account.
     * NOTE: This must be called on the notification handler thread.
     * @param accountId The ID of the account to register the observer for. May be
     *                  {@link Account#ACCOUNT_ID_COMBINED_VIEW} to register observers for all
     *                  accounts that allow for user notification.
     */
    private void registerMessageNotification(long accountId) {
        ContentResolver resolver = mContext.getContentResolver();
        if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
            Cursor c = resolver.query(
                    Account.CONTENT_URI, EmailContent.ID_PROJECTION,
                    NOTIFIED_ACCOUNT_SELECTION, null, null);
            try {
                while (c.moveToNext()) {
                    long id = c.getLong(EmailContent.ID_PROJECTION_COLUMN);
                    registerMessageNotification(id);
                }
            } finally {
                c.close();
            }
        } else {
            ContentObserver obs = mNotificationMap.get(accountId);
            if (obs != null) return;  // we're already observing; nothing to do

            Mailbox mailbox = Mailbox.restoreMailboxOfType(mContext, accountId, Mailbox.TYPE_INBOX);
            if (mailbox == null) {
                Log.w(Logging.LOG_TAG, ""Could not load INBOX for account id: "" + accountId);
                return;
            }
            if (Email.DEBUG) {
                Log.i(Logging.LOG_TAG, ""Registering for notifications for account "" + accountId);
            }
            ContentObserver observer = new MessageContentObserver(
                    sNotificationHandler, mContext, mailbox.mId, accountId);
            resolver.registerContentObserver(Message.NOTIFIER_URI, true, observer);
            mNotificationMap.put(accountId, observer);
            // Now, ping the observer for any initial notifications
            observer.onChange(true);
        }
    }

    /**
     * Unregisters the observer for the given account. If the specified account does not have
     * a registered observer, no action is performed. This will not clear any existing notification
     * for the specified account. Use {@link NotificationManager#cancel(int)}.
     * NOTE: This must be called on the notification handler thread.
     * @param accountId The ID of the account to unregister from. To unregister all accounts that
     *                  have observers, specify an ID of {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
     */
    private void unregisterMessageNotification(long accountId) {
        ContentResolver resolver = mContext.getContentResolver();
        if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
            if (Email.DEBUG) {
                Log.i(Logging.LOG_TAG, ""Unregistering notifications for all accounts"");
            }
            // cancel all existing message observers
            for (ContentObserver observer : mNotificationMap.values()) {
                resolver.unregisterContentObserver(observer);
            }
            mNotificationMap.clear();
        } else {
            if (Email.DEBUG) {
                Log.i(Logging.LOG_TAG, ""Unregistering notifications for account "" + accountId);
            }
            ContentObserver observer = mNotificationMap.remove(accountId);
            if (observer != null) {
                resolver.unregisterContentObserver(observer);
            }
        }
    }

    /**
     * Returns a picture of the sender of the given message. If no picture is available, returns
     * {@code null}.
     *
     * NOTE: DO NOT CALL THIS METHOD FROM THE UI THREAD (DATABASE ACCESS)
     */
    private Bitmap getSenderPhoto(Message message) {
        Address sender = Address.unpackFirst(message.mFrom);
        if (sender == null) {
            return null;
        }
        String email = sender.getAddress();
        if (TextUtils.isEmpty(email)) {
            return null;
        }
        return ContactStatusLoader.getContactInfo(mContext, email).mPhoto;
    }

    /**
     * Returns a ""new message"" notification for the given account.
     *
     * NOTE: DO NOT CALL THIS METHOD FROM THE UI THREAD (DATABASE ACCESS)
     */
    @VisibleForTesting
    Notification createNewMessageNotification(long accountId, long mailboxId, long messageId,
            int unseenMessageCount, int unreadCount) {
        final Account account = Account.restoreAccountWithId(mContext, accountId);
        if (account == null) {
            return null;
        }
        // Get the latest message
        final Message message = Message.restoreMessageWithId(mContext, messageId);
        if (message == null) {
            return null; // no message found???
        }

        String senderName = Address.toFriendly(Address.unpack(message.mFrom));
        if (senderName == null) {
            senderName = """"; // Happens when a message has no from.
        }
        final boolean multipleUnseen = unseenMessageCount > 1;
        final Bitmap senderPhoto = multipleUnseen
                ? mGenericMultipleSenderIcon
                : getSenderPhoto(message);
        final SpannableString title = getNewMessageTitle(senderName, unseenMessageCount);
        // TODO: add in display name on the second line for the text, once framework supports
        // multiline texts.
        final String text = multipleUnseen
                ? account.mDisplayName
                : message.mSubject;
        final Bitmap largeIcon = senderPhoto != null ? senderPhoto : mGenericSenderIcon;
        final Integer number = unreadCount > 1 ? unreadCount : null;
        final Intent intent;
        if (unseenMessageCount > 1) {
            intent = Welcome.createOpenAccountInboxIntent(mContext, accountId);
        } else {
            intent = Welcome.createOpenMessageIntent(mContext, accountId, mailboxId, messageId);
        }
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        long now = mClock.getTime();
        boolean enableAudio = (now - mLastMessageNotifyTime) > MIN_SOUND_INTERVAL_MS;
        Notification notification = createAccountNotification(
                account, title.toString(), title, text,
                intent, largeIcon, number, enableAudio, false);
        mLastMessageNotifyTime = now;
        return notification;
    }

    /**
     * Creates a notification title for a new message. If there is only a single message,
     * show the sender name. Otherwise, show ""X new messages"".
     */
    @VisibleForTesting
    SpannableString getNewMessageTitle(String sender, int unseenCount) {
        String title;
        if (unseenCount > 1) {
            title = String.format(
                    mContext.getString(R.string.notification_multiple_new_messages_fmt),
                    unseenCount);
        } else {
            title = sender;
        }
        return new SpannableString(title);
    }

    /** Returns the system's current ringer mode */
    @VisibleForTesting
    int getRingerMode() {
        return mAudioManager.getRingerMode();
    }

    /** Sets up the notification's sound and vibration based upon account details. */
    @VisibleForTesting
    void setupSoundAndVibration(Notification.Builder builder, Account account) {
        final int flags = account.mFlags;
        final String ringtoneUri = account.mRingtoneUri;
        final boolean vibrate = (flags & Account.FLAGS_VIBRATE_ALWAYS) != 0;
        final boolean vibrateWhenSilent = (flags & Account.FLAGS_VIBRATE_WHEN_SILENT) != 0;
        final boolean isRingerSilent = getRingerMode() != AudioManager.RINGER_MODE_NORMAL;

        int defaults = Notification.DEFAULT_LIGHTS;
        if (vibrate || (vibrateWhenSilent && isRingerSilent)) {
            defaults |= Notification.DEFAULT_VIBRATE;
        }

        builder.setSound((ringtoneUri == null) ? null : Uri.parse(ringtoneUri))
            .setDefaults(defaults);
    }

    /**
     * Show (or update) a notification that the given attachment could not be forwarded. This
     * is a very unusual case, and perhaps we shouldn't even send a notification. For now,
     * it's helpful for debugging.
     *
     * NOTE: DO NOT CALL THIS METHOD FROM THE UI THREAD (DATABASE ACCESS)
     */
    public void showDownloadForwardFailedNotification(Attachment attachment) {
        final Account account = Account.restoreAccountWithId(mContext, attachment.mAccountKey);
        if (account == null) return;
        showAccountNotification(account,
                mContext.getString(R.string.forward_download_failed_ticker),
                mContext.getString(R.string.forward_download_failed_title),
                attachment.mFileName,
                null,
                NOTIFICATION_ID_ATTACHMENT_WARNING);
    }

    /**
     * Returns a notification ID for login failed notifications for the given account account.
     */
    private int getLoginFailedNotificationId(long accountId) {
        return NOTIFICATION_ID_BASE_LOGIN_WARNING + (int)accountId;
    }

    /**
     * Show (or update) a notification that there was a login failure for the given account.
     *
     * NOTE: DO NOT CALL THIS METHOD FROM THE UI THREAD (DATABASE ACCESS)
     */
    public void showLoginFailedNotification(long accountId) {
        final Account account = Account.restoreAccountWithId(mContext, accountId);
        if (account == null) return;
        showAccountNotification(account,
                mContext.getString(R.string.login_failed_ticker, account.mDisplayName),
                mContext.getString(R.string.login_failed_title),
                account.getDisplayName(),
                AccountSettings.createAccountSettingsIntent(mContext, accountId,
                        account.mDisplayName),
                getLoginFailedNotificationId(accountId));
    }

    /**
     * Cancels the login failed notification for the given account.
     */
    public void cancelLoginFailedNotification(long accountId) {
        mNotificationManager.cancel(getLoginFailedNotificationId(accountId));
    }

    /**
     * Show (or update) a notification that the user's password is expiring. The given account
     * is used to update the display text, but, all accounts share the same notification ID.
     *
     * NOTE: DO NOT CALL THIS METHOD FROM THE UI THREAD (DATABASE ACCESS)
     */
    public void showPasswordExpiringNotification(long accountId) {
        Account account = Account.restoreAccountWithId(mContext, accountId);
        if (account == null) return;

        Intent intent = AccountSecurity.actionDevicePasswordExpirationIntent(mContext,
                accountId, false);
        String accountName = account.getDisplayName();
        String ticker =
            mContext.getString(R.string.password_expire_warning_ticker_fmt, accountName);
        String title = mContext.getString(R.string.password_expire_warning_content_title);
        showAccountNotification(account, ticker, title, accountName, intent,
                NOTIFICATION_ID_PASSWORD_EXPIRING);
    }

    /**
     * Show (or update) a notification that the user's password has expired. The given account
     * is used to update the display text, but, all accounts share the same notification ID.
     *
     * NOTE: DO NOT CALL THIS METHOD FROM THE UI THREAD (DATABASE ACCESS)
     */
    public void showPasswordExpiredNotification(long accountId) {
        Account account = Account.restoreAccountWithId(mContext, accountId);
        if (account == null) return;

        Intent intent = AccountSecurity.actionDevicePasswordExpirationIntent(mContext,
                accountId, true);
        String accountName = account.getDisplayName();
        String ticker = mContext.getString(R.string.password_expired_ticker);
        String title = mContext.getString(R.string.password_expired_content_title);
        showAccountNotification(account, ticker, title, accountName, intent,
                NOTIFICATION_ID_PASSWORD_EXPIRED);
    }

    /**
     * Cancels any password expire notifications [both expired & expiring].
     */
    public void cancelPasswordExpirationNotifications() {
        mNotificationManager.cancel(NOTIFICATION_ID_PASSWORD_EXPIRING);
        mNotificationManager.cancel(NOTIFICATION_ID_PASSWORD_EXPIRED);
    }

    /**
     * Show (or update) a security needed notification. The given account is used to update
     * the display text, but, all accounts share the same notification ID.
     */
    public void showSecurityNeededNotification(Account account) {
        Intent intent = AccountSecurity.actionUpdateSecurityIntent(mContext, account.mId, true);
        String accountName = account.getDisplayName();
        String ticker =
            mContext.getString(R.string.security_notification_ticker_fmt, accountName);
        String title = mContext.getString(R.string.security_notification_content_title);
        showAccountNotification(account, ticker, title, accountName, intent,
                NOTIFICATION_ID_SECURITY_NEEDED);
    }

    /**
     * Cancels the security needed notification.
     */
    public void cancelSecurityNeededNotification() {
        mNotificationManager.cancel(NOTIFICATION_ID_SECURITY_NEEDED);
    }

    /**
     * Observer invoked whenever a message we're notifying the user about changes.
     */
    private static class MessageContentObserver extends ContentObserver {
        /** A selection to get messages the user hasn't seen before */
        private final static String MESSAGE_SELECTION =
                MessageColumns.MAILBOX_KEY + ""=? AND ""
                + MessageColumns.ID + "">? AND ""
                + MessageColumns.FLAG_READ + ""=0 AND ""
                + Message.FLAG_LOADED_SELECTION;
        private final Context mContext;
        private final long mMailboxId;
        private final long mAccountId;

        public MessageContentObserver(
                Handler handler, Context context, long mailboxId, long accountId) {
            super(handler);
            mContext = context;
            mMailboxId = mailboxId;
            mAccountId = accountId;
        }

        @Override
        public void onChange(boolean selfChange) {
            if (mAccountId == sInstance.mSuspendAccountId
                    || sInstance.mSuspendAccountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                return;
            }

            ContentObserver observer = sInstance.mNotificationMap.get(mAccountId);
            if (observer == null) {
                // Notification for a mailbox that we aren't observing; account is probably
                // being deleted.
                Log.w(Logging.LOG_TAG, ""Received notification when observer data was null"");
                return;
            }
            Account account = Account.restoreAccountWithId(mContext, mAccountId);
            if (account == null) {
                Log.w(Logging.LOG_TAG, ""Couldn't find account for changed message notification"");
                return;
            }
            long oldMessageId = account.mNotifiedMessageId;
            int oldMessageCount = account.mNotifiedMessageCount;

            ContentResolver resolver = mContext.getContentResolver();
            Long lastSeenMessageId = Utility.getFirstRowLong(
                    mContext, ContentUris.withAppendedId(Mailbox.CONTENT_URI, mMailboxId),
                    new String[] { MailboxColumns.LAST_SEEN_MESSAGE_KEY },
                    null, null, null, 0);
            if (lastSeenMessageId == null) {
                // Mailbox got nuked. Could be that the account is in the process of being deleted
                Log.w(Logging.LOG_TAG, ""Couldn't find mailbox for changed message notification"");
                return;
            }

            Cursor c = resolver.query(
                    Message.CONTENT_URI, EmailContent.ID_PROJECTION,
                    MESSAGE_SELECTION,
                    new String[] { Long.toString(mMailboxId), Long.toString(lastSeenMessageId) },
                    MessageColumns.ID + "" DESC"");
            if (c == null) {
                // Couldn't find message info - things may be getting deleted in bulk.
                Log.w(Logging.LOG_TAG, ""#onChange(); NULL response for message id query"");
                return;
            }
            try {
                int newMessageCount = c.getCount();
                long newMessageId = 0L;
                if (c.moveToNext()) {
                    newMessageId = c.getLong(EmailContent.ID_PROJECTION_COLUMN);
                }

                if (newMessageCount == 0) {
                    // No messages to notify for; clear the notification
                    int notificationId = sInstance.getNewMessageNotificationId(mAccountId);
                    sInstance.mNotificationManager.cancel(notificationId);
                } else if (newMessageCount != oldMessageCount
                        || (newMessageId != 0 && newMessageId != oldMessageId)) {
                    // Either the count or last message has changed; update the notification
                    Integer unreadCount = Utility.getFirstRowInt(
                            mContext, ContentUris.withAppendedId(Mailbox.CONTENT_URI, mMailboxId),
                            new String[] { MailboxColumns.UNREAD_COUNT },
                            null, null, null, 0);
                    if (unreadCount == null) {
                        Log.w(Logging.LOG_TAG, ""Couldn't find unread count for mailbox"");
                        return;
                    }

                    Notification n = sInstance.createNewMessageNotification(
                            mAccountId, mMailboxId, newMessageId,
                            newMessageCount, unreadCount);
                    if (n != null) {
                        // Make the notification visible
                        sInstance.mNotificationManager.notify(
                                sInstance.getNewMessageNotificationId(mAccountId), n);
                    }
                }
                // Save away the new values
                ContentValues cv = new ContentValues();
                cv.put(AccountColumns.NOTIFIED_MESSAGE_ID, newMessageId);
                cv.put(AccountColumns.NOTIFIED_MESSAGE_COUNT, newMessageCount);
                resolver.update(ContentUris.withAppendedId(Account.CONTENT_URI, mAccountId), cv,
                        null, null);
            } finally {
                c.close();
            }
        }
    }

    /**
     * Observer invoked whenever an account is modified. This could mean the user changed the
     * notification settings.
     */
    private static class AccountContentObserver extends ContentObserver {
        private final Context mContext;
        public AccountContentObserver(Handler handler, Context context) {
            super(handler);
            mContext = context;
        }

        @Override
        public void onChange(boolean selfChange) {
            final ContentResolver resolver = mContext.getContentResolver();
            final Cursor c = resolver.query(
                Account.CONTENT_URI, EmailContent.ID_PROJECTION,
                NOTIFIED_ACCOUNT_SELECTION, null, null);
            final HashSet<Long> newAccountList = new HashSet<Long>();
            final HashSet<Long> removedAccountList = new HashSet<Long>();
            if (c == null) {
                // Suspender time ... theoretically, this will never happen
                Log.wtf(Logging.LOG_TAG, ""#onChange(); NULL response for account id query"");
                return;
            }
            try {
                while (c.moveToNext()) {
                    long accountId = c.getLong(EmailContent.ID_PROJECTION_COLUMN);
                    newAccountList.add(accountId);
                }
            } finally {
                if (c != null) {
                    c.close();
                }
            }
            // NOTE: Looping over three lists is not necessarily the most efficient. However, the
            // account lists are going to be very small, so, this will not be necessarily bad.
            // Cycle through existing notification list and adjust as necessary
            for (long accountId : sInstance.mNotificationMap.keySet()) {
                if (!newAccountList.remove(accountId)) {
                    // account id not in the current set of notifiable accounts
                    removedAccountList.add(accountId);
                }
            }
            // A new account was added to the notification list
            for (long accountId : newAccountList) {
                sInstance.registerMessageNotification(accountId);
            }
            // An account was removed from the notification list
            for (long accountId : removedAccountList) {
                sInstance.unregisterMessageNotification(accountId);
                int notificationId = sInstance.getNewMessageNotificationId(accountId);
                sInstance.mNotificationManager.cancel(notificationId);
            }
        }
    }

    /**
     * Thread to handle all notification actions through its own {@link Looper}.
     */
    private static class NotificationThread implements Runnable {
        /** Lock to ensure proper initialization */
        private final Object mLock = new Object();
        /** The {@link Looper} that handles messages for this thread */
        private Looper mLooper;

        NotificationThread() {
            new Thread(null, this, ""EmailNotification"").start();
            synchronized (mLock) {
                while (mLooper == null) {
                    try {
                        mLock.wait();
                    } catch (InterruptedException ex) {
                    }
                }
            }
        }

        @Override
        public void run() {
            synchronized (mLock) {
                Looper.prepare();
                mLooper = Looper.myLooper();
                mLock.notifyAll();
            }
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            Looper.loop();
        }
        void quit() {
            mLooper.quit();
        }
        Looper getLooper() {
            return mLooper;
        }
    }
}
",True,269,1,2,11,62,7,12,L6
4,com.android.email.Controller.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.app.Service;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.util.Log;

import com.android.email.mail.store.Pop3Store.Pop3Message;
import com.android.email.provider.AccountBackupRestore;
import com.android.email.service.EmailServiceUtils;
import com.android.email.service.MailService;
import com.android.emailcommon.Api;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.Folder.MessageRetrievalListener;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.Body;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.EmailServiceStatus;
import com.android.emailcommon.service.IEmailService;
import com.android.emailcommon.service.IEmailServiceCallback;
import com.android.emailcommon.service.SearchParams;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.concurrent.ConcurrentHashMap;

/**
 * New central controller/dispatcher for Email activities that may require remote operations.
 * Handles disambiguating between legacy MessagingController operations and newer provider/sync
 * based code.  We implement Service to allow loadAttachment calls to be sent in a consistent manner
 * to IMAP, POP3, and EAS by AttachmentDownloadService
 */
public class Controller {
    private static final String TAG = ""Controller"";
    private static Controller sInstance;
    private final Context mContext;
    private Context mProviderContext;
    private final MessagingController mLegacyController;
    private final LegacyListener mLegacyListener = new LegacyListener();
    private final ServiceCallback mServiceCallback = new ServiceCallback();
    private final HashSet<Result> mListeners = new HashSet<Result>();
    /*package*/ final ConcurrentHashMap<Long, Boolean> mLegacyControllerMap =
        new ConcurrentHashMap<Long, Boolean>();

    // Note that 0 is a syntactically valid account key; however there can never be an account
    // with id = 0, so attempts to restore the account will return null.  Null values are
    // handled properly within the code, so this won't cause any issues.
    private static final long GLOBAL_MAILBOX_ACCOUNT_KEY = 0;
    /*package*/ static final String ATTACHMENT_MAILBOX_SERVER_ID = ""__attachment_mailbox__"";
    /*package*/ static final String ATTACHMENT_MESSAGE_UID_PREFIX = ""__attachment_message__"";
    /*package*/ static final String SEARCH_MAILBOX_SERVER_ID = ""__search_mailbox__"";
    private static final String WHERE_TYPE_ATTACHMENT =
        MailboxColumns.TYPE + ""="" + Mailbox.TYPE_ATTACHMENT;
    private static final String WHERE_MAILBOX_KEY = MessageColumns.MAILBOX_KEY + ""=?"";

    private static final String[] MESSAGEID_TO_ACCOUNTID_PROJECTION = new String[] {
        EmailContent.RECORD_ID,
        EmailContent.MessageColumns.ACCOUNT_KEY
    };
    private static final int MESSAGEID_TO_ACCOUNTID_COLUMN_ACCOUNTID = 1;

    private static final String[] BODY_SOURCE_KEY_PROJECTION =
        new String[] {Body.SOURCE_MESSAGE_KEY};
    private static final int BODY_SOURCE_KEY_COLUMN = 0;
    private static final String WHERE_MESSAGE_KEY = Body.MESSAGE_KEY + ""=?"";

    private static final String MAILBOXES_FOR_ACCOUNT_SELECTION = MailboxColumns.ACCOUNT_KEY + ""=?"";
    private static final String MAILBOXES_FOR_ACCOUNT_EXCEPT_ACCOUNT_MAILBOX_SELECTION =
        MAILBOXES_FOR_ACCOUNT_SELECTION + "" AND "" + MailboxColumns.TYPE + ""!="" +
        Mailbox.TYPE_EAS_ACCOUNT_MAILBOX;
    private static final String MESSAGES_FOR_ACCOUNT_SELECTION = MessageColumns.ACCOUNT_KEY + ""=?"";

    // Service callbacks as set up via setCallback
    private static RemoteCallbackList<IEmailServiceCallback> sCallbackList =
        new RemoteCallbackList<IEmailServiceCallback>();

    private volatile boolean mInUnitTests = false;

    protected Controller(Context _context) {
        mContext = _context.getApplicationContext();
        mProviderContext = _context;
        mLegacyController = MessagingController.getInstance(mProviderContext, this);
        mLegacyController.addListener(mLegacyListener);
    }

    /**
     * Mark this controller as being in use in a unit test.
     * This is a kludge vs having proper mocks and dependency injection; since the Controller is a
     * global singleton there isn't much else we can do.
     */
    public void markForTest(boolean inUnitTests) {
        mInUnitTests = inUnitTests;
    }

    /**
     * Cleanup for test.  Mustn't be called for the regular {@link Controller}, as it's a
     * singleton and lives till the process finishes.
     *
     * <p>However, this method MUST be called for mock instances.
     */
    public void cleanupForTest() {
        mLegacyController.removeListener(mLegacyListener);
    }

    /**
     * Gets or creates the singleton instance of Controller.
     */
    public synchronized static Controller getInstance(Context _context) {
        if (sInstance == null) {
            sInstance = new Controller(_context);
        }
        return sInstance;
    }

    /**
     * Inject a mock controller.  Used only for testing.  Affects future calls to getInstance().
     *
     * Tests that use this method MUST clean it up by calling this method again with null.
     */
    public synchronized static void injectMockControllerForTest(Controller mockController) {
        sInstance = mockController;
    }

    /**
     * For testing only:  Inject a different context for provider access.  This will be
     * used internally for access the underlying provider (e.g. getContentResolver().query()).
     * @param providerContext the provider context to be used by this instance
     */
    public void setProviderContext(Context providerContext) {
        mProviderContext = providerContext;
    }

    /**
     * Any UI code that wishes for callback results (on async ops) should register their callback
     * here (typically from onResume()).  Unregistered callbacks will never be called, to prevent
     * problems when the command completes and the activity has already paused or finished.
     * @param listener The callback that may be used in action methods
     */
    public void addResultCallback(Result listener) {
        synchronized (mListeners) {
            listener.setRegistered(true);
            mListeners.add(listener);
        }
    }

    /**
     * Any UI code that no longer wishes for callback results (on async ops) should unregister
     * their callback here (typically from onPause()).  Unregistered callbacks will never be called,
     * to prevent problems when the command completes and the activity has already paused or
     * finished.
     * @param listener The callback that may no longer be used
     */
    public void removeResultCallback(Result listener) {
        synchronized (mListeners) {
            listener.setRegistered(false);
            mListeners.remove(listener);
        }
    }

    public Collection<Result> getResultCallbacksForTest() {
        return mListeners;
    }

    /**
     * Delete all Messages that live in the attachment mailbox
     */
    public void deleteAttachmentMessages() {
        // Note: There should only be one attachment mailbox at present
        ContentResolver resolver = mProviderContext.getContentResolver();
        Cursor c = null;
        try {
            c = resolver.query(Mailbox.CONTENT_URI, EmailContent.ID_PROJECTION,
                    WHERE_TYPE_ATTACHMENT, null, null);
            while (c.moveToNext()) {
                long mailboxId = c.getLong(EmailContent.ID_PROJECTION_COLUMN);
                // Must delete attachments BEFORE messages
                AttachmentUtilities.deleteAllMailboxAttachmentFiles(mProviderContext, 0,
                        mailboxId);
                resolver.delete(Message.CONTENT_URI, WHERE_MAILBOX_KEY,
                        new String[] {Long.toString(mailboxId)});
           }
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }

    /**
     * Get a mailbox based on a sqlite WHERE clause
     */
    private Mailbox getGlobalMailboxWhere(String where) {
        Cursor c = mProviderContext.getContentResolver().query(Mailbox.CONTENT_URI,
                Mailbox.CONTENT_PROJECTION, where, null, null);
        try {
            if (c.moveToFirst()) {
                Mailbox m = new Mailbox();
                m.restore(c);
                return m;
            }
        } finally {
            c.close();
        }
        return null;
    }

    /**
     * Returns the attachment mailbox (where we store eml attachment Emails), creating one
     * if necessary
     * @return the global attachment mailbox
     */
    public Mailbox getAttachmentMailbox() {
        Mailbox m = getGlobalMailboxWhere(WHERE_TYPE_ATTACHMENT);
        if (m == null) {
            m = new Mailbox();
            m.mAccountKey = GLOBAL_MAILBOX_ACCOUNT_KEY;
            m.mServerId = ATTACHMENT_MAILBOX_SERVER_ID;
            m.mFlagVisible = false;
            m.mDisplayName = ATTACHMENT_MAILBOX_SERVER_ID;
            m.mSyncInterval = Mailbox.CHECK_INTERVAL_NEVER;
            m.mType = Mailbox.TYPE_ATTACHMENT;
            m.save(mProviderContext);
        }
        return m;
    }

    /**
     * Returns the search mailbox for the specified account, creating one if necessary
     * @return the search mailbox for the passed in account
     */
    public Mailbox getSearchMailbox(long accountId) {
        Mailbox m = Mailbox.restoreMailboxOfType(mContext, accountId, Mailbox.TYPE_SEARCH);
        if (m == null) {
            m = new Mailbox();
            m.mAccountKey = accountId;
            m.mServerId = SEARCH_MAILBOX_SERVER_ID;
            m.mFlagVisible = false;
            m.mDisplayName = SEARCH_MAILBOX_SERVER_ID;
            m.mSyncInterval = Mailbox.CHECK_INTERVAL_NEVER;
            m.mType = Mailbox.TYPE_SEARCH;
            m.mFlags = Mailbox.FLAG_HOLDS_MAIL;
            m.mParentKey = Mailbox.NO_MAILBOX;
            m.save(mProviderContext);
        }
        return m;
    }

    /**
     * Create a Message from the Uri and store it in the attachment mailbox
     * @param uri the uri containing message content
     * @return the Message or null
     */
    public Message loadMessageFromUri(Uri uri) {
        Mailbox mailbox = getAttachmentMailbox();
        if (mailbox == null) return null;
        try {
            InputStream is = mProviderContext.getContentResolver().openInputStream(uri);
            try {
                // First, create a Pop3Message from the attachment and then parse it
                Pop3Message pop3Message = new Pop3Message(
                        ATTACHMENT_MESSAGE_UID_PREFIX + System.currentTimeMillis(), null);
                pop3Message.parse(is);
                // Now, pull out the header fields
                Message msg = new Message();
                LegacyConversions.updateMessageFields(msg, pop3Message, 0, mailbox.mId);
                // Commit the message to the local store
                msg.save(mProviderContext);
                // Setup the rest of the message and mark it completely loaded
                mLegacyController.copyOneMessageToProvider(pop3Message, msg,
                        Message.FLAG_LOADED_COMPLETE, mProviderContext);
                // Restore the complete message and return it
                return Message.restoreMessageWithId(mProviderContext, msg.mId);
            } catch (MessagingException e) {
            } catch (IOException e) {
            }
        } catch (FileNotFoundException e) {
        }
        return null;
    }

    /**
     * Set logging flags for external sync services
     *
     * Generally this should be called by anybody who changes Email.DEBUG
     */
    public void serviceLogging(int debugFlags) {
        IEmailService service = EmailServiceUtils.getExchangeService(mContext, mServiceCallback);
        try {
            service.setLogging(debugFlags);
        } catch (RemoteException e) {
            // TODO Change exception handling to be consistent with however this method
            // is implemented for other protocols
            Log.d(""setLogging"", ""RemoteException"" + e);
        }
    }

    /**
     * Request a remote update of mailboxes for an account.
     */
    public void updateMailboxList(final long accountId) {
        Utility.runAsync(new Runnable() {
            @Override
            public void run() {
                final IEmailService service = getServiceForAccount(accountId);
                if (service != null) {
                    // Service implementation
                    try {
                        service.updateFolderList(accountId);
                    } catch (RemoteException e) {
                        // TODO Change exception handling to be consistent with however this method
                        // is implemented for other protocols
                        Log.d(""updateMailboxList"", ""RemoteException"" + e);
                    }
                } else {
                    // MessagingController implementation
                    mLegacyController.listFolders(accountId, mLegacyListener);
                }
            }
        });
    }

    /**
     * Request a remote update of a mailbox.  For use by the timed service.
     *
     * Functionally this is quite similar to updateMailbox(), but it's a separate API and
     * separate callback in order to keep UI callbacks from affecting the service loop.
     */
    public void serviceCheckMail(final long accountId, final long mailboxId, final long tag) {
        IEmailService service = getServiceForAccount(accountId);
        if (service != null) {
            // Service implementation
//            try {
                // TODO this isn't quite going to work, because we're going to get the
                // generic (UI) callbacks and not the ones we need to restart the ol' service.
                // service.startSync(mailboxId, tag);
            mLegacyListener.checkMailFinished(mContext, accountId, mailboxId, tag);
//            } catch (RemoteException e) {
                // TODO Change exception handling to be consistent with however this method
                // is implemented for other protocols
//                Log.d(""updateMailbox"", ""RemoteException"" + e);
//            }
        } else {
            // MessagingController implementation
            Utility.runAsync(new Runnable() {
                public void run() {
                    mLegacyController.checkMail(accountId, tag, mLegacyListener);
                }
            });
        }
    }

    /**
     * Request a remote update of a mailbox.
     *
     * The contract here should be to try and update the headers ASAP, in order to populate
     * a simple message list.  We should also at this point queue up a background task of
     * downloading some/all of the messages in this mailbox, but that should be interruptable.
     */
    public void updateMailbox(final long accountId, final long mailboxId, boolean userRequest) {

        IEmailService service = getServiceForAccount(accountId);
        if (service != null) {
           try {
                service.startSync(mailboxId, userRequest);
            } catch (RemoteException e) {
                // TODO Change exception handling to be consistent with however this method
                // is implemented for other protocols
                Log.d(""updateMailbox"", ""RemoteException"" + e);
            }
        } else {
            // MessagingController implementation
            Utility.runAsync(new Runnable() {
                public void run() {
                    // TODO shouldn't be passing fully-build accounts & mailboxes into APIs
                    Account account =
                        Account.restoreAccountWithId(mProviderContext, accountId);
                    Mailbox mailbox =
                        Mailbox.restoreMailboxWithId(mProviderContext, mailboxId);
                    if (account == null || mailbox == null ||
                            mailbox.mType == Mailbox.TYPE_SEARCH) {
                        return;
                    }
                    mLegacyController.synchronizeMailbox(account, mailbox, mLegacyListener);
                }
            });
        }
    }

    /**
     * Request that any final work necessary be done, to load a message.
     *
     * Note, this assumes that the caller has already checked message.mFlagLoaded and that
     * additional work is needed.  There is no optimization here for a message which is already
     * loaded.
     *
     * @param messageId the message to load
     * @param callback the Controller callback by which results will be reported
     */
    public void loadMessageForView(final long messageId) {

        // Split here for target type (Service or MessagingController)
        IEmailService service = getServiceForMessage(messageId);
        if (service != null) {
            // There is no service implementation, so we'll just jam the value, log the error,
            // and get out of here.
            Uri uri = ContentUris.withAppendedId(Message.CONTENT_URI, messageId);
            ContentValues cv = new ContentValues();
            cv.put(MessageColumns.FLAG_LOADED, Message.FLAG_LOADED_COMPLETE);
            mProviderContext.getContentResolver().update(uri, cv, null, null);
            Log.d(Logging.LOG_TAG, ""Unexpected loadMessageForView() for service-based message."");
            final long accountId = Account.getAccountIdForMessageId(mProviderContext, messageId);
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadMessageForViewCallback(null, accountId, messageId, 100);
                }
            }
        } else {
            // MessagingController implementation
            Utility.runAsync(new Runnable() {
                public void run() {
                    mLegacyController.loadMessageForView(messageId, mLegacyListener);
                }
            });
        }
    }


    /**
     * Saves the message to a mailbox of given type.
     * This is a synchronous operation taking place in the same thread as the caller.
     * Upon return the message.mId is set.
     * @param message the message (must have the mAccountId set).
     * @param mailboxType the mailbox type (e.g. Mailbox.TYPE_DRAFTS).
     */
    public void saveToMailbox(final EmailContent.Message message, final int mailboxType) {
        long accountId = message.mAccountKey;
        long mailboxId = findOrCreateMailboxOfType(accountId, mailboxType);
        message.mMailboxKey = mailboxId;
        message.save(mProviderContext);
    }

    /**
     * Look for a specific system mailbox, creating it if necessary, and return the mailbox id.
     * This is a blocking operation and should not be called from the UI thread.
     *
     * Synchronized so multiple threads can call it (and not risk creating duplicate boxes).
     *
     * @param accountId the account id
     * @param mailboxType the mailbox type (e.g.  EmailContent.Mailbox.TYPE_TRASH)
     * @return the id of the mailbox. The mailbox is created if not existing.
     * Returns Mailbox.NO_MAILBOX if the accountId or mailboxType are negative.
     * Does not validate the input in other ways (e.g. does not verify the existence of account).
     */
    public synchronized long findOrCreateMailboxOfType(long accountId, int mailboxType) {
        if (accountId < 0 || mailboxType < 0) {
            return Mailbox.NO_MAILBOX;
        }
        long mailboxId =
            Mailbox.findMailboxOfType(mProviderContext, accountId, mailboxType);
        return mailboxId == Mailbox.NO_MAILBOX ? createMailbox(accountId, mailboxType) : mailboxId;
    }

    /**
     * Returns the server-side name for a specific mailbox.
     *
     * @return the resource string corresponding to the mailbox type, empty if not found.
     */
    public static String getMailboxServerName(Context context, int mailboxType) {
        int resId = -1;
        switch (mailboxType) {
            case Mailbox.TYPE_INBOX:
                resId = R.string.mailbox_name_server_inbox;
                break;
            case Mailbox.TYPE_OUTBOX:
                resId = R.string.mailbox_name_server_outbox;
                break;
            case Mailbox.TYPE_DRAFTS:
                resId = R.string.mailbox_name_server_drafts;
                break;
            case Mailbox.TYPE_TRASH:
                resId = R.string.mailbox_name_server_trash;
                break;
            case Mailbox.TYPE_SENT:
                resId = R.string.mailbox_name_server_sent;
                break;
            case Mailbox.TYPE_JUNK:
                resId = R.string.mailbox_name_server_junk;
                break;
        }
        return resId != -1 ? context.getString(resId) : """";
    }

    /**
     * Create a mailbox given the account and mailboxType.
     * TODO: Does this need to be signaled explicitly to the sync engines?
     */
    @VisibleForTesting
    long createMailbox(long accountId, int mailboxType) {
        if (accountId < 0 || mailboxType < 0) {
            String mes = ""Invalid arguments "" + accountId + ' ' + mailboxType;
            Log.e(Logging.LOG_TAG, mes);
            throw new RuntimeException(mes);
        }
        Mailbox box = Mailbox.newSystemMailbox(
                accountId, mailboxType, getMailboxServerName(mContext, mailboxType));
        box.save(mProviderContext);
        return box.mId;
    }

    /**
     * Send a message:
     * - move the message to Outbox (the message is assumed to be in Drafts).
     * - EAS service will take it from there
     * - mark reply/forward state in source message (if any)
     * - trigger send for POP/IMAP
     * @param message the fully populated Message (usually retrieved from the Draft box). Note that
     *     all transient fields (e.g. Body related fields) are also expected to be fully loaded
     */
    public void sendMessage(Message message) {
        ContentResolver resolver = mProviderContext.getContentResolver();
        long accountId = message.mAccountKey;
        long messageId = message.mId;
        if (accountId == Account.NO_ACCOUNT) {
            accountId = lookupAccountForMessage(messageId);
        }
        if (accountId == Account.NO_ACCOUNT) {
            // probably the message was not found
            if (Logging.LOGD) {
                Email.log(""no account found for message "" + messageId);
            }
            return;
        }

        // Move to Outbox
        long outboxId = findOrCreateMailboxOfType(accountId, Mailbox.TYPE_OUTBOX);
        ContentValues cv = new ContentValues();
        cv.put(EmailContent.MessageColumns.MAILBOX_KEY, outboxId);

        // does this need to be SYNCED_CONTENT_URI instead?
        Uri uri = ContentUris.withAppendedId(Message.CONTENT_URI, messageId);
        resolver.update(uri, cv, null, null);

        // If this is a reply/forward, indicate it as such on the source.
        long sourceKey = message.mSourceKey;
        if (sourceKey != Message.NO_MESSAGE) {
            boolean isReply = (message.mFlags & Message.FLAG_TYPE_REPLY) != 0;
            int flagUpdate = isReply ? Message.FLAG_REPLIED_TO : Message.FLAG_FORWARDED;
            setMessageAnsweredOrForwarded(sourceKey, flagUpdate);
        }

        sendPendingMessages(accountId);
    }

    private void sendPendingMessagesSmtp(long accountId) {
        // for IMAP & POP only, (attempt to) send the message now
        final Account account =
                Account.restoreAccountWithId(mProviderContext, accountId);
        if (account == null) {
            return;
        }
        final long sentboxId = findOrCreateMailboxOfType(accountId, Mailbox.TYPE_SENT);
        Utility.runAsync(new Runnable() {
            public void run() {
                mLegacyController.sendPendingMessages(account, sentboxId, mLegacyListener);
            }
        });
    }

    /**
     * Try to send all pending messages for a given account
     *
     * @param accountId the account for which to send messages
     */
    public void sendPendingMessages(long accountId) {
        // 1. make sure we even have an outbox, exit early if not
        final long outboxId =
            Mailbox.findMailboxOfType(mProviderContext, accountId, Mailbox.TYPE_OUTBOX);
        if (outboxId == Mailbox.NO_MAILBOX) {
            return;
        }

        // 2. dispatch as necessary
        IEmailService service = getServiceForAccount(accountId);
        if (service != null) {
            // Service implementation
            try {
                service.startSync(outboxId, false);
            } catch (RemoteException e) {
                // TODO Change exception handling to be consistent with however this method
                // is implemented for other protocols
                Log.d(""updateMailbox"", ""RemoteException"" + e);
            }
        } else {
            // MessagingController implementation
            sendPendingMessagesSmtp(accountId);
        }
    }

    /**
     * Reset visible limits for all accounts.
     * For each account:
     *   look up limit
     *   write limit into all mailboxes for that account
     */
    public void resetVisibleLimits() {
        Utility.runAsync(new Runnable() {
            public void run() {
                ContentResolver resolver = mProviderContext.getContentResolver();
                Cursor c = null;
                try {
                    c = resolver.query(
                            Account.CONTENT_URI,
                            Account.ID_PROJECTION,
                            null, null, null);
                    while (c.moveToNext()) {
                        long accountId = c.getLong(Account.ID_PROJECTION_COLUMN);
                        String protocol = Account.getProtocol(mProviderContext, accountId);
                        if (!HostAuth.SCHEME_EAS.equals(protocol)) {
                            ContentValues cv = new ContentValues();
                            cv.put(MailboxColumns.VISIBLE_LIMIT, Email.VISIBLE_LIMIT_DEFAULT);
                            resolver.update(Mailbox.CONTENT_URI, cv,
                                    MailboxColumns.ACCOUNT_KEY + ""=?"",
                                    new String[] { Long.toString(accountId) });
                        }
                    }
                } finally {
                    if (c != null) {
                        c.close();
                    }
                }
            }
        });
    }

    /**
     * Increase the load count for a given mailbox, and trigger a refresh.  Applies only to
     * IMAP and POP mailboxes, with the exception of the EAS search mailbox.
     *
     * @param mailboxId the mailbox
     */
    public void loadMoreMessages(final long mailboxId) {
        EmailAsyncTask.runAsyncParallel(new Runnable() {
            public void run() {
                Mailbox mailbox = Mailbox.restoreMailboxWithId(mProviderContext, mailboxId);
                if (mailbox == null) {
                    return;
                }
                if (mailbox.mType == Mailbox.TYPE_SEARCH) {
                    try {
                        searchMore(mailbox.mAccountKey);
                    } catch (MessagingException e) {
                        // Nothing to be done
                    }
                    return;
                }
                Account account = Account.restoreAccountWithId(mProviderContext,
                        mailbox.mAccountKey);
                if (account == null) {
                    return;
                }
                // Use provider math to increment the field
                ContentValues cv = new ContentValues();;
                cv.put(EmailContent.FIELD_COLUMN_NAME, MailboxColumns.VISIBLE_LIMIT);
                cv.put(EmailContent.ADD_COLUMN_NAME, Email.VISIBLE_LIMIT_INCREMENT);
                Uri uri = ContentUris.withAppendedId(Mailbox.ADD_TO_FIELD_URI, mailboxId);
                mProviderContext.getContentResolver().update(uri, cv, null, null);
                // Trigger a refresh using the new, longer limit
                mailbox.mVisibleLimit += Email.VISIBLE_LIMIT_INCREMENT;
                mLegacyController.synchronizeMailbox(account, mailbox, mLegacyListener);
            }
        });
    }

    /**
     * @param messageId the id of message
     * @return the accountId corresponding to the given messageId, or -1 if not found.
     */
    private long lookupAccountForMessage(long messageId) {
        ContentResolver resolver = mProviderContext.getContentResolver();
        Cursor c = resolver.query(EmailContent.Message.CONTENT_URI,
                                  MESSAGEID_TO_ACCOUNTID_PROJECTION, EmailContent.RECORD_ID + ""=?"",
                                  new String[] { Long.toString(messageId) }, null);
        try {
            return c.moveToFirst()
                ? c.getLong(MESSAGEID_TO_ACCOUNTID_COLUMN_ACCOUNTID)
                : -1;
        } finally {
            c.close();
        }
    }

    /**
     * Delete a single attachment entry from the DB given its id.
     * Does not delete any eventual associated files.
     */
    public void deleteAttachment(long attachmentId) {
        ContentResolver resolver = mProviderContext.getContentResolver();
        Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);
        resolver.delete(uri, null, null);
    }

    /**
     * Async version of {@link #deleteMessageSync}.
     */
    public void deleteMessage(final long messageId) {
        EmailAsyncTask.runAsyncParallel(new Runnable() {
            public void run() {
                deleteMessageSync(messageId);
            }
        });
    }

    /**
     * Batch & async version of {@link #deleteMessageSync}.
     */
    public void deleteMessages(final long[] messageIds) {
        if (messageIds == null || messageIds.length == 0) {
            throw new IllegalArgumentException();
        }
        EmailAsyncTask.runAsyncParallel(new Runnable() {
            public void run() {
                for (long messageId: messageIds) {
                    deleteMessageSync(messageId);
                }
            }
        });
    }

    /**
     * Delete a single message by moving it to the trash, or really delete it if it's already in
     * trash or a draft message.
     *
     * This function has no callback, no result reporting, because the desired outcome
     * is reflected entirely by changes to one or more cursors.
     *
     * @param messageId The id of the message to ""delete"".
     */
    /* package */ void deleteMessageSync(long messageId) {
        // 1. Get the message's account
        Account account = Account.getAccountForMessageId(mProviderContext, messageId);

        if (account == null) return;

        // 2. Confirm that there is a trash mailbox available.  If not, create one
        long trashMailboxId = findOrCreateMailboxOfType(account.mId, Mailbox.TYPE_TRASH);

        // 3. Get the message's original mailbox
        Mailbox mailbox = Mailbox.getMailboxForMessageId(mProviderContext, messageId);

        if (mailbox == null) return;

        // 4.  Drop non-essential data for the message (e.g. attachment files)
        AttachmentUtilities.deleteAllAttachmentFiles(mProviderContext, account.mId,
                messageId);

        Uri uri = ContentUris.withAppendedId(EmailContent.Message.SYNCED_CONTENT_URI,
                messageId);
        ContentResolver resolver = mProviderContext.getContentResolver();

        // 5. Perform ""delete"" as appropriate
        if ((mailbox.mId == trashMailboxId) || (mailbox.mType == Mailbox.TYPE_DRAFTS)) {
            // 5a. Really delete it
            resolver.delete(uri, null, null);
        } else {
            // 5b. Move to trash
            ContentValues cv = new ContentValues();
            cv.put(EmailContent.MessageColumns.MAILBOX_KEY, trashMailboxId);
            resolver.update(uri, cv, null, null);
        }

        if (isMessagingController(account)) {
            mLegacyController.processPendingActions(account.mId);
        }
    }

    /**
     * Moves messages to a new mailbox.
     *
     * This function has no callback, no result reporting, because the desired outcome
     * is reflected entirely by changes to one or more cursors.
     *
     * Note this method assumes all of the given message and mailbox IDs belong to the same
     * account.
     *
     * @param messageIds IDs of the messages that are to be moved
     * @param newMailboxId ID of the new mailbox that the messages will be moved to
     * @return an asynchronous task that executes the move (for testing only)
     */
    public EmailAsyncTask<Void, Void, Void> moveMessages(final long[] messageIds,
            final long newMailboxId) {
        if (messageIds == null || messageIds.length == 0) {
            throw new IllegalArgumentException();
        }
        return EmailAsyncTask.runAsyncParallel(new Runnable() {
            public void run() {
                Account account = Account.getAccountForMessageId(mProviderContext, messageIds[0]);
                if (account != null) {
                    ContentValues cv = new ContentValues();
                    cv.put(EmailContent.MessageColumns.MAILBOX_KEY, newMailboxId);
                    ContentResolver resolver = mProviderContext.getContentResolver();
                    for (long messageId : messageIds) {
                        Uri uri = ContentUris.withAppendedId(
                                EmailContent.Message.SYNCED_CONTENT_URI, messageId);
                        resolver.update(uri, cv, null, null);
                    }
                    if (isMessagingController(account)) {
                        mLegacyController.processPendingActions(account.mId);
                    }
                }
            }
        });
    }

    /**
     * Set/clear the unread status of a message
     *
     * @param messageId the message to update
     * @param isRead the new value for the isRead flag
     */
    public void setMessageReadSync(long messageId, boolean isRead) {
        setMessageBooleanSync(messageId, EmailContent.MessageColumns.FLAG_READ, isRead);
    }

    /**
     * Set/clear the unread status of a message from UI thread
     *
     * @param messageId the message to update
     * @param isRead the new value for the isRead flag
     * @return the EmailAsyncTask created
     */
    public EmailAsyncTask<Void, Void, Void> setMessageRead(final long messageId,
            final boolean isRead) {
        return EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
            public void run() {
                setMessageBooleanSync(messageId, EmailContent.MessageColumns.FLAG_READ, isRead);
            }});
    }

    /**
     * Update a message record and ping MessagingController, if necessary
     *
     * @param messageId the message to update
     * @param cv the ContentValues used in the update
     */
    private void updateMessageSync(long messageId, ContentValues cv) {
        Uri uri = ContentUris.withAppendedId(EmailContent.Message.SYNCED_CONTENT_URI, messageId);
        mProviderContext.getContentResolver().update(uri, cv, null, null);

        // Service runs automatically, MessagingController needs a kick
        long accountId = Account.getAccountIdForMessageId(mProviderContext, messageId);
        if (accountId == Account.NO_ACCOUNT) return;
        if (isMessagingController(accountId)) {
            mLegacyController.processPendingActions(accountId);
        }
    }

    /**
     * Set the answered status of a message
     *
     * @param messageId the message to update
     * @return the AsyncTask that will execute the changes (for testing only)
     */
    public void setMessageAnsweredOrForwarded(final long messageId,
            final int flag) {
        EmailAsyncTask.runAsyncParallel(new Runnable() {
            public void run() {
                Message msg = Message.restoreMessageWithId(mProviderContext, messageId);
                if (msg == null) {
                    Log.w(Logging.LOG_TAG, ""Unable to find source message for a reply/forward"");
                    return;
                }
                ContentValues cv = new ContentValues();
                cv.put(MessageColumns.FLAGS, msg.mFlags | flag);
                updateMessageSync(messageId, cv);
            }
        });
    }

    /**
     * Set/clear the favorite status of a message from UI thread
     *
     * @param messageId the message to update
     * @param isFavorite the new value for the isFavorite flag
     * @return the EmailAsyncTask created
     */
    public EmailAsyncTask<Void, Void, Void> setMessageFavorite(final long messageId,
            final boolean isFavorite) {
        return EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
            public void run() {
                setMessageBooleanSync(messageId, EmailContent.MessageColumns.FLAG_FAVORITE,
                        isFavorite);
            }});
    }
    /**
     * Set/clear the favorite status of a message
     *
     * @param messageId the message to update
     * @param isFavorite the new value for the isFavorite flag
     */
    public void setMessageFavoriteSync(long messageId, boolean isFavorite) {
        setMessageBooleanSync(messageId, EmailContent.MessageColumns.FLAG_FAVORITE, isFavorite);
    }

    /**
     * Set/clear boolean columns of a message
     *
     * @param messageId the message to update
     * @param columnName the column to update
     * @param columnValue the new value for the column
     */
    private void setMessageBooleanSync(long messageId, String columnName, boolean columnValue) {
        ContentValues cv = new ContentValues();
        cv.put(columnName, columnValue);
        updateMessageSync(messageId, cv);
    }


    private static final HashMap<Long, SearchParams> sSearchParamsMap =
        new HashMap<Long, SearchParams>();

    public void searchMore(long accountId) throws MessagingException {
        SearchParams params = sSearchParamsMap.get(accountId);
        if (params == null) return;
        params.mOffset += params.mLimit;
        searchMessages(accountId, params);
    }

    /**
     * Search for messages on the (IMAP) server; do not call this on the UI thread!
     * @param accountId the id of the account to be searched
     * @param searchParams the parameters for this search
     * @throws MessagingException
     */
    public int searchMessages(final long accountId, final SearchParams searchParams)
            throws MessagingException {
        // Find/create our search mailbox
        Mailbox searchMailbox = getSearchMailbox(accountId);
        if (searchMailbox == null) return 0;
        final long searchMailboxId = searchMailbox.mId;
        // Save this away (per account)
        sSearchParamsMap.put(accountId, searchParams);

        if (searchParams.mOffset == 0) {
            // Delete existing contents of search mailbox
            ContentResolver resolver = mContext.getContentResolver();
            resolver.delete(Message.CONTENT_URI, Message.MAILBOX_KEY + ""="" + searchMailboxId,
                    null);
            ContentValues cv = new ContentValues();
            // For now, use the actual query as the name of the mailbox
            cv.put(Mailbox.DISPLAY_NAME, searchParams.mFilter);
            resolver.update(ContentUris.withAppendedId(Mailbox.CONTENT_URI, searchMailboxId),
                    cv, null, null);
        }

        IEmailService service = getServiceForAccount(accountId);
        if (service != null) {
            // Service implementation
            try {
                return service.searchMessages(accountId, searchParams, searchMailboxId);
            } catch (RemoteException e) {
                // TODO Change exception handling to be consistent with however this method
                // is implemented for other protocols
                Log.e(""searchMessages"", ""RemoteException"", e);
                return 0;
            }
        } else {
            // This is the actual mailbox we'll be searching
            Mailbox actualMailbox = Mailbox.restoreMailboxWithId(mContext, searchParams.mMailboxId);
            if (actualMailbox == null) {
                Log.e(Logging.LOG_TAG, ""Unable to find mailbox "" + searchParams.mMailboxId
                        + "" to search in with "" + searchParams);
                return 0;
            }
            // Do the search
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ""Search: "" + searchParams.mFilter);
            }
            return mLegacyController.searchMailbox(accountId, searchParams, searchMailboxId);
        }
    }

    /**
     * Respond to a meeting invitation.
     *
     * @param messageId the id of the invitation being responded to
     * @param response the code representing the response to the invitation
     */
    public void sendMeetingResponse(final long messageId, final int response) {
         // Split here for target type (Service or MessagingController)
        IEmailService service = getServiceForMessage(messageId);
        if (service != null) {
            // Service implementation
            try {
                service.sendMeetingResponse(messageId, response);
            } catch (RemoteException e) {
                // TODO Change exception handling to be consistent with however this method
                // is implemented for other protocols
                Log.e(""onDownloadAttachment"", ""RemoteException"", e);
            }
        }
    }

    /**
     * Request that an attachment be loaded.  It will be stored at a location controlled
     * by the AttachmentProvider.
     *
     * @param attachmentId the attachment to load
     * @param messageId the owner message
     * @param accountId the owner account
     */
    public void loadAttachment(final long attachmentId, final long messageId,
            final long accountId) {
        Attachment attachInfo = Attachment.restoreAttachmentWithId(mProviderContext, attachmentId);
        if (attachInfo == null) {
            return;
        }

        if (Utility.attachmentExists(mProviderContext, attachInfo)) {
            // The attachment has already been downloaded, so we will just ""pretend"" to download it
            // This presumably is for POP3 messages
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadAttachmentCallback(null, accountId, messageId, attachmentId, 0);
                }
                for (Result listener : mListeners) {
                    listener.loadAttachmentCallback(null, accountId, messageId, attachmentId, 100);
                }
            }
            return;
        }

        // Flag the attachment as needing download at the user's request
        ContentValues cv = new ContentValues();
        cv.put(Attachment.FLAGS, attachInfo.mFlags | Attachment.FLAG_DOWNLOAD_USER_REQUEST);
        attachInfo.update(mProviderContext, cv);
    }

    /**
     * For a given message id, return a service proxy if applicable, or null.
     *
     * @param messageId the message of interest
     * @result service proxy, or null if n/a
     */
    private IEmailService getServiceForMessage(long messageId) {
        // TODO make this more efficient, caching the account, smaller lookup here, etc.
        Message message = Message.restoreMessageWithId(mProviderContext, messageId);
        if (message == null) {
            return null;
        }
        return getServiceForAccount(message.mAccountKey);
    }

    /**
     * For a given account id, return a service proxy if applicable, or null.
     *
     * @param accountId the message of interest
     * @result service proxy, or null if n/a
     */
    private IEmailService getServiceForAccount(long accountId) {
        if (isMessagingController(accountId)) return null;
        return getExchangeEmailService();
    }

    private IEmailService getExchangeEmailService() {
        return EmailServiceUtils.getExchangeService(mContext, mServiceCallback);
    }

    /**
     * Simple helper to determine if legacy MessagingController should be used
     */
    public boolean isMessagingController(Account account) {
        if (account == null) return false;
        return isMessagingController(account.mId);
    }

    public boolean isMessagingController(long accountId) {
        Boolean isLegacyController = mLegacyControllerMap.get(accountId);
        if (isLegacyController == null) {
            String protocol = Account.getProtocol(mProviderContext, accountId);
            isLegacyController = (""pop3"".equals(protocol) || ""imap"".equals(protocol));
            mLegacyControllerMap.put(accountId, isLegacyController);
        }
        return isLegacyController;
    }

    /**
     * Delete an account.
     */
    public void deleteAccount(final long accountId) {
        EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
            public void run() {
                deleteAccountSync(accountId, mProviderContext);
            }
        });
    }

    /**
     * Delete an account synchronously.
     */
    public void deleteAccountSync(long accountId, Context context) {
        try {
            mLegacyControllerMap.remove(accountId);
            // Get the account URI.
            final Account account = Account.restoreAccountWithId(context, accountId);
            if (account == null) {
                return; // Already deleted?
            }

            // Delete account data, attachments, PIM data, etc.
            deleteSyncedDataSync(accountId);

            // Now delete the account itself
            Uri uri = ContentUris.withAppendedId(Account.CONTENT_URI, accountId);
            context.getContentResolver().delete(uri, null, null);

            // For unit tests, don't run backup, security, and ui pieces.
            if (mInUnitTests) {
                return;
            }

            // Clean up
            AccountBackupRestore.backup(context);
            SecurityPolicy.getInstance(context).reducePolicies();
            Email.setServicesEnabledSync(context);
            Email.setNotifyUiAccountsChanged(true);
            MailService.actionReschedule(context);
        } catch (Exception e) {
            Log.w(Logging.LOG_TAG, ""Exception while deleting account"", e);
        }
    }

    /**
     * Delete all synced data, but don't delete the actual account.  This is used when security
     * policy requirements are not met, and we don't want to reveal any synced data, but we do
     * wish to keep the account configured (e.g. to accept remote wipe commands).
     *
     * The only mailbox not deleted is the account mailbox (if any)
     * Also, clear the sync keys on the remaining account, since the data is gone.
     *
     * SYNCHRONOUS - do not call from UI thread.
     *
     * @param accountId The account to wipe.
     */
    public void deleteSyncedDataSync(long accountId) {
        try {
            // Delete synced attachments
            AttachmentUtilities.deleteAllAccountAttachmentFiles(mProviderContext,
                    accountId);

            // Delete synced email, leaving only an empty inbox.  We do this in two phases:
            // 1. Delete all non-inbox mailboxes (which will delete all of their messages)
            // 2. Delete all remaining messages (which will be the inbox messages)
            ContentResolver resolver = mProviderContext.getContentResolver();
            String[] accountIdArgs = new String[] { Long.toString(accountId) };
            resolver.delete(Mailbox.CONTENT_URI,
                    MAILBOXES_FOR_ACCOUNT_EXCEPT_ACCOUNT_MAILBOX_SELECTION,
                    accountIdArgs);
            resolver.delete(Message.CONTENT_URI, MESSAGES_FOR_ACCOUNT_SELECTION, accountIdArgs);

            // Delete sync keys on remaining items
            ContentValues cv = new ContentValues();
            cv.putNull(Account.SYNC_KEY);
            resolver.update(Account.CONTENT_URI, cv, Account.ID_SELECTION, accountIdArgs);
            cv.clear();
            cv.putNull(Mailbox.SYNC_KEY);
            resolver.update(Mailbox.CONTENT_URI, cv,
                    MAILBOXES_FOR_ACCOUNT_SELECTION, accountIdArgs);

            // Delete PIM data (contacts, calendar), stop syncs, etc. if applicable
            IEmailService service = getServiceForAccount(accountId);
            if (service != null) {
                service.deleteAccountPIMData(accountId);
            }
        } catch (Exception e) {
            Log.w(Logging.LOG_TAG, ""Exception while deleting account synced data"", e);
        }
    }

    /**
     * Simple callback for synchronous commands.  For many commands, this can be largely ignored
     * and the result is observed via provider cursors.  The callback will *not* necessarily be
     * made from the UI thread, so you may need further handlers to safely make UI updates.
     */
    public static abstract class Result {
        private volatile boolean mRegistered;

        protected void setRegistered(boolean registered) {
            mRegistered = registered;
        }

        protected final boolean isRegistered() {
            return mRegistered;
        }

        /**
         * Callback for updateMailboxList
         *
         * @param result If null, the operation completed without error
         * @param accountId The account being operated on
         * @param progress 0 for ""starting"", 1..99 for updates (if needed in UI), 100 for complete
         */
        public void updateMailboxListCallback(MessagingException result, long accountId,
                int progress) {
        }

        /**
         * Callback for updateMailbox.  Note:  This looks a lot like checkMailCallback, but
         * it's a separate call used only by UI's, so we can keep things separate.
         *
         * @param result If null, the operation completed without error
         * @param accountId The account being operated on
         * @param mailboxId The mailbox being operated on
         * @param progress 0 for ""starting"", 1..99 for updates (if needed in UI), 100 for complete
         * @param numNewMessages the number of new messages delivered
         */
        public void updateMailboxCallback(MessagingException result, long accountId,
                long mailboxId, int progress, int numNewMessages, ArrayList<Long> addedMessages) {
        }

        /**
         * Callback for loadMessageForView
         *
         * @param result if null, the attachment completed - if non-null, terminating with failure
         * @param messageId the message which contains the attachment
         * @param progress 0 for ""starting"", 1..99 for updates (if needed in UI), 100 for complete
         */
        public void loadMessageForViewCallback(MessagingException result, long accountId,
                long messageId, int progress) {
        }

        /**
         * Callback for loadAttachment
         *
         * @param result if null, the attachment completed - if non-null, terminating with failure
         * @param messageId the message which contains the attachment
         * @param attachmentId the attachment being loaded
         * @param progress 0 for ""starting"", 1..99 for updates (if needed in UI), 100 for complete
         */
        public void loadAttachmentCallback(MessagingException result, long accountId,
                long messageId, long attachmentId, int progress) {
        }

        /**
         * Callback for checkmail.  Note:  This looks a lot like updateMailboxCallback, but
         * it's a separate call used only by the automatic checker service, so we can keep
         * things separate.
         *
         * @param result If null, the operation completed without error
         * @param accountId The account being operated on
         * @param mailboxId The mailbox being operated on (may be unknown at start)
         * @param progress 0 for ""starting"", no updates, 100 for complete
         * @param tag the same tag that was passed to serviceCheckMail()
         */
        public void serviceCheckMailCallback(MessagingException result, long accountId,
                long mailboxId, int progress, long tag) {
        }

        /**
         * Callback for sending pending messages.  This will be called once to start the
         * group, multiple times for messages, and once to complete the group.
         *
         * Unfortunately this callback works differently on SMTP and EAS.
         *
         * On SMTP:
         *
         * First, we get this.
         *  result == null, messageId == -1, progress == 0:     start batch send
         *
         * Then we get these callbacks per message.
         * (Exchange backend may skip ""start sending one message"".)
         *  result == null, messageId == xx, progress == 0:     start sending one message
         *  result == xxxx, messageId == xx, progress == 0;     failed sending one message
         *
         * Finally we get this.
         *  result == null, messageId == -1, progres == 100;    finish sending batch
         *
         * On EAS: Almost same as above, except:
         *
         * - There's no first (""start batch send"") callback.
         * - accountId is always -1.
         *
         * @param result If null, the operation completed without error
         * @param accountId The account being operated on
         * @param messageId The being sent (may be unknown at start)
         * @param progress 0 for ""starting"", 100 for complete
         */
        public void sendMailCallback(MessagingException result, long accountId,
                long messageId, int progress) {
        }
    }

    /**
     * Bridge to intercept {@link MessageRetrievalListener#loadAttachmentProgress} and
     * pass down to {@link Result}.
     */
    public class MessageRetrievalListenerBridge implements MessageRetrievalListener {
        private final long mMessageId;
        private final long mAttachmentId;
        private final long mAccountId;

        public MessageRetrievalListenerBridge(long messageId, long attachmentId) {
            mMessageId = messageId;
            mAttachmentId = attachmentId;
            mAccountId = Account.getAccountIdForMessageId(mProviderContext, mMessageId);
        }

        @Override
        public void loadAttachmentProgress(int progress) {
              synchronized (mListeners) {
                  for (Result listener : mListeners) {
                      listener.loadAttachmentCallback(null, mAccountId, mMessageId, mAttachmentId,
                              progress);
                 }
              }
        }

        @Override
        public void messageRetrieved(com.android.emailcommon.mail.Message message) {
        }
    }

    /**
     * Support for receiving callbacks from MessagingController and dealing with UI going
     * out of scope.
     */
    public class LegacyListener extends MessagingListener {
        public LegacyListener() {
        }

        @Override
        public void listFoldersStarted(long accountId) {
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.updateMailboxListCallback(null, accountId, 0);
                }
            }
        }

        @Override
        public void listFoldersFailed(long accountId, String message) {
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.updateMailboxListCallback(new MessagingException(message), accountId, 0);
                }
            }
        }

        @Override
        public void listFoldersFinished(long accountId) {
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.updateMailboxListCallback(null, accountId, 100);
                }
            }
        }

        @Override
        public void synchronizeMailboxStarted(long accountId, long mailboxId) {
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.updateMailboxCallback(null, accountId, mailboxId, 0, 0, null);
                }
            }
        }

        @Override
        public void synchronizeMailboxFinished(long accountId, long mailboxId,
                int totalMessagesInMailbox, int numNewMessages, ArrayList<Long> addedMessages) {
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.updateMailboxCallback(null, accountId, mailboxId, 100, numNewMessages,
                            addedMessages);
                }
            }
        }

        @Override
        public void synchronizeMailboxFailed(long accountId, long mailboxId, Exception e) {
            MessagingException me;
            if (e instanceof MessagingException) {
                me = (MessagingException) e;
            } else {
                me = new MessagingException(e.toString());
            }
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.updateMailboxCallback(me, accountId, mailboxId, 0, 0, null);
                }
            }
        }

        @Override
        public void checkMailStarted(Context context, long accountId, long tag) {
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.serviceCheckMailCallback(null, accountId, -1, 0, tag);
                }
            }
        }

        @Override
        public void checkMailFinished(Context context, long accountId, long folderId, long tag) {
            synchronized (mListeners) {
                for (Result l : mListeners) {
                    l.serviceCheckMailCallback(null, accountId, folderId, 100, tag);
                }
            }
        }

        @Override
        public void loadMessageForViewStarted(long messageId) {
            final long accountId = Account.getAccountIdForMessageId(mProviderContext, messageId);
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadMessageForViewCallback(null, accountId, messageId, 0);
                }
            }
        }

        @Override
        public void loadMessageForViewFinished(long messageId) {
            final long accountId = Account.getAccountIdForMessageId(mProviderContext, messageId);
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadMessageForViewCallback(null, accountId, messageId, 100);
                }
            }
        }

        @Override
        public void loadMessageForViewFailed(long messageId, String message) {
            final long accountId = Account.getAccountIdForMessageId(mProviderContext, messageId);
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadMessageForViewCallback(new MessagingException(message),
                            accountId, messageId, 0);
                }
            }
        }

        @Override
        public void loadAttachmentStarted(long accountId, long messageId, long attachmentId,
                boolean requiresDownload) {
            try {
                mCallbackProxy.loadAttachmentStatus(messageId, attachmentId,
                        EmailServiceStatus.IN_PROGRESS, 0);
            } catch (RemoteException e) {
            }
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadAttachmentCallback(null, accountId, messageId, attachmentId, 0);
                }
            }
        }

        @Override
        public void loadAttachmentFinished(long accountId, long messageId, long attachmentId) {
            try {
                mCallbackProxy.loadAttachmentStatus(messageId, attachmentId,
                        EmailServiceStatus.SUCCESS, 100);
            } catch (RemoteException e) {
            }
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadAttachmentCallback(null, accountId, messageId, attachmentId, 100);
                }
            }
        }

        @Override
        public void loadAttachmentFailed(long accountId, long messageId, long attachmentId,
                MessagingException me, boolean background) {
            try {
                // If the cause of the MessagingException is an IOException, we send a status of
                // CONNECTION_ERROR; in this case, AttachmentDownloadService will try again to
                // download the attachment.  Otherwise, the error is considered non-recoverable.
                int status = EmailServiceStatus.ATTACHMENT_NOT_FOUND;
                if (me != null && me.getCause() instanceof IOException) {
                    status = EmailServiceStatus.CONNECTION_ERROR;
                }
                mCallbackProxy.loadAttachmentStatus(messageId, attachmentId, status, 0);
            } catch (RemoteException e) {
            }
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    // TODO We are overloading the exception here. The UI listens for this
                    // callback and displays a toast if the exception is not null. Since we
                    // want to avoid displaying toast for background operations, we force
                    // the exception to be null. This needs to be re-worked so the UI will
                    // only receive (or at least pays attention to) responses for requests
                    // it explicitly cares about. Then we would not need to overload the
                    // exception parameter.
                    listener.loadAttachmentCallback(background ? null : me, accountId, messageId,
                            attachmentId, 0);
                }
            }
        }

        @Override
        synchronized public void sendPendingMessagesStarted(long accountId, long messageId) {
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.sendMailCallback(null, accountId, messageId, 0);
                }
            }
        }

        @Override
        synchronized public void sendPendingMessagesCompleted(long accountId) {
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.sendMailCallback(null, accountId, -1, 100);
                }
            }
        }

        @Override
        synchronized public void sendPendingMessagesFailed(long accountId, long messageId,
                Exception reason) {
            MessagingException me;
            if (reason instanceof MessagingException) {
                me = (MessagingException) reason;
            } else {
                me = new MessagingException(reason.toString());
            }
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.sendMailCallback(me, accountId, messageId, 0);
                }
            }
        }
    }

    /**
     * Service callback for service operations
     */
    private class ServiceCallback extends IEmailServiceCallback.Stub {

        private final static boolean DEBUG_FAIL_DOWNLOADS = false;       // do not check in ""true""

        public void loadAttachmentStatus(long messageId, long attachmentId, int statusCode,
                int progress) {
            MessagingException result = mapStatusToException(statusCode);
            switch (statusCode) {
                case EmailServiceStatus.SUCCESS:
                    progress = 100;
                    break;
                case EmailServiceStatus.IN_PROGRESS:
                    if (DEBUG_FAIL_DOWNLOADS && progress > 75) {
                        result = new MessagingException(
                                String.valueOf(EmailServiceStatus.CONNECTION_ERROR));
                    }
                    // discard progress reports that look like sentinels
                    if (progress < 0 || progress >= 100) {
                        return;
                    }
                    break;
            }
            final long accountId = Account.getAccountIdForMessageId(mProviderContext, messageId);
            synchronized (mListeners) {
                for (Result listener : mListeners) {
                    listener.loadAttachmentCallback(result, accountId, messageId, attachmentId,
                            progress);
                }
            }
        }

        /**
         * Note, this is an incomplete implementation of this callback, because we are
         * not getting things back from Service in quite the same way as from MessagingController.
         * However, this is sufficient for basic ""progress=100"" notification that message send
         * has just completed.
         */
        public void sendMessageStatus(long messageId, String subject, int statusCode,
                int progress) {
            long accountId = -1;        // This should be in the callback
            MessagingException result = mapStatusToException(statusCode);
            switch (statusCode) {
                case EmailServiceStatus.SUCCESS:
                    progress = 100;
                    break;
                case EmailServiceStatus.IN_PROGRESS:
                    // discard progress reports that look like sentinels
                    if (progress < 0 || progress >= 100) {
                        return;
                    }
                    break;
            }
            synchronized(mListeners) {
                for (Result listener : mListeners) {
                    listener.sendMailCallback(result, accountId, messageId, progress);
                }
            }
        }

        public void syncMailboxListStatus(long accountId, int statusCode, int progress) {
            MessagingException result = mapStatusToException(statusCode);
            switch (statusCode) {
                case EmailServiceStatus.SUCCESS:
                    progress = 100;
                    break;
                case EmailServiceStatus.IN_PROGRESS:
                    // discard progress reports that look like sentinels
                    if (progress < 0 || progress >= 100) {
                        return;
                    }
                    break;
            }
            synchronized(mListeners) {
                for (Result listener : mListeners) {
                    listener.updateMailboxListCallback(result, accountId, progress);
                }
            }
        }

        public void syncMailboxStatus(long mailboxId, int statusCode, int progress) {
            MessagingException result = mapStatusToException(statusCode);
            switch (statusCode) {
                case EmailServiceStatus.SUCCESS:
                    progress = 100;
                    break;
                case EmailServiceStatus.IN_PROGRESS:
                    // discard progress reports that look like sentinels
                    if (progress < 0 || progress >= 100) {
                        return;
                    }
                    break;
            }
            // TODO should pass this back instead of looking it up here
            Mailbox mbx = Mailbox.restoreMailboxWithId(mProviderContext, mailboxId);
            // The mailbox could have disappeared if the server commanded it
            if (mbx == null) return;
            long accountId = mbx.mAccountKey;
            synchronized(mListeners) {
                for (Result listener : mListeners) {
                    listener.updateMailboxCallback(result, accountId, mailboxId, progress, 0, null);
                }
            }
        }

        private MessagingException mapStatusToException(int statusCode) {
            switch (statusCode) {
                case EmailServiceStatus.SUCCESS:
                case EmailServiceStatus.IN_PROGRESS:
                // Don't generate error if the account is uninitialized
                case EmailServiceStatus.ACCOUNT_UNINITIALIZED:
                    return null;

                case EmailServiceStatus.LOGIN_FAILED:
                    return new AuthenticationFailedException("""");

                case EmailServiceStatus.CONNECTION_ERROR:
                    return new MessagingException(MessagingException.IOERROR);

                case EmailServiceStatus.SECURITY_FAILURE:
                    return new MessagingException(MessagingException.SECURITY_POLICIES_REQUIRED);

                case EmailServiceStatus.ACCESS_DENIED:
                    return new MessagingException(MessagingException.ACCESS_DENIED);

                case EmailServiceStatus.ATTACHMENT_NOT_FOUND:
                    return new MessagingException(MessagingException.ATTACHMENT_NOT_FOUND);

                case EmailServiceStatus.CLIENT_CERTIFICATE_ERROR:
                    return new MessagingException(MessagingException.CLIENT_CERTIFICATE_ERROR);

                case EmailServiceStatus.MESSAGE_NOT_FOUND:
                case EmailServiceStatus.FOLDER_NOT_DELETED:
                case EmailServiceStatus.FOLDER_NOT_RENAMED:
                case EmailServiceStatus.FOLDER_NOT_CREATED:
                case EmailServiceStatus.REMOTE_EXCEPTION:
                    // TODO: define exception code(s) & UI string(s) for server-side errors
                default:
                    return new MessagingException(String.valueOf(statusCode));
            }
        }
    }

    private interface ServiceCallbackWrapper {
        public void call(IEmailServiceCallback cb) throws RemoteException;
    }

    /**
     * Proxy that can be used to broadcast service callbacks; we currently use this only for
     * loadAttachment callbacks
     */
    private final IEmailServiceCallback.Stub mCallbackProxy =
        new IEmailServiceCallback.Stub() {

        /**
         * Broadcast a callback to the everyone that's registered
         *
         * @param wrapper the ServiceCallbackWrapper used in the broadcast
         */
        private synchronized void broadcastCallback(ServiceCallbackWrapper wrapper) {
            if (sCallbackList != null) {
                // Call everyone on our callback list
                // Exceptions can be safely ignored
                int count = sCallbackList.beginBroadcast();
                for (int i = 0; i < count; i++) {
                    try {
                        wrapper.call(sCallbackList.getBroadcastItem(i));
                    } catch (RemoteException e) {
                    }
                }
                sCallbackList.finishBroadcast();
            }
        }

        public void loadAttachmentStatus(final long messageId, final long attachmentId,
                final int status, final int progress) {
            broadcastCallback(new ServiceCallbackWrapper() {
                @Override
                public void call(IEmailServiceCallback cb) throws RemoteException {
                    cb.loadAttachmentStatus(messageId, attachmentId, status, progress);
                }
            });
        }

        @Override
        public void sendMessageStatus(long messageId, String subject, int statusCode, int progress){
        }

        @Override
        public void syncMailboxListStatus(long accountId, int statusCode, int progress) {
        }

        @Override
        public void syncMailboxStatus(long mailboxId, int statusCode, int progress) {
        }
    };

    public static class ControllerService extends Service {
        /**
         * Create our EmailService implementation here.  For now, only loadAttachment is supported;
         * the intention, however, is to move more functionality to the service interface
         */
        private final IEmailService.Stub mBinder = new IEmailService.Stub() {

            public Bundle validate(HostAuth hostAuth) {
                return null;
            }

            public Bundle autoDiscover(String userName, String password) {
                return null;
            }

            public void startSync(long mailboxId, boolean userRequest) {
            }

            public void stopSync(long mailboxId) {
            }

            public void loadAttachment(long attachmentId, boolean background)
                    throws RemoteException {
                Attachment att = Attachment.restoreAttachmentWithId(ControllerService.this,
                        attachmentId);
                if (att != null) {
                    if (Email.DEBUG) {
                        Log.d(TAG, ""loadAttachment "" + attachmentId + "": "" + att.mFileName);
                    }
                    Message msg = Message.restoreMessageWithId(ControllerService.this,
                            att.mMessageKey);
                    if (msg != null) {
                        // If the message is a forward and the attachment needs downloading, we need
                        // to retrieve the message from the source, rather than from the message
                        // itself
                        if ((msg.mFlags & Message.FLAG_TYPE_FORWARD) != 0) {
                            String[] cols = Utility.getRowColumns(ControllerService.this,
                                    Body.CONTENT_URI, BODY_SOURCE_KEY_PROJECTION, WHERE_MESSAGE_KEY,
                                    new String[] {Long.toString(msg.mId)});
                            if (cols != null) {
                                msg = Message.restoreMessageWithId(ControllerService.this,
                                        Long.parseLong(cols[BODY_SOURCE_KEY_COLUMN]));
                                if (msg == null) {
                                    // TODO: We can try restoring from the deleted table here...
                                    return;
                                }
                            }
                        }
                        MessagingController legacyController = sInstance.mLegacyController;
                        LegacyListener legacyListener = sInstance.mLegacyListener;
                        legacyController.loadAttachment(msg.mAccountKey, msg.mId, msg.mMailboxKey,
                                attachmentId, legacyListener, background);
                    } else {
                        // Send back the specific error status for this case
                        sInstance.mCallbackProxy.loadAttachmentStatus(att.mMessageKey, attachmentId,
                                EmailServiceStatus.MESSAGE_NOT_FOUND, 0);
                    }
                }
            }

            public void updateFolderList(long accountId) {
            }

            public void hostChanged(long accountId) {
            }

            public void setLogging(int flags) {
            }

            public void sendMeetingResponse(long messageId, int response) {
            }

            public void loadMore(long messageId) {
            }

            // The following three methods are not implemented in this version
            public boolean createFolder(long accountId, String name) {
                return false;
            }

            public boolean deleteFolder(long accountId, String name) {
                return false;
            }

            public boolean renameFolder(long accountId, String oldName, String newName) {
                return false;
            }

            public void setCallback(IEmailServiceCallback cb) {
                sCallbackList.register(cb);
            }

            public void deleteAccountPIMData(long accountId) {
            }

            public int searchMessages(long accountId, SearchParams searchParams,
                    long destMailboxId) {
                return 0;
            }

            @Override
            public int getApiLevel() {
                return Api.LEVEL;
            }
        };

        @Override
        public IBinder onBind(Intent intent) {
            return mBinder;
        }
    }
}
",True,279,2,10,9,49,31,24,L6
5,com.android.email.MessageListContext.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.content.Context;
import android.content.Intent;
import android.os.Parcel;
import android.os.Parcelable;

import com.android.email.activity.EmailActivity;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.SearchParams;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;

/**
 * Information about what is being shown in a message list.
 * This encapsulates the meta-data about the list of messages, which can either be the
 * {@link Mailbox} ID, or {@link SearchParams}.
 */
public class MessageListContext implements Parcelable {

    /**
     * The active account. Changing an account is a destructive enough operation that it warrants
     * the creation of a new {@link MessageListContext}
     */
    public final long mAccountId;

    /**
     * The mailbox ID containing the messages. Must not be {@link Mailbox#NO_MAILBOX}.
     */
    private final long mMailboxId;

    /**
     * The search parameters, if the user is in a search.
     * If non-null, {@link #mMailboxId} will always correspond to the search mailbox for the user.
     */
    private final SearchParams mSearchParams;

    // Private constructor - use static builder methods to generate a validated instance.
    private MessageListContext(long accountId, long searchMailboxId, SearchParams searchParams) {
        mAccountId = accountId;
        mMailboxId = searchMailboxId;
        mSearchParams = searchParams;
    }

    /**
     * Builds an instance from the information provided in an Intent.
     * This method will perform proper validation and throw an {@link IllegalArgumentException}
     * if values in the {@link Intent} are inconsistent.
     * This will also handle the generation of default values if certain fields are unspecified
     * in the {@link Intent}.
     */
    public static MessageListContext forIntent(Context context, Intent intent) {
        long accountId = intent.getLongExtra(EmailActivity.EXTRA_ACCOUNT_ID, Account.NO_ACCOUNT);
        long mailboxId = intent.getLongExtra(EmailActivity.EXTRA_MAILBOX_ID, Mailbox.NO_MAILBOX);

        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
            final String queryTerm = intent.getStringExtra(EmailActivity.EXTRA_QUERY_STRING);
            final long searchMailboxId =
                    Controller.getInstance(context).getSearchMailbox(accountId).mId;
            return forSearch(accountId, searchMailboxId, new SearchParams(mailboxId, queryTerm));
        } else {
            if (accountId == Account.NO_ACCOUNT) {
                accountId = Account.getDefaultAccountId(context);
                if (accountId == Account.NO_ACCOUNT) {
                    return null;
                }
            }
            if (mailboxId == Mailbox.NO_MAILBOX) {
                mailboxId = (accountId == Account.ACCOUNT_ID_COMBINED_VIEW)
                        ? Mailbox.QUERY_ALL_INBOXES
                        : Mailbox.findMailboxOfType(context, accountId, Mailbox.TYPE_INBOX);
            }

            return forMailbox(accountId, mailboxId);
        }
    }

    /**
     * Creates a view context for a given search.
     */
    public static MessageListContext forSearch(
            long accountId, long searchMailboxId, SearchParams searchParams) {
        Preconditions.checkArgument(
                Account.isNormalAccount(accountId),
                ""Can only search in normal accounts"");
        return new MessageListContext(accountId, searchMailboxId, searchParams);
    }

    /**
     * Creates a view context for a given mailbox.
     */
    public static MessageListContext forMailbox(long accountId, long mailboxId) {
        Preconditions.checkArgument(accountId != Account.NO_ACCOUNT, ""Must specify an account"");
        Preconditions.checkArgument(mailboxId != Mailbox.NO_MAILBOX, ""Must specify a mailbox"");
        return new MessageListContext(accountId, mailboxId, null);
    }

    public boolean isSearch() {
        return mSearchParams != null;
    }

    public long getSearchedMailbox() {
        return isSearch() ? mSearchParams.mMailboxId : Mailbox.NO_MAILBOX;
    }

    public SearchParams getSearchParams() {
        return mSearchParams;
    }

    public long getMailboxId() {
        return mMailboxId;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if ((o == null) || !(o instanceof MessageListContext)) {
            return false;
        }

        MessageListContext om = (MessageListContext) o;
        return mAccountId == om.mAccountId
                && mMailboxId == om.mMailboxId
                && Objects.equal(mSearchParams, om.mSearchParams);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(mAccountId, mMailboxId, mSearchParams);
    }

    @Override
    public String toString() {
        return ""[MessageListContext "" + mAccountId + "":"" + mMailboxId + "":"" + mSearchParams + ""]"";
    }


    private MessageListContext(Parcel in) {
        mAccountId = in.readLong();
        mMailboxId = in.readLong();
        mSearchParams = in.readParcelable(SearchParams.class.getClassLoader());
    }

    @Override
    public int describeContents() {
        return 0;
    }

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeLong(mAccountId);
        dest.writeLong(mMailboxId);
        dest.writeParcelable(mSearchParams, flags);
    }

    public static Parcelable.Creator<MessageListContext> CREATOR =
                new Parcelable.Creator<MessageListContext>() {
        @Override
        public MessageListContext createFromParcel(Parcel source) {
            return new MessageListContext(source);
        }

        @Override
        public MessageListContext[] newArray(int size) {
            return new MessageListContext[size];
        }
    };
}
",True,270,1,3,10,65,10,6,L6
6,com.android.email.FolderProperties.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.google.common.base.Preconditions;

import android.content.Context;
import android.content.res.TypedArray;
import android.database.Cursor;
import android.graphics.drawable.Drawable;


// TODO When the UI is settled, cache all strings/drawables
/**
 * Stores names and icons for system folders. System folders are those with special
 * meaning, such as Inbox, Drafts, Trash, etc... Although these folders may or may
 * not exist on the server, we want to ensure they are displayed in a very specific
 * manner.
 *
 * Some methods probably should belong to {@link Mailbox}, but as this class uses resources,
 * we can't move them to emailcommon...
 */
public class FolderProperties {

    private static FolderProperties sInstance;

    private final Context mContext;

    // Caches for frequently accessed resources.
    private final String[] mSpecialMailbox;
    private final TypedArray mSpecialMailboxDrawable;
    private final Drawable mSummaryStarredMailboxDrawable;
    private final Drawable mSummaryCombinedInboxDrawable;

    private FolderProperties(Context context) {
        mContext = context.getApplicationContext();
        mSpecialMailbox = context.getResources().getStringArray(R.array.mailbox_display_names);
        for (int i = 0; i < mSpecialMailbox.length; ++i) {
            if ("""".equals(mSpecialMailbox[i])) {
                // there is no localized name, so use the display name from the server
                mSpecialMailbox[i] = null;
            }
        }
        mSpecialMailboxDrawable =
            context.getResources().obtainTypedArray(R.array.mailbox_display_icons);
        mSummaryStarredMailboxDrawable =
            context.getResources().getDrawable(R.drawable.ic_menu_star_holo_light);
        mSummaryCombinedInboxDrawable =
            context.getResources().getDrawable(R.drawable.ic_list_combined_inbox);
    }

    public static synchronized FolderProperties getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new FolderProperties(context);
        }
        return sInstance;
    }

    public String getCombinedMailboxName(long mailboxId) {
        // Special combined mailboxes
        int resId = 0;

        // Can't use long for switch!?
        if (mailboxId == Mailbox.QUERY_ALL_INBOXES) {
            resId = R.string.account_folder_list_summary_inbox;
        } else if (mailboxId == Mailbox.QUERY_ALL_FAVORITES) {
            resId = R.string.account_folder_list_summary_starred;
        } else if (mailboxId == Mailbox.QUERY_ALL_DRAFTS) {
            resId = R.string.account_folder_list_summary_drafts;
        } else if (mailboxId == Mailbox.QUERY_ALL_OUTBOX) {
            resId = R.string.account_folder_list_summary_outbox;
        }
        if (resId != 0) {
            return mContext.getString(resId);
        }
        return null;
    }

    /**
     * Lookup names of localized special mailboxes
     */
    private String getDisplayName(int type, long mailboxId) {
        String name = getCombinedMailboxName(mailboxId);

        if ((name == null) && (type < mSpecialMailbox.length)) {
            name = mSpecialMailbox[type];
        }
        return name;
    }

    /**
     * Return the display name for a mailbox for UI.  For normal mailboxes, it just returns
     * {@code originalDisplayName}, but for special mailboxes (such as combined mailboxes) it
     * returns a name obtained from the resource.
     *
     * @param mailboxType Such as {@link Mailbox#TYPE_INBOX}
     * @param mailboxId ID of a mailbox.
     * @param originalDisplayName Display name of the mailbox stored in the database.
     */
    public String getDisplayName(int mailboxType, long mailboxId, String originalDisplayName) {
        String name = getDisplayName(mailboxType, mailboxId);
        if (name != null) {
            return name;
        }
        return originalDisplayName;
    }

    /**
     * Same as {@link #getDisplayName(int, long, String)}, but gets information form a mailbox
     * cursor.  The cursor must contain the following columns:
     * {@link MailboxColumns#ID}, {@link MailboxColumns#TYPE} and
     * {@link MailboxColumns#DISPLAY_NAME}.
     */
    public String getDisplayName(Cursor mailboxCursor) {
        final Cursor c = mailboxCursor;
        return getDisplayName(
                c.getInt(c.getColumnIndex(MailboxColumns.TYPE)),
                c.getLong(c.getColumnIndex(MailboxColumns.ID)),
                c.getString(c.getColumnIndex(MailboxColumns.DISPLAY_NAME))
                );
    }

    public String getDisplayName(Mailbox mailbox) {
        return getDisplayName(mailbox.mType, mailbox.mId, mailbox.mDisplayName);
    }

    /**
     * Return the message count which should be shown with a mailbox name.  Depending on
     * the mailbox type, we change what to show.
     *
     * @param mailboxType Such as {@link Mailbox#TYPE_INBOX}
     * @param unreadCount Count obtained from {@link MailboxColumns#UNREAD_COUNT}
     * @param totalCount Count obtained from {@link MailboxColumns#MESSAGE_COUNT}
     */
    public int getMessageCount(int mailboxType, int unreadCount, int totalCount) {
        switch (mailboxType) {
            case Mailbox.TYPE_DRAFTS:
            case Mailbox.TYPE_OUTBOX:
                return totalCount;
            case Mailbox.TYPE_SENT:
            case Mailbox.TYPE_TRASH:
                return 0; // We don't show a count for sent/trash.
        }
        return unreadCount;
    }

    /**
     * Same as {@link #getMessageCount(int, int, int)}, but gets information form a mailbox
     * cursor.  The cursor must contain the following columns:
     * {@link MailboxColumns#TYPE}, {@link MailboxColumns#UNREAD_COUNT} and
     * {@link MailboxColumns#MESSAGE_COUNT}.
     */
    public int getMessageCount(Cursor mailboxCursor) {
        final Cursor c = mailboxCursor;
        return getMessageCount(
                c.getInt(c.getColumnIndex(MailboxColumns.TYPE)),
                c.getInt(c.getColumnIndex(MailboxColumns.UNREAD_COUNT)),
                c.getInt(c.getColumnIndex(MailboxColumns.MESSAGE_COUNT))
                );
    }

    /**
     * @return message count to show for the UI for a combined inbox.
     *
     * Note this method doesn't use mContext so we can inject a mock context for provider
     * access.  So it's static.
     */
    public static int getMessageCountForCombinedMailbox(Context context, long mailboxId) {
        Preconditions.checkState(mailboxId < -1L);
        if ((mailboxId == Mailbox.QUERY_ALL_INBOXES)
                || (mailboxId == Mailbox.QUERY_ALL_UNREAD)) {
            return Mailbox.getUnreadCountByMailboxType(context, Mailbox.TYPE_INBOX);

        } else if (mailboxId == Mailbox.QUERY_ALL_FAVORITES) {
            return Message.getFavoriteMessageCount(context);

        } else if (mailboxId == Mailbox.QUERY_ALL_DRAFTS) {
            return Mailbox.getMessageCountByMailboxType(context, Mailbox.TYPE_DRAFTS);

        } else if (mailboxId == Mailbox.QUERY_ALL_OUTBOX) {
            return Mailbox.getMessageCountByMailboxType(context, Mailbox.TYPE_OUTBOX);
        }
        throw new IllegalStateException(""Invalid mailbox ID"");
    }

    /**
     * Lookup icons of special mailboxes
     */
    public Drawable getIcon(int type, long mailboxId, int mailboxFlags) {
        if (mailboxId == Mailbox.QUERY_ALL_INBOXES) {
            return mSummaryCombinedInboxDrawable;
        } else if (mailboxId == Mailbox.QUERY_ALL_FAVORITES) {
            return mSummaryStarredMailboxDrawable;
        } else if (mailboxId == Mailbox.QUERY_ALL_DRAFTS) {
            return mSpecialMailboxDrawable.getDrawable(Mailbox.TYPE_DRAFTS);
        } else if (mailboxId == Mailbox.QUERY_ALL_OUTBOX) {
            return mSpecialMailboxDrawable.getDrawable(Mailbox.TYPE_OUTBOX);
        }
        if (0 <= type && type < mSpecialMailboxDrawable.length()) {
            final int resId = mSpecialMailboxDrawable.getResourceId(type, -1);
            if (resId != -1) {
                return mContext.getResources().getDrawable(resId);
            }
        }
        return null; // No icon
    }
}

",False,160,10,42,4,6,7,2,L2
7,com.android.email.Throttle.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.Logging;

import android.os.Handler;
import android.util.Log;

import java.util.Timer;
import java.util.TimerTask;

/**
 * This class used to ""throttle"" a flow of events.
 *
 * When {@link #onEvent()} is called, it calls the callback in a certain timeout later.
 * Initially {@link #mMinTimeout} is used as the timeout, but if it gets multiple {@link #onEvent}
 * calls in a certain amount of time, it extends the timeout, until it reaches {@link #mMaxTimeout}.
 *
 * This class is primarily used to throttle content changed events.
 */
public class Throttle {
    public static final boolean DEBUG = false; // Don't submit with true

    public static final int DEFAULT_MIN_TIMEOUT = 150;
    public static final int DEFAULT_MAX_TIMEOUT = 2500;
    /* package */ static final int TIMEOUT_EXTEND_INTERVAL = 500;

    private static Timer TIMER = new Timer();

    private final Clock mClock;
    private final Timer mTimer;

    /** Name of the instance.  Only for logging. */
    private final String mName;

    /** Handler for UI thread. */
    private final Handler mHandler;

    /** Callback to be called */
    private final Runnable mCallback;

    /** Minimum (default) timeout, in milliseconds.  */
    private final int mMinTimeout;

    /** Max timeout, in milliseconds.  */
    private final int mMaxTimeout;

    /** Current timeout, in milliseconds. */
    private int mTimeout;

    /** When {@link #onEvent()} was last called. */
    private long mLastEventTime;

    private MyTimerTask mRunningTimerTask;

    /** Constructor with default timeout */
    public Throttle(String name, Runnable callback, Handler handler) {
        this(name, callback, handler, DEFAULT_MIN_TIMEOUT, DEFAULT_MAX_TIMEOUT);
    }

    /** Constructor that takes custom timeout */
    public Throttle(String name, Runnable callback, Handler handler,int minTimeout,
            int maxTimeout) {
        this(name, callback, handler, minTimeout, maxTimeout, Clock.INSTANCE, TIMER);
    }

    /** Constructor for tests */
    /* package */ Throttle(String name, Runnable callback, Handler handler,int minTimeout,
            int maxTimeout, Clock clock, Timer timer) {
        if (maxTimeout < minTimeout) {
            throw new IllegalArgumentException();
        }
        mName = name;
        mCallback = callback;
        mClock = clock;
        mTimer = timer;
        mHandler = handler;
        mMinTimeout = minTimeout;
        mMaxTimeout = maxTimeout;
        mTimeout = mMinTimeout;
    }

    private void debugLog(String message) {
        Log.d(Logging.LOG_TAG, ""Throttle: ["" + mName + ""] "" + message);
    }

    private boolean isCallbackScheduled() {
        return mRunningTimerTask != null;
    }

    public void cancelScheduledCallback() {
        if (mRunningTimerTask != null) {
            if (DEBUG) debugLog(""Canceling scheduled callback"");
            mRunningTimerTask.cancel();
            mRunningTimerTask = null;
        }
    }

    /* package */ void updateTimeout() {
        final long now = mClock.getTime();
        if ((now - mLastEventTime) <= TIMEOUT_EXTEND_INTERVAL) {
            mTimeout *= 2;
            if (mTimeout >= mMaxTimeout) {
                mTimeout = mMaxTimeout;
            }
            if (DEBUG) debugLog(""Timeout extended "" + mTimeout);
        } else {
            mTimeout = mMinTimeout;
            if (DEBUG) debugLog(""Timeout reset to "" + mTimeout);
        }

        mLastEventTime = now;
    }

    public void onEvent() {
        if (DEBUG) debugLog(""onEvent"");

        updateTimeout();

        if (isCallbackScheduled()) {
            if (DEBUG) debugLog(""    callback already scheduled"");
        } else {
            if (DEBUG) debugLog(""    scheduling callback"");
            mRunningTimerTask = new MyTimerTask();
            mTimer.schedule(mRunningTimerTask, mTimeout);
        }
    }

    /**
     * Timer task called on timeout,
     */
    private class MyTimerTask extends TimerTask {
        private boolean mCanceled;

        @Override
        public void run() {
            mHandler.post(new HandlerRunnable());
        }

        @Override
        public boolean cancel() {
            mCanceled = true;
            return super.cancel();
        }

        private class HandlerRunnable implements Runnable {
            @Override
            public void run() {
                mRunningTimerTask = null;
                if (!mCanceled) { // This check has to be done on the UI thread.
                    if (DEBUG) debugLog(""Kicking callback"");
                    mCallback.run();
                }
            }
        }
    }

    /* package */ int getTimeoutForTest() {
        return mTimeout;
    }

    /* package */ long getLastEventTimeForTest() {
        return mLastEventTime;
    }
}
",True,152,10,50,1,2,4,2,L1
8,com.android.email.AttachmentInfo.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.internet.MimeUtility;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.emailcommon.utility.Utility;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.database.Cursor;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.provider.Settings;
import android.text.TextUtils;

import java.util.List;

/**
 * Encapsulates commonly used attachment information related to suitability for viewing and saving,
 * based on the attachment's filename and mime type.
 */
public class AttachmentInfo {
    // Projection which can be used with the constructor taking a Cursor argument
    public static final String[] PROJECTION = new String[] {Attachment.RECORD_ID, Attachment.SIZE,
        Attachment.FILENAME, Attachment.MIME_TYPE, Attachment.ACCOUNT_KEY, Attachment.FLAGS};
    // Offsets into PROJECTION
    public static final int COLUMN_ID = 0;
    public static final int COLUMN_SIZE = 1;
    public static final int COLUMN_FILENAME = 2;
    public static final int COLUMN_MIME_TYPE = 3;
    public static final int COLUMN_ACCOUNT_KEY = 4;
    public static final int COLUMN_FLAGS = 5;

    /** Attachment not denied */
    public static final int ALLOW           = 0x00;
    /** Attachment suspected of being malware */
    public static final int DENY_MALWARE    = 0x01;
    /** Attachment too large; must download over wi-fi */
    public static final int DENY_WIFIONLY   = 0x02;
    /** No receiving intent to handle attachment type */
    public static final int DENY_NOINTENT   = 0x04;
    /** Side load of applications is disabled */
    public static final int DENY_NOSIDELOAD = 0x08;
    // TODO Remove DENY_APKINSTALL when we can install directly from the Email activity
    /** Unable to install any APK */
    public static final int DENY_APKINSTALL = 0x10;
    /** Security policy prohibits install */
    public static final int DENY_POLICY = 0x20;

    public final long mId;
    public final long mSize;
    public final String mName;
    public final String mContentType;
    public final long mAccountKey;
    public final int mFlags;

    /** Whether or not this attachment can be viewed */
    public final boolean mAllowView;
    /** Whether or not this attachment can be saved */
    public final boolean mAllowSave;
    /** Whether or not this attachment can be installed [only true for APKs] */
    public final boolean mAllowInstall;
    /** Reason(s) why this attachment is denied from being viewed */
    public final int mDenyFlags;

    public AttachmentInfo(Context context, Attachment attachment) {
        this(context, attachment.mId, attachment.mSize, attachment.mFileName, attachment.mMimeType,
                attachment.mAccountKey, attachment.mFlags);
    }

    public AttachmentInfo(Context context, Cursor c) {
        this(context, c.getLong(COLUMN_ID), c.getLong(COLUMN_SIZE), c.getString(COLUMN_FILENAME),
                c.getString(COLUMN_MIME_TYPE), c.getLong(COLUMN_ACCOUNT_KEY),
                c.getInt(COLUMN_FLAGS));
    }

    public AttachmentInfo(Context context, AttachmentInfo info) {
        this(context, info.mId, info.mSize, info.mName, info.mContentType, info.mAccountKey,
                info.mFlags);
    }

    public AttachmentInfo(Context context, long id, long size, String fileName, String mimeType,
            long accountKey, int flags) {
        mSize = size;
        mContentType = AttachmentUtilities.inferMimeType(fileName, mimeType);
        mName = fileName;
        mId = id;
        mAccountKey = accountKey;
        mFlags = flags;
        boolean canView = true;
        boolean canSave = true;
        boolean canInstall = false;
        int denyFlags = ALLOW;

        // Don't enable the ""save"" button if we've got no place to save the file
        if (!Utility.isExternalStorageMounted()) {
            canSave = false;
        }

        // Check for acceptable / unacceptable attachments by MIME-type
        if ((!MimeUtility.mimeTypeMatches(mContentType,
                AttachmentUtilities.ACCEPTABLE_ATTACHMENT_VIEW_TYPES)) ||
            (MimeUtility.mimeTypeMatches(mContentType,
                    AttachmentUtilities.UNACCEPTABLE_ATTACHMENT_VIEW_TYPES))) {
            canView = false;
        }

        // Check for unacceptable attachments by filename extension
        String extension = AttachmentUtilities.getFilenameExtension(mName);
        if (!TextUtils.isEmpty(extension) &&
                Utility.arrayContains(AttachmentUtilities.UNACCEPTABLE_ATTACHMENT_EXTENSIONS,
                        extension)) {
            canView = false;
            canSave = false;
            denyFlags |= DENY_MALWARE;
        }

        // Check for policy restrictions on download
        if ((flags & Attachment.FLAG_POLICY_DISALLOWS_DOWNLOAD) != 0) {
            canView = false;
            canSave = false;
            denyFlags |= DENY_POLICY;
        }

        // Check for installable attachments by filename extension
        extension = AttachmentUtilities.getFilenameExtension(mName);
        if (!TextUtils.isEmpty(extension) &&
                Utility.arrayContains(AttachmentUtilities.INSTALLABLE_ATTACHMENT_EXTENSIONS,
                        extension)) {
            boolean sideloadEnabled;
            sideloadEnabled = Settings.Secure.getInt(context.getContentResolver(),
                    Settings.Secure.INSTALL_NON_MARKET_APPS, 0 /* sideload disabled */) == 1;
            canSave &= sideloadEnabled;
            canView = canSave;
            canInstall = canSave;
            if (!sideloadEnabled) {
                denyFlags |= DENY_NOSIDELOAD;
            }
        }

        // Check for file size exceeded
        // The size limit is overridden when on a wifi connection - any size is OK
        if (mSize > AttachmentUtilities.MAX_ATTACHMENT_DOWNLOAD_SIZE) {
            int networkType = EmailConnectivityManager.getActiveNetworkType(context);
            if (networkType != ConnectivityManager.TYPE_WIFI) {
                canView = false;
                canSave = false;
                denyFlags |= DENY_WIFIONLY;
            }
        }

        // Check to see if any activities can view this attachment; if none, we can't view it
        Intent intent = getAttachmentIntent(context, 0);
        PackageManager pm = context.getPackageManager();
        List<ResolveInfo> activityList = pm.queryIntentActivities(intent, 0 /*no account*/);
        if (activityList.isEmpty()) {
            canView = false;
            canSave = false;
            denyFlags |= DENY_NOINTENT;
        }

        mAllowView = canView;
        mAllowSave = canSave;
        mAllowInstall = canInstall;
        mDenyFlags = denyFlags;
    }

    /**
     * Returns an <code>Intent</code> to load the given attachment.
     * @param context the caller's context
     * @param accountId the account associated with the attachment (or 0 if we don't need to
     *     resolve from attachmentUri to contentUri)
     * @return an Intent suitable for viewing the attachment
     */
    public Intent getAttachmentIntent(Context context, long accountId) {
        Uri contentUri = getUriForIntent(context, accountId);
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setDataAndType(contentUri, mContentType);
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        return intent;
    }

    protected Uri getUriForIntent(Context context, long accountId) {
        Uri contentUri = AttachmentUtilities.getAttachmentUri(accountId, mId);
        if (accountId > 0) {
            contentUri = AttachmentUtilities.resolveAttachmentIdToContentUri(
                    context.getContentResolver(), contentUri);
        }

        return contentUri;
    }

    /**
     * An attachment is eligible for download if it can either be viewed or saved (or both)
     * @return whether the attachment is eligible for download
     */
    public boolean isEligibleForDownload() {
        return mAllowView || mAllowSave;
    }

    @Override
    public int hashCode() {
        return (int) (mId ^ (mId >>> 32));
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }

        if ((o == null) || (o.getClass() != getClass())) {
            return false;
        }

        return ((AttachmentInfo) o).mId == mId;
    }

    @Override
    public String toString() {
        return ""{Attachment "" + mId + "":"" + mName + "","" + mContentType + "","" + mSize + ""}"";
    }
}
",False,268,1,1,12,40,4,5,L6
9,com.android.email.EmailAddressAdapter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.common.contacts.BaseEmailAddressAdapter;
import com.android.emailcommon.provider.Account;
import com.android.ex.chips.AccountSpecifier;

import android.content.Context;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;

/**
 * An adaptation of {@link BaseEmailAddressAdapter} for the Email app. The main
 * purpose of the class is to bind the generic implementation to the resources
 * defined locally: strings and layouts.
 */
public class EmailAddressAdapter extends BaseEmailAddressAdapter implements AccountSpecifier {

    private LayoutInflater mInflater;

    public EmailAddressAdapter(Context context) {
        super(context);
        mInflater = LayoutInflater.from(context);
    }

    @Override
    protected View inflateItemView(ViewGroup parent) {
        return mInflater.inflate(R.layout.recipient_dropdown_item, parent, false);
    }

    @Override
    protected View inflateItemViewLoading(ViewGroup parent) {
        return mInflater.inflate(R.layout.recipient_dropdown_item_loading, parent, false);
    }

    @Override
    protected void bindView(View view, String directoryType, String directoryName,
            String displayName, String emailAddress) {
      TextView text1 = (TextView)view.findViewById(R.id.text1);
      TextView text2 = (TextView)view.findViewById(R.id.text2);
      text1.setText(displayName);
      text2.setText(emailAddress);
    }

    @Override
    protected void bindViewLoading(View view, String directoryType, String directoryName) {
        TextView text1 = (TextView)view.findViewById(R.id.text1);
        String text = getContext().getString(R.string.gal_searching_fmt,
                TextUtils.isEmpty(directoryName) ? directoryType : directoryName);
        text1.setText(text);
    }

    /**
     * Set the account when known. Causes the search to prioritize contacts
     * from that account.
     */
    public void setAccount(Account account) {
        if (account != null) {
            // TODO: figure out how to infer the contacts account type from the email account
            super.setAccount(new android.accounts.Account(account.mEmailAddress, ""unknown""));
        }
    }
}
",False,159,7,63,4,5,1,1,L6
10,com.android.email.EmailConnectivityManager.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.content.BroadcastReceiver;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.NetworkInfo;
import android.net.NetworkInfo.State;
import android.os.Bundle;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.util.Log;

/**
 * Encapsulates functionality of ConnectivityManager for use in the Email application.  In
 * particular, this class provides callbacks for connectivity lost, connectivity restored, and
 * background setting changed, as well as providing a method that waits for connectivity
 * to be available without holding a wake lock
 *
 * To use, EmailConnectivityManager mgr = new EmailConnectivityManager(context, ""Name"");
 * When done, mgr.unregister() to unregister the internal receiver
 *
 * TODO: Use this class in ExchangeService
 */
public class EmailConnectivityManager extends BroadcastReceiver {
    private static final String TAG = ""EmailConnectivityManager"";

    // Loop time while waiting (stopgap in case we don't get a broadcast)
    private static final int CONNECTIVITY_WAIT_TIME = 10*60*1000;

    // Sentinel value for ""no active network""
    public static final int NO_ACTIVE_NETWORK = -1;

    // The name of this manager (used for logging)
    private final String mName;
    // The monitor lock we use while waiting for connectivity
    private final Object mLock = new Object();
    // The instantiator's context
    private final Context mContext;
    // The wake lock used while running (so we don't fall asleep during execution/callbacks)
    private final WakeLock mWakeLock;
    private final android.net.ConnectivityManager mConnectivityManager;

    // Set when we abort waitForConnectivity() via stopWait
    private boolean mStop = false;
    // The thread waiting for connectivity
    private Thread mWaitThread;
    // Whether or not we're registered with the system connectivity manager
    private boolean mRegistered = true;

    public EmailConnectivityManager(Context context, String name)  {
        mContext = context;
        mName = name;
        mConnectivityManager =
            (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
        PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, name);
        mContext.registerReceiver(this, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));
    }

    public boolean isAutoSyncAllowed() {
        return ContentResolver.getMasterSyncAutomatically();
    }

    public void stopWait() {
        mStop = true;
        Thread thread= mWaitThread;
        if (thread != null) {
            thread.interrupt();
        }
    }

    /**
     * Called when network connectivity has been restored; this method should be overridden by
     * subclasses as necessary. NOTE: CALLED ON UI THREAD
     * @param networkType as defined by ConnectivityManager
     */
    public void onConnectivityRestored(int networkType) {
    }

    /**
     * Called when network connectivity has been lost; this method should be overridden by
     * subclasses as necessary. NOTE: CALLED ON UI THREAD
     * @param networkType as defined by ConnectivityManager
     */
    public void onConnectivityLost(int networkType) {
    }

    public void unregister() {
        try {
            mContext.unregisterReceiver(this);
        } catch (RuntimeException e) {
            // Don't crash if we didn't register
        } finally {
            mRegistered = false;
        }
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent.getAction().equals(ConnectivityManager.CONNECTIVITY_ACTION)) {
            Bundle extras = intent.getExtras();
            if (extras != null) {
                NetworkInfo networkInfo =
                    (NetworkInfo)extras.get(ConnectivityManager.EXTRA_NETWORK_INFO);
                if (networkInfo == null) return;
                State state = networkInfo.getState();
                if (state == State.CONNECTED) {
                    synchronized (mLock) {
                        mLock.notifyAll();
                    }
                    onConnectivityRestored(networkInfo.getType());
                } else if (state == State.DISCONNECTED) {
                    onConnectivityLost(networkInfo.getType());
                }
            }
        }
    }

    /**
     * Request current connectivity status
     * @return whether there is connectivity at this time
     */
    public boolean hasConnectivity() {
        NetworkInfo info = mConnectivityManager.getActiveNetworkInfo();
        return (info != null);
    }

    /**
     * Get the type of the currently active data network
     * @return the type of the active network (or NO_ACTIVE_NETWORK)
     */
    public int getActiveNetworkType() {
        return getActiveNetworkType(mConnectivityManager);
    }

    static public int getActiveNetworkType(Context context) {
        ConnectivityManager cm =
            (ConnectivityManager)context.getSystemService(Context.CONNECTIVITY_SERVICE);
        return getActiveNetworkType(cm);
    }

    static public int getActiveNetworkType(ConnectivityManager cm) {
        NetworkInfo info = cm.getActiveNetworkInfo();
        if (info == null) return NO_ACTIVE_NETWORK;
        return info.getType();
    }

    public void waitForConnectivity() {
        // If we're unregistered, throw an exception
        if (!mRegistered) {
            throw new IllegalStateException(""ConnectivityManager not registered"");
        }
        boolean waiting = false;
        mWaitThread = Thread.currentThread();
        // Acquire the wait lock while we work
        mWakeLock.acquire();
        try {
            while (!mStop) {
                NetworkInfo info = mConnectivityManager.getActiveNetworkInfo();
                if (info != null) {
                    // We're done if there's an active network
                    if (waiting) {
                        if (Email.DEBUG) {
                            Log.d(TAG, mName + "": Connectivity wait ended"");
                        }
                    }
                    return;
                } else {
                    if (!waiting) {
                        if (Email.DEBUG) {
                            Log.d(TAG, mName + "": Connectivity waiting..."");
                        }
                        waiting = true;
                    }
                    // Wait until a network is connected (or 10 mins), but let the device sleep
                    synchronized (mLock) {
                        // Don't hold a lock during our wait
                        mWakeLock.release();
                        try {
                            mLock.wait(CONNECTIVITY_WAIT_TIME);
                        } catch (InterruptedException e) {
                            // This is fine; we just go around the loop again
                        }
                        // Get the lock back and check again for connectivity
                        mWakeLock.acquire();
                    }
                }
            }
        } finally {
            // Make sure we always release the wait lock
            if (mWakeLock.isHeld()) {
                mWakeLock.release();
            }
            mWaitThread = null;
        }
    }
}
",True,268,1,1,11,49,3,1,L6
11,com.android.email.Email.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.app.Application;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.util.Log;

import com.android.email.activity.MessageCompose;
import com.android.email.activity.ShortcutPicker;
import com.android.email.service.AttachmentDownloadService;
import com.android.email.service.MailService;
import com.android.email.widget.WidgetConfiguration;
import com.android.emailcommon.Logging;
import com.android.emailcommon.TempDirectory;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;

public class Email extends Application {
    /**
     * If this is enabled there will be additional logging information sent to
     * Log.d, including protocol dumps.
     *
     * This should only be used for logs that are useful for debbuging user problems,
     * not for internal/development logs.
     *
     * This can be enabled by typing ""debug"" in the AccountFolderList activity.
     * Changing the value to 'true' here will likely have no effect at all!
     *
     * TODO: rename this to sUserDebug, and rename LOGD below to DEBUG.
     */
    public static boolean DEBUG;

    // Exchange debugging flags (passed to Exchange, when available, via EmailServiceProxy)
    public static boolean DEBUG_EXCHANGE;
    public static boolean DEBUG_EXCHANGE_VERBOSE;
    public static boolean DEBUG_EXCHANGE_FILE;

    /**
     * If true, inhibit hardware graphics acceleration in UI (for a/b testing)
     */
    public static boolean sDebugInhibitGraphicsAcceleration = false;

    /**
     * Specifies how many messages will be shown in a folder by default. This number is set
     * on each new folder and can be incremented with ""Load more messages..."" by the
     * VISIBLE_LIMIT_INCREMENT
     */
    public static final int VISIBLE_LIMIT_DEFAULT = 25;

    /**
     * Number of additional messages to load when a user selects ""Load more messages...""
     */
    public static final int VISIBLE_LIMIT_INCREMENT = 25;

    /**
     * This is used to force stacked UI to return to the ""welcome"" screen any time we change
     * the accounts list (e.g. deleting accounts in the Account Manager preferences.)
     */
    private static boolean sAccountsChangedNotification = false;

    private static String sMessageDecodeErrorString;

    private static Thread sUiThread;

    /**
     * Asynchronous version of {@link #setServicesEnabledSync(Context)}.  Use when calling from
     * UI thread (or lifecycle entry points.)
     *
     * @param context
     */
    public static void setServicesEnabledAsync(final Context context) {
        EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
            public void run() {
                setServicesEnabledSync(context);
            }
        });
    }

    /**
     * Called throughout the application when the number of accounts has changed. This method
     * enables or disables the Compose activity, the boot receiver and the service based on
     * whether any accounts are configured.
     *
     * Blocking call - do not call from UI/lifecycle threads.
     *
     * @param context
     * @return true if there are any accounts configured.
     */
    public static boolean setServicesEnabledSync(Context context) {
        Cursor c = null;
        try {
            c = context.getContentResolver().query(
                    Account.CONTENT_URI,
                    Account.ID_PROJECTION,
                    null, null, null);
            boolean enable = c.getCount() > 0;
            setServicesEnabled(context, enable);
            return enable;
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }

    private static void setServicesEnabled(Context context, boolean enabled) {
        PackageManager pm = context.getPackageManager();
        if (!enabled && pm.getComponentEnabledSetting(
                new ComponentName(context, MailService.class)) ==
                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
            /*
             * If no accounts now exist but the service is still enabled we're about to disable it
             * so we'll reschedule to kill off any existing alarms.
             */
            MailService.actionReschedule(context);
        }
        pm.setComponentEnabledSetting(
                new ComponentName(context, MessageCompose.class),
                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);
        pm.setComponentEnabledSetting(
                new ComponentName(context, ShortcutPicker.class),
                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);
        pm.setComponentEnabledSetting(
                new ComponentName(context, MailService.class),
                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);
        pm.setComponentEnabledSetting(
                new ComponentName(context, AttachmentDownloadService.class),
                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);
        if (enabled && pm.getComponentEnabledSetting(
                new ComponentName(context, MailService.class)) ==
                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED) {
            /*
             * And now if accounts do exist then we've just enabled the service and we want to
             * schedule alarms for the new accounts.
             */
            MailService.actionReschedule(context);
        }

        pm.setComponentEnabledSetting(
                new ComponentName(context, WidgetConfiguration.class),
                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED :
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);

        // Start/stop the various services depending on whether there are any accounts
        startOrStopService(enabled, context, new Intent(context, AttachmentDownloadService.class));
        NotificationController.getInstance(context).watchForMessages(enabled);
    }

    /**
     * Starts or stops the service as necessary.
     * @param enabled If {@code true}, the service will be started. Otherwise, it will be stopped.
     * @param context The context to manage the service with.
     * @param intent The intent of the service to be managed.
     */
    private static void startOrStopService(boolean enabled, Context context, Intent intent) {
        if (enabled) {
            context.startService(intent);
        } else {
            context.stopService(intent);
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
        sUiThread = Thread.currentThread();
        Preferences prefs = Preferences.getPreferences(this);
        DEBUG = prefs.getEnableDebugLogging();
        sDebugInhibitGraphicsAcceleration = prefs.getInhibitGraphicsAcceleration();
        enableStrictMode(prefs.getEnableStrictMode());
        TempDirectory.setTempDirectory(this);

        // Tie MailRefreshManager to the Controller.
        RefreshManager.getInstance(this);
        // Reset all accounts to default visible window
        Controller.getInstance(this).resetVisibleLimits();

        // Enable logging in the EAS service, so it starts up as early as possible.
        updateLoggingFlags(this);

        // Get a helper string used deep inside message decoders (which don't have context)
        sMessageDecodeErrorString = getString(R.string.message_decode_error);

        // Make sure all required services are running when the app is started (can prevent
        // issues after an adb sync/install)
        setServicesEnabledAsync(this);
    }

    /**
     * Load enabled debug flags from the preferences and update the EAS debug flag.
     */
    public static void updateLoggingFlags(Context context) {
        Preferences prefs = Preferences.getPreferences(context);
        int debugLogging = prefs.getEnableDebugLogging() ? EmailServiceProxy.DEBUG_BIT : 0;
        int verboseLogging =
            prefs.getEnableExchangeLogging() ? EmailServiceProxy.DEBUG_VERBOSE_BIT : 0;
        int fileLogging =
            prefs.getEnableExchangeFileLogging() ? EmailServiceProxy.DEBUG_FILE_BIT : 0;
        int enableStrictMode =
            prefs.getEnableStrictMode() ? EmailServiceProxy.DEBUG_ENABLE_STRICT_MODE : 0;
        int debugBits = debugLogging | verboseLogging | fileLogging | enableStrictMode;
        Controller.getInstance(context).serviceLogging(debugBits);
    }

    /**
     * Internal, utility method for logging.
     * The calls to log() must be guarded with ""if (Email.LOGD)"" for performance reasons.
     */
    public static void log(String message) {
        Log.d(Logging.LOG_TAG, message);
    }

    /**
     * Called by the accounts reconciler to notify that accounts have changed, or by  ""Welcome""
     * to clear the flag.
     * @param setFlag true to set the notification flag, false to clear it
     */
    public static synchronized void setNotifyUiAccountsChanged(boolean setFlag) {
        sAccountsChangedNotification = setFlag;
    }

    /**
     * Called from activity onResume() functions to check for an accounts-changed condition, at
     * which point they should finish() and jump to the Welcome activity.
     */
    public static synchronized boolean getNotifyUiAccountsChanged() {
        return sAccountsChangedNotification;
    }

    public static void warnIfUiThread() {
        if (Thread.currentThread().equals(sUiThread)) {
            Log.w(Logging.LOG_TAG, ""Method called on the UI thread"", new Exception(""STACK TRACE""));
        }
    }

    /**
     * Retrieve a simple string that can be used when message decoders encounter bad data.
     * This is provided here because the protocol decoders typically don't have mContext.
     */
    public static String getMessageDecodeErrorString() {
        return sMessageDecodeErrorString != null ? sMessageDecodeErrorString : """";
    }

    public static void enableStrictMode(boolean enabled) {
        Utility.enableStrictMode(enabled);
    }
}
",True,276,2,6,10,50,51,16,L6
12,com.android.email.PeekableInputStream.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that allows single byte ""peeks"" without consuming the byte. The
 * client of this stream can call peek() to see the next available byte in the stream
 * and a subsequent read will still return the peeked byte. 
 */
public class PeekableInputStream extends InputStream {
    private final InputStream mIn;
    private boolean mPeeked;
    private int mPeekedByte;

    public PeekableInputStream(InputStream in) {
        this.mIn = in;
    }

    @Override
    public int read() throws IOException {
        if (!mPeeked) {
            return mIn.read();
        } else {
            mPeeked = false;
            return mPeekedByte;
        }
    }

    public int peek() throws IOException {
        if (!mPeeked) {
            mPeekedByte = read();
            mPeeked = true;
        }
        return mPeekedByte;
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException {
        if (!mPeeked) {
            return mIn.read(b, offset, length);
        } else {
            b[0] = (byte)mPeekedByte;
            mPeeked = false;
            int r = mIn.read(b, offset + 1, length - 1);
            if (r == -1) {
                return 1;
            } else {
                return r + 1;
            }
        }
    }

    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    @Override
    public String toString() {
        return String.format(""PeekableInputStream(in=%s, peeked=%b, peekedByte=%d)"",
                mIn.toString(), mPeeked, mPeekedByte);
    }
}
",True,147,12,49,0,0,1,0,L6
13,com.android.email.Clock.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

/**
 * A class provide the current time (like {@link System#currentTimeMillis()}).
 * It's intended to be mocked out for unit tests.
 */
public class Clock {
    public static final Clock INSTANCE = new Clock();

    protected Clock() {
    }

    public long getTime() {
        return System.currentTimeMillis();
    }
}
",False,152,7,52,0,0,9,0,L1
14,com.android.email.MessagingExceptionStrings.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.mail.MessagingException;

import android.content.Context;

/**
 * @return the error message associated with this exception.
 */
public class MessagingExceptionStrings {
    public static String getErrorString(Context context, MessagingException e) {
        return context.getResources().getString(getErrorStringResourceId(e));
    }

    /**
     * @return the resource ID of the error message associated with this exception.
     */
    private static int getErrorStringResourceId(MessagingException e) {
        switch (e.getExceptionType()) {
            case MessagingException.IOERROR:
                return R.string.account_setup_failed_ioerror;
            case MessagingException.ATTACHMENT_NOT_FOUND:
                return R.string.attachment_not_found;
            case MessagingException.TLS_REQUIRED:
                return R.string.account_setup_failed_tls_required;
            case MessagingException.AUTH_REQUIRED:
                return R.string.account_setup_failed_auth_required;
            case MessagingException.GENERAL_SECURITY:
                return R.string.account_setup_failed_security;
                // TODO Generate a unique string for this case, which is the case
                // where the security policy needs to be updated.
            case MessagingException.SECURITY_POLICIES_REQUIRED:
                return R.string.account_setup_failed_security;
            case MessagingException.ACCESS_DENIED:
                return R.string.account_setup_failed_access_denied;
            case MessagingException.CLIENT_CERTIFICATE_ERROR:
                return R.string.account_setup_failed_certificate_inaccessible;
        }
        return R.string.status_network_error; // default
    }
}
",False,148,7,57,1,1,3,1,L6
15,com.android.email.FixedLengthInputStream.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import java.io.IOException;
import java.io.InputStream;

/**
 * A filtering InputStream that stops allowing reads after the given length has been read. This
 * is used to allow a client to read directly from an underlying protocol stream without reading
 * past where the protocol handler intended the client to read. 
 */
public class FixedLengthInputStream extends InputStream {
    private final InputStream mIn;
    private final int mLength;
    private int mCount;

    public FixedLengthInputStream(InputStream in, int length) {
        this.mIn = in;
        this.mLength = length;
    }

    @Override
    public int available() throws IOException {
        return mLength - mCount;
    }

    @Override
    public int read() throws IOException {
        if (mCount < mLength) {
            mCount++;
            return mIn.read();
        } else {
            return -1;
        }
    }

    @Override
    public int read(byte[] b, int offset, int length) throws IOException {
        if (mCount < mLength) {
            int d = mIn.read(b, offset, Math.min(mLength - mCount, length));
            if (d == -1) {
                return -1;
            } else {
                mCount += d;
                return d;
            }
        } else {
            return -1;
        }
    }

    @Override
    public int read(byte[] b) throws IOException {
        return read(b, 0, b.length);
    }

    public int getLength() {
        return mLength;
    }

    @Override
    public String toString() {
        return String.format(""FixedLengthInputStream(in=%s, length=%d)"", mIn.toString(), mLength);
    }
}
",True,149,12,49,0,0,4,0,L6
16,com.android.email.RefreshManager.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.utility.Utility;

import android.content.Context;
import android.os.AsyncTask;
import android.os.Handler;
import android.util.Log;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;

/**
 * Class that handles ""refresh"" (and ""send pending messages"" for outboxes) related functionalities.
 *
 * <p>This class is responsible for two things:
 * <ul>
 *   <li>Taking refresh requests of mailbox-lists and message-lists and the ""send outgoing
 *       messages"" requests from UI, and calls appropriate methods of {@link Controller}.
 *       Note at this point the timer-based refresh
 *       (by {@link com.android.email.service.MailService}) uses {@link Controller} directly.
 *   <li>Keeping track of which mailbox list/message list is actually being refreshed.
 * </ul>
 * Refresh requests will be ignored if a request to the same target is already requested, or is
 * already being refreshed.
 *
 * <p>Conceptually it can be a part of {@link Controller}, but extracted for easy testing.
 *
 * (All public methods must be called on the UI thread.  All callbacks will be called on the UI
 * thread.)
 */
public class RefreshManager {
    private static final boolean LOG_ENABLED = false; // DONT SUBMIT WITH TRUE
    private static final long MAILBOX_AUTO_REFRESH_INTERVAL = 5 * 60 * 1000; // in milliseconds
    private static final long MAILBOX_LIST_AUTO_REFRESH_INTERVAL = 5 * 60 * 1000; // in milliseconds

    private static RefreshManager sInstance;

    private final Clock mClock;
    private final Context mContext;
    private final Controller mController;
    private final Controller.Result mControllerResult;

    /** Last error message */
    private String mErrorMessage;

    public interface Listener {
        /**
         * Refresh status of a mailbox list or a message list has changed.
         *
         * @param accountId ID of the account.
         * @param mailboxId -1 if it's about the mailbox list, or the ID of the mailbox list in
         * question.
         */
        public void onRefreshStatusChanged(long accountId, long mailboxId);

        /**
         * Error callback.
         *
         * @param accountId ID of the account, or -1 if unknown.
         * @param mailboxId ID of the mailbox, or -1 if unknown.
         * @param message error message which can be shown to the user.
         */
        public void onMessagingError(long accountId, long mailboxId, String message);
    }

    private final ArrayList<Listener> mListeners = new ArrayList<Listener>();

    /**
     * Status of a mailbox list/message list.
     */
    /* package */ static class Status {
        /**
         * True if a refresh of the mailbox is requested, and not finished yet.
         */
        private boolean mIsRefreshRequested;

        /**
         * True if the mailbox is being refreshed.
         *
         * Set true when {@link #onRefreshRequested} is called, i.e. refresh is requested by UI.
         * Note refresh can occur without a request from UI as well (e.g. timer based refresh).
         * In which case, {@link #mIsRefreshing} will be true with {@link #mIsRefreshRequested}
         * being false.
         */
        private boolean mIsRefreshing;

        private long mLastRefreshTime;

        public boolean isRefreshing() {
            return mIsRefreshRequested || mIsRefreshing;
        }

        public boolean canRefresh() {
            return !isRefreshing();
        }

        public void onRefreshRequested() {
            mIsRefreshRequested = true;
        }

        public long getLastRefreshTime() {
            return mLastRefreshTime;
        }

        public void onCallback(MessagingException exception, int progress, Clock clock) {
            if (exception == null && progress == 0) {
                // Refresh started
                mIsRefreshing = true;
            } else if (exception != null || progress == 100) {
                // Refresh finished
                mIsRefreshing = false;
                mIsRefreshRequested = false;
                mLastRefreshTime = clock.getTime();
            }
        }
    }

    /**
     * Map of accounts/mailboxes to {@link Status}.
     */
    private static class RefreshStatusMap {
        private final HashMap<Long, Status> mMap = new HashMap<Long, Status>();

        public Status get(long id) {
            Status s = mMap.get(id);
            if (s == null) {
                s = new Status();
                mMap.put(id, s);
            }
            return s;
        }

        public boolean isRefreshingAny() {
            for (Status s : mMap.values()) {
                if (s.isRefreshing()) {
                    return true;
                }
            }
            return false;
        }
    }

    private final RefreshStatusMap mMailboxListStatus = new RefreshStatusMap();
    private final RefreshStatusMap mMessageListStatus = new RefreshStatusMap();

    /**
     * @return the singleton instance.
     */
    public static synchronized RefreshManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new RefreshManager(context, Controller.getInstance(context),
                    Clock.INSTANCE, new Handler());
        }
        return sInstance;
    }

    protected RefreshManager(Context context, Controller controller, Clock clock,
            Handler handler) {
        mClock = clock;
        mContext = context.getApplicationContext();
        mController = controller;
        mControllerResult = new ControllerResultUiThreadWrapper<ControllerResult>(
                handler, new ControllerResult());
        mController.addResultCallback(mControllerResult);
    }

    /**
     * MUST be called for mock instances.  (The actual instance is a singleton, so no cleanup
     * is necessary.)
     */
    public void cleanUpForTest() {
        mController.removeResultCallback(mControllerResult);
    }

    public void registerListener(Listener listener) {
        if (listener == null) {
            throw new IllegalArgumentException();
        }
        mListeners.add(listener);
    }

    public void unregisterListener(Listener listener) {
        if (listener == null) {
            throw new IllegalArgumentException();
        }
        mListeners.remove(listener);
    }

    /**
     * Refresh the mailbox list of an account.
     */
    public boolean refreshMailboxList(long accountId) {
        final Status status = mMailboxListStatus.get(accountId);
        if (!status.canRefresh()) return false;

        if (LOG_ENABLED) {
            Log.d(Logging.LOG_TAG, ""refreshMailboxList "" + accountId);
        }
        status.onRefreshRequested();
        notifyRefreshStatusChanged(accountId, -1);
        mController.updateMailboxList(accountId);
        return true;
    }

    public boolean isMailboxStale(long mailboxId) {
        return mClock.getTime() >= (mMessageListStatus.get(mailboxId).getLastRefreshTime()
                + MAILBOX_AUTO_REFRESH_INTERVAL);
    }

    public boolean isMailboxListStale(long accountId) {
        return mClock.getTime() >= (mMailboxListStatus.get(accountId).getLastRefreshTime()
                + MAILBOX_LIST_AUTO_REFRESH_INTERVAL);
    }

    /**
     * Refresh messages in a mailbox.
     */
    public boolean refreshMessageList(long accountId, long mailboxId, boolean userRequest) {
        return refreshMessageList(accountId, mailboxId, false, userRequest);
    }

    /**
     * ""load more messages"" in a mailbox.
     */
    public boolean loadMoreMessages(long accountId, long mailboxId) {
        return refreshMessageList(accountId, mailboxId, true, true);
    }

    private boolean refreshMessageList(long accountId, long mailboxId, boolean loadMoreMessages,
            boolean userRequest) {
        final Status status = mMessageListStatus.get(mailboxId);
        if (!status.canRefresh()) return false;

        if (LOG_ENABLED) {
            Log.d(Logging.LOG_TAG, ""refreshMessageList "" + accountId + "", "" + mailboxId + "", ""
                    + loadMoreMessages);
        }
        status.onRefreshRequested();
        notifyRefreshStatusChanged(accountId, mailboxId);
        if (loadMoreMessages) {
            mController.loadMoreMessages(mailboxId);
        } else {
            mController.updateMailbox(accountId, mailboxId, userRequest);
        }
        return true;
    }

    /**
     * Send pending messages.
     */
    public boolean sendPendingMessages(long accountId) {
        if (LOG_ENABLED) {
            Log.d(Logging.LOG_TAG, ""sendPendingMessages "" + accountId);
        }
        notifyRefreshStatusChanged(accountId, -1);
        mController.sendPendingMessages(accountId);
        return true;
    }

    /**
     * Call {@link #sendPendingMessages} for all accounts.
     */
    public void sendPendingMessagesForAllAccounts() {
        if (LOG_ENABLED) {
            Log.d(Logging.LOG_TAG, ""sendPendingMessagesForAllAccounts"");
        }
        new SendPendingMessagesForAllAccountsImpl()
                .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }

    private class SendPendingMessagesForAllAccountsImpl extends Utility.ForEachAccount {
        public SendPendingMessagesForAllAccountsImpl() {
            super(mContext);
        }

        @Override
        protected void performAction(long accountId) {
            sendPendingMessages(accountId);
        }
    }

    public long getLastMailboxListRefreshTime(long accountId) {
        return mMailboxListStatus.get(accountId).getLastRefreshTime();
    }

    public long getLastMessageListRefreshTime(long mailboxId) {
        return mMessageListStatus.get(mailboxId).getLastRefreshTime();
    }

    public boolean isMailboxListRefreshing(long accountId) {
        return mMailboxListStatus.get(accountId).isRefreshing();
    }

    public boolean isMessageListRefreshing(long mailboxId) {
        return mMessageListStatus.get(mailboxId).isRefreshing();
    }

    public boolean isRefreshingAnyMailboxListForTest() {
        return mMailboxListStatus.isRefreshingAny();
    }

    public boolean isRefreshingAnyMessageListForTest() {
        return mMessageListStatus.isRefreshingAny();
    }

    public String getErrorMessage() {
        return mErrorMessage;
    }

    private void notifyRefreshStatusChanged(long accountId, long mailboxId) {
        for (Listener l : mListeners) {
            l.onRefreshStatusChanged(accountId, mailboxId);
        }
    }

    private void reportError(long accountId, long mailboxId, String errorMessage) {
        mErrorMessage = errorMessage;
        for (Listener l : mListeners) {
            l.onMessagingError(accountId, mailboxId, mErrorMessage);
        }
    }

    /* package */ Collection<Listener> getListenersForTest() {
        return mListeners;
    }

    /* package */ Status getMailboxListStatusForTest(long accountId) {
        return mMailboxListStatus.get(accountId);
    }

    /* package */ Status getMessageListStatusForTest(long mailboxId) {
        return mMessageListStatus.get(mailboxId);
    }

    private class ControllerResult extends Controller.Result {
        private boolean mSendMailExceptionReported = false;

        private String exceptionToString(MessagingException exception) {
            if (exception == null) {
                return ""(no exception)"";
            } else {
                return MessagingExceptionStrings.getErrorString(mContext, exception);
            }
        }

        /**
         * Callback for mailbox list refresh.
         */
        @Override
        public void updateMailboxListCallback(MessagingException exception, long accountId,
                int progress) {
            if (LOG_ENABLED) {
                Log.d(Logging.LOG_TAG, ""updateMailboxListCallback "" + accountId + "", "" + progress
                        + "", "" + exceptionToString(exception));
            }
            mMailboxListStatus.get(accountId).onCallback(exception, progress, mClock);
            if (exception != null) {
                reportError(accountId, -1,
                        MessagingExceptionStrings.getErrorString(mContext, exception));
            }
            notifyRefreshStatusChanged(accountId, -1);
        }

        /**
         * Callback for explicit (user-driven) mailbox refresh.
         */
        @Override
        public void updateMailboxCallback(MessagingException exception, long accountId,
                long mailboxId, int progress, int dontUseNumNewMessages,
                ArrayList<Long> addedMessages) {
            if (LOG_ENABLED) {
                Log.d(Logging.LOG_TAG, ""updateMailboxCallback "" + accountId + "", ""
                        + mailboxId + "", "" + progress + "", "" + exceptionToString(exception));
            }
            updateMailboxCallbackInternal(exception, accountId, mailboxId, progress, 0);
        }

        /**
         * Callback for implicit (timer-based) mailbox refresh.
         *
         * Do the same as {@link #updateMailboxCallback}.
         * TODO: Figure out if it's really okay to do the same as updateMailboxCallback.
         * If both the explicit refresh and the implicit refresh can run at the same time,
         * we need to keep track of their status separately.
         */
        @Override
        public void serviceCheckMailCallback(
                MessagingException exception, long accountId, long mailboxId, int progress,
                long tag) {
            if (LOG_ENABLED) {
                Log.d(Logging.LOG_TAG, ""serviceCheckMailCallback "" + accountId + "", ""
                        + mailboxId + "", "" + progress + "", "" + exceptionToString(exception));
            }
            updateMailboxCallbackInternal(exception, accountId, mailboxId, progress, 0);
        }

        private void updateMailboxCallbackInternal(MessagingException exception, long accountId,
                long mailboxId, int progress, int dontUseNumNewMessages) {
            // Don't use dontUseNumNewMessages.  serviceCheckMailCallback() don't set it.
            mMessageListStatus.get(mailboxId).onCallback(exception, progress, mClock);
            if (exception != null) {
                reportError(accountId, mailboxId,
                        MessagingExceptionStrings.getErrorString(mContext, exception));
            }
            notifyRefreshStatusChanged(accountId, mailboxId);
        }


        /**
         * Send message progress callback.
         *
         * We don't keep track of the status of outboxes, but we monitor this to catch
         * errors.
         */
        @Override
        public void sendMailCallback(MessagingException exception, long accountId, long messageId,
                int progress) {
            if (LOG_ENABLED) {
                Log.d(Logging.LOG_TAG, ""sendMailCallback "" + accountId + "", ""
                        + messageId + "", "" + progress + "", "" + exceptionToString(exception));
            }
            if (progress == 0 && messageId == -1) {
                mSendMailExceptionReported = false;
            }
            if (exception != null && !mSendMailExceptionReported) {
                // Only the first error in a batch will be reported.
                mSendMailExceptionReported = true;
                reportError(accountId, messageId,
                        MessagingExceptionStrings.getErrorString(mContext, exception));
            }
            if (progress == 100) {
                mSendMailExceptionReported = false;
            }
        }
    }
}
",False,269,1,2,10,46,9,7,L6
17,com.android.email.MessagingController.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.net.TrafficStats;
import android.net.Uri;
import android.os.Process;
import android.text.TextUtils;
import android.util.Log;

import com.android.email.mail.Sender;
import com.android.email.mail.Store;
import com.android.emailcommon.Logging;
import com.android.emailcommon.TrafficFlags;
import com.android.emailcommon.internet.MimeBodyPart;
import com.android.emailcommon.internet.MimeHeader;
import com.android.emailcommon.internet.MimeMultipart;
import com.android.emailcommon.internet.MimeUtility;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.FetchProfile;
import com.android.emailcommon.mail.Flag;
import com.android.emailcommon.mail.Folder;
import com.android.emailcommon.mail.Folder.FolderType;
import com.android.emailcommon.mail.Folder.MessageRetrievalListener;
import com.android.emailcommon.mail.Folder.MessageUpdateCallbacks;
import com.android.emailcommon.mail.Folder.OpenMode;
import com.android.emailcommon.mail.Message;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.mail.Part;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.AttachmentColumns;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.EmailContent.SyncColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.SearchParams;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.emailcommon.utility.ConversionUtilities;
import com.android.emailcommon.utility.Utility;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Starts a long running (application) Thread that will run through commands
 * that require remote mailbox access. This class is used to serialize and
 * prioritize these commands. Each method that will submit a command requires a
 * MessagingListener instance to be provided. It is expected that that listener
 * has also been added as a registered listener using addListener(). When a
 * command is to be executed, if the listener that was provided with the command
 * is no longer registered the command is skipped. The design idea for the above
 * is that when an Activity starts it registers as a listener. When it is paused
 * it removes itself. Thus, any commands that that activity submitted are
 * removed from the queue once the activity is no longer active.
 */
public class MessagingController implements Runnable {

    /**
     * The maximum message size that we'll consider to be ""small"". A small message is downloaded
     * in full immediately instead of in pieces. Anything over this size will be downloaded in
     * pieces with attachments being left off completely and downloaded on demand.
     *
     *
     * 25k for a ""small"" message was picked by educated trial and error.
     * http://answers.google.com/answers/threadview?id=312463 claims that the
     * average size of an email is 59k, which I feel is too large for our
     * blind download. The following tests were performed on a download of
     * 25 random messages.
     * <pre>
     * 5k - 61 seconds,
     * 25k - 51 seconds,
     * 55k - 53 seconds,
     * </pre>
     * So 25k gives good performance and a reasonable data footprint. Sounds good to me.
     */
    private static final int MAX_SMALL_MESSAGE_SIZE = (25 * 1024);

    private static final Flag[] FLAG_LIST_SEEN = new Flag[] { Flag.SEEN };
    private static final Flag[] FLAG_LIST_FLAGGED = new Flag[] { Flag.FLAGGED };
    private static final Flag[] FLAG_LIST_ANSWERED = new Flag[] { Flag.ANSWERED };

    /**
     * We write this into the serverId field of messages that will never be upsynced.
     */
    private static final String LOCAL_SERVERID_PREFIX = ""Local-"";

    /**
     * Cache search results by account; this allows for ""load more"" support without having to
     * redo the search (which can be quite slow).  SortableMessage is a smallish class, so memory
     * shouldn't be an issue
     */
    private static final HashMap<Long, SortableMessage[]> sSearchResults =
        new HashMap<Long, SortableMessage[]>();

    private static final ContentValues PRUNE_ATTACHMENT_CV = new ContentValues();
    static {
        PRUNE_ATTACHMENT_CV.putNull(AttachmentColumns.CONTENT_URI);
    }

    private static MessagingController sInstance = null;
    private final BlockingQueue<Command> mCommands = new LinkedBlockingQueue<Command>();
    private final Thread mThread;

    /**
     * All access to mListeners *must* be synchronized
     */
    private final GroupMessagingListener mListeners = new GroupMessagingListener();
    private boolean mBusy;
    private final Context mContext;
    private final Controller mController;

    /**
     * Simple cache for last search result mailbox by account and serverId, since the most common
     * case will be repeated use of the same mailbox
     */
    private long mLastSearchAccountKey = Account.NO_ACCOUNT;
    private String mLastSearchServerId = null;
    private Mailbox mLastSearchRemoteMailbox = null;

    protected MessagingController(Context _context, Controller _controller) {
        mContext = _context.getApplicationContext();
        mController = _controller;
        mThread = new Thread(this);
        mThread.start();
    }

    /**
     * Gets or creates the singleton instance of MessagingController. Application is used to
     * provide a Context to classes that need it.
     */
    public synchronized static MessagingController getInstance(Context _context,
            Controller _controller) {
        if (sInstance == null) {
            sInstance = new MessagingController(_context, _controller);
        }
        return sInstance;
    }

    /**
     * Inject a mock controller.  Used only for testing.  Affects future calls to getInstance().
     */
    public static void injectMockController(MessagingController mockController) {
        sInstance = mockController;
    }

    // TODO: seems that this reading of mBusy isn't thread-safe
    public boolean isBusy() {
        return mBusy;
    }

    public void run() {
        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
        // TODO: add an end test to this infinite loop
        while (true) {
            Command command;
            try {
                command = mCommands.take();
            } catch (InterruptedException e) {
                continue; //re-test the condition on the eclosing while
            }
            if (command.listener == null || isActiveListener(command.listener)) {
                mBusy = true;
                command.runnable.run();
                mListeners.controllerCommandCompleted(mCommands.size() > 0);
            }
            mBusy = false;
        }
    }

    private void put(String description, MessagingListener listener, Runnable runnable) {
        try {
            Command command = new Command();
            command.listener = listener;
            command.runnable = runnable;
            command.description = description;
            mCommands.add(command);
        }
        catch (IllegalStateException ie) {
            throw new Error(ie);
        }
    }

    public void addListener(MessagingListener listener) {
        mListeners.addListener(listener);
    }

    public void removeListener(MessagingListener listener) {
        mListeners.removeListener(listener);
    }

    private boolean isActiveListener(MessagingListener listener) {
        return mListeners.isActiveListener(listener);
    }

    private static final int MAILBOX_COLUMN_ID = 0;
    private static final int MAILBOX_COLUMN_SERVER_ID = 1;
    private static final int MAILBOX_COLUMN_TYPE = 2;

    /** Small projection for just the columns required for a sync. */
    private static final String[] MAILBOX_PROJECTION = new String[] {
        MailboxColumns.ID,
        MailboxColumns.SERVER_ID,
        MailboxColumns.TYPE,
    };

    /**
     * Synchronize the folder list with the remote server. Synchronization occurs in the
     * background and results are passed through the {@link MessagingListener}. If the
     * given listener is not {@code null}, it must have been previously added to the set
     * of listeners using the {@link #addListener(MessagingListener)}. Otherwise, no
     * actions will be performed.
     *
     * TODO this needs to cache the remote folder list
     * TODO break out an inner listFoldersSynchronized which could simplify checkMail
     *
     * @param accountId ID of the account for which to list the folders
     * @param listener A listener to notify
     */
    void listFolders(final long accountId, MessagingListener listener) {
        final Account account = Account.restoreAccountWithId(mContext, accountId);
        if (account == null) {
            Log.i(Logging.LOG_TAG, ""Could not load account id "" + accountId
                    + "". Has it been removed?"");
            return;
        }
        mListeners.listFoldersStarted(accountId);
        put(""listFolders"", listener, new Runnable() {
            // TODO For now, mailbox addition occurs in the server-dependent store implementation,
            // but, mailbox removal occurs here. Instead, each store should be responsible for
            // content synchronization (addition AND removal) since each store will likely need
            // to implement it's own, unique synchronization methodology.
            public void run() {
                TrafficStats.setThreadStatsTag(TrafficFlags.getSyncFlags(mContext, account));
                Cursor localFolderCursor = null;
                try {
                    // Step 1: Get remote mailboxes
                    Store store = Store.getInstance(account, mContext);
                    Folder[] remoteFolders = store.updateFolders();
                    HashSet<String> remoteFolderNames = new HashSet<String>();
                    for (int i = 0, count = remoteFolders.length; i < count; i++) {
                        remoteFolderNames.add(remoteFolders[i].getName());
                    }

                    // Step 2: Get local mailboxes
                    localFolderCursor = mContext.getContentResolver().query(
                            Mailbox.CONTENT_URI,
                            MAILBOX_PROJECTION,
                            EmailContent.MailboxColumns.ACCOUNT_KEY + ""=?"",
                            new String[] { String.valueOf(account.mId) },
                            null);

                    // Step 3: Remove any local mailbox not on the remote list
                    while (localFolderCursor.moveToNext()) {
                        String mailboxPath = localFolderCursor.getString(MAILBOX_COLUMN_SERVER_ID);
                        // Short circuit if we have a remote mailbox with the same name
                        if (remoteFolderNames.contains(mailboxPath)) {
                            continue;
                        }

                        int mailboxType = localFolderCursor.getInt(MAILBOX_COLUMN_TYPE);
                        long mailboxId = localFolderCursor.getLong(MAILBOX_COLUMN_ID);
                        switch (mailboxType) {
                            case Mailbox.TYPE_INBOX:
                            case Mailbox.TYPE_DRAFTS:
                            case Mailbox.TYPE_OUTBOX:
                            case Mailbox.TYPE_SENT:
                            case Mailbox.TYPE_TRASH:
                            case Mailbox.TYPE_SEARCH:
                                // Never, ever delete special mailboxes
                                break;
                            default:
                                // Drop all attachment files related to this mailbox
                                AttachmentUtilities.deleteAllMailboxAttachmentFiles(
                                        mContext, accountId, mailboxId);
                                // Delete the mailbox; database triggers take care of related
                                // Message, Body and Attachment records
                                Uri uri = ContentUris.withAppendedId(
                                        Mailbox.CONTENT_URI, mailboxId);
                                mContext.getContentResolver().delete(uri, null, null);
                                break;
                        }
                    }
                    mListeners.listFoldersFinished(accountId);
                } catch (Exception e) {
                    mListeners.listFoldersFailed(accountId, e.toString());
                } finally {
                    if (localFolderCursor != null) {
                        localFolderCursor.close();
                    }
                }
            }
        });
    }

    /**
     * Start background synchronization of the specified folder.
     * @param account
     * @param folder
     * @param listener
     */
    public void synchronizeMailbox(final Account account,
            final Mailbox folder, MessagingListener listener) {
        /*
         * We don't ever sync the Outbox.
         */
        if (folder.mType == Mailbox.TYPE_OUTBOX) {
            return;
        }
        mListeners.synchronizeMailboxStarted(account.mId, folder.mId);
        put(""synchronizeMailbox"", listener, new Runnable() {
            public void run() {
                synchronizeMailboxSynchronous(account, folder);
            }
        });
    }

    /**
     * Start foreground synchronization of the specified folder. This is called by
     * synchronizeMailbox or checkMail.
     * TODO this should use ID's instead of fully-restored objects
     * @param account
     * @param folder
     */
    private void synchronizeMailboxSynchronous(final Account account,
            final Mailbox folder) {
        TrafficStats.setThreadStatsTag(TrafficFlags.getSyncFlags(mContext, account));
        mListeners.synchronizeMailboxStarted(account.mId, folder.mId);
        if ((folder.mFlags & Mailbox.FLAG_HOLDS_MAIL) == 0) {
            // We don't hold messages, so, nothing to synchronize
            mListeners.synchronizeMailboxFinished(account.mId, folder.mId, 0, 0, null);
            return;
        }
        NotificationController nc = NotificationController.getInstance(mContext);
        try {
            processPendingActionsSynchronous(account);

            // Select generic sync or store-specific sync
            SyncResults results = synchronizeMailboxGeneric(account, folder);
            // The account might have been deleted
            if (results == null) return;
            mListeners.synchronizeMailboxFinished(account.mId, folder.mId,
                                                  results.mTotalMessages,
                                                  results.mAddedMessages.size(),
                                                  results.mAddedMessages);
            // Clear authentication notification for this account
            nc.cancelLoginFailedNotification(account.mId);
        } catch (MessagingException e) {
            if (Logging.LOGD) {
                Log.v(Logging.LOG_TAG, ""synchronizeMailbox"", e);
            }
            if (e instanceof AuthenticationFailedException) {
                // Generate authentication notification
                nc.showLoginFailedNotification(account.mId);
            }
            mListeners.synchronizeMailboxFailed(account.mId, folder.mId, e);
        }
    }

    /**
     * Lightweight record for the first pass of message sync, where I'm just seeing if
     * the local message requires sync.  Later (for messages that need syncing) we'll do a full
     * readout from the DB.
     */
    private static class LocalMessageInfo {
        private static final int COLUMN_ID = 0;
        private static final int COLUMN_FLAG_READ = 1;
        private static final int COLUMN_FLAG_FAVORITE = 2;
        private static final int COLUMN_FLAG_LOADED = 3;
        private static final int COLUMN_SERVER_ID = 4;
        private static final int COLUMN_FLAGS =  7;
        private static final String[] PROJECTION = new String[] {
            EmailContent.RECORD_ID,
            MessageColumns.FLAG_READ, MessageColumns.FLAG_FAVORITE, MessageColumns.FLAG_LOADED,
            SyncColumns.SERVER_ID, MessageColumns.MAILBOX_KEY, MessageColumns.ACCOUNT_KEY,
            MessageColumns.FLAGS
        };

        final long mId;
        final boolean mFlagRead;
        final boolean mFlagFavorite;
        final int mFlagLoaded;
        final String mServerId;
        final int mFlags;

        public LocalMessageInfo(Cursor c) {
            mId = c.getLong(COLUMN_ID);
            mFlagRead = c.getInt(COLUMN_FLAG_READ) != 0;
            mFlagFavorite = c.getInt(COLUMN_FLAG_FAVORITE) != 0;
            mFlagLoaded = c.getInt(COLUMN_FLAG_LOADED);
            mServerId = c.getString(COLUMN_SERVER_ID);
            mFlags = c.getInt(COLUMN_FLAGS);
            // Note: mailbox key and account key not needed - they are projected for the SELECT
        }
    }

    private void saveOrUpdate(EmailContent content, Context context) {
        if (content.isSaved()) {
            content.update(context, content.toContentValues());
        } else {
            content.save(context);
        }
    }

    /**
     * Load the structure and body of messages not yet synced
     * @param account the account we're syncing
     * @param remoteFolder the (open) Folder we're working on
     * @param unsyncedMessages an array of Message's we've got headers for
     * @param toMailbox the destination mailbox we're syncing
     * @throws MessagingException
     */
    void loadUnsyncedMessages(final Account account, Folder remoteFolder,
            ArrayList<Message> unsyncedMessages, final Mailbox toMailbox)
            throws MessagingException {

        // 1. Divide the unsynced messages into small & large (by size)

        // TODO doing this work here (synchronously) is problematic because it prevents the UI
        // from affecting the order (e.g. download a message because the user requested it.)  Much
        // of this logic should move out to a different sync loop that attempts to update small
        // groups of messages at a time, as a background task.  However, we can't just return
        // (yet) because POP messages don't have an envelope yet....

        ArrayList<Message> largeMessages = new ArrayList<Message>();
        ArrayList<Message> smallMessages = new ArrayList<Message>();
        for (Message message : unsyncedMessages) {
            if (message.getSize() > (MAX_SMALL_MESSAGE_SIZE)) {
                largeMessages.add(message);
            } else {
                smallMessages.add(message);
            }
        }

        // 2. Download small messages

        // TODO Problems with this implementation.  1. For IMAP, where we get a real envelope,
        // this is going to be inefficient and duplicate work we've already done.  2.  It's going
        // back to the DB for a local message that we already had (and discarded).

        // For small messages, we specify ""body"", which returns everything (incl. attachments)
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.BODY);
        remoteFolder.fetch(smallMessages.toArray(new Message[smallMessages.size()]), fp,
                new MessageRetrievalListener() {
                    public void messageRetrieved(Message message) {
                        // Store the updated message locally and mark it fully loaded
                        copyOneMessageToProvider(message, account, toMailbox,
                                EmailContent.Message.FLAG_LOADED_COMPLETE);
                    }

                    @Override
                    public void loadAttachmentProgress(int progress) {
                    }
        });

        // 3. Download large messages.  We ask the server to give us the message structure,
        // but not all of the attachments.
        fp.clear();
        fp.add(FetchProfile.Item.STRUCTURE);
        remoteFolder.fetch(largeMessages.toArray(new Message[largeMessages.size()]), fp, null);
        for (Message message : largeMessages) {
            if (message.getBody() == null) {
                // POP doesn't support STRUCTURE mode, so we'll just do a partial download
                // (hopefully enough to see some/all of the body) and mark the message for
                // further download.
                fp.clear();
                fp.add(FetchProfile.Item.BODY_SANE);
                //  TODO a good optimization here would be to make sure that all Stores set
                //  the proper size after this fetch and compare the before and after size. If
                //  they equal we can mark this SYNCHRONIZED instead of PARTIALLY_SYNCHRONIZED
                remoteFolder.fetch(new Message[] { message }, fp, null);

                // Store the partially-loaded message and mark it partially loaded
                copyOneMessageToProvider(message, account, toMailbox,
                        EmailContent.Message.FLAG_LOADED_PARTIAL);
            } else {
                // We have a structure to deal with, from which
                // we can pull down the parts we want to actually store.
                // Build a list of parts we are interested in. Text parts will be downloaded
                // right now, attachments will be left for later.
                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);
                // Download the viewables immediately
                for (Part part : viewables) {
                    fp.clear();
                    fp.add(part);
                    // TODO what happens if the network connection dies? We've got partial
                    // messages with incorrect status stored.
                    remoteFolder.fetch(new Message[] { message }, fp, null);
                }
                // Store the updated message locally and mark it fully loaded
                copyOneMessageToProvider(message, account, toMailbox,
                        EmailContent.Message.FLAG_LOADED_COMPLETE);
            }
        }

    }

    public void downloadFlagAndEnvelope(final Account account, final Mailbox mailbox,
            Folder remoteFolder, ArrayList<Message> unsyncedMessages,
            HashMap<String, LocalMessageInfo> localMessageMap, final ArrayList<Long> unseenMessages)
            throws MessagingException {
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.FLAGS);
        fp.add(FetchProfile.Item.ENVELOPE);

        final HashMap<String, LocalMessageInfo> localMapCopy;
        if (localMessageMap != null)
            localMapCopy = new HashMap<String, LocalMessageInfo>(localMessageMap);
        else {
            localMapCopy = new HashMap<String, LocalMessageInfo>();
        }

        remoteFolder.fetch(unsyncedMessages.toArray(new Message[0]), fp,
                new MessageRetrievalListener() {
                    @Override
                    public void messageRetrieved(Message message) {
                        try {
                            // Determine if the new message was already known (e.g. partial)
                            // And create or reload the full message info
                            LocalMessageInfo localMessageInfo =
                                localMapCopy.get(message.getUid());
                            EmailContent.Message localMessage = null;
                            if (localMessageInfo == null) {
                                localMessage = new EmailContent.Message();
                            } else {
                                localMessage = EmailContent.Message.restoreMessageWithId(
                                        mContext, localMessageInfo.mId);
                            }

                            if (localMessage != null) {
                                try {
                                    // Copy the fields that are available into the message
                                    LegacyConversions.updateMessageFields(localMessage,
                                            message, account.mId, mailbox.mId);
                                    // Commit the message to the local store
                                    saveOrUpdate(localMessage, mContext);
                                    // Track the ""new"" ness of the downloaded message
                                    if (!message.isSet(Flag.SEEN) && unseenMessages != null) {
                                        unseenMessages.add(localMessage.mId);
                                    }
                                } catch (MessagingException me) {
                                    Log.e(Logging.LOG_TAG,
                                            ""Error while copying downloaded message."" + me);
                                }

                            }
                        }
                        catch (Exception e) {
                            Log.e(Logging.LOG_TAG,
                                    ""Error while storing downloaded message."" + e.toString());
                        }
                    }

                    @Override
                    public void loadAttachmentProgress(int progress) {
                    }
                });

    }

    /**
     * A message and numeric uid that's easily sortable
     */
    private static class SortableMessage {
        private final Message mMessage;
        private final long mUid;

        SortableMessage(Message message, long uid) {
            mMessage = message;
            mUid = uid;
        }
    }

    public int searchMailbox(long accountId, SearchParams searchParams, long destMailboxId)
            throws MessagingException {
        try {
            return searchMailboxImpl(accountId, searchParams, destMailboxId);
        } finally {
            // Tell UI that we're done loading any search results (no harm calling this even if we
            // encountered an error or never sent a ""started"" message)
            mListeners.synchronizeMailboxFinished(accountId, destMailboxId, 0, 0, null);
        }
    }

    private int searchMailboxImpl(long accountId, SearchParams searchParams,
            final long destMailboxId) throws MessagingException {
        final Account account = Account.restoreAccountWithId(mContext, accountId);
        final Mailbox mailbox = Mailbox.restoreMailboxWithId(mContext, searchParams.mMailboxId);
        final Mailbox destMailbox = Mailbox.restoreMailboxWithId(mContext, destMailboxId);
        if (account == null || mailbox == null || destMailbox == null) {
            Log.d(Logging.LOG_TAG, ""Attempted search for "" + searchParams
                    + "" but account or mailbox information was missing"");
            return 0;
        }

        // Tell UI that we're loading messages
        mListeners.synchronizeMailboxStarted(accountId, destMailbox.mId);

        Store remoteStore = Store.getInstance(account, mContext);
        Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);
        remoteFolder.open(OpenMode.READ_WRITE);

        SortableMessage[] sortableMessages = new SortableMessage[0];
        if (searchParams.mOffset == 0) {
            // Get the ""bare"" messages (basically uid)
            Message[] remoteMessages = remoteFolder.getMessages(searchParams, null);
            int remoteCount = remoteMessages.length;
            if (remoteCount > 0) {
                sortableMessages = new SortableMessage[remoteCount];
                int i = 0;
                for (Message msg : remoteMessages) {
                    sortableMessages[i++] = new SortableMessage(msg, Long.parseLong(msg.getUid()));
                }
                // Sort the uid's, most recent first
                // Note: Not all servers will be nice and return results in the order of request;
                // those that do will see messages arrive from newest to oldest
                Arrays.sort(sortableMessages, new Comparator<SortableMessage>() {
                    @Override
                    public int compare(SortableMessage lhs, SortableMessage rhs) {
                        return lhs.mUid > rhs.mUid ? -1 : lhs.mUid < rhs.mUid ? 1 : 0;
                    }
                });
                sSearchResults.put(accountId, sortableMessages);
            }
        } else {
            sortableMessages = sSearchResults.get(accountId);
        }

        final int numSearchResults = sortableMessages.length;
        final int numToLoad =
            Math.min(numSearchResults - searchParams.mOffset, searchParams.mLimit);
        if (numToLoad <= 0) {
            return 0;
        }

        final ArrayList<Message> messageList = new ArrayList<Message>();
        for (int i = searchParams.mOffset; i < numToLoad + searchParams.mOffset; i++) {
            messageList.add(sortableMessages[i].mMessage);
        }
        // Get everything in one pass, rather than two (as in sync); this starts getting us
        // usable results quickly.
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.FLAGS);
        fp.add(FetchProfile.Item.ENVELOPE);
        fp.add(FetchProfile.Item.STRUCTURE);
        fp.add(FetchProfile.Item.BODY_SANE);
        remoteFolder.fetch(messageList.toArray(new Message[0]), fp,
                new MessageRetrievalListener() {
            public void messageRetrieved(Message message) {
                try {
                    // Determine if the new message was already known (e.g. partial)
                    // And create or reload the full message info
                    EmailContent.Message localMessage = new EmailContent.Message();
                    try {
                        // Copy the fields that are available into the message
                        LegacyConversions.updateMessageFields(localMessage,
                                message, account.mId, mailbox.mId);
                        // Commit the message to the local store
                        saveOrUpdate(localMessage, mContext);
                        localMessage.mMailboxKey = destMailboxId;
                        // We load 50k or so; maybe it's complete, maybe not...
                        int flag = EmailContent.Message.FLAG_LOADED_COMPLETE;
                        // We store the serverId of the source mailbox into protocolSearchInfo
                        // This will be used by loadMessageForView, etc. to use the proper remote
                        // folder
                        localMessage.mProtocolSearchInfo = mailbox.mServerId;
                        if (message.getSize() > Store.FETCH_BODY_SANE_SUGGESTED_SIZE) {
                            flag = EmailContent.Message.FLAG_LOADED_PARTIAL;
                        }
                        copyOneMessageToProvider(message, localMessage, flag, mContext);
                    } catch (MessagingException me) {
                        Log.e(Logging.LOG_TAG,
                                ""Error while copying downloaded message."" + me);
                    }
                } catch (Exception e) {
                    Log.e(Logging.LOG_TAG,
                            ""Error while storing downloaded message."" + e.toString());
                }
            }

            @Override
            public void loadAttachmentProgress(int progress) {
            }
        });
        return numSearchResults;
    }


    /**
     * Generic synchronizer - used for POP3 and IMAP.
     *
     * TODO Break this method up into smaller chunks.
     *
     * @param account the account to sync
     * @param mailbox the mailbox to sync
     * @return results of the sync pass
     * @throws MessagingException
     */
    private SyncResults synchronizeMailboxGeneric(final Account account, final Mailbox mailbox)
            throws MessagingException {

        /*
         * A list of IDs for messages that were downloaded and did not have the seen flag set.
         * This serves as the ""true"" new message count reported to the user via notification.
         */
        final ArrayList<Long> unseenMessages = new ArrayList<Long>();

        Log.d(Logging.LOG_TAG, ""*** synchronizeMailboxGeneric ***"");
        ContentResolver resolver = mContext.getContentResolver();

        // 0.  We do not ever sync DRAFTS or OUTBOX (down or up)
        if (mailbox.mType == Mailbox.TYPE_DRAFTS || mailbox.mType == Mailbox.TYPE_OUTBOX) {
            int totalMessages = EmailContent.count(mContext, mailbox.getUri(), null, null);
            return new SyncResults(totalMessages, unseenMessages);
        }

        // 1.  Get the message list from the local store and create an index of the uids

        Cursor localUidCursor = null;
        HashMap<String, LocalMessageInfo> localMessageMap = new HashMap<String, LocalMessageInfo>();

        try {
            localUidCursor = resolver.query(
                    EmailContent.Message.CONTENT_URI,
                    LocalMessageInfo.PROJECTION,
                    EmailContent.MessageColumns.ACCOUNT_KEY + ""=?"" +
                    "" AND "" + MessageColumns.MAILBOX_KEY + ""=?"",
                    new String[] {
                            String.valueOf(account.mId),
                            String.valueOf(mailbox.mId)
                    },
                    null);
            while (localUidCursor.moveToNext()) {
                LocalMessageInfo info = new LocalMessageInfo(localUidCursor);
                localMessageMap.put(info.mServerId, info);
            }
        } finally {
            if (localUidCursor != null) {
                localUidCursor.close();
            }
        }

        // 2.  Open the remote folder and create the remote folder if necessary

        Store remoteStore = Store.getInstance(account, mContext);
        // The account might have been deleted
        if (remoteStore == null) return null;
        Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);

        /*
         * If the folder is a ""special"" folder we need to see if it exists
         * on the remote server. It if does not exist we'll try to create it. If we
         * can't create we'll abort. This will happen on every single Pop3 folder as
         * designed and on Imap folders during error conditions. This allows us
         * to treat Pop3 and Imap the same in this code.
         */
        if (mailbox.mType == Mailbox.TYPE_TRASH || mailbox.mType == Mailbox.TYPE_SENT
                || mailbox.mType == Mailbox.TYPE_DRAFTS) {
            if (!remoteFolder.exists()) {
                if (!remoteFolder.create(FolderType.HOLDS_MESSAGES)) {
                    return new SyncResults(0, unseenMessages);
                }
            }
        }

        // 3, Open the remote folder. This pre-loads certain metadata like message count.
        remoteFolder.open(OpenMode.READ_WRITE);

        // 4. Trash any remote messages that are marked as trashed locally.
        // TODO - this comment was here, but no code was here.

        // 5. Get the remote message count.
        int remoteMessageCount = remoteFolder.getMessageCount();

        // 6. Determine the limit # of messages to download
        int visibleLimit = mailbox.mVisibleLimit;
        if (visibleLimit <= 0) {
            visibleLimit = Email.VISIBLE_LIMIT_DEFAULT;
        }

        // 7.  Create a list of messages to download
        Message[] remoteMessages = new Message[0];
        final ArrayList<Message> unsyncedMessages = new ArrayList<Message>();
        HashMap<String, Message> remoteUidMap = new HashMap<String, Message>();

        int newMessageCount = 0;
        if (remoteMessageCount > 0) {
            /*
             * Message numbers start at 1.
             */
            int remoteStart = Math.max(0, remoteMessageCount - visibleLimit) + 1;
            int remoteEnd = remoteMessageCount;
            remoteMessages = remoteFolder.getMessages(remoteStart, remoteEnd, null);
            // TODO Why are we running through the list twice? Combine w/ for loop below
            for (Message message : remoteMessages) {
                remoteUidMap.put(message.getUid(), message);
            }

            /*
             * Get a list of the messages that are in the remote list but not on the
             * local store, or messages that are in the local store but failed to download
             * on the last sync. These are the new messages that we will download.
             * Note, we also skip syncing messages which are flagged as ""deleted message"" sentinels,
             * because they are locally deleted and we don't need or want the old message from
             * the server.
             */
            for (Message message : remoteMessages) {
                LocalMessageInfo localMessage = localMessageMap.get(message.getUid());
                if (localMessage == null) {
                    newMessageCount++;
                }
                // localMessage == null -> message has never been created (not even headers)
                // mFlagLoaded = UNLOADED -> message created, but none of body loaded
                // mFlagLoaded = PARTIAL -> message created, a ""sane"" amt of body has been loaded
                // mFlagLoaded = COMPLETE -> message body has been completely loaded
                // mFlagLoaded = DELETED -> message has been deleted
                // Only the first two of these are ""unsynced"", so let's retrieve them
                if (localMessage == null ||
                        (localMessage.mFlagLoaded == EmailContent.Message.FLAG_LOADED_UNLOADED)) {
                    unsyncedMessages.add(message);
                }
            }
        }

        // 8.  Download basic info about the new/unloaded messages (if any)
        /*
         * Fetch the flags and envelope only of the new messages. This is intended to get us
         * critical data as fast as possible, and then we'll fill in the details.
         */
        if (unsyncedMessages.size() > 0) {
            downloadFlagAndEnvelope(account, mailbox, remoteFolder, unsyncedMessages,
                    localMessageMap, unseenMessages);
        }

        // 9. Refresh the flags for any messages in the local store that we didn't just download.
        FetchProfile fp = new FetchProfile();
        fp.add(FetchProfile.Item.FLAGS);
        remoteFolder.fetch(remoteMessages, fp, null);
        boolean remoteSupportsSeen = false;
        boolean remoteSupportsFlagged = false;
        boolean remoteSupportsAnswered = false;
        for (Flag flag : remoteFolder.getPermanentFlags()) {
            if (flag == Flag.SEEN) {
                remoteSupportsSeen = true;
            }
            if (flag == Flag.FLAGGED) {
                remoteSupportsFlagged = true;
            }
            if (flag == Flag.ANSWERED) {
                remoteSupportsAnswered = true;
            }
        }
        // Update SEEN/FLAGGED/ANSWERED (star) flags (if supported remotely - e.g. not for POP3)
        if (remoteSupportsSeen || remoteSupportsFlagged || remoteSupportsAnswered) {
            for (Message remoteMessage : remoteMessages) {
                LocalMessageInfo localMessageInfo = localMessageMap.get(remoteMessage.getUid());
                if (localMessageInfo == null) {
                    continue;
                }
                boolean localSeen = localMessageInfo.mFlagRead;
                boolean remoteSeen = remoteMessage.isSet(Flag.SEEN);
                boolean newSeen = (remoteSupportsSeen && (remoteSeen != localSeen));
                boolean localFlagged = localMessageInfo.mFlagFavorite;
                boolean remoteFlagged = remoteMessage.isSet(Flag.FLAGGED);
                boolean newFlagged = (remoteSupportsFlagged && (localFlagged != remoteFlagged));
                int localFlags = localMessageInfo.mFlags;
                boolean localAnswered = (localFlags & EmailContent.Message.FLAG_REPLIED_TO) != 0;
                boolean remoteAnswered = remoteMessage.isSet(Flag.ANSWERED);
                boolean newAnswered = (remoteSupportsAnswered && (localAnswered != remoteAnswered));
                if (newSeen || newFlagged || newAnswered) {
                    Uri uri = ContentUris.withAppendedId(
                            EmailContent.Message.CONTENT_URI, localMessageInfo.mId);
                    ContentValues updateValues = new ContentValues();
                    updateValues.put(MessageColumns.FLAG_READ, remoteSeen);
                    updateValues.put(MessageColumns.FLAG_FAVORITE, remoteFlagged);
                    if (remoteAnswered) {
                        localFlags |= EmailContent.Message.FLAG_REPLIED_TO;
                    } else {
                        localFlags &= ~EmailContent.Message.FLAG_REPLIED_TO;
                    }
                    updateValues.put(MessageColumns.FLAGS, localFlags);
                    resolver.update(uri, updateValues, null, null);
                }
            }
        }

        // 10. Remove any messages that are in the local store but no longer on the remote store.
        HashSet<String> localUidsToDelete = new HashSet<String>(localMessageMap.keySet());
        localUidsToDelete.removeAll(remoteUidMap.keySet());
        for (String uidToDelete : localUidsToDelete) {
            LocalMessageInfo infoToDelete = localMessageMap.get(uidToDelete);

            // Delete associated data (attachment files)
            // Attachment & Body records are auto-deleted when we delete the Message record
            AttachmentUtilities.deleteAllAttachmentFiles(mContext, account.mId,
                    infoToDelete.mId);

            // Delete the message itself
            Uri uriToDelete = ContentUris.withAppendedId(
                    EmailContent.Message.CONTENT_URI, infoToDelete.mId);
            resolver.delete(uriToDelete, null, null);

            // Delete extra rows (e.g. synced or deleted)
            Uri syncRowToDelete = ContentUris.withAppendedId(
                    EmailContent.Message.UPDATED_CONTENT_URI, infoToDelete.mId);
            resolver.delete(syncRowToDelete, null, null);
            Uri deletERowToDelete = ContentUris.withAppendedId(
                    EmailContent.Message.UPDATED_CONTENT_URI, infoToDelete.mId);
            resolver.delete(deletERowToDelete, null, null);
        }

        loadUnsyncedMessages(account, remoteFolder, unsyncedMessages, mailbox);

        // 14. Clean up and report results
        remoteFolder.close(false);

        return new SyncResults(remoteMessageCount, unseenMessages);
    }

    /**
     * Copy one downloaded message (which may have partially-loaded sections)
     * into a newly created EmailProvider Message, given the account and mailbox
     *
     * @param message the remote message we've just downloaded
     * @param account the account it will be stored into
     * @param folder the mailbox it will be stored into
     * @param loadStatus when complete, the message will be marked with this status (e.g.
     *        EmailContent.Message.LOADED)
     */
    public void copyOneMessageToProvider(Message message, Account account,
            Mailbox folder, int loadStatus) {
        EmailContent.Message localMessage = null;
        Cursor c = null;
        try {
            c = mContext.getContentResolver().query(
                    EmailContent.Message.CONTENT_URI,
                    EmailContent.Message.CONTENT_PROJECTION,
                    EmailContent.MessageColumns.ACCOUNT_KEY + ""=?"" +
                    "" AND "" + MessageColumns.MAILBOX_KEY + ""=?"" +
                    "" AND "" + SyncColumns.SERVER_ID + ""=?"",
                    new String[] {
                            String.valueOf(account.mId),
                            String.valueOf(folder.mId),
                            String.valueOf(message.getUid())
                    },
                    null);
            if (c.moveToNext()) {
                localMessage = EmailContent.getContent(c, EmailContent.Message.class);
                localMessage.mMailboxKey = folder.mId;
                localMessage.mAccountKey = account.mId;
                copyOneMessageToProvider(message, localMessage, loadStatus, mContext);
            }
        } finally {
            if (c != null) {
                c.close();
            }
        }
    }

    /**
     * Copy one downloaded message (which may have partially-loaded sections)
     * into an already-created EmailProvider Message
     *
     * @param message the remote message we've just downloaded
     * @param localMessage the EmailProvider Message, already created
     * @param loadStatus when complete, the message will be marked with this status (e.g.
     *        EmailContent.Message.LOADED)
     * @param context the context to be used for EmailProvider
     */
    public void copyOneMessageToProvider(Message message, EmailContent.Message localMessage,
            int loadStatus, Context context) {
        try {

            EmailContent.Body body = EmailContent.Body.restoreBodyWithMessageId(context,
                    localMessage.mId);
            if (body == null) {
                body = new EmailContent.Body();
            }
            try {
                // Copy the fields that are available into the message object
                LegacyConversions.updateMessageFields(localMessage, message,
                        localMessage.mAccountKey, localMessage.mMailboxKey);

                // Now process body parts & attachments
                ArrayList<Part> viewables = new ArrayList<Part>();
                ArrayList<Part> attachments = new ArrayList<Part>();
                MimeUtility.collectParts(message, viewables, attachments);

                ConversionUtilities.updateBodyFields(body, localMessage, viewables);

                // Commit the message & body to the local store immediately
                saveOrUpdate(localMessage, context);
                saveOrUpdate(body, context);

                // process (and save) attachments
                LegacyConversions.updateAttachments(context, localMessage, attachments);

                // One last update of message with two updated flags
                localMessage.mFlagLoaded = loadStatus;

                ContentValues cv = new ContentValues();
                cv.put(EmailContent.MessageColumns.FLAG_ATTACHMENT, localMessage.mFlagAttachment);
                cv.put(EmailContent.MessageColumns.FLAG_LOADED, localMessage.mFlagLoaded);
                Uri uri = ContentUris.withAppendedId(EmailContent.Message.CONTENT_URI,
                        localMessage.mId);
                context.getContentResolver().update(uri, cv, null, null);

            } catch (MessagingException me) {
                Log.e(Logging.LOG_TAG, ""Error while copying downloaded message."" + me);
            }

        } catch (RuntimeException rte) {
            Log.e(Logging.LOG_TAG, ""Error while storing downloaded message."" + rte.toString());
        } catch (IOException ioe) {
            Log.e(Logging.LOG_TAG, ""Error while storing attachment."" + ioe.toString());
        }
    }

    public void processPendingActions(final long accountId) {
        put(""processPendingActions"", null, new Runnable() {
            public void run() {
                try {
                    Account account = Account.restoreAccountWithId(mContext, accountId);
                    if (account == null) {
                        return;
                    }
                    processPendingActionsSynchronous(account);
                }
                catch (MessagingException me) {
                    if (Logging.LOGD) {
                        Log.v(Logging.LOG_TAG, ""processPendingActions"", me);
                    }
                    /*
                     * Ignore any exceptions from the commands. Commands will be processed
                     * on the next round.
                     */
                }
            }
        });
    }

    /**
     * Find messages in the updated table that need to be written back to server.
     *
     * Handles:
     *   Read/Unread
     *   Flagged
     *   Append (upload)
     *   Move To Trash
     *   Empty trash
     * TODO:
     *   Move
     *
     * @param account the account to scan for pending actions
     * @throws MessagingException
     */
    private void processPendingActionsSynchronous(Account account)
           throws MessagingException {
        TrafficStats.setThreadStatsTag(TrafficFlags.getSyncFlags(mContext, account));
        ContentResolver resolver = mContext.getContentResolver();
        String[] accountIdArgs = new String[] { Long.toString(account.mId) };

        // Handle deletes first, it's always better to get rid of things first
        processPendingDeletesSynchronous(account, resolver, accountIdArgs);

        // Handle uploads (currently, only to sent messages)
        processPendingUploadsSynchronous(account, resolver, accountIdArgs);

        // Now handle updates / upsyncs
        processPendingUpdatesSynchronous(account, resolver, accountIdArgs);
    }

    /**
     * Get the mailbox corresponding to the remote location of a message; this will normally be
     * the mailbox whose _id is mailboxKey, except for search results, where we must look it up
     * by serverId
     * @param message the message in question
     * @return the mailbox in which the message resides on the server
     */
    private Mailbox getRemoteMailboxForMessage(EmailContent.Message message) {
        // If this is a search result, use the protocolSearchInfo field to get the server info
        if (!TextUtils.isEmpty(message.mProtocolSearchInfo)) {
            long accountKey = message.mAccountKey;
            String protocolSearchInfo = message.mProtocolSearchInfo;
            if (accountKey == mLastSearchAccountKey &&
                    protocolSearchInfo.equals(mLastSearchServerId)) {
                return mLastSearchRemoteMailbox;
            }
            Cursor c =  mContext.getContentResolver().query(Mailbox.CONTENT_URI,
                    Mailbox.CONTENT_PROJECTION, Mailbox.PATH_AND_ACCOUNT_SELECTION,
                    new String[] {protocolSearchInfo, Long.toString(accountKey)},
                    null);
            try {
                if (c.moveToNext()) {
                    Mailbox mailbox = new Mailbox();
                    mailbox.restore(c);
                    mLastSearchAccountKey = accountKey;
                    mLastSearchServerId = protocolSearchInfo;
                    mLastSearchRemoteMailbox = mailbox;
                    return mailbox;
                } else {
                    return null;
                }
            } finally {
                c.close();
            }
        } else {
            return Mailbox.restoreMailboxWithId(mContext, message.mMailboxKey);
        }
    }

    /**
     * Scan for messages that are in the Message_Deletes table, look for differences that
     * we can deal with, and do the work.
     *
     * @param account
     * @param resolver
     * @param accountIdArgs
     */
    private void processPendingDeletesSynchronous(Account account,
            ContentResolver resolver, String[] accountIdArgs) {
        Cursor deletes = resolver.query(EmailContent.Message.DELETED_CONTENT_URI,
                EmailContent.Message.CONTENT_PROJECTION,
                EmailContent.MessageColumns.ACCOUNT_KEY + ""=?"", accountIdArgs,
                EmailContent.MessageColumns.MAILBOX_KEY);
        long lastMessageId = -1;
        try {
            // Defer setting up the store until we know we need to access it
            Store remoteStore = null;
            // loop through messages marked as deleted
            while (deletes.moveToNext()) {
                boolean deleteFromTrash = false;

                EmailContent.Message oldMessage =
                        EmailContent.getContent(deletes, EmailContent.Message.class);

                if (oldMessage != null) {
                    lastMessageId = oldMessage.mId;

                    Mailbox mailbox = getRemoteMailboxForMessage(oldMessage);
                    if (mailbox == null) {
                        continue; // Mailbox removed. Move to the next message.
                    }
                    deleteFromTrash = mailbox.mType == Mailbox.TYPE_TRASH;

                    // Load the remote store if it will be needed
                    if (remoteStore == null && deleteFromTrash) {
                        remoteStore = Store.getInstance(account, mContext);
                    }

                    // Dispatch here for specific change types
                    if (deleteFromTrash) {
                        // Move message to trash
                        processPendingDeleteFromTrash(remoteStore, account, mailbox, oldMessage);
                    }
                }

                // Finally, delete the update
                Uri uri = ContentUris.withAppendedId(EmailContent.Message.DELETED_CONTENT_URI,
                        oldMessage.mId);
                resolver.delete(uri, null, null);
            }
        } catch (MessagingException me) {
            // Presumably an error here is an account connection failure, so there is
            // no point in continuing through the rest of the pending updates.
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ""Unable to process pending delete for id=""
                            + lastMessageId + "": "" + me);
            }
        } finally {
            deletes.close();
        }
    }

    /**
     * Scan for messages that are in Sent, and are in need of upload,
     * and send them to the server.  ""In need of upload"" is defined as:
     *  serverId == null (no UID has been assigned)
     * or
     *  message is in the updated list
     *
     * Note we also look for messages that are moving from drafts->outbox->sent.  They never
     * go through ""drafts"" or ""outbox"" on the server, so we hang onto these until they can be
     * uploaded directly to the Sent folder.
     *
     * @param account
     * @param resolver
     * @param accountIdArgs
     */
    private void processPendingUploadsSynchronous(Account account,
            ContentResolver resolver, String[] accountIdArgs) {
        // Find the Sent folder (since that's all we're uploading for now
        Cursor mailboxes = resolver.query(Mailbox.CONTENT_URI, Mailbox.ID_PROJECTION,
                MailboxColumns.ACCOUNT_KEY + ""=?""
                + "" and "" + MailboxColumns.TYPE + ""="" + Mailbox.TYPE_SENT,
                accountIdArgs, null);
        long lastMessageId = -1;
        try {
            // Defer setting up the store until we know we need to access it
            Store remoteStore = null;
            while (mailboxes.moveToNext()) {
                long mailboxId = mailboxes.getLong(Mailbox.ID_PROJECTION_COLUMN);
                String[] mailboxKeyArgs = new String[] { Long.toString(mailboxId) };
                // Demand load mailbox
                Mailbox mailbox = null;

                // First handle the ""new"" messages (serverId == null)
                Cursor upsyncs1 = resolver.query(EmailContent.Message.CONTENT_URI,
                        EmailContent.Message.ID_PROJECTION,
                        EmailContent.Message.MAILBOX_KEY + ""=?""
                        + "" and ("" + EmailContent.Message.SERVER_ID + "" is null""
                        + "" or "" + EmailContent.Message.SERVER_ID + ""=''"" + "")"",
                        mailboxKeyArgs,
                        null);
                try {
                    while (upsyncs1.moveToNext()) {
                        // Load the remote store if it will be needed
                        if (remoteStore == null) {
                            remoteStore = Store.getInstance(account, mContext);
                        }
                        // Load the mailbox if it will be needed
                        if (mailbox == null) {
                            mailbox = Mailbox.restoreMailboxWithId(mContext, mailboxId);
                            if (mailbox == null) {
                                continue; // Mailbox removed. Move to the next message.
                            }
                        }
                        // upsync the message
                        long id = upsyncs1.getLong(EmailContent.Message.ID_PROJECTION_COLUMN);
                        lastMessageId = id;
                        processUploadMessage(resolver, remoteStore, account, mailbox, id);
                    }
                } finally {
                    if (upsyncs1 != null) {
                        upsyncs1.close();
                    }
                }

                // Next, handle any updates (e.g. edited in place, although this shouldn't happen)
                Cursor upsyncs2 = resolver.query(EmailContent.Message.UPDATED_CONTENT_URI,
                        EmailContent.Message.ID_PROJECTION,
                        EmailContent.MessageColumns.MAILBOX_KEY + ""=?"", mailboxKeyArgs,
                        null);
                try {
                    while (upsyncs2.moveToNext()) {
                        // Load the remote store if it will be needed
                        if (remoteStore == null) {
                            remoteStore = Store.getInstance(account, mContext);
                        }
                        // Load the mailbox if it will be needed
                        if (mailbox == null) {
                            mailbox = Mailbox.restoreMailboxWithId(mContext, mailboxId);
                            if (mailbox == null) {
                                continue; // Mailbox removed. Move to the next message.
                            }
                        }
                        // upsync the message
                        long id = upsyncs2.getLong(EmailContent.Message.ID_PROJECTION_COLUMN);
                        lastMessageId = id;
                        processUploadMessage(resolver, remoteStore, account, mailbox, id);
                    }
                } finally {
                    if (upsyncs2 != null) {
                        upsyncs2.close();
                    }
                }
            }
        } catch (MessagingException me) {
            // Presumably an error here is an account connection failure, so there is
            // no point in continuing through the rest of the pending updates.
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ""Unable to process pending upsync for id=""
                        + lastMessageId + "": "" + me);
            }
        } finally {
            if (mailboxes != null) {
                mailboxes.close();
            }
        }
    }

    /**
     * Scan for messages that are in the Message_Updates table, look for differences that
     * we can deal with, and do the work.
     *
     * @param account
     * @param resolver
     * @param accountIdArgs
     */
    private void processPendingUpdatesSynchronous(Account account,
            ContentResolver resolver, String[] accountIdArgs) {
        Cursor updates = resolver.query(EmailContent.Message.UPDATED_CONTENT_URI,
                EmailContent.Message.CONTENT_PROJECTION,
                EmailContent.MessageColumns.ACCOUNT_KEY + ""=?"", accountIdArgs,
                EmailContent.MessageColumns.MAILBOX_KEY);
        long lastMessageId = -1;
        try {
            // Defer setting up the store until we know we need to access it
            Store remoteStore = null;
            // Demand load mailbox (note order-by to reduce thrashing here)
            Mailbox mailbox = null;
            // loop through messages marked as needing updates
            while (updates.moveToNext()) {
                boolean changeMoveToTrash = false;
                boolean changeRead = false;
                boolean changeFlagged = false;
                boolean changeMailbox = false;
                boolean changeAnswered = false;

                EmailContent.Message oldMessage =
                    EmailContent.getContent(updates, EmailContent.Message.class);
                lastMessageId = oldMessage.mId;
                EmailContent.Message newMessage =
                    EmailContent.Message.restoreMessageWithId(mContext, oldMessage.mId);
                if (newMessage != null) {
                    mailbox = Mailbox.restoreMailboxWithId(mContext, newMessage.mMailboxKey);
                    if (mailbox == null) {
                        continue; // Mailbox removed. Move to the next message.
                    }
                    if (oldMessage.mMailboxKey != newMessage.mMailboxKey) {
                        if (mailbox.mType == Mailbox.TYPE_TRASH) {
                            changeMoveToTrash = true;
                        } else {
                            changeMailbox = true;
                        }
                    }
                    changeRead = oldMessage.mFlagRead != newMessage.mFlagRead;
                    changeFlagged = oldMessage.mFlagFavorite != newMessage.mFlagFavorite;
                    changeAnswered = (oldMessage.mFlags & EmailContent.Message.FLAG_REPLIED_TO) !=
                        (newMessage.mFlags & EmailContent.Message.FLAG_REPLIED_TO);
               }

                // Load the remote store if it will be needed
                if (remoteStore == null &&
                        (changeMoveToTrash || changeRead || changeFlagged || changeMailbox ||
                                changeAnswered)) {
                    remoteStore = Store.getInstance(account, mContext);
                }

                // Dispatch here for specific change types
                if (changeMoveToTrash) {
                    // Move message to trash
                    processPendingMoveToTrash(remoteStore, account, mailbox, oldMessage,
                            newMessage);
                } else if (changeRead || changeFlagged || changeMailbox || changeAnswered) {
                    processPendingDataChange(remoteStore, mailbox, changeRead, changeFlagged,
                            changeMailbox, changeAnswered, oldMessage, newMessage);
                }

                // Finally, delete the update
                Uri uri = ContentUris.withAppendedId(EmailContent.Message.UPDATED_CONTENT_URI,
                        oldMessage.mId);
                resolver.delete(uri, null, null);
            }

        } catch (MessagingException me) {
            // Presumably an error here is an account connection failure, so there is
            // no point in continuing through the rest of the pending updates.
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ""Unable to process pending update for id=""
                            + lastMessageId + "": "" + me);
            }
        } finally {
            updates.close();
        }
    }

    /**
     * Upsync an entire message.  This must also unwind whatever triggered it (either by
     * updating the serverId, or by deleting the update record, or it's going to keep happening
     * over and over again.
     *
     * Note:  If the message is being uploaded into an unexpected mailbox, we *do not* upload.
     * This is to avoid unnecessary uploads into the trash.  Although the caller attempts to select
     * only the Drafts and Sent folders, this can happen when the update record and the current
     * record mismatch.  In this case, we let the update record remain, because the filters
     * in processPendingUpdatesSynchronous() will pick it up as a move and handle it (or drop it)
     * appropriately.
     *
     * @param resolver
     * @param remoteStore
     * @param account
     * @param mailbox the actual mailbox
     * @param messageId
     */
    private void processUploadMessage(ContentResolver resolver, Store remoteStore,
            Account account, Mailbox mailbox, long messageId)
            throws MessagingException {
        EmailContent.Message newMessage =
            EmailContent.Message.restoreMessageWithId(mContext, messageId);
        boolean deleteUpdate = false;
        if (newMessage == null) {
            deleteUpdate = true;
            Log.d(Logging.LOG_TAG, ""Upsync failed for null message, id="" + messageId);
        } else if (mailbox.mType == Mailbox.TYPE_DRAFTS) {
            deleteUpdate = false;
            Log.d(Logging.LOG_TAG, ""Upsync skipped for mailbox=drafts, id="" + messageId);
        } else if (mailbox.mType == Mailbox.TYPE_OUTBOX) {
            deleteUpdate = false;
            Log.d(Logging.LOG_TAG, ""Upsync skipped for mailbox=outbox, id="" + messageId);
        } else if (mailbox.mType == Mailbox.TYPE_TRASH) {
            deleteUpdate = false;
            Log.d(Logging.LOG_TAG, ""Upsync skipped for mailbox=trash, id="" + messageId);
        } else if (newMessage != null && newMessage.mMailboxKey != mailbox.mId) {
            deleteUpdate = false;
            Log.d(Logging.LOG_TAG, ""Upsync skipped; mailbox changed, id="" + messageId);
        } else {
            Log.d(Logging.LOG_TAG, ""Upsyc triggered for message id="" + messageId);
            deleteUpdate = processPendingAppend(remoteStore, account, mailbox, newMessage);
        }
        if (deleteUpdate) {
            // Finally, delete the update (if any)
            Uri uri = ContentUris.withAppendedId(
                    EmailContent.Message.UPDATED_CONTENT_URI, messageId);
            resolver.delete(uri, null, null);
        }
    }

    /**
     * Upsync changes to read, flagged, or mailbox
     *
     * @param remoteStore the remote store for this mailbox
     * @param mailbox the mailbox the message is stored in
     * @param changeRead whether the message's read state has changed
     * @param changeFlagged whether the message's flagged state has changed
     * @param changeMailbox whether the message's mailbox has changed
     * @param oldMessage the message in it's pre-change state
     * @param newMessage the current version of the message
     */
    private void processPendingDataChange(Store remoteStore, Mailbox mailbox, boolean changeRead,
            boolean changeFlagged, boolean changeMailbox, boolean changeAnswered,
            EmailContent.Message oldMessage, final EmailContent.Message newMessage)
            throws MessagingException {
        // New mailbox is the mailbox this message WILL be in (same as the one it WAS in if it isn't
        // being moved
        Mailbox newMailbox = mailbox;
        // Mailbox is the original remote mailbox (the one we're acting on)
        mailbox = getRemoteMailboxForMessage(oldMessage);

        // 0. No remote update if the message is local-only
        if (newMessage.mServerId == null || newMessage.mServerId.equals("""")
                || newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX) || (mailbox == null)) {
            return;
        }

        // 1. No remote update for DRAFTS or OUTBOX
        if (mailbox.mType == Mailbox.TYPE_DRAFTS || mailbox.mType == Mailbox.TYPE_OUTBOX) {
            return;
        }

        // 2. Open the remote store & folder
        Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);
        if (!remoteFolder.exists()) {
            return;
        }
        remoteFolder.open(OpenMode.READ_WRITE);
        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
            return;
        }

        // 3. Finally, apply the changes to the message
        Message remoteMessage = remoteFolder.getMessage(newMessage.mServerId);
        if (remoteMessage == null) {
            return;
        }
        if (Email.DEBUG) {
            Log.d(Logging.LOG_TAG,
                    ""Update for msg id="" + newMessage.mId
                    + "" read="" + newMessage.mFlagRead
                    + "" flagged="" + newMessage.mFlagFavorite
                    + "" answered=""
                    + ((newMessage.mFlags & EmailContent.Message.FLAG_REPLIED_TO) != 0)
                    + "" new mailbox="" + newMessage.mMailboxKey);
        }
        Message[] messages = new Message[] { remoteMessage };
        if (changeRead) {
            remoteFolder.setFlags(messages, FLAG_LIST_SEEN, newMessage.mFlagRead);
        }
        if (changeFlagged) {
            remoteFolder.setFlags(messages, FLAG_LIST_FLAGGED, newMessage.mFlagFavorite);
        }
        if (changeAnswered) {
            remoteFolder.setFlags(messages, FLAG_LIST_ANSWERED,
                    (newMessage.mFlags & EmailContent.Message.FLAG_REPLIED_TO) != 0);
        }
        if (changeMailbox) {
            Folder toFolder = remoteStore.getFolder(newMailbox.mServerId);
            if (!remoteFolder.exists()) {
                return;
            }
            // We may need the message id to search for the message in the destination folder
            remoteMessage.setMessageId(newMessage.mMessageId);
            // Copy the message to its new folder
            remoteFolder.copyMessages(messages, toFolder, new MessageUpdateCallbacks() {
                @Override
                public void onMessageUidChange(Message message, String newUid) {
                    ContentValues cv = new ContentValues();
                    cv.put(EmailContent.Message.SERVER_ID, newUid);
                    // We only have one message, so, any updates _must_ be for it. Otherwise,
                    // we'd have to cycle through to find the one with the same server ID.
                    mContext.getContentResolver().update(ContentUris.withAppendedId(
                            EmailContent.Message.CONTENT_URI, newMessage.mId), cv, null, null);
                }
                @Override
                public void onMessageNotFound(Message message) {
                }
            });
            // Delete the message from the remote source folder
            remoteMessage.setFlag(Flag.DELETED, true);
            remoteFolder.expunge();
        }
        remoteFolder.close(false);
    }

    /**
     * Process a pending trash message command.
     *
     * @param remoteStore the remote store we're working in
     * @param account The account in which we are working
     * @param newMailbox The local trash mailbox
     * @param oldMessage The message copy that was saved in the updates shadow table
     * @param newMessage The message that was moved to the mailbox
     */
    private void processPendingMoveToTrash(Store remoteStore,
            Account account, Mailbox newMailbox, EmailContent.Message oldMessage,
            final EmailContent.Message newMessage) throws MessagingException {

        // 0. No remote move if the message is local-only
        if (newMessage.mServerId == null || newMessage.mServerId.equals("""")
                || newMessage.mServerId.startsWith(LOCAL_SERVERID_PREFIX)) {
            return;
        }

        // 1. Escape early if we can't find the local mailbox
        // TODO smaller projection here
        Mailbox oldMailbox = getRemoteMailboxForMessage(oldMessage);
        if (oldMailbox == null) {
            // can't find old mailbox, it may have been deleted.  just return.
            return;
        }
        // 2. We don't support delete-from-trash here
        if (oldMailbox.mType == Mailbox.TYPE_TRASH) {
            return;
        }

        // 3. If DELETE_POLICY_NEVER, simply write back the deleted sentinel and return
        //
        // This sentinel takes the place of the server-side message, and locally ""deletes"" it
        // by inhibiting future sync or display of the message.  It will eventually go out of
        // scope when it becomes old, or is deleted on the server, and the regular sync code
        // will clean it up for us.
        if (account.getDeletePolicy() == Account.DELETE_POLICY_NEVER) {
            EmailContent.Message sentinel = new EmailContent.Message();
            sentinel.mAccountKey = oldMessage.mAccountKey;
            sentinel.mMailboxKey = oldMessage.mMailboxKey;
            sentinel.mFlagLoaded = EmailContent.Message.FLAG_LOADED_DELETED;
            sentinel.mFlagRead = true;
            sentinel.mServerId = oldMessage.mServerId;
            sentinel.save(mContext);

            return;
        }

        // The rest of this method handles server-side deletion

        // 4.  Find the remote mailbox (that we deleted from), and open it
        Folder remoteFolder = remoteStore.getFolder(oldMailbox.mServerId);
        if (!remoteFolder.exists()) {
            return;
        }

        remoteFolder.open(OpenMode.READ_WRITE);
        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
            remoteFolder.close(false);
            return;
        }

        // 5. Find the remote original message
        Message remoteMessage = remoteFolder.getMessage(oldMessage.mServerId);
        if (remoteMessage == null) {
            remoteFolder.close(false);
            return;
        }

        // 6. Find the remote trash folder, and create it if not found
        Folder remoteTrashFolder = remoteStore.getFolder(newMailbox.mServerId);
        if (!remoteTrashFolder.exists()) {
            /*
             * If the remote trash folder doesn't exist we try to create it.
             */
            remoteTrashFolder.create(FolderType.HOLDS_MESSAGES);
        }

        // 7.  Try to copy the message into the remote trash folder
        // Note, this entire section will be skipped for POP3 because there's no remote trash
        if (remoteTrashFolder.exists()) {
            /*
             * Because remoteTrashFolder may be new, we need to explicitly open it
             */
            remoteTrashFolder.open(OpenMode.READ_WRITE);
            if (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {
                remoteFolder.close(false);
                remoteTrashFolder.close(false);
                return;
            }

            remoteFolder.copyMessages(new Message[] { remoteMessage }, remoteTrashFolder,
                    new Folder.MessageUpdateCallbacks() {
                public void onMessageUidChange(Message message, String newUid) {
                    // update the UID in the local trash folder, because some stores will
                    // have to change it when copying to remoteTrashFolder
                    ContentValues cv = new ContentValues();
                    cv.put(EmailContent.Message.SERVER_ID, newUid);
                    mContext.getContentResolver().update(newMessage.getUri(), cv, null, null);
                }

                /**
                 * This will be called if the deleted message doesn't exist and can't be
                 * deleted (e.g. it was already deleted from the server.)  In this case,
                 * attempt to delete the local copy as well.
                 */
                public void onMessageNotFound(Message message) {
                    mContext.getContentResolver().delete(newMessage.getUri(), null, null);
                }
            });
            remoteTrashFolder.close(false);
        }

        // 8. Delete the message from the remote source folder
        remoteMessage.setFlag(Flag.DELETED, true);
        remoteFolder.expunge();
        remoteFolder.close(false);
    }

    /**
     * Process a pending trash message command.
     *
     * @param remoteStore the remote store we're working in
     * @param account The account in which we are working
     * @param oldMailbox The local trash mailbox
     * @param oldMessage The message that was deleted from the trash
     */
    private void processPendingDeleteFromTrash(Store remoteStore,
            Account account, Mailbox oldMailbox, EmailContent.Message oldMessage)
            throws MessagingException {

        // 1. We only support delete-from-trash here
        if (oldMailbox.mType != Mailbox.TYPE_TRASH) {
            return;
        }

        // 2.  Find the remote trash folder (that we are deleting from), and open it
        Folder remoteTrashFolder = remoteStore.getFolder(oldMailbox.mServerId);
        if (!remoteTrashFolder.exists()) {
            return;
        }

        remoteTrashFolder.open(OpenMode.READ_WRITE);
        if (remoteTrashFolder.getMode() != OpenMode.READ_WRITE) {
            remoteTrashFolder.close(false);
            return;
        }

        // 3. Find the remote original message
        Message remoteMessage = remoteTrashFolder.getMessage(oldMessage.mServerId);
        if (remoteMessage == null) {
            remoteTrashFolder.close(false);
            return;
        }

        // 4. Delete the message from the remote trash folder
        remoteMessage.setFlag(Flag.DELETED, true);
        remoteTrashFolder.expunge();
        remoteTrashFolder.close(false);
    }

    /**
     * Process a pending append message command. This command uploads a local message to the
     * server, first checking to be sure that the server message is not newer than
     * the local message.
     *
     * @param remoteStore the remote store we're working in
     * @param account The account in which we are working
     * @param newMailbox The mailbox we're appending to
     * @param message The message we're appending
     * @return true if successfully uploaded
     */
    private boolean processPendingAppend(Store remoteStore, Account account,
            Mailbox newMailbox, EmailContent.Message message)
            throws MessagingException {

        boolean updateInternalDate = false;
        boolean updateMessage = false;
        boolean deleteMessage = false;

        // 1. Find the remote folder that we're appending to and create and/or open it
        Folder remoteFolder = remoteStore.getFolder(newMailbox.mServerId);
        if (!remoteFolder.exists()) {
            if (!remoteFolder.canCreate(FolderType.HOLDS_MESSAGES)) {
                // This is POP3, we cannot actually upload.  Instead, we'll update the message
                // locally with a fake serverId (so we don't keep trying here) and return.
                if (message.mServerId == null || message.mServerId.length() == 0) {
                    message.mServerId = LOCAL_SERVERID_PREFIX + message.mId;
                    Uri uri =
                        ContentUris.withAppendedId(EmailContent.Message.CONTENT_URI, message.mId);
                    ContentValues cv = new ContentValues();
                    cv.put(EmailContent.Message.SERVER_ID, message.mServerId);
                    mContext.getContentResolver().update(uri, cv, null, null);
                }
                return true;
            }
            if (!remoteFolder.create(FolderType.HOLDS_MESSAGES)) {
                // This is a (hopefully) transient error and we return false to try again later
                return false;
            }
        }
        remoteFolder.open(OpenMode.READ_WRITE);
        if (remoteFolder.getMode() != OpenMode.READ_WRITE) {
            return false;
        }

        // 2. If possible, load a remote message with the matching UID
        Message remoteMessage = null;
        if (message.mServerId != null && message.mServerId.length() > 0) {
            remoteMessage = remoteFolder.getMessage(message.mServerId);
        }

        // 3. If a remote message could not be found, upload our local message
        if (remoteMessage == null) {
            // 3a. Create a legacy message to upload
            Message localMessage = LegacyConversions.makeMessage(mContext, message);

            // 3b. Upload it
            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.BODY);
            remoteFolder.appendMessages(new Message[] { localMessage });

            // 3b. And record the UID from the server
            message.mServerId = localMessage.getUid();
            updateInternalDate = true;
            updateMessage = true;
        } else {
            // 4. If the remote message exists we need to determine which copy to keep.
            FetchProfile fp = new FetchProfile();
            fp.add(FetchProfile.Item.ENVELOPE);
            remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);
            Date localDate = new Date(message.mServerTimeStamp);
            Date remoteDate = remoteMessage.getInternalDate();
            if (remoteDate != null && remoteDate.compareTo(localDate) > 0) {
                // 4a. If the remote message is newer than ours we'll just
                // delete ours and move on. A sync will get the server message
                // if we need to be able to see it.
                deleteMessage = true;
            } else {
                // 4b. Otherwise we'll upload our message and then delete the remote message.

                // Create a legacy message to upload
                Message localMessage = LegacyConversions.makeMessage(mContext, message);

                // 4c. Upload it
                fp.clear();
                fp = new FetchProfile();
                fp.add(FetchProfile.Item.BODY);
                remoteFolder.appendMessages(new Message[] { localMessage });

                // 4d. Record the UID and new internalDate from the server
                message.mServerId = localMessage.getUid();
                updateInternalDate = true;
                updateMessage = true;

                // 4e. And delete the old copy of the message from the server
                remoteMessage.setFlag(Flag.DELETED, true);
            }
        }

        // 5. If requested, Best-effort to capture new ""internaldate"" from the server
        if (updateInternalDate && message.mServerId != null) {
            try {
                Message remoteMessage2 = remoteFolder.getMessage(message.mServerId);
                if (remoteMessage2 != null) {
                    FetchProfile fp2 = new FetchProfile();
                    fp2.add(FetchProfile.Item.ENVELOPE);
                    remoteFolder.fetch(new Message[] { remoteMessage2 }, fp2, null);
                    message.mServerTimeStamp = remoteMessage2.getInternalDate().getTime();
                    updateMessage = true;
                }
            } catch (MessagingException me) {
                // skip it - we can live without this
            }
        }

        // 6. Perform required edits to local copy of message
        if (deleteMessage || updateMessage) {
            Uri uri = ContentUris.withAppendedId(EmailContent.Message.CONTENT_URI, message.mId);
            ContentResolver resolver = mContext.getContentResolver();
            if (deleteMessage) {
                resolver.delete(uri, null, null);
            } else if (updateMessage) {
                ContentValues cv = new ContentValues();
                cv.put(EmailContent.Message.SERVER_ID, message.mServerId);
                cv.put(EmailContent.Message.SERVER_TIMESTAMP, message.mServerTimeStamp);
                resolver.update(uri, cv, null, null);
            }
        }

        return true;
    }

    /**
     * Finish loading a message that have been partially downloaded.
     *
     * @param messageId the message to load
     * @param listener the callback by which results will be reported
     */
    public void loadMessageForView(final long messageId, MessagingListener listener) {
        mListeners.loadMessageForViewStarted(messageId);
        put(""loadMessageForViewRemote"", listener, new Runnable() {
            public void run() {
                try {
                    // 1. Resample the message, in case it disappeared or synced while
                    // this command was in queue
                    EmailContent.Message message =
                        EmailContent.Message.restoreMessageWithId(mContext, messageId);
                    if (message == null) {
                        mListeners.loadMessageForViewFailed(messageId, ""Unknown message"");
                        return;
                    }
                    if (message.mFlagLoaded == EmailContent.Message.FLAG_LOADED_COMPLETE) {
                        mListeners.loadMessageForViewFinished(messageId);
                        return;
                    }

                    // 2. Open the remote folder.
                    // TODO combine with common code in loadAttachment
                    Account account = Account.restoreAccountWithId(mContext, message.mAccountKey);
                    Mailbox mailbox = Mailbox.restoreMailboxWithId(mContext, message.mMailboxKey);
                    if (account == null || mailbox == null) {
                        mListeners.loadMessageForViewFailed(messageId, ""null account or mailbox"");
                        return;
                    }
                    TrafficStats.setThreadStatsTag(TrafficFlags.getSyncFlags(mContext, account));

                    Store remoteStore = Store.getInstance(account, mContext);
                    String remoteServerId = mailbox.mServerId;
                    // If this is a search result, use the protocolSearchInfo field to get the
                    // correct remote location
                    if (!TextUtils.isEmpty(message.mProtocolSearchInfo)) {
                        remoteServerId = message.mProtocolSearchInfo;
                    }
                    Folder remoteFolder = remoteStore.getFolder(remoteServerId);
                    remoteFolder.open(OpenMode.READ_WRITE);

                    // 3. Set up to download the entire message
                    Message remoteMessage = remoteFolder.getMessage(message.mServerId);
                    FetchProfile fp = new FetchProfile();
                    fp.add(FetchProfile.Item.BODY);
                    remoteFolder.fetch(new Message[] { remoteMessage }, fp, null);

                    // 4. Write to provider
                    copyOneMessageToProvider(remoteMessage, account, mailbox,
                            EmailContent.Message.FLAG_LOADED_COMPLETE);

                    // 5. Notify UI
                    mListeners.loadMessageForViewFinished(messageId);

                } catch (MessagingException me) {
                    if (Logging.LOGD) Log.v(Logging.LOG_TAG, """", me);
                    mListeners.loadMessageForViewFailed(messageId, me.getMessage());
                } catch (RuntimeException rte) {
                    mListeners.loadMessageForViewFailed(messageId, rte.getMessage());
                }
            }
        });
    }

    /**
     * Attempts to load the attachment specified by id from the given account and message.
     */
    public void loadAttachment(final long accountId, final long messageId, final long mailboxId,
            final long attachmentId, MessagingListener listener, final boolean background) {
        mListeners.loadAttachmentStarted(accountId, messageId, attachmentId, true);

        put(""loadAttachment"", listener, new Runnable() {
            public void run() {
                try {
                    //1. Check if the attachment is already here and return early in that case
                    Attachment attachment =
                        Attachment.restoreAttachmentWithId(mContext, attachmentId);
                    if (attachment == null) {
                        mListeners.loadAttachmentFailed(accountId, messageId, attachmentId,
                                   new MessagingException(""The attachment is null""),
                                   background);
                        return;
                    }
                    if (Utility.attachmentExists(mContext, attachment)) {
                        mListeners.loadAttachmentFinished(accountId, messageId, attachmentId);
                        return;
                    }

                    // 2. Open the remote folder.
                    // TODO all of these could be narrower projections
                    Account account = Account.restoreAccountWithId(mContext, accountId);
                    Mailbox mailbox = Mailbox.restoreMailboxWithId(mContext, mailboxId);
                    EmailContent.Message message =
                        EmailContent.Message.restoreMessageWithId(mContext, messageId);

                    if (account == null || mailbox == null || message == null) {
                        mListeners.loadAttachmentFailed(accountId, messageId, attachmentId,
                                new MessagingException(
                                        ""Account, mailbox, message or attachment are null""),
                                background);
                        return;
                    }
                    TrafficStats.setThreadStatsTag(
                            TrafficFlags.getAttachmentFlags(mContext, account));

                    Store remoteStore = Store.getInstance(account, mContext);
                    Folder remoteFolder = remoteStore.getFolder(mailbox.mServerId);
                    remoteFolder.open(OpenMode.READ_WRITE);

                    // 3. Generate a shell message in which to retrieve the attachment,
                    // and a shell BodyPart for the attachment.  Then glue them together.
                    Message storeMessage = remoteFolder.createMessage(message.mServerId);
                    MimeBodyPart storePart = new MimeBodyPart();
                    storePart.setSize((int)attachment.mSize);
                    storePart.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA,
                            attachment.mLocation);
                    storePart.setHeader(MimeHeader.HEADER_CONTENT_TYPE,
                            String.format(""%s;\n name=\""%s\"""",
                            attachment.mMimeType,
                            attachment.mFileName));
                    // TODO is this always true for attachments?  I think we dropped the
                    // true encoding along the way
                    storePart.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING, ""base64"");

                    MimeMultipart multipart = new MimeMultipart();
                    multipart.setSubType(""mixed"");
                    multipart.addBodyPart(storePart);

                    storeMessage.setHeader(MimeHeader.HEADER_CONTENT_TYPE, ""multipart/mixed"");
                    storeMessage.setBody(multipart);

                    // 4. Now ask for the attachment to be fetched
                    FetchProfile fp = new FetchProfile();
                    fp.add(storePart);
                    remoteFolder.fetch(new Message[] { storeMessage }, fp,
                            mController.new MessageRetrievalListenerBridge(
                                    messageId, attachmentId));

                    // If we failed to load the attachment, throw an Exception here, so that
                    // AttachmentDownloadService knows that we failed
                    if (storePart.getBody() == null) {
                        throw new MessagingException(""Attachment not loaded."");
                    }

                    // 5. Save the downloaded file and update the attachment as necessary
                    LegacyConversions.saveAttachmentBody(mContext, storePart, attachment,
                            accountId);

                    // 6. Report success
                    mListeners.loadAttachmentFinished(accountId, messageId, attachmentId);
                }
                catch (MessagingException me) {
                    if (Logging.LOGD) Log.v(Logging.LOG_TAG, """", me);
                    mListeners.loadAttachmentFailed(
                            accountId, messageId, attachmentId, me, background);
                } catch (IOException ioe) {
                    Log.e(Logging.LOG_TAG, ""Error while storing attachment."" + ioe.toString());
                }
            }});
    }

    /**
     * Attempt to send any messages that are sitting in the Outbox.
     * @param account
     * @param listener
     */
    public void sendPendingMessages(final Account account, final long sentFolderId,
            MessagingListener listener) {
        put(""sendPendingMessages"", listener, new Runnable() {
            public void run() {
                sendPendingMessagesSynchronous(account, sentFolderId);
            }
        });
    }

    /**
     * Attempt to send all messages sitting in the given account's outbox. Optionally,
     * if the server requires it, the message will be moved to the given sent folder.
     */
    public void sendPendingMessagesSynchronous(final Account account,
            long sentFolderId) {
        TrafficStats.setThreadStatsTag(TrafficFlags.getSmtpFlags(mContext, account));
        NotificationController nc = NotificationController.getInstance(mContext);
        // 1.  Loop through all messages in the account's outbox
        long outboxId = Mailbox.findMailboxOfType(mContext, account.mId, Mailbox.TYPE_OUTBOX);
        if (outboxId == Mailbox.NO_MAILBOX) {
            return;
        }
        ContentResolver resolver = mContext.getContentResolver();
        Cursor c = resolver.query(EmailContent.Message.CONTENT_URI,
                EmailContent.Message.ID_COLUMN_PROJECTION,
                EmailContent.Message.MAILBOX_KEY + ""=?"", new String[] { Long.toString(outboxId) },
                null);
        try {
            // 2.  exit early
            if (c.getCount() <= 0) {
                return;
            }
            // 3. do one-time setup of the Sender & other stuff
            mListeners.sendPendingMessagesStarted(account.mId, -1);

            Sender sender = Sender.getInstance(mContext, account);
            Store remoteStore = Store.getInstance(account, mContext);
            boolean requireMoveMessageToSentFolder = remoteStore.requireCopyMessageToSentFolder();
            ContentValues moveToSentValues = null;
            if (requireMoveMessageToSentFolder) {
                moveToSentValues = new ContentValues();
                moveToSentValues.put(MessageColumns.MAILBOX_KEY, sentFolderId);
            }

            // 4.  loop through the available messages and send them
            while (c.moveToNext()) {
                long messageId = -1;
                try {
                    messageId = c.getLong(0);
                    mListeners.sendPendingMessagesStarted(account.mId, messageId);
                    // Don't send messages with unloaded attachments
                    if (Utility.hasUnloadedAttachments(mContext, messageId)) {
                        if (Email.DEBUG) {
                            Log.d(Logging.LOG_TAG, ""Can't send #"" + messageId +
                                    ""; unloaded attachments"");
                        }
                        continue;
                    }
                    sender.sendMessage(messageId);
                } catch (MessagingException me) {
                    // report error for this message, but keep trying others
                    if (me instanceof AuthenticationFailedException) {
                        nc.showLoginFailedNotification(account.mId);
                    }
                    mListeners.sendPendingMessagesFailed(account.mId, messageId, me);
                    continue;
                }
                // 5. move to sent, or delete
                Uri syncedUri =
                    ContentUris.withAppendedId(EmailContent.Message.SYNCED_CONTENT_URI, messageId);
                if (requireMoveMessageToSentFolder) {
                    // If this is a forwarded message and it has attachments, delete them, as they
                    // duplicate information found elsewhere (on the server).  This saves storage.
                    EmailContent.Message msg =
                        EmailContent.Message.restoreMessageWithId(mContext, messageId);
                    if (msg != null &&
                            ((msg.mFlags & EmailContent.Message.FLAG_TYPE_FORWARD) != 0)) {
                        AttachmentUtilities.deleteAllAttachmentFiles(mContext, account.mId,
                                messageId);
                    }
                    resolver.update(syncedUri, moveToSentValues, null, null);
                } else {
                    AttachmentUtilities.deleteAllAttachmentFiles(mContext, account.mId,
                            messageId);
                    Uri uri =
                        ContentUris.withAppendedId(EmailContent.Message.CONTENT_URI, messageId);
                    resolver.delete(uri, null, null);
                    resolver.delete(syncedUri, null, null);
                }
            }
            // 6. report completion/success
            mListeners.sendPendingMessagesCompleted(account.mId);
            nc.cancelLoginFailedNotification(account.mId);
        } catch (MessagingException me) {
            if (me instanceof AuthenticationFailedException) {
                nc.showLoginFailedNotification(account.mId);
            }
            mListeners.sendPendingMessagesFailed(account.mId, -1, me);
        } finally {
            c.close();
        }
    }

    /**
     * Checks mail for an account.
     * This entry point is for use by the mail checking service only, because it
     * gives slightly different callbacks (so the service doesn't get confused by callbacks
     * triggered by/for the foreground UI.
     *
     * TODO clean up the execution model which is unnecessarily threaded due to legacy code
     *
     * @param accountId the account to check
     * @param listener
     */
    public void checkMail(final long accountId, final long tag, final MessagingListener listener) {
        mListeners.checkMailStarted(mContext, accountId, tag);

        // This puts the command on the queue (not synchronous)
        listFolders(accountId, null);

        // Put this on the queue as well so it follows listFolders
        put(""checkMail"", listener, new Runnable() {
            public void run() {
                // send any pending outbound messages.  note, there is a slight race condition
                // here if we somehow don't have a sent folder, but this should never happen
                // because the call to sendMessage() would have built one previously.
                long inboxId = -1;
                Account account = Account.restoreAccountWithId(mContext, accountId);
                if (account != null) {
                    long sentboxId = Mailbox.findMailboxOfType(mContext, accountId,
                            Mailbox.TYPE_SENT);
                    if (sentboxId != Mailbox.NO_MAILBOX) {
                        sendPendingMessagesSynchronous(account, sentboxId);
                    }
                    // find mailbox # for inbox and sync it.
                    // TODO we already know this in Controller, can we pass it in?
                    inboxId = Mailbox.findMailboxOfType(mContext, accountId, Mailbox.TYPE_INBOX);
                    if (inboxId != Mailbox.NO_MAILBOX) {
                        Mailbox mailbox =
                            Mailbox.restoreMailboxWithId(mContext, inboxId);
                        if (mailbox != null) {
                            synchronizeMailboxSynchronous(account, mailbox);
                        }
                    }
                }
                mListeners.checkMailFinished(mContext, accountId, inboxId, tag);
            }
        });
    }

    private static class Command {
        public Runnable runnable;

        public MessagingListener listener;

        public String description;

        @Override
        public String toString() {
            return description;
        }
    }

    /** Results of the latest synchronization. */
    private static class SyncResults {
        /** The total # of messages in the folder */
        public final int mTotalMessages;
        /** A list of new message IDs; must not be {@code null} */
        public final ArrayList<Long> mAddedMessages;

        public SyncResults(int totalMessages, ArrayList<Long> addedMessages) {
            if (addedMessages == null) {
                throw new IllegalArgumentException(""addedMessages must not be null"");
            }
            mTotalMessages = totalMessages;
            mAddedMessages = addedMessages;
        }
    }
}
",True,267,0,0,9,65,1,29,L6
18,com.android.email.ResourceHelper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.content.Context;
import android.content.res.Resources;
import android.content.res.TypedArray;
import android.graphics.Paint;

/**
 * Helper class to load resources.
 */
public class ResourceHelper {
    public final static int UNDEFINED_RESOURCE_ID = -1;

    private static ResourceHelper sInstance;
    private final Context mContext;
    private final Resources mResources;

    private final int[] mAccountColors;
    private final Paint[] mAccountColorPaints;
    private final TypedArray mAccountColorArray;

    private ResourceHelper(Context context) {
        mContext = context.getApplicationContext();
        mResources = mContext.getResources();

        mAccountColorArray = mResources.obtainTypedArray(R.array.combined_view_account_colors);
        mAccountColors = mResources.getIntArray(R.array.combined_view_account_colors);
        mAccountColorPaints = new Paint[mAccountColors.length];
        for (int i = 0; i < mAccountColors.length; i++) {
            Paint p = new Paint();
            p.setColor(mAccountColors[i]);
            mAccountColorPaints[i] = p;
        }
    }

    public static synchronized ResourceHelper getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new ResourceHelper(context);
        }
        return sInstance;
    }

    /* package */ int getAccountColorIndex(long accountId) {
        // The account ID is 1-based, so -1.
        // Use abs so that it'd work for -1 as well.
        return Math.abs((int) ((accountId - 1) % mAccountColors.length));
    }

    /**
     * @return color for an account.
     */
    public int getAccountColor(long accountId) {
        return mAccountColors[getAccountColorIndex(accountId)];
    }

    /**
     * @return The resource ID for an account color.
     * Otherwise, {@value #UNDEFINED_RESOURCE_ID} if color was not specified via ID.
     */
    public int getAccountColorId(long accountId) {
        return mAccountColorArray.getResourceId(getAccountColorIndex(accountId),
                UNDEFINED_RESOURCE_ID);
    }

    /**
     * @return {@link Paint} equivalent to {@link #getAccountColor}.
     */
    public Paint getAccountColorPaint(long accountId) {
        return mAccountColorPaints[getAccountColorIndex(accountId)];
    }
}
",False,148,8,60,0,0,6,0,L0
19,com.android.email.RequireManualSyncDialog.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.provider.Account;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.res.Resources;

public class RequireManualSyncDialog extends AlertDialog implements OnClickListener {

    public RequireManualSyncDialog(Context context, Account account) {
        super(context);
        setMessage(context.getResources().getString(R.string.require_manual_sync_message));
        setButton(DialogInterface.BUTTON_POSITIVE, context.getString(android.R.string.ok), this);
        Preferences.getPreferences(context).setHasShownRequireManualSync(context, account, true);
    }

    /** {@inheritDoc} */
    public void onClick(DialogInterface dialog, int which) {
        // No-op.
    }
}",False,160,10,45,4,6,1,2,L6
20,com.android.email.ControllerResultUiThreadWrapper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.os.Handler;

import com.android.email.Controller.Result;
import com.android.emailcommon.mail.MessagingException;

import java.util.ArrayList;

/**
 * A {@link Result} that wraps another {@link Result} and makes sure methods gets called back
 * on the UI thread.
 *
 * <p>Optionally it supports the ""synchronous"" mode, if you pass null for the {@code handler}
 * parameter, which allows unit tests to run synchronously.
 */
public class ControllerResultUiThreadWrapper<T extends Result> extends Result {
    private final Handler mHandler;
    private final T mWrappee;

    public ControllerResultUiThreadWrapper(Handler handler, T wrappee) {
        mHandler = handler;
        mWrappee = wrappee;
    }

    public T getWrappee() {
        return mWrappee;
    }

    @Override
    protected void setRegistered(boolean registered) {
        super.setRegistered(registered);
        mWrappee.setRegistered(registered);
    }

    private void run(Runnable runnable) {
        if (mHandler == null) {
            runnable.run();
        } else {
            mHandler.post(runnable);
        }
    }

    @Override
    public void loadAttachmentCallback(final MessagingException result, final long accountId,
                final long messageId, final long attachmentId, final int progress) {
        run(new Runnable() {
            public void run() {
                /* It's possible this callback is unregistered after this Runnable was posted and
                 * sitting in the handler queue, so we always need to check if it's still registered
                 * on the UI thread.
                 */
                if (!isRegistered()) return;
                mWrappee.loadAttachmentCallback(result, accountId, messageId, attachmentId,
                        progress);
            }
        });
    }

    @Override
    public void loadMessageForViewCallback(final MessagingException result, final long accountId,
            final long messageId, final int progress) {
        run(new Runnable() {
            public void run() {
                if (!isRegistered()) return;
                mWrappee.loadMessageForViewCallback(result, accountId, messageId, progress);
            }
        });
    }

    @Override
    public void sendMailCallback(final MessagingException result, final long accountId,
            final long messageId, final int progress) {
        run(new Runnable() {
            public void run() {
                if (!isRegistered()) return;
                mWrappee.sendMailCallback(result, accountId, messageId, progress);
            }
        });
    }

    @Override
    public void serviceCheckMailCallback(final MessagingException result, final long accountId,
            final long mailboxId, final int progress, final long tag) {
        run(new Runnable() {
            public void run() {
                if (!isRegistered()) return;
                mWrappee.serviceCheckMailCallback(result, accountId, mailboxId, progress, tag);
            }
        });
    }

    @Override
    public void updateMailboxCallback(final MessagingException result, final long accountId,
            final long mailboxId, final int progress, final int numNewMessages,
            final ArrayList<Long> addedMessages) {
        run(new Runnable() {
            public void run() {
                if (!isRegistered()) return;
                mWrappee.updateMailboxCallback(result, accountId, mailboxId, progress,
                        numNewMessages, addedMessages);
            }
        });
    }

    @Override
    public void updateMailboxListCallback(final MessagingException result, final long accountId,
            final int progress) {
        run(new Runnable() {
            public void run() {
                if (!isRegistered()) return;
                mWrappee.updateMailboxListCallback(result, accountId, progress);
            }
        });
    }
}
 ",True,267,0,0,10,48,4,2,L6
21,com.android.email.GroupMessagingListener.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.mail.MessagingException;

import android.content.Context;

import java.util.ArrayList;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

public class GroupMessagingListener extends MessagingListener {
    /* The synchronization of the methods in this class
       is not needed because we use ConcurrentHashMap.

       Nevertheless, let's keep the ""synchronized"" for a while in the case
       we may want to change the implementation to use something else
       than ConcurrentHashMap.
    */

    private ConcurrentHashMap<MessagingListener, Object> mListenersMap =
        new ConcurrentHashMap<MessagingListener, Object>();

    private Set<MessagingListener> mListeners = mListenersMap.keySet();

    synchronized public void addListener(MessagingListener listener) {
        // we use ""this"" as a dummy non-null value
        mListenersMap.put(listener, this);
    }

    synchronized public void removeListener(MessagingListener listener) {
        mListenersMap.remove(listener);
    }

    synchronized public boolean isActiveListener(MessagingListener listener) {
        return mListenersMap.containsKey(listener);
    }

    @Override
    synchronized public void listFoldersStarted(long accountId) {
        for (MessagingListener l : mListeners) {
            l.listFoldersStarted(accountId);
        }
    }

    @Override
    synchronized public void listFoldersFailed(long accountId, String message) {
        for (MessagingListener l : mListeners) {
            l.listFoldersFailed(accountId, message);
        }
    }

    @Override
    synchronized public void listFoldersFinished(long accountId) {
        for (MessagingListener l : mListeners) {
            l.listFoldersFinished(accountId);
        }
    }

    @Override
    synchronized public void synchronizeMailboxStarted(long accountId, long mailboxId) {
        for (MessagingListener l : mListeners) {
            l.synchronizeMailboxStarted(accountId, mailboxId);
        }
    }

    @Override
    synchronized public void synchronizeMailboxFinished(long accountId, long mailboxId,
            int totalMessagesInMailbox, int numNewMessages, ArrayList<Long> addedMessages) {
        for (MessagingListener l : mListeners) {
            l.synchronizeMailboxFinished(accountId, mailboxId,
                    totalMessagesInMailbox, numNewMessages, addedMessages);
        }
    }

    @Override
    synchronized public void synchronizeMailboxFailed(long accountId, long mailboxId, Exception e) {
        for (MessagingListener l : mListeners) {
            l.synchronizeMailboxFailed(accountId, mailboxId, e);
        }
    }

    @Override
    synchronized public void loadMessageForViewStarted(long messageId) {
        for (MessagingListener l : mListeners) {
            l.loadMessageForViewStarted(messageId);
        }
    }

    @Override
    synchronized public void loadMessageForViewFinished(long messageId) {
        for (MessagingListener l : mListeners) {
            l.loadMessageForViewFinished(messageId);
        }
    }

    @Override
    synchronized public void loadMessageForViewFailed(long messageId, String message) {
        for (MessagingListener l : mListeners) {
            l.loadMessageForViewFailed(messageId, message);
        }
    }

    @Override
    synchronized public void checkMailStarted(Context context, long accountId, long tag) {
        for (MessagingListener l : mListeners) {
            l.checkMailStarted(context, accountId, tag);
        }
    }

    @Override
    synchronized public void checkMailFinished(Context context, long accountId, long folderId,
            long tag) {
        for (MessagingListener l : mListeners) {
            l.checkMailFinished(context, accountId, folderId, tag);
        }
    }

    @Override
    synchronized public void sendPendingMessagesStarted(long accountId, long messageId) {
        for (MessagingListener l : mListeners) {
            l.sendPendingMessagesStarted(accountId, messageId);
        }
    }

    @Override
    synchronized public void sendPendingMessagesCompleted(long accountId) {
        for (MessagingListener l : mListeners) {
            l.sendPendingMessagesCompleted(accountId);
        }
    }

    @Override
    synchronized public void sendPendingMessagesFailed(long accountId, long messageId,
            Exception reason) {
        for (MessagingListener l : mListeners) {
            l.sendPendingMessagesFailed(accountId, messageId, reason);
        }
    }

    @Override
    synchronized public void messageUidChanged(long accountId, long mailboxId,
            String oldUid, String newUid) {
        for (MessagingListener l : mListeners) {
            l.messageUidChanged(accountId, mailboxId, oldUid, newUid);
        }
    }

    @Override
    synchronized public void loadAttachmentStarted(
            long accountId,
            long messageId,
            long attachmentId,
            boolean requiresDownload) {
        for (MessagingListener l : mListeners) {
            l.loadAttachmentStarted(accountId, messageId, attachmentId, requiresDownload);
        }
    }

    @Override
    synchronized public void loadAttachmentFinished(
            long accountId,
            long messageId,
            long attachmentId) {
        for (MessagingListener l : mListeners) {
            l.loadAttachmentFinished(accountId, messageId, attachmentId);
        }
    }

    @Override
    synchronized public void loadAttachmentFailed(
            long accountId,
            long messageId,
            long attachmentId,
            MessagingException me,
            boolean background) {
        for (MessagingListener l : mListeners) {
            l.loadAttachmentFailed(accountId, messageId, attachmentId, me, background);
        }
    }

    @Override
    synchronized public void controllerCommandCompleted(boolean moreCommandsToRun) {
        for (MessagingListener l : mListeners) {
            l.controllerCommandCompleted(moreCommandsToRun);
        }
    }
}
",False,150,8,54,1,2,2,2,L1
22,com.android.email.MessagingListener.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.mail.MessagingException;

import android.content.Context;

import java.util.ArrayList;

/**
 * Defines the interface that MessagingController will use to callback to requesters. This class
 * is defined as non-abstract so that someone who wants to receive only a few messages can
 * do so without implementing the entire interface. It is highly recommended that users of
 * this interface use the @Override annotation in their implementations to avoid being caught by
 * changes in this class.
 */
public class MessagingListener {
    public MessagingListener() {
    }

    public void listFoldersStarted(long accountId) {
    }

    public void listFoldersFailed(long accountId, String message) {
    }

    public void listFoldersFinished(long accountId) {
    }

    public void synchronizeMailboxStarted(long accountId, long mailboxId) {
    }

    /**
     * Synchronization of the mailbox finished. The mailbox and/or message databases have been
     * updated accordingly.
     *
     * @param accountId The account that was synchronized
     * @param mailboxId The mailbox that was synchronized
     * @param totalMessagesInMailbox The total number of messages in the mailbox
     * @param numNewMessages The number of new messages
     * @param addedMessages Message IDs of messages that were added during the synchronization.
     * These are new, unread messages. Messages that were previously read are not in this list.
     */
    public void synchronizeMailboxFinished(long accountId, long mailboxId,
            int totalMessagesInMailbox, int numNewMessages, ArrayList<Long> addedMessages) {
    }

    public void synchronizeMailboxFailed(long accountId, long mailboxId, Exception e) {
    }

    public void loadMessageForViewStarted(long messageId) {
    }

    public void loadMessageForViewFinished(long messageId) {
    }

    public void loadMessageForViewFailed(long messageId, String message) {
    }

    public void checkMailStarted(Context context, long accountId, long tag) {
    }

    public void checkMailFinished(Context context, long accountId, long mailboxId, long tag) {
    }

    public void sendPendingMessagesStarted(long accountId, long messageId) {
    }

    public void sendPendingMessagesCompleted(long accountId) {
    }

    public void sendPendingMessagesFailed(long accountId, long messageId, Exception reason) {
    }

    public void messageUidChanged(long accountId, long mailboxId, String oldUid, String newUid) {
    }

    public void loadAttachmentStarted(
            long accountId,
            long messageId,
            long attachmentId,
            boolean requiresDownload) {
    }

    public void loadAttachmentFinished(
            long accountId,
            long messageId,
            long attachmentId) {
    }

    public void loadAttachmentFailed(
            long accountId,
            long messageId,
            long attachmentId,
            MessagingException me,
            boolean background) {
    }

    /**
     * General notification messages subclasses can override to be notified that the controller
     * has completed a command. This is useful for turning off progress indicators that may have
     * been left over from previous commands.
     * @param moreCommandsToRun True if the controller will continue on to another command
     * immediately.
     */
    public void controllerCommandCompleted(boolean moreCommandsToRun) {

    }
}
",False,150,7,54,1,1,4,1,L1
23,com.android.email.EmailAddressValidator.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.mail.Address;

import android.widget.AutoCompleteTextView.Validator;

public class EmailAddressValidator implements Validator {
    public CharSequence fixText(CharSequence invalidText) {
        return """";
    }

    public boolean isValid(CharSequence text) {
        return Address.parse(text.toString()).length > 0;
    }
}
",False,169,7,56,5,12,3,1,L6
24,com.android.email.SecurityPolicy.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.app.admin.DeviceAdminInfo;
import android.app.admin.DeviceAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.util.Log;

import com.android.email.service.EmailBroadcastProcessorService;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.EmailContent.PolicyColumns;
import com.android.emailcommon.provider.Policy;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

/**
 * Utility functions to support reading and writing security policies, and handshaking the device
 * into and out of various security states.
 */
public class SecurityPolicy {
    private static final String TAG = ""Email/SecurityPolicy"";
    private static SecurityPolicy sInstance = null;
    private Context mContext;
    private DevicePolicyManager mDPM;
    private final ComponentName mAdminName;
    private Policy mAggregatePolicy;

    // Messages used for DevicePolicyManager callbacks
    private static final int DEVICE_ADMIN_MESSAGE_ENABLED = 1;
    private static final int DEVICE_ADMIN_MESSAGE_DISABLED = 2;
    private static final int DEVICE_ADMIN_MESSAGE_PASSWORD_CHANGED = 3;
    private static final int DEVICE_ADMIN_MESSAGE_PASSWORD_EXPIRING = 4;

    private static final String HAS_PASSWORD_EXPIRATION =
        PolicyColumns.PASSWORD_EXPIRATION_DAYS + "">0"";

    /**
     * Get the security policy instance
     */
    public synchronized static SecurityPolicy getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new SecurityPolicy(context.getApplicationContext());
        }
        return sInstance;
    }

    /**
     * Private constructor (one time only)
     */
    private SecurityPolicy(Context context) {
        mContext = context.getApplicationContext();
        mDPM = null;
        mAdminName = new ComponentName(context, PolicyAdmin.class);
        mAggregatePolicy = null;
    }

    /**
     * For testing only: Inject context into already-created instance
     */
    /* package */ void setContext(Context context) {
        mContext = context;
    }

    /**
     * Compute the aggregate policy for all accounts that require it, and record it.
     *
     * The business logic is as follows:
     *  min password length         take the max
     *  password mode               take the max (strongest mode)
     *  max password fails          take the min
     *  max screen lock time        take the min
     *  require remote wipe         take the max (logical or)
     *  password history            take the max (strongest mode)
     *  password expiration         take the min (strongest mode)
     *  password complex chars      take the max (strongest mode)
     *  encryption                  take the max (logical or)
     *
     * @return a policy representing the strongest aggregate.  If no policy sets are defined,
     * a lightweight ""nothing required"" policy will be returned.  Never null.
     */
    @VisibleForTesting
    Policy computeAggregatePolicy() {
        boolean policiesFound = false;
        Policy aggregate = new Policy();
        aggregate.mPasswordMinLength = Integer.MIN_VALUE;
        aggregate.mPasswordMode = Integer.MIN_VALUE;
        aggregate.mPasswordMaxFails = Integer.MAX_VALUE;
        aggregate.mPasswordHistory = Integer.MIN_VALUE;
        aggregate.mPasswordExpirationDays = Integer.MAX_VALUE;
        aggregate.mPasswordComplexChars = Integer.MIN_VALUE;
        aggregate.mMaxScreenLockTime = Integer.MAX_VALUE;
        aggregate.mRequireRemoteWipe = false;
        aggregate.mRequireEncryption = false;

        // This can never be supported at this time. It exists only for historic reasons where
        // this was able to be supported prior to the introduction of proper removable storage
        // support for external storage.
        aggregate.mRequireEncryptionExternal = false;

        Cursor c = mContext.getContentResolver().query(Policy.CONTENT_URI,
                Policy.CONTENT_PROJECTION, null, null, null);
        Policy policy = new Policy();
        try {
            while (c.moveToNext()) {
                policy.restore(c);
                if (Email.DEBUG) {
                    Log.d(TAG, ""Aggregate from: "" + policy);
                }
                aggregate.mPasswordMinLength =
                    Math.max(policy.mPasswordMinLength, aggregate.mPasswordMinLength);
                aggregate.mPasswordMode  = Math.max(policy.mPasswordMode, aggregate.mPasswordMode);
                if (policy.mPasswordMaxFails > 0) {
                    aggregate.mPasswordMaxFails =
                        Math.min(policy.mPasswordMaxFails, aggregate.mPasswordMaxFails);
                }
                if (policy.mMaxScreenLockTime > 0) {
                    aggregate.mMaxScreenLockTime = Math.min(policy.mMaxScreenLockTime,
                            aggregate.mMaxScreenLockTime);
                }
                if (policy.mPasswordHistory > 0) {
                    aggregate.mPasswordHistory =
                        Math.max(policy.mPasswordHistory, aggregate.mPasswordHistory);
                }
                if (policy.mPasswordExpirationDays > 0) {
                    aggregate.mPasswordExpirationDays =
                        Math.min(policy.mPasswordExpirationDays, aggregate.mPasswordExpirationDays);
                }
                if (policy.mPasswordComplexChars > 0) {
                    aggregate.mPasswordComplexChars = Math.max(policy.mPasswordComplexChars,
                            aggregate.mPasswordComplexChars);
                }
                aggregate.mRequireRemoteWipe |= policy.mRequireRemoteWipe;
                aggregate.mRequireEncryption |= policy.mRequireEncryption;
                aggregate.mDontAllowCamera |= policy.mDontAllowCamera;
                policiesFound = true;
            }
        } finally {
            c.close();
        }
        if (policiesFound) {
            // final cleanup pass converts any untouched min/max values to zero (not specified)
            if (aggregate.mPasswordMinLength == Integer.MIN_VALUE) aggregate.mPasswordMinLength = 0;
            if (aggregate.mPasswordMode == Integer.MIN_VALUE) aggregate.mPasswordMode = 0;
            if (aggregate.mPasswordMaxFails == Integer.MAX_VALUE) aggregate.mPasswordMaxFails = 0;
            if (aggregate.mMaxScreenLockTime == Integer.MAX_VALUE) aggregate.mMaxScreenLockTime = 0;
            if (aggregate.mPasswordHistory == Integer.MIN_VALUE) aggregate.mPasswordHistory = 0;
            if (aggregate.mPasswordExpirationDays == Integer.MAX_VALUE)
                aggregate.mPasswordExpirationDays = 0;
            if (aggregate.mPasswordComplexChars == Integer.MIN_VALUE)
                aggregate.mPasswordComplexChars = 0;
            if (Email.DEBUG) {
                Log.d(TAG, ""Calculated Aggregate: "" + aggregate);
            }
            return aggregate;
        }
        if (Email.DEBUG) {
            Log.d(TAG, ""Calculated Aggregate: no policy"");
        }
        return Policy.NO_POLICY;
    }

    /**
     * Return updated aggregate policy, from cached value if possible
     */
    public synchronized Policy getAggregatePolicy() {
        if (mAggregatePolicy == null) {
            mAggregatePolicy = computeAggregatePolicy();
        }
        return mAggregatePolicy;
    }

    /**
     * Get the dpm.  This mainly allows us to make some utility calls without it, for testing.
     */
    /* package */ synchronized DevicePolicyManager getDPM() {
        if (mDPM == null) {
            mDPM = (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
        }
        return mDPM;
    }

    /**
     * API: Report that policies may have been updated due to rewriting values in an Account.
     * @param accountId the account that has been updated, -1 if unknown/deleted
     */
    public synchronized void policiesUpdated(long accountId) {
        mAggregatePolicy = null;
    }

    /**
     * API: Report that policies may have been updated *and* the caller vouches that the
     * change is a reduction in policies.  This forces an immediate change to device state.
     * Typically used when deleting accounts, although we may use it for server-side policy
     * rollbacks.
     */
    public void reducePolicies() {
        if (Email.DEBUG) {
            Log.d(TAG, ""reducePolicies"");
        }
        policiesUpdated(-1);
        setActivePolicies();
    }

    /**
     * API: Query if the proposed set of policies are supported on the device.
     *
     * @param policy the polices that were requested
     * @return boolean if supported
     */
    public boolean isSupported(Policy policy) {
        // IMPLEMENTATION:  At this time, the only policy which might not be supported is
        // encryption (which requires low-level systems support).  Other policies are fully
        // supported by the framework and do not need to be checked.
        if (policy.mRequireEncryption) {
            int encryptionStatus = getDPM().getStorageEncryptionStatus();
            if (encryptionStatus == DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED) {
                return false;
            }
        }

        // If we ever support devices that can't disable cameras for any reason, we should
        // indicate as such in the mDontAllowCamera policy

        return true;
    }

    /**
     * API: Remove any unsupported policies
     *
     * This is used when we have a set of polices that have been requested, but the server
     * is willing to allow unsupported policies to be considered optional.
     *
     * @param policy the polices that were requested
     * @return the same PolicySet if all are supported;  A replacement PolicySet if any
     *   unsupported policies were removed
     */
    public Policy clearUnsupportedPolicies(Policy policy) {
        // IMPLEMENTATION:  At this time, the only policy which might not be supported is
        // encryption (which requires low-level systems support).  Other policies are fully
        // supported by the framework and do not need to be checked.
        if (policy.mRequireEncryption) {
            int encryptionStatus = getDPM().getStorageEncryptionStatus();
            if (encryptionStatus == DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED) {
                policy.mRequireEncryption = false;
            }
        }

        // If we ever support devices that can't disable cameras for any reason, we should
        // clear the mDontAllowCamera policy

        return policy;
    }

    /**
     * API: Query used to determine if a given policy is ""active"" (the device is operating at
     * the required security level).
     *
     * @param policy the policies requested, or null to check aggregate stored policies
     * @return true if the requested policies are active, false if not.
     */
    public boolean isActive(Policy policy) {
        int reasons = getInactiveReasons(policy);
        if (Email.DEBUG && (reasons != 0)) {
            StringBuilder sb = new StringBuilder(""isActive for "" + policy + "": "");
            if (reasons == 0) {
                sb.append(""true"");
            } else {
                sb.append(""FALSE -> "");
            }
            if ((reasons & INACTIVE_NEED_ACTIVATION) != 0) {
                sb.append(""no_admin "");
            }
            if ((reasons & INACTIVE_NEED_CONFIGURATION) != 0) {
                sb.append(""config "");
            }
            if ((reasons & INACTIVE_NEED_PASSWORD) != 0) {
                sb.append(""password "");
            }
            if ((reasons & INACTIVE_NEED_ENCRYPTION) != 0) {
                sb.append(""encryption "");
            }
            Log.d(TAG, sb.toString());
        }
        return reasons == 0;
    }

    /**
     * Return bits from isActive:  Device Policy Manager has not been activated
     */
    public final static int INACTIVE_NEED_ACTIVATION = 1;

    /**
     * Return bits from isActive:  Some required configuration is not correct (no user action).
     */
    public final static int INACTIVE_NEED_CONFIGURATION = 2;

    /**
     * Return bits from isActive:  Password needs to be set or updated
     */
    public final static int INACTIVE_NEED_PASSWORD = 4;

    /**
     * Return bits from isActive:  Encryption has not be enabled
     */
    public final static int INACTIVE_NEED_ENCRYPTION = 8;

    /**
     * API: Query used to determine if a given policy is ""active"" (the device is operating at
     * the required security level).
     *
     * This can be used when syncing a specific account, by passing a specific set of policies
     * for that account.  Or, it can be used at any time to compare the device
     * state against the aggregate set of device policies stored in all accounts.
     *
     * This method is for queries only, and does not trigger any change in device state.
     *
     * NOTE:  If there are multiple accounts with password expiration policies, the device
     * password will be set to expire in the shortest required interval (most secure).  This method
     * will return 'false' as soon as the password expires - irrespective of which account caused
     * the expiration.  In other words, all accounts (that require expiration) will run/stop
     * based on the requirements of the account with the shortest interval.
     *
     * @param policy the policies requested, or null to check aggregate stored policies
     * @return zero if the requested policies are active, non-zero bits indicates that more work
     * is needed (typically, by the user) before the required security polices are fully active.
     */
    public int getInactiveReasons(Policy policy) {
        // select aggregate set if needed
        if (policy == null) {
            policy = getAggregatePolicy();
        }
        // quick check for the ""empty set"" of no policies
        if (policy == Policy.NO_POLICY) {
            return 0;
        }
        int reasons = 0;
        DevicePolicyManager dpm = getDPM();
        if (isActiveAdmin()) {
            // check each policy explicitly
            if (policy.mPasswordMinLength > 0) {
                if (dpm.getPasswordMinimumLength(mAdminName) < policy.mPasswordMinLength) {
                    reasons |= INACTIVE_NEED_PASSWORD;
                }
            }
            if (policy.mPasswordMode > 0) {
                if (dpm.getPasswordQuality(mAdminName) < policy.getDPManagerPasswordQuality()) {
                    reasons |= INACTIVE_NEED_PASSWORD;
                }
                if (!dpm.isActivePasswordSufficient()) {
                    reasons |= INACTIVE_NEED_PASSWORD;
                }
            }
            if (policy.mMaxScreenLockTime > 0) {
                // Note, we use seconds, dpm uses milliseconds
                if (dpm.getMaximumTimeToLock(mAdminName) > policy.mMaxScreenLockTime * 1000) {
                    reasons |= INACTIVE_NEED_CONFIGURATION;
                }
            }
            if (policy.mPasswordExpirationDays > 0) {
                // confirm that expirations are currently set
                long currentTimeout = dpm.getPasswordExpirationTimeout(mAdminName);
                if (currentTimeout == 0
                        || currentTimeout > policy.getDPManagerPasswordExpirationTimeout()) {
                    reasons |= INACTIVE_NEED_PASSWORD;
                }
                // confirm that the current password hasn't expired
                long expirationDate = dpm.getPasswordExpiration(mAdminName);
                long timeUntilExpiration = expirationDate - System.currentTimeMillis();
                boolean expired = timeUntilExpiration < 0;
                if (expired) {
                    reasons |= INACTIVE_NEED_PASSWORD;
                }
            }
            if (policy.mPasswordHistory > 0) {
                if (dpm.getPasswordHistoryLength(mAdminName) < policy.mPasswordHistory) {
                    // There's no user action for changes here; this is just a configuration change
                    reasons |= INACTIVE_NEED_CONFIGURATION;
                }
            }
            if (policy.mPasswordComplexChars > 0) {
                if (dpm.getPasswordMinimumNonLetter(mAdminName) < policy.mPasswordComplexChars) {
                    reasons |= INACTIVE_NEED_PASSWORD;
                }
            }
            if (policy.mRequireEncryption) {
                int encryptionStatus = getDPM().getStorageEncryptionStatus();
                if (encryptionStatus != DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE) {
                    reasons |= INACTIVE_NEED_ENCRYPTION;
                }
            }
            if (policy.mDontAllowCamera && !dpm.getCameraDisabled(mAdminName)) {
                reasons |= INACTIVE_NEED_CONFIGURATION;
            }
            // password failures are counted locally - no test required here
            // no check required for remote wipe (it's supported, if we're the admin)

            // If we made it all the way, reasons == 0 here.  Otherwise it's a list of grievances.
            return reasons;
        }
        // return false, not active
        return INACTIVE_NEED_ACTIVATION;
    }

    /**
     * Set the requested security level based on the aggregate set of requests.
     * If the set is empty, we release our device administration.  If the set is non-empty,
     * we only proceed if we are already active as an admin.
     */
    public void setActivePolicies() {
        DevicePolicyManager dpm = getDPM();
        // compute aggregate set of policies
        Policy aggregatePolicy = getAggregatePolicy();
        // if empty set, detach from policy manager
        if (aggregatePolicy == Policy.NO_POLICY) {
            if (Email.DEBUG) {
                Log.d(TAG, ""setActivePolicies: none, remove admin"");
            }
            dpm.removeActiveAdmin(mAdminName);
        } else if (isActiveAdmin()) {
            if (Email.DEBUG) {
                Log.d(TAG, ""setActivePolicies: "" + aggregatePolicy);
            }
            // set each policy in the policy manager
            // password mode & length
            dpm.setPasswordQuality(mAdminName, aggregatePolicy.getDPManagerPasswordQuality());
            dpm.setPasswordMinimumLength(mAdminName, aggregatePolicy.mPasswordMinLength);
            // screen lock time
            dpm.setMaximumTimeToLock(mAdminName, aggregatePolicy.mMaxScreenLockTime * 1000);
            // local wipe (failed passwords limit)
            dpm.setMaximumFailedPasswordsForWipe(mAdminName, aggregatePolicy.mPasswordMaxFails);
            // password expiration (days until a password expires).  API takes mSec.
            dpm.setPasswordExpirationTimeout(mAdminName,
                    aggregatePolicy.getDPManagerPasswordExpirationTimeout());
            // password history length (number of previous passwords that may not be reused)
            dpm.setPasswordHistoryLength(mAdminName, aggregatePolicy.mPasswordHistory);
            // password minimum complex characters.
            // Note, in Exchange, ""complex chars"" simply means ""non alpha"", but in the DPM,
            // setting the quality to complex also defaults min symbols=1 and min numeric=1.
            // We always / safely clear minSymbols & minNumeric to zero (there is no policy
            // configuration in which we explicitly require a minimum number of digits or symbols.)
            dpm.setPasswordMinimumSymbols(mAdminName, 0);
            dpm.setPasswordMinimumNumeric(mAdminName, 0);
            dpm.setPasswordMinimumNonLetter(mAdminName, aggregatePolicy.mPasswordComplexChars);
            // Device capabilities
            dpm.setCameraDisabled(mAdminName, aggregatePolicy.mDontAllowCamera);

            // encryption required
            dpm.setStorageEncryption(mAdminName, aggregatePolicy.mRequireEncryption);
        }
    }

    /**
     * Convenience method; see javadoc below
     */
    public static void setAccountHoldFlag(Context context, long accountId, boolean newState) {
        Account account = Account.restoreAccountWithId(context, accountId);
        if (account != null) {
            setAccountHoldFlag(context, account, newState);
        }
    }

    /**
     * API: Set/Clear the ""hold"" flag in any account.  This flag serves a dual purpose:
     * Setting it gives us an indication that it was blocked, and clearing it gives EAS a
     * signal to try syncing again.
     * @param context
     * @param account the account whose hold flag is to be set/cleared
     * @param newState true = security hold, false = free to sync
     */
    public static void setAccountHoldFlag(Context context, Account account, boolean newState) {
        if (newState) {
            account.mFlags |= Account.FLAGS_SECURITY_HOLD;
        } else {
            account.mFlags &= ~Account.FLAGS_SECURITY_HOLD;
        }
        ContentValues cv = new ContentValues();
        cv.put(AccountColumns.FLAGS, account.mFlags);
        account.update(context, cv);
    }

    /**
     * API: Sync service should call this any time a sync fails due to isActive() returning false.
     * This will kick off the notify-acquire-admin-state process and/or increase the security level.
     * The caller needs to write the required policies into this account before making this call.
     * Should not be called from UI thread - uses DB lookups to prepare new notifications
     *
     * @param accountId the account for which sync cannot proceed
     */
    public void policiesRequired(long accountId) {
        Account account = Account.restoreAccountWithId(mContext, accountId);
        // In case the account has been deleted, just return
        if (account == null) return;
        if (Email.DEBUG) {
            if (account.mPolicyKey == 0) {
                Log.d(TAG, ""policiesRequired for "" + account.mDisplayName + "": none"");
            } else {
                Policy policy = Policy.restorePolicyWithId(mContext, account.mPolicyKey);
                if (policy == null) {
                    Log.w(TAG, ""No policy??"");
                } else {
                    Log.d(TAG, ""policiesRequired for "" + account.mDisplayName + "": "" + policy);
                }
            }
        }

        // Mark the account as ""on hold"".
        setAccountHoldFlag(mContext, account, true);

        // Put up a notification
        NotificationController.getInstance(mContext).showSecurityNeededNotification(account);
    }

    /**
     * Called from the notification's intent receiver to register that the notification can be
     * cleared now.
     */
    public void clearNotification() {
        NotificationController.getInstance(mContext).cancelSecurityNeededNotification();
    }

    /**
     * API: Remote wipe (from server).  This is final, there is no confirmation.  It will only
     * return to the caller if there is an unexpected failure.  The wipe includes external storage.
     */
    public void remoteWipe() {
        DevicePolicyManager dpm = getDPM();
        if (dpm.isAdminActive(mAdminName)) {
            dpm.wipeData(DevicePolicyManager.WIPE_EXTERNAL_STORAGE);
        } else {
            Log.d(Logging.LOG_TAG, ""Could not remote wipe because not device admin."");
        }
    }
    /**
     * If we are not the active device admin, try to become so.
     *
     * Also checks for any policies that we have added during the lifetime of this app.
     * This catches the case where the user granted an earlier (smaller) set of policies
     * but an app upgrade requires that new policies be granted.
     *
     * @return true if we are already active, false if we are not
     */
    public boolean isActiveAdmin() {
        DevicePolicyManager dpm = getDPM();
        return dpm.isAdminActive(mAdminName)
                && dpm.hasGrantedPolicy(mAdminName, DeviceAdminInfo.USES_POLICY_EXPIRE_PASSWORD)
                && dpm.hasGrantedPolicy(mAdminName, DeviceAdminInfo.USES_ENCRYPTED_STORAGE)
                && dpm.hasGrantedPolicy(mAdminName, DeviceAdminInfo.USES_POLICY_DISABLE_CAMERA);
    }

    /**
     * Report admin component name - for making calls into device policy manager
     */
    public ComponentName getAdminComponent() {
        return mAdminName;
    }

    /**
     * Delete all accounts whose security flags aren't zero (i.e. they have security enabled).
     * This method is synchronous, so it should normally be called within a worker thread (the
     * exception being for unit tests)
     *
     * @param context the caller's context
     */
    /*package*/ void deleteSecuredAccounts(Context context) {
        ContentResolver cr = context.getContentResolver();
        // Find all accounts with security and delete them
        Cursor c = cr.query(Account.CONTENT_URI, EmailContent.ID_PROJECTION,
                Account.SECURITY_NONZERO_SELECTION, null, null);
        try {
            Log.w(TAG, ""Email administration disabled; deleting "" + c.getCount() +
                    "" secured account(s)"");
            while (c.moveToNext()) {
                Controller.getInstance(context).deleteAccountSync(
                        c.getLong(EmailContent.ID_PROJECTION_COLUMN), context);
            }
        } finally {
            c.close();
        }
        policiesUpdated(-1);
    }

    /**
     * Internal handler for enabled->disabled transitions.  Deletes all secured accounts.
     * Must call from worker thread, not on UI thread.
     */
    /*package*/ void onAdminEnabled(boolean isEnabled) {
        if (!isEnabled) {
            deleteSecuredAccounts(mContext);
        }
    }

    /**
     * Handle password expiration - if any accounts appear to have triggered this, put up
     * warnings, or even shut them down.
     *
     * NOTE:  If there are multiple accounts with password expiration policies, the device
     * password will be set to expire in the shortest required interval (most secure).  The logic
     * in this method operates based on the aggregate setting - irrespective of which account caused
     * the expiration.  In other words, all accounts (that require expiration) will run/stop
     * based on the requirements of the account with the shortest interval.
     */
    private void onPasswordExpiring(Context context) {
        // 1.  Do we have any accounts that matter here?
        long nextExpiringAccountId = findShortestExpiration(context);

        // 2.  If not, exit immediately
        if (nextExpiringAccountId == -1) {
            return;
        }

        // 3.  If yes, are we warning or expired?
        long expirationDate = getDPM().getPasswordExpiration(mAdminName);
        long timeUntilExpiration = expirationDate - System.currentTimeMillis();
        boolean expired = timeUntilExpiration < 0;
        if (!expired) {
            // 4.  If warning, simply put up a generic notification and report that it came from
            // the shortest-expiring account.
            NotificationController.getInstance(mContext).showPasswordExpiringNotification(
                    nextExpiringAccountId);
        } else {
            // 5.  Actually expired - find all accounts that expire passwords, and wipe them
            boolean wiped = wipeExpiredAccounts(context, Controller.getInstance(context));
            if (wiped) {
                NotificationController.getInstance(mContext).showPasswordExpiredNotification(
                        nextExpiringAccountId);
            }
        }
    }

    /**
     * Find the account with the shortest expiration time.  This is always assumed to be
     * the account that forces the password to be refreshed.
     * @return -1 if no expirations, or accountId if one is found
     */
    @VisibleForTesting
    /*package*/ static long findShortestExpiration(Context context) {
        long policyId = Utility.getFirstRowLong(context, Policy.CONTENT_URI, Policy.ID_PROJECTION,
                HAS_PASSWORD_EXPIRATION, null, PolicyColumns.PASSWORD_EXPIRATION_DAYS + "" ASC"",
                EmailContent.ID_PROJECTION_COLUMN, -1L);
        if (policyId < 0) return -1L;
        return Policy.getAccountIdWithPolicyKey(context, policyId);
    }

    /**
     * For all accounts that require password expiration, put them in security hold and wipe
     * their data.
     * @param context
     * @param controller
     * @return true if one or more accounts were wiped
     */
    @VisibleForTesting
    /*package*/ static boolean wipeExpiredAccounts(Context context, Controller controller) {
        boolean result = false;
        Cursor c = context.getContentResolver().query(Policy.CONTENT_URI,
                Policy.ID_PROJECTION, HAS_PASSWORD_EXPIRATION, null, null);
        try {
            while (c.moveToNext()) {
                long policyId = c.getLong(Policy.ID_PROJECTION_COLUMN);
                long accountId = Policy.getAccountIdWithPolicyKey(context, policyId);
                if (accountId < 0) continue;
                Account account = Account.restoreAccountWithId(context, accountId);
                if (account != null) {
                    // Mark the account as ""on hold"".
                    setAccountHoldFlag(context, account, true);
                    // Erase data
                    controller.deleteSyncedDataSync(accountId);
                    // Report one or more were found
                    result = true;
                }
            }
        } finally {
            c.close();
        }
        return result;
    }

    /**
     * Callback from EmailBroadcastProcessorService.  This provides the workers for the
     * DeviceAdminReceiver calls.  These should perform the work directly and not use async
     * threads for completion.
     */
    public static void onDeviceAdminReceiverMessage(Context context, int message) {
        SecurityPolicy instance = SecurityPolicy.getInstance(context);
        switch (message) {
            case DEVICE_ADMIN_MESSAGE_ENABLED:
                instance.onAdminEnabled(true);
                break;
            case DEVICE_ADMIN_MESSAGE_DISABLED:
                instance.onAdminEnabled(false);
                break;
            case DEVICE_ADMIN_MESSAGE_PASSWORD_CHANGED:
                // TODO make a small helper for this
                // Clear security holds (if any)
                Account.clearSecurityHoldOnAllAccounts(context);
                // Cancel any active notifications (if any are posted)
                NotificationController.getInstance(context).cancelPasswordExpirationNotifications();
                break;
            case DEVICE_ADMIN_MESSAGE_PASSWORD_EXPIRING:
                instance.onPasswordExpiring(instance.mContext);
                break;
        }
    }

    /**
     * Device Policy administrator.  This is primarily a listener for device state changes.
     * Note:  This is instantiated by incoming messages.
     * Note:  This is actually a BroadcastReceiver and must remain within the guidelines required
     *        for proper behavior, including avoidance of ANRs.
     * Note:  We do not implement onPasswordFailed() because the default behavior of the
     *        DevicePolicyManager - complete local wipe after 'n' failures - is sufficient.
     */
    public static class PolicyAdmin extends DeviceAdminReceiver {

        /**
         * Called after the administrator is first enabled.
         */
        @Override
        public void onEnabled(Context context, Intent intent) {
            EmailBroadcastProcessorService.processDevicePolicyMessage(context,
                    DEVICE_ADMIN_MESSAGE_ENABLED);
        }

        /**
         * Called prior to the administrator being disabled.
         */
        @Override
        public void onDisabled(Context context, Intent intent) {
            EmailBroadcastProcessorService.processDevicePolicyMessage(context,
                    DEVICE_ADMIN_MESSAGE_DISABLED);
        }

        /**
         * Called when the user asks to disable administration; we return a warning string that
         * will be presented to the user
         */
        @Override
        public CharSequence onDisableRequested(Context context, Intent intent) {
            return context.getString(R.string.disable_admin_warning);
        }

        /**
         * Called after the user has changed their password.
         */
        @Override
        public void onPasswordChanged(Context context, Intent intent) {
            EmailBroadcastProcessorService.processDevicePolicyMessage(context,
                    DEVICE_ADMIN_MESSAGE_PASSWORD_CHANGED);
        }

        /**
         * Called when device password is expiring
         */
        @Override
        public void onPasswordExpiring(Context context, Intent intent) {
            EmailBroadcastProcessorService.processDevicePolicyMessage(context,
                    DEVICE_ADMIN_MESSAGE_PASSWORD_EXPIRING);
        }
    }
}
",True,269,1,2,10,58,5,9,L6
25,com.android.email.SingleRunningTask.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.emailcommon.Logging;

import android.util.Log;

import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Base class for a task that runs at most one instance at any given moment.
 *
 * Call {@link #run} to start the task.  If the task is already running on another thread, it'll do
 * nothing.
 */
public abstract class SingleRunningTask<Param> {
    private final AtomicBoolean mIsRunning = new AtomicBoolean(false);
    private final String mLogTaskName;

    public SingleRunningTask(String logTaskName) {
        mLogTaskName = logTaskName;
    }

    /**
     * Calls {@link #runInternal} if it's not running already.
     */
    public final void run(Param param) {
        if (mIsRunning.compareAndSet(false, true)) {
            Log.i(Logging.LOG_TAG,  mLogTaskName + "": start"");
            try {
                runInternal(param);
            } finally {
                Log.i(Logging.LOG_TAG, mLogTaskName + "": done"");
                mIsRunning.set(false);
            }
        } else {
            // Already running -- do nothing.
            Log.i(Logging.LOG_TAG, mLogTaskName + "": already running"");
        }
    }

    /**
     * The actual task must be implemented by subclasses.
     */
    protected abstract void runInternal(Param param);

    /* package */ boolean isRunningForTest() {
        return mIsRunning.get();
    }
}
",False,149,7,68,1,1,2,1,L1
26,com.android.email.VendorPolicyLoader.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import com.android.email.activity.setup.AccountSettingsUtils.Provider;
import com.android.emailcommon.Logging;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Bundle;
import android.util.Log;

import java.lang.reflect.Method;

/**
 * A bridge class to the email vendor policy apk.
 *
 * <p>Email vendor policy is a system apk named ""com.android.email.helper"".  When exists, it must
 * contain a class called ""com.android.email.policy.EmailPolicy"" with a static public method
 * <code>Bundle getPolicy(String, Bundle)</code>, which serves vendor specific configurations.
 *
 * <p>A vendor policy apk is optional.  The email application will operate properly when none is
 * found.
 */
public class VendorPolicyLoader {
    private static final String POLICY_PACKAGE = ""com.android.email.policy"";
    private static final String POLICY_CLASS = POLICY_PACKAGE + "".EmailPolicy"";
    private static final String GET_POLICY_METHOD = ""getPolicy"";
    private static final Class<?>[] ARGS = new Class<?>[] {String.class, Bundle.class};

    // call keys and i/o bundle keys
    // when there is only one parameter or return value, use call key
    private static final String USE_ALTERNATE_EXCHANGE_STRINGS = ""useAlternateExchangeStrings"";
    private static final String GET_IMAP_ID = ""getImapId"";
    private static final String GET_IMAP_ID_USER = ""getImapId.user"";
    private static final String GET_IMAP_ID_HOST = ""getImapId.host"";
    private static final String GET_IMAP_ID_CAPA = ""getImapId.capabilities"";
    private static final String FIND_PROVIDER = ""findProvider"";
    private static final String FIND_PROVIDER_IN_URI = ""findProvider.inUri"";
    private static final String FIND_PROVIDER_IN_USER = ""findProvider.inUser"";
    private static final String FIND_PROVIDER_OUT_URI = ""findProvider.outUri"";
    private static final String FIND_PROVIDER_OUT_USER = ""findProvider.outUser"";
    private static final String FIND_PROVIDER_NOTE = ""findProvider.note"";

    /** Singleton instance */
    private static VendorPolicyLoader sInstance;

    private final Method mPolicyMethod;

    public static VendorPolicyLoader getInstance(Context context) {
        if (sInstance == null) {
            // It's okay to instantiate VendorPolicyLoader multiple times.  No need to synchronize.
            sInstance = new VendorPolicyLoader(context);
        }
        return sInstance;
    }

    /**
     * For testing only.
     *
     * Replaces the instance with a new instance that loads a specified class.
     */
    public static void injectPolicyForTest(Context context, String apkPackageName, Class<?> clazz) {
        String name = clazz.getName();
        Log.d(Logging.LOG_TAG, String.format(""Using policy: package=%s name=%s"",
                apkPackageName, name));
        sInstance = new VendorPolicyLoader(context, apkPackageName, name, true);
    }

    /**
     * For testing only.
     *
     * Clear the instance so that the next {@link #getInstance} call will return a regular,
     * non-injected instance.
     */
    public static void clearInstanceForTest() {
        sInstance = null;
    }

    private VendorPolicyLoader(Context context) {
        this(context, POLICY_PACKAGE, POLICY_CLASS, false);
    }

    /**
     * Constructor for testing, where we need to use an alternate package/class name, and skip
     * the system apk check.
     */
    /* package */ VendorPolicyLoader(Context context, String apkPackageName, String className,
            boolean allowNonSystemApk) {
        if (!allowNonSystemApk && !isSystemPackage(context, apkPackageName)) {
            mPolicyMethod = null;
            return;
        }

        Class<?> clazz = null;
        Method method = null;
        try {
            final Context policyContext = context.createPackageContext(apkPackageName,
                    Context.CONTEXT_IGNORE_SECURITY | Context.CONTEXT_INCLUDE_CODE);
            final ClassLoader classLoader = policyContext.getClassLoader();
            clazz = classLoader.loadClass(className);
            method = clazz.getMethod(GET_POLICY_METHOD, ARGS);
        } catch (NameNotFoundException ignore) {
            // Package not found -- it's okay - there's no policy .apk found, which is OK
        } catch (ClassNotFoundException e) {
            // Class not found -- probably not OK, but let's not crash here
            Log.w(Logging.LOG_TAG, ""VendorPolicyLoader: "" + e);
        } catch (NoSuchMethodException e) {
            // Method not found -- probably not OK, but let's not crash here
            Log.w(Logging.LOG_TAG, ""VendorPolicyLoader: "" + e);
        }
        mPolicyMethod = method;
    }

    // Not private for testing
    /* package */ static boolean isSystemPackage(Context context, String packageName) {
        try {
            ApplicationInfo ai = context.getPackageManager().getApplicationInfo(packageName, 0);
            return (ai.flags & ApplicationInfo.FLAG_SYSTEM) != 0;
        } catch (NameNotFoundException e) {
            return false; // Package not found.
        }
    }

    /**
     * Calls the getPolicy method in the policy apk, if one exists.  This method never returns null;
     * It returns an empty {@link Bundle} when there is no policy apk (or even if the inner
     * getPolicy returns null).
     */
    // Not private for testing
    /* package */ Bundle getPolicy(String policy, Bundle args) {
        Bundle ret = null;
        if (mPolicyMethod != null) {
            try {
                ret = (Bundle) mPolicyMethod.invoke(null, policy, args);
            } catch (Exception e) {
                Log.w(Logging.LOG_TAG, ""VendorPolicyLoader"", e);
            }
        }
        return (ret != null) ? ret : Bundle.EMPTY;
    }

    /**
     * Returns true if alternate exchange descriptive text is required.
     *
     * Vendor function:
     *  Select: USE_ALTERNATE_EXCHANGE_STRINGS
     *  Params: none
     *  Result: USE_ALTERNATE_EXCHANGE_STRINGS (boolean)
     */
    public boolean useAlternateExchangeStrings() {
        return getPolicy(USE_ALTERNATE_EXCHANGE_STRINGS, null)
                .getBoolean(USE_ALTERNATE_EXCHANGE_STRINGS, false);
    }

    /**
     * Returns additional key/value pairs for the IMAP ID string.
     *
     * Vendor function:
     *  Select: GET_IMAP_ID
     *  Params: GET_IMAP_ID_USER (String)
     *          GET_IMAP_ID_HOST (String)
     *          GET_IMAP_ID_CAPABILITIES (String)
     *  Result: GET_IMAP_ID (String)
     *
     * @param userName the server that is being contacted (e.g. ""imap.server.com"")
     * @param host the server that is being contacted (e.g. ""imap.server.com"")
     * @param capabilities reported capabilities, if known.  null is OK
     * @return zero or more key/value pairs, quoted and delimited by spaces.  If there is
     * nothing to add, return null.
     */
    public String getImapIdValues(String userName, String host, String capabilities) {
        Bundle params = new Bundle();
        params.putString(GET_IMAP_ID_USER, userName);
        params.putString(GET_IMAP_ID_HOST, host);
        params.putString(GET_IMAP_ID_CAPA, capabilities);
        String result = getPolicy(GET_IMAP_ID, params).getString(GET_IMAP_ID);
        return result;
    }

    /**
     * Returns provider setup information for a given email address
     *
     * Vendor function:
     *  Select: FIND_PROVIDER
     *  Param:  FIND_PROVIDER (String)
     *  Result: FIND_PROVIDER_IN_URI
     *          FIND_PROVIDER_IN_USER
     *          FIND_PROVIDER_OUT_URI
     *          FIND_PROVIDER_OUT_USER
     *          FIND_PROVIDER_NOTE (optional - null is OK)
     *
     * Note, if we get this far, we expect ""correct"" results from the policy method.  But throwing
     * checked exceptions requires a bunch of upstream changes, so we're going to catch them here
     * and add logging.  Other exceptions may escape here (such as null pointers) to fail fast.
     *
     * @param domain The domain portion of the user's email address
     * @return suitable Provider definition, or null if no match found
     */
    public Provider findProviderForDomain(String domain) {
        Bundle params = new Bundle();
        params.putString(FIND_PROVIDER, domain);
        Bundle out = getPolicy(FIND_PROVIDER, params);
        if (out != null && !out.isEmpty()) {
            Provider p = new Provider();
            p.id = null;
            p.label = null;
            p.domain = domain;
            p.incomingUriTemplate = out.getString(FIND_PROVIDER_IN_URI);
            p.incomingUsernameTemplate = out.getString(FIND_PROVIDER_IN_USER);
            p.outgoingUriTemplate = out.getString(FIND_PROVIDER_OUT_URI);
            p.outgoingUsernameTemplate = out.getString(FIND_PROVIDER_OUT_USER);
            p.note = out.getString(FIND_PROVIDER_NOTE);
            return p;
        }
        return null;
    }
}
",True,271,1,4,14,41,9,2,L6
27,com.android.email.LegacyConversions.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email;

import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.util.Log;

import com.android.emailcommon.Logging;
import com.android.emailcommon.internet.MimeBodyPart;
import com.android.emailcommon.internet.MimeHeader;
import com.android.emailcommon.internet.MimeMessage;
import com.android.emailcommon.internet.MimeMultipart;
import com.android.emailcommon.internet.MimeUtility;
import com.android.emailcommon.internet.TextBody;
import com.android.emailcommon.mail.Address;
import com.android.emailcommon.mail.Flag;
import com.android.emailcommon.mail.Message;
import com.android.emailcommon.mail.Message.RecipientType;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.mail.Part;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.AttachmentColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.AttachmentUtilities;

import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;

public class LegacyConversions {

    /** DO NOT CHECK IN ""TRUE"" */
    private static final boolean DEBUG_ATTACHMENTS = false;

    /** Used for mapping folder names to type codes (e.g. inbox, drafts, trash) */
    private static final HashMap<String, Integer>
            sServerMailboxNames = new HashMap<String, Integer>();

    /**
     * Values for HEADER_ANDROID_BODY_QUOTED_PART to tag body parts
     */
    /* package */ static final String BODY_QUOTED_PART_REPLY = ""quoted-reply"";
    /* package */ static final String BODY_QUOTED_PART_FORWARD = ""quoted-forward"";
    /* package */ static final String BODY_QUOTED_PART_INTRO = ""quoted-intro"";

    /**
     * Copy field-by-field from a ""store"" message to a ""provider"" message
     * @param message The message we've just downloaded (must be a MimeMessage)
     * @param localMessage The message we'd like to write into the DB
     * @result true if dirty (changes were made)
     */
    public static boolean updateMessageFields(EmailContent.Message localMessage, Message message,
                long accountId, long mailboxId) throws MessagingException {

        Address[] from = message.getFrom();
        Address[] to = message.getRecipients(Message.RecipientType.TO);
        Address[] cc = message.getRecipients(Message.RecipientType.CC);
        Address[] bcc = message.getRecipients(Message.RecipientType.BCC);
        Address[] replyTo = message.getReplyTo();
        String subject = message.getSubject();
        Date sentDate = message.getSentDate();
        Date internalDate = message.getInternalDate();

        if (from != null && from.length > 0) {
            localMessage.mDisplayName = from[0].toFriendly();
        }
        if (sentDate != null) {
            localMessage.mTimeStamp = sentDate.getTime();
        }
        if (subject != null) {
            localMessage.mSubject = subject;
        }
        localMessage.mFlagRead = message.isSet(Flag.SEEN);
        if (message.isSet(Flag.ANSWERED)) {
            localMessage.mFlags |= EmailContent.Message.FLAG_REPLIED_TO;
        }

        // Keep the message in the ""unloaded"" state until it has (at least) a display name.
        // This prevents early flickering of empty messages in POP download.
        if (localMessage.mFlagLoaded != EmailContent.Message.FLAG_LOADED_COMPLETE) {
            if (localMessage.mDisplayName == null || """".equals(localMessage.mDisplayName)) {
                localMessage.mFlagLoaded = EmailContent.Message.FLAG_LOADED_UNLOADED;
            } else {
                localMessage.mFlagLoaded = EmailContent.Message.FLAG_LOADED_PARTIAL;
            }
        }
        localMessage.mFlagFavorite = message.isSet(Flag.FLAGGED);
//        public boolean mFlagAttachment = false;
//        public int mFlags = 0;

        localMessage.mServerId = message.getUid();
        if (internalDate != null) {
            localMessage.mServerTimeStamp = internalDate.getTime();
        }
//        public String mClientId;

        // Only replace the local message-id if a new one was found.  This is seen in some ISP's
        // which may deliver messages w/o a message-id header.
        String messageId = ((MimeMessage)message).getMessageId();
        if (messageId != null) {
            localMessage.mMessageId = messageId;
        }

//        public long mBodyKey;
        localMessage.mMailboxKey = mailboxId;
        localMessage.mAccountKey = accountId;

        if (from != null && from.length > 0) {
            localMessage.mFrom = Address.pack(from);
        }

        localMessage.mTo = Address.pack(to);
        localMessage.mCc = Address.pack(cc);
        localMessage.mBcc = Address.pack(bcc);
        localMessage.mReplyTo = Address.pack(replyTo);

//        public String mText;
//        public String mHtml;
//        public String mTextReply;
//        public String mHtmlReply;

//        // Can be used while building messages, but is NOT saved by the Provider
//        transient public ArrayList<Attachment> mAttachments = null;

        return true;
    }

    /**
     * Copy attachments from MimeMessage to provider Message.
     *
     * @param context a context for file operations
     * @param localMessage the attachments will be built against this message
     * @param attachments the attachments to add
     * @throws IOException
     */
    public static void updateAttachments(Context context, EmailContent.Message localMessage,
            ArrayList<Part> attachments) throws MessagingException, IOException {
        localMessage.mAttachments = null;
        for (Part attachmentPart : attachments) {
            addOneAttachment(context, localMessage, attachmentPart);
        }
    }

    /**
     * Add a single attachment part to the message
     *
     * This will skip adding attachments if they are already found in the attachments table.
     * The heuristic for this will fail (false-positive) if two identical attachments are
     * included in a single POP3 message.
     * TODO: Fix that, by (elsewhere) simulating an mLocation value based on the attachments
     * position within the list of multipart/mixed elements.  This would make every POP3 attachment
     * unique, and might also simplify the code (since we could just look at the positions, and
     * ignore the filename, etc.)
     *
     * TODO: Take a closer look at encoding and deal with it if necessary.
     *
     * @param context a context for file operations
     * @param localMessage the attachments will be built against this message
     * @param part a single attachment part from POP or IMAP
     * @throws IOException
     */
    private static void addOneAttachment(Context context, EmailContent.Message localMessage,
            Part part) throws MessagingException, IOException {

        Attachment localAttachment = new Attachment();

        // Transfer fields from mime format to provider format
        String contentType = MimeUtility.unfoldAndDecode(part.getContentType());
        String name = MimeUtility.getHeaderParameter(contentType, ""name"");
        if (name == null) {
            String contentDisposition = MimeUtility.unfoldAndDecode(part.getDisposition());
            name = MimeUtility.getHeaderParameter(contentDisposition, ""filename"");
        }

        // Incoming attachment: Try to pull size from disposition (if not downloaded yet)
        long size = 0;
        String disposition = part.getDisposition();
        if (disposition != null) {
            String s = MimeUtility.getHeaderParameter(disposition, ""size"");
            if (s != null) {
                size = Long.parseLong(s);
            }
        }

        // Get partId for unloaded IMAP attachments (if any)
        // This is only provided (and used) when we have structure but not the actual attachment
        String[] partIds = part.getHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA);
        String partId = partIds != null ? partIds[0] : null;

        localAttachment.mFileName = name;
        localAttachment.mMimeType = part.getMimeType();
        localAttachment.mSize = size;           // May be reset below if file handled
        localAttachment.mContentId = part.getContentId();
        localAttachment.mContentUri = null;     // Will be rewritten by saveAttachmentBody
        localAttachment.mMessageKey = localMessage.mId;
        localAttachment.mLocation = partId;
        localAttachment.mEncoding = ""B"";        // TODO - convert other known encodings
        localAttachment.mAccountKey = localMessage.mAccountKey;

        if (DEBUG_ATTACHMENTS) {
            Log.d(Logging.LOG_TAG, ""Add attachment "" + localAttachment);
        }

        // To prevent duplication - do we already have a matching attachment?
        // The fields we'll check for equality are:
        //  mFileName, mMimeType, mContentId, mMessageKey, mLocation
        // NOTE:  This will false-positive if you attach the exact same file, twice, to a POP3
        // message.  We can live with that - you'll get one of the copies.
        Uri uri = ContentUris.withAppendedId(Attachment.MESSAGE_ID_URI, localMessage.mId);
        Cursor cursor = context.getContentResolver().query(uri, Attachment.CONTENT_PROJECTION,
                null, null, null);
        boolean attachmentFoundInDb = false;
        try {
            while (cursor.moveToNext()) {
                Attachment dbAttachment = new Attachment();
                dbAttachment.restore(cursor);
                // We test each of the fields here (instead of in SQL) because they may be
                // null, or may be strings.
                if (stringNotEqual(dbAttachment.mFileName, localAttachment.mFileName)) continue;
                if (stringNotEqual(dbAttachment.mMimeType, localAttachment.mMimeType)) continue;
                if (stringNotEqual(dbAttachment.mContentId, localAttachment.mContentId)) continue;
                if (stringNotEqual(dbAttachment.mLocation, localAttachment.mLocation)) continue;
                // We found a match, so use the existing attachment id, and stop looking/looping
                attachmentFoundInDb = true;
                localAttachment.mId = dbAttachment.mId;
                if (DEBUG_ATTACHMENTS) {
                    Log.d(Logging.LOG_TAG, ""Skipped, found db attachment "" + dbAttachment);
                }
                break;
            }
        } finally {
            cursor.close();
        }

        // Save the attachment (so far) in order to obtain an id
        if (!attachmentFoundInDb) {
            localAttachment.save(context);
        }

        // If an attachment body was actually provided, we need to write the file now
        saveAttachmentBody(context, part, localAttachment, localMessage.mAccountKey);

        if (localMessage.mAttachments == null) {
            localMessage.mAttachments = new ArrayList<Attachment>();
        }
        localMessage.mAttachments.add(localAttachment);
        localMessage.mFlagAttachment = true;
    }

    /**
     * Helper for addOneAttachment that compares two strings, deals with nulls, and treats
     * nulls and empty strings as equal.
     */
    /* package */ static boolean stringNotEqual(String a, String b) {
        if (a == null && b == null) return false;       // fast exit for two null strings
        if (a == null) a = """";
        if (b == null) b = """";
        return !a.equals(b);
    }

    /**
     * Save the body part of a single attachment, to a file in the attachments directory.
     */
    public static void saveAttachmentBody(Context context, Part part, Attachment localAttachment,
            long accountId) throws MessagingException, IOException {
        if (part.getBody() != null) {
            long attachmentId = localAttachment.mId;

            InputStream in = part.getBody().getInputStream();

            File saveIn = AttachmentUtilities.getAttachmentDirectory(context, accountId);
            if (!saveIn.exists()) {
                saveIn.mkdirs();
            }
            File saveAs = AttachmentUtilities.getAttachmentFilename(context, accountId,
                    attachmentId);
            saveAs.createNewFile();
            FileOutputStream out = new FileOutputStream(saveAs);
            long copySize = IOUtils.copy(in, out);
            in.close();
            out.close();

            // update the attachment with the extra information we now know
            String contentUriString = AttachmentUtilities.getAttachmentUri(
                    accountId, attachmentId).toString();

            localAttachment.mSize = copySize;
            localAttachment.mContentUri = contentUriString;

            // update the attachment in the database as well
            ContentValues cv = new ContentValues();
            cv.put(AttachmentColumns.SIZE, copySize);
            cv.put(AttachmentColumns.CONTENT_URI, contentUriString);
            Uri uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, attachmentId);
            context.getContentResolver().update(uri, cv, null, null);
        }
    }

    /**
     * Read a complete Provider message into a legacy message (for IMAP upload).  This
     * is basically the equivalent of LocalFolder.getMessages() + LocalFolder.fetch().
     */
    public static Message makeMessage(Context context, EmailContent.Message localMessage)
            throws MessagingException {
        MimeMessage message = new MimeMessage();

        // LocalFolder.getMessages() equivalent:  Copy message fields
        message.setSubject(localMessage.mSubject == null ? """" : localMessage.mSubject);
        Address[] from = Address.unpack(localMessage.mFrom);
        if (from.length > 0) {
            message.setFrom(from[0]);
        }
        message.setSentDate(new Date(localMessage.mTimeStamp));
        message.setUid(localMessage.mServerId);
        message.setFlag(Flag.DELETED,
                localMessage.mFlagLoaded == EmailContent.Message.FLAG_LOADED_DELETED);
        message.setFlag(Flag.SEEN, localMessage.mFlagRead);
        message.setFlag(Flag.FLAGGED, localMessage.mFlagFavorite);
//      message.setFlag(Flag.DRAFT, localMessage.mMailboxKey == draftMailboxKey);
        message.setRecipients(RecipientType.TO, Address.unpack(localMessage.mTo));
        message.setRecipients(RecipientType.CC, Address.unpack(localMessage.mCc));
        message.setRecipients(RecipientType.BCC, Address.unpack(localMessage.mBcc));
        message.setReplyTo(Address.unpack(localMessage.mReplyTo));
        message.setInternalDate(new Date(localMessage.mServerTimeStamp));
        message.setMessageId(localMessage.mMessageId);

        // LocalFolder.fetch() equivalent: build body parts
        message.setHeader(MimeHeader.HEADER_CONTENT_TYPE, ""multipart/mixed"");
        MimeMultipart mp = new MimeMultipart();
        mp.setSubType(""mixed"");
        message.setBody(mp);

        try {
            addTextBodyPart(mp, ""text/html"", null,
                    EmailContent.Body.restoreBodyHtmlWithMessageId(context, localMessage.mId));
        } catch (RuntimeException rte) {
            Log.d(Logging.LOG_TAG, ""Exception while reading html body "" + rte.toString());
        }

        try {
            addTextBodyPart(mp, ""text/plain"", null,
                    EmailContent.Body.restoreBodyTextWithMessageId(context, localMessage.mId));
        } catch (RuntimeException rte) {
            Log.d(Logging.LOG_TAG, ""Exception while reading text body "" + rte.toString());
        }

        boolean isReply = (localMessage.mFlags & EmailContent.Message.FLAG_TYPE_REPLY) != 0;
        boolean isForward = (localMessage.mFlags & EmailContent.Message.FLAG_TYPE_FORWARD) != 0;

        // If there is a quoted part (forwarding or reply), add the intro first, and then the
        // rest of it.  If it is opened in some other viewer, it will (hopefully) be displayed in
        // the same order as we've just set up the blocks:  composed text, intro, replied text
        if (isReply || isForward) {
            try {
                addTextBodyPart(mp, ""text/plain"", BODY_QUOTED_PART_INTRO,
                        EmailContent.Body.restoreIntroTextWithMessageId(context, localMessage.mId));
            } catch (RuntimeException rte) {
                Log.d(Logging.LOG_TAG, ""Exception while reading text reply "" + rte.toString());
            }

            String replyTag = isReply ? BODY_QUOTED_PART_REPLY : BODY_QUOTED_PART_FORWARD;
            try {
                addTextBodyPart(mp, ""text/html"", replyTag,
                        EmailContent.Body.restoreReplyHtmlWithMessageId(context, localMessage.mId));
            } catch (RuntimeException rte) {
                Log.d(Logging.LOG_TAG, ""Exception while reading html reply "" + rte.toString());
            }

            try {
                addTextBodyPart(mp, ""text/plain"", replyTag,
                        EmailContent.Body.restoreReplyTextWithMessageId(context, localMessage.mId));
            } catch (RuntimeException rte) {
                Log.d(Logging.LOG_TAG, ""Exception while reading text reply "" + rte.toString());
            }
        }

        // Attachments
        // TODO: Make sure we deal with these as structures and don't accidentally upload files
//        Uri uri = ContentUris.withAppendedId(Attachment.MESSAGE_ID_URI, localMessage.mId);
//        Cursor attachments = context.getContentResolver().query(uri, Attachment.CONTENT_PROJECTION,
//                null, null, null);
//        try {
//
//        } finally {
//            attachments.close();
//        }

        return message;
    }

    /**
     * Helper method to add a body part for a given type of text, if found
     *
     * @param mp The text body part will be added to this multipart
     * @param contentType The content-type of the text being added
     * @param quotedPartTag If non-null, HEADER_ANDROID_BODY_QUOTED_PART will be set to this value
     * @param partText The text to add.  If null, nothing happens
     */
    private static void addTextBodyPart(MimeMultipart mp, String contentType, String quotedPartTag,
            String partText) throws MessagingException {
        if (partText == null) {
            return;
        }
        TextBody body = new TextBody(partText);
        MimeBodyPart bp = new MimeBodyPart(body, contentType);
        if (quotedPartTag != null) {
            bp.addHeader(MimeHeader.HEADER_ANDROID_BODY_QUOTED_PART, quotedPartTag);
        }
        mp.addBodyPart(bp);
    }


    /**
     * Infer mailbox type from mailbox name.  Used by MessagingController (for live folder sync).
     */
    public static synchronized int inferMailboxTypeFromName(Context context, String mailboxName) {
        if (sServerMailboxNames.size() == 0) {
            // preload the hashmap, one time only
            sServerMailboxNames.put(
                    context.getString(R.string.mailbox_name_server_inbox).toLowerCase(),
                    Mailbox.TYPE_INBOX);
            sServerMailboxNames.put(
                    context.getString(R.string.mailbox_name_server_outbox).toLowerCase(),
                    Mailbox.TYPE_OUTBOX);
            sServerMailboxNames.put(
                    context.getString(R.string.mailbox_name_server_drafts).toLowerCase(),
                    Mailbox.TYPE_DRAFTS);
            sServerMailboxNames.put(
                    context.getString(R.string.mailbox_name_server_trash).toLowerCase(),
                    Mailbox.TYPE_TRASH);
            sServerMailboxNames.put(
                    context.getString(R.string.mailbox_name_server_sent).toLowerCase(),
                    Mailbox.TYPE_SENT);
            sServerMailboxNames.put(
                    context.getString(R.string.mailbox_name_server_junk).toLowerCase(),
                    Mailbox.TYPE_JUNK);
        }
        if (mailboxName == null || mailboxName.length() == 0) {
            return Mailbox.TYPE_MAIL;
        }
        String lowerCaseName = mailboxName.toLowerCase();
        Integer type = sServerMailboxNames.get(lowerCaseName);
        if (type != null) {
            return type;
        }
        return Mailbox.TYPE_MAIL;
    }
}
",True,258,7,56,8,22,4,18,L6
28,com.android.email.view.CertificateSelector.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.android.email.view;

import android.content.Context;
import android.content.res.Resources;
import android.os.Parcel;
import android.os.Parcelable;
import android.security.KeyChain;
import android.util.AttributeSet;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.RelativeLayout;
import android.widget.TextView;

import com.android.email.R;
import com.android.email.activity.UiUtilities;

/**
 * A simple view that can be used to select a certificate from the system {@link KeyChain}.
 *
 * Host activities must register themselves view {@link #setHostActivity} for this selector to work.
 */
public class CertificateSelector extends RelativeLayout implements OnClickListener {

    /** Button to select or remove the certificate. */
    private Button mSelectButton;
    private TextView mAliasText;

    /** The value of the cert selected, if any. Null, otherwise. */
    private String mValue;

    /** The host activity. */
    private HostCallback mHost;

    public interface HostCallback {
        void onCertificateRequested();
    }

    public CertificateSelector(Context context) {
        super(context);
    }
    public CertificateSelector(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    public CertificateSelector(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public void setHostActivity(HostCallback host) {
        mHost = host;
    }

    public void setDelegate(String uri) {
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();

        mAliasText = UiUtilities.getView(this, R.id.certificate_alias);
        mSelectButton = UiUtilities.getView(this, R.id.select_button);
        mSelectButton.setOnClickListener(this);
        setCertificate(null);
    }

    public void setCertificate(String alias) {
        Resources res = getResources();
        mValue = alias;
        mAliasText.setText(
                (alias == null)
                ? res.getString(R.string.account_setup_exchange_no_certificate)
                : alias);
        mSelectButton.setText(res.getString(
                (alias == null)
                ? R.string.account_setup_exchange_select_certificate
                : R.string.account_setup_exchange_remove_certificate));
    }

    public boolean hasCertificate() {
        return mValue != null;
    }

    /**
     * Gets the alias for the currently selected certificate, or null if one is not selected.
     */
    public String getCertificate() {
        return mValue;
    }


    @Override
    public void onClick(View target) {
        if (target == mSelectButton && mHost != null) {
            if (hasCertificate()) {
                // Handle the click on the button when it says ""Remove""
                setCertificate(null);
            } else {
                mHost.onCertificateRequested();
            }
        }
    }

    @Override
    protected void onRestoreInstanceState(Parcelable parcel) {
        SavedState savedState = (SavedState) parcel;
        super.onRestoreInstanceState(savedState.getSuperState());
        setCertificate(savedState.mValue);
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        return new SavedState(super.onSaveInstanceState(), getCertificate());
    }

    public static class SavedState extends BaseSavedState {
        final String mValue;

        SavedState(Parcelable superState, String value) {
            super(superState);
            mValue = value;
        }

        @Override
        public void writeToParcel(Parcel out, int flags) {
            super.writeToParcel(out, flags);
            out.writeString(mValue);
        }

        @SuppressWarnings(""hiding"")
        public static final Parcelable.Creator<SavedState> CREATOR
                = new Parcelable.Creator<SavedState>() {
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };

        private SavedState(Parcel in) {
            super(in);
            mValue = in.readString();
        }
    }
}
",False,149,12,44,2,1,1,1,L6
29,com.android.email.view.RigidWebView.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.android.email.view;

import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.webkit.WebView;

import com.android.email.Clock;
import com.android.email.Email;
import com.android.email.Throttle;
import com.android.emailcommon.Logging;
import com.android.emailcommon.utility.Utility;

/**
 * A custom WebView that is robust to rapid resize events in sequence.
 *
 * This is useful for a WebView which needs to have a layout of {@code WRAP_CONTENT}, since any
 * contents with percent-based height will force the WebView to infinitely expand (or shrink).
 */
public class RigidWebView extends WebView {

    public RigidWebView(Context context) {
        super(context);
    }
    public RigidWebView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    public RigidWebView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    private static final int MIN_RESIZE_INTERVAL = 200;
    private static final int MAX_RESIZE_INTERVAL = 300;
    private final Clock mClock = Clock.INSTANCE;

    private final Throttle mThrottle = new Throttle(getClass().getName(),
            new Runnable() {
                @Override public void run() {
                    performSizeChangeDelayed();
                }
            }, Utility.getMainThreadHandler(),
            MIN_RESIZE_INTERVAL, MAX_RESIZE_INTERVAL);

    private int mRealWidth;
    private int mRealHeight;
    private boolean mIgnoreNext;
    private long mLastSizeChangeTime = -1;

    @Override
    protected void onSizeChanged(int w, int h, int ow, int oh) {
        mRealWidth = w;
        mRealHeight = h;
        long now = mClock.getTime();
        boolean recentlySized = (now - mLastSizeChangeTime < MIN_RESIZE_INTERVAL);

        // It's known that the previous resize event may cause a resize event immediately. If
        // this happens sufficiently close to the last resize event, drop it on the floor.
        if (mIgnoreNext) {
            mIgnoreNext = false;
            if (recentlySized) {
                if (Email.DEBUG) {
                    Log.w(Logging.LOG_TAG, ""Supressing size change in RigidWebView"");
                }
                return;
            }
        }

        if (recentlySized) {
            mThrottle.onEvent();
        } else {
            // It's been a sufficiently long time - just perform the resize as normal. This should
            // be the normal code path.
            performSizeChange(ow, oh);
        }
    }

    private void performSizeChange(int ow, int oh) {
        super.onSizeChanged(mRealWidth, mRealHeight, ow, oh);
        mLastSizeChangeTime = mClock.getTime();
    }

    private void performSizeChangeDelayed() {
        mIgnoreNext = true;
        performSizeChange(getWidth(), getHeight());
    }
}
",False,268,0,0,11,47,0,5,L8
30,com.android.email.view.SizeBoundingFrameLayout.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.view;

import com.android.email.R;

import android.content.Context;
import android.content.res.TypedArray;
import android.util.AttributeSet;
import android.widget.FrameLayout;

/**
 * A {@link FrameLayout} with the max width/height.
 */
public class SizeBoundingFrameLayout extends FrameLayout {
    public static final int DIMENSION_DEFAULT = -1; // unspecified

    private int mMaxWidth = DIMENSION_DEFAULT;
    private int mMaxHeight = DIMENSION_DEFAULT;

    public SizeBoundingFrameLayout(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        initFromAttributeSet(context, attrs);
    }

    public SizeBoundingFrameLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        initFromAttributeSet(context, attrs);
    }

    public SizeBoundingFrameLayout(Context context) {
        super(context);
    }

    private void initFromAttributeSet(Context c, AttributeSet attrs) {
        TypedArray a = c.obtainStyledAttributes(attrs,
                R.styleable.SizeBoundingFrameLayout_attributes);
        mMaxWidth = a.getDimensionPixelSize(
                R.styleable.SizeBoundingFrameLayout_attributes_maxWidth, DIMENSION_DEFAULT);
        mMaxHeight = a.getDimensionPixelSize(
                R.styleable.SizeBoundingFrameLayout_attributes_maxHeight, DIMENSION_DEFAULT);
        a.recycle();
    }

    /** Set the max width.  Use {@link #DIMENSION_DEFAULT} for unspecified. */
    public void setMaxWidth(int maxWidth) {
        mMaxWidth = maxWidth;
        requestLayout();
        invalidate();
    }

    public int getMaxWidth() {
        return mMaxWidth;
    }

    /** Set the max height.  Use {@link #DIMENSION_DEFAULT} for unspecified. */
    public void setMaxHeight(int maxHeight) {
        mMaxHeight = maxHeight;
        requestLayout();
        invalidate();
    }

    public int getMaxHeight() {
        return mMaxHeight;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);

        // Limit the size, unless MeasureSpec.EXACTLY
        if (mMaxWidth >= 0) {
            switch (widthMode) {
                case MeasureSpec.AT_MOST:
                    widthSize = Math.min(widthSize, mMaxWidth);
                    break;
                case MeasureSpec.UNSPECIFIED:
                    widthMode = MeasureSpec.AT_MOST;
                    widthSize = mMaxWidth;
                    break;
            }
        }

        if (mMaxHeight >= 0) {
            switch (heightMode) {
                case MeasureSpec.AT_MOST:
                    heightSize = Math.min(heightSize, mMaxHeight);
                    break;
                case MeasureSpec.UNSPECIFIED:
                    heightMode = MeasureSpec.AT_MOST;
                    heightSize = mMaxHeight;
                    break;
            }
        }
        super.onMeasure(MeasureSpec.makeMeasureSpec(widthSize, widthMode),
                MeasureSpec.makeMeasureSpec(heightSize, heightMode));
    }
}
",False,1,0,0,0,0,0,0,I0
31,com.android.email.view.NonLockingScrollView.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.android.email.view;

import android.content.Context;
import android.graphics.Rect;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.WebView;
import android.widget.ScrollView;

import java.util.ArrayList;

/**
 * A {@link ScrollView} that will never lock scrolling in a particular direction.
 *
 * Usually ScrollView will capture all touch events once a drag has begun. In some cases,
 * we want to delegate those touches to children as normal, even in the middle of a drag. This is
 * useful when there are childviews like a WebView tha handles scrolling in the horizontal direction
 * even while the ScrollView drags vertically.
 *
 * This is only tested to work for ScrollViews where the content scrolls in one direction.
 */
public class NonLockingScrollView extends ScrollView {
    public NonLockingScrollView(Context context) {
        super(context);
    }
    public NonLockingScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }
    public NonLockingScrollView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    /**
     * Whether or not the contents of this view is being dragged by one of the children in
     * {@link #mChildrenNeedingAllTouches}.
     */
    private boolean mInCustomDrag = false;

    /**
     * The list of children who should always receive touch events, and not have them intercepted.
     */
    private final ArrayList<View> mChildrenNeedingAllTouches = new ArrayList<View>();

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        final int action = ev.getActionMasked();
        final boolean isUp = action == MotionEvent.ACTION_UP;

        if (isUp && mInCustomDrag) {
            // An up event after a drag should be intercepted so that child views don't handle
            // click events falsely after a drag.
            mInCustomDrag = false;
            onTouchEvent(ev);
            return true;
        }

        if (!mInCustomDrag && !isEventOverChild(ev, mChildrenNeedingAllTouches)) {
            return super.onInterceptTouchEvent(ev);
        }

        // Note the normal scrollview implementation is to intercept all touch events after it has
        // detected a drag starting. We will handle this ourselves.
        mInCustomDrag = super.onInterceptTouchEvent(ev);
        if (mInCustomDrag) {
            onTouchEvent(ev);
        }

        // Don't intercept events - pass them on to children as normal.
        return false;
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        excludeChildrenFromInterceptions(this);
    }

    /**
     * Traverses the view tree for {@link WebView}s so they can be excluded from touch
     * interceptions and receive all events.
     */
    private void excludeChildrenFromInterceptions(View node) {
        // If additional types of children should be excluded (e.g. horizontal scrolling banners),
        // this needs to be modified accordingly.
        if (node instanceof WebView) {
            mChildrenNeedingAllTouches.add(node);
        } else if (node instanceof ViewGroup) {
            ViewGroup viewGroup = (ViewGroup) node;
            final int childCount = viewGroup.getChildCount();
            for (int i = 0; i < childCount; i++) {
                final View child = viewGroup.getChildAt(i);
                excludeChildrenFromInterceptions(child);
            }
        }
    }

    private static final Rect sHitFrame = new Rect();
    private static boolean isEventOverChild(MotionEvent ev, ArrayList<View> children) {
        final int actionIndex = ev.getActionIndex();
        final float x = ev.getX(actionIndex);
        final float y = ev.getY(actionIndex);

        for (View child : children) {
            if (!canViewReceivePointerEvents(child)) {
                continue;
            }
            child.getHitRect(sHitFrame);

            // child can receive the motion event.
            if (sHitFrame.contains((int) x, (int) y)) {
                return true;
            }
        }
        return false;
    }

    private static boolean canViewReceivePointerEvents(View child) {
        return child.getVisibility() == VISIBLE || (child.getAnimation() != null);
    }
}
",False,1,0,0,0,0,0,0,I0
32,com.android.email.data.ThrottlingCursorLoader.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.data;

import com.android.email.Throttle;
import com.android.emailcommon.Logging;

import android.content.Context;
import android.content.CursorLoader;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;
import android.util.Log;

/**
 * A {@link CursorLoader} variant that throttle auto-requery on content changes using
 * {@link Throttle}.
 */
public class ThrottlingCursorLoader extends CursorLoader {
    private final Throttle mThrottle;

    /** Constructor with default timeout */
    public ThrottlingCursorLoader(Context context, Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder) {
        this(context, uri, projection, selection, selectionArgs, sortOrder,
                Throttle.DEFAULT_MIN_TIMEOUT, Throttle.DEFAULT_MAX_TIMEOUT);
    }

    /** Constructor that takes custom timeout */
    public ThrottlingCursorLoader(Context context, Uri uri, String[] projection, String selection,
            String[] selectionArgs, String sortOrder, int minTimeout, int maxTimeout) {
        super(context, uri, projection, selection, selectionArgs, sortOrder);

        Runnable forceLoadRunnable = new Runnable() {
            @Override
            public void run() {
                callSuperOnContentChanged();
            }
        };
        mThrottle = new Throttle(uri.toString(), forceLoadRunnable, new Handler(),
                minTimeout, maxTimeout);
    }

    private void debugLog(String message) {
        Log.d(Logging.LOG_TAG, ""ThrottlingCursorLoader: ["" + getUri() + ""] "" + message);
    }

    @Override
    protected void onStartLoading() {
        if (Throttle.DEBUG) debugLog(""startLoading"");
        mThrottle.cancelScheduledCallback();
        super.onStartLoading();
    }

    @Override
    protected void onForceLoad() {
        if (Throttle.DEBUG) debugLog(""forceLoad"");
        mThrottle.cancelScheduledCallback();
        super.onForceLoad();
    }

    @Override
    protected void onStopLoading() {
        if (Throttle.DEBUG) debugLog(""stopLoading"");
        mThrottle.cancelScheduledCallback();
        super.onStopLoading();
    }

    @Override
    public void onCanceled(Cursor cursor) {
        if (Throttle.DEBUG) debugLog(""onCancelled"");
        mThrottle.cancelScheduledCallback();
        super.onCanceled(cursor);
    }

    @Override
    protected void onReset() {
        if (Throttle.DEBUG) debugLog(""onReset"");
        mThrottle.cancelScheduledCallback();
        super.onReset();
    }

    @Override
    public void onContentChanged() {
        if (Throttle.DEBUG) debugLog(""onContentChanged"");

        mThrottle.onEvent();
    }

    private void callSuperOnContentChanged() {
        if (Throttle.DEBUG) debugLog(""callSuperOnContentChanged"");
        super.onContentChanged();
    }
}
",False,151,9,56,2,2,5,2,L6
33,com.android.email.data.ClosingMatrixCursor.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.data;

import android.database.Cursor;
import android.database.MatrixCursor;


/**
 * {@link MatrixCursor} which takes an extra {@link Cursor} to the constructor, and close
 * it when self is closed.
 */
public class ClosingMatrixCursor extends MatrixCursor {
    private final Cursor mInnerCursor;

    public ClosingMatrixCursor(String[] columnNames, Cursor innerCursor) {
        super(columnNames);
        mInnerCursor = innerCursor;
    }

    @Override
    public void close() {
        if (mInnerCursor != null) {
            mInnerCursor.close();
        }
        super.close();
    }
}
",False,147,12,42,0,0,2,0,L6
34,com.android.email.activity.MessageViewFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.accessibility.AccessibilityEvent;
import android.widget.ImageView;
import android.widget.PopupMenu;
import android.widget.PopupMenu.OnMenuItemClickListener;

import com.android.email.Email;
import com.android.email.Preferences;
import com.android.email.R;
import com.android.emailcommon.mail.MeetingInfo;
import com.android.emailcommon.mail.PackedString;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.EmailServiceConstants;
import com.android.emailcommon.utility.Utility;

/**
 * A {@link MessageViewFragmentBase} subclass for regular email messages.  (regular as in ""not eml
 * files"").
 */
public class MessageViewFragment extends MessageViewFragmentBase
        implements MoveMessageToDialog.Callback, OnMenuItemClickListener {
    /** Argument name(s) */
    private static final String ARG_MESSAGE_ID = ""messageId"";

    private ImageView mFavoriteIcon;

    private View mReplyButton;

    private View mReplyAllButton;

    /* Nullable - not available on phone portrait. */
    private View mForwardButton;

    private View mMoreButton;

    // calendar meeting invite answers
    private View mMeetingYes;
    private View mMeetingMaybe;
    private View mMeetingNo;
    private Drawable mFavoriteIconOn;
    private Drawable mFavoriteIconOff;

    /** Default to ReplyAll if true. Otherwise Reply. */
    boolean mDefaultReplyAll;

    /** Whether or not to enable Reply/ReplyAll and Forward buttons */
    boolean mEnableReplyForwardButtons;

    /** Whether or not the message can be moved from the mailbox it's in. */
    private boolean mSupportsMove;

    private int mPreviousMeetingResponse = EmailServiceConstants.MEETING_REQUEST_NOT_RESPONDED;

    /**
     * This class has more call backs than {@link MessageViewFragmentBase}.
     *
     * - EML files can't be ""mark unread"".
     * - EML files can't have the invite buttons or the view in calender link.
     *   Note EML files can have ICS (calendar invitation) files, but we don't treat them as
     *   invites.  (Only exchange provider sets the FLAG_INCOMING_MEETING_INVITE
     *   flag.)
     *   It'd be weird to respond to an invitation in an EML that might not be addressed to you...
     */
    public interface Callback extends MessageViewFragmentBase.Callback {
        /** Called when the ""view in calendar"" link is clicked. */
        public void onCalendarLinkClicked(long epochEventStartTime);

        /**
         * Called when a calender response button is clicked.
         *
         * @param response one of {@link EmailServiceConstants#MEETING_REQUEST_ACCEPTED},
         * {@link EmailServiceConstants#MEETING_REQUEST_DECLINED}, or
         * {@link EmailServiceConstants#MEETING_REQUEST_TENTATIVE}.
         */
        public void onRespondedToInvite(int response);

        /** Called when the current message is set unread. */
        public void onMessageSetUnread();

        /**
         * Called right before the current message will be deleted or moved to another mailbox.
         *
         * Callees will usually close the fragment.
         */
        public void onBeforeMessageGone();

        /** Called when the forward button is pressed. */
        public void onForward();
        /** Called when the reply button is pressed. */
        public void onReply();
        /** Called when the reply-all button is pressed. */
        public void onReplyAll();
    }

    public static final class EmptyCallback extends MessageViewFragmentBase.EmptyCallback
            implements Callback {
        @SuppressWarnings(""hiding"")
        public static final Callback INSTANCE = new EmptyCallback();

        @Override public void onCalendarLinkClicked(long epochEventStartTime) { }
        @Override public void onMessageSetUnread() { }
        @Override public void onRespondedToInvite(int response) { }
        @Override public void onBeforeMessageGone() { }
        @Override public void onForward() { }
        @Override public void onReply() { }
        @Override public void onReplyAll() { }
    }

    private Callback mCallback = EmptyCallback.INSTANCE;

    /**
     * Create a new instance with initialization parameters.
     *
     * This fragment should be created only with this method.  (Arguments should always be set.)
     *
     * @param messageId ID of the message to open
     */
    public static MessageViewFragment newInstance(long messageId) {
        if (messageId == Message.NO_MESSAGE) {
            throw new IllegalArgumentException();
        }
        final MessageViewFragment instance = new MessageViewFragment();
        final Bundle args = new Bundle();
        args.putLong(ARG_MESSAGE_ID, messageId);
        instance.setArguments(args);
        return instance;
    }

    /**
     * We will display the message for this ID. This must never be a special message ID such as
     * {@link Message#NO_MESSAGE}. Do NOT use directly; instead, use {@link #getMessageId()}.
     * <p><em>NOTE:</em> Although we cannot force these to be immutable using Java language
     * constructs, this <em>must</em> be considered immutable.
     */
    private Long mImmutableMessageId;

    private void initializeArgCache() {
        if (mImmutableMessageId != null) return;
        mImmutableMessageId = getArguments().getLong(ARG_MESSAGE_ID);
    }

    /**
     * @return the message ID passed to {@link #newInstance}.  Safe to call even before onCreate.
     */
    public long getMessageId() {
        initializeArgCache();
        return mImmutableMessageId;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setHasOptionsMenu(true);

        final Resources res = getActivity().getResources();
        mFavoriteIconOn = res.getDrawable(R.drawable.btn_star_on_convo_holo_light);
        mFavoriteIconOff = res.getDrawable(R.drawable.btn_star_off_convo_holo_light);
    }

    @Override
    public void onResume() {
        super.onResume();
        if (mMoreButton != null) {
            mDefaultReplyAll = Preferences.getSharedPreferences(mContext).getBoolean(
                    Preferences.REPLY_ALL, Preferences.REPLY_ALL_DEFAULT);

            int replyVisibility = View.GONE;
            int replyAllVisibility = View.GONE;
            if (mEnableReplyForwardButtons) {
                replyVisibility = mDefaultReplyAll ? View.GONE : View.VISIBLE;
                replyAllVisibility = mDefaultReplyAll ? View.VISIBLE : View.GONE;
            }
            mReplyButton.setVisibility(replyVisibility);
            mReplyAllButton.setVisibility(replyAllVisibility);
        }
    }

    @Override
    public View onCreateView(
            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        final View view = super.onCreateView(inflater, container, savedInstanceState);

        mFavoriteIcon = (ImageView) UiUtilities.getView(view, R.id.favorite);
        mReplyButton = UiUtilities.getView(view, R.id.reply);
        mReplyAllButton = UiUtilities.getView(view, R.id.reply_all);
        mForwardButton = UiUtilities.getViewOrNull(view, R.id.forward);
        mMeetingYes = UiUtilities.getView(view, R.id.accept);
        mMeetingMaybe = UiUtilities.getView(view, R.id.maybe);
        mMeetingNo = UiUtilities.getView(view, R.id.decline);
        mMoreButton = UiUtilities.getViewOrNull(view, R.id.more);

        mFavoriteIcon.setOnClickListener(this);
        mReplyButton.setOnClickListener(this);
        mReplyAllButton.setOnClickListener(this);
        if (mMoreButton != null) {
            mMoreButton.setOnClickListener(this);
        }
        if (mForwardButton != null) {
            mForwardButton.setOnClickListener(this);
        }
        mMeetingYes.setOnClickListener(this);
        mMeetingMaybe.setOnClickListener(this);
        mMeetingNo.setOnClickListener(this);
        UiUtilities.getView(view, R.id.invite_link).setOnClickListener(this);

        enableReplyForwardButtons(false);

        return view;
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.message_view_fragment_option, menu);
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        menu.findItem(R.id.move).setVisible(mSupportsMove);
    }

    private void enableReplyForwardButtons(boolean enabled) {
        mEnableReplyForwardButtons = enabled;
        // We don't have disabled button assets, so let's hide them for now
        final int visibility = enabled ? View.VISIBLE : View.GONE;

        // Modify Reply All button only if there's no overflow OR there is
        // overflow but default is to show the Reply All button
        if (mMoreButton == null || mDefaultReplyAll) {
            UiUtilities.setVisibilitySafe(mReplyAllButton, visibility);
        }

        // Modify Reply button only if there's no overflow OR there is
        // overflow but default is to show the Reply button
        if (mMoreButton == null || !mDefaultReplyAll) {
               UiUtilities.setVisibilitySafe(mReplyButton, visibility);
        }

        if (mForwardButton != null) {
            mForwardButton.setVisibility(visibility);
        }
        if (mMoreButton != null) {
            mMoreButton.setVisibility(visibility);
        }
    }

    public void setCallback(Callback callback) {
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
        super.setCallback(mCallback);
    }

    @Override
    protected void resetView() {
        super.resetView();
        mPreviousMeetingResponse = EmailServiceConstants.MEETING_REQUEST_NOT_RESPONDED;
    }

    /**
     * NOTE See the comment on the super method.  It's called on a worker thread.
     */
    @Override
    protected Message openMessageSync(Activity activity) {
        return Message.restoreMessageWithId(activity, getMessageId());
    }

    @Override
    protected void onMessageShown(long messageId, Mailbox mailbox) {
        super.onMessageShown(messageId, mailbox);

        Account account = Account.restoreAccountWithId(mContext, getAccountId());
        boolean supportsMove = account.supportsMoveMessages(mContext)
                && mailbox.canHaveMessagesMoved();
        if (mSupportsMove != supportsMove) {
            mSupportsMove = supportsMove;
            Activity host = getActivity();
            if (host != null) {
                host.invalidateOptionsMenu();
            }
        }

        // Disable forward/reply buttons as necessary.
        enableReplyForwardButtons(Mailbox.isMailboxTypeReplyAndForwardable(mailbox.mType));
    }

    /**
     * Sets the content description for the star icon based on whether it's currently starred.
     */
    private void setStarContentDescription(boolean isFavorite) {
        if (isFavorite) {
            mFavoriteIcon.setContentDescription(
                    mContext.getResources().getString(R.string.remove_star_action));
        } else {
            mFavoriteIcon.setContentDescription(
                    mContext.getResources().getString(R.string.set_star_action));
        }
    }

    /**
     * Toggle favorite status and write back to provider
     */
    private void onClickFavorite() {
        if (!isMessageOpen()) return;
        Message message = getMessage();

        // Update UI
        boolean newFavorite = ! message.mFlagFavorite;
        mFavoriteIcon.setImageDrawable(newFavorite ? mFavoriteIconOn : mFavoriteIconOff);

        // Handle accessibility event
        setStarContentDescription(newFavorite);
        mFavoriteIcon.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_FOCUSED);

        // Update provider
        message.mFlagFavorite = newFavorite;
        getController().setMessageFavorite(message.mId, newFavorite);
    }

    /**
     * Set message read/unread.
     */
    public void onMarkMessageAsRead(boolean isRead) {
        if (!isMessageOpen()) return;
        Message message = getMessage();
        if (message.mFlagRead != isRead) {
            message.mFlagRead = isRead;
            getController().setMessageRead(message.mId, isRead);
            if (!isRead) { // Became unread.  We need to close the message.
                mCallback.onMessageSetUnread();
            }
        }
    }

    /**
     * Send a service message indicating that a meeting invite button has been clicked.
     */
    private void onRespondToInvite(int response, int toastResId) {
        if (!isMessageOpen()) return;
        Message message = getMessage();
        // do not send twice in a row the same response
        if (mPreviousMeetingResponse != response) {
            getController().sendMeetingResponse(message.mId, response);
            mPreviousMeetingResponse = response;
        }
        Utility.showToast(getActivity(), toastResId);
        mCallback.onRespondedToInvite(response);
    }

    private void onInviteLinkClicked() {
        if (!isMessageOpen()) return;
        Message message = getMessage();
        String startTime = new PackedString(message.mMeetingInfo).get(MeetingInfo.MEETING_DTSTART);
        if (startTime != null) {
            long epochTimeMillis = Utility.parseEmailDateTimeToMillis(startTime);
            mCallback.onCalendarLinkClicked(epochTimeMillis);
        } else {
            Email.log(""meetingInfo without DTSTART "" + message.mMeetingInfo);
        }
    }

    @Override
    public void onClick(View view) {
        if (!isMessageOpen()) {
            return; // Ignore.
        }
        switch (view.getId()) {
            case R.id.reply:
                mCallback.onReply();
                return;
            case R.id.reply_all:
                mCallback.onReplyAll();
                return;
            case R.id.forward:
                mCallback.onForward();
                return;

            case R.id.favorite:
                onClickFavorite();
                return;

            case R.id.invite_link:
                onInviteLinkClicked();
                return;

            case R.id.accept:
                onRespondToInvite(EmailServiceConstants.MEETING_REQUEST_ACCEPTED,
                        R.string.message_view_invite_toast_yes);
                return;
            case R.id.maybe:
                onRespondToInvite(EmailServiceConstants.MEETING_REQUEST_TENTATIVE,
                        R.string.message_view_invite_toast_maybe);
                return;
            case R.id.decline:
                onRespondToInvite(EmailServiceConstants.MEETING_REQUEST_DECLINED,
                        R.string.message_view_invite_toast_no);
                return;

            case R.id.more: {
                PopupMenu popup = new PopupMenu(getActivity(), mMoreButton);
                Menu menu = popup.getMenu();
                popup.getMenuInflater().inflate(R.menu.message_header_overflow_menu,
                        menu);

                // Remove Reply if ReplyAll icon is visible or vice versa
                menu.removeItem(mDefaultReplyAll ? R.id.reply_all : R.id.reply);
                popup.setOnMenuItemClickListener(this);
                popup.show();
                break;
            }

        }
        super.onClick(view);
    }

    @Override
    public boolean onMenuItemClick(MenuItem item) {
        if (isMessageOpen()) {
            switch (item.getItemId()) {
                case R.id.reply:
                    mCallback.onReply();
                    return true;
                case R.id.reply_all:
                    mCallback.onReplyAll();
                    return true;
                case R.id.forward:
                    mCallback.onForward();
                    return true;
            }
        }
        return false;
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.move:
                onMove();
                return true;
            case R.id.delete:
                onDelete();
                return true;
            case R.id.mark_as_unread:
                onMarkAsUnread();
                return true;
        }
        return super.onOptionsItemSelected(item);
    }

    private void onMove() {
        MoveMessageToDialog dialog = MoveMessageToDialog.newInstance(new long[] {getMessageId()},
                this);
        dialog.show(getFragmentManager(), ""dialog"");
    }

    // MoveMessageToDialog$Callback
    @Override
    public void onMoveToMailboxSelected(long newMailboxId, long[] messageIds) {
        mCallback.onBeforeMessageGone();
        ActivityHelper.moveMessages(mContext, newMailboxId, messageIds);
    }

    private void onDelete() {
        mCallback.onBeforeMessageGone();
        ActivityHelper.deleteMessage(mContext, getMessageId());
    }

    private void onMarkAsUnread() {
        onMarkMessageAsRead(false);
    }

    /**
     * {@inheritDoc}
     *
     * Mark the current as unread.
     */
    @Override
    protected void onPostLoadBody() {
        onMarkMessageAsRead(true);

        // Initialize star content description for accessibility
        Message message = getMessage();
        setStarContentDescription(message.mFlagFavorite);
    }

    @Override
    protected void updateHeaderView(Message message) {
        super.updateHeaderView(message);

        mFavoriteIcon.setImageDrawable(message.mFlagFavorite ? mFavoriteIconOn : mFavoriteIconOff);

        // Enable the invite tab if necessary
        if ((message.mFlags & Message.FLAG_INCOMING_MEETING_INVITE) != 0) {
            addTabFlags(TAB_FLAGS_HAS_INVITE);
        }
    }
}
",False,267,0,0,10,49,3,14,L6
35,com.android.email.activity.MessageListFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.ListFragment;
import android.app.LoaderManager;
import android.content.ClipData;
import android.content.ContentUris;
import android.content.Context;
import android.content.Loader;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Canvas;
import android.graphics.Point;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.os.Parcelable;
import android.text.TextPaint;
import android.util.Log;
import android.view.ActionMode;
import android.view.DragEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.DragShadowBuilder;
import android.view.View.OnDragListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import com.android.email.Controller;
import com.android.email.Email;
import com.android.email.MessageListContext;
import com.android.email.NotificationController;
import com.android.email.R;
import com.android.email.RefreshManager;
import com.android.email.activity.MessagesAdapter.SearchResultsCursor;
import com.android.email.provider.EmailProvider;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Maps;

import java.util.HashMap;
import java.util.Set;

/**
 * Message list.
 *
 * See the class javadoc for {@link MailboxListFragment} for notes on {@link #getListView()} and
 * {@link #isViewCreated()}.
 */
public class MessageListFragment extends ListFragment
        implements OnItemLongClickListener, MessagesAdapter.Callback,
        MoveMessageToDialog.Callback, OnDragListener, OnTouchListener {
    private static final String BUNDLE_LIST_STATE = ""MessageListFragment.state.listState"";
    private static final String BUNDLE_KEY_SELECTED_MESSAGE_ID
            = ""messageListFragment.state.listState.selected_message_id"";

    private static final int LOADER_ID_MESSAGES_LOADER = 1;

    /** Argument name(s) */
    private static final String ARG_LIST_CONTEXT = ""listContext"";

    // Controller access
    private Controller mController;
    private RefreshManager mRefreshManager;
    private final RefreshListener mRefreshListener = new RefreshListener();

    // UI Support
    private Activity mActivity;
    private Callback mCallback = EmptyCallback.INSTANCE;
    private boolean mIsViewCreated;

    private View mListPanel;
    private View mListFooterView;
    private TextView mListFooterText;
    private View mListFooterProgress;
    private ViewGroup mSearchHeader;
    private ViewGroup mWarningContainer;
    private TextView mSearchHeaderText;
    private TextView mSearchHeaderCount;

    private static final int LIST_FOOTER_MODE_NONE = 0;
    private static final int LIST_FOOTER_MODE_MORE = 1;
    private int mListFooterMode;

    private MessagesAdapter mListAdapter;
    private boolean mIsFirstLoad;

    /** ID of the message to hightlight. */
    private long mSelectedMessageId = -1;

    private Account mAccount;
    private Mailbox mMailbox;
    /** The original mailbox being searched, if this list is showing search results. */
    private Mailbox mSearchedMailbox;
    private boolean mIsEasAccount;
    private boolean mIsRefreshable;
    private int mCountTotalAccounts;

    // Misc members

    private boolean mShowSendCommand;
    private boolean mShowMoveCommand;

    /**
     * If true, we disable the CAB even if there are selected messages.
     * It's used in portrait on the tablet when the message view becomes visible and the message
     * list gets pushed out of the screen, in which case we want to keep the selection but the CAB
     * should be gone.
     */
    private boolean mDisableCab;

    /** true between {@link #onResume} and {@link #onPause}. */
    private boolean mResumed;

    /**
     * {@link ActionMode} shown when 1 or more message is selected.
     */
    private ActionMode mSelectionMode;
    private SelectionModeCallback mLastSelectionModeCallback;

    private Parcelable mSavedListState;

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    /**
     * Callback interface that owning activities must implement
     */
    public interface Callback {
        public static final int TYPE_REGULAR = 0;
        public static final int TYPE_DRAFT = 1;
        public static final int TYPE_TRASH = 2;

        /**
         * Called when the specified mailbox does not exist.
         */
        public void onMailboxNotFound(boolean firstLoad);

        /**
         * Called when the user wants to open a message.
         * Note {@code mailboxId} is of the actual mailbox of the message, which is different from
         * {@link MessageListFragment#getMailboxId} if it's magic mailboxes.
         *
         * @param messageId the message ID of the message
         * @param messageMailboxId the mailbox ID of the message.
         *     This will never take values like {@link Mailbox#QUERY_ALL_INBOXES}.
         * @param listMailboxId the mailbox ID of the listbox shown on this fragment.
         *     This can be that of a magic mailbox, e.g.  {@link Mailbox#QUERY_ALL_INBOXES}.
         * @param type {@link #TYPE_REGULAR}, {@link #TYPE_DRAFT} or {@link #TYPE_TRASH}.
         */
        public void onMessageOpen(long messageId, long messageMailboxId, long listMailboxId,
                int type);

        /**
         * Called when an operation is initiated that can potentially advance the current
         * message selection (e.g. a delete operation may advance the selection).
         * @param affectedMessages the messages the operation will apply to
         */
        public void onAdvancingOpAccepted(Set<Long> affectedMessages);

        /**
         * Called when a drag & drop is initiated.
         *
         * @return true if drag & drop is allowed
         */
        public boolean onDragStarted();

        /**
         * Called when a drag & drop is ended.
         */
        public void onDragEnded();
    }

    private static final class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();

        @Override
        public void onMailboxNotFound(boolean isFirstLoad) {
        }

        @Override
        public void onMessageOpen(
                long messageId, long messageMailboxId, long listMailboxId, int type) {
        }

        @Override
        public void onAdvancingOpAccepted(Set<Long> affectedMessages) {
        }

        @Override
        public boolean onDragStarted() {
            return false; // We don't know -- err on the safe side.
        }

        @Override
        public void onDragEnded() {
        }
    }

    /**
     * Create a new instance with initialization parameters.
     *
     * This fragment should be created only with this method.  (Arguments should always be set.)
     *
     * @param listContext The list context to show messages for
     */
    public static MessageListFragment newInstance(MessageListContext listContext) {
        final MessageListFragment instance = new MessageListFragment();
        final Bundle args = new Bundle();
        args.putParcelable(ARG_LIST_CONTEXT, listContext);
        instance.setArguments(args);
        return instance;
    }

    /**
     * The context describing the contents to be shown in the list.
     * Do not use directly; instead, use the getters such as {@link #getAccountId()}.
     * <p><em>NOTE:</em> Although we cannot force these to be immutable using Java language
     * constructs, this <em>must</em> be considered immutable.
     */
    private MessageListContext mListContext;

    private void initializeArgCache() {
        if (mListContext != null) return;
        mListContext = getArguments().getParcelable(ARG_LIST_CONTEXT);
    }

    /**
     * @return the account ID passed to {@link #newInstance}.  Safe to call even before onCreate.
     *
     * NOTE it may return {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
     */
    public long getAccountId() {
        initializeArgCache();
        return mListContext.mAccountId;
    }

    /**
     * @return the mailbox ID passed to {@link #newInstance}.  Safe to call even before onCreate.
     */
    public long getMailboxId() {
        initializeArgCache();
        return mListContext.getMailboxId();
    }

    /**
     * @return true if the mailbox is a combined mailbox.  Safe to call even before onCreate.
     */
    public boolean isCombinedMailbox() {
        return getAccountId() == Account.ACCOUNT_ID_COMBINED_VIEW;
    }

    public MessageListContext getListContext() {
        initializeArgCache();
        return mListContext;
    }

    /**
     * @return Whether or not initial data is loaded in this list.
     */
    public boolean hasDataLoaded() {
        return mCountTotalAccounts > 0;
    }

    /**
     * @return The account object, when known. Null if not yet known.
     */
    public Account getAccount() {
        return mAccount;
    }

    /**
     * @return The mailbox where the messages belong in, when known. Null if not yet known.
     */
    public Mailbox getMailbox() {
        return mMailbox;
    }

    /**
     * @return Whether or not this message list is showing a user's inbox.
     *     Note that combined inbox view is treated as an inbox view.
     */
    public boolean isInboxList() {
        MessageListContext listContext = getListContext();
        long accountId = listContext.mAccountId;
        if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
            return listContext.getMailboxId() == Mailbox.QUERY_ALL_INBOXES;
        }

        if (!hasDataLoaded()) {
            // If the data hasn't finished loading, we don't have the full mailbox - infer from ID.
            long inboxId = Mailbox.findMailboxOfType(mActivity, accountId, Mailbox.TYPE_INBOX);
            return listContext.getMailboxId() == inboxId;
        }
        return (mMailbox != null) && (mMailbox.mType == Mailbox.TYPE_INBOX);
    }

    /**
     * @return The mailbox being searched, when known. Null if not yet known or if not a search
     *    result.
     */
    public Mailbox getSearchedMailbox() {
        return mSearchedMailbox;
    }

    @Override
    public void onAttach(Activity activity) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onAttach"");
        }
        super.onAttach(activity);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onCreate"");
        }
        super.onCreate(savedInstanceState);

        mActivity = getActivity();
        setHasOptionsMenu(true);
        mController = Controller.getInstance(mActivity);
        mRefreshManager = RefreshManager.getInstance(mActivity);

        mListAdapter = new MessagesAdapter(mActivity, this);
        mIsFirstLoad = true;
    }

    @Override
    public View onCreateView(
            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onCreateView"");
        }
        // Use a custom layout, which includes the original layout with ""send messages"" panel.
        View root = inflater.inflate(R.layout.message_list_fragment,null);
        mIsViewCreated = true;
        mListPanel = UiUtilities.getView(root, R.id.list_panel);
        return root;
    }

    public void setLayout(ThreePaneLayout layout) {
        if (UiUtilities.useTwoPane(mActivity)) {
            mListAdapter.setLayout(layout);
        }
    }

    private void initSearchHeader() {
        if (mSearchHeader == null) {
            ViewGroup root = (ViewGroup) getView();
            mSearchHeader = (ViewGroup) LayoutInflater.from(mActivity).inflate(
                    R.layout.message_list_search_header, root, false);
            mSearchHeaderText = UiUtilities.getView(mSearchHeader, R.id.search_header_text);
            mSearchHeaderCount = UiUtilities.getView(mSearchHeader, R.id.search_count);

            // Add above the actual list.
            root.addView(mSearchHeader, 0);
        }
    }

    /**
     * @return true if the content view is created and not destroyed yet. (i.e. between
     * {@link #onCreateView} and {@link #onDestroyView}.
     */
    private boolean isViewCreated() {
        // Note that we don't use ""getView() != null"".  This method is used in updateSelectionMode()
        // to determine if CAB shold be shown.  But because it's called from onDestroyView(), at
        // this point the fragment still has views but we want to hide CAB, we can't use
        // getView() here.
        return mIsViewCreated;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityCreated"");
        }
        super.onActivityCreated(savedInstanceState);

        final ListView lv = getListView();
        lv.setOnItemLongClickListener(this);
        lv.setOnTouchListener(this);
        lv.setItemsCanFocus(false);
        lv.setChoiceMode(ListView.CHOICE_MODE_SINGLE);

        mListFooterView = getActivity().getLayoutInflater().inflate(
                R.layout.message_list_item_footer, lv, false);
        setEmptyText(getString(R.string.message_list_no_messages));

        if (savedInstanceState != null) {
            // Fragment doesn't have this method.  Call it manually.
            restoreInstanceState(savedInstanceState);
        }

        startLoading();

        UiUtilities.installFragment(this);
    }

    @Override
    public void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onStart"");
        }
        super.onStart();
    }

    @Override
    public void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onResume"");
        }
        super.onResume();
        adjustMessageNotification(false);
        mRefreshManager.registerListener(mRefreshListener);
        mResumed = true;
    }

    @Override
    public void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onPause"");
        }
        mResumed = false;
        mSavedListState = getListView().onSaveInstanceState();
        adjustMessageNotification(true);
        super.onPause();
    }

    @Override
    public void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onStop"");
        }
        mTaskTracker.cancellAllInterrupt();
        mRefreshManager.unregisterListener(mRefreshListener);

        super.onStop();
    }

    @Override
    public void onDestroyView() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDestroyView"");
        }
        mIsViewCreated = false; // Clear this first for updateSelectionMode(). See isViewCreated().
        UiUtilities.uninstallFragment(this);
        updateSelectionMode();

        // Reset the footer mode since we just blew away the footer view we were holding on to.
        // This will get re-updated when/if this fragment is restored.
        mListFooterMode = LIST_FOOTER_MODE_NONE;
        super.onDestroyView();
    }

    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDestroy"");
        }

        finishSelectionMode();
        super.onDestroy();
    }

    @Override
    public void onDetach() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDetach"");
        }
        super.onDetach();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);
        mListAdapter.onSaveInstanceState(outState);
        if (isViewCreated()) {
            outState.putParcelable(BUNDLE_LIST_STATE, getListView().onSaveInstanceState());
        }
        outState.putLong(BUNDLE_KEY_SELECTED_MESSAGE_ID, mSelectedMessageId);
    }

    @VisibleForTesting
    void restoreInstanceState(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" restoreInstanceState"");
        }
        mListAdapter.loadState(savedInstanceState);
        mSavedListState = savedInstanceState.getParcelable(BUNDLE_LIST_STATE);
        mSelectedMessageId = savedInstanceState.getLong(BUNDLE_KEY_SELECTED_MESSAGE_ID);
    }

    @Override
    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        inflater.inflate(R.menu.message_list_fragment_option, menu);
    }

    @Override
    public void onPrepareOptionsMenu(Menu menu) {
        menu.findItem(R.id.send).setVisible(mShowSendCommand);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.send:
                onSendPendingMessages();
                return true;

        }
        return false;
    }

    public void setCallback(Callback callback) {
        mCallback = (callback != null) ? callback : EmptyCallback.INSTANCE;
    }

    /**
     * This method must be called when the fragment is hidden/shown.
     */
    public void onHidden(boolean hidden) {
        // When hidden, we need to disable CAB.
        if (hidden == mDisableCab) {
            return;
        }
        mDisableCab = hidden;
        updateSelectionMode();
    }

    public void setSelectedMessage(long messageId) {
        if (mSelectedMessageId == messageId) {
            return;
        }
        mSelectedMessageId = messageId;
        if (mResumed) {
            highlightSelectedMessage(true);
        }
    }

    /**
     * @return true if the mailbox is refreshable.  false otherwise, or unknown yet.
     */
    public boolean isRefreshable() {
        return mIsRefreshable;
    }

    /**
     * @return the number of messages that are currently selected.
     */
    private int getSelectedCount() {
        return mListAdapter.getSelectedSet().size();
    }

    /**
     * @return true if the list is in the ""selection"" mode.
     */
    public boolean isInSelectionMode() {
        return mSelectionMode != null;
    }

    /**
     * Called when a message is clicked.
     */
    @Override
    public void onListItemClick(ListView parent, View view, int position, long id) {
        if (view != mListFooterView) {
            MessageListItem itemView = (MessageListItem) view;
            onMessageOpen(itemView.mMailboxId, id);
        } else {
            doFooterClick();
        }
    }

    // This is tentative drag & drop UI
    private static class ShadowBuilder extends DragShadowBuilder {
        private static Drawable sBackground;
        /** Paint information for the move message text */
        private static TextPaint sMessagePaint;
        /** Paint information for the message count */
        private static TextPaint sCountPaint;
        /** The x location of any touch event; used to ensure the drag overlay is drawn correctly */
        private static int sTouchX;

        /** Width of the draggable view */
        private final int mDragWidth;
        /** Height of the draggable view */
        private final int mDragHeight;

        private final String mMessageText;
        private final PointF mMessagePoint;

        private final String mCountText;
        private final PointF mCountPoint;
        private int mOldOrientation = Configuration.ORIENTATION_UNDEFINED;

        /** Margin applied to the right of count text */
        private static float sCountMargin;
        /** Margin applied to left of the message text */
        private static float sMessageMargin;
        /** Vertical offset of the drag view */
        private static int sDragOffset;

        public ShadowBuilder(View view, int count) {
            super(view);
            Resources res = view.getResources();
            int newOrientation = res.getConfiguration().orientation;

            mDragHeight = view.getHeight();
            mDragWidth = view.getWidth();

            // TODO: Can we define a layout for the contents of the drag area?
            if (sBackground == null || mOldOrientation != newOrientation) {
                mOldOrientation = newOrientation;

                sBackground = res.getDrawable(R.drawable.list_pressed_holo);
                sBackground.setBounds(0, 0, mDragWidth, mDragHeight);

                sDragOffset = (int)res.getDimension(R.dimen.message_list_drag_offset);

                sMessagePaint = new TextPaint();
                float messageTextSize;
                messageTextSize = res.getDimension(R.dimen.message_list_drag_message_font_size);
                sMessagePaint.setTextSize(messageTextSize);
                sMessagePaint.setTypeface(Typeface.DEFAULT_BOLD);
                sMessagePaint.setAntiAlias(true);
                sMessageMargin = res.getDimension(R.dimen.message_list_drag_message_right_margin);

                sCountPaint = new TextPaint();
                float countTextSize;
                countTextSize = res.getDimension(R.dimen.message_list_drag_count_font_size);
                sCountPaint.setTextSize(countTextSize);
                sCountPaint.setTypeface(Typeface.DEFAULT_BOLD);
                sCountPaint.setAntiAlias(true);
                sCountMargin = res.getDimension(R.dimen.message_list_drag_count_left_margin);
            }

            // Calculate layout positions
            Rect b = new Rect();

            mMessageText = res.getQuantityString(R.plurals.move_messages, count, count);
            sMessagePaint.getTextBounds(mMessageText, 0, mMessageText.length(), b);
            mMessagePoint = new PointF(mDragWidth - b.right - sMessageMargin,
                    (mDragHeight - b.top)/ 2);

            mCountText = Integer.toString(count);
            sCountPaint.getTextBounds(mCountText, 0, mCountText.length(), b);
            mCountPoint = new PointF(sCountMargin,
                    (mDragHeight - b.top) / 2);
        }

        @Override
        public void onProvideShadowMetrics(Point shadowSize, Point shadowTouchPoint) {
            shadowSize.set(mDragWidth, mDragHeight);
            shadowTouchPoint.set(sTouchX, (mDragHeight / 2) + sDragOffset);
        }

        @Override
        public void onDrawShadow(Canvas canvas) {
            super.onDrawShadow(canvas);
            sBackground.draw(canvas);
            canvas.drawText(mMessageText, mMessagePoint.x, mMessagePoint.y, sMessagePaint);
            canvas.drawText(mCountText, mCountPoint.x, mCountPoint.y, sCountPaint);
        }
    }

    @Override
    public boolean onDrag(View view, DragEvent event) {
        switch(event.getAction()) {
            case DragEvent.ACTION_DRAG_ENDED:
                if (event.getResult()) {
                    onDeselectAll(); // Clear the selection
                }
                mCallback.onDragEnded();
                break;
        }
        return false;
    }

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            // Save the touch location to draw the drag overlay at the correct location
            ShadowBuilder.sTouchX = (int)event.getX();
        }
        // don't do anything, let the system process the event
        return false;
    }

    @Override
    public boolean onItemLongClick(AdapterView<?> parent, View view, int position, long id) {
        if (view != mListFooterView) {
            // Always toggle the item.
            MessageListItem listItem = (MessageListItem) view;
            boolean toggled = false;
            if (!mListAdapter.isSelected(listItem)) {
                toggleSelection(listItem);
                toggled = true;
            }

            // Additionally, check to see if we can drag the item.
            if (!mCallback.onDragStarted()) {
                return toggled; // D&D not allowed.
            }
            // We can't move from combined accounts view
            // We also need to check the actual mailbox to see if we can move items from it
            final long mailboxId = getMailboxId();
            if (mAccount == null || mMailbox == null) {
                return false;
            } else if (mailboxId > 0 && !mMailbox.canHaveMessagesMoved()) {
                return false;
            }
            // Start drag&drop.

            // Create ClipData with the Uri of the message we're long clicking
            ClipData data = ClipData.newUri(mActivity.getContentResolver(),
                    MessageListItem.MESSAGE_LIST_ITEMS_CLIP_LABEL, Message.CONTENT_URI.buildUpon()
                    .appendPath(Long.toString(listItem.mMessageId))
                    .appendQueryParameter(
                            EmailProvider.MESSAGE_URI_PARAMETER_MAILBOX_ID,
                            Long.toString(mailboxId))
                            .build());
            Set<Long> selectedMessageIds = mListAdapter.getSelectedSet();
            int size = selectedMessageIds.size();
            // Add additional Uri's for any other selected messages
            for (Long messageId: selectedMessageIds) {
                if (messageId.longValue() != listItem.mMessageId) {
                    data.addItem(new ClipData.Item(
                            ContentUris.withAppendedId(Message.CONTENT_URI, messageId)));
                }
            }
            // Start dragging now
            listItem.setOnDragListener(this);
            listItem.startDrag(data, new ShadowBuilder(listItem, size), null, 0);
            return true;
        }
        return false;
    }

    private void toggleSelection(MessageListItem itemView) {
        itemView.invalidate();
        mListAdapter.toggleSelected(itemView);
    }

    /**
     * Called when a message on the list is selected
     *
     * @param messageMailboxId the actual mailbox ID of the message.  Note it's different than
     *        what is returned by {@link #getMailboxId()} for combined mailboxes.
     *        ({@link #getMailboxId()} may return special mailbox values such as
     *        {@link Mailbox#QUERY_ALL_INBOXES})
     * @param messageId ID of the message to open.
     */
    private void onMessageOpen(final long messageMailboxId, final long messageId) {
        if ((mMailbox != null) && (mMailbox.mId == messageMailboxId)) {
            // Normal case - the message belongs in the mailbox list we're viewing.
            mCallback.onMessageOpen(messageId, messageMailboxId,
                    getMailboxId(), callbackTypeForMailboxType(mMailbox.mType));
            return;
        }

        // Weird case - a virtual mailbox where the messages could come from different mailbox
        // types - here we have to query the DB for the type.
        new MessageOpenTask(messageMailboxId, messageId).cancelPreviousAndExecuteParallel();
    }

    private int callbackTypeForMailboxType(int mailboxType) {
        switch (mailboxType) {
            case Mailbox.TYPE_DRAFTS:
                return Callback.TYPE_DRAFT;
            case Mailbox.TYPE_TRASH:
                return Callback.TYPE_TRASH;
            default:
                return Callback.TYPE_REGULAR;
        }
    }

    /**
     * Task to look up the mailbox type for a message, and kicks the callback.
     */
    private class MessageOpenTask extends EmailAsyncTask<Void, Void, Integer> {
        private final long mMessageMailboxId;
        private final long mMessageId;

        public MessageOpenTask(long messageMailboxId, long messageId) {
            super(mTaskTracker);
            mMessageMailboxId = messageMailboxId;
            mMessageId = messageId;
        }

        @Override
        protected Integer doInBackground(Void... params) {
            // Restore the mailbox type.  Note we can't use mMailbox.mType here, because
            // we don't have mMailbox for combined mailbox.
            // (""All Starred"" can contain any kind of messages.)
            return callbackTypeForMailboxType(
                    Mailbox.getMailboxType(mActivity, mMessageMailboxId));
        }

        @Override
        protected void onSuccess(Integer type) {
            if (type == null) {
                return;
            }
            mCallback.onMessageOpen(mMessageId, mMessageMailboxId, getMailboxId(), type);
        }
    }

    private void showMoveMessagesDialog(Set<Long> selectedSet) {
        long[] messageIds = Utility.toPrimitiveLongArray(selectedSet);
        MoveMessageToDialog dialog = MoveMessageToDialog.newInstance(messageIds, this);
        dialog.show(getFragmentManager(), ""dialog"");
    }

    @Override
    public void onMoveToMailboxSelected(long newMailboxId, long[] messageIds) {
        final Context context = getActivity();
        if (context == null) {
            // Detached from activity. This callback was really delayed or a monkey was involved.
            return;
        }

        mCallback.onAdvancingOpAccepted(Utility.toLongSet(messageIds));
        ActivityHelper.moveMessages(context, newMailboxId, messageIds);

        // Move is async, so we can't refresh now.  Instead, just clear the selection.
        onDeselectAll();
    }

    /**
     * Refresh the list.  NOOP for special mailboxes (e.g. combined inbox).
     *
     * Note: Manual refresh is enabled even for push accounts.
     */
    public void onRefresh(boolean userRequest) {
        if (mIsRefreshable) {
            mRefreshManager.refreshMessageList(getAccountId(), getMailboxId(), userRequest);
        }
    }

    private void onDeselectAll() {
        mListAdapter.clearSelection();
        if (isInSelectionMode()) {
            finishSelectionMode();
        }
    }

    /**
     * Load more messages.  NOOP for special mailboxes (e.g. combined inbox).
     */
    private void onLoadMoreMessages() {
        if (mIsRefreshable) {
            mRefreshManager.loadMoreMessages(getAccountId(), getMailboxId());
        }
    }

    public void onSendPendingMessages() {
        RefreshManager rm = RefreshManager.getInstance(mActivity);
        if (getMailboxId() == Mailbox.QUERY_ALL_OUTBOX) {
            rm.sendPendingMessagesForAllAccounts();
        } else if (mMailbox != null) { // Magic boxes don't have a specific account id.
            rm.sendPendingMessages(mMailbox.mAccountKey);
        }
    }

    /**
     * Toggles a set read/unread states.  Note, the default behavior is ""mark unread"", so the
     * sense of the helper methods is ""true=unread""; this may be called from the UI thread
     *
     * @param selectedSet The current list of selected items
     */
    private void toggleRead(Set<Long> selectedSet) {
        toggleMultiple(selectedSet, new MultiToggleHelper() {

            @Override
            public boolean getField(Cursor c) {
                return c.getInt(MessagesAdapter.COLUMN_READ) == 0;
            }

            @Override
            public void setField(long messageId, boolean newValue) {
                mController.setMessageReadSync(messageId, !newValue);
            }
        });
    }

    /**
     * Toggles a set of favorites (stars); this may be called from the UI thread
     *
     * @param selectedSet The current list of selected items
     */
    private void toggleFavorite(Set<Long> selectedSet) {
        toggleMultiple(selectedSet, new MultiToggleHelper() {

            @Override
            public boolean getField(Cursor c) {
                return c.getInt(MessagesAdapter.COLUMN_FAVORITE) != 0;
            }

            @Override
            public void setField(long messageId, boolean newValue) {
                mController.setMessageFavoriteSync(messageId, newValue);
             }
        });
    }

    private void deleteMessages(Set<Long> selectedSet) {
        final long[] messageIds = Utility.toPrimitiveLongArray(selectedSet);
        mController.deleteMessages(messageIds);
        Toast.makeText(mActivity, mActivity.getResources().getQuantityString(
                R.plurals.message_deleted_toast, messageIds.length), Toast.LENGTH_SHORT).show();
        selectedSet.clear();
        // Message deletion is async... Can't refresh the list immediately.
    }

    private interface MultiToggleHelper {
        /**
         * Return true if the field of interest is ""set"".  If one or more are false, then our
         * bulk action will be to ""set"".  If all are set, our bulk action will be to ""clear"".
         * @param c the cursor, positioned to the item of interest
         * @return true if the field at this row is ""set""
         */
        public boolean getField(Cursor c);

        /**
         * Set or clear the field of interest; setField is called asynchronously via EmailAsyncTask
         * @param messageId the message id of the current message
         * @param newValue the new value to be set at this row
         */
        public void setField(long messageId, boolean newValue);
    }

    /**
     * Toggle multiple fields in a message, using the following logic:  If one or more fields
     * are ""clear"", then ""set"" them.  If all fields are ""set"", then ""clear"" them all.  Provider
     * calls are applied asynchronously in setField
     *
     * @param selectedSet the set of messages that are selected
     * @param helper functions to implement the specific getter & setter
     */
    private void toggleMultiple(final Set<Long> selectedSet, final MultiToggleHelper helper) {
        final Cursor c = mListAdapter.getCursor();
        if (c == null || c.isClosed()) {
            return;
        }

        final HashMap<Long, Boolean> setValues = Maps.newHashMap();
        boolean allWereSet = true;

        c.moveToPosition(-1);
        while (c.moveToNext()) {
            long id = c.getInt(MessagesAdapter.COLUMN_ID);
            if (selectedSet.contains(id)) {
                boolean value = helper.getField(c);
                setValues.put(id, value);
                allWereSet = allWereSet && value;
            }
        }

        if (!setValues.isEmpty()) {
            final boolean newValue = !allWereSet;
            c.moveToPosition(-1);
            // TODO: we should probably put up a dialog or some other progress indicator for this.
            EmailAsyncTask.runAsyncParallel(new Runnable() {
               @Override
                public void run() {
                   for (long id : setValues.keySet()) {
                       if (setValues.get(id) != newValue) {
                           helper.setField(id, newValue);
                       }
                   }
                }});
        }
    }

    /**
     * Test selected messages for showing appropriate labels
     * @param selectedSet
     * @param columnId
     * @param defaultflag
     * @return true when the specified flagged message is selected
     */
    private boolean testMultiple(Set<Long> selectedSet, int columnId, boolean defaultflag) {
        final Cursor c = mListAdapter.getCursor();
        if (c == null || c.isClosed()) {
            return false;
        }
        c.moveToPosition(-1);
        while (c.moveToNext()) {
            long id = c.getInt(MessagesAdapter.COLUMN_ID);
            if (selectedSet.contains(Long.valueOf(id))) {
                if (c.getInt(columnId) == (defaultflag ? 1 : 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * @return true if one or more non-starred messages are selected.
     */
    public boolean doesSelectionContainNonStarredMessage() {
        return testMultiple(mListAdapter.getSelectedSet(), MessagesAdapter.COLUMN_FAVORITE,
                false);
    }

    /**
     * @return true if one or more read messages are selected.
     */
    public boolean doesSelectionContainReadMessage() {
        return testMultiple(mListAdapter.getSelectedSet(), MessagesAdapter.COLUMN_READ, true);
    }

    /**
     * Implements a timed refresh of ""stale"" mailboxes.  This should only happen when
     * multiple conditions are true, including:
     *   Only refreshable mailboxes.
     *   Only when the mailbox is ""stale"" (currently set to 5 minutes since last refresh)
     * Note we do this even if it's a push account; even on Exchange only inbox can be pushed.
     */
    private void autoRefreshStaleMailbox() {
        if (!mIsRefreshable) {
            // Not refreshable (special box such as drafts, or magic boxes)
            return;
        }
        if (!mRefreshManager.isMailboxStale(getMailboxId())) {
            return;
        }
        onRefresh(false);
    }

    /** Implements {@link MessagesAdapter.Callback} */
    @Override
    public void onAdapterFavoriteChanged(MessageListItem itemView, boolean newFavorite) {
        mController.setMessageFavorite(itemView.mMessageId, newFavorite);
    }

    /** Implements {@link MessagesAdapter.Callback} */
    @Override
    public void onAdapterSelectedChanged(MessageListItem itemView, boolean newSelected,
            int mSelectedCount) {
        updateSelectionMode();
    }

    private void updateSearchHeader(Cursor cursor) {
        MessageListContext listContext = getListContext();
        if (!listContext.isSearch() || cursor == null) {
            UiUtilities.setVisibilitySafe(mSearchHeader, View.GONE);
            return;
        }

        SearchResultsCursor searchCursor = (SearchResultsCursor) cursor;
        initSearchHeader();
        mSearchHeader.setVisibility(View.VISIBLE);
        String header = String.format(
                mActivity.getString(R.string.search_header_text_fmt),
                listContext.getSearchParams().mFilter);
        mSearchHeaderText.setText(header);
        int resultCount = searchCursor.getResultsCount();
        // Don't show a negative value here; this means that the server request failed
        // TODO Use some other text for this case (e.g. ""search failed"")?
        if (resultCount < 0) {
            resultCount = 0;
        }
        mSearchHeaderCount.setText(UiUtilities.getMessageCountForUi(
                mActivity, resultCount, false /* replaceZeroWithBlank */));
    }

    private int determineFooterMode() {
        int result = LIST_FOOTER_MODE_NONE;
        if ((mMailbox == null)
                || (mMailbox.mType == Mailbox.TYPE_OUTBOX)
                || (mMailbox.mType == Mailbox.TYPE_DRAFTS)) {
            return result; // No footer
        }
        if (mMailbox.mType == Mailbox.TYPE_SEARCH) {
            // Determine how many results have been loaded.
            Cursor c = mListAdapter.getCursor();
            if (c == null || c.isClosed()) {
                // Unknown yet - don't do anything.
                return result;
            }
            int total = ((SearchResultsCursor) c).getResultsCount();
            int loaded = c.getCount();

            if (loaded < total) {
                result = LIST_FOOTER_MODE_MORE;
            }
        } else if (!mIsEasAccount) {
            // IMAP, POP has ""load more"" for regular mailboxes.
            result = LIST_FOOTER_MODE_MORE;
        }
        return result;
    }

    private void updateFooterView() {
        // Only called from onLoadFinished -- always has views.
        int mode = determineFooterMode();
        if (mListFooterMode == mode) {
            return;
        }
        mListFooterMode = mode;

        ListView lv = getListView();
        if (mListFooterMode != LIST_FOOTER_MODE_NONE) {
            lv.addFooterView(mListFooterView);
            if (getListAdapter() != null) {
                // Already have an adapter - reset it to force the mode. But save the scroll
                // position so that we don't get kicked to the top.
                Parcelable listState = lv.onSaveInstanceState();
                setListAdapter(mListAdapter);
                lv.onRestoreInstanceState(listState);
            }

            mListFooterProgress = mListFooterView.findViewById(R.id.progress);
            mListFooterText = (TextView) mListFooterView.findViewById(R.id.main_text);
        } else {
            lv.removeFooterView(mListFooterView);
        }
        updateListFooter();
    }

    /**
     * Set the list footer text based on mode and the current ""network active"" status
     */
    private void updateListFooter() {
        if (mListFooterMode != LIST_FOOTER_MODE_NONE) {
            int footerTextId = 0;
            switch (mListFooterMode) {
                case LIST_FOOTER_MODE_MORE:
                    boolean active = mRefreshManager.isMessageListRefreshing(getMailboxId());
                    footerTextId = active ? R.string.status_loading_messages
                            : R.string.message_list_load_more_messages_action;
                    mListFooterProgress.setVisibility(active ? View.VISIBLE : View.GONE);
                    break;
            }
            mListFooterText.setText(footerTextId);
        }
    }

    /**
     * Handle a click in the list footer, which changes meaning depending on what we're looking at.
     */
    private void doFooterClick() {
        switch (mListFooterMode) {
            case LIST_FOOTER_MODE_NONE: // should never happen
                break;
            case LIST_FOOTER_MODE_MORE:
                onLoadMoreMessages();
                break;
        }
    }

    private void showSendCommand(boolean show) {
        if (show != mShowSendCommand) {
            mShowSendCommand = show;
            mActivity.invalidateOptionsMenu();
        }
    }

    private void updateMailboxSpecificActions() {
        final boolean isOutbox = (getMailboxId() == Mailbox.QUERY_ALL_OUTBOX)
                || ((mMailbox != null) && (mMailbox.mType == Mailbox.TYPE_OUTBOX));
        showSendCommand(isOutbox && (mListAdapter != null) && (mListAdapter.getCount() > 0));

        // A null account/mailbox means we're in a combined view. We show the move icon there,
        // even though it may be the case that we can't move messages from one of the mailboxes.
        // There's no good way to tell that right now, though.
        mShowMoveCommand = (mAccount == null || mAccount.supportsMoveMessages(getActivity()))
                && (mMailbox == null || mMailbox.canHaveMessagesMoved());

        // Enable mailbox specific actions on the UIController level if needed.
        mActivity.invalidateOptionsMenu();
    }

    /**
     * Adjusts message notification depending upon the state of the fragment and the currently
     * viewed mailbox. If the fragment is resumed, notifications for the current mailbox may
     * be suspended. Otherwise, notifications may be re-activated. Not all mailbox types are
     * supported for notifications. These include (but are not limited to) special mailboxes
     * such as {@link Mailbox#QUERY_ALL_DRAFTS}, {@link Mailbox#QUERY_ALL_FAVORITES}, etc...
     *
     * @param updateLastSeenKey If {@code true}, the last seen message key for the currently
     *                          viewed mailbox will be updated.
     */
    private void adjustMessageNotification(boolean updateLastSeenKey) {
        final long accountId = getAccountId();
        final long mailboxId = getMailboxId();
        if (mailboxId == Mailbox.QUERY_ALL_INBOXES || mailboxId > 0) {
            if (updateLastSeenKey) {
                Utility.updateLastSeenMessageKey(mActivity, accountId);
            }
            NotificationController notifier = NotificationController.getInstance(mActivity);
            notifier.suspendMessageNotification(mResumed, accountId);
        }
    }

    private void startLoading() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" startLoading"");
        }
        // Clear the list. (ListFragment will show the ""Loading"" animation)
        showSendCommand(false);
        updateSearchHeader(null);

        // Start loading...
        final LoaderManager lm = getLoaderManager();
        lm.initLoader(LOADER_ID_MESSAGES_LOADER, null, LOADER_CALLBACKS);
    }

    /** Timeout to show a warning, since some IMAP searches could take a long time. */
    private final int SEARCH_WARNING_DELAY_MS = 10000;

    private void onSearchLoadTimeout() {
        // Search is taking too long. Show an error message.
        ViewGroup root = (ViewGroup) getView();
        Activity host = getActivity();
        if (root != null && host != null) {
            mListPanel.setVisibility(View.GONE);
            mWarningContainer = (ViewGroup) LayoutInflater.from(host).inflate(
                    R.layout.message_list_warning, root, false);
            TextView title = UiUtilities.getView(mWarningContainer, R.id.message_title);
            TextView message = UiUtilities.getView(mWarningContainer, R.id.message_warning);
            title.setText(R.string.search_slow_warning_title);
            message.setText(R.string.search_slow_warning_message);
            root.addView(mWarningContainer);
        }
    }

    /**
     * Loader callbacks for message list.
     */
    private final LoaderManager.LoaderCallbacks<Cursor> LOADER_CALLBACKS =
            new LoaderManager.LoaderCallbacks<Cursor>() {
        @Override
        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
            final MessageListContext listContext = getListContext();
            if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                Log.d(Logging.LOG_TAG, MessageListFragment.this
                        + "" onCreateLoader(messages) listContext="" + listContext);
            }

            if (mListContext.isSearch()) {
                final MessageListContext searchInfo = mListContext;

                // Search results are not primed with local data, and so will usually be slow.
                // In some cases, they could take a long time to return, so we need to be robust.
                setListShownNoAnimation(false);
                Utility.getMainThreadHandler().postDelayed(new Runnable() {
                    @Override
                    public void run() {
                        if (mListContext != searchInfo) {
                            // Different list is being shown now.
                            return;
                        }
                        if (!mIsFirstLoad) {
                            // Something already returned. No need to do anything.
                            return;
                        }
                        onSearchLoadTimeout();
                    }
                }, SEARCH_WARNING_DELAY_MS);
            }

            mIsFirstLoad = true;
            return MessagesAdapter.createLoader(getActivity(), listContext);
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor c) {
            if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                Log.d(Logging.LOG_TAG, MessageListFragment.this
                        + "" onLoadFinished(messages) mailboxId="" + getMailboxId());
            }
            MessagesAdapter.MessagesCursor cursor = (MessagesAdapter.MessagesCursor) c;

            // Update the list
            mListAdapter.swapCursor(cursor);

            if (!cursor.mIsFound) {
                mCallback.onMailboxNotFound(mIsFirstLoad);
                return;
            }

            // Get the ""extras"" part.
            mAccount = cursor.mAccount;
            mMailbox = cursor.mMailbox;
            mIsEasAccount = cursor.mIsEasAccount;
            mIsRefreshable = cursor.mIsRefreshable;
            mCountTotalAccounts = cursor.mCountTotalAccounts;

            // If this is a search result, open the first message.
            if (UiUtilities.useTwoPane(getActivity()) && mIsFirstLoad && mListContext.isSearch()
                    && cursor.getCount() > 0) {
                cursor.moveToFirst();
                onMessageOpen(getMailboxId(), cursor.getLong(MessagesAdapter.COLUMN_ID));
            }

            // Suspend message notifications as long as we're resumed
            adjustMessageNotification(false);

            // If this is a search mailbox, set the query; otherwise, clear it
            if (mIsFirstLoad) {
                if (mMailbox != null && mMailbox.mType == Mailbox.TYPE_SEARCH) {
                    mListAdapter.setQuery(getListContext().getSearchParams().mFilter);
                    mSearchedMailbox = ((SearchResultsCursor) c).getSearchedMailbox();
                } else {
                    mListAdapter.setQuery(null);
                    mSearchedMailbox = null;
                }
                updateMailboxSpecificActions();

                // Show chips if combined view.
                mListAdapter.setShowColorChips(isCombinedMailbox() && mCountTotalAccounts > 1);
            }

            // Various post processing...
            updateSearchHeader(cursor);
            autoRefreshStaleMailbox();
            updateFooterView();
            updateSelectionMode();

            // We want to make visible the selection only for the first load.
            // Re-load caused by content changed events shouldn't scroll the list.
            highlightSelectedMessage(mIsFirstLoad);

            if (mIsFirstLoad) {
                UiUtilities.setVisibilitySafe(mWarningContainer, View.GONE);
                mListPanel.setVisibility(View.VISIBLE);

                // Setting the adapter will automatically transition from ""Loading"" to showing
                // the list, which could show ""No messages"". Avoid showing that on the first sync,
                // if we know we're still potentially loading more.
                if (!isEmptyAndLoading(cursor)) {
                    setListAdapter(mListAdapter);
                }
            } else if ((getListAdapter() == null) && !isEmptyAndLoading(cursor)) {
                setListAdapter(mListAdapter);
            }

            // Restore the state -- this step has to be the last, because Some of the
            // ""post processing"" seems to reset the scroll position.
            if (mSavedListState != null) {
                getListView().onRestoreInstanceState(mSavedListState);
                mSavedListState = null;
            }

            mIsFirstLoad = false;
        }

        /**
         * Determines whether or not the list is empty, but we're still potentially loading data.
         * This represents an ambiguous state where we may not want to show ""No messages"", since
         * it may still just be loading.
         */
        private boolean isEmptyAndLoading(Cursor cursor) {
            return (cursor.getCount() == 0)
                        && mRefreshManager.isMessageListRefreshing(mMailbox.mId);
        }

        @Override
        public void onLoaderReset(Loader<Cursor> loader) {
            if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                Log.d(Logging.LOG_TAG, MessageListFragment.this
                        + "" onLoaderReset(messages)"");
            }
            mListAdapter.swapCursor(null);
            mAccount = null;
            mMailbox = null;
            mSearchedMailbox = null;
            mCountTotalAccounts = 0;
        }
    };

    /**
     * Show/hide the ""selection"" action mode, according to the number of selected messages and
     * the visibility of the fragment.
     * Also update the content (title and menus) if necessary.
     */
    public void updateSelectionMode() {
        final int numSelected = getSelectedCount();
        if ((numSelected == 0) || mDisableCab || !isViewCreated()) {
            finishSelectionMode();
            return;
        }
        if (isInSelectionMode()) {
            updateSelectionModeView();
        } else {
            mLastSelectionModeCallback = new SelectionModeCallback();
            getActivity().startActionMode(mLastSelectionModeCallback);
        }
    }


    /**
     * Finish the ""selection"" action mode.
     *
     * Note this method finishes the contextual mode, but does *not* clear the selection.
     * If you want to do so use {@link #onDeselectAll()} instead.
     */
    private void finishSelectionMode() {
        if (isInSelectionMode()) {
            mLastSelectionModeCallback.mClosedByUser = false;
            mSelectionMode.finish();
        }
    }

    /** Update the ""selection"" action mode bar */
    private void updateSelectionModeView() {
        mSelectionMode.invalidate();
    }

    private class SelectionModeCallback implements ActionMode.Callback {
        private MenuItem mMarkRead;
        private MenuItem mMarkUnread;
        private MenuItem mAddStar;
        private MenuItem mRemoveStar;
        private MenuItem mMove;

        /* package */ boolean mClosedByUser = true;

        @Override
        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
            mSelectionMode = mode;

            MenuInflater inflater = getActivity().getMenuInflater();
            inflater.inflate(R.menu.message_list_fragment_cab_options, menu);
            mMarkRead = menu.findItem(R.id.mark_read);
            mMarkUnread = menu.findItem(R.id.mark_unread);
            mAddStar = menu.findItem(R.id.add_star);
            mRemoveStar = menu.findItem(R.id.remove_star);
            mMove = menu.findItem(R.id.move);
            return true;
        }

        @Override
        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
            int num = getSelectedCount();
            // Set title -- ""# selected""
            mSelectionMode.setTitle(getActivity().getResources().getQuantityString(
                    R.plurals.message_view_selected_message_count, num, num));

            // Show appropriate menu items.
            boolean nonStarExists = doesSelectionContainNonStarredMessage();
            boolean readExists = doesSelectionContainReadMessage();
            mMarkRead.setVisible(!readExists);
            mMarkUnread.setVisible(readExists);
            mAddStar.setVisible(nonStarExists);
            mRemoveStar.setVisible(!nonStarExists);
            mMove.setVisible(mShowMoveCommand);
            return true;
        }

        @Override
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
            Set<Long> selectedConversations = mListAdapter.getSelectedSet();
            if (selectedConversations.isEmpty()) return true;
            switch (item.getItemId()) {
                case R.id.mark_read:
                    // Note - marking as read does not trigger auto-advance.
                    toggleRead(selectedConversations);
                    break;
                case R.id.mark_unread:
                    mCallback.onAdvancingOpAccepted(selectedConversations);
                    toggleRead(selectedConversations);
                    break;
                case R.id.add_star:
                case R.id.remove_star:
                    // TODO: removing a star can be a destructive command and cause auto-advance
                    // if the current mailbox shown is favorites.
                    toggleFavorite(selectedConversations);
                    break;
                case R.id.delete:
                    mCallback.onAdvancingOpAccepted(selectedConversations);
                    deleteMessages(selectedConversations);
                    break;
                case R.id.move:
                    showMoveMessagesDialog(selectedConversations);
                    break;
            }
            return true;
        }

        @Override
        public void onDestroyActionMode(ActionMode mode) {
            // Clear this before onDeselectAll() to prevent onDeselectAll() from trying to close the
            // contextual mode again.
            mSelectionMode = null;
            if (mClosedByUser) {
                // Clear selection, only when the contextual mode is explicitly closed by the user.
                //
                // We close the contextual mode when the fragment becomes temporary invisible
                // (i.e. mIsVisible == false) too, in which case we want to keep the selection.
                onDeselectAll();
            }
        }
    }

    private class RefreshListener implements RefreshManager.Listener {
        @Override
        public void onMessagingError(long accountId, long mailboxId, String message) {
        }

        @Override
        public void onRefreshStatusChanged(long accountId, long mailboxId) {
            updateListFooter();
        }
    }

    /**
     * Highlight the selected message.
     */
    private void highlightSelectedMessage(boolean ensureSelectionVisible) {
        if (!isViewCreated()) {
            return;
        }

        final ListView lv = getListView();
        if (mSelectedMessageId == -1) {
            // No message selected
            lv.clearChoices();
            return;
        }

        final int count = lv.getCount();
        for (int i = 0; i < count; i++) {
            if (lv.getItemIdAtPosition(i) != mSelectedMessageId) {
                continue;
            }
            lv.setItemChecked(i, true);
            if (ensureSelectionVisible) {
                Utility.listViewSmoothScrollToPosition(getActivity(), lv, i);
            }
            break;
        }
    }
}
",False,267,0,0,10,56,3,19,L6
36,com.android.email.activity.MessageCommandButtonView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;

import android.content.Context;
import android.util.AttributeSet;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.TextView;

/**
 * A View that is shown at the bottom of {@link MessageViewFragment} and contains buttons such
 * as ""(move to) newer"".
 *
 * This class is meant to hide layout differences between portrait and landscape, if any.
 * e.g. We might combine some of the buttons when we have small real estate.
 */
public class MessageCommandButtonView extends LinearLayout implements View.OnClickListener {
    /**
     * If false, we don't want to show anything, in which case all fields holding a view
     * (e.g. {@link #mMoveToNewerButton}) are null.
     */
    private boolean mShowPanel;

    private View mMoveToNewerButton;
    private View mMoveToOlderButton;
    private TextView mMessagePosition;

    private Callback mCallback = EmptyCallback.INSTANCE;

    public interface Callback {
        public void onMoveToNewer();
        public void onMoveToOlder();
    }

    private static class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();
        @Override public void onMoveToNewer() {}
        @Override public void onMoveToOlder() {}
    }

    public MessageCommandButtonView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public MessageCommandButtonView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MessageCommandButtonView(Context context) {
        super(context);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();

        mMoveToNewerButton = findViewById(R.id.move_to_newer_button);
        if (mMoveToNewerButton == null) {
            mShowPanel = false;
            return;
        }
        mShowPanel = true;
        mMoveToOlderButton = findViewById(R.id.move_to_older_button);
        mMessagePosition = (TextView) findViewById(R.id.message_position);

        mMoveToNewerButton.setOnClickListener(this);
        mMoveToOlderButton.setOnClickListener(this);
    }

    public void setCallback(Callback callback) {
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
    }

    public void enableNavigationButtons(boolean enableMoveToNewer, boolean enableMoveToOlder,
            int currentPosition, int countMessages) {
        if (!mShowPanel) {
            return;
        }
        mMoveToNewerButton.setEnabled(enableMoveToNewer);
        mMoveToOlderButton.setEnabled(enableMoveToOlder);

        // Show ""POSITION of TOTAL""
        final String positionOfCount;
        if (countMessages == 0) {
            positionOfCount = """";
        } else {
            positionOfCount = getContext().getResources().getString(R.string.position_of_count,
                (currentPosition + 1), countMessages);
        }
        mMessagePosition.setText(positionOfCount);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.move_to_newer_button:
                mCallback.onMoveToNewer();
                break;
            case R.id.move_to_older_button:
                mCallback.onMoveToOlder();
                break;
        }
    }
}
",False,148,10,45,0,0,2,0,L6
37,com.android.email.activity.MessageFileView.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import android.app.ActionBar;
import android.app.Activity;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.view.MenuItem;

/**
 * Activity to show file-based messages.  (i.e. *.eml files, and possibly *.msg files).
 */
public class MessageFileView extends Activity implements MessageViewFragmentBase.Callback {
    private ActionBar mActionBar;

    private MessageFileViewFragment mFragment;

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(R.layout.message_file_view);

        mActionBar = getActionBar();
        mActionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_HOME | ActionBar.DISPLAY_HOME_AS_UP
                | ActionBar.DISPLAY_SHOW_TITLE);

        mFragment = (MessageFileViewFragment) getFragmentManager().findFragmentById(
                R.id.message_file_view_fragment);
        mFragment.setCallback(this);

        final Uri fileEmailUri = getIntent().getData();
        if (fileEmailUri == null) {
            Log.w(Logging.LOG_TAG, ""Insufficient intent parameter.  Closing..."");
            finish();
            return;
        }

        mFragment.setFileUri(fileEmailUri);

        // Set title.
        new LoadFilenameTask(fileEmailUri).executeParallel();
    }

    @Override
    public void onResume() {
        super.onResume();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        mTaskTracker.cancellAllInterrupt();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                onBackPressed(); // Treat as ""back"".
                return true;
        }

        return super.onOptionsItemSelected(item);
    }

    /**
     * Set the activity title.  (""Viewing FILENAME"")
     */
    private void setTitle(String filename) {
        mActionBar.setTitle(getString(R.string.eml_view_title, filename));
    }

    /**
     * Load the filename of the EML, and update the activity title.
     */
    private class LoadFilenameTask extends EmailAsyncTask<Void, Void, String> {
        private final Uri mContentUri;

        public LoadFilenameTask(Uri contentUri) {
            super(mTaskTracker);
            mContentUri = contentUri;
        }

        @Override
        protected String doInBackground(Void... params) {
            return Utility.getContentFileName(MessageFileView.this, mContentUri);
        }

        @Override
        protected void onSuccess(String filename) {
            if (filename == null) {
                return;
            }
            setTitle(filename);
        }
    }

    @Override
    public boolean onUrlInMessageClicked(String url) {
        // EML files don't have the ""owner"" account, so use the default account as the sender.
        return ActivityHelper.openUrlInMessage(this, url, Account.NO_ACCOUNT);
    }

    @Override
    public void onMessageNotExists() { // Probably meessage deleted.
        finish();
    }

    @Override
    public void onLoadMessageStarted() {
        // Not important for EMLs
    }

    @Override
    public void onLoadMessageFinished() {
        // Not important for EMLs
    }

    @Override
    public void onLoadMessageError(String errorMessage) {
        // Not important for EMLs
    }

    @VisibleForTesting
    MessageFileViewFragment getFragment() {
        return mFragment;
    }
}
",False,270,1,1,11,50,1,7,L8
38,com.android.email.activity.Welcome.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup.LayoutParams;

import com.android.email.Email;
import com.android.email.Preferences;
import com.android.email.R;
import com.android.email.activity.setup.AccountSettings;
import com.android.email.activity.setup.AccountSetupBasics;
import com.android.email.service.EmailServiceUtils;
import com.android.email.service.MailService;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.IntentUtilities;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

/**
 * The Welcome activity initializes the application and starts {@link EmailActivity}, or launch
 * {@link AccountSetupBasics} if no accounts are configured.
 *
 * TOOD Show ""your messages are on the way"" message like gmail does during the inbox lookup.
 */
public class Welcome extends Activity {
    /*
     * Commands for testing...
     *  Open 1 pane
        adb shell am start -a android.intent.action.MAIN \
            -d '""content://ui.email.android.com/view/mailbox""' \
            -e DEBUG_PANE_MODE 1

     *  Open 2 pane
        adb shell am start -a android.intent.action.MAIN \
            -d '""content://ui.email.android.com/view/mailbox""' \
            -e DEBUG_PANE_MODE 2

     *  Open an account (ID=1) in 2 pane
        adb shell am start -a android.intent.action.MAIN \
            -d '""content://ui.email.android.com/view/mailbox?ACCOUNT_ID=1""' \
            -e DEBUG_PANE_MODE 2

     *  Open a message (account id=1, mailbox id=2, message id=3)
        adb shell am start -a android.intent.action.MAIN \
            -d '""content://ui.email.android.com/view/mailbox?ACCOUNT_ID=1&MAILBOX_ID=2&MESSAGE_ID=3""' \
            -e DEBUG_PANE_MODE 2

     *  Open the combined starred on the combined view
        adb shell am start -a android.intent.action.MAIN \
            -d '""content://ui.email.android.com/view/mailbox?ACCOUNT_ID=1152921504606846976&MAILBOX_ID=-4""' \
            -e DEBUG_PANE_MODE 2
     */

    /**
     * Extra for debugging.  Set 1 to force one-pane.  Set 2 to force two-pane.
     */
    private static final String EXTRA_DEBUG_PANE_MODE = ""DEBUG_PANE_MODE"";

    private static final String VIEW_MAILBOX_INTENT_URL_PATH = ""/view/mailbox"";

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    private View mWaitingForSyncView;

    private long mAccountId;
    private long mMailboxId;
    private long mMessageId;
    private String mAccountUuid;

    private MailboxFinder mInboxFinder;

    /**
     * Launch this activity.  Note:  It's assumed that this activity is only called as a means to
     * 'reset' the UI state; Because of this, it is always launched with FLAG_ACTIVITY_CLEAR_TOP,
     * which will drop any other activities on the stack (e.g. AccountFolderList or MessageList).
     */
    public static void actionStart(Activity fromActivity) {
        Intent i = IntentUtilities.createRestartAppIntent(fromActivity, Welcome.class);
        fromActivity.startActivity(i);
    }

    /**
     * Create an Intent to open email activity. If <code>accountId</code> is not -1, the
     * specified account will be automatically be opened when the activity starts.
     */
    public static Intent createOpenAccountInboxIntent(Context context, long accountId) {
        final Uri.Builder b = IntentUtilities.createActivityIntentUrlBuilder(
                VIEW_MAILBOX_INTENT_URL_PATH);
        IntentUtilities.setAccountId(b, accountId);
        return IntentUtilities.createRestartAppIntent(b.build());
    }

    /**
     * Create an Intent to open a message.
     */
    public static Intent createOpenMessageIntent(Context context, long accountId,
            long mailboxId, long messageId) {
        final Uri.Builder b = IntentUtilities.createActivityIntentUrlBuilder(
                VIEW_MAILBOX_INTENT_URL_PATH);
        IntentUtilities.setAccountId(b, accountId);
        IntentUtilities.setMailboxId(b, mailboxId);
        IntentUtilities.setMessageId(b, messageId);
        return IntentUtilities.createRestartAppIntent(b.build());
    }

    /**
     * Open account's inbox.
     */
    public static void actionOpenAccountInbox(Activity fromActivity, long accountId) {
        fromActivity.startActivity(createOpenAccountInboxIntent(fromActivity, accountId));
    }

    /**
     * Create an {@link Intent} for account shortcuts.  The returned intent stores the account's
     * UUID rather than the account ID, which will be changed after account restore.
     */
    public static Intent createAccountShortcutIntent(Context context, String uuid, long mailboxId) {
        final Uri.Builder b = IntentUtilities.createActivityIntentUrlBuilder(
                VIEW_MAILBOX_INTENT_URL_PATH);
        IntentUtilities.setAccountUuid(b, uuid);
        IntentUtilities.setMailboxId(b, mailboxId);
        return IntentUtilities.createRestartAppIntent(b.build());
    }

    /**
     * If the {@link #EXTRA_DEBUG_PANE_MODE} extra is ""1"" or ""2"", return 1 or 2 respectively.
     * Otherwise return 0.
     *
     * @see UiUtilities#setDebugPaneMode(int)
     * @see UiUtilities#useTwoPane(Context)
     */
    private static int getDebugPaneMode(Intent i) {
        Bundle extras = i.getExtras();
        if (extras != null) {
            String s = extras.getString(EXTRA_DEBUG_PANE_MODE);
            if (""1"".equals(s)) {
                return 1;
            } else if (""2"".equals(s)) {
                return 2;
            }
        }
        return 0;
    }

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);
        ActivityHelper.debugSetWindowFlags(this);

        // Because the app could be reloaded (for debugging, etc.), we need to make sure that
        // ExchangeService gets a chance to start.  There is no harm to starting it if it has
        // already been started
        // When the service starts, it reconciles EAS accounts.
        // TODO More completely separate ExchangeService from Email app
        EmailServiceUtils.startExchangeService(this);

        // Extract parameters from the intent.
        final Intent intent = getIntent();
        mAccountId = IntentUtilities.getAccountIdFromIntent(intent);
        mMailboxId = IntentUtilities.getMailboxIdFromIntent(intent);
        mMessageId = IntentUtilities.getMessageIdFromIntent(intent);
        mAccountUuid = IntentUtilities.getAccountUuidFromIntent(intent);
        UiUtilities.setDebugPaneMode(getDebugPaneMode(intent));

        // Reconcile POP/IMAP accounts.  EAS accounts are taken care of by ExchangeService.
        if (MailService.hasMismatchInPopImapAccounts(this)) {
            EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
                public void run() {
                    // Reconciling can be heavy - so do it in the background.
                    MailService.reconcilePopImapAccountsSync(Welcome.this);
                    resolveAccount();
                }
            });
        } else {
            resolveAccount();
        }

        // Reset the ""accounts changed"" notification, now that we're here
        Email.setNotifyUiAccountsChanged(false);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Only create the menu if we had to stop and show a loading spinner - otherwise
        // this is a transient activity with no UI.
        if (mInboxFinder == null) {
            return super.onCreateOptionsMenu(menu);
        }

        getMenuInflater().inflate(R.menu.welcome, menu);
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == R.id.account_settings) {
            AccountSettings.actionSettings(this, mAccountId);
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    protected void onStop() {
        // Cancel all running tasks.
        // (If it's stopping for configuration changes, we just re-do everything on the new
        // instance)
        stopInboxLookup();
        mTaskTracker.cancellAllInterrupt();

        super.onStop();

        if (!isChangingConfigurations()) {
            // This means the user opened some other app.
            // Just close self and not launch EmailActivity.
            if (Email.DEBUG && Logging.DEBUG_LIFECYCLE) {
                Log.d(Logging.LOG_TAG, ""Welcome: Closing self..."");
            }
            finish();
        }
    }

    /**
     * {@inheritDoc}
     *
     * When launching an activity from {@link Welcome}, we always want to set
     * {@link Intent#FLAG_ACTIVITY_FORWARD_RESULT}.
     */
    @Override
    public void startActivity(Intent intent) {
        intent.setFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);
        super.startActivity(intent);
    }

    /**
     * Stop inbox lookup.  This MSUT be called on the UI thread.
     */
    private void stopInboxLookup() {
        if (mInboxFinder != null) {
            mInboxFinder.cancel();
            mInboxFinder = null;
        }
    }

    /**
     * Start inbox lookup.  This MSUT be called on the UI thread.
     */
    private void startInboxLookup() {
        Log.i(Logging.LOG_TAG, ""Inbox not found.  Starting mailbox finder..."");
        stopInboxLookup(); // Stop if already running -- it shouldn't be but just in case.
        mInboxFinder = new MailboxFinder(this, mAccountId, Mailbox.TYPE_INBOX,
                mMailboxFinderCallback);
        mInboxFinder.startLookup();

        // Show ""your email will appear shortly"" message.
        mWaitingForSyncView = LayoutInflater.from(this).inflate(
                R.layout.waiting_for_sync_message, null);
        addContentView(mWaitingForSyncView, new LayoutParams(
                LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
        invalidateOptionsMenu();
    }

    /**
     * Determine which account to open with the given account ID and UUID.
     *
     * @return ID of the account to use.
     */
    @VisibleForTesting
    static long resolveAccountId(Context context, long inputAccountId, String inputUuid) {
        final long accountId;

        if (!TextUtils.isEmpty(inputUuid)) {
            // If a UUID is specified, try to use it.
            // If the UUID is invalid, accountId will be NO_ACCOUNT.
            accountId = Account.getAccountIdFromUuid(context, inputUuid);

        } else if (inputAccountId != Account.NO_ACCOUNT) {
            // If a valid account ID is specified, just use it.
            if (inputAccountId == Account.ACCOUNT_ID_COMBINED_VIEW
                    || Account.isValidId(context, inputAccountId)) {
                accountId = inputAccountId;
            } else {
                accountId = Account.NO_ACCOUNT;
            }
        } else {
            // Neither an accountID or a UUID is specified.
            // Use the last account used, falling back to the default.
            long lastUsedId = Preferences.getPreferences(context).getLastUsedAccountId();
            if (lastUsedId != Account.NO_ACCOUNT) {
                if (!Account.isValidId(context, lastUsedId)) {
                    // The last account that was used has since been deleted.
                    lastUsedId = Account.NO_ACCOUNT;
                    Preferences.getPreferences(context).setLastUsedAccountId(Account.NO_ACCOUNT);
                }
            }
            accountId = (lastUsedId == Account.NO_ACCOUNT)
                    ? Account.getDefaultAccountId(context)
                    : lastUsedId;
        }
        if (accountId != Account.NO_ACCOUNT) {
            // Okay, the given account is valid.
            return accountId;
        } else {
            // No, it's invalid.  Show the warning toast and use the default.
            Utility.showToast(context, R.string.toast_account_not_found);
            return Account.getDefaultAccountId(context);
        }
    }

    /**
     * Determine which account to use according to the number of accounts already set up,
     * {@link #mAccountId} and {@link #mAccountUuid}.
     *
     * <pre>
     * 1. If there's no account configured, start account setup.
     * 2. Otherwise detemine which account to open with {@link #resolveAccountId} and
     *   2a. If the account doesn't have inbox yet, start inbox finder.
     *   2b. Otherwise open the main activity.
     * </pre>
     */
    private void resolveAccount() {
        final int numAccount = EmailContent.count(this, Account.CONTENT_URI);
        if (numAccount == 0) {
            AccountSetupBasics.actionNewAccount(this);
            finish();
            return;
        } else {
            mAccountId = resolveAccountId(this, mAccountId, mAccountUuid);
            if (Account.isNormalAccount(mAccountId) &&
                    Mailbox.findMailboxOfType(this, mAccountId, Mailbox.TYPE_INBOX)
                            == Mailbox.NO_MAILBOX) {
                startInboxLookup();
                return;
            }
        }
        startEmailActivity();
    }

    /**
     * Start {@link EmailActivity} using {@link #mAccountId}, {@link #mMailboxId} and
     * {@link #mMessageId}.
     */
    private void startEmailActivity() {
        final Intent i;
        if (mMessageId != Message.NO_MESSAGE) {
            i = EmailActivity.createOpenMessageIntent(this, mAccountId, mMailboxId, mMessageId);
        } else if (mMailboxId != Mailbox.NO_MAILBOX) {
            i = EmailActivity.createOpenMailboxIntent(this, mAccountId, mMailboxId);
        } else {
            i = EmailActivity.createOpenAccountIntent(this, mAccountId);
        }
        startActivity(i);
        finish();
    }

    private final MailboxFinder.Callback mMailboxFinderCallback = new MailboxFinder.Callback() {
        // This MUST be called from callback methods.
        private void cleanUp() {
            mInboxFinder = null;
        }

        @Override
        public void onAccountNotFound() {
            cleanUp();
            // Account removed?  Clear the IDs and restart the task.  Which will result in either
            // a) show account setup if there's really no accounts  or b) open the default account.

            mAccountId = Account.NO_ACCOUNT;
            mMailboxId = Mailbox.NO_MAILBOX;
            mMessageId = Message.NO_MESSAGE;
            mAccountUuid = null;

            // Restart the account resolution.
            resolveAccount();
        }

        @Override
        public void onMailboxNotFound(long accountId) {
            // Just do the same thing as ""account not found"".
            onAccountNotFound();
        }

        @Override
        public void onAccountSecurityHold(long accountId) {
            cleanUp();

            ActivityHelper.showSecurityHoldDialog(Welcome.this, accountId);
            finish();
        }

        @Override
        public void onMailboxFound(long accountId, long mailboxId) {
            cleanUp();

            // Okay the account has Inbox now.  Start the main activity.
            startEmailActivity();
        }
    };
}
",False,268,1,1,11,53,12,17,L6
39,com.android.email.activity.MailboxListItem.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Mailbox;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.widget.RelativeLayout;
import android.widget.TextView;

public class MailboxListItem extends RelativeLayout {
    // Colors used for drop targets
    private static Integer sDropAvailableBgColor;
    private static Integer sDropTrashBgColor;

    /**
     * Owner account ID for the mailbox, {@link Account#ACCOUNT_ID_COMBINED_VIEW} for a combined
     * mailbox, or the ID for the current account, if it's an account row.
     */
    public long mAccountId;

    /**
     * ID for the current mailbox, or {@link Mailbox#NO_MAILBOX} if it's an account row.
     */
    public long mMailboxId;
    public Integer mMailboxType;
    /** If {@code true} this item can be used as a drop target. Otherwise, drop is prohibited. */
    public boolean mIsValidDropTarget;
    /** If {@code true} this item can be navigated to. Otherwise, it can just be selected. */
    public boolean mIsNavigable;
    public MailboxFragmentAdapter mAdapter;

    private Drawable mBackground;
    private TextView mLabelName;
    private TextView mLabelCount;

    /**
     * Drawable for an active item for D&D.  Note the drawable has state, so we can't share it
     * between items.
     * DO NOT use this directly; use {@link #getDropActiveBgDrawable()} instead, as it's lazily-
     * initialized.
     */
    private Drawable mDropActiveBgDrawable;

    public MailboxListItem(Context context) {
        super(context);
    }

    public MailboxListItem(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MailboxListItem(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        mBackground = getBackground();
        if (sDropAvailableBgColor == null) {
            Resources res = getResources();
            sDropAvailableBgColor = res.getColor(R.color.mailbox_drop_available_bg_color);
            sDropTrashBgColor = res.getColor(R.color.mailbox_drop_destructive_bg_color);
        }
        mLabelName = (TextView)findViewById(R.id.mailbox_name);
        mLabelCount = (TextView)findViewById(R.id.message_count);
    }

    /**
     * Whether or not this mailbox item is a drop target. Only valid mailboxes or those
     * not forbidden by the system (see {@link Mailbox#INVALID_DROP_TARGETS}) will return
     * {@code true}.
     */
    public boolean isDropTarget(long itemMailboxId) {
        return mIsValidDropTarget && (itemMailboxId != mMailboxId);
    }

    /**
     * Returns whether or not this item can be navigated to.
     */
    public boolean isNavigable() {
        return mIsNavigable;
    }

    private Drawable getDropActiveBgDrawable() {
        if (mDropActiveBgDrawable == null) {
            mDropActiveBgDrawable =
                getContext().getResources().getDrawable(R.drawable.list_activated_holo);
        }
        return mDropActiveBgDrawable;
    }

    @Override
    public void setBackgroundDrawable(Drawable d) {
        // Don't override with the same instance.
        // If we don't do the check, something bad will happen to the fade-out animation for
        // the selected to non-selected transition.  (Looks like if you re-set the same
        // StateListDrawable instance, it'll get confused.)
        if (d != getBackground()) {
            super.setBackgroundDrawable(d);
        }
    }

    /**
     * Set the ""trash"" drop target background.
     */
    public void setDropTrashBackground() {
        setBackgroundColor(sDropTrashBgColor);
    }

    /**
     * Set the ""active"" drop target background.  (Used for the items that the user is hovering over)
     */
    public void setDropActiveBackground() {
        setBackgroundDrawable(getDropActiveBgDrawable());
    }

    public void setDropTargetBackground(boolean dragInProgress, long itemMailbox) {
        boolean isBackgroundSet = false;
        if (dragInProgress) {
            if (isDropTarget(itemMailbox)) {
                setBackgroundColor(sDropAvailableBgColor);
                isBackgroundSet = true;
            } else {
                mLabelName.setEnabled(false);
                mLabelCount.setEnabled(false);
            }
        } else {
            mLabelName.setEnabled(true);
            mLabelCount.setEnabled(true);
        }
        if (!isBackgroundSet) {
            // Drag not in progress, or it's not a drop target.
            setBackgroundDrawable(mBackground);
        }
    }
}
",False,267,0,0,12,44,2,3,L6
40,com.android.email.activity.MessageListItem.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.Context;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.text.Layout.Alignment;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.text.TextUtils;
import android.text.TextUtils.TruncateAt;
import android.text.format.DateUtils;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;

import com.android.email.R;
import com.android.emailcommon.utility.TextUtilities;
import com.google.common.base.Objects;

/**
 * This custom View is the list item for the MessageList activity, and serves two purposes:
 * 1.  It's a container to store message metadata (e.g. the ids of the message, mailbox, & account)
 * 2.  It handles internal clicks such as the checkbox or the favorite star
 */
public class MessageListItem extends View {
    // Note: messagesAdapter directly fiddles with these fields.
    /* package */ long mMessageId;
    /* package */ long mMailboxId;
    /* package */ long mAccountId;

    private ThreePaneLayout mLayout;
    private MessagesAdapter mAdapter;
    private MessageListItemCoordinates mCoordinates;
    private Context mContext;

    private boolean mDownEvent;

    public static final String MESSAGE_LIST_ITEMS_CLIP_LABEL =
        ""com.android.email.MESSAGE_LIST_ITEMS"";

    public MessageListItem(Context context) {
        super(context);
        init(context);
    }

    public MessageListItem(Context context, AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    public MessageListItem(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        init(context);
    }

    // Wide mode shows sender, snippet, time, and favorite spread out across the screen
    private static final int MODE_WIDE = MessageListItemCoordinates.WIDE_MODE;
    // Sentinel indicating that the view needs layout
    public static final int NEEDS_LAYOUT = -1;

    private static boolean sInit = false;
    private static final TextPaint sDefaultPaint = new TextPaint();
    private static final TextPaint sBoldPaint = new TextPaint();
    private static final TextPaint sDatePaint = new TextPaint();
    private static Bitmap sAttachmentIcon;
    private static Bitmap sInviteIcon;
    private static int sBadgeMargin;
    private static Bitmap sFavoriteIconOff;
    private static Bitmap sFavoriteIconOn;
    private static Bitmap sSelectedIconOn;
    private static Bitmap sSelectedIconOff;
    private static Bitmap sStateReplied;
    private static Bitmap sStateForwarded;
    private static Bitmap sStateRepliedAndForwarded;
    private static String sSubjectSnippetDivider;
    private static String sSubjectDescription;
    private static String sSubjectEmptyDescription;

    // Static colors.
    private static int DEFAULT_TEXT_COLOR;
    private static int ACTIVATED_TEXT_COLOR;
    private static int LIGHT_TEXT_COLOR;
    private static int DRAFT_TEXT_COLOR;
    private static int SUBJECT_TEXT_COLOR_READ;
    private static int SUBJECT_TEXT_COLOR_UNREAD;
    private static int SNIPPET_TEXT_COLOR_READ;
    private static int SNIPPET_TEXT_COLOR_UNREAD;
    private static int SENDERS_TEXT_COLOR_READ;
    private static int SENDERS_TEXT_COLOR_UNREAD;
    private static int DATE_TEXT_COLOR_READ;
    private static int DATE_TEXT_COLOR_UNREAD;

    public String mSender;
    public SpannableStringBuilder mText;
    public CharSequence mSnippet;
    private String mSubject;
    private StaticLayout mSubjectLayout;
    public boolean mRead;
    public boolean mHasAttachment = false;
    public boolean mHasInvite = true;
    public boolean mIsFavorite = false;
    public boolean mHasBeenRepliedTo = false;
    public boolean mHasBeenForwarded = false;
    /** {@link Paint} for account color chips.  null if no chips should be drawn.  */
    public Paint mColorChipPaint;

    private int mMode = -1;

    private int mViewWidth = 0;
    private int mViewHeight = 0;

    private static int sItemHeightWide;
    private static int sItemHeightNormal;

    // Note: these cannot be shared Drawables because they are selectors which have state.
    private Drawable mReadSelector;
    private Drawable mUnreadSelector;
    private Drawable mWideReadSelector;
    private Drawable mWideUnreadSelector;

    private CharSequence mFormattedSender;
    // We must initialize this to something, in case the timestamp of the message is zero (which
    // should be very rare); this is otherwise set in setTimestamp
    private CharSequence mFormattedDate = """";

    private void init(Context context) {
        mContext = context;
        if (!sInit) {
            Resources r = context.getResources();
            sSubjectDescription = r.getString(R.string.message_subject_description).concat("", "");
            sSubjectEmptyDescription = r.getString(R.string.message_is_empty_description);
            sSubjectSnippetDivider = r.getString(R.string.message_list_subject_snippet_divider);
            sItemHeightWide =
                r.getDimensionPixelSize(R.dimen.message_list_item_height_wide);
            sItemHeightNormal =
                r.getDimensionPixelSize(R.dimen.message_list_item_height_normal);

            sDefaultPaint.setTypeface(Typeface.DEFAULT);
            sDefaultPaint.setAntiAlias(true);
            sDatePaint.setTypeface(Typeface.DEFAULT);
            sDatePaint.setAntiAlias(true);
            sBoldPaint.setTypeface(Typeface.DEFAULT_BOLD);
            sBoldPaint.setAntiAlias(true);

            sAttachmentIcon = BitmapFactory.decodeResource(r, R.drawable.ic_badge_attachment);
            sInviteIcon = BitmapFactory.decodeResource(r, R.drawable.ic_badge_invite_holo_light);
            sBadgeMargin = r.getDimensionPixelSize(R.dimen.message_list_badge_margin);
            sFavoriteIconOff =
                BitmapFactory.decodeResource(r, R.drawable.btn_star_off_normal_email_holo_light);
            sFavoriteIconOn =
                BitmapFactory.decodeResource(r, R.drawable.btn_star_on_normal_email_holo_light);
            sSelectedIconOff =
                BitmapFactory.decodeResource(r, R.drawable.btn_check_off_normal_holo_light);
            sSelectedIconOn =
                BitmapFactory.decodeResource(r, R.drawable.btn_check_on_normal_holo_light);

            sStateReplied =
                BitmapFactory.decodeResource(r, R.drawable.ic_badge_reply_holo_light);
            sStateForwarded =
                BitmapFactory.decodeResource(r, R.drawable.ic_badge_forward_holo_light);
            sStateRepliedAndForwarded =
                BitmapFactory.decodeResource(r, R.drawable.ic_badge_reply_forward_holo_light);

            DEFAULT_TEXT_COLOR = r.getColor(R.color.default_text_color);
            ACTIVATED_TEXT_COLOR = r.getColor(android.R.color.white);
            SUBJECT_TEXT_COLOR_READ = r.getColor(R.color.subject_text_color_read);
            SUBJECT_TEXT_COLOR_UNREAD = r.getColor(R.color.subject_text_color_unread);
            SNIPPET_TEXT_COLOR_READ = r.getColor(R.color.snippet_text_color_read);
            SNIPPET_TEXT_COLOR_UNREAD = r.getColor(R.color.snippet_text_color_unread);
            SENDERS_TEXT_COLOR_READ = r.getColor(R.color.senders_text_color_read);
            SENDERS_TEXT_COLOR_UNREAD = r.getColor(R.color.senders_text_color_unread);
            DATE_TEXT_COLOR_READ = r.getColor(R.color.date_text_color_read);
            DATE_TEXT_COLOR_UNREAD = r.getColor(R.color.date_text_color_unread);

            sInit = true;
        }
    }

    /**
     * Invalidate all drawing caches associated with drawing message list items.
     * This is an expensive operation, and should be done rarely, such as when system font size
     * changes occurs.
     */
    public static void resetDrawingCaches() {
        MessageListItemCoordinates.resetCaches();
        sInit = false;
    }

    /**
     * Sets message subject and snippet safely, ensuring the cache is invalidated.
     */
    public void setText(String subject, String snippet, boolean forceUpdate) {
        boolean changed = false;
        if (!Objects.equal(mSubject, subject)) {
            mSubject = subject;
            changed = true;
            populateContentDescription();
        }

        if (!Objects.equal(mSnippet, snippet)) {
            mSnippet = snippet;
            changed = true;
        }

        if (forceUpdate || changed || (mSubject == null && mSnippet == null) /* first time */) {
            SpannableStringBuilder ssb = new SpannableStringBuilder();
            boolean hasSubject = false;
            if (!TextUtils.isEmpty(mSubject)) {
                SpannableString ss = new SpannableString(mSubject);
                ss.setSpan(new StyleSpan(mRead ? Typeface.NORMAL : Typeface.BOLD), 0, ss.length(),
                        Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                ssb.append(ss);
                hasSubject = true;
            }
            if (!TextUtils.isEmpty(mSnippet)) {
                if (hasSubject) {
                    ssb.append(sSubjectSnippetDivider);
                }
                ssb.append(mSnippet);
            }
            mText = ssb;
            requestLayout();
        }
    }

    long mTimeFormatted = 0;
    public void setTimestamp(long timestamp) {
        if (mTimeFormatted != timestamp) {
            mFormattedDate = DateUtils.getRelativeTimeSpanString(mContext, timestamp).toString();
            mTimeFormatted = timestamp;
        }
    }

    /**
     * Determine the mode of this view (WIDE or NORMAL)
     *
     * @param width The width of the view
     * @return The mode of the view
     */
    private int getViewMode(int width) {
        return MessageListItemCoordinates.getMode(mContext, width);
    }

    private Drawable mCurentBackground = null; // Only used by updateBackground()

    private void updateBackground() {
        final Drawable newBackground;
        boolean isMultiPane = MessageListItemCoordinates.isMultiPane(mContext);
        if (mRead) {
            if (isMultiPane && mLayout.isLeftPaneVisible()) {
                if (mWideReadSelector == null) {
                    mWideReadSelector = getContext().getResources()
                            .getDrawable(R.drawable.conversation_wide_read_selector);
                }
                newBackground = mWideReadSelector;
            } else {
                if (mReadSelector == null) {
                    mReadSelector = getContext().getResources()
                            .getDrawable(R.drawable.conversation_read_selector);
                }
                newBackground = mReadSelector;
            }
        } else {
            if (isMultiPane && mLayout.isLeftPaneVisible()) {
                if (mWideUnreadSelector == null) {
                    mWideUnreadSelector = getContext().getResources().getDrawable(
                            R.drawable.conversation_wide_unread_selector);
                }
                newBackground = mWideUnreadSelector;
            } else {
                if (mUnreadSelector == null) {
                    mUnreadSelector = getContext().getResources()
                            .getDrawable(R.drawable.conversation_unread_selector);
                }
                newBackground = mUnreadSelector;
            }
        }
        if (newBackground != mCurentBackground) {
            // setBackgroundDrawable is a heavy operation.  Only call it when really needed.
            setBackgroundDrawable(newBackground);
            mCurentBackground = newBackground;
        }
    }

    private void calculateSubjectText() {
        if (mText == null || mText.length() == 0) {
            return;
        }
        boolean hasSubject = false;
        int snippetStart = 0;
        if (!TextUtils.isEmpty(mSubject)) {
            int subjectColor = getFontColor(mRead ? SUBJECT_TEXT_COLOR_READ
                    : SUBJECT_TEXT_COLOR_UNREAD);
            mText.setSpan(new ForegroundColorSpan(subjectColor), 0, mSubject.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            snippetStart = mSubject.length() + 1;
        }
        if (!TextUtils.isEmpty(mSnippet)) {
            int snippetColor = getFontColor(mRead ? SNIPPET_TEXT_COLOR_READ
                    : SNIPPET_TEXT_COLOR_UNREAD);
            mText.setSpan(new ForegroundColorSpan(snippetColor), snippetStart, mText.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
    }

    private void calculateDrawingData() {
        sDefaultPaint.setTextSize(mCoordinates.subjectFontSize);
        calculateSubjectText();
        mSubjectLayout = new StaticLayout(mText, sDefaultPaint,
                mCoordinates.subjectWidth, Alignment.ALIGN_NORMAL, 1, 0, false /* includePad */);
        if (mCoordinates.subjectLineCount < mSubjectLayout.getLineCount()) {
            // TODO: ellipsize.
            int end = mSubjectLayout.getLineEnd(mCoordinates.subjectLineCount - 1);
            mSubjectLayout = new StaticLayout(mText.subSequence(0, end),
                    sDefaultPaint, mCoordinates.subjectWidth, Alignment.ALIGN_NORMAL, 1, 0, true);
        }

        // Now, format the sender for its width
        TextPaint senderPaint = mRead ? sDefaultPaint : sBoldPaint;
        // And get the ellipsized string for the calculated width
        if (TextUtils.isEmpty(mSender)) {
            mFormattedSender = """";
        } else {
            int senderWidth = mCoordinates.sendersWidth;
            senderPaint.setTextSize(mCoordinates.sendersFontSize);
            senderPaint.setColor(getFontColor(mRead ? SENDERS_TEXT_COLOR_READ
                    : SENDERS_TEXT_COLOR_UNREAD));
            mFormattedSender = TextUtils.ellipsize(mSender, senderPaint, senderWidth,
                    TruncateAt.END);
        }
    }
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (widthMeasureSpec != 0 || mViewWidth == 0) {
            mViewWidth = MeasureSpec.getSize(widthMeasureSpec);
            int mode = getViewMode(mViewWidth);
            if (mode != mMode) {
                mMode = mode;
            }
            mViewHeight = measureHeight(heightMeasureSpec, mMode);
        }
        setMeasuredDimension(mViewWidth, mViewHeight);
    }

    /**
     * Determine the height of this view
     *
     * @param measureSpec A measureSpec packed into an int
     * @param mode The current mode of this view
     * @return The height of the view, honoring constraints from measureSpec
     */
    private int measureHeight(int measureSpec, int mode) {
        int result = 0;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize = MeasureSpec.getSize(measureSpec);

        if (specMode == MeasureSpec.EXACTLY) {
            // We were told how big to be
            result = specSize;
        } else {
            // Measure the text
            if (mMode == MODE_WIDE) {
                result = sItemHeightWide;
            } else {
                result = sItemHeightNormal;
            }
            if (specMode == MeasureSpec.AT_MOST) {
                // Respect AT_MOST value if that was what is called for by
                // measureSpec
                result = Math.min(result, specSize);
            }
        }
        return result;
    }

    @Override
    public void draw(Canvas canvas) {
        // Update the background, before View.draw() draws it.
        setSelected(mAdapter.isSelected(this));
        updateBackground();
        super.draw(canvas);
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);

        mCoordinates = MessageListItemCoordinates.forWidth(mContext, mViewWidth);
        calculateDrawingData();
    }

    private int getFontColor(int defaultColor) {
        return isActivated() ? ACTIVATED_TEXT_COLOR : defaultColor;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        // Draw the color chip indicating the mailbox this belongs to
        if (mColorChipPaint != null) {
            canvas.drawRect(
                    mCoordinates.chipX, mCoordinates.chipY,
                    mCoordinates.chipX + mCoordinates.chipWidth,
                    mCoordinates.chipY + mCoordinates.chipHeight,
                    mColorChipPaint);
        }

        // Draw the checkbox
        canvas.drawBitmap(mAdapter.isSelected(this) ? sSelectedIconOn : sSelectedIconOff,
                mCoordinates.checkmarkX, mCoordinates.checkmarkY, null);

        // Draw the sender name
        Paint senderPaint = mRead ? sDefaultPaint : sBoldPaint;
        senderPaint.setColor(getFontColor(mRead ? SENDERS_TEXT_COLOR_READ
                : SENDERS_TEXT_COLOR_UNREAD));
        senderPaint.setTextSize(mCoordinates.sendersFontSize);
        canvas.drawText(mFormattedSender, 0, mFormattedSender.length(),
                mCoordinates.sendersX, mCoordinates.sendersY - mCoordinates.sendersAscent,
                senderPaint);

        // Draw the reply state. Draw nothing if neither replied nor forwarded.
        if (mHasBeenRepliedTo && mHasBeenForwarded) {
            canvas.drawBitmap(sStateRepliedAndForwarded,
                    mCoordinates.stateX, mCoordinates.stateY, null);
        } else if (mHasBeenRepliedTo) {
            canvas.drawBitmap(sStateReplied,
                    mCoordinates.stateX, mCoordinates.stateY, null);
        } else if (mHasBeenForwarded) {
            canvas.drawBitmap(sStateForwarded,
                    mCoordinates.stateX, mCoordinates.stateY, null);
        }

        // Subject and snippet.
        sDefaultPaint.setTextSize(mCoordinates.subjectFontSize);
        canvas.save();
        canvas.translate(
                mCoordinates.subjectX,
                mCoordinates.subjectY);
        mSubjectLayout.draw(canvas);
        canvas.restore();

        // Draw the date
        sDatePaint.setTextSize(mCoordinates.dateFontSize);
        sDatePaint.setColor(mRead ? DATE_TEXT_COLOR_READ : DATE_TEXT_COLOR_UNREAD);
        int dateX = mCoordinates.dateXEnd
                - (int) sDatePaint.measureText(mFormattedDate, 0, mFormattedDate.length());

        canvas.drawText(mFormattedDate, 0, mFormattedDate.length(),
                dateX, mCoordinates.dateY - mCoordinates.dateAscent, sDatePaint);

        // Draw the favorite icon
        canvas.drawBitmap(mIsFavorite ? sFavoriteIconOn : sFavoriteIconOff,
                mCoordinates.starX, mCoordinates.starY, null);

        // TODO: deal with the icon layouts better from the coordinate class so that this logic
        // doesn't have to exist.
        // Draw the attachment and invite icons, if necessary.
        int iconsLeft = dateX - sBadgeMargin;
        if (mHasAttachment) {
            iconsLeft = iconsLeft - sAttachmentIcon.getWidth();
            canvas.drawBitmap(sAttachmentIcon, iconsLeft, mCoordinates.paperclipY, null);
        }
        if (mHasInvite) {
            iconsLeft -= sInviteIcon.getWidth();
            canvas.drawBitmap(sInviteIcon, iconsLeft, mCoordinates.paperclipY, null);
        }

    }

    /**
     * Called by the adapter at bindView() time
     *
     * @param adapter the adapter that creates this view
     * @param layout If this is a three pane implementation, the
     *            ThreePaneLayout. Otherwise, null.
     */
    public void bindViewInit(MessagesAdapter adapter, ThreePaneLayout layout) {
        mLayout = layout;
        mAdapter = adapter;
        requestLayout();
    }

    private static final int TOUCH_SLOP = 24;
    private static int sScaledTouchSlop = -1;

    private void initializeSlop(Context context) {
        if (sScaledTouchSlop == -1) {
            final Resources res = context.getResources();
            final Configuration config = res.getConfiguration();
            final float density = res.getDisplayMetrics().density;
            final float sizeAndDensity;
            if (config.isLayoutSizeAtLeast(Configuration.SCREENLAYOUT_SIZE_XLARGE)) {
                sizeAndDensity = density * 1.5f;
            } else {
                sizeAndDensity = density;
            }
            sScaledTouchSlop = (int) (sizeAndDensity * TOUCH_SLOP + 0.5f);
        }
    }

    /**
     * Overriding this method allows us to ""catch"" clicks in the checkbox or star
     * and process them accordingly.
     */
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        initializeSlop(getContext());

        boolean handled = false;
        int touchX = (int) event.getX();
        int checkRight = mCoordinates.checkmarkX
                + mCoordinates.checkmarkWidthIncludingMargins + sScaledTouchSlop;
        int starLeft = mCoordinates.starX - sScaledTouchSlop;

        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                if (touchX < checkRight || touchX > starLeft) {
                    mDownEvent = true;
                    if ((touchX < checkRight) || (touchX > starLeft)) {
                        handled = true;
                    }
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                mDownEvent = false;
                break;

            case MotionEvent.ACTION_UP:
                if (mDownEvent) {
                    if (touchX < checkRight) {
                        mAdapter.toggleSelected(this);
                        handled = true;
                    } else if (touchX > starLeft) {
                        mIsFavorite = !mIsFavorite;
                        mAdapter.updateFavorite(this, mIsFavorite);
                        handled = true;
                    }
                }
                break;
        }

        if (handled) {
            invalidate();
        } else {
            handled = super.onTouchEvent(event);
        }

        return handled;
    }

    @Override
    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
        event.setClassName(getClass().getName());
        event.setPackageName(getContext().getPackageName());
        event.setEnabled(true);
        event.setContentDescription(getContentDescription());
        return true;
    }

    /**
     * Sets the content description for this item, used for accessibility.
     */
    private void populateContentDescription() {
        if (!TextUtils.isEmpty(mSubject)) {
            setContentDescription(sSubjectDescription + mSubject);
        } else {
            setContentDescription(sSubjectEmptyDescription);
        }
    }
}
",True,267,0,0,11,56,3,4,L6
41,com.android.email.activity.AccountSelectorAdapter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.Context;
import android.content.Loader;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.CursorAdapter;
import android.widget.TextView;

import com.android.email.FolderProperties;
import com.android.email.R;
import com.android.email.ResourceHelper;
import com.android.email.data.ClosingMatrixCursor;
import com.android.email.data.ThrottlingCursorLoader;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;

import java.util.ArrayList;
import java.util.Collection;

/**
 * Account selector spinner.
 *
 * TODO Test it!
 */
public class AccountSelectorAdapter extends CursorAdapter {
    /** meta data column for an message count (unread or total, depending on row) */
    private static final String MESSAGE_COUNT = ""unreadCount"";

    /** meta data column for the row type; used for display purposes */
    private static final String ROW_TYPE = ""rowType"";

    /** meta data position of the currently selected account in the drop-down list */
    private static final String ACCOUNT_POSITION = ""accountPosition"";

    /** ""account id"" virtual column name for the matrix cursor */
    private static final String ACCOUNT_ID = ""accountId"";

    private static final int ROW_TYPE_HEADER = AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER;
    @SuppressWarnings(""unused"")
    private static final int ROW_TYPE_MAILBOX = 0;
    private static final int ROW_TYPE_ACCOUNT = 1;
    private static final int ITEM_VIEW_TYPE_ACCOUNT = 0;
    static final int UNKNOWN_POSITION = -1;
    /** Projection for account database query */
    private static final String[] ACCOUNT_PROJECTION = new String[] {
        EmailContent.RECORD_ID,
        Account.DISPLAY_NAME,
        Account.EMAIL_ADDRESS,
    };
    /**
     * Projection used for the selector display; we add meta data that doesn't exist in the
     * account database, so, this should be a super-set of {@link #ACCOUNT_PROJECTION}.
     */
    private static final String[] ADAPTER_PROJECTION = new String[] {
        ROW_TYPE,
        EmailContent.RECORD_ID,
        Account.DISPLAY_NAME,
        Account.EMAIL_ADDRESS,
        MESSAGE_COUNT,
        ACCOUNT_POSITION, // TODO Probably we don't really need this
        ACCOUNT_ID,
    };

    /** Sort order.  Show the default account first. */
    private static final String ORDER_BY = Account.IS_DEFAULT + "" desc, "" + Account.RECORD_ID;

    @SuppressWarnings(""hiding"")
    private final Context mContext;
    private final LayoutInflater mInflater;
    private final ResourceHelper mResourceHelper;

    /**
     * Returns a loader that can populate the account spinner.
     * @param context a context
     * @param accountId the ID of the currently viewed account
     */
    public static Loader<Cursor> createLoader(Context context, long accountId, long mailboxId) {
        return new AccountsLoader(context, accountId, mailboxId, UiUtilities.useTwoPane(context));
    }

    public AccountSelectorAdapter(Context context) {
        super(context, null, 0 /* no auto-requery */);
        mContext = context;
        mInflater = LayoutInflater.from(context);
        mResourceHelper = ResourceHelper.getInstance(context);
    }

    /**
     * {@inheritDoc}
     *
     * The account selector view can contain one of four types of row data:
     * <ol>
     * <li>headers</li>
     * <li>accounts</li>
     * <li>recent mailboxes</li>
     * <li>""show all folders""</li>
     * </ol>
     * Headers are handled separately as they have a unique layout and cannot be interacted with.
     * Accounts, recent mailboxes and ""show all folders"" all have the same interaction model and
     * share a very similar layout. The single difference is that both accounts and recent
     * mailboxes display an unread count; whereas ""show all folders"" does not. To determine
     * if a particular row is ""show all folders"" verify that a) it's not an account row and
     * b) it's ID is {@link Mailbox#NO_MAILBOX}.
     *
     * TODO Use recycled views.  ({@link #getViewTypeCount} and {@link #getItemViewType})
     */
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        Cursor c = getCursor();
        c.moveToPosition(position);
        View view;
        if (c.getInt(c.getColumnIndex(ROW_TYPE)) == ROW_TYPE_HEADER) {
            view = mInflater.inflate(R.layout.action_bar_spinner_dropdown_header, parent, false);
            final TextView displayNameView = (TextView) view.findViewById(R.id.display_name);
            final String displayName = getDisplayName(c);
            displayNameView.setText(displayName);
        } else {
            view = mInflater.inflate(R.layout.action_bar_spinner_dropdown, parent, false);
            final TextView displayNameView = (TextView) view.findViewById(R.id.display_name);
            final TextView emailAddressView = (TextView) view.findViewById(R.id.email_address);
            final TextView unreadCountView = (TextView) view.findViewById(R.id.unread_count);
            final View chipView = view.findViewById(R.id.color_chip);

            final String displayName = getDisplayName(c);
            final String emailAddress = getAccountEmailAddress(c);

            displayNameView.setText(displayName);

            // Show the email address only when it's different from the display name.
            boolean isAccount = isAccountItem(c);
            if (displayName.equals(emailAddress) || !isAccount) {
                emailAddressView.setVisibility(View.GONE);
            } else {
                emailAddressView.setVisibility(View.VISIBLE);
                emailAddressView.setText(emailAddress);
            }

            long id = getId(c);
            if (isAccount || id != Mailbox.NO_MAILBOX) {
                unreadCountView.setVisibility(View.VISIBLE);
                unreadCountView.setText(UiUtilities.getMessageCountForUi(mContext,
                        getAccountUnreadCount(c), true));

                // If we're on a combined account, show the color chip indicators for all real
                // accounts so it can be used as a legend.
                boolean isCombinedActive =
                        ((CursorWithExtras) c).getAccountId() == Account.ACCOUNT_ID_COMBINED_VIEW;

                if (isCombinedActive && Account.isNormalAccount(id)) {
                    chipView.setBackgroundColor(mResourceHelper.getAccountColor(id));
                    chipView.setVisibility(View.VISIBLE);
                } else {
                    chipView.setVisibility(View.GONE);
                }
            } else {
                unreadCountView.setVisibility(View.INVISIBLE);
                chipView.setVisibility(View.GONE);
            }

        }
        return view;
    }

    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
        return null; // we don't reuse views.  This method never gets called.
    }

    @Override
    public void bindView(View view, Context context, Cursor cursor) {
        // we don't reuse views.  This method never gets called.
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }

    @Override
    public int getItemViewType(int position) {
        Cursor c = getCursor();
        c.moveToPosition(position);
        return c.getLong(c.getColumnIndex(ROW_TYPE)) == ROW_TYPE_HEADER
                ? AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER
                : ITEM_VIEW_TYPE_ACCOUNT;
    }

    @Override
    public boolean isEnabled(int position) {
        return (getItemViewType(position) != AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER);
    }

    public boolean isAccountItem(int position) {
        Cursor c = getCursor();
        c.moveToPosition(position);
        return isAccountItem(c);
    }

    public boolean isAccountItem(Cursor c) {
        return (c.getLong(c.getColumnIndex(ROW_TYPE)) == ROW_TYPE_ACCOUNT);
    }

    public boolean isMailboxItem(int position) {
        Cursor c = getCursor();
        c.moveToPosition(position);
        return (c.getLong(c.getColumnIndex(ROW_TYPE)) == ROW_TYPE_MAILBOX);
    }

    private int getAccountUnreadCount(Cursor c) {
        return getMessageCount(c);
    }

    /**
     * Returns the account/mailbox ID extracted from the given cursor.
     */
    private static long getId(Cursor c) {
        return c.getLong(c.getColumnIndex(EmailContent.RECORD_ID));
    }

    /**
     * @return ID of the account / mailbox for a row
     */
    public long getId(int position) {
        final Cursor c = getCursor();
        return c.moveToPosition(position) ? getId(c) : Account.NO_ACCOUNT;
    }

    /**
     * @return ID of the account for a row
     */
    public long getAccountId(int position) {
        final Cursor c = getCursor();
        return c.moveToPosition(position)
                ? c.getLong(c.getColumnIndex(ACCOUNT_ID))
                : Account.NO_ACCOUNT;
    }

    /** Returns the account name extracted from the given cursor. */
    static String getDisplayName(Cursor cursor) {
        return cursor.getString(cursor.getColumnIndex(Account.DISPLAY_NAME));
    }

    /** Returns the email address extracted from the given cursor. */
    private static String getAccountEmailAddress(Cursor cursor) {
        return cursor.getString(cursor.getColumnIndex(Account.EMAIL_ADDRESS));
    }

    /**
     * Returns the message count (unread or total, depending on row) extracted from the given
     * cursor.
     */
    private static int getMessageCount(Cursor cursor) {
        return cursor.getInt(cursor.getColumnIndex(MESSAGE_COUNT));
    }

    private static String sCombinedViewDisplayName;
    private static String getCombinedViewDisplayName(Context c) {
        if (sCombinedViewDisplayName == null) {
            sCombinedViewDisplayName = c.getResources().getString(
                    R.string.mailbox_list_account_selector_combined_view);
        }
        return sCombinedViewDisplayName;
    }

    /**
     * Load the account list.  The resulting cursor contains
     * - Account info
     * - # of unread messages in inbox
     * - The ""Combined view"" row if there's more than one account.
     */
    @VisibleForTesting
    static class AccountsLoader extends ThrottlingCursorLoader {
        private final Context mContext;
        private final long mAccountId;
        private final long mMailboxId;
        private final boolean mUseTwoPane; // Injectable for test
        private final FolderProperties mFolderProperties;

        @VisibleForTesting
        AccountsLoader(Context context, long accountId, long mailboxId, boolean useTwoPane) {
            // Super class loads a regular account cursor, but we replace it in loadInBackground().
            super(context, Account.CONTENT_URI, ACCOUNT_PROJECTION, null, null,
                    ORDER_BY);
            mContext = context;
            mAccountId = accountId;
            mMailboxId = mailboxId;
            mFolderProperties = FolderProperties.getInstance(mContext);
            mUseTwoPane = useTwoPane;
        }

        @Override
        public Cursor loadInBackground() {
            final Cursor accountsCursor = super.loadInBackground();
            // Use ClosingMatrixCursor so that accountsCursor gets closed too when it's closed.
            final CursorWithExtras resultCursor
                    = new CursorWithExtras(ADAPTER_PROJECTION, accountsCursor);
            final int accountPosition = addAccountsToCursor(resultCursor, accountsCursor);
            addMailboxesToCursor(resultCursor, accountPosition);

            resultCursor.setAccountMailboxInfo(getContext(), mAccountId, mMailboxId);
            return resultCursor;
        }

        /** Adds the account list [with extra meta data] to the given matrix cursor */
        private int addAccountsToCursor(CursorWithExtras matrixCursor, Cursor accountCursor) {
            int accountPosition = UNKNOWN_POSITION;
            accountCursor.moveToPosition(-1);

            matrixCursor.mAccountCount = accountCursor.getCount();
            int totalUnread = 0;
            while (accountCursor.moveToNext()) {
                // Add account, with its unread count.
                final long accountId = accountCursor.getLong(0);
                final int unread = Mailbox.getUnreadCountByAccountAndMailboxType(
                        mContext, accountId, Mailbox.TYPE_INBOX);
                final String name = getDisplayName(accountCursor);
                final String emailAddress = getAccountEmailAddress(accountCursor);
                addRow(matrixCursor, ROW_TYPE_ACCOUNT, accountId, name, emailAddress, unread,
                    UNKNOWN_POSITION, accountId);
                totalUnread += unread;
                if (accountId == mAccountId) {
                    accountPosition = accountCursor.getPosition();
                }
            }
            // Add ""combined view"" if more than one account exists
            final int countAccounts = accountCursor.getCount();
            if (countAccounts > 1) {
                final String accountCount = mContext.getResources().getQuantityString(
                        R.plurals.number_of_accounts, countAccounts, countAccounts);
                addRow(matrixCursor, ROW_TYPE_ACCOUNT, Account.ACCOUNT_ID_COMBINED_VIEW,
                        getCombinedViewDisplayName(mContext),
                        accountCount, totalUnread, UNKNOWN_POSITION,
                        Account.ACCOUNT_ID_COMBINED_VIEW);

                // Increment the account count for the combined account.
                matrixCursor.mAccountCount++;
            }
            return accountPosition;
        }

        /**
         * Adds the recent mailbox list / ""show all folders"" to the given cursor.
         *
         * @param matrixCursor the cursor to add the list to
         * @param accountPosition the cursor position of the currently selected account
         */
        private void addMailboxesToCursor(CursorWithExtras matrixCursor, int accountPosition) {
            if (mAccountId == Account.NO_ACCOUNT) {
                return; // Account not selected
            }
            if (mAccountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                if (!mUseTwoPane) {
                    // TODO We may want a header for this to separate it from the account list
                    addShowAllFoldersRow(matrixCursor, accountPosition);
                }
                return;
            }
            String emailAddress = null;
            if (accountPosition != UNKNOWN_POSITION) {
                matrixCursor.moveToPosition(accountPosition);
                emailAddress =
                        matrixCursor.getString(matrixCursor.getColumnIndex(Account.EMAIL_ADDRESS));
            }
            RecentMailboxManager mailboxManager = RecentMailboxManager.getInstance(mContext);
            ArrayList<Long> recentMailboxes = null;
            if (!mUseTwoPane) {
                // Do not display recent mailboxes in the account spinner for the two pane view
                recentMailboxes = mailboxManager.getMostRecent(mAccountId, mUseTwoPane);
            }
            final int recentCount = (recentMailboxes == null) ? 0 : recentMailboxes.size();
            matrixCursor.mRecentCount = recentCount;

            if (!mUseTwoPane) {
                // ""Recent mailboxes"" header
                addHeaderRow(matrixCursor, mContext.getString(
                        R.string.mailbox_list_account_selector_mailbox_header_fmt, emailAddress));
            }

            if (recentCount > 0) {
                addMailboxRows(matrixCursor, accountPosition, recentMailboxes);
            }

            if (!mUseTwoPane) {
                addShowAllFoldersRow(matrixCursor, accountPosition);
            }
        }

        private void addShowAllFoldersRow(CursorWithExtras matrixCursor, int accountPosition) {
            matrixCursor.mHasShowAllFolders = true;
            String name = mContext.getString(
                    R.string.mailbox_list_account_selector_show_all_folders);
            addRow(matrixCursor, ROW_TYPE_MAILBOX, Mailbox.NO_MAILBOX, name, null, 0,
                    accountPosition, mAccountId);
        }


        private static final String[] RECENT_MAILBOX_INFO_PROJECTION = new String[] {
            MailboxColumns.ID, MailboxColumns.DISPLAY_NAME, MailboxColumns.TYPE,
            MailboxColumns.UNREAD_COUNT, MailboxColumns.MESSAGE_COUNT
        };

        private void addMailboxRows(MatrixCursor matrixCursor, int accountPosition,
                Collection<Long> mailboxIds) {
            Cursor c = mContext.getContentResolver().query(
                    Mailbox.CONTENT_URI, RECENT_MAILBOX_INFO_PROJECTION,
                    Utility.buildInSelection(MailboxColumns.ID, mailboxIds), null,
                    RecentMailboxManager.RECENT_MAILBOXES_SORT_ORDER);
            try {
                c.moveToPosition(-1);
                while (c.moveToNext()) {
                    addRow(matrixCursor, ROW_TYPE_MAILBOX,
                            c.getLong(c.getColumnIndex(MailboxColumns.ID)),
                            mFolderProperties.getDisplayName(c), null,
                            mFolderProperties.getMessageCount(c), accountPosition, mAccountId);
                }
            } finally {
                c.close();
            }
        }

        private void addHeaderRow(MatrixCursor cursor, String name) {
            addRow(cursor, ROW_TYPE_HEADER, 0L, name, null, 0, UNKNOWN_POSITION,
                    Account.NO_ACCOUNT);
        }

        /** Adds a row to the given cursor */
        private void addRow(MatrixCursor cursor, int rowType, long id, String name,
                String emailAddress, int messageCount, int listPosition, long accountId) {
            cursor.newRow()
                .add(rowType)
                .add(id)
                .add(name)
                .add(emailAddress)
                .add(messageCount)
                .add(listPosition)
                .add(accountId);
        }
    }

    /** Cursor with some extra meta data. */
    static class CursorWithExtras extends ClosingMatrixCursor {

        /** Number of account elements, including the combined account row. */
        private int mAccountCount;
        /** Number of recent mailbox elements */
        private int mRecentCount;
        private boolean mHasShowAllFolders;

        private boolean mAccountExists;

        /**
         * Account ID that's loaded.
         */
        private long mAccountId;
        private String mAccountDisplayName;

        /**
         * Mailbox ID that's loaded.
         */
        private long mMailboxId;
        private String mMailboxDisplayName;
        private int mMailboxMessageCount;

        @VisibleForTesting
        CursorWithExtras(String[] columnNames, Cursor innerCursor) {
            super(columnNames, innerCursor);
        }

        private static final String[] ACCOUNT_INFO_PROJECTION = new String[] {
            AccountColumns.DISPLAY_NAME,
        };
        private static final String[] MAILBOX_INFO_PROJECTION = new String[] {
            MailboxColumns.ID, MailboxColumns.DISPLAY_NAME, MailboxColumns.TYPE,
            MailboxColumns.UNREAD_COUNT, MailboxColumns.MESSAGE_COUNT
        };

        /**
         * Set the current account/mailbox info.
         */
        @VisibleForTesting
        void setAccountMailboxInfo(Context context, long accountId, long mailboxId) {
            mAccountId = accountId;
            mMailboxId = mailboxId;

            // Get account info
            if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                // We need to treat ACCOUNT_ID_COMBINED_VIEW specially...
                mAccountExists = true;
                mAccountDisplayName = getCombinedViewDisplayName(context);
                if (mailboxId != Mailbox.NO_MAILBOX) {
                    setCombinedMailboxInfo(context, mailboxId);
                }
                return;
            }

            mAccountDisplayName = Utility.getFirstRowString(context,
                    ContentUris.withAppendedId(Account.CONTENT_URI, accountId),
                    ACCOUNT_INFO_PROJECTION, null, null, null, 0, null);
            if (mAccountDisplayName == null) {
                // Account gone!
                mAccountExists = false;
                return;
            }
            mAccountExists = true;

            // If mailbox not specified, done.
            if (mMailboxId == Mailbox.NO_MAILBOX) {
                return;
            }
            // Combined mailbox?
            // Unfortunately this can happen even when account != ACCOUNT_ID_COMBINED_VIEW,
            // when you open ""starred"" on 2-pane on non-combined view.
            if (mMailboxId < 0) {
                setCombinedMailboxInfo(context, mailboxId);
                return;
            }

            // Get mailbox info
            final ContentResolver r = context.getContentResolver();
            final Cursor mailboxCursor = r.query(
                    ContentUris.withAppendedId(Mailbox.CONTENT_URI, mailboxId),
                    MAILBOX_INFO_PROJECTION, null, null, null);
            try {
                if (mailboxCursor.moveToFirst()) {
                    final FolderProperties fp = FolderProperties.getInstance(context);
                    mMailboxDisplayName = fp.getDisplayName(mailboxCursor);
                    mMailboxMessageCount = fp.getMessageCount(mailboxCursor);
                }
            } finally {
                mailboxCursor.close();
            }
        }

        private void setCombinedMailboxInfo(Context context, long mailboxId) {
            Preconditions.checkState(mailboxId < -1, ""Not combined mailbox"");
            mMailboxDisplayName = FolderProperties.getInstance(context)
                    .getCombinedMailboxName(mMailboxId);

            mMailboxMessageCount = FolderProperties.getMessageCountForCombinedMailbox(
                    context, mailboxId);
        }

        /**
         * Returns the cursor position of the item with the given ID. Or {@link #UNKNOWN_POSITION}
         * if the given ID does not exist.
         */
        int getPosition(long id) {
            moveToPosition(-1);
            while(moveToNext()) {
                if (id == getId(this)) {
                    return getPosition();
                }
            }
            return UNKNOWN_POSITION;
        }

        public int getAccountCount() {
            return mAccountCount;
        }

        @VisibleForTesting
        public int getRecentMailboxCount() {
            return mRecentCount;
        }

        /**
         * @return true if the cursor has more than one selectable item so we should enable the
         *     spinner.
         */
        public boolean shouldEnableSpinner() {
            return mHasShowAllFolders || (mAccountCount + mRecentCount > 1);
        }

        public long getAccountId() {
            return mAccountId;
        }

        public String getAccountDisplayName() {
            return mAccountDisplayName;
        }

        @VisibleForTesting
        public long getMailboxId() {
            return mMailboxId;
        }

        public String getMailboxDisplayName() {
            return mMailboxDisplayName;
        }

        public int getMailboxMessageCount() {
            return mMailboxMessageCount;
        }

        /**
         * @return {@code true} if the specified accuont exists.
         */
        public boolean accountExists() {
            return mAccountExists;
        }
    }
}
",True,268,1,1,11,46,2,10,L6
42,com.android.email.activity.NfcHandler.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.nfc.NdefMessage;
import android.nfc.NdefRecord;
import android.nfc.NfcAdapter;
import android.nfc.NfcEvent;
import android.text.TextUtils;

import com.android.emailcommon.provider.Account;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

/**
  * This class implements sharing the e-mail address of the
  * active account to another device using NFC. NFC sharing is only
  * enabled when the activity is in the foreground and resumed.
  * When an NFC link is established, {@link #createMessage}
  * will be called to create the data to be sent over the link,
  * which is a vCard in this case.
  */
public class NfcHandler implements NfcAdapter.CreateNdefMessageCallback {
    final UIControllerBase mUiController;
    final Activity mActivity;

    String mCurrentEmail;

    public static NfcHandler register(UIControllerBase controller, Activity activity) {
        NfcAdapter adapter = NfcAdapter.getDefaultAdapter(activity);
        if (adapter == null) {
            return null;  // NFC not available on this device
        }
        NfcHandler nfcHandler = new NfcHandler(controller, activity);
        adapter.setNdefPushMessageCallback(nfcHandler, activity);
        return nfcHandler;
    }

    public NfcHandler(UIControllerBase controller, Activity activity) {
        mUiController = controller;
        mActivity = activity;
    }

    public void onAccountChanged() {
        if (mUiController.isActualAccountSelected()) {
            final long accountId = mUiController.getActualAccountId();
            final Account account = Account.restoreAccountWithId(mActivity, accountId);
            if (account == null) return;
            mCurrentEmail = account.mEmailAddress;
        } else {
            mCurrentEmail = null;
        }
    }

    private static NdefMessage buildMailtoNdef(String address) {
        if (TextUtils.isEmpty(address)) {
            return null;
        }
        byte[] accountBytes;
        try {
            accountBytes = URLEncoder.encode(address, ""UTF-8"")
                    .getBytes(""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            return null;
        }
        byte[] recordBytes = new byte[accountBytes.length + 1];
        recordBytes[0] = 0x06; // NDEF mailto: prefix
        System.arraycopy(accountBytes, 0, recordBytes, 1, accountBytes.length);
        NdefRecord mailto = new NdefRecord(NdefRecord.TNF_WELL_KNOWN, NdefRecord.RTD_URI,
                new byte[0], recordBytes);
        return new NdefMessage(new NdefRecord[] { mailto });
    }

    @Override
    public NdefMessage createNdefMessage(NfcEvent event) {
        if (mCurrentEmail != null) {
            return buildMailtoNdef(mCurrentEmail);
        } else {
            return null;
        }
    }
}
",False,267,0,0,12,60,1,2,L6
43,com.android.email.activity.ShortcutPickerFragment.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;

import android.app.Activity;
import android.app.FragmentTransaction;
import android.app.ListFragment;
import android.app.LoaderManager.LoaderCallbacks;
import android.content.ContentValues;
import android.content.Context;
import android.content.CursorLoader;
import android.content.Loader;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.database.MatrixCursor.RowBuilder;
import android.database.MergeCursor;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.SimpleCursorAdapter;

/**
 * Fragment containing a list of accounts to show during shortcut creation.
 * <p>
 * NOTE: In order to receive callbacks, the activity containing this fragment must implement
 * the {@link PickerCallback} interface.
 */
public abstract class ShortcutPickerFragment extends ListFragment
        implements OnItemClickListener, LoaderCallbacks<Cursor> {
    /** Callback methods. Enclosing activities must implement to receive fragment notifications. */
    public static interface PickerCallback {
        /** Builds a mailbox filter for the given account. See MailboxShortcutPickerFragment. */
        public Integer buildFilter(Account account);
        /** Invoked when an account and mailbox have been selected. */
        public void onSelected(Account account, long mailboxId);
        /** Required data is missing; either the account and/or mailbox */
        public void onMissingData(boolean missingAccount, boolean missingMailbox);
    }

    /** A no-op callback */
    private final PickerCallback EMPTY_CALLBACK = new PickerCallback() {
        @Override public Integer buildFilter(Account account) { return null; }
        @Override public void onSelected(Account account, long mailboxId){ getActivity().finish(); }
        @Override public void onMissingData(boolean missingAccount, boolean missingMailbox) { }
    };
    private final static int LOADER_ID = 0;
    private final static int[] TO_VIEWS = new int[] {
        android.R.id.text1,
    };

    PickerCallback mCallback = EMPTY_CALLBACK;
    /** Cursor adapter that provides either the account or mailbox list */
    private SimpleCursorAdapter mAdapter;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        if (activity instanceof PickerCallback) {
            mCallback = (PickerCallback) activity;
        }
        final String[] fromColumns = getFromColumns();
        mAdapter = new SimpleCursorAdapter(activity,
            android.R.layout.simple_expandable_list_item_1, null, fromColumns, TO_VIEWS, 0);
        setListAdapter(mAdapter);

        getLoaderManager().initLoader(LOADER_ID, null, this);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        ListView listView = getListView();
        listView.setOnItemClickListener(this);
        listView.setItemsCanFocus(false);
    }

    @Override
    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
        mAdapter.swapCursor(data);
    }

    @Override
    public void onLoaderReset(Loader<Cursor> loader) {
        mAdapter.swapCursor(null);
    }

    /** Returns the cursor columns to map into list */
    abstract String[] getFromColumns();

    // TODO if we add meta-accounts to the database, remove this class entirely
    private static final class AccountPickerLoader extends CursorLoader {
        public AccountPickerLoader(Context context, Uri uri, String[] projection, String selection,
                String[] selectionArgs, String sortOrder) {
            super(context, uri, projection, selection, selectionArgs, sortOrder);
        }

        @Override
        public Cursor loadInBackground() {
            Cursor parentCursor = super.loadInBackground();
            int cursorCount = parentCursor.getCount();
            final Cursor returnCursor;

            if (cursorCount > 1) {
                // Only add ""All accounts"" if there is more than 1 account defined
                MatrixCursor allAccountCursor = new MatrixCursor(getProjection());
                addCombinedAccountRow(allAccountCursor, cursorCount);
                returnCursor = new MergeCursor(new Cursor[] { allAccountCursor, parentCursor });
            } else {
                returnCursor = parentCursor;
            }
            return returnCursor;
        }

        /** Adds a row for ""All Accounts"" into the given cursor */
        private void addCombinedAccountRow(MatrixCursor cursor, int accountCount) {
            Context context = getContext();
            Account account = new Account();
            account.mId = Account.ACCOUNT_ID_COMBINED_VIEW;
            Resources res = context.getResources();
            String countString = res.getQuantityString(R.plurals.picker_combined_view_account_count,
                    accountCount, accountCount);
            account.mDisplayName = res.getString(R.string.picker_combined_view_fmt, countString);
            ContentValues values = account.toContentValues();
            RowBuilder row = cursor.newRow();
            for (String rowName : cursor.getColumnNames()) {
                // special case some of the rows ...
                if (AccountColumns.ID.equals(rowName)) {
                    row.add(Account.ACCOUNT_ID_COMBINED_VIEW);
                    continue;
                } else if (AccountColumns.IS_DEFAULT.equals(rowName)) {
                    row.add(0);
                    continue;
                }
                row.add(values.get(rowName));
            }
        }
    }

    /** Account picker */
    public static class AccountShortcutPickerFragment extends ShortcutPickerFragment {
        private volatile Boolean mLoadFinished = new Boolean(false);
        private final static String[] ACCOUNT_FROM_COLUMNS = new String[] {
            AccountColumns.DISPLAY_NAME,
        };

        @Override
        public void onActivityCreated(Bundle savedInstanceState) {
            super.onActivityCreated(savedInstanceState);
            getActivity().setTitle(R.string.account_shortcut_picker_title);
            if (!mLoadFinished) {
                getActivity().setVisible(false);
            }
        }

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Cursor cursor = (Cursor) parent.getItemAtPosition(position);
            selectAccountCursor(cursor, true);
        }

        @Override
        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
            Context context = getActivity();
            return new AccountPickerLoader(
                context, Account.CONTENT_URI, Account.CONTENT_PROJECTION, null, null, null);
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
            // if there is only one account, auto-select it
            // No accounts; close the dialog
            if (data.getCount() == 0) {
                mCallback.onMissingData(true, false);
                return;
            }
            if (data.getCount() == 1 && data.moveToFirst()) {
                selectAccountCursor(data, false);
                return;
            }
            super.onLoadFinished(loader, data);
            mLoadFinished = true;
            getActivity().setVisible(true);
        }

        @Override
        String[] getFromColumns() {
            return ACCOUNT_FROM_COLUMNS;
        }

        /** Selects the account specified by the given cursor */
        private void selectAccountCursor(Cursor cursor, boolean allowBack) {
            Account account = new Account();
            account.restore(cursor);
            ShortcutPickerFragment fragment = MailboxShortcutPickerFragment.newInstance(
                    getActivity(), account, mCallback.buildFilter(account));
            FragmentTransaction transaction = getFragmentManager().beginTransaction();
            transaction.replace(R.id.shortcut_list, fragment);
            if (allowBack) {
                transaction.addToBackStack(null);
            }
            transaction.commitAllowingStateLoss();
        }
    }

    // TODO if we add meta-mailboxes to the database, remove this class entirely
    private static final class MailboxPickerLoader extends CursorLoader {
        private final long mAccountId;
        private final boolean mAllowUnread;
        public MailboxPickerLoader(Context context, Uri uri, String[] projection, String selection,
                String[] selectionArgs, String sortOrder, long accountId, boolean allowUnread) {
            super(context, uri, projection, selection, selectionArgs, sortOrder);
            mAccountId = accountId;
            mAllowUnread = allowUnread;
        }

        @Override
        public Cursor loadInBackground() {
            MatrixCursor unreadCursor =
                    new MatrixCursor(MailboxShortcutPickerFragment.MATRIX_PROJECTION);
            Context context = getContext();
            if (mAllowUnread) {
                // For the special mailboxes, their ID is < 0. The UI list does not deal with
                // negative values very well, so, add MAX_VALUE to ensure they're positive, but,
                // don't clash with legitimate mailboxes.
                String mailboxName = context.getString(R.string.picker_mailbox_name_all_unread);
                unreadCursor.addRow(
                        new Object[] {
                            Integer.MAX_VALUE + Mailbox.QUERY_ALL_UNREAD,
                            Mailbox.QUERY_ALL_UNREAD,
                            mailboxName,
                        });
            }

            if (mAccountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                // Do something special for the ""combined"" view
                MatrixCursor combinedMailboxesCursor =
                        new MatrixCursor(MailboxShortcutPickerFragment.MATRIX_PROJECTION);
                // For the special mailboxes, their ID is < 0. The UI list does not deal with
                // negative values very well, so, add MAX_VALUE to ensure they're positive, but,
                // don't clash with legitimate mailboxes.
                String mailboxName = context.getString(R.string.picker_mailbox_name_all_inbox);
                combinedMailboxesCursor.addRow(
                        new Object[] {
                            Integer.MAX_VALUE + Mailbox.QUERY_ALL_INBOXES,
                            Mailbox.QUERY_ALL_INBOXES,
                            mailboxName
                        });
                return new MergeCursor(new Cursor[] { combinedMailboxesCursor, unreadCursor });
            }

            // Loading for a regular account; perform a normal load
            return new MergeCursor(new Cursor[] { super.loadInBackground(), unreadCursor });
        }
    }

    /** Mailbox picker */
    public static class MailboxShortcutPickerFragment extends ShortcutPickerFragment {
        /** Allow all mailboxes in the mailbox list */
        public static int FILTER_ALLOW_ALL    = 0;
        /** Only allow an account's INBOX */
        public static int FILTER_INBOX_ONLY   = 1 << 0;
        /** Allow an ""unread"" mailbox; this is not affected by {@link #FILTER_INBOX_ONLY} */
        public static int FILTER_ALLOW_UNREAD = 1 << 1;
        /** Fragment argument to set filter values */
        static final String ARG_FILTER  = ""MailboxShortcutPickerFragment.filter"";
        static final String ARG_ACCOUNT = ""MailboxShortcutPickerFragment.account"";

        private final static String REAL_ID = ""realId"";
        private final static String[] MAILBOX_FROM_COLUMNS = new String[] {
            MailboxColumns.DISPLAY_NAME,
        };
        /** Loader projection used for IMAP & POP3 accounts */
        private final static String[] IMAP_PROJECTION = new String [] {
            MailboxColumns.ID, MailboxColumns.ID + "" as "" + REAL_ID,
            MailboxColumns.SERVER_ID + "" as "" + MailboxColumns.DISPLAY_NAME
        };
        /** Loader projection used for EAS accounts */
        private final static String[] EAS_PROJECTION = new String [] {
            MailboxColumns.ID, MailboxColumns.ID + "" as "" + REAL_ID,
            MailboxColumns.DISPLAY_NAME
        };
        /** Loader projection used for a matrix cursor */
        private final static String[] MATRIX_PROJECTION = new String [] {
            MailboxColumns.ID, REAL_ID, MailboxColumns.DISPLAY_NAME
        };
        // TODO #ALL_MAILBOX_SELECTION is identical to MailboxesAdapter#ALL_MAILBOX_SELECTION;
        // create a common selection. Move this to the Mailbox class?
        /** Selection for all visible mailboxes for an account */
        private final static String ALL_MAILBOX_SELECTION = MailboxColumns.ACCOUNT_KEY + ""=?"" +
                "" AND "" + Mailbox.USER_VISIBLE_MAILBOX_SELECTION;
        /** Selection for just the INBOX of an account */
        private final static String INBOX_ONLY_SELECTION = ALL_MAILBOX_SELECTION +
                    "" AND "" + MailboxColumns.TYPE + "" = "" + Mailbox.TYPE_INBOX;
        private volatile Boolean mLoadFinished = new Boolean(false);
        /** The currently selected account */
        private Account mAccount;
        /** The filter values; default to allow all mailboxes */
        private Integer mFilter;

        /**
         * Builds a mailbox shortcut picker for the given account.
         */
        public static MailboxShortcutPickerFragment newInstance(
                Context context, Account account, Integer filter) {

            MailboxShortcutPickerFragment fragment = new MailboxShortcutPickerFragment();
            Bundle args = new Bundle();
            args.putParcelable(ARG_ACCOUNT, account);
            args.putInt(ARG_FILTER, filter);
            fragment.setArguments(args);
            return fragment;
        }

        /** Returns the mailbox filter */
        int getFilter() {
            if (mFilter == null) {
                mFilter = getArguments().getInt(ARG_FILTER, FILTER_ALLOW_ALL);
            }
            return mFilter;
        }

        @Override
        public void onAttach(Activity activity) {
            // Need to setup the account first thing
            mAccount = getArguments().getParcelable(ARG_ACCOUNT);
            super.onAttach(activity);
        }

        @Override
        public void onActivityCreated(Bundle savedInstanceState) {
            super.onActivityCreated(savedInstanceState);
            getActivity().setTitle(R.string.mailbox_shortcut_picker_title);
            if (!mLoadFinished) {
                getActivity().setVisible(false);
            }
        }

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            Cursor cursor = (Cursor) parent.getItemAtPosition(position);
            long mailboxId = cursor.getLong(cursor.getColumnIndex(REAL_ID));
            mCallback.onSelected(mAccount, mailboxId);
        }

        @Override
        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
            Context context = getActivity();
            // TODO Create a fully-qualified path name for Exchange accounts [code should also work
            //      for MoveMessageToDialog.java]
            HostAuth recvAuth = mAccount.getOrCreateHostAuthRecv(context);
            final String[] projection;
            final String orderBy;
            final String selection;
            if (recvAuth.isEasConnection()) {
                projection = EAS_PROJECTION;
                orderBy = MailboxColumns.DISPLAY_NAME;
            } else {
                projection = IMAP_PROJECTION;
                orderBy = MailboxColumns.SERVER_ID;
            }
            if ((getFilter() & FILTER_INBOX_ONLY) == 0) {
                selection = ALL_MAILBOX_SELECTION;
            } else {
                selection = INBOX_ONLY_SELECTION;
            }
            return new MailboxPickerLoader(
                context, Mailbox.CONTENT_URI, projection, selection,
                new String[] { Long.toString(mAccount.mId) }, orderBy, mAccount.mId,
                (getFilter() & FILTER_ALLOW_UNREAD) != 0);
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
            // No accounts; close the dialog
            if (data.getCount() == 0) {
                mCallback.onMissingData(false, true);
                return;
            }
            // if there is only one mailbox, auto-select it
            if (data.getCount() == 1 && data.moveToFirst()) {
                long mailboxId = data.getLong(data.getColumnIndex(REAL_ID));
                mCallback.onSelected(mAccount, mailboxId);
                return;
            }
            super.onLoadFinished(loader, data);
            mLoadFinished = true;
            getActivity().setVisible(true);
        }

        @Override
        String[] getFromColumns() {
            return MAILBOX_FROM_COLUMNS;
        }
    }
}
",True,159,7,66,3,6,2,4,L6
44,com.android.email.activity.ActivityHelper.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.provider.Browser;
import android.view.WindowManager;

import com.android.email.Controller;
import com.android.email.Email;
import com.android.email.R;
import com.android.email.activity.setup.AccountSecurity;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;

/**
 * Various methods that are used by both 1-pane and 2-pane activities.
 *
 * Common code used by the activities and the fragments.
 */
public final class ActivityHelper {
    private ActivityHelper() {
    }

    /**
     * Open an URL in a message.
     *
     * This is intended to mirror the operation of the original
     * (see android.webkit.CallbackProxy) with one addition of intent flags
     * ""FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET"".  This improves behavior when sublaunching
     * other apps via embedded URI's.
     *
     * We also use this hook to catch ""mailto:"" links and handle them locally.
     *
     * @param activity parent activity
     * @param url URL to open
     * @param senderAccountId if the URL is mailto:, we use this account as the sender.
     *        TODO When MessageCompose implements the account selector, this won't be necessary.
     *        Pass {@link Account#NO_ACCOUNT} to use the default account.
     * @return true if the URI has successfully been opened.
     */
    public static boolean openUrlInMessage(Activity activity, String url, long senderAccountId) {
        // hijack mailto: uri's and handle locally
        if (url != null && url.toLowerCase().startsWith(""mailto:"")) {
            return MessageCompose.actionCompose(activity, url, senderAccountId);
        }

        // Handle most uri's via intent launch
        boolean result = false;
        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
        intent.addCategory(Intent.CATEGORY_BROWSABLE);
        intent.putExtra(Browser.EXTRA_APPLICATION_ID, activity.getPackageName());
        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        try {
            activity.startActivity(intent);
            result = true;
        } catch (ActivityNotFoundException ex) {
            // No applications can handle it.  Ignore.
        }
        return result;
    }

    /**
     * Open Calendar app with specific time
     */
    public static void openCalendar(Activity activity, long epochEventStartTime) {
        Uri uri = Uri.parse(""content://com.android.calendar/time/"" + epochEventStartTime);
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(uri);
        intent.putExtra(""VIEW"", ""DAY"");
        intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
        activity.startActivity(intent);
    }

    public static void deleteMessage(Context context, long messageId) {
        Controller.getInstance(context).deleteMessage(messageId);
        Utility.showToast(context,
                context.getResources().getQuantityString(R.plurals.message_deleted_toast, 1));
    }

    public static void moveMessages(final Context context, final long newMailboxId,
            final long[] messageIds) {
        Controller.getInstance(context).moveMessages(messageIds, newMailboxId);
        EmailAsyncTask.runAsyncSerial(new Runnable() {
            @Override
            public void run() {
                String mailboxName = Mailbox.getDisplayName(context, newMailboxId);
                if (mailboxName == null) {
                    return; // Mailbox gone??
                }
                String message = context.getResources().getQuantityString(
                        R.plurals.message_moved_toast, messageIds.length, messageIds.length ,
                        mailboxName);
                Utility.showToast(context, message);
            }
        });
    }

    /**
     * If configured via debug flags, inhibit hardware graphics acceleration.  Must be called
     * early in onCreate().
     *
     * NOTE: Currently, this only works if HW accel is *not* enabled via the manifest.
     */
    public static void debugSetWindowFlags(Activity activity) {
        if (Email.sDebugInhibitGraphicsAcceleration) {
            // Clear the flag in the activity's window
            activity.getWindow().setFlags(0,
                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
        } else {
            // Set the flag in the activity's window
            activity.getWindow().setFlags(WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,
                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);
        }
    }

    public static void showSecurityHoldDialog(Activity callerActivity, long accountId) {
        callerActivity.startActivity(
                AccountSecurity.actionUpdateSecurityIntent(callerActivity, accountId, true));
    }

}
",True,269,2,1,10,57,18,8,L6
45,com.android.email.activity.UiUtilities.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;

import android.app.Activity;
import android.app.Fragment;
import android.content.Context;
import android.content.res.Resources;
import android.view.View;

public class UiUtilities {
    private UiUtilities() {
    }

    /**
     * Formats the given size as a String in bytes, kB, MB or GB.  Ex: 12,315,000 = 11 MB
     */
    public static String formatSize(Context context, long size) {
        final Resources res = context.getResources();
        final long KB = 1024;
        final long MB = (KB * 1024);
        final long GB  = (MB * 1024);

        int resId;
        int value;

        if (size < KB) {
            resId = R.plurals.message_view_attachment_bytes;
            value = (int) size;
        } else if (size < MB) {
            resId = R.plurals.message_view_attachment_kilobytes;
            value = (int) (size / KB);
        } else if (size < GB) {
            resId = R.plurals.message_view_attachment_megabytes;
            value = (int) (size / MB);
        } else {
            resId = R.plurals.message_view_attachment_gigabytes;
            value = (int) (size / GB);
        }
        return res.getQuantityString(resId, value, value);
    }

    public static String getMessageCountForUi(Context context, int count,
            boolean replaceZeroWithBlank) {
        if (replaceZeroWithBlank && (count == 0)) {
            return """";
        } else if (count > 999) {
            return context.getString(R.string.more_than_999);
        } else {
            return Integer.toString(count);
        }
    }

    /** Generics version of {@link Activity#findViewById} */
    @SuppressWarnings(""unchecked"")
    public static <T extends View> T getViewOrNull(Activity parent, int viewId) {
        return (T) parent.findViewById(viewId);
    }

    /** Generics version of {@link View#findViewById} */
    @SuppressWarnings(""unchecked"")
    public static <T extends View> T getViewOrNull(View parent, int viewId) {
        return (T) parent.findViewById(viewId);
    }

    /**
     * Same as {@link Activity#findViewById}, but crashes if there's no view.
     */
    @SuppressWarnings(""unchecked"")
    public static <T extends View> T getView(Activity parent, int viewId) {
        return (T) checkView(parent.findViewById(viewId));
    }

    /**
     * Same as {@link View#findViewById}, but crashes if there's no view.
     */
    @SuppressWarnings(""unchecked"")
    public static <T extends View> T getView(View parent, int viewId) {
        return (T) checkView(parent.findViewById(viewId));
    }

    private static View checkView(View v) {
        if (v == null) {
            throw new IllegalArgumentException(""View doesn't exist"");
        }
        return v;
    }

    /**
     * Same as {@link View#setVisibility(int)}, but doesn't crash even if {@code view} is null.
     */
    public static void setVisibilitySafe(View v, int visibility) {
        if (v != null) {
            v.setVisibility(visibility);
        }
    }

    /**
     * Same as {@link View#setVisibility(int)}, but doesn't crash even if {@code view} is null.
     */
    public static void setVisibilitySafe(Activity parent, int viewId, int visibility) {
        setVisibilitySafe(parent.findViewById(viewId), visibility);
    }

    /**
     * Same as {@link View#setVisibility(int)}, but doesn't crash even if {@code view} is null.
     */
    public static void setVisibilitySafe(View parent, int viewId, int visibility) {
        setVisibilitySafe(parent.findViewById(viewId), visibility);
    }

    /**
     * Used by an {@link Fragment} to install itself to the host activity.
     *
     * @see FragmentInstallable
     */
    public static void installFragment(Fragment fragment) {
        final Activity a = fragment.getActivity();
        if (a instanceof FragmentInstallable) {
            ((FragmentInstallable) a).onInstallFragment(fragment);
        }
    }

    /**
     * Used by an {@link Fragment} to uninstall itself from the host activity.
     *
     * @see FragmentInstallable
     */
    public static void uninstallFragment(Fragment fragment) {
        final Activity a = fragment.getActivity();
        if (a instanceof FragmentInstallable) {
            ((FragmentInstallable) a).onUninstallFragment(fragment);
        }
    }

    private static int sDebugForcedPaneMode = 0;

    /**
     * Force 1-pane UI or 2-pane UI.
     *
     * @param paneMode Set 1 if 1-pane UI should be used.  Set 2 if 2-pane UI should be used.
     *        Set 0 to use the default UI.
     */
    static void setDebugPaneMode(int paneMode) {
        sDebugForcedPaneMode = paneMode;
    }

    /**
     * @return {@code true} if 2-pane UI should be used.  {@code false} otherwise.
     */
    public static boolean useTwoPane(Context context) {
        if (sDebugForcedPaneMode == 1) {
            return false;
        }
        if (sDebugForcedPaneMode == 2) {
            return true;
        }
        return context.getResources().getBoolean(R.bool.use_two_pane);
    }
}
",False,152,7,43,1,1,28,1,L0
46,com.android.email.activity.UIControllerOnePane.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.Fragment;
import android.app.FragmentTransaction;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

import com.android.email.Email;
import com.android.email.MessageListContext;
import com.android.email.R;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;

import java.util.Set;


/**
 * UI Controller for non x-large devices.  Supports a single-pane layout.
 *
 * One one-pane, only at most one fragment can be installed at a time.
 *
 * Note: Always use {@link #commitFragmentTransaction} to operate fragment transactions,
 * so that we can easily switch between synchronous and asynchronous transactions.
 *
 * Major TODOs
 * - TODO Implement callbacks
 */
class UIControllerOnePane extends UIControllerBase {
    private static final String BUNDLE_KEY_PREVIOUS_FRAGMENT
            = ""UIControllerOnePane.PREVIOUS_FRAGMENT"";

    // Our custom poor-man's back stack which has only one entry at maximum.
    private Fragment mPreviousFragment;

    // MailboxListFragment.Callback
    @Override
    public void onAccountSelected(long accountId) {
        // It's from combined view, so ""forceShowInbox"" doesn't really matter.
        // (We're always switching accounts.)
        switchAccount(accountId, true);
    }

    // MailboxListFragment.Callback
    @Override
    public void onMailboxSelected(long accountId, long mailboxId, boolean nestedNavigation) {
        if (nestedNavigation) {
            return; // Nothing to do on 1-pane.
        }
        openMailbox(accountId, mailboxId);
    }

    // MailboxListFragment.Callback
    @Override
    public void onParentMailboxChanged() {
        refreshActionBar();
    }

    // MessageListFragment.Callback
    @Override
    public void onAdvancingOpAccepted(Set<Long> affectedMessages) {
        // Nothing to do on 1 pane.
    }

    // MessageListFragment.Callback
    @Override
    public void onMessageOpen(
            long messageId, long messageMailboxId, long listMailboxId, int type) {
        if (type == MessageListFragment.Callback.TYPE_DRAFT) {
            MessageCompose.actionEditDraft(mActivity, messageId);
        } else {
            open(mListContext, messageId);
        }
    }

    // MessageListFragment.Callback
    @Override
    public boolean onDragStarted() {
        // No drag&drop on 1-pane
        return false;
    }

    // MessageListFragment.Callback
    @Override
    public void onDragEnded() {
        // No drag&drop on 1-pane
    }

    // MessageViewFragment.Callback
    @Override
    public void onForward() {
        MessageCompose.actionForward(mActivity, getMessageId());
    }

    // MessageViewFragment.Callback
    @Override
    public void onReply() {
        MessageCompose.actionReply(mActivity, getMessageId(), false);
    }

    // MessageViewFragment.Callback
    @Override
    public void onReplyAll() {
        MessageCompose.actionReply(mActivity, getMessageId(), true);
    }

    // MessageViewFragment.Callback
    @Override
    public void onCalendarLinkClicked(long epochEventStartTime) {
        ActivityHelper.openCalendar(mActivity, epochEventStartTime);
    }

    // MessageViewFragment.Callback
    @Override
    public boolean onUrlInMessageClicked(String url) {
        return ActivityHelper.openUrlInMessage(mActivity, url, getActualAccountId());
    }

    // MessageViewFragment.Callback
    @Override
    public void onLoadMessageError(String errorMessage) {
        // TODO Auto-generated method stub
    }

    // MessageViewFragment.Callback
    @Override
    public void onLoadMessageFinished() {
        // TODO Auto-generated method stub
    }

    // MessageViewFragment.Callback
    @Override
    public void onLoadMessageStarted() {
        // TODO Auto-generated method stub
    }

    private boolean isInboxShown() {
        if (!isMessageListInstalled()) {
            return false;
        }
        return getMessageListFragment().isInboxList();
    }

    // This is all temporary as we'll have a different action bar controller for 1-pane.
    private class ActionBarControllerCallback implements ActionBarController.Callback {
        @Override
        public int getTitleMode() {
            if (isMailboxListInstalled()) {
                return TITLE_MODE_ACCOUNT_WITH_ALL_FOLDERS_LABEL;
            }
            if (isMessageViewInstalled()) {
                return TITLE_MODE_MESSAGE_SUBJECT;
            }
            return TITLE_MODE_ACCOUNT_WITH_MAILBOX;
        }

        public String getMessageSubject() {
            if (isMessageViewInstalled() && getMessageViewFragment().isMessageOpen()) {
                return getMessageViewFragment().getMessage().mSubject;
            } else {
                return null;
            }
        }

        @Override
        public boolean shouldShowUp() {
            return isMessageViewInstalled()
                    || (isMessageListInstalled() && !isInboxShown())
                    || isMailboxListInstalled();
        }

        @Override
        public long getUIAccountId() {
            return UIControllerOnePane.this.getUIAccountId();
        }

        @Override
        public long getMailboxId() {
            return UIControllerOnePane.this.getMailboxId();
        }

        @Override
        public void onMailboxSelected(long accountId, long mailboxId) {
            if (mailboxId == Mailbox.NO_MAILBOX) {
                showAllMailboxes();
            } else {
                openMailbox(accountId, mailboxId);
            }
        }

        @Override
        public boolean isAccountSelected() {
            return UIControllerOnePane.this.isAccountSelected();
        }

        @Override
        public void onAccountSelected(long accountId) {
            switchAccount(accountId, true); // Always go to inbox
        }

        @Override
        public void onNoAccountsFound() {
            Welcome.actionStart(mActivity);
            mActivity.finish();
        }

        @Override
        public String getSearchHint() {
            if (!isMessageListInstalled()) {
                return null;
            }
            return UIControllerOnePane.this.getSearchHint();
        }

        @Override
        public void onSearchStarted() {
            if (!isMessageListInstalled()) {
                return;
            }
            UIControllerOnePane.this.onSearchStarted();
        }

        @Override
        public void onSearchSubmit(String queryTerm) {
            if (!isMessageListInstalled()) {
                return;
            }
            UIControllerOnePane.this.onSearchSubmit(queryTerm);
        }

        @Override
        public void onSearchExit() {
            UIControllerOnePane.this.onSearchExit();
        }
    }

    public UIControllerOnePane(EmailActivity activity) {
        super(activity);
    }

    @Override
    protected ActionBarController createActionBarController(Activity activity) {

        // For now, we just reuse the same action bar controller used for 2-pane.
        // We may change it later.

        return new ActionBarController(activity, activity.getLoaderManager(),
                activity.getActionBar(), new ActionBarControllerCallback());
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (mPreviousFragment != null) {
            mFragmentManager.putFragment(outState,
                    BUNDLE_KEY_PREVIOUS_FRAGMENT, mPreviousFragment);
        }
    }

    @Override
    public void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
        mPreviousFragment = mFragmentManager.getFragment(savedInstanceState,
                BUNDLE_KEY_PREVIOUS_FRAGMENT);
    }

    @Override
    public int getLayoutId() {
        return R.layout.email_activity_one_pane;
    }

    @Override
    public long getUIAccountId() {
        if (mListContext != null) {
            return mListContext.mAccountId;
        }
        if (isMailboxListInstalled()) {
            return getMailboxListFragment().getAccountId();
        }
        return Account.NO_ACCOUNT;
    }

    private long getMailboxId() {
        if (mListContext != null) {
            return mListContext.getMailboxId();
        }
        return Mailbox.NO_MAILBOX;
    }

    @Override
    public boolean onBackPressed(boolean isSystemBackKey) {
        if (Email.DEBUG) {
            // This is VERY important -- no check for DEBUG_LIFECYCLE
            Log.d(Logging.LOG_TAG, this + "" onBackPressed: "" + isSystemBackKey);
        }
        // The action bar controller has precedence.  Must call it first.
        if (mActionBarController.onBackPressed(isSystemBackKey)) {
            return true;
        }
        // If the mailbox list is shown and showing a nested mailbox, let it navigate up first.
        if (isMailboxListInstalled() && getMailboxListFragment().navigateUp()) {
            if (DEBUG_FRAGMENTS) {
                Log.d(Logging.LOG_TAG, this + "" Back: back handled by mailbox list"");
            }
            return true;
        }

        // Custom back stack
        if (shouldPopFromBackStack(isSystemBackKey)) {
            if (DEBUG_FRAGMENTS) {
                Log.d(Logging.LOG_TAG, this + "" Back: Popping from back stack"");
            }
            popFromBackStack();
            return true;
        }

        // No entry in the back stack.
        if (isMessageViewInstalled()) {
            if (DEBUG_FRAGMENTS) {
                Log.d(Logging.LOG_TAG, this + "" Back: Message view -> Message List"");
            }
            // If the message view is shown, show the ""parent"" message list.
            // This happens when we get a deep link to a message.  (e.g. from a widget)
            openMailbox(mListContext.mAccountId, mListContext.getMailboxId());
            return true;
        } else if (isMailboxListInstalled()) {
            // If the mailbox list is shown, always go back to the inbox.
            switchAccount(getMailboxListFragment().getAccountId(), true /* force show inbox */);
            return true;
        } else if (isMessageListInstalled() && !isInboxShown()) {
            // Non-inbox list. Go to inbox.
            switchAccount(mListContext.mAccountId, true /* force show inbox */);
            return true;
        }
        return false;
    }

    @Override
    public void openInternal(final MessageListContext listContext, final long messageId) {
        if (Email.DEBUG) {
            // This is VERY important -- don't check for DEBUG_LIFECYCLE
            Log.i(Logging.LOG_TAG, this + "" open "" + listContext + "" messageId="" + messageId);
        }

        if (messageId != Message.NO_MESSAGE) {
            openMessage(messageId);
        } else {
            showFragment(MessageListFragment.newInstance(listContext));
        }
    }

    /**
     * @return currently installed {@link Fragment} (1-pane has only one at most), or null if none
     *         exists.
     */
    private Fragment getInstalledFragment() {
        if (isMailboxListInstalled()) {
            return getMailboxListFragment();
        } else if (isMessageListInstalled()) {
            return getMessageListFragment();
        } else if (isMessageViewInstalled()) {
            return getMessageViewFragment();
        }
        return null;
    }

    /**
     * Show the mailbox list.
     *
     * This is the only way to open the mailbox list on 1-pane.
     * {@link #open(MessageListContext, long)} will only open either the message list or the
     * message view.
     */
    private void openMailboxList(long accountId) {
        setListContext(null);
        showFragment(MailboxListFragment.newInstance(accountId, Mailbox.NO_MAILBOX, false));
    }

    private void openMessage(long messageId) {
        showFragment(MessageViewFragment.newInstance(messageId));
    }

    /**
     * Push the installed fragment into our custom back stack (or optionally
     * {@link FragmentTransaction#remove} it) and {@link FragmentTransaction#add} {@code fragment}.
     *
     * @param fragment {@link Fragment} to be added.
     *
     *  TODO Delay-call the whole method and use the synchronous transaction.
     */
    private void showFragment(Fragment fragment) {
        final FragmentTransaction ft = mFragmentManager.beginTransaction();
        final Fragment installed = getInstalledFragment();
        if ((installed instanceof MessageViewFragment)
                && (fragment instanceof MessageViewFragment)) {
            // Newer/older navigation, auto-advance, etc.
            // In this case we want to keep the backstack untouched, so that after back navigation
            // we can restore the message list, including scroll position and batch selection.
        } else {
            if (DEBUG_FRAGMENTS) {
                Log.i(Logging.LOG_TAG, this + "" backstack: [push] "" + getInstalledFragment()
                        + "" -> "" + fragment);
            }
            if (mPreviousFragment != null) {
                if (DEBUG_FRAGMENTS) {
                    Log.d(Logging.LOG_TAG, this + "" showFragment: destroying previous fragment ""
                            + mPreviousFragment);
                }
                removeFragment(ft, mPreviousFragment);
                mPreviousFragment = null;
            }
            // Remove the current fragment or push it into the backstack.
            if (installed != null) {
                if (installed instanceof MessageViewFragment) {
                    // Message view should never be pushed to the backstack.
                    if (DEBUG_FRAGMENTS) {
                        Log.d(Logging.LOG_TAG, this + "" showFragment: removing "" + installed);
                    }
                    ft.remove(installed);
                } else {
                    // Other fragments should be pushed.
                    mPreviousFragment = installed;
                    if (DEBUG_FRAGMENTS) {
                        Log.d(Logging.LOG_TAG, this + "" showFragment: detaching ""
                                + mPreviousFragment);
                    }
                    ft.detach(mPreviousFragment);
                }
            }
        }
        // Show the new one
        if (DEBUG_FRAGMENTS) {
            Log.d(Logging.LOG_TAG, this + "" showFragment: replacing with "" + fragment);
        }
        ft.replace(R.id.fragment_placeholder, fragment);
        ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
        commitFragmentTransaction(ft);
    }

    /**
     * @param isSystemBackKey <code>true</code> if the system back key was pressed.
     *        <code>false</code> if it's caused by the ""home"" icon click on the action bar.
     * @return true if we should pop from our custom back stack.
     */
    private boolean shouldPopFromBackStack(boolean isSystemBackKey) {
        if (mPreviousFragment == null) {
            return false; // Nothing in the back stack
        }
        if (mPreviousFragment instanceof MessageViewFragment) {
            throw new IllegalStateException(""Message view should never be in backstack"");
        }
        final Fragment installed = getInstalledFragment();
        if (installed == null) {
            // If no fragment is installed right now, do nothing.
            return false;
        }

        // Okay now we have 2 fragments; the one in the back stack and the one that's currently
        // installed.
        if (isInboxShown()) {
            // Inbox is the top level list - never go back from here.
            return false;
        }

        // Disallow the MailboxList--> non-inbox MessageList transition as the Mailbox list
        // is always considered ""higher"" than a non-inbox MessageList
        if ((mPreviousFragment instanceof MessageListFragment)
                && (!((MessageListFragment) mPreviousFragment).isInboxList())
                && (installed  instanceof MailboxListFragment)) {
            return false;
        }
        return true;
    }

    /**
     * Pop from our custom back stack.
     *
     * TODO Delay-call the whole method and use the synchronous transaction.
     */
    private void popFromBackStack() {
        if (mPreviousFragment == null) {
            return;
        }
        final FragmentTransaction ft = mFragmentManager.beginTransaction();
        final Fragment installed = getInstalledFragment();
        if (DEBUG_FRAGMENTS) {
            Log.i(Logging.LOG_TAG, this + "" backstack: [pop] "" + installed + "" -> ""
                    + mPreviousFragment);
        }
        removeFragment(ft, installed);

        // Restore listContext.
        if (mPreviousFragment instanceof MailboxListFragment) {
            setListContext(null);
        } else if (mPreviousFragment instanceof MessageListFragment) {
            setListContext(((MessageListFragment) mPreviousFragment).getListContext());
        } else {
            throw new IllegalStateException(""Message view should never be in backstack"");
        }

        ft.attach(mPreviousFragment);
        ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_CLOSE);
        mPreviousFragment = null;
        commitFragmentTransaction(ft);
        return;
    }

    private void showAllMailboxes() {
        if (!isAccountSelected()) {
            return; // Can happen because of asynchronous fragment transactions.
        }

        openMailboxList(getUIAccountId());
    }

    @Override
    protected void installMailboxListFragment(MailboxListFragment fragment) {
        stopMessageOrderManager();
        super.installMailboxListFragment(fragment);
    }

    @Override
    protected void installMessageListFragment(MessageListFragment fragment) {
        stopMessageOrderManager();
        super.installMessageListFragment(fragment);
    }

    @Override
    protected long getMailboxSettingsMailboxId() {
        return isMessageListInstalled()
                ? getMessageListFragment().getMailboxId()
                : Mailbox.NO_MAILBOX;
    }

    @Override
    public boolean onPrepareOptionsMenu(MenuInflater inflater, Menu menu) {
        // First, let the base class do what it has to do.
        super.onPrepareOptionsMenu(inflater, menu);

        // Then override
        final boolean messageListVisible = isMessageListInstalled();
        if (!messageListVisible) {
            menu.findItem(R.id.search).setVisible(false);
            menu.findItem(R.id.compose).setVisible(false);
            menu.findItem(R.id.refresh).setVisible(false);
            menu.findItem(R.id.show_all_mailboxes).setVisible(false);
            menu.findItem(R.id.mailbox_settings).setVisible(false);
        }

        final boolean messageViewVisible = isMessageViewInstalled();
        if (messageViewVisible) {
            final MessageOrderManager om = getMessageOrderManager();
            menu.findItem(R.id.newer).setVisible(true);
            menu.findItem(R.id.older).setVisible(true);
            // orderManager shouldn't be null when the message view is installed, but just in case..
            menu.findItem(R.id.newer).setEnabled((om != null) && om.canMoveToNewer());
            menu.findItem(R.id.older).setEnabled((om != null) && om.canMoveToOlder());
        }
        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.newer:
                moveToNewer();
                return true;
            case R.id.older:
                moveToOlder();
                return true;
            case R.id.show_all_mailboxes:
                showAllMailboxes();
                return true;
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    protected boolean isRefreshEnabled() {
        // Refreshable only when an actual account is selected, and message view isn't shown.
        // (i.e. only available on the mailbox list or the message view, but not on the combined
        // one)
        if (!isActualAccountSelected() || isMessageViewInstalled()) {
            return false;
        }
        return isMailboxListInstalled() || (mListContext.getMailboxId() > 0);
    }

    @Override
    protected void onRefresh() {
        if (!isRefreshEnabled()) {
            return;
        }
        if (isMessageListInstalled()) {
            mRefreshManager.refreshMessageList(getActualAccountId(), getMailboxId(), true);
        } else {
            mRefreshManager.refreshMailboxList(getActualAccountId());
        }
    }

    @Override
    protected boolean isRefreshInProgress() {
        if (!isRefreshEnabled()) {
            return false;
        }
        if (isMessageListInstalled()) {
            return mRefreshManager.isMessageListRefreshing(getMailboxId());
        } else {
            return mRefreshManager.isMailboxListRefreshing(getActualAccountId());
        }
    }

    @Override protected void navigateToMessage(long messageId) {
        openMessage(messageId);
    }

    @Override protected void updateNavigationArrows() {
        refreshActionBar();
    }
}
",True,267,0,0,11,62,1,18,L6
47,com.android.email.activity.MailboxListFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.ListFragment;
import android.app.LoaderManager;
import android.app.LoaderManager.LoaderCallbacks;
import android.content.ClipData;
import android.content.ClipDescription;
import android.content.Context;
import android.content.Loader;
import android.database.Cursor;
import android.graphics.Rect;
import android.net.Uri;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.Log;
import android.view.DragEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnDragListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

import com.android.email.Controller;
import com.android.email.Email;
import com.android.email.R;
import com.android.email.RefreshManager;
import com.android.email.provider.EmailProvider;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.util.Timer;

/**
 * This fragment presents a list of mailboxes for a given account or the combined mailboxes.
 *
 * This fragment has several parameters that determine the current view.
 *
 * <pre>
 * Parameters:
 * - Account ID.
 *   - Set via {@link #newInstance}.
 *   - Can be obtained with {@link #getAccountId()}.
 *   - Will not change throughout fragment lifecycle.
 *   - Either an actual account ID, or {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
 *
 * - ""Highlight enabled?"" flag
 *   - Set via {@link #newInstance}.
 *   - Can be obtained with {@link #getEnableHighlight()}.
 *   - Will not change throughout fragment lifecycle.
 *   - If {@code true}, we highlight the ""selected"" mailbox (used only on 2-pane).
 *   - Note even if it's {@code true}, there may be no highlighted mailbox.
 *     (This usually happens on 2-pane before the UI controller finds the Inbox to highlight.)
 *
 * - ""Parent"" mailbox ID
 *   - Stored in {@link #mParentMailboxId}
 *   - Changes as the user navigates through nested mailboxes.
 *   - Initialized using the {@code mailboxId} parameter for {@link #newInstance}
 *     in {@link #setInitialParentAndHighlight()}.
 *
 * - ""Highlighted"" mailbox
 *   - Only used when highlighting is enabled.  (Otherwise always {@link Mailbox#NO_MAILBOX}.)
 *     i.e. used only on two-pane.
 *   - Stored in {@link #mHighlightedMailboxId}
 *   - Initialized using the {@code mailboxId} parameter for {@link #newInstance}
 *     in {@link #setInitialParentAndHighlight()}.
 *
 *   - Can be changed any time, using {@link #setHighlightedMailbox(long)}.
 *
 *   - If set, it's considered ""selected"", and we highlight the list item.
 *
 *   - (It should always be the ID of the list item selected in the list view, but we store it in
 *     a member for efficiency.)
 *
 *   - Sometimes, we need to set the highlighted mailbox while we're still loading data.
 *     In this case, we can't update {@link #mHighlightedMailboxId} right away, but need to do so
 *     in when the next data set arrives, in
 *     {@link MailboxListFragment.MailboxListLoaderCallbacks#onLoadFinished}.  For this, we use
 *     we store the mailbox ID in {@link #mNextHighlightedMailboxId} and update
 *     {@link #mHighlightedMailboxId} in onLoadFinished.
 *
 *
 * The ""selected"" is defined using the ""parent"" and ""highlighted"" mailboxes.
 * - ""Selected"" mailbox  (also sometimes called ""current"".)
 *   - This is what the user thinks it's now selected.
 *
 *   - Can be obtained with {@link #getSelectedMailboxId()}
 *   - If the ""highlighted"" mailbox exists, it's the ""selected.""  Otherwise, the ""parent""
 *     is considered ""selected.""
 *   - This is what is passed to {@link Callback#onMailboxSelected}.
 * </pre>
 *
 *
 * This fragment shows the content in one of the three following views, depending on the
 * parameters above.
 *
 * <pre>
 * 1. Combined view
 *   - Used if the account ID == {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
 *   - Parent mailbox is always {@link Mailbox#NO_MAILBOX}.
 *   - List contains:
 *     - combined mailboxes
 *     - all accounts
 *
 * 2. Root view for an account
 *   - Used if the account ID != {@link Account#ACCOUNT_ID_COMBINED_VIEW} and
 *     Parent mailbox == {@link Mailbox#NO_MAILBOX}
 *   - List contains
 *     - all the top level mailboxes for the selected account.
 *
 * 3. Root view for a mailbox.  (nested view)
 *   - Used if the account ID != {@link Account#ACCOUNT_ID_COMBINED_VIEW} and
 *     Parent mailbox != {@link Mailbox#NO_MAILBOX}
 *   - List contains:
 *     - parent mailbox (determined by ""parent"" mailbox ID)
 *     - all child mailboxes of the parent mailbox.
 * </pre>
 *
 *
 * Note that when a fragment is put in the back stack, it'll lose the content view but the fragment
 * itself is not destroyed.  If you call {@link #getListView()} in this state it'll throw
 * an {@link IllegalStateException}.  So,
 * - If code is supposed to be executed only when the fragment has the content view, use
 *   {@link #getListView()} directly to make sure it doesn't accidentally get executed when there's
 *   no views.
 * - Otherwise, make sure to check if the fragment has views with {@link #isViewCreated()}
 *   before touching any views.
 */
public class MailboxListFragment extends ListFragment implements OnItemClickListener,
        OnDragListener {
    private static final String TAG = ""MailboxListFragment"";

    private static final String BUNDLE_KEY_PARENT_MAILBOX_ID
            = ""MailboxListFragment.state.parent_mailbox_id"";
    private static final String BUNDLE_KEY_HIGHLIGHTED_MAILBOX_ID
            = ""MailboxListFragment.state.selected_mailbox_id"";
    private static final String BUNDLE_LIST_STATE = ""MailboxListFragment.state.listState"";
    private static final boolean DEBUG_DRAG_DROP = false; // MUST NOT SUBMIT SET TO TRUE

    /** No drop target is available where the user is currently hovering over */
    private static final int NO_DROP_TARGET = -1;
    // Total height of the top and bottom scroll zones, in pixels
    private static final int SCROLL_ZONE_SIZE = 64;
    // The amount of time to scroll by one pixel, in ms
    private static final int SCROLL_SPEED = 4;

    /** Arbitrary number for use with the loader manager */
    private static final int MAILBOX_LOADER_ID = 1;

    /** Argument name(s) */
    private static final String ARG_ACCOUNT_ID = ""accountId"";
    private static final String ARG_ENABLE_HIGHLIGHT = ""enablehighlight"";
    private static final String ARG_INITIAL_CURRENT_MAILBOX_ID = ""initialParentMailboxId"";

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    /** Rectangle used for hit testing children */
    private static final Rect sTouchFrame = new Rect();

    private RefreshManager mRefreshManager;

    // UI Support
    private Activity mActivity;
    private MailboxFragmentAdapter mListAdapter;
    private Callback mCallback = EmptyCallback.INSTANCE;

    // See the class javadoc
    private long mParentMailboxId;
    private long mHighlightedMailboxId;

    /**
     * Becomes {@code true} once we determine which mailbox to use as the parent.
     */
    private boolean mParentDetermined;

    /**
     * ID of the mailbox that should be highlighted when the next cursor is loaded.
     */
    private long mNextHighlightedMailboxId = Mailbox.NO_MAILBOX;

    // True if a drag is currently in progress
    private boolean mDragInProgress;
    /** Mailbox ID of the item being dragged. Used to determine valid drop targets. */
    private long mDragItemMailboxId = -1;
    /** A unique identifier for the drop target. May be {@link #NO_DROP_TARGET}. */
    private int mDropTargetId = NO_DROP_TARGET;
    // The mailbox list item view that the user's finger is hovering over
    private MailboxListItem mDropTargetView;
    // Lazily instantiated height of a mailbox list item (-1 is a sentinel for 'not initialized')
    private int mDragItemHeight = -1;
    /** {@code true} if we are currently scrolling under the drag item */
    private boolean mTargetScrolling;

    private Parcelable mSavedListState;

    private final MailboxFragmentAdapter.Callback mMailboxesAdapterCallback =
            new MailboxFragmentAdapter.Callback() {
        @Override
        public void onBind(MailboxListItem listItem) {
            listItem.setDropTargetBackground(mDragInProgress, mDragItemMailboxId);
        }
    };

    /**
     * Callback interface that owning activities must implement
     */
    public interface Callback {
        /**
         * Called when any mailbox (even a combined mailbox) is selected.
         *
         * @param accountId
         *          The ID of the owner account of the selected mailbox.
         *          Or {@link Account#ACCOUNT_ID_COMBINED_VIEW} if it's a combined mailbox.
         * @param mailboxId
         *          The ID of the selected mailbox. This may be real mailbox ID [e.g. a number > 0],
         *          or a combined mailbox ID [e.g. {@link Mailbox#QUERY_ALL_INBOXES}].
         * @param nestedNavigation {@code true} if the event is caused by nested mailbox navigation,
         *          that is, going up or drilling-in to a child mailbox.
         */
        public void onMailboxSelected(long accountId, long mailboxId, boolean nestedNavigation);

        /** Called when an account is selected on the combined view. */
        public void onAccountSelected(long accountId);

        /**
         * Called when the parent mailbox is changing.
         */
        public void onParentMailboxChanged();
    }

    private static class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();
        @Override public void onMailboxSelected(long accountId, long mailboxId,
                boolean nestedNavigation) { }
        @Override public void onAccountSelected(long accountId) { }
        @Override
        public void onParentMailboxChanged() { }
    }

    /**
     * Returns the index of the view located at the specified coordinates in the given list.
     * If the coordinates are outside of the list, {@code NO_DROP_TARGET} is returned.
     */
    private static int pointToIndex(ListView list, int x, int y) {
        final int count = list.getChildCount();
        for (int i = count - 1; i >= 0; i--) {
            final View child = list.getChildAt(i);
            if (child.getVisibility() == View.VISIBLE) {
                child.getHitRect(sTouchFrame);
                if (sTouchFrame.contains(x, y)) {
                    return i;
                }
            }
        }
        return NO_DROP_TARGET;
    }

    /**
     * Create a new instance with initialization parameters.
     *
     * This fragment should be created only with this method.  (Arguments should always be set.)
     *
     * @param accountId The ID of the account we want to view
     * @param initialCurrentMailboxId ID of the mailbox of interest.
     *        Pass {@link Mailbox#NO_MAILBOX} to show top-level mailboxes.
     * @param enableHighlight {@code true} if highlighting is enabled on the current screen
     *        configuration.  (We don't highlight mailboxes on one-pane.)
     */
    public static MailboxListFragment newInstance(long accountId, long initialCurrentMailboxId,
            boolean enableHighlight) {
        final MailboxListFragment instance = new MailboxListFragment();
        final Bundle args = new Bundle();
        args.putLong(ARG_ACCOUNT_ID, accountId);
        args.putLong(ARG_INITIAL_CURRENT_MAILBOX_ID, initialCurrentMailboxId);
        args.putBoolean(ARG_ENABLE_HIGHLIGHT, enableHighlight);
        instance.setArguments(args);
        return instance;
    }

    /**
     * The account ID the mailbox is associated with. Do not use directly; instead, use
     * {@link #getAccountId()}.
     * <p><em>NOTE:</em> Although we cannot force these to be immutable using Java language
     * constructs, this <em>must</em> be considered immutable.
     */
    private Long mImmutableAccountId;

    /**
     * {@code initialCurrentMailboxId} passed to {@link #newInstance}.
     * Do not use directly; instead, use {@link #getInitialCurrentMailboxId()}.
     * <p><em>NOTE:</em> Although we cannot force these to be immutable using Java language
     * constructs, this <em>must</em> be considered immutable.
     */
    private long mImmutableInitialCurrentMailboxId;

    /**
     * {@code enableHighlight} passed to {@link #newInstance}.
     * Do not use directly; instead, use {@link #getEnableHighlight()}.
     * <p><em>NOTE:</em> Although we cannot force these to be immutable using Java language
     * constructs, this <em>must</em> be considered immutable.
     */
    private boolean mImmutableEnableHighlight;

    private void initializeArgCache() {
        if (mImmutableAccountId != null) return;
        mImmutableAccountId = getArguments().getLong(ARG_ACCOUNT_ID);
        mImmutableInitialCurrentMailboxId = getArguments().getLong(ARG_INITIAL_CURRENT_MAILBOX_ID);
        mImmutableEnableHighlight = getArguments().getBoolean(ARG_ENABLE_HIGHLIGHT);
    }

    /**
     * @return {@code accountId} passed to {@link #newInstance}.  Safe to call even before onCreate.
     */
    public long getAccountId() {
        initializeArgCache();
        return mImmutableAccountId;
    }

    /**
     * @return {@code initialCurrentMailboxId} passed to {@link #newInstance}.
     * Safe to call even before onCreate.
     */
    public long getInitialCurrentMailboxId() {
        initializeArgCache();
        return mImmutableInitialCurrentMailboxId;
    }

    /**
     * @return {@code enableHighlight} passed to {@link #newInstance}.
     * Safe to call even before onCreate.
     */
    public boolean getEnableHighlight() {
        initializeArgCache();
        return mImmutableEnableHighlight;
    }

    @Override
    public void onAttach(Activity activity) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onAttach"");
        }
        super.onAttach(activity);
    }

    /**
     * Called to do initial creation of a fragment.  This is called after
     * {@link #onAttach(Activity)} and before {@link #onActivityCreated(Bundle)}.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onCreate"");
        }
        super.onCreate(savedInstanceState);

        mActivity = getActivity();
        mRefreshManager = RefreshManager.getInstance(mActivity);
        mListAdapter = new MailboxFragmentAdapter(mActivity, mMailboxesAdapterCallback);
        setListAdapter(mListAdapter); // It's safe to do even before the list view is created.

        if (savedInstanceState == null) {
            setInitialParentAndHighlight();
        } else {
            restoreInstanceState(savedInstanceState);
        }
    }

    /**
     * Set {@link #mParentMailboxId} and {@link #mHighlightedMailboxId} from the fragment arguments.
     */
    private void setInitialParentAndHighlight() {
        final long initialMailboxId = getInitialCurrentMailboxId();
        if (getAccountId() == Account.ACCOUNT_ID_COMBINED_VIEW) {
            // For the combined view, always show the top-level, but highlight the ""current"".
            mParentMailboxId = Mailbox.NO_MAILBOX;
        } else {
            // Inbox needs special care.
            // Note we can't get the mailbox type on the UI thread but this method *can* be used...
            final long inboxId = Mailbox.findMailboxOfType(getActivity(), getAccountId(),
                    Mailbox.TYPE_INBOX);
            if (initialMailboxId == inboxId) {
                // If Inbox is set as the initial current, we show the top level mailboxes
                // with inbox highlighted.
                mParentMailboxId = Mailbox.NO_MAILBOX;
            } else {
                // Otherwise, try using the ""current"" as the ""parent"" (and also highlight it).
                // If it has no children, we go up in onLoadFinished().
                mParentMailboxId = initialMailboxId;
            }
        }
        // Highlight the mailbox of interest
        if (getEnableHighlight()) {
            mHighlightedMailboxId = initialMailboxId;
        }
    }

    @Override
    public View onCreateView(
            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onCreateView"");
        }
        return inflater.inflate(R.layout.mailbox_list_fragment, container, false);
    }

    /**
     * @return true if the content view is created and not destroyed yet. (i.e. between
     * {@link #onCreateView} and {@link #onDestroyView}.
     */
    private boolean isViewCreated() {
        return getView() != null;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityCreated"");
        }
        super.onActivityCreated(savedInstanceState);

        // Note we can't do this in onCreateView.
        // getListView() is only usable after onCreateView().
        final ListView lv = getListView();
        lv.setOnItemClickListener(this);
        lv.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
        lv.setOnDragListener(this);

        startLoading(mParentMailboxId, mHighlightedMailboxId);

        UiUtilities.installFragment(this);
    }

    public void setCallback(Callback callback) {
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
    }

    /**
     * Called when the Fragment is visible to the user.
     */
    @Override
    public void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onStart"");
        }
        super.onStart();
    }

    /**
     * Called when the fragment is visible to the user and actively running.
     */
    @Override
    public void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onResume"");
        }
        super.onResume();

        // Fetch the latest mailbox list from the server here if stale so that the user always
        // sees the (reasonably) up-to-date mailbox list, without pressing ""refresh"".
        final long accountId = getAccountId();
        if (mRefreshManager.isMailboxListStale(accountId)) {
            mRefreshManager.refreshMailboxList(accountId);
        }
    }

    @Override
    public void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onPause"");
        }
        mSavedListState = getListView().onSaveInstanceState();
        super.onPause();
    }

    /**
     * Called when the Fragment is no longer started.
     */
    @Override
    public void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onStop"");
        }
        super.onStop();
    }

    @Override
    public void onDestroyView() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDestroyView"");
        }
        UiUtilities.uninstallFragment(this);
        super.onDestroyView();
    }

    /**
     * Called when the fragment is no longer in use.
     */
    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDestroy"");
        }
        mTaskTracker.cancellAllInterrupt();
        super.onDestroy();
    }

    @Override
    public void onDetach() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDetach"");
        }
        super.onDetach();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);
        outState.putLong(BUNDLE_KEY_PARENT_MAILBOX_ID, mParentMailboxId);
        outState.putLong(BUNDLE_KEY_HIGHLIGHTED_MAILBOX_ID, mHighlightedMailboxId);
        if (isViewCreated()) {
            outState.putParcelable(BUNDLE_LIST_STATE, getListView().onSaveInstanceState());
        }
    }

    private void restoreInstanceState(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" restoreInstanceState"");
        }
        mParentMailboxId = savedInstanceState.getLong(BUNDLE_KEY_PARENT_MAILBOX_ID);
        mNextHighlightedMailboxId = savedInstanceState.getLong(BUNDLE_KEY_HIGHLIGHTED_MAILBOX_ID);
        mSavedListState = savedInstanceState.getParcelable(BUNDLE_LIST_STATE);
    }

    /**
     * @return ""Selected"" mailbox ID.
     */
    public long getSelectedMailboxId() {
        return (mHighlightedMailboxId != Mailbox.NO_MAILBOX) ? mHighlightedMailboxId
                : mParentMailboxId;
    }

    /**
     * @return {@code true} if top-level mailboxes are shown.  {@code false} otherwise.
     */
    private boolean isRoot() {
        return mParentMailboxId == Mailbox.NO_MAILBOX;
    }

    /**
     * Navigate one level up in the mailbox hierarchy. Does nothing if at the root account view.
     */
    public boolean navigateUp() {
        if (isRoot()) {
            return false;
        }
        FindParentMailboxTask.ResultCallback callback = new FindParentMailboxTask.ResultCallback() {
            @Override public void onResult(long nextParentMailboxId,
                    long nextHighlightedMailboxId, long nextSelectedMailboxId) {

                startLoading(nextParentMailboxId, nextHighlightedMailboxId);
            }
        };
        new FindParentMailboxTask(
                getActivity().getApplicationContext(), mTaskTracker, getAccountId(),
                getEnableHighlight(), mParentMailboxId, mHighlightedMailboxId, callback
                ).cancelPreviousAndExecuteParallel((Void[]) null);
        return true;
    }

    /**
     * @return {@code true} if the fragment is showing nested mailboxes and we can go one level up.
     *         {@code false} otherwise, meaning we're showing the top level mailboxes *OR*
     *         we're still loading initial data and we can't determine if we're going to show
     *         top-level or not.
     */
    public boolean canNavigateUp() {
        if (!mParentDetermined) {
            return false; // We can't determine yet...
        }
        return !isRoot();
    }

    /**
     * A task to determine what parent mailbox ID/highlighted mailbox ID to use for the ""UP""
     * navigation, given the current parent mailbox ID, the highlighted mailbox ID, and {@link
     * #mEnableHighlight}.
     */
    @VisibleForTesting
    static class FindParentMailboxTask extends EmailAsyncTask<Void, Void, Long[]> {
        public interface ResultCallback {
            /**
             * Callback to get the result.
             *
             * @param nextParentMailboxId ID of the mailbox to use
             * @param nextHighlightedMailboxId ID of the mailbox to highlight
             * @param nextSelectedMailboxId ID of the mailbox to notify with
             *        {@link Callback#onMailboxSelected}.
             */
            public void onResult(long nextParentMailboxId, long nextHighlightedMailboxId,
                    long nextSelectedMailboxId);
        }

        private final Context mContext;
        private final long mAccountId;
        private final boolean mEnableHighlight;
        private final long mParentMailboxId;
        private final long mHighlightedMailboxId;
        private final ResultCallback mCallback;

        public FindParentMailboxTask(Context context, EmailAsyncTask.Tracker taskTracker,
                long accountId, boolean enableHighlight, long parentMailboxId,
                long highlightedMailboxId, ResultCallback callback) {
            super(taskTracker);
            mContext = context;
            mAccountId = accountId;
            mEnableHighlight = enableHighlight;
            mParentMailboxId = parentMailboxId;
            mHighlightedMailboxId = highlightedMailboxId;
            mCallback = callback;
        }

        @Override
        protected Long[] doInBackground(Void... params) {
            Mailbox parentMailbox = Mailbox.restoreMailboxWithId(mContext, mParentMailboxId);
            final long nextParentId = (parentMailbox == null) ? Mailbox.NO_MAILBOX
                    : parentMailbox.mParentKey;
            final long nextHighlightedId;
            final long nextSelectedId;
            if (mEnableHighlight) {
                // If the ""parent"" is highlighted before the transition, it should still be
                // highlighted after the upper level view.
                if (mParentMailboxId == mHighlightedMailboxId) {
                    nextHighlightedId = mParentMailboxId;
                } else {
                    // Otherwise, the next parent will be highlighted, unless we're going up to
                    // the root, in which case Inbox should be highlighted.
                    if (nextParentId == Mailbox.NO_MAILBOX) {
                        nextHighlightedId = Mailbox.findMailboxOfType(mContext, mAccountId,
                                Mailbox.TYPE_INBOX);
                    } else {
                        nextHighlightedId = nextParentId;
                    }
                }

                // Highlighted one will be ""selected"".
                nextSelectedId = nextHighlightedId;

            } else { // !mEnableHighlight
                nextHighlightedId = Mailbox.NO_MAILBOX;

                // Parent will be selected.
                nextSelectedId = nextParentId;
            }
            return new Long[]{nextParentId, nextHighlightedId, nextSelectedId};
        }

        @Override
        protected void onSuccess(Long[] result) {
            mCallback.onResult(result[0], result[1], result[2]);
        }
    }

    /**
     * Starts the loader.
     *
     * @param parentMailboxId Mailbox ID to be used as the ""parent"" mailbox
     * @param highlightedMailboxId Mailbox ID that should be highlighted when the data is loaded.
     */
    private void startLoading(long parentMailboxId, long highlightedMailboxId) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" startLoading  parent="" + parentMailboxId
                    + "" highlighted="" + highlightedMailboxId);
        }
        final LoaderManager lm = getLoaderManager();
        boolean parentMailboxChanging = false;

        // Parent mailbox changing -- destroy the current loader to force reload.
        if (mParentMailboxId != parentMailboxId) {
            lm.destroyLoader(MAILBOX_LOADER_ID);
            setListShown(false);
            parentMailboxChanging = true;
        }
        mParentMailboxId = parentMailboxId;
        if (getEnableHighlight()) {
            mNextHighlightedMailboxId = highlightedMailboxId;
        }

        lm.initLoader(MAILBOX_LOADER_ID, null, new MailboxListLoaderCallbacks());

        if (parentMailboxChanging) {
            mCallback.onParentMailboxChanged();
        }
    }

    /**
     * Highlight the given mailbox.
     *
     * If data is already loaded, it just sets {@link #mHighlightedMailboxId} and highlight the
     * corresponding list item.  (And if the corresponding list item is not found,
     * {@link #mHighlightedMailboxId} is set to {@link Mailbox#NO_MAILBOX})
     *
     * If we're still loading data, it sets {@link #mNextHighlightedMailboxId} instead, and then
     * it'll be set to {@link #mHighlightedMailboxId} in
     * {@link MailboxListLoaderCallbacks#onLoadFinished}.
     *
     * @param mailboxId The ID of the mailbox to highlight.
     */
    public void setHighlightedMailbox(long mailboxId) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" setHighlightedMailbox  mailbox="" + mailboxId);
        }
        if (!getEnableHighlight()) {
            return;
        }
        if (mHighlightedMailboxId == mailboxId) {
            return; // already highlighted.
        }
        if (mListAdapter.getCursor() == null) {
            // List not loaded yet.  Just remember the ID here and let onLoadFinished() update
            // mHighlightedMailboxId.
            mNextHighlightedMailboxId = mailboxId;
            return;
        }
        mHighlightedMailboxId = mailboxId;
        updateHighlightedMailbox(true);
    }

    // TODO This class probably should be made static. There are many calls into the enclosing
    // class and we need to be cautious about what we call while in these callbacks
    private class MailboxListLoaderCallbacks implements LoaderCallbacks<Cursor> {
        private boolean mIsFirstLoad;

        @Override
        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
            if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                Log.d(Logging.LOG_TAG, MailboxListFragment.this + "" onCreateLoader"");
            }
            mIsFirstLoad = true;
            if (getAccountId() == Account.ACCOUNT_ID_COMBINED_VIEW) {
                return MailboxFragmentAdapter.createCombinedViewLoader(getActivity());
            } else {
                return MailboxFragmentAdapter.createMailboxesLoader(getActivity(), getAccountId(),
                        mParentMailboxId);
            }
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor cursor) {
            if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                Log.d(Logging.LOG_TAG, MailboxListFragment.this + "" onLoadFinished  count=""
                        + cursor.getCount());
            }
            // Note in onLoadFinished we can assume the view is created.
            // The loader manager doesn't deliver results when a fragment is stopped.

            // If we're showing a nested mailboxes, and the current parent mailbox has no children,
            // go up.
            if (getAccountId() != Account.ACCOUNT_ID_COMBINED_VIEW) {
                MailboxFragmentAdapter.CursorWithExtras c =
                        (MailboxFragmentAdapter.CursorWithExtras) cursor;
                if ((c.mChildCount == 0) && !isRoot()) {
                    // Always swap out the cursor so we don't hold a reference to a stale one.
                    mListAdapter.swapCursor(cursor);
                    navigateUp();
                    return;
                }
            }

            // Save list view state (primarily scroll position)
            final ListView lv = getListView();
            final Parcelable listState;
            if (mSavedListState != null) {
                listState = mSavedListState;
                mSavedListState = null;
            } else {
                listState = lv.onSaveInstanceState();
            }

            if (cursor.getCount() == 0) {
                // There's no row -- call setListShown(false) to make ListFragment show progress
                // icon.
                mListAdapter.swapCursor(null);
                setListShown(false);

            } else {
                mParentDetermined = true; // Okay now we're sure which mailbox is the parent.

                mListAdapter.swapCursor(cursor);
                setListShown(true);

                // Restore the list state, so scroll position is restored - this has to happen
                // prior to setting the checked/highlighted mailbox below.
                lv.onRestoreInstanceState(listState);

                // Update the highlighted mailbox
                if (mNextHighlightedMailboxId != Mailbox.NO_MAILBOX) {
                    setHighlightedMailbox(mNextHighlightedMailboxId);
                    mNextHighlightedMailboxId = Mailbox.NO_MAILBOX;
                }

                // We want to make visible the selection only for the first load.
                // Re-load caused by content changed events shouldn't scroll the list.
                if (!updateHighlightedMailbox(mIsFirstLoad)) {
                    // This may happen if the mailbox to be selected is not actually in the list
                    // that was loaded. Let the user just pick one manually if needed.
                    return;
                }
            }

            // List has been reloaded; clear any drop target information
            mDropTargetId = NO_DROP_TARGET;
            mDropTargetView = null;

            mIsFirstLoad = false;
        }

        @Override
        public void onLoaderReset(Loader<Cursor> loader) {
            if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                Log.d(Logging.LOG_TAG, MailboxListFragment.this + "" onLoaderReset"");
            }
            mListAdapter.swapCursor(null);
        }
    }

    /**
     * {@inheritDoc}
     * <p>
     * @param doNotUse <em>IMPORTANT</em>: Do not use this parameter. The ID in the list widget
     * must be a positive value. However, we rely on negative IDs for special mailboxes. Instead,
     * we use the ID returned by {@link MailboxFragmentAdapter#getId(int)}.
     */
    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long doNotUse) {
        final long id = mListAdapter.getId(position);
        if (mListAdapter.isAccountRow(position)) {
            mCallback.onAccountSelected(id);
        } else if (mListAdapter.isMailboxRow(position)) {
            // Save account-id.  (Need to do this before startLoading() below, which will destroy
            // the current loader and make the mListAdapter lose the cursor.
            // Note, don't just use getAccountId().  A mailbox may tied to a different account ID
            // from getAccountId().  (Currently ""Starred"" does so.)
            long accountId = mListAdapter.getAccountId(position);
            boolean nestedNavigation = false;
            if (((MailboxListItem) view).isNavigable() && (id != mParentMailboxId)) {
                // Drill-in.  Selected one will be the next parent, and it'll also be highlighted.
                startLoading(id, id);
                nestedNavigation = true;
            }
            if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                // Virtual mailboxes, such as ""Starred"", will have a ""combined view"" ID. However,
                // we really want to relay the current active account, so that
                // things like per-account starred mailboxes work as expected.
                accountId = getAccountId();
            }
            mCallback.onMailboxSelected(accountId, id, nestedNavigation);
        }
    }

    /**
     * Really highlight the mailbox for {@link #mHighlightedMailboxId} on the list view.
     *
     * Note if a list item for {@link #mHighlightedMailboxId} is not found,
     * {@link #mHighlightedMailboxId} will be set to {@link Mailbox#NO_MAILBOX}.
     *
     * @return false when the highlighted mailbox seems to be gone; i.e. if
     *         {@link #mHighlightedMailboxId} is set but not found in the list.
     */
    private boolean updateHighlightedMailbox(boolean ensureSelectionVisible) {
        if (!getEnableHighlight() || !isViewCreated()) {
            return true; // Nothing to highlight
        }
        final ListView lv = getListView();
        boolean found = false;
        if (mHighlightedMailboxId == Mailbox.NO_MAILBOX) {
            // No mailbox selected
            lv.clearChoices();
            found = true;
        } else {
            // TODO Don't mix list view & list adapter indices. This is a recipe for disaster.
            final int count = lv.getCount();
            for (int i = 0; i < count; i++) {
                if (mListAdapter.getId(i) != mHighlightedMailboxId) {
                    continue;
                }
                found = true;
                lv.setItemChecked(i, true);
                if (ensureSelectionVisible) {
                    Utility.listViewSmoothScrollToPosition(getActivity(), lv, i);
                }
                break;
            }
        }
        if (!found) {
            mHighlightedMailboxId = Mailbox.NO_MAILBOX;
        }
        return found;
    }

    // Drag & Drop handling

    /**
     * Update all of the list's child views with the proper target background (for now, orange if
     * a valid target, except red if the trash; standard background otherwise)
     */
    private void updateChildViews() {
        final ListView lv = getListView();
        int itemCount = lv.getChildCount();
        // Lazily initialize the height of our list items
        if (itemCount > 0 && mDragItemHeight < 0) {
            mDragItemHeight = lv.getChildAt(0).getHeight();
        }
        for (int i = 0; i < itemCount; i++) {
            final View child = lv.getChildAt(i);
            if (!(child instanceof MailboxListItem)) {
                continue;
            }
            MailboxListItem item = (MailboxListItem) child;
            item.setDropTargetBackground(mDragInProgress, mDragItemMailboxId);
        }
    }

    /**
     * Called when the user has dragged outside of the mailbox list area.
     */
    private void onDragExited() {
        // Reset the background of the current target
        if (mDropTargetView != null) {
            mDropTargetView.setDropTargetBackground(mDragInProgress, mDragItemMailboxId);
            mDropTargetView = null;
        }
        mDropTargetId = NO_DROP_TARGET;
        stopScrolling();
    }

    /**
     * Called while dragging;  highlight possible drop targets, and auto scroll the list.
     */
    private void onDragLocation(DragEvent event) {
        final ListView lv = getListView();
        // TODO The list may be changing while in drag-n-drop; temporarily suspend drag-n-drop
        // if the list is being updated [i.e. navigated to another mailbox]
        if (mDragItemHeight <= 0) {
            // This shouldn't be possible, but avoid NPE
            Log.w(TAG, ""drag item height is not set"");
            return;
        }
        // Find out which item we're in and highlight as appropriate
        final int rawTouchX = (int) event.getX();
        final int rawTouchY = (int) event.getY();
        final int viewIndex = pointToIndex(lv, rawTouchX, rawTouchY);
        int targetId = viewIndex;
        if (targetId != mDropTargetId) {
            if (DEBUG_DRAG_DROP) {
                Log.d(TAG, ""=== Target changed; oldId: "" + mDropTargetId + "", newId: "" + targetId);
            }
            // Remove highlight the current target; if there was one
            if (mDropTargetView != null) {
                mDropTargetView.setDropTargetBackground(true, mDragItemMailboxId);
                mDropTargetView = null;
            }
            // Get the new target mailbox view
            final View childView = lv.getChildAt(viewIndex);
            final MailboxListItem newTarget;
            if (childView == null) {
                // In any event, we're no longer dragging in the list view if newTarget is null
                if (DEBUG_DRAG_DROP) {
                    Log.d(TAG, ""=== Drag off the list"");
                }
                newTarget = null;
                final int childCount = lv.getChildCount();
                if (viewIndex >= childCount) {
                    // Touching beyond the end of the list; may happen for small lists
                    onDragExited();
                    return;
                } else {
                    // We should never get here
                    Log.w(TAG, ""null view; idx: "" + viewIndex + "", cnt: "" + childCount);
                }
            } else if (!(childView instanceof MailboxListItem)) {
                // We're over a header suchas ""Recent folders"".  We shouldn't finish DnD, but
                // drop should be disabled.
                newTarget = null;
                targetId = NO_DROP_TARGET;
            } else {
                newTarget = (MailboxListItem) childView;
                if (newTarget.mMailboxType == Mailbox.TYPE_TRASH) {
                    if (DEBUG_DRAG_DROP) {
                        Log.d(TAG, ""=== Trash mailbox; id: "" + newTarget.mMailboxId);
                    }
                    newTarget.setDropTrashBackground();
                } else if (newTarget.isDropTarget(mDragItemMailboxId)) {
                    if (DEBUG_DRAG_DROP) {
                        Log.d(TAG, ""=== Target mailbox; id: "" + newTarget.mMailboxId);
                    }
                    newTarget.setDropActiveBackground();
                } else {
                    if (DEBUG_DRAG_DROP) {
                        Log.d(TAG, ""=== Non-droppable mailbox; id: "" + newTarget.mMailboxId);
                    }
                    newTarget.setDropTargetBackground(true, mDragItemMailboxId);
                    targetId = NO_DROP_TARGET;
                }
            }
            // Save away our current position and view
            mDropTargetId = targetId;
            mDropTargetView = newTarget;
        }

        // This is a quick-and-dirty implementation of drag-under-scroll; something like this
        // should eventually find its way into the framework
        int scrollDiff = rawTouchY - (lv.getHeight() - SCROLL_ZONE_SIZE);
        boolean scrollDown = (scrollDiff > 0);
        boolean scrollUp = (SCROLL_ZONE_SIZE > rawTouchY);
        if (!mTargetScrolling && scrollDown) {
            int itemsToScroll = lv.getCount() - lv.getLastVisiblePosition();
            int pixelsToScroll = (itemsToScroll + 1) * mDragItemHeight;
            lv.smoothScrollBy(pixelsToScroll, pixelsToScroll * SCROLL_SPEED);
            if (DEBUG_DRAG_DROP) {
                Log.d(TAG, ""=== Start scrolling list down"");
            }
            mTargetScrolling = true;
        } else if (!mTargetScrolling && scrollUp) {
            int pixelsToScroll = (lv.getFirstVisiblePosition() + 1) * mDragItemHeight;
            lv.smoothScrollBy(-pixelsToScroll, pixelsToScroll * SCROLL_SPEED);
            if (DEBUG_DRAG_DROP) {
                Log.d(TAG, ""=== Start scrolling list up"");
            }
            mTargetScrolling = true;
        } else if (!scrollUp && !scrollDown) {
            stopScrolling();
        }
    }

    /**
     * Indicate that scrolling has stopped
     */
    private void stopScrolling() {
        final ListView lv = getListView();
        if (mTargetScrolling) {
            mTargetScrolling = false;
            if (DEBUG_DRAG_DROP) {
                Log.d(TAG, ""=== Stop scrolling list"");
            }
            // Stop the scrolling
            lv.smoothScrollBy(0, 0);
        }
    }

    private void onDragEnded() {
        if (mDragInProgress) {
            mDragInProgress = false;
            // Reenable updates to the view and redraw (in case it changed)
            MailboxFragmentAdapter.enableUpdates(true);
            mListAdapter.notifyDataSetChanged();
            // Stop highlighting targets
            updateChildViews();
            // Stop any scrolling that was going on
            stopScrolling();
        }
    }

    private boolean onDragStarted(DragEvent event) {
        // We handle dropping of items with our email mime type
        // If the mime type has a mailbox id appended, that is the mailbox of the item
        // being draged
        ClipDescription description = event.getClipDescription();
        int mimeTypeCount = description.getMimeTypeCount();
        for (int i = 0; i < mimeTypeCount; i++) {
            String mimeType = description.getMimeType(i);
            if (mimeType.startsWith(EmailProvider.EMAIL_MESSAGE_MIME_TYPE)) {
                if (DEBUG_DRAG_DROP) {
                    Log.d(TAG, ""=== Drag started"");
                }
                mDragItemMailboxId = -1;
                // See if we find a mailbox id here
                int dash = mimeType.lastIndexOf('-');
                if (dash > 0) {
                    try {
                        mDragItemMailboxId = Long.parseLong(mimeType.substring(dash + 1));
                    } catch (NumberFormatException e) {
                        // Ignore; we just won't know the mailbox
                    }
                }
                mDragInProgress = true;
                // Stop the list from updating
                MailboxFragmentAdapter.enableUpdates(false);
                // Update the backgrounds of our child views to highlight drop targets
                updateChildViews();
                return true;
            }
        }
        return false;
    }

    /**
     * Perform a ""drop"" action. If the user is not on top of a valid drop target, no action
     * is performed.
     * @return {@code true} if the drop action was performed. Otherwise {@code false}.
     */
    private boolean onDrop(DragEvent event) {
        stopScrolling();
        // If we're not on a target, we're done
        if (mDropTargetId == NO_DROP_TARGET) {
            return false;
        }
        final Controller controller = Controller.getInstance(mActivity);
        ClipData clipData = event.getClipData();
        int count = clipData.getItemCount();
        if (DEBUG_DRAG_DROP) {
            Log.d(TAG, ""=== Dropping "" + count + "" items."");
        }
        // Extract the messageId's to move from the ClipData (set up in MessageListItem)
        final long[] messageIds = new long[count];
        for (int i = 0; i < count; i++) {
            Uri uri = clipData.getItemAt(i).getUri();
            String msgNum = uri.getPathSegments().get(1);
            long id = Long.parseLong(msgNum);
            messageIds[i] = id;
        }
        // Call either deleteMessage or moveMessage, depending on the target
        if (mDropTargetView.mMailboxType == Mailbox.TYPE_TRASH) {
            controller.deleteMessages(messageIds);
        } else {
            controller.moveMessages(messageIds, mDropTargetView.mMailboxId);
        }
        return true;
    }

    @Override
    public boolean onDrag(View view, DragEvent event) {
        boolean result = false;
        switch (event.getAction()) {
            case DragEvent.ACTION_DRAG_STARTED:
                result = onDragStarted(event);
                break;
            case DragEvent.ACTION_DRAG_ENTERED:
                // The drag has entered the ListView window
                if (DEBUG_DRAG_DROP) {
                    Log.d(TAG, ""=== Drag entered; targetId: "" + mDropTargetId);
                }
                break;
            case DragEvent.ACTION_DRAG_EXITED:
                // The drag has left the building
                if (DEBUG_DRAG_DROP) {
                    Log.d(TAG, ""=== Drag exited; targetId: "" + mDropTargetId);
                }
                onDragExited();
                break;
            case DragEvent.ACTION_DRAG_ENDED:
                // The drag is over
                if (DEBUG_DRAG_DROP) {
                    Log.d(TAG, ""=== Drag ended"");
                }
                onDragEnded();
                break;
            case DragEvent.ACTION_DRAG_LOCATION:
                // We're moving around within our window; handle scroll, if necessary
                onDragLocation(event);
                break;
            case DragEvent.ACTION_DROP:
                // The drag item was dropped
                if (DEBUG_DRAG_DROP) {
                    Log.d(TAG, ""=== Drop"");
                }
                result = onDrop(event);
                break;
            default:
                break;
        }
        return result;
    }
}
",True,268,1,1,10,47,4,12,L6
48,com.android.email.activity.ShortcutPicker.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;

import com.android.email.R;
import com.android.email.activity.ShortcutPickerFragment.AccountShortcutPickerFragment;
import com.android.email.activity.ShortcutPickerFragment.MailboxShortcutPickerFragment;
import com.android.email.activity.ShortcutPickerFragment.PickerCallback;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;

/**
 * This class implements a launcher shortcut for directly accessing a single account.
 */
public class ShortcutPicker extends Activity implements OnClickListener, PickerCallback {
    /**
     * If true, creates pre-honeycomb style shortcuts. This allows developers to test launching
     * the app from old style shortcuts (which point sat MessageList rather than Welcome) without
     * actually carrying over shortcuts from previous versions.
     */
    private final static boolean TEST_CREATE_OLD_STYLE_SHORTCUT = false; // DO NOT SUBMIT WITH TRUE

    @Override
    public void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        // TODO Relax this test slightly in order to re-use this activity for widget creation
        if (!Intent.ACTION_CREATE_SHORTCUT.equals(getIntent().getAction())) {
            // finish() immediately if we aren't supposed to be here
            finish();
            return;
        }

        // Set handler for the ""cancel"" button
        setContentView(R.layout.account_shortcut_picker);
        findViewById(R.id.cancel).setOnClickListener(this);

        if (getFragmentManager().findFragmentById(R.id.shortcut_list) == null) {
            // Load the account picking fragment if we haven't created a fragment yet
            // NOTE: do not add to history as this will be the first fragment in the flow
            AccountShortcutPickerFragment fragment = new AccountShortcutPickerFragment();
            getFragmentManager().beginTransaction().add(R.id.shortcut_list, fragment).commit();
        }
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.cancel:
                finish();
                break;
        }
    }

    @Override
    public Integer buildFilter(Account account) {
        if (!Account.isNormalAccount(account.mId)) {
            // Shortcuts for combined accounts can only be for inboxes.
            return MailboxShortcutPickerFragment.FILTER_INBOX_ONLY;
        }

        return MailboxShortcutPickerFragment.FILTER_ALLOW_ALL;
    }

    @Override
    public void onSelected(Account account, long mailboxId) {
        String shortcutName;
        if (Account.isNormalAccount(account.mId) &&
                (Mailbox.getMailboxType(this, mailboxId) != Mailbox.TYPE_INBOX)) {
            shortcutName = Mailbox.getDisplayName(this, mailboxId);
        } else {
            shortcutName = account.getDisplayName();
        }
        setupShortcut(account, mailboxId, shortcutName);
        finish();
    }

    @Override
    public void onMissingData(boolean missingAccount, boolean missingMailbox) {
        // TODO what's the proper handling if the mailbox list is '0'? display toast?
        finish();
    }

    /**
     * This function creates a shortcut and returns it to the caller.  There are actually two
     * intents that you will send back.
     *
     * The first intent serves as a container for the shortcut and is returned to the launcher by
     * setResult().  This intent must contain three fields:
     *
     * <ul>
     * <li>{@link android.content.Intent#EXTRA_SHORTCUT_INTENT} The shortcut intent.</li>
     * <li>{@link android.content.Intent#EXTRA_SHORTCUT_NAME} The text that will be displayed with
     * the shortcut.</li>
     * <li>{@link android.content.Intent#EXTRA_SHORTCUT_ICON} The shortcut's icon, if provided as a
     * bitmap, <i>or</i> {@link android.content.Intent#EXTRA_SHORTCUT_ICON_RESOURCE} if provided as
     * a drawable resource.</li>
     * </ul>
     *
     * If you use a simple drawable resource, note that you must wrapper it using
     * {@link android.content.Intent.ShortcutIconResource}, as shown below.  This is required so
     * that the launcher can access resources that are stored in your application's .apk file.  If
     * you return a bitmap, such as a thumbnail, you can simply put the bitmap into the extras
     * bundle using {@link android.content.Intent#EXTRA_SHORTCUT_ICON}.
     *
     * The shortcut intent can be any intent that you wish the launcher to send, when the user
     * clicks on the shortcut.  Typically this will be {@link android.content.Intent#ACTION_VIEW}
     * with an appropriate Uri for your content, but any Intent will work here as long as it
     * triggers the desired action within your Activity.
     */
    private void setupShortcut(Account account, long mailboxId, String shortcutName) {
        Activity myActivity = this;
        // First, set up the shortcut intent.
        final Intent shortcutIntent;
        if (TEST_CREATE_OLD_STYLE_SHORTCUT) {
            shortcutIntent = MessageList.createFroyoIntent(myActivity, account);
            Log.d(Logging.LOG_TAG, ""Created old style intent: "" + shortcutIntent);
        } else {
            // TODO if we add meta-mailboxes/accounts to the database, remove this special case
            if (account.mId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                shortcutIntent = Welcome.createOpenMessageIntent(
                        myActivity, account.mId, mailboxId, Message.NO_MESSAGE);
            } else {
                String uuid = account.mCompatibilityUuid;
                shortcutIntent = Welcome.createAccountShortcutIntent(myActivity, uuid, mailboxId);
            }
        }

        // Then, set up the container intent (the response to the caller)
        Intent intent = new Intent();
        intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
        intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, shortcutName);
        Parcelable iconResource
                = Intent.ShortcutIconResource.fromContext(myActivity, R.mipmap.ic_launcher_email);
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, iconResource);

        // Now, return the result to the launcher
        myActivity.setResult(Activity.RESULT_OK, intent);
    }
}
",False,267,0,0,12,52,1,7,L6
49,com.android.email.activity.ChipsAddressTextView.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.Context;
import android.util.AttributeSet;

import com.android.ex.chips.RecipientEditTextView;

/**
 * This is a MultiAutoCompleteTextView which has a custom validator.
 */
class ChipsAddressTextView extends RecipientEditTextView {
    /** A noop validator that does not munge invalid texts. */
    private class ForwardValidator implements Validator {
        private Validator mValidator = null;

        public CharSequence fixText(CharSequence invalidText) {
            return invalidText;
        }

        public boolean isValid(CharSequence text) {
            return mValidator != null ? mValidator.isValid(text) : true;
        }

        public void setValidator(Validator validator) {
            mValidator = validator;
        }
    }

    private final ForwardValidator mInternalValidator = new ForwardValidator();

    public ChipsAddressTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
        super.setValidator(mInternalValidator);
    }

    @Override
    public void setValidator(Validator validator) {
        mInternalValidator.setValidator(validator);
    }
}
",False,1,0,0,0,0,0,0,I0
50,com.android.email.activity.BannerController.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.animation.Animator;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.TimeInterpolator;
import android.content.Context;
import android.view.ViewGroup;
import android.view.animation.DecelerateInterpolator;
import android.widget.TextView;

/**
 * Class to hide/show a banner.
 */
public class BannerController {
    private static final int ANIMATION_DURATION = 100;
    private static final TimeInterpolator INTERPOLATOR = new DecelerateInterpolator(1.5f);

    private final TextView mBannerView;
    private final int mBannerHeight;

    private boolean mShown;

    /** Hold last animator to cancel. */
    private Animator mLastAnimator;

    public BannerController(Context context, TextView bannerView, int bannerHeight) {
        mBannerView = bannerView;
        mBannerHeight = bannerHeight;

        setBannerYAnim(-mBannerHeight); // hide by default.
    }

    /**
     * @return the current y position of the banner.
     */
    private int getBannerY() {
        return ((ViewGroup.MarginLayoutParams) mBannerView.getLayoutParams()).topMargin;
    }

    private static final String PROP_SET_BANNER_Y = ""bannerYAnim"";

    /**
     * Set the Y position of the banner.  public, but should only be used by animators.
     */
    public void setBannerYAnim(int y) {
        ((ViewGroup.MarginLayoutParams) mBannerView.getLayoutParams()).topMargin = y;
        mBannerView.requestLayout();
    }

    /**
     * Show a banner with a message.
     *
     * @return false if a banner is already shown, in which case the message won't be updated.
     */
    public boolean show(String message) {
        if (mShown) {
            return false; // If already shown, don't change the message, to avoid flicker.
        }
        mShown = true;
        mBannerView.setText(message);
        slideBanner(0);
        return true;
    }

    /**
     * Dismiss a banner.
     */
    public void dismiss() {
        if (!mShown) {
            return; // Always hidden, or hiding.
        }
        mShown = false;
        slideBanner(-mBannerHeight); // Slide up to hide.
    }

    private void slideBanner(int toY) {
        if (mLastAnimator != null) {
            mLastAnimator.cancel();
        }

        final PropertyValuesHolder[] values = {
                PropertyValuesHolder.ofInt(PROP_SET_BANNER_Y, getBannerY(), toY) };
        final ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(
                this, values).setDuration(ANIMATION_DURATION);
        animator.setInterpolator(INTERPOLATOR);
        mLastAnimator = animator;
        animator.start();
    }
}
",False,147,9,45,0,0,1,0,L6
51,com.android.email.activity.MailboxFinder.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.Controller;
import com.android.email.ControllerResultUiThreadWrapper;
import com.android.email.Email;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;

import android.content.Context;
import android.os.Handler;
import android.util.Log;

/**
 * A class that finds a mailbox ID by account ID and mailbox type.
 *
 * If an account doesn't have a mailbox of a specified type, it refreshes the mailbox list and
 * try looking for again.
 *
 * This is a ""one-shot"" class.  You create an instance, call {@link #startLookup}, get a result
 * or call {@link #cancel}, and that's it.  The instance can't be re-used.
 */
public class MailboxFinder {
    private final Context mContext;
    private final Controller mController;

    // Actual Controller.Result that will wrapped by ControllerResultUiThreadWrapper.
    // Unit tests directly use it to avoid asynchronicity caused by ControllerResultUiThreadWrapper.
    private final ControllerResults mInnerControllerResults;
    private Controller.Result mControllerResults; // Not final, we null it out when done.

    private final long mAccountId;
    private final int mMailboxType;
    private final Callback mCallback;

    private FindMailboxTask mTask;
    private boolean mStarted;
    private boolean mClosed;

    /**
     * Callback for results.
     */
    public interface Callback {
        public void onAccountNotFound();
        public void onMailboxNotFound(long accountId);
        public void onAccountSecurityHold(long accountId);
        public void onMailboxFound(long accountId, long mailboxId);
    }

    /**
     * Creates an instance for {@code accountId} and {@code mailboxType}.  (But won't start yet)
     *
     * Must be called on the UI thread.
     */
    public MailboxFinder(Context context, long accountId, int mailboxType, Callback callback) {
        if (accountId == -1) {
            throw new UnsupportedOperationException();
        }
        mContext = context.getApplicationContext();
        mController = Controller.getInstance(context);
        mAccountId = accountId;
        mMailboxType = mailboxType;
        mCallback = callback;
        mInnerControllerResults = new ControllerResults();
        mControllerResults = new ControllerResultUiThreadWrapper<ControllerResults>(
                new Handler(), mInnerControllerResults);
        mController.addResultCallback(mControllerResults);
    }

    /**
     * Start looking up.
     *
     * Must be called on the UI thread.
     */
    public void startLookup() {
        if (mStarted) {
            throw new IllegalStateException(); // Can't start twice.
        }
        mStarted = true;
        mTask = new FindMailboxTask(true);
        mTask.executeParallel();
    }

    /**
     * Cancel the operation.  It's safe to call it multiple times, or even if the operation is
     * already finished.
     */
    public void cancel() {
        if (!mClosed) {
            close();
        }
    }

    /**
     * Stop the running task, if exists, and clean up internal resources.
     */
    private void close() {
        mClosed = true;
        if (mControllerResults != null) {
            mController.removeResultCallback(mControllerResults);
            mControllerResults = null;
        }
        Utility.cancelTaskInterrupt(mTask);
        mTask = null;
    }

    private class ControllerResults extends Controller.Result {
        @Override
        public void updateMailboxListCallback(MessagingException result, long accountId,
                int progress) {
            if (mClosed || (accountId != mAccountId)) {
                return; // Already closed, or non-target account.
            }
            Log.i(Logging.LOG_TAG, ""MailboxFinder: updateMailboxListCallback"");
            if (result != null) {
                // Error while updating the mailbox list.  Notify the UI...
                try {
                    mCallback.onMailboxNotFound(mAccountId);
                } finally {
                    close();
                }
            } else if (progress == 100) {
                // Mailbox list updated, look for mailbox again...
                mTask = new FindMailboxTask(false);
                mTask.executeParallel();
            }
        }
    }

    /**
     * Async task for finding a single mailbox by type.  If a mailbox of a type is not found,
     * and {@code okToRecurse} is true, we update the mailbox list and try looking again.
     */
    private class FindMailboxTask extends EmailAsyncTask<Void, Void, Long> {
        private final boolean mOkToRecurse;

        private static final int RESULT_MAILBOX_FOUND = 0;
        private static final int RESULT_ACCOUNT_SECURITY_HOLD = 1;
        private static final int RESULT_ACCOUNT_NOT_FOUND = 2;
        private static final int RESULT_MAILBOX_NOT_FOUND = 3;
        private static final int RESULT_START_NETWORK_LOOK_UP = 4;

        private int mResult = -1;

        /**
         * Special constructor to cache some local info
         */
        public FindMailboxTask(boolean okToRecurse) {
            super(null);
            mOkToRecurse = okToRecurse;
        }

        @Override
        protected Long doInBackground(Void... params) {
            // Quick check that account is not in security hold
            if (Account.isSecurityHold(mContext, mAccountId)) {
                mResult = RESULT_ACCOUNT_SECURITY_HOLD;
                return Mailbox.NO_MAILBOX;
            }

            // See if we can find the requested mailbox in the DB.
            long mailboxId = Mailbox.findMailboxOfType(mContext, mAccountId, mMailboxType);
            if (mailboxId != Mailbox.NO_MAILBOX) {
                mResult = RESULT_MAILBOX_FOUND;
                return mailboxId; // Found
            }

            // Mailbox not found.  Does the account really exists?
            final boolean accountExists = Account.isValidId(mContext, mAccountId);
            if (accountExists) {
                if (mOkToRecurse) {
                    // launch network lookup
                    mResult = RESULT_START_NETWORK_LOOK_UP;
                } else {
                    mResult = RESULT_MAILBOX_NOT_FOUND;
                }
            } else {
                mResult = RESULT_ACCOUNT_NOT_FOUND;
            }
            return Mailbox.NO_MAILBOX;
        }

        @Override
        protected void onSuccess(Long mailboxId) {
            switch (mResult) {
                case RESULT_ACCOUNT_SECURITY_HOLD:
                    Log.w(Logging.LOG_TAG, ""MailboxFinder: Account security hold."");
                    try {
                        mCallback.onAccountSecurityHold(mAccountId);
                    } finally {
                        close();
                    }
                    return;
                case RESULT_ACCOUNT_NOT_FOUND:
                    Log.w(Logging.LOG_TAG, ""MailboxFinder: Account not found."");
                    try {
                        mCallback.onAccountNotFound();
                    } finally {
                        close();
                    }
                    return;
                case RESULT_MAILBOX_NOT_FOUND:
                    Log.w(Logging.LOG_TAG, ""MailboxFinder: Mailbox not found."");
                    try {
                        mCallback.onMailboxNotFound(mAccountId);
                    } finally {
                        close();
                    }
                    return;
                case RESULT_MAILBOX_FOUND:
                    if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                        Log.d(Logging.LOG_TAG, ""MailboxFinder: mailbox found: id="" + mailboxId);
                    }
                    try {
                        mCallback.onMailboxFound(mAccountId, mailboxId);
                    } finally {
                        close();
                    }
                    return;
                case RESULT_START_NETWORK_LOOK_UP:
                    // Not found locally.  Let's sync the mailbox list...
                    Log.i(Logging.LOG_TAG, ""MailboxFinder: Starting network lookup."");
                    mController.updateMailboxList(mAccountId);
                    return;
                default:
                    throw new RuntimeException();
            }
        }
    }

    /* package */ boolean isStartedForTest() {
        return mStarted;
    }

    /**
     * Called by unit test.  Return true if all the internal resources are really released.
     */
    /* package */ boolean isReallyClosedForTest() {
        return mClosed && (mTask == null) && (mControllerResults == null);
    }

    /* package */ Controller.Result getControllerResultsForTest() {
        return mInnerControllerResults;
    }
}
",False,268,1,1,10,52,2,9,L6
52,com.android.email.activity.MailboxMoveToAdapter.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.Context;
import android.content.Loader;
import android.database.Cursor;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CursorAdapter;
import android.widget.TextView;

import com.android.email.Email;
import com.android.email.FolderProperties;
import com.android.email.data.ThrottlingCursorLoader;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.Utility;

/**
 * Cursor adapter for the ""move to mailbox"" dialog.
 * TODO We've detached this class from {@link MailboxFragmentAdapter} and {@link MailboxFragmentAdapter}.
 * Depending upon the UX for the dialog and nested folders, we may want to bring these three
 * adapter classes back into alignment.
 */
class MailboxMoveToAdapter extends CursorAdapter {
    /** Selection for all mailboxes in an account */
    private static final String ALL_MAILBOX_SELECTION = MailboxColumns.ACCOUNT_KEY + ""=?""
        + "" AND "" + Mailbox.USER_VISIBLE_MAILBOX_SELECTION;
    /** Selection for valid target mailboxes */
    private static final String TARGET_MAILBOX_SELECTION =
        MailboxColumns.TYPE + "" NOT IN ("" + Mailbox.TYPE_DRAFTS + "",""
        + Mailbox.TYPE_OUTBOX + "","" + Mailbox.TYPE_SENT + "","" + Mailbox.TYPE_TRASH + "") AND (""
        + MailboxColumns.FLAGS + "" & "" + Mailbox.FLAG_ACCEPTS_MOVED_MAIL + "" != 0)"";
    /** Selection to exclude a mailbox ID */
    private static final String EXCLUDE_MAILBOX_SELECTION =
        MailboxColumns.ID + ""!=?"";
    /** The main selection to populate the ""move to"" dialog */
    private static final String MOVE_TO_SELECTION =
        ALL_MAILBOX_SELECTION
        + "" AND "" + TARGET_MAILBOX_SELECTION
        + "" AND "" + EXCLUDE_MAILBOX_SELECTION;
    /** Projection that uses the server id column as the mailbox name */
    private static final String[] MOVE_TO_PROJECTION_SERVER_ID = new String[] {
        MailboxColumns.ID,
        MailboxColumns.ID + "" AS org_mailbox_id"",
        MailboxColumns.SERVER_ID,
        MailboxColumns.TYPE,
    };
    /** Projection that uses the display name column as the mailbox name */
    private static final String[] MOVE_TO_PROJECTION_DISPLAY_NAME = new String[] {
        MailboxColumns.ID,
        MailboxColumns.ID + "" AS org_mailbox_id"",
        MailboxColumns.DISPLAY_NAME,
        MailboxColumns.TYPE,
    };
    /** Sort order for special mailboxes */
    private static final String MOVE_TO_ORDER_BY_STATIC =
        ""CASE "" + MailboxColumns.TYPE
        + "" WHEN "" + Mailbox.TYPE_INBOX   + "" THEN 0""
        + "" WHEN "" + Mailbox.TYPE_JUNK    + "" THEN 1""
        + "" ELSE 10 END"";
    /** Server id sort order */
    private static final String MOVE_TO_ORDER_BY_SERVER_ID =
        MOVE_TO_ORDER_BY_STATIC
        // All other mailboxes are shown in alphabetical order.
        + "", "" + MailboxColumns.SERVER_ID;
    /** Display name sort order */
    private static final String MOVE_TO_ORDER_BY_DISPLAY_NAME =
        MOVE_TO_ORDER_BY_STATIC
        // All other mailboxes are shown in alphabetical order.
        + "", "" + MailboxColumns.DISPLAY_NAME;

    // Column 0 is only for ListView; we don't use it in our code.
    private static final int COLUMN_ID = 1;
    private static final int COLUMN_MAILBOX_NAME = 2;
    private static final int COLUMN_TYPE = 3;

    /** Cached layout inflater */
    private final LayoutInflater mInflater;

    public MailboxMoveToAdapter(Context context) {
        super(context, null, 0 /* flags; no content observer */);
        mInflater = LayoutInflater.from(context);
    }

    @Override
    public void bindView(View view, Context context, Cursor cursor) {
        TextView t = (TextView) view;
        t.setText(getDisplayText(context, cursor));
    }

    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
        return mInflater.inflate(android.R.layout.simple_list_item_1, parent, false);
    }

    static Loader<Cursor> createLoader(Context context, long accountId, long mailboxId) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""MailboxDialogAdapter#createLoader accountId="" + accountId
                    + "", mailboxId="" + mailboxId);
        }
        return new MailboxMoveToLoader(context, accountId, mailboxId);
    }

    /**
     * Returns the mailbox name to display in the dialog list. If the mailbox is of
     * certain, well known, types, use a predefined name. Otherwise, use the server
     * provided name.
     */
    private static String getDisplayText(Context context, Cursor cursor) {
        final int type = cursor.getInt(COLUMN_TYPE);
        final long mailboxId = cursor.getLong(COLUMN_ID);
        return FolderProperties.getInstance(context).getDisplayName(type, mailboxId,
                cursor.getString(COLUMN_MAILBOX_NAME));
    }

    /** Loader for the ""move to mailbox"" dialog. */
    private static class MailboxMoveToLoader extends ThrottlingCursorLoader {
        private final long mAccountId;
        public MailboxMoveToLoader(Context context, long accountId, long mailboxId) {
            super(context, Mailbox.CONTENT_URI,
                    null, MOVE_TO_SELECTION,
                    new String[] { Long.toString(accountId), Long.toString(mailboxId) }, null);
            mAccountId = accountId;
        }

        @Override
        public Cursor loadInBackground() {
            // TODO Create a common way to store the fully qualified path name for all account types
            final String protocol = Account.getProtocol(getContext(), mAccountId);
            if (HostAuth.SCHEME_EAS.equals(protocol)) {
                // For EAS accounts; use the display name
                setProjection(MOVE_TO_PROJECTION_DISPLAY_NAME);
                setSortOrder(MOVE_TO_ORDER_BY_DISPLAY_NAME);
            } else {
                // For all other accounts; use the server id
                setProjection(MOVE_TO_PROJECTION_SERVER_ID);
                setSortOrder(MOVE_TO_ORDER_BY_SERVER_ID);
            }
            final Cursor mailboxesCursor = super.loadInBackground();
            return Utility.CloseTraceCursorWrapper.get(mailboxesCursor);
        }
    }
}
",False,267,0,0,11,46,1,9,L6
53,com.android.email.activity.AddressTextView.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.MultiAutoCompleteTextView;

/**
 * This is a MultiAutoCompleteTextView which sets the error state
 * (@see TextView.setError) when email address validation fails.
 */
class AddressTextView extends MultiAutoCompleteTextView {
    private class ForwardValidator implements Validator {
        private Validator mValidator = null;

        public CharSequence fixText(CharSequence invalidText) {
            mIsValid = false;
            return invalidText;
        }

        public boolean isValid(CharSequence text) {
            return mValidator != null ? mValidator.isValid(text) : true;
        }

        public void setValidator(Validator validator) {
            mValidator = validator;
        }
    }

    private boolean mIsValid = true;
    private final ForwardValidator mInternalValidator = new ForwardValidator();

    public AddressTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
        super.setValidator(mInternalValidator);
    }

    @Override
    public void setValidator(Validator validator) {
        mInternalValidator.setValidator(validator);
    }

    @Override
    public void performValidation() {
        mIsValid = true;
        super.performValidation();
        markError(!mIsValid);
    }

    private void markError(boolean enable) {
        if (enable) {
            setError(getContext().getString(R.string.message_compose_error_invalid_email));
        } else {
            setError(null);
        }
    }
}
",False,1,0,0,0,0,0,0,I0
54,com.android.email.activity.RecentMailboxManager.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;

import com.android.email.Clock;
import com.android.email.Controller;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Maps;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Manages recent data for mailboxes.
 */
public class RecentMailboxManager {
    @VisibleForTesting
    static Clock sClock = Clock.INSTANCE;
    @VisibleForTesting
    static RecentMailboxManager sInstance;

    public static String RECENT_MAILBOXES_SORT_ORDER = MailboxColumns.DISPLAY_NAME;

    /** The maximum number of results to retrieve */
    private static final int LIMIT_RESULTS = 5;
    /** Query to find the top most recent mailboxes */
    private static final String RECENT_SELECTION =
            MailboxColumns.ID + "" IN "" +
            ""( SELECT "" + MailboxColumns.ID
            + "" FROM "" + Mailbox.TABLE_NAME
            + "" WHERE ( "" + MailboxColumns.ACCOUNT_KEY + ""=? ""
            +     "" AND "" + Mailbox.USER_VISIBLE_MAILBOX_SELECTION
            +     "" AND "" + MailboxColumns.TYPE + ""!="" + Mailbox.TYPE_INBOX
            +     "" AND "" + MailboxColumns.LAST_TOUCHED_TIME + "">0 )""
            + "" ORDER BY "" + MailboxColumns.LAST_TOUCHED_TIME + "" DESC""
            + "" LIMIT ? )"";
    /** Similar query to {@link #RECENT_SELECTION}, except, exclude all but user mailboxes */
    private static final String RECENT_SELECTION_WITH_EXCLUSIONS =
            MailboxColumns.ID + "" IN "" +
            ""( SELECT "" + MailboxColumns.ID
            + "" FROM "" + Mailbox.TABLE_NAME
            + "" WHERE ( "" + MailboxColumns.ACCOUNT_KEY + ""=? ""
            +     "" AND "" + Mailbox.USER_VISIBLE_MAILBOX_SELECTION
            +     "" AND "" + MailboxColumns.TYPE + ""="" + Mailbox.TYPE_MAIL
            +     "" AND "" + MailboxColumns.LAST_TOUCHED_TIME + "">0 )""
            + "" ORDER BY "" + MailboxColumns.LAST_TOUCHED_TIME + "" DESC""
            + "" LIMIT ? )"";

    /** Mailbox types for default ""recent mailbox"" entries if none exist */
    @VisibleForTesting
    static final int[] DEFAULT_RECENT_TYPES = new int[] {
        Mailbox.TYPE_DRAFTS,
        Mailbox.TYPE_SENT,
    };

    private final Context mContext;
    private final HashMap<Long, Boolean> mDefaultRecentsInitialized;

    public static synchronized RecentMailboxManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new RecentMailboxManager(context);
        }
        return sInstance;
    }

    /** Hide constructor */
    private RecentMailboxManager(Context context) {
        mContext = context;
        mDefaultRecentsInitialized = Maps.newHashMap();
    }

    /** Updates the specified mailbox's touch time. Returns an async task for test only. */
    public EmailAsyncTask<Void, Void, Void> touch(long accountId, long mailboxId) {
        return fireAndForget(accountId, mailboxId, sClock.getTime());
    }

    /**
     * Gets the most recently touched mailboxes for the specified account. If there are no
     * recent mailboxes and withExclusions is {@code false}, default recent mailboxes will
     * be returned.
     * <p><em>WARNING</em>: This method blocks on the database.
     * @param accountId The ID of the account to load the recent list.
     * @param withExclusions If {@code false}, all mailboxes are eligible for the recent list.
     *          Otherwise, only user defined mailboxes are eligible for the recent list.
     */
    public ArrayList<Long> getMostRecent(long accountId, boolean withExclusions) {
        ensureDefaultsInitialized(accountId, sClock.getTime());

        String selection = withExclusions ? RECENT_SELECTION_WITH_EXCLUSIONS : RECENT_SELECTION;
        ArrayList<Long> returnList = new ArrayList<Long>();
        Cursor cursor = mContext.getContentResolver().query(Mailbox.CONTENT_URI,
            EmailContent.ID_PROJECTION,
            selection,
            new String[] { Long.toString(accountId), Integer.toString(LIMIT_RESULTS) },
            RECENT_MAILBOXES_SORT_ORDER);
        try {
            while (cursor.moveToNext()) {
                returnList.add(cursor.getLong(EmailContent.ID_PROJECTION_COLUMN));
            }
        } finally {
            cursor.close();
        }
        return returnList;
    }

    /** Updates the last touched time for the mailbox in the background */
    private EmailAsyncTask<Void, Void, Void> fireAndForget(
            final long accountId, final long mailboxId, final long time) {
        return EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
            public void run() {
                ensureDefaultsInitialized(accountId, time);
                touchMailboxSynchronous(accountId, mailboxId, time);
            }
        });
    }

    private void touchMailboxSynchronous(long accountId, long mailboxId, long time) {
        ContentValues values = new ContentValues();
        values.put(MailboxColumns.LAST_TOUCHED_TIME, time);
        mContext.getContentResolver().update(
                ContentUris.withAppendedId(Mailbox.CONTENT_URI, mailboxId),
                values, null, null);
    }

    /**
     * Ensures the default recent mailboxes have been set for this account.
     */
    private synchronized void ensureDefaultsInitialized(long accountId, long time) {
        if (Boolean.TRUE.equals(mDefaultRecentsInitialized.get(accountId))) {
            return;
        }

        String[] args = new String[] { Long.toString(accountId), Integer.toString(LIMIT_RESULTS) };
        if (EmailContent.count(mContext, Mailbox.CONTENT_URI, RECENT_SELECTION, args) == 0) {
            // There are no recent mailboxes at all. Populate with default set.
            for (int type : DEFAULT_RECENT_TYPES) {
                long mailbox = Controller.getInstance(mContext).findOrCreateMailboxOfType(
                        accountId, type);
                touchMailboxSynchronous(accountId, mailbox, time);
            }
        }

        mDefaultRecentsInitialized.put(accountId, true);
    }
}
",True,268,1,1,10,48,4,5,L6
55,com.android.email.activity.ActionBarController.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.ActionBar;
import android.app.LoaderManager;
import android.app.LoaderManager.LoaderCallbacks;
import android.content.Context;
import android.content.Loader;
import android.database.Cursor;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.text.TextUtils;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListPopupWindow;
import android.widget.ListView;
import android.widget.SearchView;
import android.widget.TextView;

import com.android.email.R;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.DelayedOperations;
import com.android.emailcommon.utility.Utility;

/**
 * Manages the account name and the custom view part on the action bar.
 */
public class ActionBarController {
    private static final String BUNDLE_KEY_MODE = ""ActionBarController.BUNDLE_KEY_MODE"";

    /**
     * Constants for {@link #mSearchMode}.
     *
     * In {@link #MODE_NORMAL} mode, we don't show the search box.
     * In {@link #MODE_SEARCH} mode, we do show the search box.
     * The action bar doesn't really care if the activity is showing search results.
     * If the activity is showing search results, and the {@link Callback#onSearchExit} is called,
     * the activity probably wants to close itself, but this class doesn't make the desision.
     */
    private static final int MODE_NORMAL = 0;
    private static final int MODE_SEARCH = 1;

    private static final int LOADER_ID_ACCOUNT_LIST
            = EmailActivity.ACTION_BAR_CONTROLLER_LOADER_ID_BASE + 0;

    private final Context mContext;
    private final LoaderManager mLoaderManager;
    private final ActionBar mActionBar;
    private final DelayedOperations mDelayedOperations;

    /** ""Folders"" label shown with account name on 1-pane mailbox list */
    private final String mAllFoldersLabel;

    private final ViewGroup mActionBarCustomView;
    private final ViewGroup mAccountSpinnerContainer;
    private final View mAccountSpinner;
    private final Drawable mAccountSpinnerDefaultBackground;
    private final TextView mAccountSpinnerLine1View;
    private final TextView mAccountSpinnerLine2View;
    private final TextView mAccountSpinnerCountView;

    private View mSearchContainer;
    private SearchView mSearchView;

    private final AccountDropdownPopup mAccountDropdown;

    private final AccountSelectorAdapter mAccountsSelectorAdapter;

    private AccountSelectorAdapter.CursorWithExtras mCursor;

    /** The current account ID; used to determine if the account has changed. */
    private long mLastAccountIdForDirtyCheck = Account.NO_ACCOUNT;

    /** The current mailbox ID; used to determine if the mailbox has changed. */
    private long mLastMailboxIdForDirtyCheck = Mailbox.NO_MAILBOX;

    /** Either {@link #MODE_NORMAL} or {@link #MODE_SEARCH}. */
    private int mSearchMode = MODE_NORMAL;

    /** The current title mode, which should be one of {@code Callback TITLE_MODE_*} */
    private int mTitleMode;

    public final Callback mCallback;

    public interface SearchContext {
        public long getTargetMailboxId();
    }

    private static final int TITLE_MODE_SPINNER_ENABLED = 0x10;

    public interface Callback {
        /** Values for {@link #getTitleMode}.  Show only account name */
        public static final int TITLE_MODE_ACCOUNT_NAME_ONLY = 0 | TITLE_MODE_SPINNER_ENABLED;

        /**
         * Show the current account name with ""Folders""
         * The account spinner will be disabled in this mode.
         */
        public static final int TITLE_MODE_ACCOUNT_WITH_ALL_FOLDERS_LABEL = 1;

        /**
         * Show the current account name and the current mailbox name.
         */
        public static final int TITLE_MODE_ACCOUNT_WITH_MAILBOX = 2 | TITLE_MODE_SPINNER_ENABLED;
        /**
         * Show the current message subject.  Actual subject is obtained via
         * {@link #getMessageSubject()}.
         *
         * The account spinner will be disabled in this mode.
         */
        public static final int TITLE_MODE_MESSAGE_SUBJECT = 3;

        /** @return true if an account is selected. */
        public boolean isAccountSelected();

        /**
         * @return currently selected account ID, {@link Account#ACCOUNT_ID_COMBINED_VIEW},
         * or -1 if no account is selected.
         */
        public long getUIAccountId();

        /**
         * @return currently selected mailbox ID, or {@link Mailbox#NO_MAILBOX} if no mailbox is
         * selected.
         */
        public long getMailboxId();

        /**
         * @return constants such as {@link #TITLE_MODE_ACCOUNT_NAME_ONLY}.
         */
        public int getTitleMode();

        /** @see #TITLE_MODE_MESSAGE_SUBJECT */
        public String getMessageSubject();

        /** @return the ""UP"" arrow should be shown. */
        public boolean shouldShowUp();

        /**
         * Called when an account is selected on the account spinner.
         * @param accountId ID of the selected account, or {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
         */
        public void onAccountSelected(long accountId);

        /**
         * Invoked when a recent mailbox is selected on the account spinner.
         *
         * @param accountId ID of the selected account, or {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
         * @param mailboxId The ID of the selected mailbox, or {@link Mailbox#NO_MAILBOX} if the
         *          special option ""show all mailboxes"" was selected.
         */
        public void onMailboxSelected(long accountId, long mailboxId);

        /** Called when no accounts are found in the database. */
        public void onNoAccountsFound();

        /**
         * Retrieves the hint text to be shown for when a search entry is being made.
         */
        public String getSearchHint();

        /**
         * Called when the action bar initially shows the search entry field.
         */
        public void onSearchStarted();

        /**
         * Called when a search is submitted.
         *
         * @param queryTerm query string
         */
        public void onSearchSubmit(String queryTerm);

        /**
         * Called when the search box is closed.
         */
        public void onSearchExit();
    }

    public ActionBarController(Context context, LoaderManager loaderManager,
            ActionBar actionBar, Callback callback) {
        mContext = context;
        mLoaderManager = loaderManager;
        mActionBar = actionBar;
        mCallback = callback;
        mDelayedOperations = new DelayedOperations(Utility.getMainThreadHandler());
        mAllFoldersLabel = mContext.getResources().getString(
                R.string.action_bar_mailbox_list_title);
        mAccountsSelectorAdapter = new AccountSelectorAdapter(mContext);

        // Configure action bar.
        mActionBar.setDisplayOptions(ActionBar.DISPLAY_SHOW_HOME | ActionBar.DISPLAY_SHOW_CUSTOM);

        // Prepare the custom view
        mActionBar.setCustomView(R.layout.action_bar_custom_view);
        mActionBarCustomView = (ViewGroup) mActionBar.getCustomView();

        // Account spinner
        mAccountSpinnerContainer =
                UiUtilities.getView(mActionBarCustomView, R.id.account_spinner_container);
        mAccountSpinner = UiUtilities.getView(mActionBarCustomView, R.id.account_spinner);
        mAccountSpinnerDefaultBackground = mAccountSpinner.getBackground();

        mAccountSpinnerLine1View = UiUtilities.getView(mActionBarCustomView, R.id.spinner_line_1);
        mAccountSpinnerLine2View = UiUtilities.getView(mActionBarCustomView, R.id.spinner_line_2);
        mAccountSpinnerCountView = UiUtilities.getView(mActionBarCustomView, R.id.spinner_count);

        // Account dropdown
        mAccountDropdown = new AccountDropdownPopup(mContext);
        mAccountDropdown.setAdapter(mAccountsSelectorAdapter);

        mAccountSpinner.setOnClickListener(new View.OnClickListener() {
            @Override public void onClick(View v) {
                if (mAccountsSelectorAdapter.getCount() > 0) {
                    mAccountDropdown.show();
                }
            }
        });
    }

    private void initSearchViews() {
        if (mSearchContainer == null) {
            final LayoutInflater inflater = LayoutInflater.from(mContext);
            mSearchContainer = inflater.inflate(R.layout.action_bar_search, null);
            mSearchView = UiUtilities.getView(mSearchContainer, R.id.search_view);
            mSearchView.setSubmitButtonEnabled(false);
            mSearchView.setOnQueryTextListener(mOnQueryText);
            mSearchView.onActionViewExpanded();
            mActionBarCustomView.addView(mSearchContainer);
        }
    }


    /** Must be called from {@link UIControllerBase#onActivityCreated()} */
    public void onActivityCreated() {
        refresh();
    }

    /** Must be called from {@link UIControllerBase#onActivityDestroy()} */
    public void onActivityDestroy() {
        if (mAccountDropdown.isShowing()) {
            mAccountDropdown.dismiss();
        }
    }

    /** Must be called from {@link UIControllerBase#onSaveInstanceState} */
    public void onSaveInstanceState(Bundle outState) {
        mDelayedOperations.removeCallbacks(); // Remove all pending operations
        outState.putInt(BUNDLE_KEY_MODE, mSearchMode);
    }

    /** Must be called from {@link UIControllerBase#onRestoreInstanceState} */
    public void onRestoreInstanceState(Bundle savedState) {
        int mode = savedState.getInt(BUNDLE_KEY_MODE);
        if (mode == MODE_SEARCH) {
            // No need to re-set the initial query, as the View tree restoration does that
            enterSearchMode(null);
        }
    }

    /**
     * @return true if the search box is shown.
     */
    public boolean isInSearchMode() {
        return mSearchMode == MODE_SEARCH;
    }

    /**
     * @return Whether or not the search bar should be shown. This is a function of whether or not a
     *     search is active, and if the current layout supports it.
     */
    private boolean shouldShowSearchBar() {
        return isInSearchMode() && (mTitleMode != Callback.TITLE_MODE_MESSAGE_SUBJECT);
    }

    /**
     * Show the search box.
     *
     * @param initialQueryTerm if non-empty, set to the search box.
     */
    public void enterSearchMode(String initialQueryTerm) {
        initSearchViews();
        if (isInSearchMode()) {
            return;
        }
        if (!TextUtils.isEmpty(initialQueryTerm)) {
            mSearchView.setQuery(initialQueryTerm, false);
        } else {
            mSearchView.setQuery("""", false);
        }
        mSearchView.setQueryHint(mCallback.getSearchHint());

        mSearchMode = MODE_SEARCH;

        // Focus on the search input box and throw up the IME if specified.
        // TODO: HACK. this is a workaround IME not popping up.
        mSearchView.setIconified(false);

        refresh();
        mCallback.onSearchStarted();
    }

    public void exitSearchMode() {
        if (!isInSearchMode()) {
            return;
        }
        mSearchMode = MODE_NORMAL;

        refresh();
        mCallback.onSearchExit();
    }

    /**
     * Performs the back action.
     *
     * @param isSystemBackKey <code>true</code> if the system back key was pressed.
     * <code>false</code> if it's caused by the ""home"" icon click on the action bar.
     */
    public boolean onBackPressed(boolean isSystemBackKey) {
        if (shouldShowSearchBar()) {
            exitSearchMode();
            return true;
        }
        return false;
    }

    /** Refreshes the action bar display. */
    public void refresh() {
        // The actual work is in refreshInernal(), but we don't call it directly here, because:
        // 1. refresh() is called very often.
        // 2. to avoid nested fragment transaction.
        //    refresh is often called during a fragment transaction, but updateTitle() may call
        //    a callback which would initiate another fragment transaction.
        mDelayedOperations.removeCallbacks(mRefreshRunnable);
        mDelayedOperations.post(mRefreshRunnable);
    }

    private final Runnable mRefreshRunnable = new Runnable() {
        @Override public void run() {
            refreshInernal();
        }
    };
    private void refreshInernal() {
        final boolean showUp = isInSearchMode() || mCallback.shouldShowUp();
        mActionBar.setDisplayOptions(showUp
                ? ActionBar.DISPLAY_HOME_AS_UP : 0, ActionBar.DISPLAY_HOME_AS_UP);

        final long accountId = mCallback.getUIAccountId();
        final long mailboxId = mCallback.getMailboxId();
        if ((mLastAccountIdForDirtyCheck != accountId)
                || (mLastMailboxIdForDirtyCheck != mailboxId)) {
            mLastAccountIdForDirtyCheck = accountId;
            mLastMailboxIdForDirtyCheck = mailboxId;

            if (accountId != Account.NO_ACCOUNT) {
                loadAccountMailboxInfo(accountId, mailboxId);
            }
        }

        updateTitle();
    }

    /**
     * Load account/mailbox info, and account/recent mailbox list.
     */
    private void loadAccountMailboxInfo(final long accountId, final long mailboxId) {
        mLoaderManager.restartLoader(LOADER_ID_ACCOUNT_LIST, null,
                new LoaderCallbacks<Cursor>() {
            @Override
            public Loader<Cursor> onCreateLoader(int id, Bundle args) {
                return AccountSelectorAdapter.createLoader(mContext, accountId, mailboxId);
            }

            @Override
            public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
                mCursor = (AccountSelectorAdapter.CursorWithExtras) data;
                updateTitle();
            }

            @Override
            public void onLoaderReset(Loader<Cursor> loader) {
                mCursor = null;
                updateTitle();
            }
        });
    }

    /**
     * Update the ""title"" part.
     */
    private void updateTitle() {
        mAccountsSelectorAdapter.swapCursor(mCursor);

        if (mCursor == null) {
            // Initial load not finished.
            mActionBarCustomView.setVisibility(View.GONE);
            return;
        }
        mActionBarCustomView.setVisibility(View.VISIBLE);

        if (mCursor.getAccountCount() == 0) {
            mCallback.onNoAccountsFound();
            return;
        }

        if ((mCursor.getAccountId() != Account.NO_ACCOUNT) && !mCursor.accountExists()) {
            // Account specified, but does not exist.
            if (isInSearchMode()) {
                exitSearchMode();
            }

            // Switch to the default account.
            mCallback.onAccountSelected(Account.getDefaultAccountId(mContext));
            return;
        }

        mTitleMode = mCallback.getTitleMode();

        if (shouldShowSearchBar()) {
            initSearchViews();
            // In search mode, the search box is a replacement of the account spinner, so ignore
            // the work needed to update that. It will get updated when it goes visible again.
            mAccountSpinnerContainer.setVisibility(View.GONE);
            mSearchContainer.setVisibility(View.VISIBLE);
            return;
        }

        // Account spinner visible.
        mAccountSpinnerContainer.setVisibility(View.VISIBLE);
        UiUtilities.setVisibilitySafe(mSearchContainer, View.GONE);

        if (mTitleMode == Callback.TITLE_MODE_MESSAGE_SUBJECT) {
            mAccountSpinnerLine1View.setSingleLine(false);
            mAccountSpinnerLine1View.setMaxLines(2);
            mAccountSpinnerLine1View.setText(mCallback.getMessageSubject());
            mAccountSpinnerLine2View.setVisibility(View.GONE);

            mAccountSpinnerCountView.setVisibility(View.GONE);

        } else {
            // Get mailbox name
            final String mailboxName;
            if (mTitleMode == Callback.TITLE_MODE_ACCOUNT_WITH_ALL_FOLDERS_LABEL) {
                mailboxName = mAllFoldersLabel;
            } else if (mTitleMode == Callback.TITLE_MODE_ACCOUNT_WITH_MAILBOX) {
                mailboxName = mCursor.getMailboxDisplayName();
            } else {
                mailboxName = null;
            }

            // Note - setSingleLine is needed as well as setMaxLines since they set different
            // flags on the view.
            mAccountSpinnerLine1View.setSingleLine();
            mAccountSpinnerLine1View.setMaxLines(1);
            if (TextUtils.isEmpty(mailboxName)) {
                mAccountSpinnerLine1View.setText(mCursor.getAccountDisplayName());

                // Change the visibility of line 2, so line 1 will be vertically-centered.
                mAccountSpinnerLine2View.setVisibility(View.GONE);
            } else {
                mAccountSpinnerLine1View.setText(mailboxName);
                mAccountSpinnerLine2View.setVisibility(View.VISIBLE);
                mAccountSpinnerLine2View.setText(mCursor.getAccountDisplayName());
            }

            mAccountSpinnerCountView.setVisibility(View.VISIBLE);
            mAccountSpinnerCountView.setText(UiUtilities.getMessageCountForUi(
                    mContext, mCursor.getMailboxMessageCount(), true));
        }

        boolean spinnerEnabled =
            ((mTitleMode & TITLE_MODE_SPINNER_ENABLED) != 0) && mCursor.shouldEnableSpinner();


        setSpinnerEnabled(spinnerEnabled);
    }

    private void setSpinnerEnabled(boolean enabled) {
        if (enabled == mAccountSpinner.isEnabled()) {
            return;
        }

        mAccountSpinner.setEnabled(enabled);
        if (enabled) {
            mAccountSpinner.setBackgroundDrawable(mAccountSpinnerDefaultBackground);
        } else {
            mAccountSpinner.setBackgroundDrawable(null);
        }

        // For some reason, changing the background mucks with the padding so we have to manually
        // reset vertical padding here (also specified in XML, but it seems to be ignored for
        // some reason.
        mAccountSpinner.setPadding(
                mAccountSpinner.getPaddingLeft(),
                0,
                mAccountSpinner.getPaddingRight(),
                0);
    }


    private final SearchView.OnQueryTextListener mOnQueryText
            = new SearchView.OnQueryTextListener() {
        @Override
        public boolean onQueryTextChange(String newText) {
            // Event not handled.  Let the search do the default action.
            return false;
        }

        @Override
        public boolean onQueryTextSubmit(String query) {
            mCallback.onSearchSubmit(mSearchView.getQuery().toString());
            return true; // Event handled.
        }
    };

    private void onAccountSpinnerItemClicked(int position) {
        if (mAccountsSelectorAdapter == null) { // just in case...
            return;
        }
        final long accountId = mAccountsSelectorAdapter.getAccountId(position);

        if (mAccountsSelectorAdapter.isAccountItem(position)) {
            mCallback.onAccountSelected(accountId);
        } else if (mAccountsSelectorAdapter.isMailboxItem(position)) {
            mCallback.onMailboxSelected(accountId,
                    mAccountsSelectorAdapter.getId(position));
        }
    }

    // Based on Spinner.DropdownPopup
    private class AccountDropdownPopup extends ListPopupWindow {
        public AccountDropdownPopup(Context context) {
            super(context);
            setAnchorView(mAccountSpinner);
            setModal(true);
            setPromptPosition(POSITION_PROMPT_ABOVE);
            setOnItemClickListener(new OnItemClickListener() {
                public void onItemClick(AdapterView<?> parent, View v, int position, long id) {
                    onAccountSpinnerItemClicked(position);
                    dismiss();
                }
            });
        }

        @Override
        public void show() {
            setWidth(mContext.getResources().getDimensionPixelSize(
                    R.dimen.account_dropdown_dropdownwidth));
            setInputMethodMode(ListPopupWindow.INPUT_METHOD_NOT_NEEDED);
            super.show();
            // List view is instantiated in super.show(), so we need to do this after...
            getListView().setChoiceMode(ListView.CHOICE_MODE_SINGLE);
        }
    }
}
",False,267,0,0,11,64,3,7,L6
56,com.android.email.activity.EmailActivity.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.Fragment;
import android.content.Intent;
import android.content.res.Configuration;
import android.os.Bundle;
import android.os.Handler;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.TextView;

import com.android.email.Controller;
import com.android.email.ControllerResultUiThreadWrapper;
import com.android.email.Email;
import com.android.email.MessageListContext;
import com.android.email.MessagingExceptionStrings;
import com.android.email.R;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.IntentUtilities;
import com.google.common.base.Preconditions;

import java.util.ArrayList;

/**
 * The main Email activity, which is used on both the tablet and the phone.
 *
 * Because this activity is device agnostic, so most of the UI aren't owned by this, but by
 * the UIController.
 */
public class EmailActivity extends Activity implements View.OnClickListener, FragmentInstallable {
    public static final String EXTRA_ACCOUNT_ID = ""ACCOUNT_ID"";
    public static final String EXTRA_MAILBOX_ID = ""MAILBOX_ID"";
    public static final String EXTRA_MESSAGE_ID = ""MESSAGE_ID"";
    public static final String EXTRA_QUERY_STRING = ""QUERY_STRING"";

    /** Loader IDs starting with this is safe to use from UIControllers. */
    static final int UI_CONTROLLER_LOADER_ID_BASE = 100;

    /** Loader IDs starting with this is safe to use from ActionBarController. */
    static final int ACTION_BAR_CONTROLLER_LOADER_ID_BASE = 200;

    private static float sLastFontScale = -1;

    private Controller mController;
    private Controller.Result mControllerResult;

    private UIControllerBase mUIController;

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    /** Banner to display errors */
    private BannerController mErrorBanner;
    /** Id of the account that had a messaging exception most recently. */
    private long mLastErrorAccountId;

    /**
     * Create an intent to launch and open account's inbox.
     *
     * @param accountId If -1, default account will be used.
     */
    public static Intent createOpenAccountIntent(Activity fromActivity, long accountId) {
        Intent i = IntentUtilities.createRestartAppIntent(fromActivity, EmailActivity.class);
        if (accountId != -1) {
            i.putExtra(EXTRA_ACCOUNT_ID, accountId);
        }
        return i;
    }

    /**
     * Create an intent to launch and open a mailbox.
     *
     * @param accountId must not be -1.
     * @param mailboxId must not be -1.  Magic mailboxes IDs (such as
     * {@link Mailbox#QUERY_ALL_INBOXES}) don't work.
     */
    public static Intent createOpenMailboxIntent(Activity fromActivity, long accountId,
            long mailboxId) {
        if (accountId == -1 || mailboxId == -1) {
            throw new IllegalArgumentException();
        }
        Intent i = IntentUtilities.createRestartAppIntent(fromActivity, EmailActivity.class);
        i.putExtra(EXTRA_ACCOUNT_ID, accountId);
        i.putExtra(EXTRA_MAILBOX_ID, mailboxId);
        return i;
    }

    /**
     * Create an intent to launch and open a message.
     *
     * @param accountId must not be -1.
     * @param mailboxId must not be -1.  Magic mailboxes IDs (such as
     * {@link Mailbox#QUERY_ALL_INBOXES}) don't work.
     * @param messageId must not be -1.
     */
    public static Intent createOpenMessageIntent(Activity fromActivity, long accountId,
            long mailboxId, long messageId) {
        if (accountId == -1 || mailboxId == -1 || messageId == -1) {
            throw new IllegalArgumentException();
        }
        Intent i = IntentUtilities.createRestartAppIntent(fromActivity, EmailActivity.class);
        i.putExtra(EXTRA_ACCOUNT_ID, accountId);
        i.putExtra(EXTRA_MAILBOX_ID, mailboxId);
        i.putExtra(EXTRA_MESSAGE_ID, messageId);
        return i;
    }

    /**
     * Create an intent to launch search activity.
     *
     * @param accountId ID of the account for the mailbox.  Must not be {@link Account#NO_ACCOUNT}.
     * @param mailboxId ID of the mailbox to search, or {@link Mailbox#NO_MAILBOX} to perform
     *     global search.
     * @param query query string.
     */
    public static Intent createSearchIntent(Activity fromActivity, long accountId,
            long mailboxId, String query) {
        Preconditions.checkArgument(Account.isNormalAccount(accountId),
                ""Can only search in normal accounts"");

        // Note that a search doesn't use a restart intent, as we want another instance of
        // the activity to sit on the stack for search.
        Intent i = new Intent(fromActivity, EmailActivity.class);
        i.putExtra(EXTRA_ACCOUNT_ID, accountId);
        i.putExtra(EXTRA_MAILBOX_ID, mailboxId);
        i.putExtra(EXTRA_QUERY_STRING, query);
        i.setAction(Intent.ACTION_SEARCH);
        return i;
    }

    /**
     * Initialize {@link #mUIController}.
     */
    private void initUIController() {
        mUIController = UiUtilities.useTwoPane(this)
                ? new UIControllerTwoPane(this) : new UIControllerOnePane(this);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) Log.d(Logging.LOG_TAG, this + "" onCreate"");

        float fontScale = getResources().getConfiguration().fontScale;
        if (sLastFontScale != -1 && sLastFontScale != fontScale) {
            // If the font scale has been initialized, and has been detected to be different than
            // the last time the Activity ran, it means the user changed the font while no
            // Email Activity was running - we still need to purge static information though.
            onFontScaleChangeDetected();
        }
        sLastFontScale = fontScale;

        // UIController is used in onPrepareOptionsMenu(), which can be called from within
        // super.onCreate(), so we need to initialize it here.
        initUIController();

        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(mUIController.getLayoutId());

        mUIController.onActivityViewReady();

        mController = Controller.getInstance(this);
        mControllerResult = new ControllerResultUiThreadWrapper<ControllerResult>(new Handler(),
                new ControllerResult());
        mController.addResultCallback(mControllerResult);

        // Set up views
        // TODO Probably better to extract mErrorMessageView related code into a separate class,
        // so that it'll be easy to reuse for the phone activities.
        TextView errorMessage = (TextView) findViewById(R.id.error_message);
        errorMessage.setOnClickListener(this);
        int errorBannerHeight = getResources().getDimensionPixelSize(R.dimen.error_message_height);
        mErrorBanner = new BannerController(this, errorMessage, errorBannerHeight);

        if (savedInstanceState != null) {
            mUIController.onRestoreInstanceState(savedInstanceState);
        } else {
            final Intent intent = getIntent();
            final MessageListContext viewContext = MessageListContext.forIntent(this, intent);
            if (viewContext == null) {
                // This might happen if accounts were deleted on another thread, and there aren't
                // any remaining
                Welcome.actionStart(this);
                finish();
                return;
            } else {
                final long messageId = intent.getLongExtra(EXTRA_MESSAGE_ID, Message.NO_MESSAGE);
                mUIController.open(viewContext, messageId);
            }
        }
        mUIController.onActivityCreated();
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);
        mUIController.onSaveInstanceState(outState);
    }

    // FragmentInstallable
    @Override
    public void onInstallFragment(Fragment fragment) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onInstallFragment fragment="" + fragment);
        }
        mUIController.onInstallFragment(fragment);
    }

    // FragmentInstallable
    @Override
    public void onUninstallFragment(Fragment fragment) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onUninstallFragment fragment="" + fragment);
        }
        mUIController.onUninstallFragment(fragment);
    }

    @Override
    protected void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) Log.d(Logging.LOG_TAG, this + "" onStart"");
        super.onStart();
        mUIController.onActivityStart();
    }

    @Override
    protected void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) Log.d(Logging.LOG_TAG, this + "" onResume"");
        super.onResume();
        mUIController.onActivityResume();
        /**
         * In {@link MessageList#onResume()}, we go back to {@link Welcome} if an account
         * has been added/removed. We don't need to do that here, because we fetch the most
         * up-to-date account list. Additionally, we detect and do the right thing if all
         * of the accounts have been removed.
         */
    }

    @Override
    protected void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) Log.d(Logging.LOG_TAG, this + "" onPause"");
        super.onPause();
        mUIController.onActivityPause();
    }

    @Override
    protected void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) Log.d(Logging.LOG_TAG, this + "" onStop"");
        super.onStop();
        mUIController.onActivityStop();
    }

    @Override
    protected void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) Log.d(Logging.LOG_TAG, this + "" onDestroy"");
        mController.removeResultCallback(mControllerResult);
        mTaskTracker.cancellAllInterrupt();
        mUIController.onActivityDestroy();
        super.onDestroy();
    }

    @Override
    public void onBackPressed() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onBackPressed"");
        }
        if (!mUIController.onBackPressed(true)) {
            // Not handled by UIController -- perform the default. i.e. close the app.
            super.onBackPressed();
        }
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.error_message:
                dismissErrorMessage();
                break;
        }
    }

    /**
     * Force dismiss the error banner.
     */
    private void dismissErrorMessage() {
        mErrorBanner.dismiss();
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        return mUIController.onCreateOptionsMenu(getMenuInflater(), menu);
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        return mUIController.onPrepareOptionsMenu(getMenuInflater(), menu);
    }

    /**
     * Called when the search key is pressd.
     *
     * Use the below command to emulate the key press on devices without the search key.
     * adb shell input keyevent 84
     */
    @Override
    public boolean onSearchRequested() {
        if (Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onSearchRequested"");
        }
        mUIController.onSearchRequested();
        return true; // Event handled.
    }

    @Override
    @SuppressWarnings(""deprecation"")
    public boolean onOptionsItemSelected(MenuItem item) {
        if (mUIController.onOptionsItemSelected(item)) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    /**
     * A {@link Controller.Result} to detect connection status.
     */
    private class ControllerResult extends Controller.Result {
        @Override
        public void sendMailCallback(
                MessagingException result, long accountId, long messageId, int progress) {
            handleError(result, accountId, progress);
        }

        @Override
        public void serviceCheckMailCallback(
                MessagingException result, long accountId, long mailboxId, int progress, long tag) {
            handleError(result, accountId, progress);
        }

        @Override
        public void updateMailboxCallback(MessagingException result, long accountId, long mailboxId,
                int progress, int numNewMessages, ArrayList<Long> addedMessages) {
            handleError(result, accountId, progress);
        }

        @Override
        public void updateMailboxListCallback(
                MessagingException result, long accountId, int progress) {
            handleError(result, accountId, progress);
        }

        @Override
        public void loadAttachmentCallback(MessagingException result, long accountId,
                long messageId, long attachmentId, int progress) {
            handleError(result, accountId, progress);
        }

        @Override
        public void loadMessageForViewCallback(MessagingException result, long accountId,
                long messageId, int progress) {
            handleError(result, accountId, progress);
        }

        private void handleError(final MessagingException result, final long accountId,
                int progress) {
            if (accountId == -1) {
                return;
            }
            if (result == null) {
                if (progress > 0) {
                    // Connection now working; clear the error message banner
                    if (mLastErrorAccountId == accountId) {
                        dismissErrorMessage();
                    }
                }
            } else {
                Account account = Account.restoreAccountWithId(EmailActivity.this, accountId);
                if (account == null) return;
                String message =
                    MessagingExceptionStrings.getErrorString(EmailActivity.this, result);
                if (!TextUtils.isEmpty(account.mDisplayName)) {
                    // TODO Use properly designed layout. Don't just concatenate strings;
                    // which is generally poor for I18N.
                    message = message + ""   ("" + account.mDisplayName + "")"";
                }
                if (mErrorBanner.show(message)) {
                    mLastErrorAccountId = accountId;
                }
             }
        }
    }

    /**
     * Handle a change to the system font size. This invalidates some static caches we have.
     */
    private void onFontScaleChangeDetected() {
        MessageListItem.resetDrawingCaches();
    }
}
",True,267,0,0,10,70,6,21,L6
57,com.android.email.activity.ContactStatusLoader.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.AsyncTaskLoader;
import android.content.ContentUris;
import android.content.Context;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.provider.ContactsContract.CommonDataKinds.Email;
import android.provider.ContactsContract.CommonDataKinds.Photo;
import android.provider.ContactsContract.Contacts;
import android.provider.ContactsContract.Data;
import android.provider.ContactsContract.StatusUpdates;
import android.util.Log;

import com.android.emailcommon.Logging;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

/**
 * Loader to load presence statuses and the contact photo.
 */
public class ContactStatusLoader extends AsyncTaskLoader<ContactStatusLoader.Result> {
    @VisibleForTesting
    static final int PRESENCE_UNKNOWN_RESOURCE_ID = android.R.drawable.presence_offline;

    /** email address -> photo id, presence */
    /* package */ static final String[] PROJECTION_PHOTO_ID_PRESENCE = new String[] {
            Contacts.PHOTO_ID,
            Contacts.CONTACT_PRESENCE
            };
    private static final int COLUMN_PHOTO_ID = 0;
    private static final int COLUMN_PRESENCE = 1;

    /** photo id -> photo data */
    /* package */ static final String[] PHOTO_PROJECTION = new String[] {
            Photo.PHOTO
            };
    private static final int PHOTO_COLUMN = 0;

    private final Context mContext;
    private final String mEmailAddress;

    /**
     * Class that encapsulates the result.
     */
    public static class Result {
        public static final Result UNKNOWN = new Result(null, PRESENCE_UNKNOWN_RESOURCE_ID, null);

        /** Contact photo.  Null if unknown */
        public final Bitmap mPhoto;

        /** Presence image resource ID.  Always has a valid value, even if unknown. */
        public final int mPresenceResId;

        /** URI for opening quick contact.  Null if unknown. */
        public final Uri mLookupUri;

        public Result(Bitmap photo, int presenceResId, Uri lookupUri) {
            mPhoto = photo;
            mPresenceResId = presenceResId;
            mLookupUri = lookupUri;
        }

        public boolean isUnknown() {
            return PRESENCE_UNKNOWN_RESOURCE_ID == mPresenceResId;
        }
    }

    public ContactStatusLoader(Context context, String emailAddress) {
        super(context);
        mContext = context;
        mEmailAddress = emailAddress;
    }

    @Override
    public Result loadInBackground() {
        return getContactInfo(mContext, mEmailAddress);
    }

    /**
     * Synchronously loads contact data.
     *
     * NOTE: DO NOT CALL THIS METHOD FROM THE UI THREAD (DATABASE ACCESS)
     */
    public static Result getContactInfo(Context context, String emailAddress) {
        // Load photo-id and presence status.
        Uri uri = Uri.withAppendedPath(Email.CONTENT_LOOKUP_URI, Uri.encode(emailAddress));
        Cursor c = context.getContentResolver().query(
                uri,
                PROJECTION_PHOTO_ID_PRESENCE, null, null, null);
        if (c == null) {
            return Result.UNKNOWN;
        }
        final long photoId;
        final int presenceStatus;
        try {
            if (!c.moveToFirst()) {
                return Result.UNKNOWN;
            }
            photoId = c.getLong(COLUMN_PHOTO_ID);
            presenceStatus = c.getInt(COLUMN_PRESENCE);
        } finally {
            c.close();
        }

        // Convert presence status into the res id.
        final int presenceStatusResId = StatusUpdates.getPresenceIconResourceId(presenceStatus);

        // load photo from photo-id.
        Bitmap photo = null;
        if (photoId != -1) {
            final byte[] photoData = Utility.getFirstRowBlob(context,
                    ContentUris.withAppendedId(Data.CONTENT_URI, photoId), PHOTO_PROJECTION,
                    null, null, null, PHOTO_COLUMN, null);
            if (photoData != null) {
                try {
                    photo = BitmapFactory.decodeByteArray(photoData, 0, photoData.length, null);
                } catch (OutOfMemoryError e) {
                    Log.d(Logging.LOG_TAG, ""Decoding bitmap failed with "" + e.getMessage());
                }
            }
        }

        // Get lookup URI
        final Uri lookupUri = Data.getContactLookupUri(context.getContentResolver(), uri);
        return new Result(photo, presenceStatusResId, lookupUri);
    }

    @Override
    protected void onStartLoading() {
        cancelLoad();
        forceLoad();
    }

    @Override
    protected void onStopLoading() {
        cancelLoad();
    }

    @Override
    protected void onReset() {
        stopLoading();
    }
}
",False,160,7,60,4,6,3,2,L2
58,com.android.email.activity.MailboxFragmentAdapter.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.ContentUris;
import android.content.Context;
import android.content.Loader;
import android.database.Cursor;
import android.database.CursorWrapper;
import android.database.MatrixCursor;
import android.database.MatrixCursor.RowBuilder;
import android.database.MergeCursor;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.CursorAdapter;
import android.widget.ImageView;
import android.widget.TextView;

import com.android.email.Email;
import com.android.email.FolderProperties;
import com.android.email.R;
import com.android.email.ResourceHelper;
import com.android.email.data.ClosingMatrixCursor;
import com.android.email.data.ThrottlingCursorLoader;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.util.ArrayList;

/**
 * Mailbox cursor adapter for the mailbox list fragment.
 *
 * A mailbox cursor may contain one of several different types of data. Currently, this
 * adapter supports the following views:
 * 1. The standard inbox, mailbox view
 * 2. The combined mailbox view
 * 3. Nested folder navigation
 *
 * TODO At a minimum, we should break out the loaders. They have no relation to the view code
 * and only serve to confuse the user.
 * TODO Determine if we actually need a separate adapter / view / loader for nested folder
 * navigation. It's a little convoluted at the moment, but, still manageable.
 */
class MailboxFragmentAdapter extends CursorAdapter {
    /**
     * Callback interface used to report clicks other than the basic list item click or long press.
     */
    interface Callback {
        /** Callback for setting background of mailbox list items during a drag */
        public void onBind(MailboxListItem listItem);
    }

    /** Do-nothing callback to avoid null tests for <code>mCallback</code>. */
    private static final class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();
        @Override public void onBind(MailboxListItem listItem) { }
    }

    /*
     * The type of the row to present to the user. There are 4 defined rows that each
     * have a slightly different look. These are typically used in the constant column
     * {@link #ROW_TYPE} specified in {@link #PROJECTION} and {@link #SUBMAILBOX_PROJECTION}.
     */
    /** Both regular and combined mailboxes */
    private static final int ROW_TYPE_MAILBOX = 0;
    /** Account ""mailboxes"" in the combined view */
    private static final int ROW_TYPE_ACCOUNT = 1;
    // The following types are used when drilling into a mailbox
    /** The current mailbox */
    private static final int ROW_TYPE_CURMAILBOX = 2;
    /** Sub mailboxes */
    private static final int ROW_TYPE_SUBMAILBOX = 3;
    /** Header */
    private static final int ROW_TYPE_HEADER = 4;

    /** The type of data contained in the cursor row. */
    private static final String ROW_TYPE = ""rowType"";
    /** The original ID of the cursor row. May be negative. */
    private static final String ORIGINAL_ID = ""orgMailboxId"";
    /**
     * Projection for a typical mailbox or account row.
     * <p><em>NOTE</em> This projection contains two ID columns. The first, named ""_id"", is used
     * by the framework ListView implementation. Since ListView does not handle negative IDs in
     * this column, we define a ""mailbox_id"" column that contains the real mailbox ID; which
     * may be negative for special mailboxes.
     */
    private static final String[] PROJECTION = new String[] { MailboxColumns.ID,
            MailboxColumns.ID + "" AS "" + ORIGINAL_ID,
            MailboxColumns.DISPLAY_NAME, MailboxColumns.TYPE, MailboxColumns.UNREAD_COUNT,
            MailboxColumns.MESSAGE_COUNT, ROW_TYPE_MAILBOX + "" AS "" + ROW_TYPE,
            MailboxColumns.FLAGS, MailboxColumns.ACCOUNT_KEY };
    /**
     * Projection used to retrieve immediate children for a mailbox. The columns need to
     * be identical to those in {@link #PROJECTION}. We are only changing the constant
     * column {@link #ROW_TYPE}.
     */
    private static final String[] SUBMAILBOX_PROJECTION = new String[] { MailboxColumns.ID,
        MailboxColumns.ID + "" AS "" + ORIGINAL_ID,
        MailboxColumns.DISPLAY_NAME, MailboxColumns.TYPE, MailboxColumns.UNREAD_COUNT,
        MailboxColumns.MESSAGE_COUNT, ROW_TYPE_SUBMAILBOX + "" AS "" + ROW_TYPE,
        MailboxColumns.FLAGS, MailboxColumns.ACCOUNT_KEY };
    private static final String[] CURMAILBOX_PROJECTION = new String[] { MailboxColumns.ID,
        MailboxColumns.ID + "" AS "" + ORIGINAL_ID,
        MailboxColumns.DISPLAY_NAME, MailboxColumns.TYPE, MailboxColumns.UNREAD_COUNT,
        MailboxColumns.MESSAGE_COUNT, ROW_TYPE_CURMAILBOX + "" AS "" + ROW_TYPE,
        MailboxColumns.FLAGS, MailboxColumns.ACCOUNT_KEY };
    /** Project to use for matrix cursors; rows MUST be identical to {@link #PROJECTION} */
    private static final String[] MATRIX_PROJECTION = new String[] {
        MailboxColumns.ID, ORIGINAL_ID, MailboxColumns.DISPLAY_NAME, MailboxColumns.TYPE,
        MailboxColumns.UNREAD_COUNT, MailboxColumns.MESSAGE_COUNT, ROW_TYPE, MailboxColumns.FLAGS,
        MailboxColumns.ACCOUNT_KEY };

    /** All mailboxes for the account */
    private static final String ALL_MAILBOX_SELECTION = MailboxColumns.ACCOUNT_KEY + ""=?"" +
            "" AND "" + Mailbox.USER_VISIBLE_MAILBOX_SELECTION;
    /** All system mailboxes for an account */
    private static final String SYSTEM_MAILBOX_SELECTION = ALL_MAILBOX_SELECTION
            + "" AND "" + MailboxColumns.TYPE + ""!="" + Mailbox.TYPE_MAIL;
    /** All mailboxes with the given parent */
    private static final String USER_MAILBOX_SELECTION_WITH_PARENT = ALL_MAILBOX_SELECTION
            + "" AND "" + MailboxColumns.PARENT_KEY + ""=?""
            + "" AND "" + MailboxColumns.TYPE + ""="" + Mailbox.TYPE_MAIL;
    /** Selection for a specific mailbox */
    private static final String MAILBOX_SELECTION = MailboxColumns.ACCOUNT_KEY + ""=?""
            + "" AND "" + MailboxColumns.ID + ""=?"";

    private static final String MAILBOX_ORDER_BY = ""CASE "" + MailboxColumns.TYPE
            + "" WHEN "" + Mailbox.TYPE_INBOX   + "" THEN 0""
            + "" WHEN "" + Mailbox.TYPE_DRAFTS  + "" THEN 1""
            + "" WHEN "" + Mailbox.TYPE_OUTBOX  + "" THEN 2""
            + "" WHEN "" + Mailbox.TYPE_SENT    + "" THEN 3""
            + "" WHEN "" + Mailbox.TYPE_TRASH   + "" THEN 4""
            + "" WHEN "" + Mailbox.TYPE_JUNK    + "" THEN 5""
            // Other mailboxes (i.e. of Mailbox.TYPE_MAIL) are shown in alphabetical order.
            + "" ELSE 10 END""
            + "" ,"" + MailboxColumns.DISPLAY_NAME;

    /** View is of a ""normal"" row */
    private static final int ITEM_VIEW_TYPE_NORMAL = 0;
    /** View is of a separator row */
    private static final int ITEM_VIEW_TYPE_HEADER = AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER;

    private static boolean sEnableUpdate = true;
    private final LayoutInflater mInflater;
    private final ResourceHelper mResourceHelper;
    private final Callback mCallback;

    public MailboxFragmentAdapter(Context context, Callback callback) {
        super(context, null, 0 /* flags; no content observer */);
        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
        mResourceHelper = ResourceHelper.getInstance(context);
    }

    @Override
    public int getViewTypeCount() {
        return 2;
    }

    @Override
    public int getItemViewType(int position) {
        return isHeader(position) ? ITEM_VIEW_TYPE_HEADER : ITEM_VIEW_TYPE_NORMAL;
    }

    @Override
    public boolean isEnabled(int position) {
        return !isHeader(position);
    }

    // The LabelList has headers which are not
    // enabled.
    @Override
    public boolean areAllItemsEnabled() {
        return false;
    }

    @Override
    public void bindView(View view, Context context, Cursor cursor) {
        if (view instanceof MailboxListItem) {
            bindListItem(view, context, cursor);
        } else {
            bindListHeader(view, context, cursor);
        }
    }

    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
        if (cursor.getInt(cursor.getColumnIndex(ROW_TYPE)) == ROW_TYPE_HEADER) {
            return mInflater.inflate(R.layout.mailbox_list_header, parent, false);
        }
        return mInflater.inflate(R.layout.mailbox_list_item, parent, false);
    }

    private boolean isHeader(int position) {
        Cursor c = getCursor();
        if ((c == null) || c.isClosed()) {
            return false;
        }
        c.moveToPosition(position);
        int rowType = c.getInt(c.getColumnIndex(ROW_TYPE));
        return rowType == ROW_TYPE_HEADER;
    }

    /** Returns {@code true} if the specified row is of an account in the combined view. */
    boolean isAccountRow(int position) {
        return isAccountRow((Cursor) getItem(position));
    }

    /**
     * Returns {@code true} if the specified row is a mailbox.
     * ({@link #ROW_TYPE_MAILBOX}, {@link #ROW_TYPE_CURMAILBOX} and {@link #ROW_TYPE_SUBMAILBOX})
     */
    boolean isMailboxRow(int position) {
        return isMailboxRow((Cursor) getItem(position));
    }

    /** Returns {@code true} if the current row is of an account in the combined view. */
    private static boolean isAccountRow(Cursor cursor) {
        return getRowType(cursor) == ROW_TYPE_ACCOUNT;
    }

    /** Returns {@code true} if the current row is a header */
    private static boolean isHeaderRow(Cursor cursor) {
        return getRowType(cursor) == ROW_TYPE_HEADER;
    }

    /**
     * Returns {@code true} if the current row is a mailbox.
     * ({@link #ROW_TYPE_MAILBOX}, {@link #ROW_TYPE_CURMAILBOX} and {@link #ROW_TYPE_SUBMAILBOX})
     */
    private static boolean isMailboxRow(Cursor cursor) {
        return !(isAccountRow(cursor) || isHeaderRow(cursor));
    }

    /**
     * Returns the ID of the given row. It may be a mailbox or account ID depending upon the
     * result of {@link #isAccountRow}.
     */
    long getId(int position) {
        Cursor c = (Cursor) getItem(position);
        return getId(c);
    }

    /**
     * Returns the account ID of the mailbox owner for the given row. If the given row is a
     * combined mailbox, {@link Account#ACCOUNT_ID_COMBINED_VIEW} is returned. If the given
     * row is an account, returns the account's ID [the same as {@link #ORIGINAL_ID}].
     */
    long getAccountId(int position) {
        Cursor c = (Cursor) getItem(position);
        return getAccountId(c);
    }

    /**
     * Turn on and off list updates; during a drag operation, we do NOT want to the list of
     * mailboxes to update, as this would be visually jarring
     * @param state whether or not the MailboxList can be updated
     */
    static void enableUpdates(boolean state) {
        sEnableUpdate = state;
    }

    private static String getDisplayName(Context context, Cursor cursor) {
        final String name = cursor.getString(cursor.getColumnIndex(MailboxColumns.DISPLAY_NAME));
        if (isHeaderRow(cursor) || isAccountRow(cursor)) {
            // Always use actual name
            return name;
        } else {
            // Use this method for two purposes:
            // - Set combined mailbox names
            // - Rewrite special mailbox names (e.g. trash)
            FolderProperties fp = FolderProperties.getInstance(context);
            return fp.getDisplayName(getType(cursor), getId(cursor), name);
        }
    }

    static long getId(Cursor cursor) {
        return cursor.getLong(cursor.getColumnIndex(ORIGINAL_ID));
    }

    static int getType(Cursor cursor) {
        return cursor.getInt(cursor.getColumnIndex(MailboxColumns.TYPE));
    }

    static int getMessageCount(Cursor cursor) {
        return cursor.getInt(cursor.getColumnIndex(MailboxColumns.MESSAGE_COUNT));
    }

    static int getUnreadCount(Cursor cursor) {
        return cursor.getInt(cursor.getColumnIndex(MailboxColumns.UNREAD_COUNT));
    }

    static long getAccountId(Cursor cursor) {
        return cursor.getLong(cursor.getColumnIndex(MailboxColumns.ACCOUNT_KEY));
    }

    private static int getRowType(Cursor cursor) {
        return cursor.getInt(cursor.getColumnIndex(ROW_TYPE));
    }

    private static int getFlags(Cursor cursor) {
        return cursor.getInt(cursor.getColumnIndex(MailboxColumns.FLAGS));
    }

    /**
     * {@link Cursor} with extra information which is returned by the loader created by
     * {@link MailboxFragmentAdapter#createMailboxesLoader}.
     */
    static class CursorWithExtras extends CursorWrapper {
        /**
         * The number of mailboxes in the cursor if the cursor contains top-level mailboxes.
         * Otherwise, the number of *child* mailboxes.
         */
        public final int mChildCount;

        CursorWithExtras(Cursor cursor, int childCount) {
            super(cursor);
            mChildCount = childCount;
        }
    }

    private void bindListHeader(View view, Context context, Cursor cursor) {
        final TextView nameView = (TextView) view.findViewById(R.id.display_name);
        nameView.setText(getDisplayName(context, cursor));
    }

    private void bindListItem(View view, Context context, Cursor cursor) {
        final boolean isAccount = isAccountRow(cursor);
        final int type = getType(cursor);
        final long id = getId(cursor);
        final long accountId = getAccountId(cursor);
        final int flags = getFlags(cursor);
        final int rowType = getRowType(cursor);
        final boolean hasVisibleChildren = (flags & Mailbox.FLAG_HAS_CHILDREN) != 0
                && (flags & Mailbox.FLAG_CHILDREN_VISIBLE) != 0;

        MailboxListItem listItem = (MailboxListItem)view;
        listItem.mMailboxId = isAccountRow(cursor) ? Mailbox.NO_MAILBOX : id;
        listItem.mMailboxType = type;
        listItem.mAccountId = accountId;
        listItem.mIsValidDropTarget = (id >= 0)
                && !Utility.arrayContains(Mailbox.INVALID_DROP_TARGETS, type)
                && (flags & Mailbox.FLAG_ACCEPTS_MOVED_MAIL) != 0;
        listItem.mIsNavigable = hasVisibleChildren;

        listItem.mAdapter = this;
        // Set the background depending on whether we're in drag mode, the mailbox is a valid
        // target, etc.
        mCallback.onBind(listItem);

        // Set mailbox name
        final TextView nameView = (TextView) view.findViewById(R.id.mailbox_name);
        nameView.setText(getDisplayName(context, cursor));
        // Set count
        final int count;
        if (isAccountRow(cursor)) {
            count = getUnreadCount(cursor);
        } else {
            FolderProperties fp = FolderProperties.getInstance(context);
            count = fp.getMessageCount(type, getUnreadCount(cursor), getMessageCount(cursor));
        }
        final TextView countView = (TextView) view.findViewById(R.id.message_count);

        // Set folder icon
        final ImageView folderIcon = (ImageView) view.findViewById(R.id.folder_icon);
        folderIcon.setImageDrawable(
                FolderProperties.getInstance(context).getIcon(type, id, flags));

        final ImageView mailboxExpandedIcon =
                (ImageView) view.findViewById(R.id.folder_expanded_icon);
        switch (rowType) {
            case ROW_TYPE_SUBMAILBOX:
                if (hasVisibleChildren) {
                    mailboxExpandedIcon.setVisibility(View.VISIBLE);
                    mailboxExpandedIcon.setImageResource(
                            R.drawable.ic_mailbox_collapsed_holo_light);
                } else {
                    mailboxExpandedIcon.setVisibility(View.INVISIBLE);
                    mailboxExpandedIcon.setImageDrawable(null);
                }
                folderIcon.setVisibility(View.INVISIBLE);
                break;
            case ROW_TYPE_CURMAILBOX:
                mailboxExpandedIcon.setVisibility(View.GONE);
                mailboxExpandedIcon.setImageDrawable(null);
                folderIcon.setVisibility(View.GONE);
                break;
            case ROW_TYPE_MAILBOX:
            default: // Includes ROW_TYPE_ACCOUNT
                if (hasVisibleChildren) {
                    mailboxExpandedIcon.setVisibility(View.VISIBLE);
                    mailboxExpandedIcon.setImageResource(
                            R.drawable.ic_mailbox_collapsed_holo_light);
                } else {
                    mailboxExpandedIcon.setVisibility(View.GONE);
                    mailboxExpandedIcon.setImageDrawable(null);
                }
                folderIcon.setVisibility(View.VISIBLE);
                break;
        }

        // If the unread count is zero, not to show countView.
        if (count > 0) {
            countView.setVisibility(View.VISIBLE);
            countView.setText(Integer.toString(count));
        } else {
            countView.setVisibility(View.GONE);
        }

        final View chipView = view.findViewById(R.id.color_chip);
        if (isAccount) {
            chipView.setVisibility(View.VISIBLE);
            chipView.setBackgroundColor(mResourceHelper.getAccountColor(id));
        } else {
            chipView.setVisibility(View.GONE);
        }
    }

    /**
     * Returns a cursor loader for the mailboxes of the given account.  If <code>parentKey</code>
     * refers to a valid mailbox ID [e.g. non-zero], restrict the loader to only those mailboxes
     * contained by this parent mailbox.
     *
     * Note the returned loader always returns a {@link CursorWithExtras}.
     */
    static Loader<Cursor> createMailboxesLoader(Context context, long accountId,
            long parentMailboxId) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""MailboxFragmentAdapter#CursorWithExtras accountId="" + accountId
                    + "" parentMailboxId="" + parentMailboxId);
        }
        if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
            throw new IllegalArgumentException();
        }
        return new MailboxFragmentLoader(context, accountId, parentMailboxId);
    }

    /**
     * Returns a cursor loader for the combined view.
     */
    static Loader<Cursor> createCombinedViewLoader(Context context) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""MailboxFragmentAdapter#createCombinedViewLoader"");
        }
        return new CombinedMailboxLoader(context);
    }

    /**
     * Adds a new row into the given cursor.
     */
    private static void addMailboxRow(MatrixCursor cursor, long mailboxId, String displayName,
            int mailboxType, int unreadCount, int messageCount, int rowType, int flags,
            long accountId) {
        long listId = mailboxId;
        if (mailboxId < 0) {
            listId = Long.MAX_VALUE + mailboxId; // IDs for the list view must be positive
        }
        RowBuilder row = cursor.newRow();
        row.add(listId);
        row.add(mailboxId);
        row.add(displayName);
        row.add(mailboxType);
        row.add(unreadCount);
        row.add(messageCount);
        row.add(rowType);
        row.add(flags);
        row.add(accountId);
    }

    private static void addCombinedMailboxRow(Context context, MatrixCursor cursor, long id,
            int mailboxType, boolean showAlways) {
        if (id >= 0) {
            throw new IllegalArgumentException(); // Must be QUERY_ALL_*, which are all negative
        }
        int count = FolderProperties.getMessageCountForCombinedMailbox(context, id);
        if (showAlways || (count > 0)) {
            addMailboxRow(
                    cursor, id, """", mailboxType, count, count, ROW_TYPE_MAILBOX, Mailbox.FLAG_NONE,
                    Account.ACCOUNT_ID_COMBINED_VIEW);
        }
    }

    /**
     * Loads mailboxes that are the children of a given mailbox ID.
     *
     * The returned {@link Cursor} is always a {@link CursorWithExtras}.
     */
    private static class MailboxFragmentLoader extends ThrottlingCursorLoader {
        private final Context mContext;
        private final long mAccountId;
        private final long mParentKey;

        MailboxFragmentLoader(Context context, long accountId, long parentKey) {
            super(context, Mailbox.CONTENT_URI,
                    (parentKey != Mailbox.NO_MAILBOX)
                            ? SUBMAILBOX_PROJECTION
                            : PROJECTION,
                    USER_MAILBOX_SELECTION_WITH_PARENT,
                    new String[] { Long.toString(accountId), Long.toString(parentKey) },
                    MAILBOX_ORDER_BY);
            mContext = context;
            mAccountId = accountId;
            mParentKey = parentKey;
        }

        @Override
        public void onContentChanged() {
            if (sEnableUpdate) {
                super.onContentChanged();
            }
        }

        @Override
        public Cursor loadInBackground() {
            boolean parentRemoved = false;

            final Cursor userMailboxCursor = super.loadInBackground();
            final Cursor returnCursor;

            final int childCount = userMailboxCursor.getCount();

            if (mParentKey != Mailbox.NO_MAILBOX) {
                // If we're not showing the top level mailboxes, add the ""parent"" mailbox.
                final Cursor parentCursor = getContext().getContentResolver().query(
                        Mailbox.CONTENT_URI, CURMAILBOX_PROJECTION, MAILBOX_SELECTION,
                        new String[] { Long.toString(mAccountId), Long.toString(mParentKey) },
                        null);
                returnCursor = new MergeCursor(new Cursor[] { parentCursor, userMailboxCursor });
            } else {
                // TODO Add per-account starred mailbox support
                final MatrixCursor starredCursor = new MatrixCursor(MATRIX_PROJECTION);
                final Cursor systemMailboxCursor = mContext.getContentResolver().query(
                        Mailbox.CONTENT_URI, PROJECTION, SYSTEM_MAILBOX_SELECTION,
                        new String[] { Long.toString(mAccountId) }, MAILBOX_ORDER_BY);
                final MatrixCursor recentCursor = new MatrixCursor(MATRIX_PROJECTION);
                final MatrixCursor headerCursor = new MatrixCursor(MATRIX_PROJECTION);
                if (childCount > 0) {
                    final String name = mContext.getString(R.string.mailbox_list_user_mailboxes);
                    addMailboxRow(headerCursor, 0L, name, 0, 0, 0, ROW_TYPE_HEADER, 0, 0L);
                }
                ArrayList<Long> recentList = null;
                boolean useTwoPane = UiUtilities.useTwoPane(mContext);
                if (useTwoPane) {
                    recentList = RecentMailboxManager.getInstance(mContext)
                            .getMostRecent(mAccountId, true);
                }
                if (recentList != null && recentList.size() > 0) {
                    final String name = mContext.getString(R.string.mailbox_list_recent_mailboxes);
                    addMailboxRow(recentCursor, 0L, name, 0, 0, 0, ROW_TYPE_HEADER, 0, 0L);
                    for (long mailboxId : recentList) {
                        final Mailbox mailbox = Mailbox.restoreMailboxWithId(mContext, mailboxId);
                        if (mailbox == null) continue;
                        final int messageCount = Utility.getFirstRowInt(mContext,
                            ContentUris.withAppendedId(Mailbox.CONTENT_URI, mailboxId),
                            new String[] { MailboxColumns.MESSAGE_COUNT }, null, null, null, 0);
                        final int unreadCount = Utility.getFirstRowInt(mContext,
                            ContentUris.withAppendedId(Mailbox.CONTENT_URI, mailboxId),
                            new String[] { MailboxColumns.UNREAD_COUNT }, null, null, null, 0);
                        addMailboxRow(recentCursor, mailboxId, mailbox.mDisplayName, mailbox.mType,
                            unreadCount, messageCount, ROW_TYPE_MAILBOX, mailbox.mFlags,
                            mailbox.mAccountKey);
                    }
                }
                int accountStarredCount = Message.getFavoriteMessageCount(mContext, mAccountId);
                if (accountStarredCount > 0) {
                    // Only add ""Starred"", if there is at least one starred message
                    addCombinedMailboxRow(mContext, starredCursor, Mailbox.QUERY_ALL_FAVORITES,
                            Mailbox.TYPE_MAIL, true);
                }
                returnCursor = new MergeCursor(new Cursor[] {
                        starredCursor, systemMailboxCursor, recentCursor, headerCursor,
                        userMailboxCursor, });
            }
            return new CursorWithExtras(returnCursor, childCount);
        }
    }

    /**
     * Loader for mailboxes in ""Combined view"".
     */
    @VisibleForTesting
    static class CombinedMailboxLoader extends ThrottlingCursorLoader {
        private static final String[] ACCOUNT_PROJECTION = new String[] {
            EmailContent.RECORD_ID, AccountColumns.DISPLAY_NAME,
        };
        private static final int COLUMN_ACCOUND_ID = 0;
        private static final int COLUMN_ACCOUNT_DISPLAY_NAME = 1;

        private final Context mContext;

        private CombinedMailboxLoader(Context context) {
            super(context, Account.CONTENT_URI, ACCOUNT_PROJECTION, null, null, null);
            mContext = context;
        }

        @Override
        public Cursor loadInBackground() {
            final Cursor accounts = super.loadInBackground();

            // Build combined mailbox rows.
            final MatrixCursor returnCursor = buildCombinedMailboxes(mContext, accounts);

            // Add account rows.
            accounts.moveToPosition(-1);
            while (accounts.moveToNext()) {
                final long accountId = accounts.getLong(COLUMN_ACCOUND_ID);
                final String accountName = accounts.getString(COLUMN_ACCOUNT_DISPLAY_NAME);
                final int unreadCount = Mailbox.getUnreadCountByAccountAndMailboxType(
                        mContext, accountId, Mailbox.TYPE_INBOX);
                addMailboxRow(returnCursor, accountId, accountName, Mailbox.TYPE_NONE,
                        unreadCount, unreadCount, ROW_TYPE_ACCOUNT, Mailbox.FLAG_NONE,
                        accountId);
            }
            return returnCursor;
        }

        @VisibleForTesting
        static MatrixCursor buildCombinedMailboxes(Context c, Cursor innerCursor) {
            MatrixCursor cursor = new ClosingMatrixCursor(MATRIX_PROJECTION, innerCursor);
            // Combined inbox -- show unread count
            addCombinedMailboxRow(c, cursor, Mailbox.QUERY_ALL_INBOXES, Mailbox.TYPE_INBOX, true);

            // Favorite (starred) -- show # of favorites
            addCombinedMailboxRow(c, cursor, Mailbox.QUERY_ALL_FAVORITES, Mailbox.TYPE_MAIL, false);

            // Drafts -- show # of drafts
            addCombinedMailboxRow(c, cursor, Mailbox.QUERY_ALL_DRAFTS, Mailbox.TYPE_DRAFTS, false);

            // Outbox -- # of outstanding messages
            addCombinedMailboxRow(c, cursor, Mailbox.QUERY_ALL_OUTBOX, Mailbox.TYPE_OUTBOX, false);

            return cursor;
        }
    }
}
",True,268,1,1,11,44,3,13,L6
59,com.android.email.activity.UIControllerBase.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.Fragment;
import android.app.FragmentManager;
import android.app.FragmentTransaction;
import android.os.Bundle;
import android.util.Log;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;

import com.android.email.Email;
import com.android.email.FolderProperties;
import com.android.email.MessageListContext;
import com.android.email.Preferences;
import com.android.email.R;
import com.android.email.RefreshManager;
import com.android.email.RequireManualSyncDialog;
import com.android.email.activity.setup.AccountSettings;
import com.android.email.activity.setup.MailboxSettings;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;

import java.util.LinkedList;
import java.util.List;

/**
 * Base class for the UI controller.
 */
abstract class UIControllerBase implements MailboxListFragment.Callback,
        MessageListFragment.Callback, MessageViewFragment.Callback  {
    static final boolean DEBUG_FRAGMENTS = false; // DO NOT SUBMIT WITH TRUE

    static final String KEY_LIST_CONTEXT = ""UIControllerBase.listContext"";

    /** The owner activity */
    final EmailActivity mActivity;
    final FragmentManager mFragmentManager;

    protected final ActionBarController mActionBarController;

    private MessageOrderManager mOrderManager;
    private final MessageOrderManagerCallback mMessageOrderManagerCallback =
            new MessageOrderManagerCallback();

    final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    final RefreshManager mRefreshManager;

    /**
     * Fragments that are installed.
     *
     * A fragment is installed in {@link Fragment#onActivityCreated} and uninstalled in
     * {@link Fragment#onDestroyView}, using {@link FragmentInstallable} callbacks.
     *
     * This means fragments in the back stack are *not* installed.
     *
     * We set callbacks to fragments only when they are installed.
     *
     * @see FragmentInstallable
     */
    private MailboxListFragment mMailboxListFragment;
    private MessageListFragment mMessageListFragment;
    private MessageViewFragment mMessageViewFragment;

    /**
     * To avoid double-deleting a fragment (which will cause a runtime exception),
     * we put a fragment in this list when we {@link FragmentTransaction#remove(Fragment)} it,
     * and remove from the list when we actually uninstall it.
     */
    private final List<Fragment> mRemovedFragments = new LinkedList<Fragment>();

    /**
     * The NfcHandler implements Near Field Communication sharing features
     * whenever the activity is in the foreground.
     */
    private NfcHandler mNfcHandler;

    /**
     * The active context for the current MessageList.
     * In some UI layouts such as the one-pane view, the message list may not be visible, but is
     * on the backstack. This list context will still be accessible in those cases.
     *
     * Should be set using {@link #setListContext(MessageListContext)}.
     */
    protected MessageListContext mListContext;

    private class RefreshListener implements RefreshManager.Listener {
        private MenuItem mRefreshIcon;

        @Override
        public void onMessagingError(final long accountId, long mailboxId, final String message) {
            updateRefreshIcon();
        }

        @Override
        public void onRefreshStatusChanged(long accountId, long mailboxId) {
            updateRefreshIcon();
        }

        void setRefreshIcon(MenuItem icon) {
            mRefreshIcon = icon;
            updateRefreshIcon();
        }

        private void updateRefreshIcon() {
            if (mRefreshIcon == null) {
                return;
            }

            if (isRefreshInProgress()) {
                mRefreshIcon.setActionView(R.layout.action_bar_indeterminate_progress);
            } else {
                mRefreshIcon.setActionView(null);
            }
        }
    };

    private final RefreshListener mRefreshListener = new RefreshListener();

    public UIControllerBase(EmailActivity activity) {
        mActivity = activity;
        mFragmentManager = activity.getFragmentManager();
        mRefreshManager = RefreshManager.getInstance(mActivity);
        mActionBarController = createActionBarController(activity);
        if (DEBUG_FRAGMENTS) {
            FragmentManager.enableDebugLogging(true);
        }
    }

    /**
     * Called by the base class to let a subclass create an {@link ActionBarController}.
     */
    protected abstract ActionBarController createActionBarController(Activity activity);

    /** @return the layout ID for the activity. */
    public abstract int getLayoutId();

    /**
     * Must be called just after the activity sets up the content view.  Used to initialize views.
     *
     * (Due to the complexity regarding class/activity initialization order, we can't do this in
     * the constructor.)
     */
    public void onActivityViewReady() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityViewReady"");
        }
    }

    /**
     * Called at the end of {@link EmailActivity#onCreate}.
     */
    public void onActivityCreated() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityCreated"");
        }
        mRefreshManager.registerListener(mRefreshListener);
        mActionBarController.onActivityCreated();
        mNfcHandler = NfcHandler.register(this, mActivity);
    }

    /**
     * Handles the {@link android.app.Activity#onStart} callback.
     */
    public void onActivityStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityStart"");
        }
        if (isMessageViewInstalled()) {
            updateMessageOrderManager();
        }
    }

    /**
     * Handles the {@link android.app.Activity#onResume} callback.
     */
    public void onActivityResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityResume"");
        }
        refreshActionBar();
        if (mNfcHandler != null) {
            mNfcHandler.onAccountChanged();  // workaround for email not set on initial load
        }
        long accountId = getUIAccountId();
        Preferences.getPreferences(mActivity).setLastUsedAccountId(accountId);
        showAccountSpecificWarning(accountId);
    }

    /**
     * Handles the {@link android.app.Activity#onPause} callback.
     */
    public void onActivityPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityPause"");
        }
    }

    /**
     * Handles the {@link android.app.Activity#onStop} callback.
     */
    public void onActivityStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityStop"");
        }
        stopMessageOrderManager();
    }

    /**
     * Handles the {@link android.app.Activity#onDestroy} callback.
     */
    public void onActivityDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityDestroy"");
        }
        mActionBarController.onActivityDestroy();
        mRefreshManager.unregisterListener(mRefreshListener);
        mTaskTracker.cancellAllInterrupt();
    }

    /**
     * Handles the {@link android.app.Activity#onSaveInstanceState} callback.
     */
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onSaveInstanceState"");
        }
        mActionBarController.onSaveInstanceState(outState);
        outState.putParcelable(KEY_LIST_CONTEXT, mListContext);
    }

    /**
     * Handles the {@link android.app.Activity#onRestoreInstanceState} callback.
     */
    public void onRestoreInstanceState(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" restoreInstanceState"");
        }
        mActionBarController.onRestoreInstanceState(savedInstanceState);
        mListContext = savedInstanceState.getParcelable(KEY_LIST_CONTEXT);
    }

    // MessageViewFragment$Callback
    @Override
    public void onMessageSetUnread() {
        doAutoAdvance();
    }

    // MessageViewFragment$Callback
    @Override
    public void onMessageNotExists() {
        doAutoAdvance();
    }

    // MessageViewFragment$Callback
    @Override
    public void onRespondedToInvite(int response) {
        doAutoAdvance();
    }

    // MessageViewFragment$Callback
    @Override
    public void onBeforeMessageGone() {
        doAutoAdvance();
    }

    /**
     * Install a fragment.  Must be caleld from the host activity's
     * {@link FragmentInstallable#onInstallFragment}.
     */
    public final void onInstallFragment(Fragment fragment) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onInstallFragment  fragment="" + fragment);
        }
        if (fragment instanceof MailboxListFragment) {
            installMailboxListFragment((MailboxListFragment) fragment);
        } else if (fragment instanceof MessageListFragment) {
            installMessageListFragment((MessageListFragment) fragment);
        } else if (fragment instanceof MessageViewFragment) {
            installMessageViewFragment((MessageViewFragment) fragment);
        } else {
            throw new IllegalArgumentException(""Tried to install unknown fragment"");
        }
    }

    /** Install fragment */
    protected void installMailboxListFragment(MailboxListFragment fragment) {
        mMailboxListFragment = fragment;
        mMailboxListFragment.setCallback(this);

        // TODO: consolidate this refresh with the one that the Fragment itself does. since
        // the fragment calls setHasOptionsMenu(true) - it invalidates when it gets attached.
        // However the timing is slightly different and leads to a delay in update if this isn't
        // here - investigate why. same for the other installs.
        refreshActionBar();
    }

    /** Install fragment */
    protected void installMessageListFragment(MessageListFragment fragment) {
        mMessageListFragment = fragment;
        mMessageListFragment.setCallback(this);
        refreshActionBar();
    }

    /** Install fragment */
    protected void installMessageViewFragment(MessageViewFragment fragment) {
        mMessageViewFragment = fragment;
        mMessageViewFragment.setCallback(this);

        updateMessageOrderManager();
        refreshActionBar();
    }

    /**
     * Uninstall a fragment.  Must be caleld from the host activity's
     * {@link FragmentInstallable#onUninstallFragment}.
     */
    public final void onUninstallFragment(Fragment fragment) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onUninstallFragment  fragment="" + fragment);
        }
        mRemovedFragments.remove(fragment);
        if (fragment == mMailboxListFragment) {
            uninstallMailboxListFragment();
        } else if (fragment == mMessageListFragment) {
            uninstallMessageListFragment();
        } else if (fragment == mMessageViewFragment) {
            uninstallMessageViewFragment();
        } else {
            throw new IllegalArgumentException(""Tried to uninstall unknown fragment"");
        }
    }

    /** Uninstall {@link MailboxListFragment} */
    protected void uninstallMailboxListFragment() {
        mMailboxListFragment.setCallback(null);
        mMailboxListFragment = null;
    }

    /** Uninstall {@link MessageListFragment} */
    protected void uninstallMessageListFragment() {
        mMessageListFragment.setCallback(null);
        mMessageListFragment = null;
    }

    /** Uninstall {@link MessageViewFragment} */
    protected void uninstallMessageViewFragment() {
        mMessageViewFragment.setCallback(null);
        mMessageViewFragment = null;
    }

    /**
     * If a {@link Fragment} is not already in {@link #mRemovedFragments},
     * {@link FragmentTransaction#remove} it and add to the list.
     *
     * Do nothing if {@code fragment} is null.
     */
    protected final void removeFragment(FragmentTransaction ft, Fragment fragment) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" removeFragment fragment="" + fragment);
        }
        if (fragment == null) {
            return;
        }
        if (!mRemovedFragments.contains(fragment)) {
            // Remove try/catch when b/4981556 is fixed (framework bug)
            try {
                ft.remove(fragment);
            } catch (IllegalStateException ex) {
                Log.e(Logging.LOG_TAG, ""Swalling IllegalStateException due to known bug for ""
                        + "" fragment: "" + fragment, ex);
                Log.e(Logging.LOG_TAG, Utility.dumpFragment(fragment));
            }
            addFragmentToRemovalList(fragment);
        }
    }

    /**
     * Remove a {@link Fragment} from {@link #mRemovedFragments}.  No-op if {@code fragment} is
     * null.
     *
     * {@link #removeMailboxListFragment}, {@link #removeMessageListFragment} and
     * {@link #removeMessageViewFragment} all call this, so subclasses don't have to do this when
     * using them.
     *
     * However, unfortunately, subclasses have to call this manually when popping from the
     * back stack to avoid double-delete.
     */
    protected void addFragmentToRemovalList(Fragment fragment) {
        if (fragment != null) {
            mRemovedFragments.add(fragment);
        }
    }

    /**
     * Remove the fragment if it's installed.
     */
    protected FragmentTransaction removeMailboxListFragment(FragmentTransaction ft) {
        removeFragment(ft, mMailboxListFragment);
        return ft;
    }

    /**
     * Remove the fragment if it's installed.
     */
    protected FragmentTransaction removeMessageListFragment(FragmentTransaction ft) {
        removeFragment(ft, mMessageListFragment);
        return ft;
    }

    /**
     * Remove the fragment if it's installed.
     */
    protected FragmentTransaction removeMessageViewFragment(FragmentTransaction ft) {
        removeFragment(ft, mMessageViewFragment);
        return ft;
    }

    /** @return true if a {@link MailboxListFragment} is installed. */
    protected final boolean isMailboxListInstalled() {
        return mMailboxListFragment != null;
    }

    /** @return true if a {@link MessageListFragment} is installed. */
    protected final boolean isMessageListInstalled() {
        return mMessageListFragment != null;
    }

    /** @return true if a {@link MessageViewFragment} is installed. */
    protected final boolean isMessageViewInstalled() {
        return mMessageViewFragment != null;
    }

    /** @return the installed {@link MailboxListFragment} or null. */
    protected final MailboxListFragment getMailboxListFragment() {
        return mMailboxListFragment;
    }

    /** @return the installed {@link MessageListFragment} or null. */
    protected final MessageListFragment getMessageListFragment() {
        return mMessageListFragment;
    }

    /** @return the installed {@link MessageViewFragment} or null. */
    protected final MessageViewFragment getMessageViewFragment() {
        return mMessageViewFragment;
    }

    /**
     * Commit a {@link FragmentTransaction}.
     */
    protected void commitFragmentTransaction(FragmentTransaction ft) {
        if (DEBUG_FRAGMENTS) {
            Log.d(Logging.LOG_TAG, this + "" commitFragmentTransaction: "" + ft);
        }
        if (!ft.isEmpty()) {
            // NB: there should be no cases in which a transaction is committed after
            // onSaveInstanceState. Unfortunately, the ""state loss"" check also happens when in
            // LoaderCallbacks.onLoadFinished, and we wish to perform transactions there. The check
            // by the framework is conservative and prevents cases where there are transactions
            // affecting Loader lifecycles - but we have no such cases.
            // TODO: use asynchronous callbacks from loaders to avoid this implicit dependency
            ft.commitAllowingStateLoss();
            mFragmentManager.executePendingTransactions();
        }
    }

    /**
     * @return the currently selected account ID, *or* {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
     *
     * @see #getActualAccountId()
     */
    public abstract long getUIAccountId();

    /**
     * @return true if an account is selected, or the current view is the combined view.
     */
    public final boolean isAccountSelected() {
        return getUIAccountId() != Account.NO_ACCOUNT;
    }

    /**
     * @return if an actual account is selected.  (i.e. {@link Account#ACCOUNT_ID_COMBINED_VIEW}
     * is not considered ""actual"".s)
     */
    public final boolean isActualAccountSelected() {
        return isAccountSelected() && (getUIAccountId() != Account.ACCOUNT_ID_COMBINED_VIEW);
    }

    /**
     * @return the currently selected account ID.  If the current view is the combined view,
     * it'll return {@link Account#NO_ACCOUNT}.
     *
     * @see #getUIAccountId()
     */
    public final long getActualAccountId() {
        return isActualAccountSelected() ? getUIAccountId() : Account.NO_ACCOUNT;
    }

    /**
     * Show the default view for the given account.
     *
     * @param accountId ID of the account to load.  Can be {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
     *     Must never be {@link Account#NO_ACCOUNT}.
     * @param forceShowInbox If {@code false} and the given account is already selected, do nothing.
     *        If {@code false}, we always change the view even if the account is selected.
     */
    public final void switchAccount(long accountId, boolean forceShowInbox) {

        if (Account.isSecurityHold(mActivity, accountId)) {
            ActivityHelper.showSecurityHoldDialog(mActivity, accountId);
            mActivity.finish();
            return;
        }

        if (accountId == getUIAccountId() && !forceShowInbox) {
            // Do nothing if the account is already selected.  Not even going back to the inbox.
            return;
        }
        if (accountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
            openMailbox(accountId, Mailbox.QUERY_ALL_INBOXES);
        } else {
            long inboxId = Mailbox.findMailboxOfType(mActivity, accountId, Mailbox.TYPE_INBOX);
            if (inboxId == Mailbox.NO_MAILBOX) {
                // The account doesn't have Inbox yet... Redirect to Welcome and let it wait for
                // the initial sync...
                Log.w(Logging.LOG_TAG, ""Account "" + accountId +"" doesn't have Inbox.  Redirecting""
                        + "" to Welcome..."");
                Welcome.actionOpenAccountInbox(mActivity, accountId);
                mActivity.finish();
            } else {
                openMailbox(accountId, inboxId);
            }
        }
        if (mNfcHandler != null) {
            mNfcHandler.onAccountChanged();
        }
        Preferences.getPreferences(mActivity).setLastUsedAccountId(accountId);
        showAccountSpecificWarning(accountId);
    }

    /**
     * Returns the id of the parent mailbox used for the mailbox list fragment.
     *
     * IMPORTANT: Do not confuse {@link #getMailboxListMailboxId()} with
     *     {@link #getMessageListMailboxId()}
     */
    protected long getMailboxListMailboxId() {
        return isMailboxListInstalled() ? getMailboxListFragment().getSelectedMailboxId()
                : Mailbox.NO_MAILBOX;
    }

    /**
     * Returns the id of the mailbox used for the message list fragment.
     *
     * IMPORTANT: Do not confuse {@link #getMailboxListMailboxId()} with
     *     {@link #getMessageListMailboxId()}
     */
    protected long getMessageListMailboxId() {
        return isMessageListInstalled() ? getMessageListFragment().getMailboxId()
                : Mailbox.NO_MAILBOX;
    }

    /**
     * Shortcut for {@link #open} with {@link Message#NO_MESSAGE}.
     */
    protected final void openMailbox(long accountId, long mailboxId) {
        open(MessageListContext.forMailbox(accountId, mailboxId), Message.NO_MESSAGE);
    }

    /**
     * Opens a given list
     * @param listContext the list context for the message list to open
     * @param messageId if specified and not {@link Message#NO_MESSAGE}, will open the message
     *     in the message list.
     */
    public final void open(final MessageListContext listContext, final long messageId) {
        setListContext(listContext);
        openInternal(listContext, messageId);

        if (listContext.isSearch()) {
            mActionBarController.enterSearchMode(listContext.getSearchParams().mFilter);
        }
    }

    /**
     * Sets the internal value of the list context for the message list.
     */
    protected void setListContext(MessageListContext listContext) {
        if (Objects.equal(listContext, mListContext)) {
            return;
        }

        if (Email.DEBUG && Logging.DEBUG_LIFECYCLE) {
            Log.i(Logging.LOG_TAG, this + "" setListContext: "" + listContext);
        }
        mListContext = listContext;
    }

    protected abstract void openInternal(
            final MessageListContext listContext, final long messageId);

    /**
     * Performs the back action.
     *
     * @param isSystemBackKey <code>true</code> if the system back key was pressed.
     * <code>false</code> if it's caused by the ""home"" icon click on the action bar.
     */
    public abstract boolean onBackPressed(boolean isSystemBackKey);

    public void onSearchStarted() {
        // Show/hide the original search icon.
        mActivity.invalidateOptionsMenu();
    }

    /**
     * Must be called from {@link Activity#onSearchRequested()}.
     * This initiates the search entry mode - see {@link #onSearchSubmit} for when the search
     * is actually submitted.
     */
    public void onSearchRequested() {
        long accountId = getActualAccountId();
        boolean accountSearchable = false;
        if (accountId > 0) {
            Account account = Account.restoreAccountWithId(mActivity, accountId);
            if (account != null) {
                String protocol = account.getProtocol(mActivity);
                accountSearchable = (account.mFlags & Account.FLAGS_SUPPORTS_SEARCH) != 0;
            }
        }

        if (!accountSearchable) {
            return;
        }

        if (isMessageListReady()) {
            mActionBarController.enterSearchMode(null);
        }
    }

    /**
     * @return Whether or not a message list is ready and has its initial meta data loaded.
     */
    protected boolean isMessageListReady() {
        return isMessageListInstalled() && getMessageListFragment().hasDataLoaded();
    }

    /**
     * Determines the mailbox to search, if a search was to be initiated now.
     * This will return {@code null} if the UI is not focused on any particular mailbox to search
     * on.
     */
    private Mailbox getSearchableMailbox() {
        if (!isMessageListReady()) {
            return null;
        }
        MessageListFragment messageList = getMessageListFragment();

        // If already in a search, future searches will search the original mailbox.
        return mListContext.isSearch()
                ? messageList.getSearchedMailbox()
                : messageList.getMailbox();
    }

    // TODO: this logic probably needs to be tested in the backends as well, so it may be nice
    // to consolidate this to a centralized place, so that they don't get out of sync.
    /**
     * @return whether or not this account should do a global search instead when a user
     *     initiates a search on the given mailbox.
     */
    private static boolean shouldDoGlobalSearch(Account account, Mailbox mailbox) {
        return ((account.mFlags & Account.FLAGS_SUPPORTS_GLOBAL_SEARCH) != 0)
                && (mailbox.mType == Mailbox.TYPE_INBOX);
    }

    /**
     * Retrieves the hint text to be shown for when a search entry is being made.
     */
    protected String getSearchHint() {
        if (!isMessageListReady()) {
            return """";
        }
        Account account = getMessageListFragment().getAccount();
        Mailbox mailbox = getSearchableMailbox();

        if (mailbox == null) {
            return """";
        }

        if (shouldDoGlobalSearch(account, mailbox)) {
            return mActivity.getString(R.string.search_hint);
        }

        // Regular mailbox, or IMAP - search within that mailbox.
        String mailboxName = FolderProperties.getInstance(mActivity).getDisplayName(mailbox);
        return String.format(
                mActivity.getString(R.string.search_mailbox_hint),
                mailboxName);
    }

    /**
     * Kicks off a search query, if the UI is in a state where a search is possible.
     */
    protected void onSearchSubmit(final String queryTerm) {
        final long accountId = getUIAccountId();
        if (!Account.isNormalAccount(accountId)) {
            return; // Invalid account to search from.
        }

        Mailbox searchableMailbox = getSearchableMailbox();
        if (searchableMailbox == null) {
            return;
        }
        final long mailboxId = searchableMailbox.mId;

        if (Email.DEBUG) {
            Log.d(Logging.LOG_TAG,
                    ""Submitting search: ["" + queryTerm + ""] in mailboxId="" + mailboxId);
        }

        mActivity.startActivity(EmailActivity.createSearchIntent(
                mActivity, accountId, mailboxId, queryTerm));


        // TODO: this causes a slight flicker.
        // A new instance of the activity will sit on top. When the user exits search and
        // returns to this activity, the search box should not be open then.
        mActionBarController.exitSearchMode();
    }

    /**
     * Handles exiting of search entry mode.
     */
    protected void onSearchExit() {
        if ((mListContext != null) && mListContext.isSearch()) {
            mActivity.finish();
        } else {
            // Re show the search icon.
            mActivity.invalidateOptionsMenu();
        }
    }

    /**
     * Handles the {@link android.app.Activity#onCreateOptionsMenu} callback.
     */
    public boolean onCreateOptionsMenu(MenuInflater inflater, Menu menu) {
        inflater.inflate(R.menu.email_activity_options, menu);
        return true;
    }

    /**
     * Handles the {@link android.app.Activity#onPrepareOptionsMenu} callback.
     */
    public boolean onPrepareOptionsMenu(MenuInflater inflater, Menu menu) {
        // Update the refresh button.
        MenuItem item = menu.findItem(R.id.refresh);
        if (isRefreshEnabled()) {
            item.setVisible(true);
            mRefreshListener.setRefreshIcon(item);
        } else {
            item.setVisible(false);
            mRefreshListener.setRefreshIcon(null);
        }

        // Deal with protocol-specific menu options.
        boolean mailboxHasServerCounterpart = false;
        boolean accountSearchable = false;
        boolean isEas = false;

        if (isMessageListReady()) {
            long accountId = getActualAccountId();
            if (accountId > 0) {
                Account account = Account.restoreAccountWithId(mActivity, accountId);
                if (account != null) {
                    String protocol = account.getProtocol(mActivity);
                    isEas = HostAuth.SCHEME_EAS.equals(protocol);
                    Mailbox mailbox = getMessageListFragment().getMailbox();
                    mailboxHasServerCounterpart = (mailbox != null)
                            && mailbox.loadsFromServer(protocol);
                    accountSearchable = (account.mFlags & Account.FLAGS_SUPPORTS_SEARCH) != 0;
                }
            }
        }

        boolean showSearchIcon = !mActionBarController.isInSearchMode()
                && accountSearchable && mailboxHasServerCounterpart;

        menu.findItem(R.id.search).setVisible(showSearchIcon);
        menu.findItem(R.id.mailbox_settings).setVisible(isEas && mailboxHasServerCounterpart);
        return true;
    }

    /**
     * Handles the {@link android.app.Activity#onOptionsItemSelected} callback.
     *
     * @return true if the option item is handled.
     */
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                // Comes from the action bar when the app icon on the left is pressed.
                // It works like a back press, but it won't close the activity.
                return onBackPressed(false);
            case R.id.compose:
                return onCompose();
            case R.id.refresh:
                onRefresh();
                return true;
            case R.id.account_settings:
                return onAccountSettings();
            case R.id.search:
                onSearchRequested();
                return true;
            case R.id.mailbox_settings:
                final long mailboxId = getMailboxSettingsMailboxId();
                if (mailboxId != Mailbox.NO_MAILBOX) {
                    MailboxSettings.start(mActivity, mailboxId);
                }
                return true;
        }
        return false;
    }

    /**
     * Opens the message compose activity.
     */
    private boolean onCompose() {
        if (!isAccountSelected()) {
            return false; // this shouldn't really happen
        }
        MessageCompose.actionCompose(mActivity, getActualAccountId());
        return true;
    }

    /**
     * Handles the ""Settings"" option item.  Opens the settings activity.
     */
    private boolean onAccountSettings() {
        AccountSettings.actionSettings(mActivity, getActualAccountId());
        return true;
    }

    /**
     * @return the ID of the message in focus and visible, if any. Returns
     *     {@link Message#NO_MESSAGE} if no message is opened.
     */
    protected long getMessageId() {
        return isMessageViewInstalled()
                ? getMessageViewFragment().getMessageId()
                : Message.NO_MESSAGE;
    }


    /**
     * @return mailbox ID for ""mailbox settings"" option.
     */
    protected abstract long getMailboxSettingsMailboxId();

    /**
     * Performs ""refesh"".
     */
    protected abstract void onRefresh();

    /**
     * @return true if refresh is in progress for the current mailbox.
     */
    protected abstract boolean isRefreshInProgress();

    /**
     * @return true if the UI should enable the ""refresh"" command.
     */
    protected abstract boolean isRefreshEnabled();

    /**
     * Refresh the action bar and menu items, including the ""refreshing"" icon.
     */
    protected void refreshActionBar() {
        if (mActionBarController != null) {
            mActionBarController.refresh();
        }
        mActivity.invalidateOptionsMenu();
    }

    // MessageListFragment.Callback
    @Override
    public void onMailboxNotFound(boolean isFirstLoad) {
        // Something bad happened - the account or mailbox we were looking for was deleted.
        // Just restart and let the entry flow find a good default view.
        if (isFirstLoad) {
            // Only show this if it's the first load (e.g. a shortcut) rather an a return to
            // a mailbox (which might be in a just-deleted account)
            Utility.showToast(mActivity, R.string.toast_mailbox_not_found);
        }
        long accountId = getUIAccountId();
        if (accountId != Account.NO_ACCOUNT) {
            mActivity.startActivity(Welcome.createOpenAccountInboxIntent(mActivity, accountId));
        } else {
            Welcome.actionStart(mActivity);

        }
        mActivity.finish();
    }

    protected final MessageOrderManager getMessageOrderManager() {
        return mOrderManager;
    }

    /** Perform ""auto-advance. */
    protected final void doAutoAdvance() {
        switch (Preferences.getPreferences(mActivity).getAutoAdvanceDirection()) {
            case Preferences.AUTO_ADVANCE_NEWER:
                if (moveToNewer()) return;
                break;
            case Preferences.AUTO_ADVANCE_OLDER:
                if (moveToOlder()) return;
                break;
        }
        if (isMessageViewInstalled()) { // We really should have the message view but just in case
            // Go back to mailbox list.
            // Use onBackPressed(), so we'll restore the message view state, such as scroll
            // position.
            // Also make sure to pass false to isSystemBackKey, so on two-pane we don't go back
            // to the collapsed mode.
            onBackPressed(true);
        }
    }

    /**
     * Subclass must implement it to enable/disable the newer/older buttons.
     */
    protected abstract void updateNavigationArrows();

    protected final boolean moveToOlder() {
        if ((mOrderManager != null) && mOrderManager.moveToOlder()) {
            navigateToMessage(mOrderManager.getCurrentMessageId());
            return true;
        }
        return false;
    }

    protected final boolean moveToNewer() {
        if ((mOrderManager != null) && mOrderManager.moveToNewer()) {
            navigateToMessage(mOrderManager.getCurrentMessageId());
            return true;
        }
        return false;
    }

    /**
     * Called when the user taps newer/older.  Subclass must implement it to open the specified
     * message.
     *
     * It's a bit different from just showing the message view fragment; on one-pane we show the
     * message view fragment but don't want to change back state.
     */
    protected abstract void navigateToMessage(long messageId);

    /**
     * Potentially create a new {@link MessageOrderManager}; if it's not already started or if
     * the account has changed, and sync it to the current message.
     */
    private void updateMessageOrderManager() {
        if (!isMessageViewInstalled()) {
            return;
        }
        Preconditions.checkNotNull(mListContext);

        if (mOrderManager == null || !mOrderManager.getListContext().equals(mListContext)) {
            stopMessageOrderManager();
            mOrderManager = new MessageOrderManager(
                    mActivity, mListContext, mMessageOrderManagerCallback);
        }
        mOrderManager.moveTo(getMessageId());
        updateNavigationArrows();
    }

    /**
     * Stop {@link MessageOrderManager}.
     */
    protected final void stopMessageOrderManager() {
        if (mOrderManager != null) {
            mOrderManager.close();
            mOrderManager = null;
        }
    }

    private class MessageOrderManagerCallback implements MessageOrderManager.Callback {
        @Override
        public void onMessagesChanged() {
            updateNavigationArrows();
        }

        @Override
        public void onMessageNotFound() {
            doAutoAdvance();
        }
    }


    private void showAccountSpecificWarning(long accountId) {
        if (accountId != Account.NO_ACCOUNT && accountId != Account.NO_ACCOUNT) {
            Account account = Account.restoreAccountWithId(mActivity, accountId);
            if (account != null &&
                    Preferences.getPreferences(mActivity)
                    .shouldShowRequireManualSync(mActivity, account)) {
                new RequireManualSyncDialog(mActivity, account).show();
            }
        }
    }

    @Override
    public String toString() {
        return getClass().getSimpleName(); // Shown on logcat
    }
}
",True,267,0,0,11,60,4,26,L6
60,com.android.email.activity.UIControllerTwoPane.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.FragmentTransaction;
import android.content.Context;
import android.os.Bundle;
import android.util.Log;

import com.android.email.Clock;
import com.android.email.Email;
import com.android.email.MessageListContext;
import com.android.email.Preferences;
import com.android.email.R;
import com.android.email.RefreshManager;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.util.Set;

/**
 * UI Controller for x-large devices.  Supports a multi-pane layout.
 *
 * Note: Always use {@link #commitFragmentTransaction} to operate fragment transactions,
 * so that we can easily switch between synchronous and asynchronous transactions.
 */
class UIControllerTwoPane extends UIControllerBase implements ThreePaneLayout.Callback {
    @VisibleForTesting
    static final int MAILBOX_REFRESH_MIN_INTERVAL = 30 * 1000; // in milliseconds

    @VisibleForTesting
    static final int INBOX_AUTO_REFRESH_MIN_INTERVAL = 10 * 1000; // in milliseconds

    // Other UI elements
    private ThreePaneLayout mThreePane;

    private MessageCommandButtonView mMessageCommandButtons;

    public UIControllerTwoPane(EmailActivity activity) {
        super(activity);
    }

    @Override
    public int getLayoutId() {
        return R.layout.email_activity_two_pane;
    }

    // ThreePaneLayoutCallback
    @Override
    public void onVisiblePanesChanged(int previousVisiblePanes) {
        // If the right pane is gone, remove the message view.
        final int visiblePanes = mThreePane.getVisiblePanes();

        if (((visiblePanes & ThreePaneLayout.PANE_RIGHT) == 0) &&
                ((previousVisiblePanes & ThreePaneLayout.PANE_RIGHT) != 0)) {
            // Message view just got hidden
            unselectMessage();
        }
        // Disable CAB when the message list is not visible.
        if (isMessageListInstalled()) {
            getMessageListFragment().onHidden((visiblePanes & ThreePaneLayout.PANE_MIDDLE) == 0);
        }
        refreshActionBar();
    }

    // MailboxListFragment$Callback
    @Override
    public void onMailboxSelected(long accountId, long mailboxId, boolean nestedNavigation) {
        setListContext(MessageListContext.forMailbox(accountId, mailboxId));
        if (getMessageListMailboxId() != mListContext.getMailboxId()) {
            updateMessageList(true);
        }
    }

    // MailboxListFragment$Callback
    @Override
    public void onAccountSelected(long accountId) {
        // It's from combined view, so ""forceShowInbox"" doesn't really matter.
        // (We're always switching accounts.)
        switchAccount(accountId, true);
    }

    // MailboxListFragment$Callback
    @Override
    public void onParentMailboxChanged() {
        refreshActionBar();
    }

    // MessageListFragment$Callback
    @Override
    public void onMessageOpen(long messageId, long messageMailboxId, long listMailboxId,
            int type) {
        if (type == MessageListFragment.Callback.TYPE_DRAFT) {
            MessageCompose.actionEditDraft(mActivity, messageId);
        } else {
            if (getMessageId() != messageId) {
                navigateToMessage(messageId);
                mThreePane.showRightPane();
            }
        }
    }

    // MessageListFragment$Callback
    /**
     * Apply the auto-advance policy upon initation of a batch command that could potentially
     * affect the currently selected conversation.
     */
    @Override
    public void onAdvancingOpAccepted(Set<Long> affectedMessages) {
        if (!isMessageViewInstalled()) {
            // Do nothing if message view is not visible.
            return;
        }

        final MessageOrderManager orderManager = getMessageOrderManager();
        int autoAdvanceDir = Preferences.getPreferences(mActivity).getAutoAdvanceDirection();
        if ((autoAdvanceDir == Preferences.AUTO_ADVANCE_MESSAGE_LIST) || (orderManager == null)) {
            if (affectedMessages.contains(getMessageId())) {
                goBackToMailbox();
            }
            return;
        }

        // Navigate to the first unselected item in the appropriate direction.
        switch (autoAdvanceDir) {
            case Preferences.AUTO_ADVANCE_NEWER:
                while (affectedMessages.contains(orderManager.getCurrentMessageId())) {
                    if (!orderManager.moveToNewer()) {
                        goBackToMailbox();
                        return;
                    }
                }
                navigateToMessage(orderManager.getCurrentMessageId());
                break;

            case Preferences.AUTO_ADVANCE_OLDER:
                while (affectedMessages.contains(orderManager.getCurrentMessageId())) {
                    if (!orderManager.moveToOlder()) {
                        goBackToMailbox();
                        return;
                    }
                }
                navigateToMessage(orderManager.getCurrentMessageId());
                break;
        }
    }

    // MessageListFragment$Callback
    @Override
    public boolean onDragStarted() {
        if (Email.DEBUG) {
            Log.i(Logging.LOG_TAG, ""Drag started"");
        }

        if (((mListContext != null) && mListContext.isSearch())
                || !mThreePane.isLeftPaneVisible()) {
            // D&D not allowed.
            return false;
        }

        return true;
    }

    // MessageListFragment$Callback
    @Override
    public void onDragEnded() {
        if (Email.DEBUG) {
            Log.i(Logging.LOG_TAG, ""Drag ended"");
        }
    }


    // MessageViewFragment$Callback
    @Override
    public boolean onUrlInMessageClicked(String url) {
        return ActivityHelper.openUrlInMessage(mActivity, url, getActualAccountId());
    }

    // MessageViewFragment$Callback
    @Override
    public void onLoadMessageStarted() {
    }

    // MessageViewFragment$Callback
    @Override
    public void onLoadMessageFinished() {
    }

    // MessageViewFragment$Callback
    @Override
    public void onLoadMessageError(String errorMessage) {
    }

    // MessageViewFragment$Callback
    @Override
    public void onCalendarLinkClicked(long epochEventStartTime) {
        ActivityHelper.openCalendar(mActivity, epochEventStartTime);
    }

    // MessageViewFragment$Callback
    @Override
    public void onForward() {
        MessageCompose.actionForward(mActivity, getMessageId());
    }

    // MessageViewFragment$Callback
    @Override
    public void onReply() {
        MessageCompose.actionReply(mActivity, getMessageId(), false);
    }

    // MessageViewFragment$Callback
    @Override
    public void onReplyAll() {
        MessageCompose.actionReply(mActivity, getMessageId(), true);
    }

    /**
     * Must be called just after the activity sets up the content view.
     */
    @Override
    public void onActivityViewReady() {
        super.onActivityViewReady();

        // Set up content
        mThreePane = (ThreePaneLayout) mActivity.findViewById(R.id.three_pane);
        mThreePane.setCallback(this);

        mMessageCommandButtons = mThreePane.getMessageCommandButtons();
        mMessageCommandButtons.setCallback(new CommandButtonCallback());
    }

    @Override
    protected ActionBarController createActionBarController(Activity activity) {
        return new ActionBarController(activity, activity.getLoaderManager(),
                activity.getActionBar(), new ActionBarControllerCallback());
    }

    /**
     * @return the currently selected account ID, *or* {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
     *
     * @see #getActualAccountId()
     */
    @Override
    public long getUIAccountId() {
        return isMailboxListInstalled() ? getMailboxListFragment().getAccountId()
                :Account.NO_ACCOUNT;
    }

    @Override
    public long getMailboxSettingsMailboxId() {
        return getMessageListMailboxId();
    }

    /**
     * @return true if refresh is in progress for the current mailbox.
     */
    @Override
    protected boolean isRefreshInProgress() {
        long messageListMailboxId = getMessageListMailboxId();
        return (messageListMailboxId >= 0)
                && mRefreshManager.isMessageListRefreshing(messageListMailboxId);
    }

    /**
     * @return true if the UI should enable the ""refresh"" command.
     */
    @Override
    protected boolean isRefreshEnabled() {
        return getActualAccountId() != Account.NO_ACCOUNT
                && (mListContext.getMailboxId() > 0);
    }


    /** {@inheritDoc} */
    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
    }

    /** {@inheritDoc} */
    @Override
    public void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);
    }

    @Override
    protected void installMessageListFragment(MessageListFragment fragment) {
        super.installMessageListFragment(fragment);

        if (isMailboxListInstalled()) {
            getMailboxListFragment().setHighlightedMailbox(fragment.getMailboxId());
        }
        getMessageListFragment().setLayout(mThreePane);
    }

    @Override
    protected void installMessageViewFragment(MessageViewFragment fragment) {
        super.installMessageViewFragment(fragment);

        if (isMessageListInstalled()) {
            getMessageListFragment().setSelectedMessage(fragment.getMessageId());
        }
    }

    @Override
    public void openInternal(final MessageListContext listContext, final long messageId) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" open "" + listContext);
        }

        final FragmentTransaction ft = mFragmentManager.beginTransaction();
        updateMailboxList(ft, true);
        updateMessageList(ft, true);

        if (messageId != Message.NO_MESSAGE) {
            updateMessageView(ft, messageId);
            mThreePane.showRightPane();
        } else if (mListContext.isSearch()) {
            mThreePane.showRightPane();
            mThreePane.uncollapsePane();
        } else {
            mThreePane.showLeftPane();
        }
        commitFragmentTransaction(ft);
    }

    /**
     * Loads the given account and optionally selects the given mailbox and message. If the
     * specified account is already selected, no actions will be performed unless
     * <code>forceReload</code> is <code>true</code>.
     *
     * @param ft {@link FragmentTransaction} to use.
     * @param clearDependentPane if true, the message list and the message view will be cleared
     */
    private void updateMailboxList(FragmentTransaction ft, boolean clearDependentPane) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" updateMailboxList "" + mListContext);
        }

        long accountId = mListContext.mAccountId;
        long mailboxId = mListContext.getMailboxId();
        if ((getUIAccountId() != accountId) || (getMailboxListMailboxId() != mailboxId)) {
            removeMailboxListFragment(ft);
            boolean enableHighlight = !mListContext.isSearch();
            ft.add(mThreePane.getLeftPaneId(),
                    MailboxListFragment.newInstance(accountId, mailboxId, enableHighlight));
        }
        if (clearDependentPane) {
            removeMessageListFragment(ft);
            removeMessageViewFragment(ft);
        }
    }

    /**
     * Go back to a mailbox list view. If a message view is currently active, it will
     * be hidden.
     */
    private void goBackToMailbox() {
        if (isMessageViewInstalled()) {
            mThreePane.showLeftPane(); // Show mailbox list
        }
    }

    /**
     * Show the message list fragment for the given mailbox.
     *
     * @param ft {@link FragmentTransaction} to use.
     */
    private void updateMessageList(FragmentTransaction ft, boolean clearDependentPane) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" updateMessageList "" + mListContext);
        }

        if (mListContext.getMailboxId() != getMessageListMailboxId()) {
            removeMessageListFragment(ft);
            ft.add(mThreePane.getMiddlePaneId(), MessageListFragment.newInstance(mListContext));
        }
        if (clearDependentPane) {
            removeMessageViewFragment(ft);
        }
    }

    /**
     * Shortcut to call {@link #updateMessageList(FragmentTransaction, boolean)} and
     * commit.
     */
    private void updateMessageList(boolean clearDependentPane) {
        FragmentTransaction ft = mFragmentManager.beginTransaction();
        updateMessageList(ft, clearDependentPane);
        commitFragmentTransaction(ft);
    }

    /**
     * Show a message on the message view.
     *
     * @param ft {@link FragmentTransaction} to use.
     * @param messageId ID of the mailbox to load. Must never be {@link Message#NO_MESSAGE}.
     */
    private void updateMessageView(FragmentTransaction ft, long messageId) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" updateMessageView messageId="" + messageId);
        }
        if (messageId == Message.NO_MESSAGE) {
            throw new IllegalArgumentException();
        }

        if (messageId == getMessageId()) {
            return; // nothing to do.
        }

        removeMessageViewFragment(ft);

        ft.add(mThreePane.getRightPaneId(), MessageViewFragment.newInstance(messageId));
    }

    /**
     * Shortcut to call {@link #updateMessageView(FragmentTransaction, long)} and commit.
     */
    @Override protected void navigateToMessage(long messageId) {
        FragmentTransaction ft = mFragmentManager.beginTransaction();
        updateMessageView(ft, messageId);
        commitFragmentTransaction(ft);
    }

    /**
     * Remove the message view if shown.
     */
    private void unselectMessage() {
        commitFragmentTransaction(removeMessageViewFragment(mFragmentManager.beginTransaction()));
        if (isMessageListInstalled()) {
            getMessageListFragment().setSelectedMessage(Message.NO_MESSAGE);
        }
        stopMessageOrderManager();
    }

    private class CommandButtonCallback implements MessageCommandButtonView.Callback {
        @Override
        public void onMoveToNewer() {
            moveToNewer();
        }

        @Override
        public void onMoveToOlder() {
            moveToOlder();
        }
    }

    /**
     * Disable/enable the move-to-newer/older buttons.
     */
    @Override protected void updateNavigationArrows() {
        final MessageOrderManager orderManager = getMessageOrderManager();
        if (orderManager == null) {
            // shouldn't happen, but just in case
            mMessageCommandButtons.enableNavigationButtons(false, false, 0, 0);
        } else {
            mMessageCommandButtons.enableNavigationButtons(
                    orderManager.canMoveToNewer(), orderManager.canMoveToOlder(),
                    orderManager.getCurrentPosition(), orderManager.getTotalMessageCount());
        }
    }

    /** {@inheritDoc} */
    @Override
    public boolean onBackPressed(boolean isSystemBackKey) {
        if (!mThreePane.isPaneCollapsible()) {
            if (mActionBarController.onBackPressed(isSystemBackKey)) {
                return true;
            }

            if (mThreePane.showLeftPane()) {
                return true;
            }
        } else {
            // If it's not the system back key, always attempt to uncollapse the left pane first.
            if (!isSystemBackKey && mThreePane.uncollapsePane()) {
                return true;
            }

            if (mActionBarController.onBackPressed(isSystemBackKey)) {
                return true;
            }

            if (mThreePane.showLeftPane()) {
                return true;
            }
        }

        if (isMailboxListInstalled() && getMailboxListFragment().navigateUp()) {
            return true;
        }
        return false;
    }

    @Override
    protected void onRefresh() {
        // Cancel previously running instance if any.
        new RefreshTask(mTaskTracker, mActivity, getActualAccountId(),
                getMessageListMailboxId()).cancelPreviousAndExecuteParallel();
    }

    /**
     * Class to handle refresh.
     *
     * When the user press ""refresh"",
     * <ul>
     *   <li>Refresh the current mailbox, if it's refreshable.  (e.g. don't refresh combined inbox,
     *       drafts, etc.
     *   <li>Refresh the mailbox list, if it hasn't been refreshed in the last
     *       {@link #MAILBOX_REFRESH_MIN_INTERVAL}.
     *   <li>Refresh inbox, if it's not the current mailbox and it hasn't been refreshed in the last
     *       {@link #INBOX_AUTO_REFRESH_MIN_INTERVAL}.
     * </ul>
     */
    @VisibleForTesting
    static class RefreshTask extends EmailAsyncTask<Void, Void, Boolean> {
        private final Clock mClock;
        private final Context mContext;
        private final long mAccountId;
        private final long mMailboxId;
        private final RefreshManager mRefreshManager;
        @VisibleForTesting
        long mInboxId;

        public RefreshTask(EmailAsyncTask.Tracker tracker, Context context, long accountId,
                long mailboxId) {
            this(tracker, context, accountId, mailboxId, Clock.INSTANCE,
                    RefreshManager.getInstance(context));
        }

        @VisibleForTesting
        RefreshTask(EmailAsyncTask.Tracker tracker, Context context, long accountId,
                long mailboxId, Clock clock, RefreshManager refreshManager) {
            super(tracker);
            mClock = clock;
            mContext = context;
            mRefreshManager = refreshManager;
            mAccountId = accountId;
            mMailboxId = mailboxId;
        }

        /**
         * Do DB access on a worker thread.
         */
        @Override
        protected Boolean doInBackground(Void... params) {
            mInboxId = Account.getInboxId(mContext, mAccountId);
            return Mailbox.isRefreshable(mContext, mMailboxId);
        }

        /**
         * Do the actual refresh.
         */
        @Override
        protected void onSuccess(Boolean isCurrentMailboxRefreshable) {
            if (isCurrentMailboxRefreshable == null) {
                return;
            }
            if (isCurrentMailboxRefreshable) {
                mRefreshManager.refreshMessageList(mAccountId, mMailboxId, true);
            }
            // Refresh mailbox list
            if (mAccountId != Account.NO_ACCOUNT) {
                if (shouldRefreshMailboxList()) {
                    mRefreshManager.refreshMailboxList(mAccountId);
                }
            }
            // Refresh inbox
            if (shouldAutoRefreshInbox()) {
                mRefreshManager.refreshMessageList(mAccountId, mInboxId, true);
            }
        }

        /**
         * @return true if the mailbox list of the current account hasn't been refreshed
         * in the last {@link #MAILBOX_REFRESH_MIN_INTERVAL}.
         */
        @VisibleForTesting
        boolean shouldRefreshMailboxList() {
            if (mRefreshManager.isMailboxListRefreshing(mAccountId)) {
                return false;
            }
            final long nextRefreshTime = mRefreshManager.getLastMailboxListRefreshTime(mAccountId)
                    + MAILBOX_REFRESH_MIN_INTERVAL;
            if (nextRefreshTime > mClock.getTime()) {
                return false;
            }
            return true;
        }

        /**
         * @return true if the inbox of the current account hasn't been refreshed
         * in the last {@link #INBOX_AUTO_REFRESH_MIN_INTERVAL}.
         */
        @VisibleForTesting
        boolean shouldAutoRefreshInbox() {
            if (mInboxId == mMailboxId) {
                return false; // Current ID == inbox.  No need to auto-refresh.
            }
            if (mRefreshManager.isMessageListRefreshing(mInboxId)) {
                return false;
            }
            final long nextRefreshTime = mRefreshManager.getLastMessageListRefreshTime(mInboxId)
                    + INBOX_AUTO_REFRESH_MIN_INTERVAL;
            if (nextRefreshTime > mClock.getTime()) {
                return false;
            }
            return true;
        }
    }

    private class ActionBarControllerCallback implements ActionBarController.Callback {

        @Override
        public long getUIAccountId() {
            return UIControllerTwoPane.this.getUIAccountId();
        }

        @Override
        public long getMailboxId() {
            return getMessageListMailboxId();
        }

        @Override
        public boolean isAccountSelected() {
            return UIControllerTwoPane.this.isAccountSelected();
        }

        @Override
        public void onAccountSelected(long accountId) {
            switchAccount(accountId, false);
        }

        @Override
        public void onMailboxSelected(long accountId, long mailboxId) {
            openMailbox(accountId, mailboxId);
        }

        @Override
        public void onNoAccountsFound() {
            Welcome.actionStart(mActivity);
            mActivity.finish();
        }

        @Override
        public int getTitleMode() {
            if (mThreePane.isLeftPaneVisible()) {
                // Mailbox list visible
                return TITLE_MODE_ACCOUNT_NAME_ONLY;
            } else {
                // Mailbox list hidden
                return TITLE_MODE_ACCOUNT_WITH_MAILBOX;
            }
        }

        public String getMessageSubject() {
            if (isMessageViewInstalled() && getMessageViewFragment().isMessageOpen()) {
                return getMessageViewFragment().getMessage().mSubject;
            } else {
                return null;
            }
        }

        @Override
        public boolean shouldShowUp() {
            final int visiblePanes = mThreePane.getVisiblePanes();
            final boolean leftPaneHidden = ((visiblePanes & ThreePaneLayout.PANE_LEFT) == 0);
            return leftPaneHidden
                    || (isMailboxListInstalled() && getMailboxListFragment().canNavigateUp());
        }

        @Override
        public String getSearchHint() {
            return UIControllerTwoPane.this.getSearchHint();
        }

        @Override
        public void onSearchStarted() {
            UIControllerTwoPane.this.onSearchStarted();
        }

        @Override
        public void onSearchSubmit(final String queryTerm) {
            UIControllerTwoPane.this.onSearchSubmit(queryTerm);
        }

        @Override
        public void onSearchExit() {
            UIControllerTwoPane.this.onSearchExit();
        }
    }
}
",True,268,1,1,11,58,2,24,L6
61,com.android.email.activity.DeleteMessageConfirmationDialog.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.Fragment;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.os.Bundle;

/**
 * Confirmation dialog for deleting messages.
 */
public class DeleteMessageConfirmationDialog extends DialogFragment
        implements DialogInterface.OnClickListener {
    private static final String COUNT_MESSAGES_ARG = ""count_messages"";

    public interface Callback {
        public void onDeleteMessageConfirmationDialogOkPressed();
    }

    /**
     * Create a new dialog.
     *
     * @param countMessage the number of messages to be deleted
     * @param callbackFragment fragment that implements {@link Callback}.  Or null, in which case
     * the parent activity must implement {@link Callback}.
     */
    public static DeleteMessageConfirmationDialog newInstance(int countMessage,
            Fragment callbackFragment) {
        final DeleteMessageConfirmationDialog dialog = new DeleteMessageConfirmationDialog();
        final Bundle args = new Bundle();
        args.putInt(COUNT_MESSAGES_ARG, countMessage);
        dialog.setArguments(args);
        if (callbackFragment != null) {
            dialog.setTargetFragment(callbackFragment, 0);
        }
        return dialog;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        final int countMessages = getArguments().getInt(COUNT_MESSAGES_ARG);

        final Context context = getActivity();
        final Resources res = context.getResources();
        final AlertDialog.Builder b = new AlertDialog.Builder(context);
        b.setTitle(res.getString(R.string.message_delete_dialog_title))
                .setIconAttribute(android.R.attr.alertDialogIcon)
                .setMessage(res.getQuantityString(R.plurals.message_delete_confirm, countMessages))
                .setPositiveButton(R.string.okay_action, this)
                .setNegativeButton(R.string.cancel_action, null);
        return b.create();
    }

    @Override
    public void onClick(DialogInterface dialog, int which) {
        switch (which) {
            case DialogInterface.BUTTON_POSITIVE:
                getCallback().onDeleteMessageConfirmationDialogOkPressed();
                break;
        }
    }

    private Callback getCallback() {
        Fragment targetFragment = getTargetFragment();
        if (targetFragment != null) {
            // If a target is set, it MUST implement Callback.
            return (Callback) targetFragment;
        }
        // If not the parent activity MUST implement Callback.
        return (Callback) getActivity();
    }
}
",False,147,7,63,0,0,1,0,L6
62,com.android.email.activity.MessagesAdapter.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.Context;
import android.content.Loader;
import android.database.Cursor;
import android.database.CursorWrapper;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CursorAdapter;

import com.android.email.Controller;
import com.android.email.Email;
import com.android.email.MessageListContext;
import com.android.email.ResourceHelper;
import com.android.email.data.ThrottlingCursorLoader;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.TextUtilities;
import com.android.emailcommon.utility.Utility;
import com.google.common.base.Preconditions;

import java.util.HashSet;
import java.util.Set;


/**
 * This class implements the adapter for displaying messages based on cursors.
 */
/* package */ class MessagesAdapter extends CursorAdapter {
    private static final String STATE_CHECKED_ITEMS =
            ""com.android.email.activity.MessagesAdapter.checkedItems"";

    /* package */ static final String[] MESSAGE_PROJECTION = new String[] {
        EmailContent.RECORD_ID, MessageColumns.MAILBOX_KEY, MessageColumns.ACCOUNT_KEY,
        MessageColumns.DISPLAY_NAME, MessageColumns.SUBJECT, MessageColumns.TIMESTAMP,
        MessageColumns.FLAG_READ, MessageColumns.FLAG_FAVORITE, MessageColumns.FLAG_ATTACHMENT,
        MessageColumns.FLAGS, MessageColumns.SNIPPET
    };

    public static final int COLUMN_ID = 0;
    public static final int COLUMN_MAILBOX_KEY = 1;
    public static final int COLUMN_ACCOUNT_KEY = 2;
    public static final int COLUMN_DISPLAY_NAME = 3;
    public static final int COLUMN_SUBJECT = 4;
    public static final int COLUMN_DATE = 5;
    public static final int COLUMN_READ = 6;
    public static final int COLUMN_FAVORITE = 7;
    public static final int COLUMN_ATTACHMENTS = 8;
    public static final int COLUMN_FLAGS = 9;
    public static final int COLUMN_SNIPPET = 10;

    private final ResourceHelper mResourceHelper;

    /** If true, show color chips. */
    private boolean mShowColorChips;

    /** If not null, the query represented by this group of messages */
    private String mQuery;

    /**
     * Set of seleced message IDs.
     */
    private final HashSet<Long> mSelectedSet = new HashSet<Long>();

    /**
     * Callback from MessageListAdapter.  All methods are called on the UI thread.
     */
    public interface Callback {
        /** Called when the use starts/unstars a message */
        void onAdapterFavoriteChanged(MessageListItem itemView, boolean newFavorite);
        /** Called when the user selects/unselects a message */
        void onAdapterSelectedChanged(MessageListItem itemView, boolean newSelected,
                int mSelectedCount);
    }

    private final Callback mCallback;

    private ThreePaneLayout mLayout;

    /**
     * The actual return type from the loader.
     */
    public static class MessagesCursor extends CursorWrapper {
        /**  Whether the mailbox is found. */
        public final boolean mIsFound;
        /** {@link Account} that owns the mailbox.  Null for combined mailboxes. */
        public final Account mAccount;
        /** {@link Mailbox} for the loaded mailbox. Null for combined mailboxes. */
        public final Mailbox mMailbox;
        /** {@code true} if the account is an EAS account */
        public final boolean mIsEasAccount;
        /** {@code true} if the loaded mailbox can be refreshed. */
        public final boolean mIsRefreshable;
        /** the number of accounts currently configured. */
        public final int mCountTotalAccounts;

        private MessagesCursor(Cursor cursor,
                boolean found, Account account, Mailbox mailbox, boolean isEasAccount,
                boolean isRefreshable, int countTotalAccounts) {
            super(cursor);
            mIsFound = found;
            mAccount = account;
            mMailbox = mailbox;
            mIsEasAccount = isEasAccount;
            mIsRefreshable = isRefreshable;
            mCountTotalAccounts = countTotalAccounts;
        }
    }

    public MessagesAdapter(Context context, Callback callback) {
        super(context.getApplicationContext(), null, 0 /* no auto requery */);
        mResourceHelper = ResourceHelper.getInstance(context);
        mCallback = callback;
    }

    public void setLayout(ThreePaneLayout layout) {
        mLayout = layout;
    }

    public void onSaveInstanceState(Bundle outState) {
        outState.putLongArray(STATE_CHECKED_ITEMS, Utility.toPrimitiveLongArray(getSelectedSet()));
    }

    public void loadState(Bundle savedInstanceState) {
        Set<Long> checkedset = getSelectedSet();
        checkedset.clear();
        for (long l: savedInstanceState.getLongArray(STATE_CHECKED_ITEMS)) {
            checkedset.add(l);
        }
        notifyDataSetChanged();
    }

    /**
     * Set true for combined mailboxes.
     */
    public void setShowColorChips(boolean show) {
        mShowColorChips = show;
    }

    public void setQuery(String query) {
        mQuery = query;
    }

    public Set<Long> getSelectedSet() {
        return mSelectedSet;
    }

    /**
     * Clear the selection.  It's preferable to calling {@link Set#clear()} on
     * {@link #getSelectedSet()}, because it also notifies observers.
     */
    public void clearSelection() {
        Set<Long> checkedset = getSelectedSet();
        if (checkedset.size() > 0) {
            checkedset.clear();
            notifyDataSetChanged();
        }
    }

    public boolean isSelected(MessageListItem itemView) {
        return getSelectedSet().contains(itemView.mMessageId);
    }

    @Override
    public void bindView(View view, Context context, Cursor cursor) {
        // Reset the view (in case it was recycled) and prepare for binding
        MessageListItem itemView = (MessageListItem) view;
        itemView.bindViewInit(this, mLayout);

        // TODO: just move thise all to a MessageListItem.bindTo(cursor) so that the fields can
        // be private, and their inter-dependence when they change can be abstracted away.

        // Load the public fields in the view (for later use)
        itemView.mMessageId = cursor.getLong(COLUMN_ID);
        itemView.mMailboxId = cursor.getLong(COLUMN_MAILBOX_KEY);
        final long accountId = cursor.getLong(COLUMN_ACCOUNT_KEY);
        itemView.mAccountId = accountId;

        boolean isRead = cursor.getInt(COLUMN_READ) != 0;
        boolean readChanged = isRead != itemView.mRead;
        itemView.mRead = isRead;
        itemView.mIsFavorite = cursor.getInt(COLUMN_FAVORITE) != 0;
        final int flags = cursor.getInt(COLUMN_FLAGS);
        itemView.mHasInvite = (flags & Message.FLAG_INCOMING_MEETING_INVITE) != 0;
        itemView.mHasBeenRepliedTo = (flags & Message.FLAG_REPLIED_TO) != 0;
        itemView.mHasBeenForwarded = (flags & Message.FLAG_FORWARDED) != 0;
        itemView.mHasAttachment = cursor.getInt(COLUMN_ATTACHMENTS) != 0;
        itemView.setTimestamp(cursor.getLong(COLUMN_DATE));
        itemView.mSender = cursor.getString(COLUMN_DISPLAY_NAME);
        itemView.setText(
                cursor.getString(COLUMN_SUBJECT), cursor.getString(COLUMN_SNIPPET), readChanged);
        itemView.mColorChipPaint =
            mShowColorChips ? mResourceHelper.getAccountColorPaint(accountId) : null;

        if (mQuery != null && itemView.mSnippet != null) {
            itemView.mSnippet =
                TextUtilities.highlightTermsInText(cursor.getString(COLUMN_SNIPPET), mQuery);
        }
    }

    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
        MessageListItem item = new MessageListItem(context);
        item.setVisibility(View.VISIBLE);
        return item;
    }

    public void toggleSelected(MessageListItem itemView) {
        updateSelected(itemView, !isSelected(itemView));
    }

    /**
     * This is used as a callback from the list items, to set the selected state
     *
     * <p>Must be called on the UI thread.
     *
     * @param itemView the item being changed
     * @param newSelected the new value of the selected flag (checkbox state)
     */
    private void updateSelected(MessageListItem itemView, boolean newSelected) {
        if (newSelected) {
            mSelectedSet.add(itemView.mMessageId);
        } else {
            mSelectedSet.remove(itemView.mMessageId);
        }
        if (mCallback != null) {
            mCallback.onAdapterSelectedChanged(itemView, newSelected, mSelectedSet.size());
        }
    }

    /**
     * This is used as a callback from the list items, to set the favorite state
     *
     * <p>Must be called on the UI thread.
     *
     * @param itemView the item being changed
     * @param newFavorite the new value of the favorite flag (star state)
     */
    public void updateFavorite(MessageListItem itemView, boolean newFavorite) {
        changeFavoriteIcon(itemView, newFavorite);
        if (mCallback != null) {
            mCallback.onAdapterFavoriteChanged(itemView, newFavorite);
        }
    }

    private void changeFavoriteIcon(MessageListItem view, boolean isFavorite) {
        view.invalidate();
    }

    /**
     * Creates the loader for {@link MessageListFragment}.
     *
     * @return always of {@link MessagesCursor}.
     */
    public static Loader<Cursor> createLoader(Context context, MessageListContext listContext) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""MessagesAdapter createLoader listContext="" + listContext);
        }
        return listContext.isSearch()
                ? new SearchCursorLoader(context, listContext)
                : new MessagesCursorLoader(context, listContext);
    }

    private static class MessagesCursorLoader extends ThrottlingCursorLoader {
        protected final Context mContext;
        private final long mAccountId;
        private final long mMailboxId;

        public MessagesCursorLoader(Context context, MessageListContext listContext) {
            // Initialize with no where clause.  We'll set it later.
            super(context, EmailContent.Message.CONTENT_URI,
                    MESSAGE_PROJECTION, null, null,
                    EmailContent.MessageColumns.TIMESTAMP + "" DESC"");
            mContext = context;
            mAccountId = listContext.mAccountId;
            mMailboxId = listContext.getMailboxId();
        }

        @Override
        public Cursor loadInBackground() {
            // Build the where cause (which can't be done on the UI thread.)
            setSelection(Message.buildMessageListSelection(mContext, mAccountId, mMailboxId));
            // Then do a query to get the cursor
            return loadExtras(super.loadInBackground());
        }

        private Cursor loadExtras(Cursor baseCursor) {
            boolean found = false;
            Account account = null;
            Mailbox mailbox = null;
            boolean isEasAccount = false;
            boolean isRefreshable = false;

            if (mMailboxId < 0) {
                // Magic mailbox.
                found = true;
            } else {
                mailbox = Mailbox.restoreMailboxWithId(mContext, mMailboxId);
                if (mailbox != null) {
                    account = Account.restoreAccountWithId(mContext, mailbox.mAccountKey);
                    if (account != null) {
                        found = true;
                        isEasAccount = account.isEasAccount(mContext) ;
                        isRefreshable = Mailbox.isRefreshable(mContext, mMailboxId);
                    } else { // Account removed?
                        mailbox = null;
                    }
                }
            }
            final int countAccounts = EmailContent.count(mContext, Account.CONTENT_URI);
            return wrapCursor(baseCursor, found, account, mailbox, isEasAccount,
                    isRefreshable, countAccounts);
        }

        /**
         * Wraps a basic cursor containing raw messages with information about the context of
         * the list that's being loaded, such as the account and the mailbox the messages
         * are for.
         * Subclasses may extend this to wrap with additional data.
         */
        protected Cursor wrapCursor(Cursor cursor,
                boolean found, Account account, Mailbox mailbox, boolean isEasAccount,
                boolean isRefreshable, int countTotalAccounts) {
            return new MessagesCursor(cursor, found, account, mailbox, isEasAccount,
                    isRefreshable, countTotalAccounts);
        }
    }

    public static class SearchResultsCursor extends MessagesCursor {
        private final Mailbox mSearchedMailbox;
        private final int mResultsCount;
        private SearchResultsCursor(Cursor cursor,
                boolean found, Account account, Mailbox mailbox, boolean isEasAccount,
                boolean isRefreshable, int countTotalAccounts,
                Mailbox searchedMailbox, int resultsCount) {
            super(cursor, found, account, mailbox, isEasAccount,
                    isRefreshable, countTotalAccounts);
            mSearchedMailbox = searchedMailbox;
            mResultsCount = resultsCount;
        }

        /**
         * @return the total number of results that match the given search query. Note that
         *     there may not be that many items loaded in the cursor yet.
         */
        public int getResultsCount() {
            return mResultsCount;
        }

        public Mailbox getSearchedMailbox() {
            return mSearchedMailbox;
        }
    }

    /**
     * A special loader used to perform a search.
     */
    private static class SearchCursorLoader extends MessagesCursorLoader {
        private final MessageListContext mListContext;
        private int mResultsCount = -1;
        private Mailbox mSearchedMailbox = null;

        public SearchCursorLoader(Context context, MessageListContext listContext) {
            super(context, listContext);
            Preconditions.checkArgument(listContext.isSearch());
            mListContext = listContext;
        }

        @Override
        public Cursor loadInBackground() {
            if (mResultsCount >= 0) {
                // Result count known - the initial search meta data must have completed.
                return super.loadInBackground();
            }

            if (mSearchedMailbox == null) {
                mSearchedMailbox = Mailbox.restoreMailboxWithId(
                        mContext, mListContext.getSearchedMailbox());
            }

            // The search results info hasn't even been loaded yet, so the Controller has not yet
            // initialized the search mailbox properly. Kick off the search first.
            Controller controller = Controller.getInstance(mContext);
            try {
                mResultsCount = controller.searchMessages(
                        mListContext.mAccountId, mListContext.getSearchParams());
            } catch (MessagingException e) {
            }

            // Return whatever the super would do, now that we know the results are ready.
            // After this point, it should behave as a normal mailbox load for messages.
            return super.loadInBackground();
        }

        @Override
        protected Cursor wrapCursor(Cursor cursor,
                boolean found, Account account, Mailbox mailbox, boolean isEasAccount,
                boolean isRefreshable, int countTotalAccounts) {
            return new SearchResultsCursor(cursor, found, account, mailbox, isEasAccount,
                    isRefreshable, countTotalAccounts, mSearchedMailbox, mResultsCount);
        }
    }
}
",True,268,1,1,10,58,3,14,L6
63,com.android.email.activity.MessageCompose.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.ActionBar;
import android.app.ActionBar.OnNavigationListener;
import android.app.ActionBar.Tab;
import android.app.ActionBar.TabListener;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.FragmentTransaction;
import android.content.ActivityNotFoundException;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.Parcelable;
import android.provider.OpenableColumns;
import android.text.InputFilter;
import android.text.SpannableStringBuilder;
import android.text.Spanned;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.text.util.Rfc822Tokenizer;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnFocusChangeListener;
import android.view.ViewGroup;
import android.webkit.WebView;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.MultiAutoCompleteTextView;
import android.widget.TextView;
import android.widget.Toast;

import com.android.common.contacts.DataUsageStatUpdater;
import com.android.email.Controller;
import com.android.email.Email;
import com.android.email.EmailAddressAdapter;
import com.android.email.EmailAddressValidator;
import com.android.email.R;
import com.android.email.RecipientAdapter;
import com.android.email.activity.setup.AccountSettings;
import com.android.email.mail.internet.EmailHtmlUtil;
import com.android.emailcommon.Logging;
import com.android.emailcommon.internet.MimeUtility;
import com.android.emailcommon.mail.Address;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.Body;
import com.android.emailcommon.provider.EmailContent.BodyColumns;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.EmailContent.QuickResponseColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.provider.QuickResponse;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.android.ex.chips.AccountSpecifier;
import com.android.ex.chips.ChipsUtil;
import com.android.ex.chips.RecipientEditTextView;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Objects;
import com.google.common.collect.Lists;

import java.io.File;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;


/**
 * Activity to compose a message.
 *
 * TODO Revive shortcuts command for removed menu options.
 * C: add cc/bcc
 * N: add attachment
 */
public class MessageCompose extends Activity implements OnClickListener, OnFocusChangeListener,
        DeleteMessageConfirmationDialog.Callback, InsertQuickResponseDialog.Callback {

    private static final String ACTION_REPLY = ""com.android.email.intent.action.REPLY"";
    private static final String ACTION_REPLY_ALL = ""com.android.email.intent.action.REPLY_ALL"";
    private static final String ACTION_FORWARD = ""com.android.email.intent.action.FORWARD"";
    private static final String ACTION_EDIT_DRAFT = ""com.android.email.intent.action.EDIT_DRAFT"";

    private static final String EXTRA_ACCOUNT_ID = ""account_id"";
    private static final String EXTRA_MESSAGE_ID = ""message_id"";
    /** If the intent is sent from the email app itself, it should have this boolean extra. */
    public static final String EXTRA_FROM_WITHIN_APP = ""from_within_app"";
    /** If the intent is sent from thw widget. */
    public static final String EXTRA_FROM_WIDGET = ""from_widget"";

    private static final String STATE_KEY_CC_SHOWN =
        ""com.android.email.activity.MessageCompose.ccShown"";
    private static final String STATE_KEY_QUOTED_TEXT_SHOWN =
        ""com.android.email.activity.MessageCompose.quotedTextShown"";
    private static final String STATE_KEY_DRAFT_ID =
        ""com.android.email.activity.MessageCompose.draftId"";
    private static final String STATE_KEY_LAST_SAVE_TASK_ID =
        ""com.android.email.activity.MessageCompose.requestId"";
    private static final String STATE_KEY_ACTION =
        ""com.android.email.activity.MessageCompose.action"";

    private static final int ACTIVITY_REQUEST_PICK_ATTACHMENT = 1;

    private static final String[] ATTACHMENT_META_SIZE_PROJECTION = {
        OpenableColumns.SIZE
    };
    private static final int ATTACHMENT_META_SIZE_COLUMN_SIZE = 0;

    /**
     * A registry of the active tasks used to save messages.
     */
    private static final ConcurrentHashMap<Long, SendOrSaveMessageTask> sActiveSaveTasks =
            new ConcurrentHashMap<Long, SendOrSaveMessageTask>();

    private static long sNextSaveTaskId = 1;

    /**
     * The ID of the latest save or send task requested by this Activity.
     */
    private long mLastSaveTaskId = -1;

    private Account mAccount;

    /**
     * The contents of the current message being edited. This is not always in sync with what's
     * on the UI. {@link #updateMessage(Message, Account, boolean, boolean)} must be called to sync
     * the UI values into this object.
     */
    private Message mDraft = new Message();

    /**
     * A collection of attachments the user is currently wanting to attach to this message.
     */
    private final ArrayList<Attachment> mAttachments = new ArrayList<Attachment>();

    /**
     * The source message for a reply, reply all, or forward. This is asynchronously loaded.
     */
    private Message mSource;

    /**
     * The attachments associated with the source attachments. Usually included in a forward.
     */
    private ArrayList<Attachment> mSourceAttachments = new ArrayList<Attachment>();

    /**
     * The action being handled by this activity. This is initially populated from the
     * {@link Intent}, but can switch between reply/reply all/forward where appropriate.
     * This value is nullable (a null value indicating a regular ""compose"").
     */
    private String mAction;

    private TextView mFromView;
    private MultiAutoCompleteTextView mToView;
    private MultiAutoCompleteTextView mCcView;
    private MultiAutoCompleteTextView mBccView;
    private View mCcBccContainer;
    private EditText mSubjectView;
    private EditText mMessageContentView;
    private View mAttachmentContainer;
    private ViewGroup mAttachmentContentView;
    private View mQuotedTextArea;
    private CheckBox mIncludeQuotedTextCheckBox;
    private WebView mQuotedText;
    private ActionSpinnerAdapter mActionSpinnerAdapter;

    private Controller mController;
    private boolean mDraftNeedsSaving;
    private boolean mMessageLoaded;
    private boolean mInitiallyEmpty;
    private boolean mPickingAttachment = false;
    private Boolean mQuickResponsesAvailable = true;
    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    private AccountSpecifier mAddressAdapterTo;
    private AccountSpecifier mAddressAdapterCc;
    private AccountSpecifier mAddressAdapterBcc;

    /**
     * Watches the to, cc, bcc, subject, and message body fields.
     */
    private final TextWatcher mWatcher = new TextWatcher() {
        @Override
        public void beforeTextChanged(CharSequence s, int start,
                                      int before, int after) { }

        @Override
        public void onTextChanged(CharSequence s, int start,
                                      int before, int count) {
            setMessageChanged(true);
        }

        @Override
        public void afterTextChanged(android.text.Editable s) { }
    };

    private static Intent getBaseIntent(Context context) {
        return new Intent(context, MessageCompose.class);
    }

    /**
     * Create an {@link Intent} that can start the message compose activity. If accountId -1,
     * the default account will be used; otherwise, the specified account is used.
     */
    public static Intent getMessageComposeIntent(Context context, long accountId) {
        Intent i = getBaseIntent(context);
        i.putExtra(EXTRA_ACCOUNT_ID, accountId);
        return i;
    }

    /**
     * Creates an {@link Intent} that can start the message compose activity from the main Email
     * activity. This should not be used for Intents to be fired from outside of the main Email
     * activity, such as from widgets, as the behavior of the compose screen differs subtly from
     * those cases.
     */
    private static Intent getMainAppIntent(Context context, long accountId) {
        Intent result = getMessageComposeIntent(context, accountId);
        result.putExtra(EXTRA_FROM_WITHIN_APP, true);
        return result;
    }

    /**
     * Compose a new message using the given account. If account is {@link Account#NO_ACCOUNT}
     * the default account will be used.
     * This should only be called from the main Email application.
     * @param context
     * @param accountId
     */
    public static void actionCompose(Context context, long accountId) {
       try {
           Intent i = getMainAppIntent(context, accountId);
           context.startActivity(i);
       } catch (ActivityNotFoundException anfe) {
           // Swallow it - this is usually a race condition, especially under automated test.
           // (The message composer might have been disabled)
           Email.log(anfe.toString());
       }
    }

    /**
     * Compose a new message using a uri (mailto:) and a given account.  If account is -1 the
     * default account will be used.
     * This should only be called from the main Email application.
     * @param context
     * @param uriString
     * @param accountId
     * @return true if startActivity() succeeded
     */
    public static boolean actionCompose(Context context, String uriString, long accountId) {
        try {
            Intent i = getMainAppIntent(context, accountId);
            i.setAction(Intent.ACTION_SEND);
            i.setData(Uri.parse(uriString));
            context.startActivity(i);
            return true;
        } catch (ActivityNotFoundException anfe) {
            // Swallow it - this is usually a race condition, especially under automated test.
            // (The message composer might have been disabled)
            Email.log(anfe.toString());
            return false;
        }
    }

    /**
     * Compose a new message as a reply to the given message. If replyAll is true the function
     * is reply all instead of simply reply.
     * @param context
     * @param messageId
     * @param replyAll
     */
    public static void actionReply(Context context, long messageId, boolean replyAll) {
        startActivityWithMessage(context, replyAll ? ACTION_REPLY_ALL : ACTION_REPLY, messageId);
    }

    /**
     * Compose a new message as a forward of the given message.
     * @param context
     * @param messageId
     */
    public static void actionForward(Context context, long messageId) {
        startActivityWithMessage(context, ACTION_FORWARD, messageId);
    }

    /**
     * Continue composition of the given message. This action modifies the way this Activity
     * handles certain actions.
     * Save will attempt to replace the message in the given folder with the updated version.
     * Discard will delete the message from the given folder.
     * @param context
     * @param messageId the message id.
     */
    public static void actionEditDraft(Context context, long messageId) {
        startActivityWithMessage(context, ACTION_EDIT_DRAFT, messageId);
    }

    /**
     * Starts a compose activity with a message as a reference message (e.g. for reply or forward).
     */
    private static void startActivityWithMessage(Context context, String action, long messageId) {
        Intent i = getBaseIntent(context);
        i.putExtra(EXTRA_MESSAGE_ID, messageId);
        i.setAction(action);
        context.startActivity(i);
    }

    private void setAccount(Intent intent) {
        long accountId = intent.getLongExtra(EXTRA_ACCOUNT_ID, -1);
        if (accountId == Account.NO_ACCOUNT) {
            accountId = Account.getDefaultAccountId(this);
        }
        if (accountId == Account.NO_ACCOUNT) {
            // There are no accounts set up. This should not have happened. Prompt the
            // user to set up an account as an acceptable bailout.
            Welcome.actionStart(this);
            finish();
        } else {
            setAccount(Account.restoreAccountWithId(this, accountId));
        }
    }

    private void setAccount(Account account) {
        if (account == null) {
            throw new IllegalArgumentException();
        }
        mAccount = account;
        mFromView.setText(account.mEmailAddress);
        mAddressAdapterTo
                .setAccount(new android.accounts.Account(account.mEmailAddress, ""unknown""));
        mAddressAdapterCc
                .setAccount(new android.accounts.Account(account.mEmailAddress, ""unknown""));
        mAddressAdapterBcc
                .setAccount(new android.accounts.Account(account.mEmailAddress, ""unknown""));

        new QuickResponseChecker(mTaskTracker).executeParallel((Void) null);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(R.layout.message_compose);

        mController = Controller.getInstance(getApplication());
        initViews();

        // Show the back arrow on the action bar.
        getActionBar().setDisplayOptions(
                ActionBar.DISPLAY_HOME_AS_UP, ActionBar.DISPLAY_HOME_AS_UP);

        if (savedInstanceState != null) {
            long draftId = savedInstanceState.getLong(STATE_KEY_DRAFT_ID, Message.NOT_SAVED);
            long existingSaveTaskId = savedInstanceState.getLong(STATE_KEY_LAST_SAVE_TASK_ID, -1);
            setAction(savedInstanceState.getString(STATE_KEY_ACTION));
            SendOrSaveMessageTask existingSaveTask = sActiveSaveTasks.get(existingSaveTaskId);

            if ((draftId != Message.NOT_SAVED) || (existingSaveTask != null)) {
                // Restoring state and there was an existing message saved or in the process of
                // being saved.
                resumeDraft(draftId, existingSaveTask, false /* don't restore views */);
            } else {
                // Restoring state but there was nothing saved - probably means the user rotated
                // the device immediately - just use the Intent.
                resolveIntent(getIntent());
            }
        } else {
            Intent intent = getIntent();
            setAction(intent.getAction());
            resolveIntent(intent);
        }
    }

    private void resolveIntent(Intent intent) {
        if (Intent.ACTION_VIEW.equals(mAction)
                || Intent.ACTION_SENDTO.equals(mAction)
                || Intent.ACTION_SEND.equals(mAction)
                || Intent.ACTION_SEND_MULTIPLE.equals(mAction)) {
            initFromIntent(intent);
            setMessageChanged(true);
            setMessageLoaded(true);
        } else if (ACTION_REPLY.equals(mAction)
                || ACTION_REPLY_ALL.equals(mAction)
                || ACTION_FORWARD.equals(mAction)) {
            long sourceMessageId = getIntent().getLongExtra(EXTRA_MESSAGE_ID, Message.NOT_SAVED);
            loadSourceMessage(sourceMessageId, true);

        } else if (ACTION_EDIT_DRAFT.equals(mAction)) {
            // Assert getIntent.hasExtra(EXTRA_MESSAGE_ID)
            long draftId = getIntent().getLongExtra(EXTRA_MESSAGE_ID, Message.NOT_SAVED);
            resumeDraft(draftId, null, true /* restore views */);

        } else {
            // Normal compose flow for a new message.
            setAccount(intent);
            setInitialComposeText(null, getAccountSignature(mAccount));
            setMessageLoaded(true);
        }
    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        // Temporarily disable onTextChanged listeners while restoring the fields
        removeListeners();
        super.onRestoreInstanceState(savedInstanceState);
        if (savedInstanceState.getBoolean(STATE_KEY_CC_SHOWN)) {
            showCcBccFields();
        }
        mQuotedTextArea.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN)
                ? View.VISIBLE : View.GONE);
        mQuotedText.setVisibility(savedInstanceState.getBoolean(STATE_KEY_QUOTED_TEXT_SHOWN)
                ? View.VISIBLE : View.GONE);
        addListeners();
    }

    // needed for unit tests
    @Override
    public void setIntent(Intent intent) {
        super.setIntent(intent);
        setAction(intent.getAction());
    }

    private void setQuickResponsesAvailable(boolean quickResponsesAvailable) {
        if (mQuickResponsesAvailable != quickResponsesAvailable) {
            mQuickResponsesAvailable = quickResponsesAvailable;
            invalidateOptionsMenu();
        }
    }

    /**
     * Given an accountId and context, finds if the database has any QuickResponse
     * entries and returns the result to the Callback.
     */
    private class QuickResponseChecker extends EmailAsyncTask<Void, Void, Boolean> {
        public QuickResponseChecker(EmailAsyncTask.Tracker tracker) {
            super(tracker);
        }

        @Override
        protected Boolean doInBackground(Void... params) {
            return EmailContent.count(MessageCompose.this, QuickResponse.CONTENT_URI,
                    QuickResponseColumns.ACCOUNT_KEY + ""=?"",
                    new String[] {Long.toString(mAccount.mId)}) > 0;
        }

        @Override
        protected void onSuccess(Boolean quickResponsesAvailable) {
            setQuickResponsesAvailable(quickResponsesAvailable);
        }
    }

    @Override
    public void onResume() {
        super.onResume();

        // Exit immediately if the accounts list has changed (e.g. externally deleted)
        if (Email.getNotifyUiAccountsChanged()) {
            Welcome.actionStart(this);
            finish();
            return;
        }

        // If activity paused and quick responses are removed/added, possibly update options menu
        if (mAccount != null) {
            new QuickResponseChecker(mTaskTracker).executeParallel((Void) null);
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        saveIfNeeded();
    }

    /**
     * We override onDestroy to make sure that the WebView gets explicitly destroyed.
     * Otherwise it can leak native references.
     */
    @Override
    public void onDestroy() {
        super.onDestroy();
        mQuotedText.destroy();
        mQuotedText = null;

        mTaskTracker.cancellAllInterrupt();

        if (mAddressAdapterTo != null && mAddressAdapterTo instanceof EmailAddressAdapter) {
            ((EmailAddressAdapter) mAddressAdapterTo).close();
        }
        if (mAddressAdapterCc != null && mAddressAdapterCc instanceof EmailAddressAdapter) {
            ((EmailAddressAdapter) mAddressAdapterCc).close();
        }
        if (mAddressAdapterBcc != null && mAddressAdapterBcc instanceof EmailAddressAdapter) {
            ((EmailAddressAdapter) mAddressAdapterBcc).close();
        }
    }

    /**
     * The framework handles most of the fields, but we need to handle stuff that we
     * dynamically show and hide:
     * Cc field,
     * Bcc field,
     * Quoted text,
     */
    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

        long draftId = mDraft.mId;
        if (draftId != Message.NOT_SAVED) {
            outState.putLong(STATE_KEY_DRAFT_ID, draftId);
        }
        outState.putBoolean(STATE_KEY_CC_SHOWN, mCcBccContainer.getVisibility() == View.VISIBLE);
        outState.putBoolean(STATE_KEY_QUOTED_TEXT_SHOWN,
                mQuotedTextArea.getVisibility() == View.VISIBLE);
        outState.putString(STATE_KEY_ACTION, mAction);

        // If there are any outstanding save requests, ensure that it's noted in case it hasn't
        // finished by the time the activity is restored.
        outState.putLong(STATE_KEY_LAST_SAVE_TASK_ID, mLastSaveTaskId);
    }

    @Override
    public void onBackPressed() {
        onBack(true /* systemKey */);
    }

    /**
     * Whether or not the current message being edited has a source message (i.e. is a reply,
     * or forward) that is loaded.
     */
    private boolean hasSourceMessage() {
        return mSource != null;
    }

    /**
     * @return true if the activity was opened by the email app itself.
     */
    private boolean isOpenedFromWithinApp() {
        Intent i = getIntent();
        return (i != null && i.getBooleanExtra(EXTRA_FROM_WITHIN_APP, false));
    }

    private boolean isOpenedFromWidget() {
        Intent i = getIntent();
        return (i != null && i.getBooleanExtra(EXTRA_FROM_WIDGET, false));
    }

    /**
     * Sets message as loaded and then initializes the TextWatchers.
     * @param isLoaded - value to which to set mMessageLoaded
     */
    private void setMessageLoaded(boolean isLoaded) {
        if (mMessageLoaded != isLoaded) {
            mMessageLoaded = isLoaded;
            addListeners();
            mInitiallyEmpty = areViewsEmpty();
        }
    }

    private void setMessageChanged(boolean messageChanged) {
        boolean needsSaving = messageChanged && !(mInitiallyEmpty && areViewsEmpty());

        if (mDraftNeedsSaving != needsSaving) {
            mDraftNeedsSaving = needsSaving;
            invalidateOptionsMenu();
        }
    }

    /**
     * @return whether or not all text fields are empty (i.e. the entire compose message is empty)
     */
    private boolean areViewsEmpty() {
        return (mToView.length() == 0)
                && (mCcView.length() == 0)
                && (mBccView.length() == 0)
                && (mSubjectView.length() == 0)
                && isBodyEmpty()
                && mAttachments.isEmpty();
    }

    private boolean isBodyEmpty() {
        return (mMessageContentView.length() == 0)
                || mMessageContentView.getText()
                        .toString().equals(""\n"" + getAccountSignature(mAccount));
    }

    public void setFocusShifter(int fromViewId, final int targetViewId) {
        View label = findViewById(fromViewId); // xlarge only
        if (label != null) {
            final View target = UiUtilities.getView(this, targetViewId);
            label.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    target.requestFocus();
                }
            });
        }
    }

    /**
     * An {@link InputFilter} that implements special address cleanup rules.
     * The first space key entry following an ""@"" symbol that is followed by any combination
     * of letters and symbols, including one+ dots and zero commas, should insert an extra
     * comma (followed by the space).
     */
    @VisibleForTesting
    static final InputFilter RECIPIENT_FILTER = new InputFilter() {
        @Override
        public CharSequence filter(CharSequence source, int start, int end, Spanned dest,
                int dstart, int dend) {

            // Quick check - did they enter a single space?
            if (end-start != 1 || source.charAt(start) != ' ') {
                return null;
            }

            // determine if the characters before the new space fit the pattern
            // follow backwards and see if we find a comma, dot, or @
            int scanBack = dstart;
            boolean dotFound = false;
            while (scanBack > 0) {
                char c = dest.charAt(--scanBack);
                switch (c) {
                    case '.':
                        dotFound = true;    // one or more dots are req'd
                        break;
                    case ',':
                        return null;
                    case '@':
                        if (!dotFound) {
                            return null;
                        }

                        // we have found a comma-insert case.  now just do it
                        // in the least expensive way we can.
                        if (source instanceof Spanned) {
                            SpannableStringBuilder sb = new SpannableStringBuilder("","");
                            sb.append(source);
                            return sb;
                        } else {
                            return "", "";
                        }
                    default:
                        // just keep going
                }
            }

            // no termination cases were found, so don't edit the input
            return null;
        }
    };

    private void initViews() {
        ViewGroup toParent = UiUtilities.getViewOrNull(this, R.id.to_content);
        if (toParent != null) {
            mToView = (MultiAutoCompleteTextView) toParent.findViewById(R.id.to);
            ViewGroup ccParent, bccParent;
            ccParent = (ViewGroup) findViewById(R.id.cc_content);
            mCcView = (MultiAutoCompleteTextView) ccParent.findViewById(R.id.cc);
            bccParent = (ViewGroup) findViewById(R.id.bcc_content);
            mBccView = (MultiAutoCompleteTextView) bccParent.findViewById(R.id.bcc);
        } else {
            mToView = UiUtilities.getView(this, R.id.to);
            mCcView = UiUtilities.getView(this, R.id.cc);
            mBccView = UiUtilities.getView(this, R.id.bcc);
        }

        mFromView = UiUtilities.getView(this, R.id.from);
        mCcBccContainer = UiUtilities.getView(this, R.id.cc_bcc_wrapper);
        mSubjectView = UiUtilities.getView(this, R.id.subject);
        mMessageContentView = UiUtilities.getView(this, R.id.body_text);
        mAttachmentContentView = UiUtilities.getView(this, R.id.attachments);
        mAttachmentContainer = UiUtilities.getView(this, R.id.attachment_container);
        mQuotedTextArea = UiUtilities.getView(this, R.id.quoted_text_area);
        mIncludeQuotedTextCheckBox = UiUtilities.getView(this, R.id.include_quoted_text);
        mQuotedText = UiUtilities.getView(this, R.id.quoted_text);

        InputFilter[] recipientFilters = new InputFilter[] { RECIPIENT_FILTER };

        // NOTE: assumes no other filters are set
        mToView.setFilters(recipientFilters);
        mCcView.setFilters(recipientFilters);
        mBccView.setFilters(recipientFilters);

        /*
         * We set this to invisible by default. Other methods will turn it back on if it's
         * needed.
         */
        mQuotedTextArea.setVisibility(View.GONE);
        setIncludeQuotedText(false, false);

        mIncludeQuotedTextCheckBox.setOnClickListener(this);

        EmailAddressValidator addressValidator = new EmailAddressValidator();

        setupAddressAdapters();
        mToView.setTokenizer(new Rfc822Tokenizer());
        mToView.setValidator(addressValidator);

        mCcView.setTokenizer(new Rfc822Tokenizer());
        mCcView.setValidator(addressValidator);

        mBccView.setTokenizer(new Rfc822Tokenizer());
        mBccView.setValidator(addressValidator);

        final View addCcBccView = UiUtilities.getViewOrNull(this, R.id.add_cc_bcc);
        if (addCcBccView != null) {
            // Tablet view.
            addCcBccView.setOnClickListener(this);
        }

        final View addAttachmentView = UiUtilities.getViewOrNull(this, R.id.add_attachment);
        if (addAttachmentView != null) {
            // Tablet view.
            addAttachmentView.setOnClickListener(this);
        }

        setFocusShifter(R.id.to_label, R.id.to);
        setFocusShifter(R.id.cc_label, R.id.cc);
        setFocusShifter(R.id.bcc_label, R.id.bcc);
        setFocusShifter(R.id.composearea_tap_trap_bottom, R.id.body_text);

        mMessageContentView.setOnFocusChangeListener(this);

        updateAttachmentContainer();
        mToView.requestFocus();
    }

    /**
     * Initializes listeners. Should only be called once initializing of views is complete to
     * avoid unnecessary draft saving.
     */
    private void addListeners() {
        mToView.addTextChangedListener(mWatcher);
        mCcView.addTextChangedListener(mWatcher);
        mBccView.addTextChangedListener(mWatcher);
        mSubjectView.addTextChangedListener(mWatcher);
        mMessageContentView.addTextChangedListener(mWatcher);
    }

    /**
     * Removes listeners from the user-editable fields. Can be used to temporarily disable them
     * while resetting fields (such as when changing from reply to reply all) to avoid
     * unnecessary saving.
     */
    private void removeListeners() {
        mToView.removeTextChangedListener(mWatcher);
        mCcView.removeTextChangedListener(mWatcher);
        mBccView.removeTextChangedListener(mWatcher);
        mSubjectView.removeTextChangedListener(mWatcher);
        mMessageContentView.removeTextChangedListener(mWatcher);
    }

    /**
     * Set up address auto-completion adapters.
     */
    private void setupAddressAdapters() {
        boolean supportsChips = ChipsUtil.supportsChipsUi();

        if (supportsChips && mToView instanceof RecipientEditTextView) {
            mAddressAdapterTo = new RecipientAdapter(this, (RecipientEditTextView) mToView);
            mToView.setAdapter((RecipientAdapter) mAddressAdapterTo);
        } else {
            mAddressAdapterTo = new EmailAddressAdapter(this);
            mToView.setAdapter((EmailAddressAdapter) mAddressAdapterTo);
        }
        if (supportsChips && mCcView instanceof RecipientEditTextView) {
            mAddressAdapterCc = new RecipientAdapter(this, (RecipientEditTextView) mCcView);
            mCcView.setAdapter((RecipientAdapter) mAddressAdapterCc);
        } else {
            mAddressAdapterCc = new EmailAddressAdapter(this);
            mCcView.setAdapter((EmailAddressAdapter) mAddressAdapterCc);
        }
        if (supportsChips && mBccView instanceof RecipientEditTextView) {
            mAddressAdapterBcc = new RecipientAdapter(this, (RecipientEditTextView) mBccView);
            mBccView.setAdapter((RecipientAdapter) mAddressAdapterBcc);
        } else {
            mAddressAdapterBcc = new EmailAddressAdapter(this);
            mBccView.setAdapter((EmailAddressAdapter) mAddressAdapterBcc);
        }
    }

    /**
     * Asynchronously loads a draft message for editing.
     * This may or may not restore the view contents, depending on whether or not callers want,
     * since in the case of screen rotation, those are restored automatically.
     */
    private void resumeDraft(
            long draftId,
            SendOrSaveMessageTask existingSaveTask,
            final boolean restoreViews) {
        // Note - this can be Message.NOT_SAVED if there is an existing save task in progress
        // for the draft we need to load.
        mDraft.mId = draftId;

        new LoadMessageTask(draftId, existingSaveTask, new OnMessageLoadHandler() {
            @Override
            public void onMessageLoaded(Message message, Body body) {
                message.mHtml = body.mHtmlContent;
                message.mText = body.mTextContent;
                message.mHtmlReply = body.mHtmlReply;
                message.mTextReply = body.mTextReply;
                message.mIntroText = body.mIntroText;
                message.mSourceKey = body.mSourceKey;

                mDraft = message;
                processDraftMessage(message, restoreViews);

                // Load attachments related to the draft.
                loadAttachments(message.mId, mAccount, new AttachmentLoadedCallback() {
                    @Override
                    public void onAttachmentLoaded(Attachment[] attachments) {
                        for (Attachment attachment: attachments) {
                            addAttachment(attachment);
                        }
                    }
                });

                // If we're resuming an edit of a reply, reply-all, or forward, re-load the
                // source message if available so that we get more information.
                if (message.mSourceKey != Message.NOT_SAVED) {
                    loadSourceMessage(message.mSourceKey, false /* restore views */);
                }
            }

            @Override
            public void onLoadFailed() {
                Utility.showToast(MessageCompose.this, R.string.error_loading_message_body);
                finish();
            }
        }).executeSerial((Void[]) null);
    }

    @VisibleForTesting
    void processDraftMessage(Message message, boolean restoreViews) {
        if (restoreViews) {
            mSubjectView.setText(message.mSubject);
            addAddresses(mToView, Address.unpack(message.mTo));
            Address[] cc = Address.unpack(message.mCc);
            if (cc.length > 0) {
                addAddresses(mCcView, cc);
            }
            Address[] bcc = Address.unpack(message.mBcc);
            if (bcc.length > 0) {
                addAddresses(mBccView, bcc);
            }

            mMessageContentView.setText(message.mText);

            showCcBccFieldsIfFilled();
            setNewMessageFocus();
        }
        setMessageChanged(false);

        // The quoted text must always be restored.
        displayQuotedText(message.mTextReply, message.mHtmlReply);
        setIncludeQuotedText(
                (mDraft.mFlags & Message.FLAG_NOT_INCLUDE_QUOTED_TEXT) == 0, false);
    }

    /**
     * Asynchronously loads a source message (to be replied or forwarded in this current view),
     * populating text fields and quoted text fields when the load finishes, if requested.
     */
    private void loadSourceMessage(long sourceMessageId, final boolean restoreViews) {
        new LoadMessageTask(sourceMessageId, null, new OnMessageLoadHandler() {
            @Override
            public void onMessageLoaded(Message message, Body body) {
                message.mHtml = body.mHtmlContent;
                message.mText = body.mTextContent;
                message.mHtmlReply = null;
                message.mTextReply = null;
                message.mIntroText = null;
                mSource = message;
                mSourceAttachments = new ArrayList<Attachment>();

                if (restoreViews) {
                    processSourceMessage(mSource, mAccount);
                    setInitialComposeText(null, getAccountSignature(mAccount));
                }

                loadAttachments(message.mId, mAccount, new AttachmentLoadedCallback() {
                    @Override
                    public void onAttachmentLoaded(Attachment[] attachments) {
                        final boolean supportsSmartForward =
                            (mAccount.mFlags & Account.FLAGS_SUPPORTS_SMART_FORWARD) != 0;

                        // Process the attachments to have the appropriate smart forward flags.
                        for (Attachment attachment : attachments) {
                            if (supportsSmartForward) {
                                attachment.mFlags |= Attachment.FLAG_SMART_FORWARD;
                            }
                            mSourceAttachments.add(attachment);
                        }
                        if (isForward() && restoreViews) {
                            if (processSourceMessageAttachments(
                                    mAttachments, mSourceAttachments, true)) {
                                updateAttachmentUi();
                                setMessageChanged(true);
                            }
                        }
                    }
                });

                if (mAction.equals(ACTION_EDIT_DRAFT)) {
                    // Resuming a draft may in fact be resuming a reply/reply all/forward.
                    // Use a best guess and infer the action here.
                    String inferredAction = inferAction();
                    if (inferredAction != null) {
                        setAction(inferredAction);
                        // No need to update the action selector as switching actions should do it.
                        return;
                    }
                }

                updateActionSelector();
            }

            @Override
            public void onLoadFailed() {
                // The loading of the source message is only really required if it is needed
                // immediately to restore the view contents. In the case of resuming draft, it
                // is only needed to gather additional information.
                if (restoreViews) {
                    Utility.showToast(MessageCompose.this, R.string.error_loading_message_body);
                    finish();
                }
            }
        }).executeSerial((Void[]) null);
    }

    /**
     * Infers whether or not the current state of the message best reflects either a reply,
     * reply-all, or forward.
     */
    @VisibleForTesting
    String inferAction() {
        String subject = mSubjectView.getText().toString();
        if (subject == null) {
            return null;
        }
        if (subject.toLowerCase().startsWith(""fwd:"")) {
            return ACTION_FORWARD;
        } else if (subject.toLowerCase().startsWith(""re:"")) {
            int numRecipients = getAddresses(mToView).length
                    + getAddresses(mCcView).length
                    + getAddresses(mBccView).length;
            if (numRecipients > 1) {
                return ACTION_REPLY_ALL;
            } else {
                return ACTION_REPLY;
            }
        } else {
            // Unsure.
            return null;
        }
    }

    private interface OnMessageLoadHandler {
        /**
         * Handles a load to a message (e.g. a draft message or a source message).
         */
        void onMessageLoaded(Message message, Body body);

        /**
         * Handles a failure to load a message.
         */
        void onLoadFailed();
    }

    /**
     * Asynchronously loads a message and the account information.
     * This can be used to load a reference message (when replying) or when restoring a draft.
     */
    private class LoadMessageTask extends EmailAsyncTask<Void, Void, Object[]> {
        /**
         * The message ID to load, if available.
         */
        private long mMessageId;

        /**
         * A future-like reference to the save task which must complete prior to this load.
         */
        private final SendOrSaveMessageTask mSaveTask;

        /**
         * A callback to pass the results of the load to.
         */
        private final OnMessageLoadHandler mCallback;

        public LoadMessageTask(
                long messageId, SendOrSaveMessageTask saveTask, OnMessageLoadHandler callback) {
            super(mTaskTracker);
            mMessageId = messageId;
            mSaveTask = saveTask;
            mCallback = callback;
        }

        private long getIdToLoad() throws InterruptedException, ExecutionException {
            if (mMessageId == -1) {
                mMessageId = mSaveTask.get();
            }
            return mMessageId;
        }

        @Override
        protected Object[] doInBackground(Void... params) {
            long messageId;
            try {
                messageId = getIdToLoad();
            } catch (InterruptedException e) {
                // Don't have a good message ID to load - bail.
                Log.e(Logging.LOG_TAG,
                        ""Unable to load draft message since existing save task failed: "" + e);
                return null;
            } catch (ExecutionException e) {
                // Don't have a good message ID to load - bail.
                Log.e(Logging.LOG_TAG,
                        ""Unable to load draft message since existing save task failed: "" + e);
                return null;
            }
            Message message = Message.restoreMessageWithId(MessageCompose.this, messageId);
            if (message == null) {
                return null;
            }
            long accountId = message.mAccountKey;
            Account account = Account.restoreAccountWithId(MessageCompose.this, accountId);
            Body body;
            try {
                body = Body.restoreBodyWithMessageId(MessageCompose.this, message.mId);
            } catch (RuntimeException e) {
                Log.d(Logging.LOG_TAG, ""Exception while loading message body: "" + e);
                return null;
            }
            return new Object[] {message, body, account};
        }

        @Override
        protected void onSuccess(Object[] results) {
            if ((results == null) || (results.length != 3)) {
                mCallback.onLoadFailed();
                return;
            }

            final Message message = (Message) results[0];
            final Body body = (Body) results[1];
            final Account account = (Account) results[2];
            if ((message == null) || (body == null) || (account == null)) {
                mCallback.onLoadFailed();
                return;
            }

            setAccount(account);
            mCallback.onMessageLoaded(message, body);
            setMessageLoaded(true);
        }
    }

    private interface AttachmentLoadedCallback {
        /**
         * Handles completion of the loading of a set of attachments.
         * Callback will always happen on the main thread.
         */
        void onAttachmentLoaded(Attachment[] attachment);
    }

    private void loadAttachments(
            final long messageId,
            final Account account,
            final AttachmentLoadedCallback callback) {
        new EmailAsyncTask<Void, Void, Attachment[]>(mTaskTracker) {
            @Override
            protected Attachment[] doInBackground(Void... params) {
                return Attachment.restoreAttachmentsWithMessageId(MessageCompose.this, messageId);
            }

            @Override
            protected void onSuccess(Attachment[] attachments) {
                if (attachments == null) {
                    attachments = new Attachment[0];
                }
                callback.onAttachmentLoaded(attachments);
            }
        }.executeSerial((Void[]) null);
    }

    @Override
    public void onFocusChange(View view, boolean focused) {
        if (focused) {
            switch (view.getId()) {
                case R.id.body_text:
                    // When focusing on the message content via tabbing to it, or other means of
                    // auto focusing, move the cursor to the end of the body (before the signature).
                    if (mMessageContentView.getSelectionStart() == 0
                            && mMessageContentView.getSelectionEnd() == 0) {
                        // There is no way to determine if the focus change was programmatic or due
                        // to keyboard event, or if it was due to a tap/restore. Use a best-guess
                        // by using the fact that auto-focus/keyboard tabs set the selection to 0.
                        setMessageContentSelection(getAccountSignature(mAccount));
                    }
            }
        }
    }

    private static void addAddresses(MultiAutoCompleteTextView view, Address[] addresses) {
        if (addresses == null) {
            return;
        }
        for (Address address : addresses) {
            addAddress(view, address.toString());
        }
    }

    private static void addAddresses(MultiAutoCompleteTextView view, String[] addresses) {
        if (addresses == null) {
            return;
        }
        for (String oneAddress : addresses) {
            addAddress(view, oneAddress);
        }
    }

    private static void addAddresses(MultiAutoCompleteTextView view, String addresses) {
        if (addresses == null) {
            return;
        }
        Address[] unpackedAddresses = Address.unpack(addresses);
        for (Address address : unpackedAddresses) {
            addAddress(view, address.toString());
        }
    }

    private static void addAddress(MultiAutoCompleteTextView view, String address) {
        view.append(address + "", "");
    }

    private static String getPackedAddresses(TextView view) {
        Address[] addresses = Address.parse(view.getText().toString().trim());
        return Address.pack(addresses);
    }

    private static Address[] getAddresses(TextView view) {
        Address[] addresses = Address.parse(view.getText().toString().trim());
        return addresses;
    }

    /*
     * Computes a short string indicating the destination of the message based on To, Cc, Bcc.
     * If only one address appears, returns the friendly form of that address.
     * Otherwise returns the friendly form of the first address appended with ""and N others"".
     */
    private String makeDisplayName(String packedTo, String packedCc, String packedBcc) {
        Address first = null;
        int nRecipients = 0;
        for (String packed: new String[] {packedTo, packedCc, packedBcc}) {
            Address[] addresses = Address.unpack(packed);
            nRecipients += addresses.length;
            if (first == null && addresses.length > 0) {
                first = addresses[0];
            }
        }
        if (nRecipients == 0) {
            return """";
        }
        String friendly = first.toFriendly();
        if (nRecipients == 1) {
            return friendly;
        }
        return this.getString(R.string.message_compose_display_name, friendly, nRecipients - 1);
    }

    private ContentValues getUpdateContentValues(Message message) {
        ContentValues values = new ContentValues();
        values.put(MessageColumns.TIMESTAMP, message.mTimeStamp);
        values.put(MessageColumns.FROM_LIST, message.mFrom);
        values.put(MessageColumns.TO_LIST, message.mTo);
        values.put(MessageColumns.CC_LIST, message.mCc);
        values.put(MessageColumns.BCC_LIST, message.mBcc);
        values.put(MessageColumns.SUBJECT, message.mSubject);
        values.put(MessageColumns.DISPLAY_NAME, message.mDisplayName);
        values.put(MessageColumns.FLAG_READ, message.mFlagRead);
        values.put(MessageColumns.FLAG_LOADED, message.mFlagLoaded);
        values.put(MessageColumns.FLAG_ATTACHMENT, message.mFlagAttachment);
        values.put(MessageColumns.FLAGS, message.mFlags);
        return values;
    }

    /**
     * Updates the given message using values from the compose UI.
     *
     * @param message The message to be updated.
     * @param account the account (used to obtain From: address).
     * @param hasAttachments true if it has one or more attachment.
     * @param sending set true if the message is about to sent, in which case we perform final
     *        clean up;
     */
    private void updateMessage(Message message, Account account, boolean hasAttachments,
            boolean sending) {
        if (message.mMessageId == null || message.mMessageId.length() == 0) {
            message.mMessageId = Utility.generateMessageId();
        }
        message.mTimeStamp = System.currentTimeMillis();
        message.mFrom = new Address(account.getEmailAddress(), account.getSenderName()).pack();
        message.mTo = getPackedAddresses(mToView);
        message.mCc = getPackedAddresses(mCcView);
        message.mBcc = getPackedAddresses(mBccView);
        message.mSubject = mSubjectView.getText().toString();
        message.mText = mMessageContentView.getText().toString();
        message.mAccountKey = account.mId;
        message.mDisplayName = makeDisplayName(message.mTo, message.mCc, message.mBcc);
        message.mFlagRead = true;
        message.mFlagLoaded = Message.FLAG_LOADED_COMPLETE;
        message.mFlagAttachment = hasAttachments;
        // Use the Intent to set flags saying this message is a reply or a forward and save the
        // unique id of the source message
        if (mSource != null && mQuotedTextArea.getVisibility() == View.VISIBLE) {
            message.mSourceKey = mSource.mId;
            // If the quote bar is visible; this must either be a reply or forward
            // Get the body of the source message here
            message.mHtmlReply = mSource.mHtml;
            message.mTextReply = mSource.mText;
            String fromAsString = Address.unpackToString(mSource.mFrom);
            if (isForward()) {
                message.mFlags |= Message.FLAG_TYPE_FORWARD;
                String subject = mSource.mSubject;
                String to = Address.unpackToString(mSource.mTo);
                String cc = Address.unpackToString(mSource.mCc);
                message.mIntroText =
                    getString(R.string.message_compose_fwd_header_fmt, subject, fromAsString,
                            to != null ? to : """", cc != null ? cc : """");
            } else {
                message.mFlags |= Message.FLAG_TYPE_REPLY;
                message.mIntroText =
                    getString(R.string.message_compose_reply_header_fmt, fromAsString);
            }
        }

        if (includeQuotedText()) {
            message.mFlags &= ~Message.FLAG_NOT_INCLUDE_QUOTED_TEXT;
        } else {
            message.mFlags |= Message.FLAG_NOT_INCLUDE_QUOTED_TEXT;
            if (sending) {
                // If we are about to send a message, and not including the original message,
                // clear the related field.
                // We can't do this until the last minutes, so that the user can change their
                // mind later and want to include it again.
                mDraft.mIntroText = null;
                mDraft.mTextReply = null;
                mDraft.mHtmlReply = null;

                // Note that mSourceKey is not cleared out as this is still considered a
                // reply/forward.
            }
        }
    }

    private class SendOrSaveMessageTask extends EmailAsyncTask<Void, Void, Long> {
        private final boolean mSend;
        private final long mTaskId;

        /** A context that will survive even past activity destruction. */
        private final Context mContext;

        public SendOrSaveMessageTask(long taskId, boolean send) {
            super(null /* DO NOT cancel in onDestroy */);
            if (send && ActivityManager.isUserAMonkey()) {
                Log.d(Logging.LOG_TAG, ""Inhibiting send while monkey is in charge."");
                send = false;
            }
            mTaskId = taskId;
            mSend = send;
            mContext = getApplicationContext();

            sActiveSaveTasks.put(mTaskId, this);
        }

        @Override
        protected Long doInBackground(Void... params) {
            synchronized (mDraft) {
                updateMessage(mDraft, mAccount, mAttachments.size() > 0, mSend);
                ContentResolver resolver = getContentResolver();
                if (mDraft.isSaved()) {
                    // Update the message
                    Uri draftUri =
                        ContentUris.withAppendedId(Message.SYNCED_CONTENT_URI, mDraft.mId);
                    resolver.update(draftUri, getUpdateContentValues(mDraft), null, null);
                    // Update the body
                    ContentValues values = new ContentValues();
                    values.put(BodyColumns.TEXT_CONTENT, mDraft.mText);
                    values.put(BodyColumns.TEXT_REPLY, mDraft.mTextReply);
                    values.put(BodyColumns.HTML_REPLY, mDraft.mHtmlReply);
                    values.put(BodyColumns.INTRO_TEXT, mDraft.mIntroText);
                    values.put(BodyColumns.SOURCE_MESSAGE_KEY, mDraft.mSourceKey);
                    Body.updateBodyWithMessageId(MessageCompose.this, mDraft.mId, values);
                } else {
                    // mDraft.mId is set upon return of saveToMailbox()
                    mController.saveToMailbox(mDraft, Mailbox.TYPE_DRAFTS);
                }
                // For any unloaded attachment, set the flag saying we need it loaded
                boolean hasUnloadedAttachments = false;
                for (Attachment attachment : mAttachments) {
                    if (attachment.mContentUri == null &&
                            ((attachment.mFlags & Attachment.FLAG_SMART_FORWARD) == 0)) {
                        attachment.mFlags |= Attachment.FLAG_DOWNLOAD_FORWARD;
                        hasUnloadedAttachments = true;
                        if (Email.DEBUG) {
                            Log.d(Logging.LOG_TAG,
                                    ""Requesting download of attachment #"" + attachment.mId);
                        }
                    }
                    // Make sure the UI version of the attachment has the now-correct id; we will
                    // use the id again when coming back from picking new attachments
                    if (!attachment.isSaved()) {
                        // this attachment is new so save it to DB.
                        attachment.mMessageKey = mDraft.mId;
                        attachment.save(MessageCompose.this);
                    } else if (attachment.mMessageKey != mDraft.mId) {
                        // We clone the attachment and save it again; otherwise, it will
                        // continue to point to the source message.  From this point forward,
                        // the attachments will be independent of the original message in the
                        // database; however, we still need the message on the server in order
                        // to retrieve unloaded attachments
                        attachment.mMessageKey = mDraft.mId;
                        ContentValues cv = attachment.toContentValues();
                        cv.put(Attachment.FLAGS, attachment.mFlags);
                        cv.put(Attachment.MESSAGE_KEY, mDraft.mId);
                        getContentResolver().insert(Attachment.CONTENT_URI, cv);
                    }
                }

                if (mSend) {
                    // Let the user know if message sending might be delayed by background
                    // downlading of unloaded attachments
                    if (hasUnloadedAttachments) {
                        Utility.showToast(MessageCompose.this,
                                R.string.message_view_attachment_background_load);
                    }
                    mController.sendMessage(mDraft);

                    ArrayList<CharSequence> addressTexts = new ArrayList<CharSequence>();
                    addressTexts.add(mToView.getText());
                    addressTexts.add(mCcView.getText());
                    addressTexts.add(mBccView.getText());
                    DataUsageStatUpdater updater = new DataUsageStatUpdater(mContext);
                    updater.updateWithRfc822Address(addressTexts);
                }
                return mDraft.mId;
            }
        }

        private boolean shouldShowSaveToast() {
            // Don't show the toast when rotating, or when opening an Activity on top of this one.
            return !isChangingConfigurations() && !mPickingAttachment;
        }

        @Override
        protected void onSuccess(Long draftId) {
            // Note that send or save tasks are always completed, even if the activity
            // finishes earlier.
            sActiveSaveTasks.remove(mTaskId);
            // Don't display the toast if the user is just changing the orientation
            if (!mSend && shouldShowSaveToast()) {
                Toast.makeText(mContext, R.string.message_saved_toast, Toast.LENGTH_LONG).show();
            }
        }
    }

    /**
     * Send or save a message:
     * - out of the UI thread
     * - write to Drafts
     * - if send, invoke Controller.sendMessage()
     * - when operation is complete, display toast
     */
    private void sendOrSaveMessage(boolean send) {
        if (!mMessageLoaded) {
            Log.w(Logging.LOG_TAG,
                    ""Attempted to save draft message prior to the state being fully loaded"");
            return;
        }
        synchronized (sActiveSaveTasks) {
            mLastSaveTaskId = sNextSaveTaskId++;

            SendOrSaveMessageTask task = new SendOrSaveMessageTask(mLastSaveTaskId, send);

            // Ensure the tasks are executed serially so that rapid scheduling doesn't result
            // in inconsistent data.
            task.executeSerial();
        }
   }

    private void saveIfNeeded() {
        if (!mDraftNeedsSaving) {
            return;
        }
        setMessageChanged(false);
        sendOrSaveMessage(false);
    }

    /**
     * Checks whether all the email addresses listed in TO, CC, BCC are valid.
     */
    @VisibleForTesting
    boolean isAddressAllValid() {
        boolean supportsChips = ChipsUtil.supportsChipsUi();
        for (TextView view : new TextView[]{mToView, mCcView, mBccView}) {
            String addresses = view.getText().toString().trim();
            if (!Address.isAllValid(addresses)) {
                // Don't show an error message if we're using chips as the chips have
                // their own error state.
                if (!supportsChips || !(view instanceof RecipientEditTextView)) {
                    view.setError(getString(R.string.message_compose_error_invalid_email));
                }
                return false;
            }
        }
        return true;
    }

    private void onSend() {
        if (!isAddressAllValid()) {
            Toast.makeText(this, getString(R.string.message_compose_error_invalid_email),
                           Toast.LENGTH_LONG).show();
        } else if (getAddresses(mToView).length == 0 &&
                getAddresses(mCcView).length == 0 &&
                getAddresses(mBccView).length == 0) {
            mToView.setError(getString(R.string.message_compose_error_no_recipients));
            Toast.makeText(this, getString(R.string.message_compose_error_no_recipients),
                    Toast.LENGTH_LONG).show();
        } else {
            sendOrSaveMessage(true);
            setMessageChanged(false);
            finish();
        }
    }

    private void showQuickResponseDialog() {
        if (mAccount == null) {
            // Load not finished, bail.
            return;
        }
        InsertQuickResponseDialog.newInstance(null, mAccount)
                .show(getFragmentManager(), null);
    }

    /**
     * Inserts the selected QuickResponse into the message body at the current cursor position.
     */
    @Override
    public void onQuickResponseSelected(CharSequence text) {
        int start = mMessageContentView.getSelectionStart();
        int end = mMessageContentView.getSelectionEnd();
        mMessageContentView.getEditableText().replace(start, end, text);
    }

    private void onDiscard() {
        DeleteMessageConfirmationDialog.newInstance(1, null).show(getFragmentManager(), ""dialog"");
    }

    /**
     * Called when ok on the ""discard draft"" dialog is pressed.  Actually delete the draft.
     */
    @Override
    public void onDeleteMessageConfirmationDialogOkPressed() {
        if (mDraft.mId > 0) {
            // By the way, we can't pass the message ID from onDiscard() to here (using a
            // dialog argument or whatever), because you can rotate the screen when the dialog is
            // shown, and during rotation we save & restore the draft.  If it's the
            // first save, we give it an ID at this point for the first time (and last time).
            // Which means it's possible for a draft to not have an ID in onDiscard(),
            // but here.
            mController.deleteMessage(mDraft.mId);
        }
        Utility.showToast(MessageCompose.this, R.string.message_discarded_toast);
        setMessageChanged(false);
        finish();
    }

    /**
     * Handles an explicit user-initiated action to save a draft.
     */
    private void onSave() {
        saveIfNeeded();
    }

    private void showCcBccFieldsIfFilled() {
        if ((mCcView.length() > 0) || (mBccView.length() > 0)) {
            showCcBccFields();
        }
    }

    private void showCcBccFields() {
        if (mCcBccContainer.getVisibility() != View.VISIBLE) {
            mCcBccContainer.setVisibility(View.VISIBLE);
            mCcView.requestFocus();
            UiUtilities.setVisibilitySafe(this, R.id.add_cc_bcc, View.INVISIBLE);
            invalidateOptionsMenu();
        }
    }

    /**
     * Kick off a picker for whatever kind of MIME types we'll accept and let Android take over.
     */
    private void onAddAttachment() {
        Intent i = new Intent(Intent.ACTION_GET_CONTENT);
        i.addCategory(Intent.CATEGORY_OPENABLE);
        i.setType(AttachmentUtilities.ACCEPTABLE_ATTACHMENT_SEND_UI_TYPES[0]);
        mPickingAttachment = true;
        startActivityForResult(
                Intent.createChooser(i, getString(R.string.choose_attachment_dialog_title)),
                ACTIVITY_REQUEST_PICK_ATTACHMENT);
    }

    private Attachment loadAttachmentInfo(Uri uri) {
        long size = -1;
        ContentResolver contentResolver = getContentResolver();

        // Load name & size independently, because not all providers support both
        final String name = Utility.getContentFileName(this, uri);

        Cursor metadataCursor = contentResolver.query(uri, ATTACHMENT_META_SIZE_PROJECTION,
                null, null, null);
        if (metadataCursor != null) {
            try {
                if (metadataCursor.moveToFirst()) {
                    size = metadataCursor.getLong(ATTACHMENT_META_SIZE_COLUMN_SIZE);
                }
            } finally {
                metadataCursor.close();
            }
        }

        // When the size is not provided, we need to determine it locally.
        if (size < 0) {
            // if the URI is a file: URI, ask file system for its size
            if (""file"".equalsIgnoreCase(uri.getScheme())) {
                String path = uri.getPath();
                if (path != null) {
                    File file = new File(path);
                    size = file.length();  // Returns 0 for file not found
                }
            }

            if (size <= 0) {
                // The size was not measurable;  This attachment is not safe to use.
                // Quick hack to force a relevant error into the UI
                // TODO: A proper announcement of the problem
                size = AttachmentUtilities.MAX_ATTACHMENT_UPLOAD_SIZE + 1;
            }
        }

        Attachment attachment = new Attachment();
        attachment.mFileName = name;
        attachment.mContentUri = uri.toString();
        attachment.mSize = size;
        attachment.mMimeType = AttachmentUtilities.inferMimeTypeForUri(this, uri);
        return attachment;
    }

    private void addAttachment(Attachment attachment) {
        // Before attaching the attachment, make sure it meets any other pre-attach criteria
        if (attachment.mSize > AttachmentUtilities.MAX_ATTACHMENT_UPLOAD_SIZE) {
            Toast.makeText(this, R.string.message_compose_attachment_size, Toast.LENGTH_LONG)
                    .show();
            return;
        }

        mAttachments.add(attachment);
        updateAttachmentUi();
    }

    private void updateAttachmentUi() {
        mAttachmentContentView.removeAllViews();

        for (Attachment attachment : mAttachments) {
            // Note: allowDelete is set in two cases:
            // 1. First time a message (w/ attachments) is forwarded,
            //    where action == ACTION_FORWARD
            // 2. 1 -> Save -> Reopen
            //    but FLAG_SMART_FORWARD is already set at 1.
            // Even if the account supports smart-forward, attachments added
            // manually are still removable.
            final boolean allowDelete = (attachment.mFlags & Attachment.FLAG_SMART_FORWARD) == 0;

            View view = getLayoutInflater().inflate(R.layout.attachment, mAttachmentContentView,
                    false);
            TextView nameView = UiUtilities.getView(view, R.id.attachment_name);
            ImageView delete = UiUtilities.getView(view, R.id.remove_attachment);
            TextView sizeView = UiUtilities.getView(view, R.id.attachment_size);

            nameView.setText(attachment.mFileName);
            if (attachment.mSize > 0) {
                sizeView.setText(UiUtilities.formatSize(this, attachment.mSize));
            } else {
                sizeView.setVisibility(View.GONE);
            }
            if (allowDelete) {
                delete.setOnClickListener(this);
                delete.setTag(view);
            } else {
                delete.setVisibility(View.INVISIBLE);
            }
            view.setTag(attachment);
            mAttachmentContentView.addView(view);
        }
        updateAttachmentContainer();
    }

    private void updateAttachmentContainer() {
        mAttachmentContainer.setVisibility(mAttachmentContentView.getChildCount() == 0
                ? View.GONE : View.VISIBLE);
    }

    private void addAttachmentFromUri(Uri uri) {
        addAttachment(loadAttachmentInfo(uri));
    }

    /**
     * Same as {@link #addAttachmentFromUri}, but does the mime-type check against
     * {@link AttachmentUtilities#ACCEPTABLE_ATTACHMENT_SEND_INTENT_TYPES}.
     */
    private void addAttachmentFromSendIntent(Uri uri) {
        final Attachment attachment = loadAttachmentInfo(uri);
        final String mimeType = attachment.mMimeType;
        if (!TextUtils.isEmpty(mimeType) && MimeUtility.mimeTypeMatches(mimeType,
                AttachmentUtilities.ACCEPTABLE_ATTACHMENT_SEND_INTENT_TYPES)) {
            addAttachment(attachment);
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        mPickingAttachment = false;
        if (data == null) {
            return;
        }
        addAttachmentFromUri(data.getData());
        setMessageChanged(true);
    }

    private boolean includeQuotedText() {
        return mIncludeQuotedTextCheckBox.isChecked();
    }

    public void onClick(View view) {
        if (handleCommand(view.getId())) {
            return;
        }
        switch (view.getId()) {
            case R.id.remove_attachment:
                onDeleteAttachmentIconClicked(view);
                break;
        }
    }

    private void setIncludeQuotedText(boolean include, boolean updateNeedsSaving) {
        mIncludeQuotedTextCheckBox.setChecked(include);
        mQuotedText.setVisibility(mIncludeQuotedTextCheckBox.isChecked()
                ? View.VISIBLE : View.GONE);
        if (updateNeedsSaving) {
            setMessageChanged(true);
        }
    }

    private void onDeleteAttachmentIconClicked(View delButtonView) {
        View attachmentView = (View) delButtonView.getTag();
        Attachment attachment = (Attachment) attachmentView.getTag();
        deleteAttachment(mAttachments, attachment);
        updateAttachmentUi();
        setMessageChanged(true);
    }

    /**
     * Removes an attachment from the current message.
     * If the attachment has previous been saved in the db (i.e. this is a draft message which
     * has previously been saved), then the draft is deleted from the db.
     *
     * This does not update the UI to remove the attachment view.
     * @param attachments the list of attachments to delete from. Injected for tests.
     * @param attachment the attachment to delete
     */
    private void deleteAttachment(List<Attachment> attachments, Attachment attachment) {
        attachments.remove(attachment);
        if ((attachment.mMessageKey == mDraft.mId) && attachment.isSaved()) {
            final long attachmentId = attachment.mId;
            EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
                public void run() {
                    mController.deleteAttachment(attachmentId);
                }
            });
        }
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (handleCommand(item.getItemId())) {
            return true;
        }
        return super.onOptionsItemSelected(item);
    }

    private boolean handleCommand(int viewId) {
        switch (viewId) {
        case android.R.id.home:
            onBack(false /* systemKey */);
            return true;
        case R.id.send:
            onSend();
            return true;
        case R.id.save:
            onSave();
            return true;
        case R.id.show_quick_text_list_dialog:
            showQuickResponseDialog();
            return true;
        case R.id.discard:
            onDiscard();
            return true;
        case R.id.include_quoted_text:
            // The checkbox is already toggled at this point.
            setIncludeQuotedText(mIncludeQuotedTextCheckBox.isChecked(), true);
            return true;
        case R.id.add_cc_bcc:
            showCcBccFields();
            return true;
        case R.id.add_attachment:
            onAddAttachment();
            return true;
        case R.id.settings:
            AccountSettings.actionSettings(this, mAccount.mId);
            return true;
        }
        return false;
    }

    /**
     * Handle a tap to the system back key, or the ""app up"" button in the action bar.
     * @param systemKey whether or not the system key was pressed
     */
    private void onBack(boolean systemKey) {
        finish();
        if (isOpenedFromWithinApp()) {
            // If opened from within the app, we just close it.
            return;
        }

        if (isOpenedFromWidget() || !systemKey) {
            // Otherwise, need to open the main screen for the appropriate account.
            // Note that mAccount should always be set by the time the action bar is set up.
            startActivity(Welcome.createOpenAccountInboxIntent(this, mAccount.mId));
        }
    }

    private void setAction(String action) {
        if (Objects.equal(action, mAction)) {
            return;
        }

        mAction = action;
        onActionChanged();
    }

    /**
     * Handles changing from reply/reply all/forward states. Note: this activity cannot transition
     * from a standard compose state to any of the other three states.
     */
    private void onActionChanged() {
        if (!hasSourceMessage()) {
            return;
        }
        // Temporarily remove listeners so that changing action does not invalidate and save message
        removeListeners();

        processSourceMessage(mSource, mAccount);

        // Note that the attachments might not be loaded yet, but this will safely noop
        // if that's the case, and the attachments will be processed when they load.
        if (processSourceMessageAttachments(mAttachments, mSourceAttachments, isForward())) {
            updateAttachmentUi();
            setMessageChanged(true);
        }

        updateActionSelector();
        addListeners();
    }

    /**
     * Updates UI components that allows the user to switch between reply/reply all/forward.
     */
    private void updateActionSelector() {
        ActionBar actionBar = getActionBar();
        if (shouldUseActionTabs()) {
            // Tab-based mode switching.
            if (actionBar.getTabCount() > 0) {
                selectActionTab(mAction);
            } else {
                createAndAddTab(R.string.reply_action, ACTION_REPLY);
                createAndAddTab(R.string.reply_all_action, ACTION_REPLY_ALL);
                createAndAddTab(R.string.forward_action, ACTION_FORWARD);
            }

            actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
        } else {
            // Spinner based mode switching.
            if (mActionSpinnerAdapter == null) {
                mActionSpinnerAdapter = new ActionSpinnerAdapter(this);
                actionBar.setListNavigationCallbacks(
                        mActionSpinnerAdapter, ACTION_SPINNER_LISTENER);
            }
            actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
            actionBar.setSelectedNavigationItem(
                    ActionSpinnerAdapter.getActionPosition(mAction));
        }
        actionBar.setDisplayShowTitleEnabled(false);
    }

    private final TabListener ACTION_TAB_LISTENER = new TabListener() {
        @Override public void onTabReselected(Tab tab, FragmentTransaction ft) {}
        @Override public void onTabUnselected(Tab tab, FragmentTransaction ft) {}

        @Override
        public void onTabSelected(Tab tab, FragmentTransaction ft) {
            String action = (String) tab.getTag();
            setAction(action);
        }
    };

    private final OnNavigationListener ACTION_SPINNER_LISTENER = new OnNavigationListener() {
        @Override
        public boolean onNavigationItemSelected(int itemPosition, long itemId) {
            setAction(ActionSpinnerAdapter.getAction(itemPosition));
            return true;
        }
    };

    private static class ActionSpinnerAdapter extends ArrayAdapter<String> {
        public ActionSpinnerAdapter(final Context context) {
            super(context,
                    android.R.layout.simple_spinner_dropdown_item,
                    android.R.id.text1,
                    Lists.newArrayList(ACTION_REPLY, ACTION_REPLY_ALL, ACTION_FORWARD));
        }

        @Override
        public View getDropDownView(int position, View convertView, ViewGroup parent) {
            View result = super.getDropDownView(position, convertView, parent);
            ((TextView) result.findViewById(android.R.id.text1)).setText(getDisplayValue(position));
            return result;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            View result = super.getView(position, convertView, parent);
            ((TextView) result.findViewById(android.R.id.text1)).setText(getDisplayValue(position));
            return result;
        }

        private String getDisplayValue(int position) {
            switch (position) {
                case 0:
                    return getContext().getString(R.string.reply_action);
                case 1:
                    return getContext().getString(R.string.reply_all_action);
                case 2:
                    return getContext().getString(R.string.forward_action);
                default:
                    throw new IllegalArgumentException(""Invalid action type for spinner"");
            }
        }

        public static String getAction(int position) {
            switch (position) {
                case 0:
                    return ACTION_REPLY;
                case 1:
                    return ACTION_REPLY_ALL;
                case 2:
                    return ACTION_FORWARD;
                default:
                    throw new IllegalArgumentException(""Invalid action type for spinner"");
            }
        }

        public static int getActionPosition(String action) {
            if (ACTION_REPLY.equals(action)) {
                return 0;
            } else if (ACTION_REPLY_ALL.equals(action)) {
                return 1;
            } else if (ACTION_FORWARD.equals(action)) {
                return 2;
            }
            throw new IllegalArgumentException(""Invalid action type for spinner"");
        }

    }

    private Tab createAndAddTab(int labelResource, final String action) {
        ActionBar.Tab tab = getActionBar().newTab();
        boolean selected = mAction.equals(action);
        tab.setTag(action);
        tab.setText(getString(labelResource));
        tab.setTabListener(ACTION_TAB_LISTENER);
        getActionBar().addTab(tab, selected);
        return tab;
    }

    private void selectActionTab(final String action) {
        final ActionBar actionBar = getActionBar();
        for (int i = 0, n = actionBar.getTabCount(); i < n; i++) {
            ActionBar.Tab tab = actionBar.getTabAt(i);
            if (action.equals(tab.getTag())) {
                actionBar.selectTab(tab);
                return;
            }
        }
    }

    private boolean shouldUseActionTabs() {
        return getResources().getBoolean(R.bool.message_compose_action_tabs);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.message_compose_option, menu);
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        menu.findItem(R.id.save).setEnabled(mDraftNeedsSaving);
        MenuItem addCcBcc = menu.findItem(R.id.add_cc_bcc);
        if (addCcBcc != null) {
            // Only available on phones.
            addCcBcc.setVisible(
                    (mCcBccContainer == null) || (mCcBccContainer.getVisibility() != View.VISIBLE));
        }
        MenuItem insertQuickResponse = menu.findItem(R.id.show_quick_text_list_dialog);
        insertQuickResponse.setVisible(mQuickResponsesAvailable);
        insertQuickResponse.setEnabled(mQuickResponsesAvailable);
        return true;
    }

    /**
     * Set a message body and a signature when the Activity is launched.
     *
     * @param text the message body
     */
    @VisibleForTesting
    void setInitialComposeText(CharSequence text, String signature) {
        mMessageContentView.setText("""");
        int textLength = 0;
        if (text != null) {
            mMessageContentView.append(text);
            textLength = text.length();
        }
        if (!TextUtils.isEmpty(signature)) {
            if (textLength == 0 || text.charAt(textLength - 1) != '\n') {
                mMessageContentView.append(""\n"");
            }
            mMessageContentView.append(signature);

            // Reset cursor to right before the signature.
            mMessageContentView.setSelection(textLength);
        }
    }

    /**
     * Fill all the widgets with the content found in the Intent Extra, if any.
     *
     * Note that we don't actually check the intent action  (typically VIEW, SENDTO, or SEND).
     * There is enough overlap in the definitions that it makes more sense to simply check for
     * all available data and use as much of it as possible.
     *
     * With one exception:  EXTRA_STREAM is defined as only valid for ACTION_SEND.
     *
     * @param intent the launch intent
     */
    @VisibleForTesting
    void initFromIntent(Intent intent) {

        setAccount(intent);

        // First, add values stored in top-level extras
        String[] extraStrings = intent.getStringArrayExtra(Intent.EXTRA_EMAIL);
        if (extraStrings != null) {
            addAddresses(mToView, extraStrings);
        }
        extraStrings = intent.getStringArrayExtra(Intent.EXTRA_CC);
        if (extraStrings != null) {
            addAddresses(mCcView, extraStrings);
        }
        extraStrings = intent.getStringArrayExtra(Intent.EXTRA_BCC);
        if (extraStrings != null) {
            addAddresses(mBccView, extraStrings);
        }
        String extraString = intent.getStringExtra(Intent.EXTRA_SUBJECT);
        if (extraString != null) {
            mSubjectView.setText(extraString);
        }

        // Next, if we were invoked with a URI, try to interpret it
        // We'll take two courses here.  If it's mailto:, there is a specific set of rules
        // that define various optional fields.  However, for any other scheme, we'll simply
        // take the entire scheme-specific part and interpret it as a possible list of addresses.
        final Uri dataUri = intent.getData();
        if (dataUri != null) {
            if (""mailto"".equals(dataUri.getScheme())) {
                initializeFromMailTo(dataUri.toString());
            } else {
                String toText = dataUri.getSchemeSpecificPart();
                if (toText != null) {
                    addAddresses(mToView, toText.split("",""));
                }
            }
        }

        // Next, fill in the plaintext (note, this will override mailto:?body=)
        CharSequence text = intent.getCharSequenceExtra(Intent.EXTRA_TEXT);
        setInitialComposeText(text, getAccountSignature(mAccount));

        // Next, convert EXTRA_STREAM into an attachment
        if (Intent.ACTION_SEND.equals(mAction) && intent.hasExtra(Intent.EXTRA_STREAM)) {
            Uri uri = (Uri) intent.getParcelableExtra(Intent.EXTRA_STREAM);
            if (uri != null) {
                addAttachmentFromSendIntent(uri);
            }
        }

        if (Intent.ACTION_SEND_MULTIPLE.equals(mAction)
                && intent.hasExtra(Intent.EXTRA_STREAM)) {
            ArrayList<Parcelable> list = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
            if (list != null) {
                for (Parcelable parcelable : list) {
                    Uri uri = (Uri) parcelable;
                    if (uri != null) {
                        addAttachmentFromSendIntent(uri);
                    }
                }
            }
        }

        // Finally - expose fields that were filled in but are normally hidden, and set focus
        showCcBccFieldsIfFilled();
        setNewMessageFocus();
    }

    /**
     * When we are launched with an intent that includes a mailto: URI, we can actually
     * gather quite a few of our message fields from it.
     *
     * @param mailToString the href (which must start with ""mailto:"").
     */
    private void initializeFromMailTo(String mailToString) {

        // Chop up everything between mailto: and ? to find recipients
        int index = mailToString.indexOf(""?"");
        int length = ""mailto"".length() + 1;
        String to;
        try {
            // Extract the recipient after mailto:
            if (index == -1) {
                to = decode(mailToString.substring(length));
            } else {
                to = decode(mailToString.substring(length, index));
            }
            addAddresses(mToView, to.split("" ,""));
        } catch (UnsupportedEncodingException e) {
            Log.e(Logging.LOG_TAG, e.getMessage() + "" while decoding '"" + mailToString + ""'"");
        }

        // Extract the other parameters

        // We need to disguise this string as a URI in order to parse it
        Uri uri = Uri.parse(""foo://"" + mailToString);

        List<String> cc = uri.getQueryParameters(""cc"");
        addAddresses(mCcView, cc.toArray(new String[cc.size()]));

        List<String> otherTo = uri.getQueryParameters(""to"");
        addAddresses(mCcView, otherTo.toArray(new String[otherTo.size()]));

        List<String> bcc = uri.getQueryParameters(""bcc"");
        addAddresses(mBccView, bcc.toArray(new String[bcc.size()]));

        List<String> subject = uri.getQueryParameters(""subject"");
        if (subject.size() > 0) {
            mSubjectView.setText(subject.get(0));
        }

        List<String> body = uri.getQueryParameters(""body"");
        if (body.size() > 0) {
            setInitialComposeText(body.get(0), getAccountSignature(mAccount));
        }
    }

    private String decode(String s) throws UnsupportedEncodingException {
        return URLDecoder.decode(s, ""UTF-8"");
    }

    /**
     * Displays quoted text from the original email
     */
    private void displayQuotedText(String textBody, String htmlBody) {
        // Only use plain text if there is no HTML body
        boolean plainTextFlag = TextUtils.isEmpty(htmlBody);
        String text = plainTextFlag ? textBody : htmlBody;
        if (text != null) {
            text = plainTextFlag ? EmailHtmlUtil.escapeCharacterToDisplay(text) : text;
            // TODO: re-enable EmailHtmlUtil.resolveInlineImage() for HTML
            //    EmailHtmlUtil.resolveInlineImage(getContentResolver(), mAccount,
            //                                     text, message, 0);
            mQuotedTextArea.setVisibility(View.VISIBLE);
            if (mQuotedText != null) {
                mQuotedText.loadDataWithBaseURL(""email://"", text, ""text/html"", ""utf-8"", null);
            }
        }
    }

    /**
     * Given a packed address String, the address of our sending account, a view, and a list of
     * addressees already added to other addressing views, adds unique addressees that don't
     * match our address to the passed in view
     */
    private static boolean safeAddAddresses(String addrs, String ourAddress,
            MultiAutoCompleteTextView view, ArrayList<Address> addrList) {
        boolean added = false;
        for (Address address : Address.unpack(addrs)) {
            // Don't send to ourselves or already-included addresses
            if (!address.getAddress().equalsIgnoreCase(ourAddress) && !addrList.contains(address)) {
                addrList.add(address);
                addAddress(view, address.toString());
                added = true;
            }
        }
        return added;
    }

    /**
     * Set up the to and cc views properly for the ""reply"" and ""replyAll"" cases.  What's important
     * is that we not 1) send to ourselves, and 2) duplicate addressees.
     * @param message the message we're replying to
     * @param account the account we're sending from
     * @param replyAll whether this is a replyAll (vs a reply)
     */
    @VisibleForTesting
    void setupAddressViews(Message message, Account account, boolean replyAll) {
        // Start clean.
        clearAddressViews();

        // If Reply-to: addresses are included, use those; otherwise, use the From: address.
        Address[] replyToAddresses = Address.unpack(message.mReplyTo);
        if (replyToAddresses.length == 0) {
            replyToAddresses = Address.unpack(message.mFrom);
        }

        // Check if ourAddress is one of the replyToAddresses to decide how to populate To: field
        String ourAddress = account.mEmailAddress;
        boolean containsOurAddress = false;
        for (Address address : replyToAddresses) {
            if (ourAddress.equalsIgnoreCase(address.getAddress())) {
                containsOurAddress = true;
                break;
            }
        }

        if (containsOurAddress) {
            addAddresses(mToView, message.mTo);
        } else {
            addAddresses(mToView, replyToAddresses);
        }

        if (replyAll) {
            // Keep a running list of addresses we're sending to
            ArrayList<Address> allAddresses = new ArrayList<Address>();
            for (Address address: replyToAddresses) {
                allAddresses.add(address);
            }

            if (!containsOurAddress) {
                safeAddAddresses(message.mTo, ourAddress, mCcView, allAddresses);
            }

            safeAddAddresses(message.mCc, ourAddress, mCcView, allAddresses);
        }
        showCcBccFieldsIfFilled();
    }

    private void clearAddressViews() {
        mToView.setText("""");
        mCcView.setText("""");
        mBccView.setText("""");
    }

    /**
     * Pull out the parts of the now loaded source message and apply them to the new message
     * depending on the type of message being composed.
     */
    @VisibleForTesting
    void processSourceMessage(Message message, Account account) {
        String subject = message.mSubject;
        if (subject == null) {
            subject = """";
        }
        if (ACTION_REPLY.equals(mAction) || ACTION_REPLY_ALL.equals(mAction)) {
            setupAddressViews(message, account, ACTION_REPLY_ALL.equals(mAction));
            if (!subject.toLowerCase().startsWith(""re:"")) {
                mSubjectView.setText(""Re: "" + subject);
            } else {
                mSubjectView.setText(subject);
            }
            displayQuotedText(message.mText, message.mHtml);
            setIncludeQuotedText(true, false);
        } else if (ACTION_FORWARD.equals(mAction)) {
            clearAddressViews();
            mSubjectView.setText(!subject.toLowerCase().startsWith(""fwd:"")
                    ? ""Fwd: "" + subject : subject);
            displayQuotedText(message.mText, message.mHtml);
            setIncludeQuotedText(true, false);
        } else {
            Log.w(Logging.LOG_TAG, ""Unexpected action for a call to processSourceMessage ""
                    + mAction);
        }
        showCcBccFieldsIfFilled();
        setNewMessageFocus();
    }

    /**
     * Processes the source attachments and ensures they're either included or excluded from
     * a list of active attachments. This can be used to add attachments for a forwarded message, or
     * to remove them if going from a ""Forward"" to a ""Reply""
     * Uniqueness is based on filename.
     *
     * @param current the list of active attachments on the current message. Injected for tests.
     * @param sourceAttachments the list of attachments related with the source message. Injected
     *     for tests.
     * @param include whether or not the sourceMessages should be included or excluded from the
     *     current list of active attachments
     * @return whether or not the current attachments were modified
     */
    @VisibleForTesting
    boolean processSourceMessageAttachments(
            List<Attachment> current, List<Attachment> sourceAttachments, boolean include) {

        // Build a map of filename to the active attachments.
        HashMap<String, Attachment> currentNames = new HashMap<String, Attachment>();
        for (Attachment attachment : current) {
            currentNames.put(attachment.mFileName, attachment);
        }

        boolean dirty = false;
        if (include) {
            // Needs to make sure it's in the list.
            for (Attachment attachment : sourceAttachments) {
                if (!currentNames.containsKey(attachment.mFileName)) {
                    current.add(attachment);
                    dirty = true;
                }
            }
        } else {
            // Need to remove the source attachments.
            HashSet<String> sourceNames = new HashSet<String>();
            for (Attachment attachment : sourceAttachments) {
                if (currentNames.containsKey(attachment.mFileName)) {
                    deleteAttachment(current, currentNames.get(attachment.mFileName));
                    dirty = true;
                }
            }
        }

        return dirty;
    }

    /**
     * Set a cursor to the end of a body except a signature.
     */
    @VisibleForTesting
    void setMessageContentSelection(String signature) {
        int selection = mMessageContentView.length();
        if (!TextUtils.isEmpty(signature)) {
            int signatureLength = signature.length();
            int estimatedSelection = selection - signatureLength;
            if (estimatedSelection >= 0) {
                CharSequence text = mMessageContentView.getText();
                int i = 0;
                while (i < signatureLength
                       && text.charAt(estimatedSelection + i) == signature.charAt(i)) {
                    ++i;
                }
                if (i == signatureLength) {
                    selection = estimatedSelection;
                    while (selection > 0 && text.charAt(selection - 1) == '\n') {
                        --selection;
                    }
                }
            }
        }
        mMessageContentView.setSelection(selection, selection);
    }

    /**
     * In order to accelerate typing, position the cursor in the first empty field,
     * or at the end of the body composition field if none are empty.  Typically, this will
     * play out as follows:
     *   Reply / Reply All - put cursor in the empty message body
     *   Forward - put cursor in the empty To field
     *   Edit Draft - put cursor in whatever field still needs entry
     */
    private void setNewMessageFocus() {
        if (mToView.length() == 0) {
            mToView.requestFocus();
        } else if (mSubjectView.length() == 0) {
            mSubjectView.requestFocus();
        } else {
            mMessageContentView.requestFocus();
        }
    }

    private boolean isForward() {
        return ACTION_FORWARD.equals(mAction);
    }

    /**
     * @return the signature for the specified account, if non-null. If the account specified is
     *     null or has no signature, {@code null} is returned.
     */
    private static String getAccountSignature(Account account) {
        return (account == null) ? null : account.mSignature;
    }
}
",True,268,1,1,10,58,7,22,L6
64,com.android.email.activity.InsertQuickResponseDialog.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;
import com.android.email.activity.setup.
        AccountSettingsEditQuickResponsesFragment.QuickResponseFinder;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.utility.EmailAsyncTask;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.Fragment;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;

/**
 * Dialog which lists QuickResponses for the specified account. On user selection, will call
 * Callback.onQuickResponseSelected() with the selected QuickResponse text.
 */
public class InsertQuickResponseDialog extends DialogFragment
        implements DialogInterface.OnClickListener, OnItemClickListener {
    private ListView mQuickResponsesView;
    private EmailAsyncTask.Tracker mTaskTracker;

    // Key for the Account object in the arguments bundle
    private static final String ACCOUNT_KEY = ""account"";

    /**
     * Callback interface for when user selects a QuickResponse.
     */
    public interface Callback {
        /**
         * Handles the text of the selected QuickResponse.
         */
        public void onQuickResponseSelected(CharSequence quickResponse);
    }

    /**
     * Create and returns new dialog.
     *
     * @param callbackFragment fragment that implements {@link Callback}.  Or null, in which case
     * the parent activity must implement {@link Callback}.
     */
    public static InsertQuickResponseDialog
            newInstance(Fragment callbackFragment, Account account) {
        final InsertQuickResponseDialog dialog = new InsertQuickResponseDialog();

        // If a target is set, it MUST implement Callback. Fail-fast if not.
        final Callback callback;
        if (callbackFragment != null) {
            try {
                callback = (Callback) callbackFragment;
            } catch (ClassCastException e) {
                throw new ClassCastException(callbackFragment.toString()
                        + "" must implement Callback"");
            }
            dialog.setTargetFragment(callbackFragment, 0);
        }

        Bundle args = new Bundle();
        args.putParcelable(ACCOUNT_KEY, account);
        dialog.setArguments(args);
        return dialog;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        // If target not set, the parent activity MUST implement Callback. Fail-fast if not.
        final Fragment targetFragment = getTargetFragment();
        if (targetFragment != null) {
            final Callback callback;
            try {
                callback = (Callback) getActivity();
            } catch (ClassCastException e) {
                throw new ClassCastException(getActivity().toString() + "" must implement Callback"");
            }
        }

        // Now that Callback implementation is verified, build the dialog
        final Context context = getActivity();
        final AlertDialog.Builder b = new AlertDialog.Builder(context);

        mQuickResponsesView = new ListView(context);

        Account account = (Account) getArguments().getParcelable(ACCOUNT_KEY);
        mTaskTracker = new EmailAsyncTask.Tracker();
        new QuickResponseFinder(mTaskTracker, account.mId, mQuickResponsesView,
                context, null, this, false).executeParallel();

        b.setTitle(getResources()
                .getString(R.string.message_compose_insert_quick_response_list_title))
                .setView(mQuickResponsesView)
                .setNegativeButton(R.string.cancel_action, this);
        return b.create();
    }

    @Override
    public void onDestroy() {
        mTaskTracker.cancellAllInterrupt();
        super.onDestroy();
    }

    /**
     * Implements OnItemClickListener.
     */
    @Override
    public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
        getCallback().onQuickResponseSelected(
                mQuickResponsesView.getItemAtPosition(position).toString());
        dismiss();
    }

    /**
     * Implements DialogInterface.OnClickListener
     */
    @Override
    public void onClick(DialogInterface dialog, int which) {
        if (which == DialogInterface.BUTTON_NEGATIVE) {
            dialog.cancel();
        }
    }

    private Callback getCallback() {
        Fragment targetFragment = getTargetFragment();
        if (targetFragment != null) {
            return (Callback) targetFragment;
        }
        return (Callback) getActivity();
    }
}
",False,267,0,0,12,43,1,4,L6
65,com.android.email.activity.MessageList.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.R;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;

/**
 * A dummy activity to support old-style (pre-honeycomb) account shortcuts.
 */
public class MessageList extends Activity {
    @VisibleForTesting
    static final String EXTRA_ACCOUNT_ID = ""com.android.email.activity._ACCOUNT_ID"";

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final Activity me = this;
        new EmailAsyncTask<Void, Void, Long>(mTaskTracker) {
            @Override
            protected Long doInBackground(Void... params) {
                return getAccountFromIntent(me, getIntent());
            }

            @Override
            protected void onSuccess(Long accountId) {
                if ((accountId == null) || (accountId == Account.NO_ACCOUNT)) {
                    // Account deleted?
                    Utility.showToast(me, R.string.toast_account_not_found);
                    Welcome.actionStart(me);
                } else {
                    Welcome.actionOpenAccountInbox(me, accountId);
                }
                finish();
            }
        }.executeParallel();
    }

    @Override
    protected void onDestroy() {
        mTaskTracker.cancellAllInterrupt();
        super.onDestroy();
    }

    @VisibleForTesting
    static long getAccountFromIntent(Context context, Intent i) {
        final Uri uri = i.getData();
        if (uri == null) {
            return Account.NO_ACCOUNT;
        }
        return Account.getAccountIdFromShortcutSafeUri(context, uri);
    }

    /**
     * Create a froyo/gingerbread style account shortcut intent.  Used by unit tests and
     * test code in {@link ShortcutPicker}.
     */
    @VisibleForTesting
    static Intent createFroyoIntent(Context context, Account account) {
        final Intent intent = new Intent(context, MessageList.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        intent.putExtra(EXTRA_ACCOUNT_ID, account.mId);
        intent.setData(account.getShortcutSafeUri());

        return intent;
    }
}
",False,268,1,1,12,52,2,5,L6
66,com.android.email.activity.MoveMessageToDialog.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.Fragment;
import android.app.LoaderManager;
import android.content.AsyncTaskLoader;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Loader;
import android.database.Cursor;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;

import com.android.email.Email;
import com.android.email.R;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.Utility;

/**
 * ""Move (messages) to"" dialog. This is a modal dialog and the design is such so that only one is
 * active. If a new instance is created while an existing one is active, the existing one is
 * dismissed.
 *
 * TODO The check logic in MessageCheckerCallback is not efficient.  It shouldn't restore full
 * Message objects.
 */
public class MoveMessageToDialog extends DialogFragment implements DialogInterface.OnClickListener {
    private static final String BUNDLE_MESSAGE_IDS = ""message_ids"";

    private static final int LOADER_ID_MOVE_TO_DIALOG_MAILBOX_LOADER = 1;
    private static final int LOADER_ID_MOVE_TO_DIALOG_MESSAGE_CHECKER = 2;

    /** Message IDs passed to {@link #newInstance} */
    private long[] mMessageIds;
    private MailboxMoveToAdapter mAdapter;

    /** ID of the account that contains all of the messages to move */
    private long mAccountId;
    /** ID of the mailbox that contains all of the messages to move */
    private long mMailboxId;

    private boolean mDestroyed;

    /**
     * Callback that target fragments, or the owner activity should implement.
     */
    public interface Callback {
        public void onMoveToMailboxSelected(long newMailboxId, long[] messageIds);
    }

    /**
     * Create and return a new instance.
     *
     * @param messageIds IDs of the messages to be moved.
     * @param callbackFragment Fragment that gets a callback.  The fragment must implement
     *     {@link Callback}.
     */
    public static <T extends Fragment & Callback> MoveMessageToDialog newInstance(long[] messageIds,
            T callbackFragment) {
        if (messageIds.length == 0) {
            throw new IllegalArgumentException();
        }
        if (callbackFragment == null) {
            throw new IllegalArgumentException(); // fail fast
        }
        MoveMessageToDialog dialog = new MoveMessageToDialog();
        Bundle args = new Bundle();
        args.putLongArray(BUNDLE_MESSAGE_IDS, messageIds);
        dialog.setArguments(args);
        dialog.setTargetFragment(callbackFragment, 0);
        return dialog;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, """" + this + "" onCreate  target="" + getTargetFragment());
        }
        super.onCreate(savedInstanceState);
        mMessageIds = getArguments().getLongArray(BUNDLE_MESSAGE_IDS);
        setStyle(STYLE_NORMAL, android.R.style.Theme_Holo_Light);
    }

    @Override
    public void onDestroy() {
        mDestroyed = true;
        super.onDestroy();
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        final Activity activity = getActivity();

        // Build adapter & dialog
        // Make sure to pass Builder's context to the adapter, so that it'll get the correct theme.
        AlertDialog.Builder builder = new AlertDialog.Builder(activity)
                .setTitle(activity.getResources().getString(R.string.move_to_folder_dialog_title));

        mAdapter = new MailboxMoveToAdapter(builder.getContext());
        builder.setSingleChoiceItems(mAdapter, -1, this);

        getLoaderManager().initLoader(
                LOADER_ID_MOVE_TO_DIALOG_MESSAGE_CHECKER,
                null, new MessageCheckerCallback());

        return builder.create();
    }

    @Override
    public void onStart() {
        super.onStart();

        if (mAdapter.getCursor() == null) {
            // Data isn't ready - don't show yet.
            getDialog().hide();
        }
    }

    /**
     * The active move message dialog. This dialog is fairly modal so it only makes sense to have
     * one instance active, and for debounce purposes, we dismiss any existing ones.
     *
     * Only touched on the UI thread so doesn't require synchronization.
     */
    static MoveMessageToDialog sActiveDialog;

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        if (sActiveDialog != null) {
            // Something is already attached. Dismiss it!
            sActiveDialog.dismissAsync();
        }

        sActiveDialog = this;
    }

    @Override
    public void onDetach() {
        super.onDetach();

        if (sActiveDialog == this) {
            sActiveDialog = null;
        }
    }

    @Override
    public void onClick(DialogInterface dialog, int position) {
        final long mailboxId = mAdapter.getItemId(position);

        ((Callback) getTargetFragment()).onMoveToMailboxSelected(mailboxId, mMessageIds);
        dismiss();
    }

    /**
     * Delay-call {@link #dismissAllowingStateLoss()} using a {@link Handler}.  Calling
     * {@link #dismissAllowingStateLoss()} from {@link LoaderManager.LoaderCallbacks#onLoadFinished}
     * is not allowed, so we use it instead.
     */
    private void dismissAsync() {
        Utility.getMainThreadHandler().post(new Runnable() {
            @Override
            public void run() {
                if (!mDestroyed) {
                    dismissAllowingStateLoss();
                }
            }
        });
    }

    /**
     * Loader callback for {@link MessageChecker}
     */
    private class MessageCheckerCallback implements LoaderManager.LoaderCallbacks<IdContainer> {
        @Override
        public Loader<IdContainer> onCreateLoader(int id, Bundle args) {
            return new MessageChecker(getActivity(), mMessageIds);
        }

        @Override
        public void onLoadFinished(Loader<IdContainer> loader, IdContainer idSet) {
            if (mDestroyed) {
                return;
            }
            // accountId shouldn't be null, but I'm paranoia.
            if (idSet == null || idSet.mAccountId == Account.NO_ACCOUNT
                    || idSet.mMailboxId == Mailbox.NO_MAILBOX) {
                // Some of the messages can't be moved.  Close the dialog.
                dismissAsync();
                return;
            }
            mAccountId = idSet.mAccountId;
            mMailboxId = idSet.mMailboxId;
            getLoaderManager().initLoader(
                    LOADER_ID_MOVE_TO_DIALOG_MAILBOX_LOADER,
                    null, new MailboxesLoaderCallbacks());
        }

        @Override
        public void onLoaderReset(Loader<IdContainer> loader) {
        }
    }

    /**
     * Loader callback for destination mailbox list.
     */
    private class MailboxesLoaderCallbacks implements LoaderManager.LoaderCallbacks<Cursor> {
        @Override
        public Loader<Cursor> onCreateLoader(int id, Bundle args) {
            return MailboxMoveToAdapter.createLoader(getActivity().getApplicationContext(),
                    mAccountId, mMailboxId);
        }

        @Override
        public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
            if (mDestroyed) {
                return;
            }
            boolean needsShowing = (mAdapter.getCursor() == null);
            mAdapter.swapCursor(data);

            // The first time data is loaded, we need to show the dialog.
            if (needsShowing && isAdded()) {
                getDialog().show();
            }
        }

        @Override
        public void onLoaderReset(Loader<Cursor> loader) {
            mAdapter.swapCursor(null);
        }
    }

    /**
     * A loader that checks if the messages can be moved. If messages can be moved, it returns
     * the account and mailbox IDs where the messages are currently located. If any the messages
     * cannot be moved (such as the messages belong to different accounts), the IDs returned
     * will be {@link Account#NO_ACCOUNT} and {@link Mailbox#NO_MAILBOX}.
     */
    private static class MessageChecker extends AsyncTaskLoader<IdContainer> {
        private final Activity mActivity;
        private final long[] mMessageIds;

        public MessageChecker(Activity activity, long[] messageIds) {
            super(activity);
            mActivity = activity;
            mMessageIds = messageIds;
        }

        @Override
        public IdContainer loadInBackground() {
            final Context c = getContext();

            long accountId = Account.NO_ACCOUNT;
            long mailboxId = Mailbox.NO_MAILBOX;

            for (long messageId : mMessageIds) {
                // TODO This shouln't restore a full Message object.
                final Message message = Message.restoreMessageWithId(c, messageId);
                if (message == null) {
                    continue; // Skip removed messages.
                }

                // First, check account.
                if (accountId == Account.NO_ACCOUNT) {
                    // First, check if the account supports move
                    accountId = message.mAccountKey;
                    if (!Account.restoreAccountWithId(c, accountId).supportsMoveMessages(c)) {
                        Utility.showToast(
                                mActivity, R.string.cannot_move_protocol_not_supported_toast);
                        accountId = Account.NO_ACCOUNT;
                        break;
                    }
                    mailboxId = message.mMailboxKey;
                    // Second, check if the mailbox supports move
                    if (!Mailbox.restoreMailboxWithId(c, mailboxId).canHaveMessagesMoved()) {
                        Utility.showToast(mActivity, R.string.cannot_move_special_mailboxes_toast);
                        accountId = Account.NO_ACCOUNT;
                        mailboxId = Mailbox.NO_MAILBOX;
                        break;
                    }
                } else {
                    // Subsequent messages; all messages must to belong to the same mailbox
                    if (message.mAccountKey != accountId || message.mMailboxKey != mailboxId) {
                        Utility.showToast(mActivity, R.string.cannot_move_multiple_accounts_toast);
                        accountId = Account.NO_ACCOUNT;
                        mailboxId = Mailbox.NO_MAILBOX;
                        break;
                    }
                }
            }
            return new IdContainer(accountId, mailboxId);
        }

        @Override
        protected void onStartLoading() {
            cancelLoad();
            forceLoad();
        }

        @Override
        protected void onStopLoading() {
            cancelLoad();
        }

        @Override
        protected void onReset() {
            stopLoading();
        }
    }

    /** Container for multiple types of IDs */
    private static class IdContainer {
        private final long mAccountId;
        private final long mMailboxId;

        private IdContainer(long accountId, long mailboxId) {
            mAccountId = accountId;
            mMailboxId = mailboxId;
        }
    }
}
",True,267,0,0,11,47,2,7,L6
67,com.android.email.activity.MessageOrderManager.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.content.ContentResolver;
import android.content.Context;
import android.database.ContentObserver;
import android.database.Cursor;
import android.os.Handler;

import com.android.email.MessageListContext;
import com.android.email.activity.MessageOrderManager.Callback;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.DelayedOperations;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;

/**
 * Used by {@link MessageView} to determine the message-id of the previous/next messages.
 *
 * All public methods must be called on the main thread.
 *
 * Call {@link #moveTo} to set the current message id.  As a result,
 * either {@link Callback#onMessagesChanged} or {@link Callback#onMessageNotFound} is called.
 *
 * Use {@link #canMoveToNewer()} and {@link #canMoveToOlder()} to see if there is a newer/older
 * message, and {@link #moveToNewer()} and {@link #moveToOlder()} to update the current position.
 *
 * If the message list changes (e.g. message removed, new message arrived, etc), {@link Callback}
 * gets called again.
 *
 * When an instance is no longer needed, call {@link #close()}, which closes an underlying cursor
 * and shuts down an async task.
 *
 * TODO: Is there better words than ""newer""/""older"" that works even if we support other sort orders
 * than timestamp?
 */
public class MessageOrderManager {
    private final Context mContext;
    private final ContentResolver mContentResolver;

    private final MessageListContext mListContext;
    private final ContentObserver mObserver;
    private final Callback mCallback;
    private final DelayedOperations mDelayedOperations;

    private LoadMessageListTask mLoadMessageListTask;
    private Cursor mCursor;

    private long mCurrentMessageId = -1;

    private int mTotalMessageCount;

    private int mCurrentPosition;

    private boolean mClosed = false;

    public interface Callback {
        /**
         * Called when the message set by {@link MessageOrderManager#moveTo(long)} is found in the
         * mailbox.  {@link #canMoveToOlder}, {@link #canMoveToNewer}, {@link #moveToOlder} and
         * {@link #moveToNewer} are ready to be called.
         */
        public void onMessagesChanged();
        /**
         * Called when the message set by {@link MessageOrderManager#moveTo(long)} is not found.
         */
        public void onMessageNotFound();
    }

    /**
     * Wrapper for {@link Callback}, which uses {@link DelayedOperations#post(Runnable)} to
     * kick callbacks rather than calling them directly.  This is used to avoid the ""nested fragment
     * transaction"" exception.  e.g. {@link #moveTo} is often called during a fragment transaction,
     * and if the message no longer exists we call {@link #onMessageNotFound}, which most probably
     * triggers another fragment transaction.
     */
    private class PostingCallback implements Callback {
        private final Callback mOriginal;

        private PostingCallback(Callback original) {
            mOriginal = original;
        }

        private final Runnable mOnMessagesChangedRunnable = new Runnable() {
            @Override public void run() {
                mOriginal.onMessagesChanged();
            }
        };

        @Override
        public void onMessagesChanged() {
            mDelayedOperations.post(mOnMessagesChangedRunnable);
        }

        private final Runnable mOnMessageNotFoundRunnable = new Runnable() {
            @Override public void run() {
                mOriginal.onMessageNotFound();
            }
        };

        @Override
        public void onMessageNotFound() {
            mDelayedOperations.post(mOnMessageNotFoundRunnable);
        }
    }

    public MessageOrderManager(Context context, MessageListContext listContext, Callback callback) {
        this(context, listContext, callback, new DelayedOperations(Utility.getMainThreadHandler()));
    }

    @VisibleForTesting
    MessageOrderManager(Context context, MessageListContext listContext, Callback callback,
            DelayedOperations delayedOperations) {
        Preconditions.checkArgument(listContext.getMailboxId() != Mailbox.NO_MAILBOX);
        mContext = context.getApplicationContext();
        mContentResolver = mContext.getContentResolver();
        mDelayedOperations = delayedOperations;
        mListContext = listContext;
        mCallback = new PostingCallback(callback);
        mObserver = new ContentObserver(getHandlerForContentObserver()) {
                @Override public void onChange(boolean selfChange) {
                    if (mClosed) {
                        return;
                    }
                    onContentChanged();
                }
        };
        startTask();
    }

    public MessageListContext getListContext() {
        return mListContext;
    }

    public long getMailboxId() {
        return mListContext.getMailboxId();
    }

    /**
     * @return the total number of messages.
     */
    public int getTotalMessageCount() {
        return mTotalMessageCount;
    }

    /**
     * @return current cursor position, starting from 0.
     */
    public int getCurrentPosition() {
        return mCurrentPosition;
    }

    /**
     * @return a {@link Handler} for {@link ContentObserver}.
     *
     * Unit tests override this and return null, so that {@link ContentObserver#onChange} is
     * called synchronously.
     */
    /* package */ Handler getHandlerForContentObserver() {
        return new Handler();
    }

    private boolean isTaskRunning() {
        return mLoadMessageListTask != null;
    }

    private void startTask() {
        cancelTask();
        startQuery();
    }

    /**
     * Start {@link LoadMessageListTask} to query DB.
     * Unit tests override this to make tests synchronous and to inject a mock query.
     */
    /* package */ void startQuery() {
        mLoadMessageListTask = new LoadMessageListTask();
        mLoadMessageListTask.executeParallel();
    }

    private void cancelTask() {
        Utility.cancelTaskInterrupt(mLoadMessageListTask);
        mLoadMessageListTask = null;
    }

    private void closeCursor() {
        if (mCursor != null) {
            mCursor.close();
            mCursor = null;
        }
    }

    private void setCurrentMessageIdFromCursor() {
        if (mCursor != null) {
            mCurrentMessageId = mCursor.getLong(EmailContent.ID_PROJECTION_COLUMN);
        }
    }

    private void onContentChanged() {
        if (!isTaskRunning()) { // Start only if not running already.
            startTask();
        }
    }

    /**
     * Shutdown itself and release resources.
     */
    public void close() {
        mClosed = true;
        mDelayedOperations.removeCallbacks();
        cancelTask();
        closeCursor();
    }

    public long getCurrentMessageId() {
        return mCurrentMessageId;
    }

    /**
     * Set the current message id.  As a result, either {@link Callback#onMessagesChanged} or
     * {@link Callback#onMessageNotFound} is called.
     */
    public void moveTo(long messageId) {
        if (mCurrentMessageId != messageId) {
            mCurrentMessageId = messageId;
            adjustCursorPosition();
        }
    }

    private void adjustCursorPosition() {
        mCurrentPosition = 0;
        if (mCurrentMessageId == -1) {
            return; // Current ID not specified yet.
        }
        if (mCursor == null) {
            // Task not finished yet.
            // We call adjustCursorPosition() again when we've opened a cursor.
            return;
        }
        mCursor.moveToPosition(-1);
        while (mCursor.moveToNext()
                && mCursor.getLong(EmailContent.ID_PROJECTION_COLUMN) != mCurrentMessageId) {
            mCurrentPosition++;
        }
        if (mCursor.isAfterLast()) {
            mCurrentPosition = 0;
            mCallback.onMessageNotFound(); // Message not found... Already deleted?
        } else {
            mCallback.onMessagesChanged();
        }
    }

    /**
     * @return true if the message set to {@link #moveTo} has an older message in the mailbox.
     * false otherwise, or unknown yet.
     */
    public boolean canMoveToOlder() {
        return (mCursor != null) && !mCursor.isLast();
    }


    /**
     * @return true if the message set to {@link #moveTo} has an newer message in the mailbox.
     * false otherwise, or unknown yet.
     */
    public boolean canMoveToNewer() {
        return (mCursor != null) && !mCursor.isFirst();
    }

    /**
     * Move to the older message.
     *
     * @return true iif succeed, and {@link Callback#onMessagesChanged} is called.
     */
    public boolean moveToOlder() {
        if (canMoveToOlder() && mCursor.moveToNext()) {
            mCurrentPosition++;
            setCurrentMessageIdFromCursor();
            mCallback.onMessagesChanged();
            return true;
        } else {
            return false;
        }
    }

    /**
     * Move to the newer message.
     *
     * @return true iif succeed, and {@link Callback#onMessagesChanged} is called.
     */
    public boolean moveToNewer() {
        if (canMoveToNewer() && mCursor.moveToPrevious()) {
            mCurrentPosition--;
            setCurrentMessageIdFromCursor();
            mCallback.onMessagesChanged();
            return true;
        } else {
            return false;
        }
    }

    /**
     * Task to open a Cursor on a worker thread.
     */
    private class LoadMessageListTask extends EmailAsyncTask<Void, Void, Cursor> {
        public LoadMessageListTask() {
            super(null);
        }

        @Override
        protected Cursor doInBackground(Void... params) {
            return openNewCursor();
        }

        @Override
        protected void onCancelled(Cursor cursor) {
            if (cursor != null) {
                cursor.close();
            }
            onCursorOpenDone(null);
        }

        @Override
        protected void onSuccess(Cursor cursor) {
            onCursorOpenDone(cursor);
        }
    }

    /**
     * Open a new cursor for a message list.
     *
     * This method is called on a worker thread by LoadMessageListTask.
     */
    private Cursor openNewCursor() {
        final Cursor cursor = mContentResolver.query(EmailContent.Message.CONTENT_URI,
                EmailContent.ID_PROJECTION,
                Message.buildMessageListSelection(
                        mContext, mListContext.mAccountId, mListContext.getMailboxId()),
                null, EmailContent.MessageColumns.TIMESTAMP + "" DESC"");
        return cursor;
    }

    /**
     * Called when {@link #openNewCursor()} is finished.
     *
     * Unit tests call this directly to inject a mock cursor.
     */
    /* package */ void onCursorOpenDone(Cursor cursor) {
        try {
            closeCursor();
            if (cursor == null || cursor.isClosed()) {
                mTotalMessageCount = 0;
                mCurrentPosition = 0;
                return; // Task canceled
            }
            mCursor = cursor;
            mTotalMessageCount = mCursor.getCount();
            mCursor.registerContentObserver(mObserver);
            adjustCursorPosition();
        } finally {
            mLoadMessageListTask = null; // isTaskRunning() becomes false.
        }
    }
}
",True,268,1,1,11,63,4,6,L6
68,com.android.email.activity.MessageListItemCoordinates.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.android.email.activity;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Typeface;
import android.text.TextPaint;
import android.util.SparseArray;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.MeasureSpec;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.widget.TextView;

import com.android.email.R;

/**
 * Represents the coordinates of elements inside a CanvasConversationHeaderView
 * (eg, checkmark, star, subject, sender, labels, etc.) It will inflate a view,
 * and record the coordinates of each element after layout. This will allows us
 * to easily improve performance by creating custom view while still defining
 * layout in XML files.
 */
public class MessageListItemCoordinates {
    // Modes.
    public static final int WIDE_MODE = 0;
    public static final int NORMAL_MODE = 1;

    // Static threshold.
    private static int MINIMUM_WIDTH_WIDE_MODE = -1;
    private static int[] SUBJECT_LENGTHS;

    // Checkmark.
    int checkmarkX;
    int checkmarkY;
    int checkmarkWidthIncludingMargins;

    // Reply and forward state.
    int stateX;
    int stateY;

    // Star.
    int starX;
    int starY;

    // Senders.
    int sendersX;
    int sendersY;
    int sendersWidth;
    int sendersLineCount;
    int sendersFontSize;
    int sendersAscent;

    // Subject.
    int subjectX;
    int subjectY;
    int subjectWidth;
    int subjectLineCount;
    int subjectFontSize;
    int subjectAscent;

    // Color chip.
    int chipX;
    int chipY;
    int chipWidth;
    int chipHeight;

    // Date.
    int dateXEnd;
    int dateY;
    int dateFontSize;
    int dateAscent;

    // Paperclip.
    int paperclipY;

    // Cache to save Coordinates based on view width.
    private static SparseArray<MessageListItemCoordinates> mCache =
            new SparseArray<MessageListItemCoordinates>();

    private static TextPaint sPaint = new TextPaint();

    static {
        sPaint.setTypeface(Typeface.DEFAULT);
        sPaint.setAntiAlias(true);
    }

    // Not directly instantiable.
    private MessageListItemCoordinates() {}

    /**
     * Returns the mode of the header view (Wide/Normal/Narrow) given the its
     * measured width.
     */
    public static int getMode(Context context, int width) {
        Resources res = context.getResources();
        if (MINIMUM_WIDTH_WIDE_MODE <= 0) {
            MINIMUM_WIDTH_WIDE_MODE = res.getDimensionPixelSize(R.dimen.minimum_width_wide_mode);
        }

        // Choose the correct mode based on view width.
        int mode = NORMAL_MODE;
        if (width > MINIMUM_WIDTH_WIDE_MODE) {
            mode = WIDE_MODE;
        }
        return mode;
    }

    public static boolean isMultiPane(Context context) {
        return UiUtilities.useTwoPane(context);
    }

    /**
     * Returns the layout id to be inflated in this mode.
     */
    private static int getLayoutId(int mode) {
        switch (mode) {
            case WIDE_MODE:
                return R.layout.message_list_item_wide;
            case NORMAL_MODE:
                return R.layout.message_list_item_normal;
            default:
                throw new IllegalArgumentException(""Unknown conversation header view mode "" + mode);
        }
    }

    /**
     * Returns a value array multiplied by the specified density.
     */
    public static int[] getDensityDependentArray(int[] values, float density) {
        int result[] = new int[values.length];
        for (int i = 0; i < values.length; ++i) {
            result[i] = (int) (values[i] * density);
        }
        return result;
    }

    /**
     * Returns the height of the view in this mode.
     */
    public static int getHeight(Context context, int mode) {
        return context.getResources().getDimensionPixelSize(
                (mode == WIDE_MODE)
                        ? R.dimen.message_list_item_height_wide
                        : R.dimen.message_list_item_height_normal);
    }

    /**
     * Returns the x coordinates of a view by tracing up its hierarchy.
     */
    private static int getX(View view) {
        int x = 0;
        while (view != null) {
            x += (int) view.getX();
            ViewParent parent = view.getParent();
            view = parent != null ? (View) parent : null;
        }
        return x;
    }

    /**
     * Returns the y coordinates of a view by tracing up its hierarchy.
     */
    private static int getY(View view) {
        int y = 0;
        while (view != null) {
            y += (int) view.getY();
            ViewParent parent = view.getParent();
            view = parent != null ? (View) parent : null;
        }
        return y;
    }

    /**
     * Returns the width of a view.
     *
     * @param includeMargins whether or not to include margins when calculating
     *            width.
     */
    public static int getWidth(View view, boolean includeMargins) {
        ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();
        return view.getWidth() + (includeMargins ? params.leftMargin + params.rightMargin : 0);
    }

    /**
     * Returns the height of a view.
     *
     * @param includeMargins whether or not to include margins when calculating
     *            height.
     */
    public static int getHeight(View view, boolean includeMargins) {
        ViewGroup.MarginLayoutParams params = (ViewGroup.MarginLayoutParams) view.getLayoutParams();
        return view.getHeight() + (includeMargins ? params.topMargin + params.bottomMargin : 0);
    }

    /**
     * Returns the number of lines of this text view.
     */
    private static int getLineCount(TextView textView) {
        return textView.getHeight() / textView.getLineHeight();
    }

    /**
     * Returns the length (maximum of characters) of subject in this mode.
     */
    public static int getSubjectLength(Context context, int mode) {
        Resources res = context.getResources();
        if (SUBJECT_LENGTHS == null) {
            SUBJECT_LENGTHS = res.getIntArray(R.array.subject_lengths);
        }
        return SUBJECT_LENGTHS[mode];
    }

    /**
     * Reset the caches associated with the coordinate layouts.
     */
    static void resetCaches() {
        mCache.clear();
    }

    /**
     * Returns coordinates for elements inside a conversation header view given
     * the view width.
     */
    public static MessageListItemCoordinates forWidth(Context context, int width) {
        MessageListItemCoordinates coordinates = mCache.get(width);
        if (coordinates == null) {
            coordinates = new MessageListItemCoordinates();
            mCache.put(width, coordinates);
            // TODO: make the field computation done inside of the constructor and mark fields final

            // Layout the appropriate view.
            int mode = getMode(context, width);
            int height = getHeight(context, mode);
            View view = LayoutInflater.from(context).inflate(getLayoutId(mode), null);
            int widthSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY);
            int heightSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
            view.measure(widthSpec, heightSpec);
            view.layout(0, 0, width, height);

            // Records coordinates.
            View checkmark = view.findViewById(R.id.checkmark);
            coordinates.checkmarkX = getX(checkmark);
            coordinates.checkmarkY = getY(checkmark);
            coordinates.checkmarkWidthIncludingMargins = getWidth(checkmark, true);

            View star = view.findViewById(R.id.star);
            coordinates.starX = getX(star);
            coordinates.starY = getY(star);

            View state = view.findViewById(R.id.reply_state);
            coordinates.stateX = getX(state);
            coordinates.stateY = getY(state);

            TextView senders = (TextView) view.findViewById(R.id.senders);
            coordinates.sendersX = getX(senders);
            coordinates.sendersY = getY(senders);
            coordinates.sendersWidth = getWidth(senders, false);
            coordinates.sendersLineCount = getLineCount(senders);
            coordinates.sendersFontSize = (int) senders.getTextSize();
            coordinates.sendersAscent = Math.round(senders.getPaint().ascent());

            TextView subject = (TextView) view.findViewById(R.id.subject);
            coordinates.subjectX = getX(subject);
            coordinates.subjectY = getY(subject);
            coordinates.subjectWidth = getWidth(subject, false);
            coordinates.subjectLineCount = getLineCount(subject);
            coordinates.subjectFontSize = (int) subject.getTextSize();
            coordinates.subjectAscent = Math.round(subject.getPaint().ascent());

            View chip = view.findViewById(R.id.color_chip);
            coordinates.chipX = getX(chip);
            coordinates.chipY = getY(chip);
            coordinates.chipWidth = getWidth(chip, false);
            coordinates.chipHeight = getHeight(chip, false);

            TextView date = (TextView) view.findViewById(R.id.date);
            coordinates.dateXEnd = getX(date) + date.getWidth();
            coordinates.dateY = getY(date);
            coordinates.dateFontSize = (int) date.getTextSize();
            coordinates.dateAscent = Math.round(date.getPaint().ascent());

            // The x-value is computed relative to the date.
            View paperclip = view.findViewById(R.id.paperclip);
            coordinates.paperclipY = getY(paperclip);
        }
        return coordinates;
    }
}
",False,149,10,45,2,1,1,1,L6
69,com.android.email.activity.ThreePaneLayout.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.animation.Animator;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.TimeInterpolator;
import android.content.Context;
import android.content.res.Resources;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.DecelerateInterpolator;
import android.widget.LinearLayout;

import com.android.email.R;
import com.android.emailcommon.Logging;

/**
 * The ""three pane"" layout used on tablet.
 *
 * This layout can show up to two panes at any given time, and operates in two different modes.
 * See {@link #isPaneCollapsible()} for details on the two modes.
 *
 * TODO Unit tests, when UX is settled.
 *
 * TODO onVisiblePanesChanged() should be called *AFTER* the animation, not before.
 */
public class ThreePaneLayout extends LinearLayout implements View.OnClickListener {
    private static final boolean ANIMATION_DEBUG = false; // DON'T SUBMIT WITH true

    private static final int ANIMATION_DURATION = ANIMATION_DEBUG ? 1000 : 150;
    private static final TimeInterpolator INTERPOLATOR = new DecelerateInterpolator(1.75f);

    /** Uninitialized state -- {@link #changePaneState} hasn't been called yet. */
    private static final int STATE_UNINITIALIZED = -1;

    /** Mailbox list + message list both visible. */
    private static final int STATE_LEFT_VISIBLE = 0;

    /**
     * A view where the MessageView is visible. The MessageList is visible if
     * {@link #isPaneCollapsible} is false, but is otherwise collapsed and hidden.
     */
    private static final int STATE_RIGHT_VISIBLE = 1;

    /**
     * A view where the MessageView is partially visible and a collapsible MessageList on the left
     * has been expanded to be in view. {@link #isPaneCollapsible} must return true for this
     * state to be active.
     */
    private static final int STATE_MIDDLE_EXPANDED = 2;

    // Flags for getVisiblePanes()
    public static final int PANE_LEFT = 1 << 2;
    public static final int PANE_MIDDLE = 1 << 1;
    public static final int PANE_RIGHT = 1 << 0;

    /** Current pane state.  See {@link #changePaneState} */
    private int mPaneState = STATE_UNINITIALIZED;

    /** See {@link #changePaneState} and {@link #onFirstSizeChanged} */
    private int mInitialPaneState = STATE_UNINITIALIZED;

    private View mLeftPane;
    private View mMiddlePane;
    private View mRightPane;
    private MessageCommandButtonView mMessageCommandButtons;

    // Views used only when the left pane is collapsible.
    private View mFoggedGlass;

    private boolean mFirstSizeChangedDone;

    /** Mailbox list width.  Comes from resources. */
    private int mMailboxListWidth;
    /**
     * Message list width, on:
     * - the message list + message view mode, when the left pane is not collapsible
     * - the message view + expanded message list mode, when the left pane is collapsible
     * Comes from resources.
     */
    private int mMessageListWidth;

    /** Hold last animator to cancel. */
    private Animator mLastAnimator;

    /**
     * Hold last animator listener to cancel.  See {@link #startLayoutAnimation} for why
     * we need both {@link #mLastAnimator} and {@link #mLastAnimatorListener}
     */
    private AnimatorListener mLastAnimatorListener;

    // 2nd index for {@link #changePaneState}
    private static final int INDEX_VISIBLE = 0;
    private static final int INDEX_INVISIBLE = 1;
    private static final int INDEX_GONE = 2;

    // Arrays used in {@link #changePaneState}
    // First index: STATE_*
    // Second index: INDEX_*
    private View[][][] mShowHideViews;

    private Callback mCallback = EmptyCallback.INSTANCE;

    public interface Callback {
        /** Called when {@link ThreePaneLayout#getVisiblePanes()} has changed. */
        public void onVisiblePanesChanged(int previousVisiblePanes);
    }

    private static final class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();

        @Override public void onVisiblePanesChanged(int previousVisiblePanes) {}
    }

    public ThreePaneLayout(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        initView();
    }

    public ThreePaneLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        initView();
    }

    public ThreePaneLayout(Context context) {
        super(context);
        initView();
    }

    /** Perform basic initialization */
    private void initView() {
        setOrientation(LinearLayout.HORIZONTAL); // Always horizontal
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();

        mLeftPane = findViewById(R.id.left_pane);
        mMiddlePane = findViewById(R.id.middle_pane);
        mMessageCommandButtons =
                (MessageCommandButtonView) findViewById(R.id.message_command_buttons);

        mFoggedGlass = findViewById(R.id.fogged_glass);
        if (mFoggedGlass != null) {
            mRightPane = findViewById(R.id.right_pane_with_fog);
            mFoggedGlass.setOnClickListener(this);
        } else {
            mRightPane = findViewById(R.id.right_pane);
        }

        if (!isPaneCollapsible()) {
            mShowHideViews = new View[][][] {
                    // STATE_LEFT_VISIBLE
                    {
                        {mLeftPane, mMiddlePane}, // Visible
                        {mRightPane}, // Invisible
                        {mMessageCommandButtons}, // Gone
                    },
                    // STATE_RIGHT_VISIBLE
                    {
                        {mMiddlePane, mMessageCommandButtons, mRightPane}, // Visible
                        {mLeftPane}, // Invisible
                        {}, // Gone
                    },
                    // STATE_MIDDLE_EXPANDED
                    {
                        {}, // Visible
                        {}, // Invisible
                        {}, // Gone
                    },
            };
        } else {
            mShowHideViews = new View[][][] {
                    // STATE_LEFT_VISIBLE
                    {
                        {mLeftPane, mMiddlePane}, // Visible
                        {mRightPane, mFoggedGlass}, // Invisible
                        {mMessageCommandButtons}, // Gone
                    },
                    // STATE_RIGHT_VISIBLE
                    {
                        {mRightPane, mMessageCommandButtons}, // Visible
                        {mLeftPane, mMiddlePane, mFoggedGlass}, // Invisible
                        {}, // Gone
                    },
                    // STATE_MIDDLE_EXPANDED
                    {
                        {mMiddlePane, mRightPane, mMessageCommandButtons, mFoggedGlass}, // Visible
                        {mLeftPane}, // Invisible
                        {}, // Gone
                    },
            };
        }

        mInitialPaneState = STATE_LEFT_VISIBLE;

        final Resources resources = getResources();
        mMailboxListWidth = getResources().getDimensionPixelSize(
                R.dimen.mailbox_list_width);
        mMessageListWidth = getResources().getDimensionPixelSize(R.dimen.message_list_width);
    }


    public void setCallback(Callback callback) {
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
    }

    /**
     * Return whether or not the left pane should be collapsible.
     */
    public boolean isPaneCollapsible() {
        return mFoggedGlass != null;
    }

    public MessageCommandButtonView getMessageCommandButtons() {
        return mMessageCommandButtons;
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        SavedState ss = new SavedState(super.onSaveInstanceState());
        ss.mPaneState = mPaneState;
        return ss;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        // Called after onFinishInflate()
        SavedState ss = (SavedState) state;
        super.onRestoreInstanceState(ss.getSuperState());
        mInitialPaneState = ss.mPaneState;
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        if (!mFirstSizeChangedDone) {
            mFirstSizeChangedDone = true;
            onFirstSizeChanged();
        }
    }

    /**
     * @return bit flags for visible panes.  Combination of {@link #PANE_LEFT}, {@link #PANE_MIDDLE}
     * and {@link #PANE_RIGHT},
     */
    public int getVisiblePanes() {
        int ret = 0;
        if (mLeftPane.getVisibility() == View.VISIBLE) ret |= PANE_LEFT;
        if (mMiddlePane.getVisibility() == View.VISIBLE) ret |= PANE_MIDDLE;
        if (mRightPane.getVisibility() == View.VISIBLE) ret |= PANE_RIGHT;
        return ret;
    }

    public boolean isLeftPaneVisible() {
        return mLeftPane.getVisibility() == View.VISIBLE;
    }
    public boolean isMiddlePaneVisible() {
        return mMiddlePane.getVisibility() == View.VISIBLE;
    }
    public boolean isRightPaneVisible() {
        return mRightPane.getVisibility() == View.VISIBLE;
    }

    /**
     * Handles the back event.
     *
     */
    public boolean uncollapsePane() {
        if (!isPaneCollapsible()) {
            return false;
        }

        if (mPaneState == STATE_RIGHT_VISIBLE) {
            return changePaneState(STATE_MIDDLE_EXPANDED, true);
        } else if (mInitialPaneState == STATE_RIGHT_VISIBLE) {
            mInitialPaneState = STATE_MIDDLE_EXPANDED;
            return true;
        }

        return false;
    }

    /**
     * Show the left most pane.  (i.e. mailbox list)
     */
    public boolean showLeftPane() {
        return changePaneState(STATE_LEFT_VISIBLE, true);
    }

    /**
     * Before the first call to {@link #onSizeChanged}, we don't know the width of the view, so we
     * can't layout properly.  We just remember all the requests to {@link #changePaneState}
     * until the first {@link #onSizeChanged}, at which point we actually change to the last
     * requested state.
     */
    private void onFirstSizeChanged() {
        if (mInitialPaneState != STATE_UNINITIALIZED) {
            changePaneState(mInitialPaneState, false);
            mInitialPaneState = STATE_UNINITIALIZED;
        }
    }

    /**
     * Show the right most pane.  (i.e. message view)
     */
    public boolean showRightPane() {
        return changePaneState(STATE_RIGHT_VISIBLE, true);
    }

    private boolean changePaneState(int newState, boolean animate) {
        if (!isPaneCollapsible() && (newState == STATE_MIDDLE_EXPANDED)) {
            newState = STATE_RIGHT_VISIBLE;
        }
        if (!mFirstSizeChangedDone) {
            // Before first onSizeChanged(), we don't know the width of the view, so we can't
            // layout properly.
            // Just remember the new state and return.
            mInitialPaneState = newState;
            return false;
        }
        if (newState == mPaneState) {
            return false;
        }
        // Just make sure the first transition doesn't animate.
        if (mPaneState == STATE_UNINITIALIZED) {
            animate = false;
        }

        final int previousVisiblePanes = getVisiblePanes();
        mPaneState = newState;

        // Animate to the new state.
        // (We still use animator even if animate == false; we just use 0 duration.)
        final int totalWidth = getMeasuredWidth();

        final int expectedMailboxLeft;
        final int expectedMessageListWidth;

        final String animatorLabel; // for debug purpose

        if (!isPaneCollapsible()) {
            setViewWidth(mLeftPane, mMailboxListWidth);
            setViewWidth(mRightPane, totalWidth - mMessageListWidth);

            switch (mPaneState) {
                case STATE_LEFT_VISIBLE:
                    // mailbox + message list
                    animatorLabel = ""moving to [mailbox list + message list]"";
                    expectedMailboxLeft = 0;
                    expectedMessageListWidth = totalWidth - mMailboxListWidth;
                    break;
                case STATE_RIGHT_VISIBLE:
                    // message list + message view
                    animatorLabel = ""moving to [message list + message view]"";
                    expectedMailboxLeft = -mMailboxListWidth;
                    expectedMessageListWidth = mMessageListWidth;
                    break;
                default:
                    throw new IllegalStateException();
            }

        } else {
            setViewWidth(mLeftPane, mMailboxListWidth);
            setViewWidth(mRightPane, totalWidth);

            switch (mPaneState) {
                case STATE_LEFT_VISIBLE:
                    // message list + Message view -> mailbox + message list
                    animatorLabel = ""moving to [mailbox list + message list]"";
                    expectedMailboxLeft = 0;
                    expectedMessageListWidth = totalWidth - mMailboxListWidth;
                    break;
                case STATE_MIDDLE_EXPANDED:
                    // mailbox + message list -> message list + message view
                    animatorLabel = ""moving to [message list + message view]"";
                    expectedMailboxLeft = -mMailboxListWidth;
                    expectedMessageListWidth = mMessageListWidth;
                    break;
                case STATE_RIGHT_VISIBLE:
                    // message view only
                    animatorLabel = ""moving to [message view]"";
                    expectedMailboxLeft = -(mMailboxListWidth + mMessageListWidth);
                    expectedMessageListWidth = mMessageListWidth;
                    break;
                default:
                    throw new IllegalStateException();
            }
        }

        final View[][] showHideViews = mShowHideViews[mPaneState];
        final AnimatorListener listener = new AnimatorListener(animatorLabel,
                showHideViews[INDEX_VISIBLE],
                showHideViews[INDEX_INVISIBLE],
                showHideViews[INDEX_GONE],
                previousVisiblePanes);

        // Animation properties -- mailbox list left and message list width, at the same time.
        startLayoutAnimation(animate ? ANIMATION_DURATION : 0, listener,
                PropertyValuesHolder.ofInt(PROP_MAILBOX_LIST_LEFT,
                        getCurrentMailboxLeft(), expectedMailboxLeft),
                PropertyValuesHolder.ofInt(PROP_MESSAGE_LIST_WIDTH,
                        getCurrentMessageListWidth(), expectedMessageListWidth)
                );
        return true;
    }

    /**
     * @return The ID of the view for the left pane fragment.  (i.e. mailbox list)
     */
    public int getLeftPaneId() {
        return R.id.left_pane;
    }

    /**
     * @return The ID of the view for the middle pane fragment.  (i.e. message list)
     */
    public int getMiddlePaneId() {
        return R.id.middle_pane;
    }

    /**
     * @return The ID of the view for the right pane fragment.  (i.e. message view)
     */
    public int getRightPaneId() {
        return R.id.right_pane;
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.fogged_glass:
                if (!isPaneCollapsible()) {
                    return; // Shouldn't happen
                }
                changePaneState(STATE_RIGHT_VISIBLE, true);
                break;
        }
    }

    private void setViewWidth(View v, int value) {
        v.getLayoutParams().width = value;
        requestLayout();
    }

    private static final String PROP_MAILBOX_LIST_LEFT = ""mailboxListLeftAnim"";
    private static final String PROP_MESSAGE_LIST_WIDTH = ""messageListWidthAnim"";

    public void setMailboxListLeftAnim(int value) {
        ((ViewGroup.MarginLayoutParams) mLeftPane.getLayoutParams()).leftMargin = value;
        requestLayout();
    }

    public void setMessageListWidthAnim(int value) {
        setViewWidth(mMiddlePane, value);
    }

    private int getCurrentMailboxLeft() {
        return ((ViewGroup.MarginLayoutParams) mLeftPane.getLayoutParams()).leftMargin;
    }

    private int getCurrentMessageListWidth() {
        return mMiddlePane.getLayoutParams().width;
    }

    /**
     * Helper method to start animation.
     */
    private void startLayoutAnimation(int duration, AnimatorListener listener,
            PropertyValuesHolder... values) {
        if (mLastAnimator != null) {
            mLastAnimator.cancel();
        }
        if (mLastAnimatorListener != null) {
            if (ANIMATION_DEBUG) {
                Log.w(Logging.LOG_TAG, ""Anim: Cancelling last animation: "" + mLastAnimator);
            }
            // Animator.cancel() doesn't call listener.cancel() immediately, so sometimes
            // we end up cancelling the previous one *after* starting the next one.
            // Directly tell the listener it's cancelled to avoid that.
            mLastAnimatorListener.cancel();
        }

        final ObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(
                this, values).setDuration(duration);
        animator.setInterpolator(INTERPOLATOR);
        if (listener != null) {
            animator.addListener(listener);
        }
        mLastAnimator = animator;
        mLastAnimatorListener = listener;
        animator.start();
    }

    /**
     * Animation listener.
     *
     * Update the visibility of each pane before/after an animation.
     */
    private class AnimatorListener implements Animator.AnimatorListener {
        private final String mLogLabel;
        private final View[] mViewsVisible;
        private final View[] mViewsInvisible;
        private final View[] mViewsGone;
        private final int mPreviousVisiblePanes;

        private boolean mCancelled;

        public AnimatorListener(String logLabel, View[] viewsVisible, View[] viewsInvisible,
                View[] viewsGone, int previousVisiblePanes) {
            mLogLabel = logLabel;
            mViewsVisible = viewsVisible;
            mViewsInvisible = viewsInvisible;
            mViewsGone = viewsGone;
            mPreviousVisiblePanes = previousVisiblePanes;
        }

        private void log(String message) {
            if (ANIMATION_DEBUG) {
                Log.w(Logging.LOG_TAG, ""Anim: "" + mLogLabel + ""["" + this + ""] "" + message);
            }
        }

        public void cancel() {
            log(""cancel"");
            mCancelled = true;
        }

        /**
         * Show the about-to-become-visible panes before an animation.
         */
        @Override
        public void onAnimationStart(Animator animation) {
            log(""start"");
            for (View v : mViewsVisible) {
                v.setVisibility(View.VISIBLE);
            }

            // TODO These things, making invisible views and calling the visible pane changed
            // callback, should really be done in onAnimationEnd.
            // However, because we may want to initiate a fragment transaction in the callback but
            // by the time animation is done, the activity may be stopped (by user's HOME press),
            // it's not easy to get right.  For now, we just do this before the animation.
            for (View v : mViewsInvisible) {
                v.setVisibility(View.INVISIBLE);
            }
            for (View v : mViewsGone) {
                v.setVisibility(View.GONE);
            }
            mCallback.onVisiblePanesChanged(mPreviousVisiblePanes);
        }

        @Override
        public void onAnimationRepeat(Animator animation) {
        }

        @Override
        public void onAnimationCancel(Animator animation) {
        }

        /**
         * Hide the about-to-become-hidden panes after an animation.
         */
        @Override
        public void onAnimationEnd(Animator animation) {
            if (mCancelled) {
                return; // But they shouldn't be hidden when cancelled.
            }
            log(""end"");
        }
    }

    private static class SavedState extends BaseSavedState {
        int mPaneState;

        /**
         * Constructor called from {@link ThreePaneLayout#onSaveInstanceState()}
         */
        SavedState(Parcelable superState) {
            super(superState);
        }

        /**
         * Constructor called from {@link #CREATOR}
         */
        private SavedState(Parcel in) {
            super(in);
            mPaneState = in.readInt();
        }

        @Override
        public void writeToParcel(Parcel out, int flags) {
            super.writeToParcel(out, flags);
            out.writeInt(mPaneState);
        }

        public static final Parcelable.Creator<SavedState> CREATOR
                = new Parcelable.Creator<SavedState>() {
            public SavedState createFromParcel(Parcel in) {
                return new SavedState(in);
            }

            public SavedState[] newArray(int size) {
                return new SavedState[size];
            }
        };
    }
}
",False,149,10,45,1,2,4,2,L6
70,com.android.email.activity.AttachmentInfoDialog.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import com.android.email.AttachmentInfo;
import com.android.email.R;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.provider.Settings;

/**
 * ""Info"" dialog box
 */
public class AttachmentInfoDialog extends DialogFragment {
    private static final String BUNDLE_TITLE         = ""title"";
    private static final String BUNDLE_BODY_TEXT     = ""body_text"";
    private static final String BUNDLE_ACTION_TEXT   = ""action_text"";
    private static final String BUNDLE_ACTION_INTENT = ""action_intent"";

    /**
     * Returns a new dialog instance
     */
    public static AttachmentInfoDialog newInstance(Context context, int denyFlags) {
        Resources res = context.getResources();
        String title = res.getString(R.string.attachment_info_dialog_default_title);
        String bodyText = res.getString(R.string.attachment_info_unknown);
        String actionText = null;
        Intent actionIntent = null;

        // NOTE: Order here matters. There can be multiple reasons for denying an attachment,
        // so, we want to show the most important ones first (i.e. it's pointless to tell the
        // user to connect to wi-fi to download a 30mb attachment that is suspected of being
        // malware).
        if ((denyFlags & AttachmentInfo.DENY_MALWARE) != 0) {
            bodyText = res.getString(R.string.attachment_info_malware);
        } else if ((denyFlags & AttachmentInfo.DENY_POLICY) != 0) {
            bodyText = res.getString(R.string.attachment_info_policy);
        } else if ((denyFlags & AttachmentInfo.DENY_NOINTENT) != 0) {
            bodyText = res.getString(R.string.attachment_info_no_intent);
        } else if ((denyFlags & AttachmentInfo.DENY_NOSIDELOAD) != 0) {
            bodyText = res.getString(R.string.attachment_info_sideload_disabled);
            actionText = res.getString(R.string.attachment_info_application_settings);
            actionIntent = new Intent(Settings.ACTION_SECURITY_SETTINGS);
            actionIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            actionIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        } else if ((denyFlags & AttachmentInfo.DENY_APKINSTALL) != 0) {
            bodyText = res.getString(R.string.attachment_info_apk_install_disabled);
        } else if ((denyFlags & AttachmentInfo.DENY_WIFIONLY) != 0) {
            title = res.getString(R.string.attachment_info_dialog_wifi_title);
            bodyText = res.getString(R.string.attachment_info_wifi_only);
            actionText = res.getString(R.string.attachment_info_wifi_settings);
            actionIntent = new Intent(Settings.ACTION_WIFI_SETTINGS);
            actionIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            actionIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        }
        AttachmentInfoDialog dialog = new AttachmentInfoDialog();
        Bundle args = new Bundle();
        args.putString(BUNDLE_TITLE, title);
        args.putString(BUNDLE_BODY_TEXT, bodyText);
        args.putString(BUNDLE_ACTION_TEXT, actionText);
        args.putParcelable(BUNDLE_ACTION_INTENT, actionIntent);
        dialog.setArguments(args);
        return dialog;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        Bundle args = getArguments();
        Context context = getActivity();
        String title = args.getString(BUNDLE_TITLE);
        String infoText = args.getString(BUNDLE_BODY_TEXT);
        String actionText = args.getString(BUNDLE_ACTION_TEXT);
        final Intent actionIntent = args.getParcelable(BUNDLE_ACTION_INTENT);

        OnClickListener onClickListener = new OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                switch (which) {
                    case DialogInterface.BUTTON_POSITIVE:
                        startActivity(actionIntent);
                        break;
                    case DialogInterface.BUTTON_NEUTRAL:
                        dialog.dismiss();
                        break;
                }
            }
        };

        AlertDialog.Builder builder = new AlertDialog.Builder(context);
        builder.setTitle(title);
        builder.setMessage(infoText);
        builder.setNeutralButton(R.string.okay_action, onClickListener);
        if (actionText != null && actionIntent != null) {
            builder.setPositiveButton(actionText, onClickListener);
        }
        return builder.show();
    }
}
",False,267,0,0,13,40,1,1,L6
71,com.android.email.activity.MessageFileViewFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

import com.android.email.Email;
import com.android.email.R;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.utility.Utility;

/**
 * A {@link MessageViewFragmentBase} subclass for file based messages. (aka EML files)
 */
public class MessageFileViewFragment extends MessageViewFragmentBase {
    /**
     * URI of message to open.
     */
    private Uri mFileEmailUri;

    /**
     * # of instances of this class.  When it gets 0, and the last one is not destroying for
     * a config change, we delete all the EML files.
     */
    private static int sFragmentCount;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        sFragmentCount++;
    }

    @Override
    public View onCreateView(
            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        View result = super.onCreateView(inflater, container, savedInstanceState);

        // Actions are not available in this view.
        UiUtilities.setVisibilitySafe(result, R.id.favorite, View.GONE);
        UiUtilities.setVisibilitySafe(result, R.id.reply, View.GONE);
        UiUtilities.setVisibilitySafe(result, R.id.reply_all, View.GONE);
        UiUtilities.setVisibilitySafe(result, R.id.forward, View.GONE);
        UiUtilities.setVisibilitySafe(result, R.id.more, View.GONE);

        return result;
    }


    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        if (mFileEmailUri == null) { // sanity check.  setFileUri() must have been called.
            throw new IllegalStateException();
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();

        // If this is the last fragment of its kind, delete any/all attachment messages
        sFragmentCount--;
        if ((sFragmentCount == 0) && !getActivity().isChangingConfigurations()) {
            getController().deleteAttachmentMessages();
        }
    }

    /**
     * Called by the host activity to set the URL to the EML file to open.
     * Must be called before {@link #onActivityCreated(Bundle)}.
     *
     * Note: We don't use the fragment transaction for this fragment, so we can't use
     * {@link #getArguments()} to pass arguments.
     */
    public void setFileUri(Uri fileEmailUri) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" openMessage"");
        }
        if (mFileEmailUri != null) {
            throw new IllegalStateException();
        }
        if (fileEmailUri == null) {
            throw new IllegalArgumentException();
        }
        mFileEmailUri = fileEmailUri;
    }

    /**
     * NOTE See the comment on the super method.  It's called on a worker thread.
     */
    @Override
    protected Message openMessageSync(Activity activity) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" openMessageSync"");
        }
        // Put up a toast; this can take a little while...
        Utility.showToast(activity, R.string.message_view_parse_message_toast);
        Message msg = getController().loadMessageFromUri(mFileEmailUri);
        if (msg == null) {
            // Indicate that the EML couldn't be loaded
            Utility.showToast(activity, R.string.message_view_display_attachment_toast);
            return null;
        }
        return msg;
    }

    @Override
    protected Message reloadMessageSync(Activity activity) {
        // EML files will never change, so just return the same copy.
        return getMessage();
    }

    /**
     * {@inheritDoc}
     *
     * Does exactly same as the super class method, but does an extra sanity check.
     */
    @Override
    protected void reloadUiFromMessage(Message message, boolean okToFetch) {
        // EML file should never be partially loaded.
        if (message.mFlagLoaded != Message.FLAG_LOADED_COMPLETE) {
            throw new IllegalStateException();
        }
        super.reloadUiFromMessage(message, okToFetch);
    }
}
",False,270,1,2,10,51,2,6,L8
72,com.android.email.activity.FragmentInstallable.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.Fragment;

/**
 * Interface for {@link Activity} that can ""install"" fragments.
 */
public interface FragmentInstallable {
    /**
     * Called when a {@link Fragment} wants to be installed to the host activity.
     *
     * Fragments which use this MUST call this from {@link Fragment#onActivityCreated} using
     * {@link UiUtilities#installFragment}.
     *
     * This means a host {@link Activity} can safely assume a passed {@link Fragment} is already
     * created.
     */
    public void onInstallFragment(Fragment fragment);

    /**
     * Called when a {@link Fragment} wants to be uninstalled from the host activity.
     *
     * Fragments which use this MUST call this from {@link Fragment#onDestroyView} using
     * {@link UiUtilities#uninstallFragment}.
     */
    public void onUninstallFragment(Fragment fragment);
}
",False,152,8,38,0,0,2,0,L0
73,com.android.email.activity.MessageViewFragmentBase.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity;

import android.app.Activity;
import android.app.DownloadManager;
import android.app.Fragment;
import android.app.LoaderManager.LoaderCallbacks;
import android.content.ActivityNotFoundException;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.Context;
import android.content.Intent;
import android.content.Loader;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.media.MediaScannerConnection;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.provider.ContactsContract;
import android.provider.ContactsContract.QuickContact;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.format.DateUtils;
import android.util.Log;
import android.util.Patterns;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.android.email.AttachmentInfo;
import com.android.email.Controller;
import com.android.email.ControllerResultUiThreadWrapper;
import com.android.email.Email;
import com.android.email.Preferences;
import com.android.email.R;
import com.android.email.Throttle;
import com.android.email.mail.internet.EmailHtmlUtil;
import com.android.email.service.AttachmentDownloadService;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.Address;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.Body;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;
import com.google.common.collect.Maps;

import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Formatter;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// TODO Better handling of config changes.
// - Retain the content; don't kick 3 async tasks every time

/**
 * Base class for {@link MessageViewFragment} and {@link MessageFileViewFragment}.
 */
public abstract class MessageViewFragmentBase extends Fragment implements View.OnClickListener {
    private static final String BUNDLE_KEY_CURRENT_TAB = ""MessageViewFragmentBase.currentTab"";
    private static final String BUNDLE_KEY_PICTURE_LOADED = ""MessageViewFragmentBase.pictureLoaded"";
    private static final int PHOTO_LOADER_ID = 1;
    protected Context mContext;

    // Regex that matches start of img tag. '<(?i)img\s+'.
    private static final Pattern IMG_TAG_START_REGEX = Pattern.compile(""<(?i)img\\s+"");
    // Regex that matches Web URL protocol part as case insensitive.
    private static final Pattern WEB_URL_PROTOCOL = Pattern.compile(""(?i)http|https://"");

    private static int PREVIEW_ICON_WIDTH = 62;
    private static int PREVIEW_ICON_HEIGHT = 62;

    // The different levels of zoom: read from the Preferences.
    private static String[] sZoomSizes = null;

    private TextView mSubjectView;
    private TextView mFromNameView;
    private TextView mFromAddressView;
    private TextView mDateTimeView;
    private TextView mAddressesView;
    private WebView mMessageContentView;
    private LinearLayout mAttachments;
    private View mTabSection;
    private ImageView mFromBadge;
    private ImageView mSenderPresenceView;
    private View mMainView;
    private View mLoadingProgress;
    private View mDetailsCollapsed;
    private View mDetailsExpanded;
    private boolean mDetailsFilled;

    private TextView mMessageTab;
    private TextView mAttachmentTab;
    private TextView mInviteTab;
    // It is not really a tab, but looks like one of them.
    private TextView mShowPicturesTab;
    private View mAlwaysShowPicturesButton;

    private View mAttachmentsScroll;
    private View mInviteScroll;

    private long mAccountId = Account.NO_ACCOUNT;
    private long mMessageId = Message.NO_MESSAGE;
    private Message mMessage;

    private Controller mController;
    private ControllerResultUiThreadWrapper<ControllerResults> mControllerCallback;

    // contains the HTML body. Is used by LoadAttachmentTask to display inline images.
    // is null most of the time, is used transiently to pass info to LoadAttachementTask
    private String mHtmlTextRaw;

    // contains the HTML content as set in WebView.
    private String mHtmlTextWebView;

    private boolean mIsMessageLoadedForTest;

    private MessageObserver mMessageObserver;

    private static final int CONTACT_STATUS_STATE_UNLOADED = 0;
    private static final int CONTACT_STATUS_STATE_UNLOADED_TRIGGERED = 1;
    private static final int CONTACT_STATUS_STATE_LOADED = 2;

    private int mContactStatusState;
    private Uri mQuickContactLookupUri;

    /** Flag for {@link #mTabFlags}: Message has attachment(s) */
    protected static final int TAB_FLAGS_HAS_ATTACHMENT = 1;

    /**
     * Flag for {@link #mTabFlags}: Message contains invite.  This flag is only set by
     * {@link MessageViewFragment}.
     */
    protected static final int TAB_FLAGS_HAS_INVITE = 2;

    /** Flag for {@link #mTabFlags}: Message contains pictures */
    protected static final int TAB_FLAGS_HAS_PICTURES = 4;

    /** Flag for {@link #mTabFlags}: ""Show pictures"" has already been pressed */
    protected static final int TAB_FLAGS_PICTURE_LOADED = 8;

    /**
     * Flags to control the tabs.
     * @see #updateTabs(int)
     */
    private int mTabFlags;

    /** # of attachments in the current message */
    private int mAttachmentCount;

    // Use (random) large values, to avoid confusion with TAB_FLAGS_*
    protected static final int TAB_MESSAGE = 101;
    protected static final int TAB_INVITE = 102;
    protected static final int TAB_ATTACHMENT = 103;
    private static final int TAB_NONE = 0;

    /** Current tab */
    private int mCurrentTab = TAB_NONE;
    /**
     * Tab that was selected in the previous activity instance.
     * Used to restore the current tab after screen rotation.
     */
    private int mRestoredTab = TAB_NONE;

    private boolean mRestoredPictureLoaded;

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    public interface Callback {
        /**
         * Called when a link in a message is clicked.
         *
         * @param url link url that's clicked.
         * @return true if handled, false otherwise.
         */
        public boolean onUrlInMessageClicked(String url);

        /**
         * Called when the message specified doesn't exist, or is deleted/moved.
         */
        public void onMessageNotExists();

        /** Called when it starts loading a message. */
        public void onLoadMessageStarted();

        /** Called when it successfully finishes loading a message. */
        public void onLoadMessageFinished();

        /** Called when an error occurred during loading a message. */
        public void onLoadMessageError(String errorMessage);
    }

    public static class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();
        @Override public void onLoadMessageError(String errorMessage) {}
        @Override public void onLoadMessageFinished() {}
        @Override public void onLoadMessageStarted() {}
        @Override public void onMessageNotExists() {}
        @Override
        public boolean onUrlInMessageClicked(String url) {
            return false;
        }
    }

    private Callback mCallback = EmptyCallback.INSTANCE;

    @Override
    public void onAttach(Activity activity) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onAttach"");
        }
        super.onAttach(activity);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onCreate"");
        }
        super.onCreate(savedInstanceState);

        mContext = getActivity().getApplicationContext();

        // Initialize components, but don't ""start"" them.  Registering the controller callbacks
        // and starting MessageObserver, should be done in onActivityCreated or later and be stopped
        // in onDestroyView to prevent from getting callbacks when the fragment is in the back
        // stack, but they'll start again when it's back from the back stack.
        mController = Controller.getInstance(mContext);
        mControllerCallback = new ControllerResultUiThreadWrapper<ControllerResults>(
                new Handler(), new ControllerResults());
        mMessageObserver = new MessageObserver(new Handler(), mContext);

        if (savedInstanceState != null) {
            restoreInstanceState(savedInstanceState);
        }
    }

    @Override
    public View onCreateView(
            LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onCreateView"");
        }
        final View view = inflater.inflate(R.layout.message_view_fragment, container, false);

        cleanupDetachedViews();

        mSubjectView = (TextView) UiUtilities.getView(view, R.id.subject);
        mFromNameView = (TextView) UiUtilities.getView(view, R.id.from_name);
        mFromAddressView = (TextView) UiUtilities.getView(view, R.id.from_address);
        mAddressesView = (TextView) UiUtilities.getView(view, R.id.addresses);
        mDateTimeView = (TextView) UiUtilities.getView(view, R.id.datetime);
        mMessageContentView = (WebView) UiUtilities.getView(view, R.id.message_content);
        mAttachments = (LinearLayout) UiUtilities.getView(view, R.id.attachments);
        mTabSection = UiUtilities.getView(view, R.id.message_tabs_section);
        mFromBadge = (ImageView) UiUtilities.getView(view, R.id.badge);
        mSenderPresenceView = (ImageView) UiUtilities.getView(view, R.id.presence);
        mMainView = UiUtilities.getView(view, R.id.main_panel);
        mLoadingProgress = UiUtilities.getView(view, R.id.loading_progress);
        mDetailsCollapsed = UiUtilities.getView(view, R.id.sub_header_contents_collapsed);
        mDetailsExpanded = UiUtilities.getView(view, R.id.sub_header_contents_expanded);

        mFromNameView.setOnClickListener(this);
        mFromAddressView.setOnClickListener(this);
        mFromBadge.setOnClickListener(this);
        mSenderPresenceView.setOnClickListener(this);

        mMessageTab = UiUtilities.getView(view, R.id.show_message);
        mAttachmentTab = UiUtilities.getView(view, R.id.show_attachments);
        mShowPicturesTab = UiUtilities.getView(view, R.id.show_pictures);
        mAlwaysShowPicturesButton = UiUtilities.getView(view, R.id.always_show_pictures_button);
        // Invite is only used in MessageViewFragment, but visibility is controlled here.
        mInviteTab = UiUtilities.getView(view, R.id.show_invite);

        mMessageTab.setOnClickListener(this);
        mAttachmentTab.setOnClickListener(this);
        mShowPicturesTab.setOnClickListener(this);
        mAlwaysShowPicturesButton.setOnClickListener(this);
        mInviteTab.setOnClickListener(this);
        mDetailsCollapsed.setOnClickListener(this);
        mDetailsExpanded.setOnClickListener(this);

        mAttachmentsScroll = UiUtilities.getView(view, R.id.attachments_scroll);
        mInviteScroll = UiUtilities.getView(view, R.id.invite_scroll);

        WebSettings webSettings = mMessageContentView.getSettings();
        boolean supportMultiTouch = mContext.getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH);
        webSettings.setDisplayZoomControls(!supportMultiTouch);
        webSettings.setSupportZoom(true);
        webSettings.setBuiltInZoomControls(true);
        mMessageContentView.setWebViewClient(new CustomWebViewClient());
        return view;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onActivityCreated"");
        }
        super.onActivityCreated(savedInstanceState);
        mController.addResultCallback(mControllerCallback);

        resetView();
        new LoadMessageTask(true).executeParallel();

        UiUtilities.installFragment(this);
    }

    @Override
    public void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onStart"");
        }
        super.onStart();
    }

    @Override
    public void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onResume"");
        }
        super.onResume();

        // We might have comes back from other full-screen activities.  If so, we need to update
        // the attachment tab as system settings may have been updated that affect which
        // options are available to the user.
        updateAttachmentTab();
    }

    @Override
    public void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onPause"");
        }
        super.onPause();
    }

    @Override
    public void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onStop"");
        }
        super.onStop();
    }

    @Override
    public void onDestroyView() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDestroyView"");
        }
        UiUtilities.uninstallFragment(this);
        mController.removeResultCallback(mControllerCallback);
        cancelAllTasks();

        // We should clean up the Webview here, but it can't release resources until it is
        // actually removed from the view tree.

        super.onDestroyView();
    }

    private void cleanupDetachedViews() {
        // WebView cleanup must be done after it leaves the rendering tree, according to
        // its contract
        if (mMessageContentView != null) {
            mMessageContentView.destroy();
            mMessageContentView = null;
        }
    }

    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDestroy"");
        }

        cleanupDetachedViews();
        super.onDestroy();
    }

    @Override
    public void onDetach() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onDetach"");
        }
        super.onDetach();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);
        outState.putInt(BUNDLE_KEY_CURRENT_TAB, mCurrentTab);
        outState.putBoolean(BUNDLE_KEY_PICTURE_LOADED, (mTabFlags & TAB_FLAGS_PICTURE_LOADED) != 0);
    }

    private void restoreInstanceState(Bundle state) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, this + "" restoreInstanceState"");
        }
        // At this point (in onCreate) no tabs are visible (because we don't know if the message has
        // an attachment or invite before loading it).  We just remember the tab here.
        // We'll make it current when the tab first becomes visible in updateTabs().
        mRestoredTab = state.getInt(BUNDLE_KEY_CURRENT_TAB);
        mRestoredPictureLoaded = state.getBoolean(BUNDLE_KEY_PICTURE_LOADED);
    }

    public void setCallback(Callback callback) {
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
    }

    private void cancelAllTasks() {
        mMessageObserver.unregister();
        mTaskTracker.cancellAllInterrupt();
    }

    protected final Controller getController() {
        return mController;
    }

    protected final Callback getCallback() {
        return mCallback;
    }

    public final Message getMessage() {
        return mMessage;
    }

    protected final boolean isMessageOpen() {
        return mMessage != null;
    }

    /**
     * Returns the account id of the current message, or -1 if unknown (message not open yet, or
     * viewing an EML message).
     */
    public long getAccountId() {
        return mAccountId;
    }

    /**
     * Show/hide the content.  We hide all the content (except for the bottom buttons) when loading,
     * to avoid flicker.
     */
    private void showContent(boolean showContent, boolean showProgressWhenHidden) {
        makeVisible(mMainView, showContent);
        makeVisible(mLoadingProgress, !showContent && showProgressWhenHidden);
    }

    // TODO: clean this up - most of this is not needed since the WebView and Fragment is not
    // reused for multiple messages.
    protected void resetView() {
        showContent(false, false);
        updateTabs(0);
        setCurrentTab(TAB_MESSAGE);
        if (mMessageContentView != null) {
            blockNetworkLoads(true);
            mMessageContentView.scrollTo(0, 0);

            // Dynamic configuration of WebView
            final WebSettings settings = mMessageContentView.getSettings();
            settings.setLayoutAlgorithm(WebSettings.LayoutAlgorithm.NORMAL);
            mMessageContentView.setInitialScale(getWebViewZoom());
        }
        mAttachmentsScroll.scrollTo(0, 0);
        mInviteScroll.scrollTo(0, 0);
        mAttachments.removeAllViews();
        mAttachments.setVisibility(View.GONE);
        initContactStatusViews();
    }

    /**
     * Returns the zoom scale (in percent) which is a combination of the user setting
     * (tiny, small, normal, large, huge) and the device density. The intention
     * is for the text to be physically equal in size over different density
     * screens.
     */
    private int getWebViewZoom() {
        float density = mContext.getResources().getDisplayMetrics().density;
        int zoom = Preferences.getPreferences(mContext).getTextZoom();
        if (sZoomSizes == null) {
            sZoomSizes = mContext.getResources()
                    .getStringArray(R.array.general_preference_text_zoom_size);
        }
        return (int)(Float.valueOf(sZoomSizes[zoom]) * density * 100);
    }

    private void initContactStatusViews() {
        mContactStatusState = CONTACT_STATUS_STATE_UNLOADED;
        mQuickContactLookupUri = null;
        showDefaultQuickContactBadgeImage();
    }

    private void showDefaultQuickContactBadgeImage() {
        mFromBadge.setImageResource(R.drawable.ic_contact_picture);
    }

    protected final void addTabFlags(int tabFlags) {
        updateTabs(mTabFlags | tabFlags);
    }

    private final void clearTabFlags(int tabFlags) {
        updateTabs(mTabFlags & ~tabFlags);
    }

    private void setAttachmentCount(int count) {
        mAttachmentCount = count;
        if (mAttachmentCount > 0) {
            addTabFlags(TAB_FLAGS_HAS_ATTACHMENT);
        } else {
            clearTabFlags(TAB_FLAGS_HAS_ATTACHMENT);
        }
    }

    private static void makeVisible(View v, boolean visible) {
        final int visibility = visible ? View.VISIBLE : View.GONE;
        if ((v != null) && (v.getVisibility() != visibility)) {
            v.setVisibility(visibility);
        }
    }

    private static boolean isVisible(View v) {
        return (v != null) && (v.getVisibility() == View.VISIBLE);
    }

    /**
     * Update the visual of the tabs.  (visibility, text, etc)
     */
    private void updateTabs(int tabFlags) {
        mTabFlags = tabFlags;

        if (getView() == null) {
            return;
        }

        boolean messageTabVisible = (tabFlags & (TAB_FLAGS_HAS_INVITE | TAB_FLAGS_HAS_ATTACHMENT))
                != 0;
        makeVisible(mMessageTab, messageTabVisible);
        makeVisible(mInviteTab, (tabFlags & TAB_FLAGS_HAS_INVITE) != 0);
        makeVisible(mAttachmentTab, (tabFlags & TAB_FLAGS_HAS_ATTACHMENT) != 0);

        final boolean hasPictures = (tabFlags & TAB_FLAGS_HAS_PICTURES) != 0;
        final boolean pictureLoaded = (tabFlags & TAB_FLAGS_PICTURE_LOADED) != 0;
        makeVisible(mShowPicturesTab, hasPictures && !pictureLoaded);

        mAttachmentTab.setText(mContext.getResources().getQuantityString(
                R.plurals.message_view_show_attachments_action,
                mAttachmentCount, mAttachmentCount));

        // Hide the entire section if no tabs are visible.
        makeVisible(mTabSection, isVisible(mMessageTab) || isVisible(mInviteTab)
                || isVisible(mAttachmentTab) || isVisible(mShowPicturesTab)
                || isVisible(mAlwaysShowPicturesButton));

        // Restore previously selected tab after rotation
        if (mRestoredTab != TAB_NONE && isVisible(getTabViewForFlag(mRestoredTab))) {
            setCurrentTab(mRestoredTab);
            mRestoredTab = TAB_NONE;
        }
    }

    /**
     * Set the current tab.
     *
     * @param tab any of {@link #TAB_MESSAGE}, {@link #TAB_ATTACHMENT} or {@link #TAB_INVITE}.
     */
    private void setCurrentTab(int tab) {
        mCurrentTab = tab;

        // Hide & unselect all tabs
        makeVisible(getTabContentViewForFlag(TAB_MESSAGE), false);
        makeVisible(getTabContentViewForFlag(TAB_ATTACHMENT), false);
        makeVisible(getTabContentViewForFlag(TAB_INVITE), false);
        getTabViewForFlag(TAB_MESSAGE).setSelected(false);
        getTabViewForFlag(TAB_ATTACHMENT).setSelected(false);
        getTabViewForFlag(TAB_INVITE).setSelected(false);

        makeVisible(getTabContentViewForFlag(mCurrentTab), true);
        getTabViewForFlag(mCurrentTab).setSelected(true);
    }

    private View getTabViewForFlag(int tabFlag) {
        switch (tabFlag) {
            case TAB_MESSAGE:
                return mMessageTab;
            case TAB_ATTACHMENT:
                return mAttachmentTab;
            case TAB_INVITE:
                return mInviteTab;
        }
        throw new IllegalArgumentException();
    }

    private View getTabContentViewForFlag(int tabFlag) {
        switch (tabFlag) {
            case TAB_MESSAGE:
                return mMessageContentView;
            case TAB_ATTACHMENT:
                return mAttachmentsScroll;
            case TAB_INVITE:
                return mInviteScroll;
        }
        throw new IllegalArgumentException();
    }

    private void blockNetworkLoads(boolean block) {
        if (mMessageContentView != null) {
            mMessageContentView.getSettings().setBlockNetworkLoads(block);
        }
    }

    private void setMessageHtml(String html) {
        if (html == null) {
            html = """";
        }
        if (mMessageContentView != null) {
            mMessageContentView.loadDataWithBaseURL(""email://"", html, ""text/html"", ""utf-8"", null);
        }
    }

    /**
     * Handle clicks on sender, which shows {@link QuickContact} or prompts to add
     * the sender as a contact.
     */
    private void onClickSender() {
        if (!isMessageOpen()) return;
        final Address senderEmail = Address.unpackFirst(mMessage.mFrom);
        if (senderEmail == null) return;

        if (mContactStatusState == CONTACT_STATUS_STATE_UNLOADED) {
            // Status not loaded yet.
            mContactStatusState = CONTACT_STATUS_STATE_UNLOADED_TRIGGERED;
            return;
        }
        if (mContactStatusState == CONTACT_STATUS_STATE_UNLOADED_TRIGGERED) {
            return; // Already clicked, and waiting for the data.
        }

        if (mQuickContactLookupUri != null) {
            QuickContact.showQuickContact(mContext, mFromBadge, mQuickContactLookupUri,
                        QuickContact.MODE_MEDIUM, null);
        } else {
            // No matching contact, ask user to create one
            final Uri mailUri = Uri.fromParts(""mailto"", senderEmail.getAddress(), null);
            final Intent intent = new Intent(ContactsContract.Intents.SHOW_OR_CREATE_CONTACT,
                    mailUri);

            // Only provide personal name hint if we have one
            final String senderPersonal = senderEmail.getPersonal();
            if (!TextUtils.isEmpty(senderPersonal)) {
                intent.putExtra(ContactsContract.Intents.Insert.NAME, senderPersonal);
            }
            intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);

            startActivity(intent);
        }
    }

    private static class ContactStatusLoaderCallbacks
            implements LoaderCallbacks<ContactStatusLoader.Result> {
        private static final String BUNDLE_EMAIL_ADDRESS = ""email"";
        private final MessageViewFragmentBase mFragment;

        public ContactStatusLoaderCallbacks(MessageViewFragmentBase fragment) {
            mFragment = fragment;
        }

        public static Bundle createArguments(String emailAddress) {
            Bundle b = new Bundle();
            b.putString(BUNDLE_EMAIL_ADDRESS, emailAddress);
            return b;
        }

        @Override
        public Loader<ContactStatusLoader.Result> onCreateLoader(int id, Bundle args) {
            return new ContactStatusLoader(mFragment.mContext,
                    args.getString(BUNDLE_EMAIL_ADDRESS));
        }

        @Override
        public void onLoadFinished(Loader<ContactStatusLoader.Result> loader,
                ContactStatusLoader.Result result) {
            boolean triggered =
                    (mFragment.mContactStatusState == CONTACT_STATUS_STATE_UNLOADED_TRIGGERED);
            mFragment.mContactStatusState = CONTACT_STATUS_STATE_LOADED;
            mFragment.mQuickContactLookupUri = result.mLookupUri;

            if (result.isUnknown()) {
                mFragment.mSenderPresenceView.setVisibility(View.GONE);
            } else {
                mFragment.mSenderPresenceView.setVisibility(View.VISIBLE);
                mFragment.mSenderPresenceView.setImageResource(result.mPresenceResId);
            }
            if (result.mPhoto != null) { // photo will be null if unknown.
                mFragment.mFromBadge.setImageBitmap(result.mPhoto);
            }
            if (triggered) {
                mFragment.onClickSender();
            }
        }

        @Override
        public void onLoaderReset(Loader<ContactStatusLoader.Result> loader) {
        }
    }

    private void onSaveAttachment(MessageViewAttachmentInfo info) {
        if (!Utility.isExternalStorageMounted()) {
            /*
             * Abort early if there's no place to save the attachment. We don't want to spend
             * the time downloading it and then abort.
             */
            Utility.showToast(getActivity(), R.string.message_view_status_attachment_not_saved);
            return;
        }

        if (info.isFileSaved()) {
            // Nothing to do - we have the file saved.
            return;
        }

        File savedFile = performAttachmentSave(info);
        if (savedFile != null) {
            Utility.showToast(getActivity(), String.format(
                    mContext.getString(R.string.message_view_status_attachment_saved),
                    savedFile.getName()));
        } else {
            Utility.showToast(getActivity(), R.string.message_view_status_attachment_not_saved);
        }
    }

    private File performAttachmentSave(MessageViewAttachmentInfo info) {
        Attachment attachment = Attachment.restoreAttachmentWithId(mContext, info.mId);
        Uri attachmentUri = AttachmentUtilities.getAttachmentUri(mAccountId, attachment.mId);

        try {
            File downloads = Environment.getExternalStoragePublicDirectory(
                    Environment.DIRECTORY_DOWNLOADS);
            downloads.mkdirs();
            File file = Utility.createUniqueFile(downloads, attachment.mFileName);
            Uri contentUri = AttachmentUtilities.resolveAttachmentIdToContentUri(
                    mContext.getContentResolver(), attachmentUri);
            InputStream in = mContext.getContentResolver().openInputStream(contentUri);
            OutputStream out = new FileOutputStream(file);
            IOUtils.copy(in, out);
            out.flush();
            out.close();
            in.close();

            String absolutePath = file.getAbsolutePath();

            // Although the download manager can scan media files, scanning only happens after the
            // user clicks on the item in the Downloads app. So, we run the attachment through
            // the media scanner ourselves so it gets added to gallery / music immediately.
            MediaScannerConnection.scanFile(mContext, new String[] {absolutePath},
                    null, null);

            DownloadManager dm =
                    (DownloadManager) getActivity().getSystemService(Context.DOWNLOAD_SERVICE);
            dm.addCompletedDownload(info.mName, info.mName,
                    false /* do not use media scanner */,
                    info.mContentType, absolutePath, info.mSize,
                    true /* show notification */);

            // Cache the stored file information.
            info.setSavedPath(absolutePath);

            // Update our buttons.
            updateAttachmentButtons(info);

            return file;

        } catch (IOException ioe) {
            // Ignore. Callers will handle it from the return code.
        }

        return null;
    }

    private void onOpenAttachment(MessageViewAttachmentInfo info) {
        if (info.mAllowInstall) {
            // The package installer is unable to install files from a content URI; it must be
            // given a file path. Therefore, we need to save it first in order to proceed
            if (!info.mAllowSave || !Utility.isExternalStorageMounted()) {
                Utility.showToast(getActivity(), R.string.message_view_status_attachment_not_saved);
                return;
            }

            if (!info.isFileSaved()) {
                if (performAttachmentSave(info) == null) {
                    // Saving failed for some reason - bail.
                    Utility.showToast(
                            getActivity(), R.string.message_view_status_attachment_not_saved);
                    return;
                }
            }
        }
        try {
            Intent intent = info.getAttachmentIntent(mContext, mAccountId);
            startActivity(intent);
        } catch (ActivityNotFoundException e) {
            Utility.showToast(getActivity(), R.string.message_view_display_attachment_toast);
        }
    }

    private void onInfoAttachment(final MessageViewAttachmentInfo attachment) {
        AttachmentInfoDialog dialog =
            AttachmentInfoDialog.newInstance(getActivity(), attachment.mDenyFlags);
        dialog.show(getActivity().getFragmentManager(), null);
    }

    private void onLoadAttachment(final MessageViewAttachmentInfo attachment) {
        attachment.loadButton.setVisibility(View.GONE);
        // If there's nothing in the download queue, we'll probably start right away so wait a
        // second before showing the cancel button
        if (AttachmentDownloadService.getQueueSize() == 0) {
            // Set to invisible; if the button is still in this state one second from now, we'll
            // assume the download won't start right away, and we make the cancel button visible
            attachment.cancelButton.setVisibility(View.GONE);
            // Create the timed task that will change the button state
            new EmailAsyncTask<Void, Void, Void>(mTaskTracker) {
                @Override
                protected Void doInBackground(Void... params) {
                    try {
                        Thread.sleep(1000L);
                    } catch (InterruptedException e) { }
                    return null;
                }
                @Override
                protected void onSuccess(Void result) {
                    // If the timeout completes and the attachment has not loaded, show cancel
                    if (!attachment.loaded) {
                        attachment.cancelButton.setVisibility(View.VISIBLE);
                    }
                }
            }.executeParallel();
        } else {
            attachment.cancelButton.setVisibility(View.VISIBLE);
        }
        attachment.showProgressIndeterminate();
        mController.loadAttachment(attachment.mId, mMessageId, mAccountId);
    }

    private void onCancelAttachment(MessageViewAttachmentInfo attachment) {
        // Don't change button states if we couldn't cancel the download
        if (AttachmentDownloadService.cancelQueuedAttachment(attachment.mId)) {
            attachment.loadButton.setVisibility(View.VISIBLE);
            attachment.cancelButton.setVisibility(View.GONE);
            attachment.hideProgress();
        }
    }

    /**
     * Called by ControllerResults. Show the ""View"" and ""Save"" buttons; hide ""Load"" and ""Stop""
     *
     * @param attachmentId the attachment that was just downloaded
     */
    private void doFinishLoadAttachment(long attachmentId) {
        MessageViewAttachmentInfo info = findAttachmentInfo(attachmentId);
        if (info != null) {
            info.loaded = true;
            updateAttachmentButtons(info);
        }
    }

    private void showPicturesInHtml() {
        boolean picturesAlreadyLoaded = (mTabFlags & TAB_FLAGS_PICTURE_LOADED) != 0;
        if ((mMessageContentView != null) && !picturesAlreadyLoaded) {
            blockNetworkLoads(false);
            // TODO: why is this calling setMessageHtml just because the images can load now?
            setMessageHtml(mHtmlTextWebView);

            // Prompt the user to always show images from this sender.
            makeVisible(UiUtilities.getView(getView(), R.id.always_show_pictures_button), true);

            addTabFlags(TAB_FLAGS_PICTURE_LOADED);
        }
    }

    private void showDetails() {
        if (!isMessageOpen()) {
            return;
        }

        if (!mDetailsFilled) {
            String date = formatDate(mMessage.mTimeStamp, true);
            final String SEPARATOR = ""\n"";
            String to = Address.toString(Address.unpack(mMessage.mTo), SEPARATOR);
            String cc = Address.toString(Address.unpack(mMessage.mCc), SEPARATOR);
            String bcc = Address.toString(Address.unpack(mMessage.mBcc), SEPARATOR);
            setDetailsRow(mDetailsExpanded, date, R.id.date, R.id.date_row);
            setDetailsRow(mDetailsExpanded, to, R.id.to, R.id.to_row);
            setDetailsRow(mDetailsExpanded, cc, R.id.cc, R.id.cc_row);
            setDetailsRow(mDetailsExpanded, bcc, R.id.bcc, R.id.bcc_row);
            mDetailsFilled = true;
        }

        mDetailsCollapsed.setVisibility(View.GONE);
        mDetailsExpanded.setVisibility(View.VISIBLE);
    }

    private void hideDetails() {
        mDetailsCollapsed.setVisibility(View.VISIBLE);
        mDetailsExpanded.setVisibility(View.GONE);
    }

    private static void setDetailsRow(View root, String text, int textViewId, int rowViewId) {
        if (TextUtils.isEmpty(text)) {
            root.findViewById(rowViewId).setVisibility(View.GONE);
            return;
        }
        ((TextView) UiUtilities.getView(root, textViewId)).setText(text);
    }


    @Override
    public void onClick(View view) {
        if (!isMessageOpen()) {
            return; // Ignore.
        }
        switch (view.getId()) {
            case R.id.badge:
                onClickSender();
                break;
            case R.id.load:
                onLoadAttachment((MessageViewAttachmentInfo) view.getTag());
                break;
            case R.id.info:
                onInfoAttachment((MessageViewAttachmentInfo) view.getTag());
                break;
            case R.id.save:
                onSaveAttachment((MessageViewAttachmentInfo) view.getTag());
                break;
            case R.id.open:
                onOpenAttachment((MessageViewAttachmentInfo) view.getTag());
                break;
            case R.id.cancel:
                onCancelAttachment((MessageViewAttachmentInfo) view.getTag());
                break;
            case R.id.show_message:
                setCurrentTab(TAB_MESSAGE);
                break;
            case R.id.show_invite:
                setCurrentTab(TAB_INVITE);
                break;
            case R.id.show_attachments:
                setCurrentTab(TAB_ATTACHMENT);
                break;
            case R.id.show_pictures:
                showPicturesInHtml();
                break;
            case R.id.always_show_pictures_button:
                setShowImagesForSender();
                break;
            case R.id.sub_header_contents_collapsed:
                showDetails();
                break;
            case R.id.sub_header_contents_expanded:
                hideDetails();
                break;
        }
    }

    /**
     * Start loading contact photo and presence.
     */
    private void queryContactStatus() {
        if (!isMessageOpen()) return;
        initContactStatusViews(); // Initialize the state, just in case.

        // Find the sender email address, and start presence check.
        Address sender = Address.unpackFirst(mMessage.mFrom);
        if (sender != null) {
            String email = sender.getAddress();
            if (email != null) {
                getLoaderManager().restartLoader(PHOTO_LOADER_ID,
                        ContactStatusLoaderCallbacks.createArguments(email),
                        new ContactStatusLoaderCallbacks(this));
            }
        }
    }

    /**
     * Called by {@link LoadMessageTask} and {@link ReloadMessageTask} to load a message in a
     * subclass specific way.
     *
     * NOTE This method is called on a worker thread!  Implementations must properly synchronize
     * when accessing members.
     *
     * @param activity the parent activity.  Subclass use it as a context, and to show a toast.
     */
    protected abstract Message openMessageSync(Activity activity);

    /**
     * Called in a background thread to reload a new copy of the Message in case something has
     * changed.
     */
    protected Message reloadMessageSync(Activity activity) {
        return openMessageSync(activity);
    }

    /**
     * Async task for loading a single message outside of the UI thread
     */
    private class LoadMessageTask extends EmailAsyncTask<Void, Void, Message> {

        private final boolean mOkToFetch;
        private Mailbox mMailbox;

        /**
         * Special constructor to cache some local info
         */
        public LoadMessageTask(boolean okToFetch) {
            super(mTaskTracker);
            mOkToFetch = okToFetch;
        }

        @Override
        protected Message doInBackground(Void... params) {
            Activity activity = getActivity();
            Message message = null;
            if (activity != null) {
                message = openMessageSync(activity);
            }
            if (message != null) {
                mMailbox = Mailbox.restoreMailboxWithId(mContext, message.mMailboxKey);
                if (mMailbox == null) {
                    message = null; // mailbox removed??
                }
            }
            return message;
        }

        @Override
        protected void onSuccess(Message message) {
            if (message == null) {
                resetView();
                mCallback.onMessageNotExists();
                return;
            }
            mMessageId = message.mId;

            reloadUiFromMessage(message, mOkToFetch);
            queryContactStatus();
            onMessageShown(mMessageId, mMailbox);
            RecentMailboxManager.getInstance(mContext).touch(mAccountId, message.mMailboxKey);
        }
    }

    /**
     * Kicked by {@link MessageObserver}.  Reload the message and update the views.
     */
    private class ReloadMessageTask extends EmailAsyncTask<Void, Void, Message> {
        public ReloadMessageTask() {
            super(mTaskTracker);
        }

        @Override
        protected Message doInBackground(Void... params) {
            Activity activity = getActivity();
            if (activity == null) {
                return null;
            } else {
                return reloadMessageSync(activity);
            }
        }

        @Override
        protected void onSuccess(Message message) {
            if (message == null || message.mMailboxKey != mMessage.mMailboxKey) {
                // Message deleted or moved.
                mCallback.onMessageNotExists();
                return;
            }
            mMessage = message;
            updateHeaderView(mMessage);
        }
    }

    /**
     * Called when a message is shown to the user.
     */
    protected void onMessageShown(long messageId, Mailbox mailbox) {
    }

    /**
     * Called when the message body is loaded.
     */
    protected void onPostLoadBody() {
    }

    /**
     * Async task for loading a single message body outside of the UI thread
     */
    private class LoadBodyTask extends EmailAsyncTask<Void, Void, String[]> {

        private final long mId;
        private boolean mErrorLoadingMessageBody;
        private final boolean mAutoShowPictures;

        /**
         * Special constructor to cache some local info
         */
        public LoadBodyTask(long messageId, boolean autoShowPictures) {
            super(mTaskTracker);
            mId = messageId;
            mAutoShowPictures = autoShowPictures;
        }

        @Override
        protected String[] doInBackground(Void... params) {
            try {
                String text = null;
                String html = Body.restoreBodyHtmlWithMessageId(mContext, mId);
                if (html == null) {
                    text = Body.restoreBodyTextWithMessageId(mContext, mId);
                }
                return new String[] { text, html };
            } catch (RuntimeException re) {
                // This catches SQLiteException as well as other RTE's we've seen from the
                // database calls, such as IllegalStateException
                Log.d(Logging.LOG_TAG, ""Exception while loading message body"", re);
                mErrorLoadingMessageBody = true;
                return null;
            }
        }

        @Override
        protected void onSuccess(String[] results) {
            if (results == null) {
                if (mErrorLoadingMessageBody) {
                    Utility.showToast(getActivity(), R.string.error_loading_message_body);
                }
                resetView();
                return;
            }
            reloadUiFromBody(results[0], results[1], mAutoShowPictures);    // text, html
            onPostLoadBody();
        }
    }

    /**
     * Async task for loading attachments
     *
     * Note:  This really should only be called when the message load is complete - or, we should
     * leave open a listener so the attachments can fill in as they are discovered.  In either case,
     * this implementation is incomplete, as it will fail to refresh properly if the message is
     * partially loaded at this time.
     */
    private class LoadAttachmentsTask extends EmailAsyncTask<Long, Void, Attachment[]> {
        public LoadAttachmentsTask() {
            super(mTaskTracker);
        }

        @Override
        protected Attachment[] doInBackground(Long... messageIds) {
            return Attachment.restoreAttachmentsWithMessageId(mContext, messageIds[0]);
        }

        @Override
        protected void onSuccess(Attachment[] attachments) {
            try {
                if (attachments == null) {
                    return;
                }
                boolean htmlChanged = false;
                int numDisplayedAttachments = 0;
                for (Attachment attachment : attachments) {
                    if (mHtmlTextRaw != null && attachment.mContentId != null
                            && attachment.mContentUri != null) {
                        // for html body, replace CID for inline images
                        // Regexp which matches ' src=""cid:contentId""'.
                        String contentIdRe =
                            ""\\s+(?i)src=\""cid(?-i):\\Q"" + attachment.mContentId + ""\\E\"""";
                        String srcContentUri = "" src=\"""" + attachment.mContentUri + ""\"""";
                        mHtmlTextRaw = mHtmlTextRaw.replaceAll(contentIdRe, srcContentUri);
                        htmlChanged = true;
                    } else {
                        addAttachment(attachment);
                        numDisplayedAttachments++;
                    }
                }
                setAttachmentCount(numDisplayedAttachments);
                mHtmlTextWebView = mHtmlTextRaw;
                mHtmlTextRaw = null;
                if (htmlChanged) {
                    setMessageHtml(mHtmlTextWebView);
                }
            } finally {
                showContent(true, false);
            }
        }
    }

    private static Bitmap getPreviewIcon(Context context, AttachmentInfo attachment) {
        try {
            return BitmapFactory.decodeStream(
                    context.getContentResolver().openInputStream(
                            AttachmentUtilities.getAttachmentThumbnailUri(
                                    attachment.mAccountKey, attachment.mId,
                                    PREVIEW_ICON_WIDTH,
                                    PREVIEW_ICON_HEIGHT)));
        } catch (Exception e) {
            Log.d(Logging.LOG_TAG, ""Attachment preview failed with exception "" + e.getMessage());
            return null;
        }
    }

    /**
     * Subclass of AttachmentInfo which includes our views and buttons related to attachment
     * handling, as well as our determination of suitability for viewing (based on availability of
     * a viewer app) and saving (based upon the presence of external storage)
     */
    private static class MessageViewAttachmentInfo extends AttachmentInfo {
        private Button openButton;
        private Button saveButton;
        private Button loadButton;
        private Button infoButton;
        private Button cancelButton;
        private ImageView iconView;

        private static final Map<AttachmentInfo, String> sSavedFileInfos = Maps.newHashMap();

        // Don't touch it directly from the outer class.
        private final ProgressBar mProgressView;
        private boolean loaded;

        private MessageViewAttachmentInfo(Context context, Attachment attachment,
                ProgressBar progressView) {
            super(context, attachment);
            mProgressView = progressView;
        }

        /**
         * Create a new attachment info based upon an existing attachment info. Display
         * related fields (such as views and buttons) are copied from old to new.
         */
        private MessageViewAttachmentInfo(Context context, MessageViewAttachmentInfo oldInfo) {
            super(context, oldInfo);
            openButton = oldInfo.openButton;
            saveButton = oldInfo.saveButton;
            loadButton = oldInfo.loadButton;
            infoButton = oldInfo.infoButton;
            cancelButton = oldInfo.cancelButton;
            iconView = oldInfo.iconView;
            mProgressView = oldInfo.mProgressView;
            loaded = oldInfo.loaded;
        }

        public void hideProgress() {
            // Don't use GONE, which'll break the layout.
            if (mProgressView.getVisibility() != View.INVISIBLE) {
                mProgressView.setVisibility(View.INVISIBLE);
            }
        }

        public void showProgress(int progress) {
            if (mProgressView.getVisibility() != View.VISIBLE) {
                mProgressView.setVisibility(View.VISIBLE);
            }
            if (mProgressView.isIndeterminate()) {
                mProgressView.setIndeterminate(false);
            }
            mProgressView.setProgress(progress);

            // Hide on completion.
            if (progress == 100) {
                hideProgress();
            }
        }

        public void showProgressIndeterminate() {
            if (mProgressView.getVisibility() != View.VISIBLE) {
                mProgressView.setVisibility(View.VISIBLE);
            }
            if (!mProgressView.isIndeterminate()) {
                mProgressView.setIndeterminate(true);
            }
        }

        /**
         * Determines whether or not this attachment has a saved file in the external storage. That
         * is, the user has at some point clicked ""save"" for this attachment.
         *
         * Note: this is an approximation and uses an in-memory cache that can get wiped when the
         * process dies, and so is somewhat conservative. Additionally, the user can modify the file
         * after saving, and so the file may not be the same (though this is unlikely).
         */
        public boolean isFileSaved() {
            String path = getSavedPath();
            if (path == null) {
                return false;
            }
            boolean savedFileExists = new File(path).exists();
            if (!savedFileExists) {
                // Purge the cache entry.
                setSavedPath(null);
            }
            return savedFileExists;
        }

        private void setSavedPath(String path) {
            if (path == null) {
                sSavedFileInfos.remove(this);
            } else {
                sSavedFileInfos.put(this, path);
            }
        }

        /**
         * Returns an absolute file path for the given attachment if it has been saved. If one is
         * not found, {@code null} is returned.
         *
         * Clients are expected to validate that the file at the given path is still valid.
         */
        private String getSavedPath() {
            return sSavedFileInfos.get(this);
        }

        @Override
        protected Uri getUriForIntent(Context context, long accountId) {
            // Prefer to act on the saved file for intents.
            String path = getSavedPath();
            return (path != null)
                    ? Uri.parse(""file://"" + getSavedPath())
                    : super.getUriForIntent(context, accountId);
        }
    }

    /**
     * Updates all current attachments on the attachment tab.
     */
    private void updateAttachmentTab() {
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
            View view = mAttachments.getChildAt(i);
            MessageViewAttachmentInfo oldInfo = (MessageViewAttachmentInfo)view.getTag();
            MessageViewAttachmentInfo newInfo =
                    new MessageViewAttachmentInfo(getActivity(), oldInfo);
            updateAttachmentButtons(newInfo);
            view.setTag(newInfo);
        }
    }

    /**
     * Updates the attachment buttons. Adjusts the visibility of the buttons as well
     * as updating any tag information associated with the buttons.
     */
    private void updateAttachmentButtons(MessageViewAttachmentInfo attachmentInfo) {
        ImageView attachmentIcon = attachmentInfo.iconView;
        Button openButton = attachmentInfo.openButton;
        Button saveButton = attachmentInfo.saveButton;
        Button loadButton = attachmentInfo.loadButton;
        Button infoButton = attachmentInfo.infoButton;
        Button cancelButton = attachmentInfo.cancelButton;

        if (!attachmentInfo.mAllowView) {
            openButton.setVisibility(View.GONE);
        }
        if (!attachmentInfo.mAllowSave) {
            saveButton.setVisibility(View.GONE);
        }

        if (!attachmentInfo.mAllowView && !attachmentInfo.mAllowSave) {
            // This attachment may never be viewed or saved, so block everything
            attachmentInfo.hideProgress();
            openButton.setVisibility(View.GONE);
            saveButton.setVisibility(View.GONE);
            loadButton.setVisibility(View.GONE);
            cancelButton.setVisibility(View.GONE);
            infoButton.setVisibility(View.VISIBLE);
        } else if (attachmentInfo.loaded) {
            // If the attachment is loaded, show 100% progress
            // Note that for POP3 messages, the user will only see ""Open"" and ""Save"",
            // because the entire message is loaded before being shown.
            // Hide ""Load"" and ""Info"", show ""View"" and ""Save""
            attachmentInfo.showProgress(100);
            if (attachmentInfo.mAllowSave) {
                saveButton.setVisibility(View.VISIBLE);

                boolean isFileSaved = attachmentInfo.isFileSaved();
                saveButton.setEnabled(!isFileSaved);
                if (!isFileSaved) {
                    saveButton.setText(R.string.message_view_attachment_save_action);
                } else {
                    saveButton.setText(R.string.message_view_attachment_saved);
                }
            }
            if (attachmentInfo.mAllowView) {
                // Set the attachment action button text accordingly
                if (attachmentInfo.mContentType.startsWith(""audio/"") ||
                        attachmentInfo.mContentType.startsWith(""video/"")) {
                    openButton.setText(R.string.message_view_attachment_play_action);
                } else if (attachmentInfo.mAllowInstall) {
                    openButton.setText(R.string.message_view_attachment_install_action);
                } else {
                    openButton.setText(R.string.message_view_attachment_view_action);
                }
                openButton.setVisibility(View.VISIBLE);
            }
            if (attachmentInfo.mDenyFlags == AttachmentInfo.ALLOW) {
                infoButton.setVisibility(View.GONE);
            } else {
                infoButton.setVisibility(View.VISIBLE);
            }
            loadButton.setVisibility(View.GONE);
            cancelButton.setVisibility(View.GONE);

            updatePreviewIcon(attachmentInfo);
        } else {
            // The attachment is not loaded, so present UI to start downloading it

            // Show ""Load""; hide ""View"", ""Save"" and ""Info""
            saveButton.setVisibility(View.GONE);
            openButton.setVisibility(View.GONE);
            infoButton.setVisibility(View.GONE);

            // If the attachment is queued, show the indeterminate progress bar.  From this point,.
            // any progress changes will cause this to be replaced by the normal progress bar
            if (AttachmentDownloadService.isAttachmentQueued(attachmentInfo.mId)) {
                attachmentInfo.showProgressIndeterminate();
                loadButton.setVisibility(View.GONE);
                cancelButton.setVisibility(View.VISIBLE);
            } else {
                loadButton.setVisibility(View.VISIBLE);
                cancelButton.setVisibility(View.GONE);
            }
        }
        openButton.setTag(attachmentInfo);
        saveButton.setTag(attachmentInfo);
        loadButton.setTag(attachmentInfo);
        infoButton.setTag(attachmentInfo);
        cancelButton.setTag(attachmentInfo);
    }

    /**
     * Copy data from a cursor-refreshed attachment into the UI.  Called from UI thread.
     *
     * @param attachment A single attachment loaded from the provider
     */
    private void addAttachment(Attachment attachment) {
        LayoutInflater inflater = getActivity().getLayoutInflater();
        View view = inflater.inflate(R.layout.message_view_attachment, null);

        TextView attachmentName = (TextView) UiUtilities.getView(view, R.id.attachment_name);
        TextView attachmentInfoView = (TextView) UiUtilities.getView(view, R.id.attachment_info);
        ImageView attachmentIcon = (ImageView) UiUtilities.getView(view, R.id.attachment_icon);
        Button openButton = (Button) UiUtilities.getView(view, R.id.open);
        Button saveButton = (Button) UiUtilities.getView(view, R.id.save);
        Button loadButton = (Button) UiUtilities.getView(view, R.id.load);
        Button infoButton = (Button) UiUtilities.getView(view, R.id.info);
        Button cancelButton = (Button) UiUtilities.getView(view, R.id.cancel);
        ProgressBar attachmentProgress = (ProgressBar) UiUtilities.getView(view, R.id.progress);

        MessageViewAttachmentInfo attachmentInfo = new MessageViewAttachmentInfo(
                mContext, attachment, attachmentProgress);

        // Check whether the attachment already exists
        if (Utility.attachmentExists(mContext, attachment)) {
            attachmentInfo.loaded = true;
        }

        attachmentInfo.openButton = openButton;
        attachmentInfo.saveButton = saveButton;
        attachmentInfo.loadButton = loadButton;
        attachmentInfo.infoButton = infoButton;
        attachmentInfo.cancelButton = cancelButton;
        attachmentInfo.iconView = attachmentIcon;

        updateAttachmentButtons(attachmentInfo);

        view.setTag(attachmentInfo);
        openButton.setOnClickListener(this);
        saveButton.setOnClickListener(this);
        loadButton.setOnClickListener(this);
        infoButton.setOnClickListener(this);
        cancelButton.setOnClickListener(this);

        attachmentName.setText(attachmentInfo.mName);
        attachmentInfoView.setText(UiUtilities.formatSize(mContext, attachmentInfo.mSize));

        mAttachments.addView(view);
        mAttachments.setVisibility(View.VISIBLE);
    }

    private MessageViewAttachmentInfo findAttachmentInfoFromView(long attachmentId) {
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
            MessageViewAttachmentInfo attachmentInfo =
                    (MessageViewAttachmentInfo) mAttachments.getChildAt(i).getTag();
            if (attachmentInfo.mId == attachmentId) {
                return attachmentInfo;
            }
        }
        return null;
    }

    /**
     * Reload the UI from a provider cursor.  {@link LoadMessageTask#onSuccess} calls it.
     *
     * Update the header views, and start loading the body.
     *
     * @param message A copy of the message loaded from the database
     * @param okToFetch If true, and message is not fully loaded, it's OK to fetch from
     * the network.  Use false to prevent looping here.
     */
    protected void reloadUiFromMessage(Message message, boolean okToFetch) {
        mMessage = message;
        mAccountId = message.mAccountKey;

        mMessageObserver.register(ContentUris.withAppendedId(Message.CONTENT_URI, mMessage.mId));

        updateHeaderView(mMessage);

        // Handle partially-loaded email, as follows:
        // 1. Check value of message.mFlagLoaded
        // 2. If != LOADED, ask controller to load it
        // 3. Controller callback (after loaded) should trigger LoadBodyTask & LoadAttachmentsTask
        // 4. Else start the loader tasks right away (message already loaded)
        if (okToFetch && message.mFlagLoaded != Message.FLAG_LOADED_COMPLETE) {
            mControllerCallback.getWrappee().setWaitForLoadMessageId(message.mId);
            mController.loadMessageForView(message.mId);
        } else {
            Address[] fromList = Address.unpack(mMessage.mFrom);
            boolean autoShowImages = false;
            for (Address sender : fromList) {
                String email = sender.getAddress();
                if (shouldShowImagesFor(email)) {
                    autoShowImages = true;
                    break;
                }
            }
            mControllerCallback.getWrappee().setWaitForLoadMessageId(Message.NO_MESSAGE);
            // Ask for body
            new LoadBodyTask(message.mId, autoShowImages).executeParallel();
        }
    }

    protected void updateHeaderView(Message message) {
        mSubjectView.setText(message.mSubject);
        final Address from = Address.unpackFirst(message.mFrom);

        // Set sender address/display name
        // Note we set "" "" for empty field, so TextView's won't get squashed.
        // Otherwise their height will be 0, which breaks the layout.
        if (from != null) {
            final String fromFriendly = from.toFriendly();
            final String fromAddress = from.getAddress();
            mFromNameView.setText(fromFriendly);
            mFromAddressView.setText(fromFriendly.equals(fromAddress) ? "" "" : fromAddress);
        } else {
            mFromNameView.setText("" "");
            mFromAddressView.setText("" "");
        }
        mDateTimeView.setText(DateUtils.getRelativeTimeSpanString(mContext, message.mTimeStamp)
                .toString());

        // To/Cc/Bcc
        final Resources res = mContext.getResources();
        final SpannableStringBuilder ssb = new SpannableStringBuilder();
        final String friendlyTo = Address.toFriendly(Address.unpack(message.mTo));
        final String friendlyCc = Address.toFriendly(Address.unpack(message.mCc));
        final String friendlyBcc = Address.toFriendly(Address.unpack(message.mBcc));

        if (!TextUtils.isEmpty(friendlyTo)) {
            Utility.appendBold(ssb, res.getString(R.string.message_view_to_label));
            ssb.append("" "");
            ssb.append(friendlyTo);
        }
        if (!TextUtils.isEmpty(friendlyCc)) {
            ssb.append(""  "");
            Utility.appendBold(ssb, res.getString(R.string.message_view_cc_label));
            ssb.append("" "");
            ssb.append(friendlyCc);
        }
        if (!TextUtils.isEmpty(friendlyBcc)) {
            ssb.append(""  "");
            Utility.appendBold(ssb, res.getString(R.string.message_view_bcc_label));
            ssb.append("" "");
            ssb.append(friendlyBcc);
        }
        mAddressesView.setText(ssb);
    }

    /**
     * @return the given date/time in a human readable form.  The returned string always have
     *     month and day (and year if {@code withYear} is set), so is usually long.
     *     Use {@link DateUtils#getRelativeTimeSpanString} instead to save the screen real estate.
     */
    private String formatDate(long millis, boolean withYear) {
        StringBuilder sb = new StringBuilder();
        Formatter formatter = new Formatter(sb);
        DateUtils.formatDateRange(mContext, formatter, millis, millis,
                DateUtils.FORMAT_SHOW_DATE
                | DateUtils.FORMAT_ABBREV_ALL
                | DateUtils.FORMAT_SHOW_TIME
                | (withYear ? DateUtils.FORMAT_SHOW_YEAR : DateUtils.FORMAT_NO_YEAR));
        return sb.toString();
    }

    /**
     * Reload the body from the provider cursor.  This must only be called from the UI thread.
     *
     * @param bodyText text part
     * @param bodyHtml html part
     *
     * TODO deal with html vs text and many other issues <- WHAT DOES IT MEAN??
     */
    private void reloadUiFromBody(String bodyText, String bodyHtml, boolean autoShowPictures) {
        String text = null;
        mHtmlTextRaw = null;
        boolean hasImages = false;

        if (bodyHtml == null) {
            text = bodyText;
            /*
             * Convert the plain text to HTML
             */
            StringBuffer sb = new StringBuffer(""<html><body>"");
            if (text != null) {
                // Escape any inadvertent HTML in the text message
                text = EmailHtmlUtil.escapeCharacterToDisplay(text);
                // Find any embedded URL's and linkify
                Matcher m = Patterns.WEB_URL.matcher(text);
                while (m.find()) {
                    int start = m.start();
                    /*
                     * WEB_URL_PATTERN may match domain part of email address. To detect
                     * this false match, the character just before the matched string
                     * should not be '@'.
                     */
                    if (start == 0 || text.charAt(start - 1) != '@') {
                        String url = m.group();
                        Matcher proto = WEB_URL_PROTOCOL.matcher(url);
                        String link;
                        if (proto.find()) {
                            // This is work around to force URL protocol part be lower case,
                            // because WebView could follow only lower case protocol link.
                            link = proto.group().toLowerCase() + url.substring(proto.end());
                        } else {
                            // Patterns.WEB_URL matches URL without protocol part,
                            // so added default protocol to link.
                            link = ""http://"" + url;
                        }
                        String href = String.format(""<a href=\""%s\"">%s</a>"", link, url);
                        m.appendReplacement(sb, href);
                    }
                    else {
                        m.appendReplacement(sb, ""$0"");
                    }
                }
                m.appendTail(sb);
            }
            sb.append(""</body></html>"");
            text = sb.toString();
        } else {
            text = bodyHtml;
            mHtmlTextRaw = bodyHtml;
            hasImages = IMG_TAG_START_REGEX.matcher(text).find();
        }

        // TODO this is not really accurate.
        // - Images aren't the only network resources.  (e.g. CSS)
        // - If images are attached to the email and small enough, we download them at once,
        //   and won't need network access when they're shown.
        if (hasImages) {
            if (mRestoredPictureLoaded || autoShowPictures) {
                blockNetworkLoads(false);
                addTabFlags(TAB_FLAGS_PICTURE_LOADED); // Set for next onSaveInstanceState

                // Make sure to reset the flag -- otherwise this will keep taking effect even after
                // moving to another message.
                mRestoredPictureLoaded = false;
            } else {
                addTabFlags(TAB_FLAGS_HAS_PICTURES);
            }
        }
        setMessageHtml(text);

        // Ask for attachments after body
        new LoadAttachmentsTask().executeParallel(mMessage.mId);

        mIsMessageLoadedForTest = true;
    }

    /**
     * Overrides for WebView behaviors.
     */
    private class CustomWebViewClient extends WebViewClient {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, String url) {
            return mCallback.onUrlInMessageClicked(url);
        }
    }

    private View findAttachmentView(long attachmentId) {
        for (int i = 0, count = mAttachments.getChildCount(); i < count; i++) {
            View view = mAttachments.getChildAt(i);
            MessageViewAttachmentInfo attachment = (MessageViewAttachmentInfo) view.getTag();
            if (attachment.mId == attachmentId) {
                return view;
            }
        }
        return null;
    }

    private MessageViewAttachmentInfo findAttachmentInfo(long attachmentId) {
        View view = findAttachmentView(attachmentId);
        if (view != null) {
            return (MessageViewAttachmentInfo)view.getTag();
        }
        return null;
    }

    /**
     * Controller results listener.  We wrap it with {@link ControllerResultUiThreadWrapper},
     * so all methods are called on the UI thread.
     */
    private class ControllerResults extends Controller.Result {
        private long mWaitForLoadMessageId;

        public void setWaitForLoadMessageId(long messageId) {
            mWaitForLoadMessageId = messageId;
        }

        @Override
        public void loadMessageForViewCallback(MessagingException result, long accountId,
                long messageId, int progress) {
            if (messageId != mWaitForLoadMessageId) {
                // We are not waiting for this message to load, so exit quickly
                return;
            }
            if (result == null) {
                switch (progress) {
                    case 0:
                        mCallback.onLoadMessageStarted();
                        // Loading from network -- show the progress icon.
                        showContent(false, true);
                        break;
                    case 100:
                        mWaitForLoadMessageId = -1;
                        mCallback.onLoadMessageFinished();
                        // reload UI and reload everything else too
                        // pass false to LoadMessageTask to prevent looping here
                        cancelAllTasks();
                        new LoadMessageTask(false).executeParallel();
                        break;
                    default:
                        // do nothing - we don't have a progress bar at this time
                        break;
                }
            } else {
                mWaitForLoadMessageId = Message.NO_MESSAGE;
                String error = mContext.getString(R.string.status_network_error);
                mCallback.onLoadMessageError(error);
                resetView();
            }
        }

        @Override
        public void loadAttachmentCallback(MessagingException result, long accountId,
                long messageId, long attachmentId, int progress) {
            if (messageId == mMessageId) {
                if (result == null) {
                    showAttachmentProgress(attachmentId, progress);
                    switch (progress) {
                        case 100:
                            final MessageViewAttachmentInfo attachmentInfo =
                                    findAttachmentInfoFromView(attachmentId);
                            if (attachmentInfo != null) {
                                updatePreviewIcon(attachmentInfo);
                            }
                            doFinishLoadAttachment(attachmentId);
                            break;
                        default:
                            // do nothing - we don't have a progress bar at this time
                            break;
                    }
                } else {
                    MessageViewAttachmentInfo attachment = findAttachmentInfo(attachmentId);
                    if (attachment == null) {
                        // Called before LoadAttachmentsTask finishes.
                        // (Possible if you quickly close & re-open a message)
                        return;
                    }
                    attachment.cancelButton.setVisibility(View.GONE);
                    attachment.loadButton.setVisibility(View.VISIBLE);
                    attachment.hideProgress();

                    final String error;
                    if (result.getCause() instanceof IOException) {
                        error = mContext.getString(R.string.status_network_error);
                    } else {
                        error = mContext.getString(
                                R.string.message_view_load_attachment_failed_toast,
                                attachment.mName);
                    }
                    mCallback.onLoadMessageError(error);
                }
            }
        }

        private void showAttachmentProgress(long attachmentId, int progress) {
            MessageViewAttachmentInfo attachment = findAttachmentInfo(attachmentId);
            if (attachment != null) {
                if (progress == 0) {
                    attachment.cancelButton.setVisibility(View.GONE);
                }
                attachment.showProgress(progress);
            }
        }
    }

    /**
     * Class to detect update on the current message (e.g. toggle star).  When it gets content
     * change notifications, it kicks {@link ReloadMessageTask}.
     */
    private class MessageObserver extends ContentObserver implements Runnable {
        private final Throttle mThrottle;
        private final ContentResolver mContentResolver;

        private boolean mRegistered;

        public MessageObserver(Handler handler, Context context) {
            super(handler);
            mContentResolver = context.getContentResolver();
            mThrottle = new Throttle(""MessageObserver"", this, handler);
        }

        public void unregister() {
            if (!mRegistered) {
                return;
            }
            mThrottle.cancelScheduledCallback();
            mContentResolver.unregisterContentObserver(this);
            mRegistered = false;
        }

        public void register(Uri notifyUri) {
            unregister();
            mContentResolver.registerContentObserver(notifyUri, true, this);
            mRegistered = true;
        }

        @Override
        public boolean deliverSelfNotifications() {
            return true;
        }

        @Override
        public void onChange(boolean selfChange) {
            if (mRegistered) {
                mThrottle.onEvent();
            }
        }

        /** This method is delay-called by {@link Throttle} on the UI thread. */
        @Override
        public void run() {
            // This method is delay-called, so need to make sure if it's still registered.
            if (mRegistered) {
                new ReloadMessageTask().cancelPreviousAndExecuteParallel();
            }
        }
    }

    private void updatePreviewIcon(MessageViewAttachmentInfo attachmentInfo) {
        new UpdatePreviewIconTask(attachmentInfo).executeParallel();
    }

    private class UpdatePreviewIconTask extends EmailAsyncTask<Void, Void, Bitmap> {
        @SuppressWarnings(""hiding"")
        private final Context mContext;
        private final MessageViewAttachmentInfo mAttachmentInfo;

        public UpdatePreviewIconTask(MessageViewAttachmentInfo attachmentInfo) {
            super(mTaskTracker);
            mContext = getActivity();
            mAttachmentInfo = attachmentInfo;
        }

        @Override
        protected Bitmap doInBackground(Void... params) {
            return getPreviewIcon(mContext, mAttachmentInfo);
        }

        @Override
        protected void onSuccess(Bitmap result) {
            if (result == null) {
                return;
            }
            mAttachmentInfo.iconView.setImageBitmap(result);
        }
    }

    private boolean shouldShowImagesFor(String senderEmail) {
        return Preferences.getPreferences(getActivity()).shouldShowImagesFor(senderEmail);
    }

    private void setShowImagesForSender() {
        makeVisible(UiUtilities.getView(getView(), R.id.always_show_pictures_button), false);
        Utility.showToast(getActivity(), R.string.message_view_always_show_pictures_confirmation);

        // Force redraw of the container.
        updateTabs(mTabFlags);

        Address[] fromList = Address.unpack(mMessage.mFrom);
        Preferences prefs = Preferences.getPreferences(getActivity());
        for (Address sender : fromList) {
            String email = sender.getAddress();
            prefs.setSenderAsTrusted(email);
        }
    }

    public boolean isMessageLoadedForTest() {
        return mIsMessageLoadedForTest;
    }

    public void clearIsMessageLoadedForTest() {
        mIsMessageLoadedForTest = true;
    }
}
",True,270,1,3,10,49,6,22,L6
74,com.android.email.activity.setup.AccountServerBaseFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.app.Fragment;
import android.content.Context;
import android.os.AsyncTask;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnFocusChangeListener;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.TextView;
import android.widget.TextView.OnEditorActionListener;

import com.android.email.R;
import com.android.email.activity.UiUtilities;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.Utility;

import java.net.URI;
import java.net.URISyntaxException;

/**
 * Common base class for server settings fragments, so they can be more easily manipulated by
 * AccountSettingsXL.  Provides the following common functionality:
 *
 * Activity-provided callbacks
 * Activity callback during onAttach
 * Present ""Next"" button and respond to its clicks
 */
public abstract class AccountServerBaseFragment extends Fragment
        implements AccountCheckSettingsFragment.Callbacks, OnClickListener {

    public static Bundle sSetupModeArgs = null;
    protected static URI sDefaultUri;

    private static final String BUNDLE_KEY_SETTINGS = ""AccountServerBaseFragment.settings"";
    private static final String BUNDLE_KEY_ACTIVITY_TITLE = ""AccountServerBaseFragment.title"";

    protected Context mContext;
    protected Callback mCallback = EmptyCallback.INSTANCE;
    /**
     * Whether or not we are in ""settings mode"". We re-use the same screens for both the initial
     * account creation as well as subsequent account modification. If <code>mSettingsMode</code>
     * if <code>false</code>, we are in account creation mode. Otherwise, we are in account
     * modification mode.
     */
    protected boolean mSettingsMode;
    /*package*/ HostAuth mLoadedSendAuth;
    /*package*/ HostAuth mLoadedRecvAuth;

    // This is null in the setup wizard screens, and non-null in AccountSettings mode
    private Button mProceedButton;
    // This is used to debounce multiple clicks on the proceed button (which does async work)
    private boolean mProceedButtonPressed;
    /*package*/ String mBaseScheme = ""protocol"";

    /**
     * Callback interface that owning activities must provide
     */
    public interface Callback {
        /**
         * Called each time the user-entered input transitions between valid and invalid
         * @param enable true to enable proceed/next button, false to disable
         */
        public void onEnableProceedButtons(boolean enable);

        /**
         * Called when user clicks ""next"".  Starts account checker.
         * @param checkMode values from {@link SetupData}
         * @param target the fragment that requested the check
         */
        public void onProceedNext(int checkMode, AccountServerBaseFragment target);

        /**
         * Called when account checker completes.  Fragments are responsible for saving
         * own edited data;  This is primarily for the activity to do post-check navigation.
         * @param result check settings result code - success is CHECK_SETTINGS_OK
         * @param setupMode signals if we were editing or creating
         */
        public void onCheckSettingsComplete(int result, int setupMode);
    }

    private static class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();
        @Override public void onEnableProceedButtons(boolean enable) { }
        @Override public void onProceedNext(int checkMode, AccountServerBaseFragment target) { }
        @Override public void onCheckSettingsComplete(int result, int setupMode) { }
    }

    /**
     * Get the static arguments bundle that forces a server settings fragment into ""settings"" mode
     * (If not included, you'll be in ""setup"" mode which behaves slightly differently.)
     */
    public static synchronized Bundle getSettingsModeArgs() {
        if (sSetupModeArgs == null) {
            sSetupModeArgs = new Bundle();
            sSetupModeArgs.putBoolean(BUNDLE_KEY_SETTINGS, true);
        }
        return sSetupModeArgs;
    }

    public AccountServerBaseFragment() {
        if (sDefaultUri == null) {
            try {
                sDefaultUri = new URI("""");
            } catch (URISyntaxException ignore) {
                // ignore; will never happen
            }
        }
    }

    /**
     * At onCreate time, read the fragment arguments
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Get arguments, which modally switch us into ""settings"" mode (different appearance)
        mSettingsMode = false;
        if (getArguments() != null) {
            mSettingsMode = getArguments().getBoolean(BUNDLE_KEY_SETTINGS);
        }
    }

    /**
     * Called from onCreateView, to do settings mode configuration
     */
    protected void onCreateViewSettingsMode(View view) {
        if (mSettingsMode) {
            UiUtilities.getView(view, R.id.cancel).setOnClickListener(this);
            mProceedButton = (Button) UiUtilities.getView(view, R.id.done);
            mProceedButton.setOnClickListener(this);
            mProceedButton.setEnabled(false);
        }
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        // startPreferencePanel launches this fragment with the right title initially, but
        // if the device is rotate we must set the title ourselves
        if (mSettingsMode && savedInstanceState != null) {
            getActivity().setTitle(savedInstanceState.getString(BUNDLE_KEY_ACTIVITY_TITLE));
        }
        super.onActivityCreated(savedInstanceState);
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        outState.putString(BUNDLE_KEY_ACTIVITY_TITLE, (String) getActivity().getTitle());
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        mContext = activity;
    }

    @Override
    public void onDetach() {
        super.onDetach();

        // Ensure that we don't have any callbacks at this point.
        mCallback = EmptyCallback.INSTANCE;
    }

    @Override
    public void onPause() {
        // Hide the soft keyboard if we lose focus
        InputMethodManager imm =
                (InputMethodManager)mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
        imm.hideSoftInputFromWindow(getView().getWindowToken(), 0);
        super.onPause();
    }

    /**
     * Implements OnClickListener
     */
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.cancel:
                getActivity().onBackPressed();
                break;
            case R.id.done:
                // Simple debounce - just ignore while checks are underway
                if (mProceedButtonPressed) {
                    return;
                }
                mProceedButtonPressed = true;
                onNext();
                break;
        }
    }

    /**
     * Activity provides callbacks here.
     */
    public void setCallback(Callback callback) {
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
        mContext = getActivity();
    }

    /**
     * Enable/disable the ""next"" button
     */
    public void enableNextButton(boolean enable) {
        // If we are in settings ""mode"" we may be showing our own next button, and we'll
        // enable it directly, here
        if (mProceedButton != null) {
            mProceedButton.setEnabled(enable);
        }
        clearButtonBounce();

        // TODO: This supports the phone UX activities and will be removed
        mCallback.onEnableProceedButtons(enable);
    }

    /**
     * Performs async operations as part of saving changes to the settings.
     *      Check for duplicate account
     *      Display dialog if necessary
     *      Else, proceed via mCallback.onProceedNext
     */
    protected void startDuplicateTaskCheck(long accountId, String checkHost, String checkLogin,
            int checkSettingsMode) {
        new DuplicateCheckTask(accountId, checkHost, checkLogin, checkSettingsMode)
                .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }

    /**
     * Make the given text view uneditable. If the text view is ever focused, the specified
     * error message will be displayed.
     */
    protected void makeTextViewUneditable(final TextView view, final String errorMessage) {
        // We're editing an existing account; don't allow modification of the user name
        if (mSettingsMode) {
            view.setKeyListener(null);
            view.setFocusable(true);
            view.setOnFocusChangeListener(new OnFocusChangeListener() {
                @Override
                public void onFocusChange(View v, boolean hasFocus) {
                    if (hasFocus) {
                        // Framework will not auto-hide IME; do it ourselves
                        InputMethodManager imm = (InputMethodManager)mContext.
                                getSystemService(Context.INPUT_METHOD_SERVICE);
                        imm.hideSoftInputFromWindow(getView().getWindowToken(), 0);
                        view.setError(errorMessage);
                    } else {
                        view.setError(null);
                    }
                }
            });
            view.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    if (view.getError() == null) {
                        view.setError(errorMessage);
                    } else {
                        view.setError(null);
                    }
                }
            });
        }
    }

    /**
     * A keyboard listener which dismisses the keyboard when ""DONE"" is pressed, but doesn't muck
     * around with focus. This is useful in settings screens, as we don't want focus to change
     * since some fields throw up errors when they're focused to give the user more info.
     */
    protected final OnEditorActionListener mDismissImeOnDoneListener =
            new OnEditorActionListener() {
        @Override
        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
            if (actionId == EditorInfo.IME_ACTION_DONE) {
                // Dismiss soft keyboard but don't modify focus.
                final Context context = getActivity();
                if (context == null) {
                    return false;
                }
                InputMethodManager imm = (InputMethodManager) context.getSystemService(
                        Context.INPUT_METHOD_SERVICE);
                if (imm != null && imm.isActive()) {
                    imm.hideSoftInputFromWindow(getView().getWindowToken(), 0);
                }
                return true;
            }
            return false;
        }
    };

    /**
     * Clears the ""next"" button de-bounce flags and allows the ""next"" button to activate.
     */
    private void clearButtonBounce() {
        mProceedButtonPressed = false;
    }

    private class DuplicateCheckTask extends AsyncTask<Void, Void, Account> {

        private final long mAccountId;
        private final String mCheckHost;
        private final String mCheckLogin;
        private final int mCheckSettingsMode;

        public DuplicateCheckTask(long accountId, String checkHost, String checkLogin,
                int checkSettingsMode) {
            mAccountId = accountId;
            mCheckHost = checkHost;
            mCheckLogin = checkLogin;
            mCheckSettingsMode = checkSettingsMode;
        }

        @Override
        protected Account doInBackground(Void... params) {
            Account account = Utility.findExistingAccount(mContext, mAccountId,
                    mCheckHost, mCheckLogin);
            return account;
        }

        @Override
        protected void onPostExecute(Account duplicateAccount) {
            AccountServerBaseFragment fragment = AccountServerBaseFragment.this;
            if (duplicateAccount != null) {
                // Show duplicate account warning
                DuplicateAccountDialogFragment dialogFragment =
                    DuplicateAccountDialogFragment.newInstance(duplicateAccount.mDisplayName);
                dialogFragment.show(fragment.getFragmentManager(),
                        DuplicateAccountDialogFragment.TAG);
            } else {
                // Otherwise, proceed with the save/check
                mCallback.onProceedNext(mCheckSettingsMode, fragment);
            }
            clearButtonBounce();
        }
    }

    /**
     * Implements AccountCheckSettingsFragment.Callbacks
     *
     * Handle OK or error result from check settings.  Save settings (async), and then
     * exit to previous fragment.
     */
    @Override
    public void onCheckSettingsComplete(final int settingsResult) {
        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... params) {
                if (settingsResult == AccountCheckSettingsFragment.CHECK_SETTINGS_OK) {
                    if (SetupData.getFlowMode() == SetupData.FLOW_MODE_EDIT) {
                        saveSettingsAfterEdit();
                    } else {
                        saveSettingsAfterSetup();
                    }
                }
                return null;
            }

            @Override
            protected void onPostExecute(Void result) {
                // Signal to owning activity that a settings check completed
                mCallback.onCheckSettingsComplete(settingsResult, SetupData.getFlowMode());
            }
        }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    }

    /**
     * Implements AccountCheckSettingsFragment.Callbacks
     * This is overridden only by AccountSetupExchange
     */
    @Override
    public void onAutoDiscoverComplete(int result, HostAuth hostAuth) {
        throw new IllegalStateException();
    }

    /**
     * Returns whether or not any settings have changed.
     */
    public boolean haveSettingsChanged() {
        Account account = SetupData.getAccount();

        HostAuth sendAuth = account.getOrCreateHostAuthSend(mContext);
        boolean sendChanged = (mLoadedSendAuth != null && !mLoadedSendAuth.equals(sendAuth));

        HostAuth recvAuth = account.getOrCreateHostAuthRecv(mContext);
        boolean recvChanged = (mLoadedRecvAuth != null && !mLoadedRecvAuth.equals(recvAuth));

        return sendChanged || recvChanged;
    }

    /**
     * Save settings after ""OK"" result from checker.  Concrete classes must implement.
     * This is called from a worker thread and is allowed to perform DB operations.
     */
    public abstract void saveSettingsAfterEdit();

    /**
     * Save settings after ""OK"" result from checker.  Concrete classes must implement.
     * This is called from a worker thread and is allowed to perform DB operations.
     */
    public abstract void saveSettingsAfterSetup();

    /**
     * Respond to a click of the ""Next"" button.  Concrete classes must implement.
     */
    public abstract void onNext();
}
",True,267,0,0,11,60,7,7,L6
75,com.android.email.activity.setup.DebugFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import com.android.email.Email;
import com.android.email.Preferences;
import com.android.email.R;
import com.android.email.activity.UiUtilities;
import com.android.email.service.EmailServiceUtils;
import com.android.email.service.MailService;
import com.android.emailcommon.Logging;

import android.app.Fragment;
import android.content.Context;
import android.os.Bundle;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.webkit.WebView;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.TextView;

public class DebugFragment extends Fragment implements OnCheckedChangeListener,
        View.OnClickListener {
    private TextView mVersionView;
    private CheckBox mEnableDebugLoggingView;
    private CheckBox mEnableExchangeLoggingView;
    private CheckBox mEnableExchangeFileLoggingView;
    private CheckBox mInhibitGraphicsAccelerationView;
    private CheckBox mForceOneMinuteRefreshView;
    private CheckBox mEnableStrictModeView;

    private Preferences mPreferences;

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupBasicsFragment onCreateView"");
        }
        View view = inflater.inflate(R.layout.debug, container, false);

        Context context = getActivity();
        mPreferences = Preferences.getPreferences(context);

        mVersionView = (TextView) UiUtilities.getView(view, R.id.version);
        mVersionView.setText(String.format(context.getString(R.string.debug_version_fmt).toString(),
                context.getString(R.string.build_number)));

        mEnableDebugLoggingView = (CheckBox) UiUtilities.getView(view, R.id.debug_logging);
        mEnableDebugLoggingView.setChecked(Email.DEBUG);

        mEnableExchangeLoggingView = (CheckBox) UiUtilities.getView(view, R.id.exchange_logging);
        mEnableExchangeFileLoggingView =
            (CheckBox) UiUtilities.getView(view, R.id.exchange_file_logging);

        // Note:  To prevent recursion while presetting checkboxes, assign all listeners last
        mEnableDebugLoggingView.setOnCheckedChangeListener(this);

        boolean exchangeAvailable = EmailServiceUtils.isExchangeAvailable(context);
        if (exchangeAvailable) {
            mEnableExchangeLoggingView.setChecked(Email.DEBUG_EXCHANGE_VERBOSE);
            mEnableExchangeFileLoggingView.setChecked(Email.DEBUG_EXCHANGE_FILE);
            mEnableExchangeLoggingView.setOnCheckedChangeListener(this);
            mEnableExchangeFileLoggingView.setOnCheckedChangeListener(this);
        } else {
            mEnableExchangeLoggingView.setVisibility(View.GONE);
            mEnableExchangeFileLoggingView.setVisibility(View.GONE);
        }

        UiUtilities.getView(view, R.id.clear_webview_cache).setOnClickListener(this);

        mInhibitGraphicsAccelerationView = (CheckBox)
                UiUtilities.getView(view, R.id.debug_disable_graphics_acceleration);
        mInhibitGraphicsAccelerationView.setChecked(Email.sDebugInhibitGraphicsAcceleration);
        mInhibitGraphicsAccelerationView.setOnCheckedChangeListener(this);

        mForceOneMinuteRefreshView = (CheckBox)
                UiUtilities.getView(view, R.id.debug_force_one_minute_refresh);
        mForceOneMinuteRefreshView.setChecked(mPreferences.getForceOneMinuteRefresh());
        mForceOneMinuteRefreshView.setOnCheckedChangeListener(this);

        mEnableStrictModeView = (CheckBox)
                UiUtilities.getView(view, R.id.debug_enable_strict_mode);
        mEnableStrictModeView.setChecked(mPreferences.getEnableStrictMode());
        mEnableStrictModeView.setOnCheckedChangeListener(this);

        return view;
    }

    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        switch (buttonView.getId()) {
            case R.id.debug_logging:
                mPreferences.setEnableDebugLogging(isChecked);
                Email.DEBUG = isChecked;
                Email.DEBUG_EXCHANGE = isChecked;
                break;
             case R.id.exchange_logging:
                mPreferences.setEnableExchangeLogging(isChecked);
                Email.DEBUG_EXCHANGE_VERBOSE = isChecked;
                break;
            case R.id.exchange_file_logging:
                mPreferences.setEnableExchangeFileLogging(isChecked);
                Email.DEBUG_EXCHANGE_FILE = isChecked;
                break;
           case R.id.debug_disable_graphics_acceleration:
                Email.sDebugInhibitGraphicsAcceleration = isChecked;
                mPreferences.setInhibitGraphicsAcceleration(isChecked);
                break;
            case R.id.debug_force_one_minute_refresh:
                mPreferences.setForceOneMinuteRefresh(isChecked);
                MailService.actionReschedule(getActivity());
                break;
            case R.id.debug_enable_strict_mode:
                mPreferences.setEnableStrictMode(isChecked);
                Email.enableStrictMode(isChecked);
                break;
        }

        Email.updateLoggingFlags(getActivity());
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.clear_webview_cache:
                clearWebViewCache();
                break;
        }
    }

    private void clearWebViewCache() {
        WebView webview = new WebView(getActivity());
        try {
            webview.clearCache(true);
            Log.w(Logging.LOG_TAG, ""Cleard WebView cache."");
        } finally {
            webview.destroy();
        }
    }
}
",False,267,0,0,11,47,1,6,L6
76,com.android.email.activity.setup.MailboxSettings.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.ActionBar;
import android.app.Activity;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.PreferenceActivity;
import android.util.Log;
import android.view.MenuItem;

import com.android.email.Email;
import com.android.email.FolderProperties;
import com.android.email.R;
import com.android.email.RefreshManager;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.google.common.base.Objects;
import com.google.common.base.Preconditions;

/**
 * ""Mailbox settings"" activity.
 *
 * It's used to update per-mailbox sync settings.  It normally updates Mailbox settings, unless
 * the target mailbox is Inbox, in which case it updates Account settings instead.
 *
 * All changes made by the user will not be immediately saved to the database, as changing the
 * sync window may result in removal of messages.  Instead, we only save to the database in {@link
 * #onDestroy()}, unless it's called for configuration changes.
 */
public class MailboxSettings extends PreferenceActivity {
    private static final String EXTRA_MAILBOX_ID = ""MAILBOX_ID"";
    private static final String BUNDLE_ACCOUNT = ""MailboxSettings.account"";
    private static final String BUNDLE_MAILBOX = ""MailboxSettings.mailbox"";
    private static final String BUNDLE_NEEDS_SAVE = ""MailboxSettings.needsSave"";

    private static final String PREF_CHECK_FREQUENCY_KEY = ""check_frequency"";
    private static final String PREF_SYNC_WINDOW_KEY = ""sync_window"";

    private final EmailAsyncTask.Tracker mTaskTracker = new EmailAsyncTask.Tracker();

    // Account and Mailbox -- directly loaded by LoadMailboxTask
    private Account mAccount;
    private Mailbox mMailbox;
    private boolean mNeedsSave;

    private ListPreference mSyncIntervalPref;
    private ListPreference mSyncLookbackPref;

    /**
     * Starts the activity for a mailbox.
     */
    public static final void start(Activity parent, long mailboxId) {
        Intent i = new Intent(parent, MailboxSettings.class);
        i.putExtra(EXTRA_MAILBOX_ID, mailboxId);
        parent.startActivity(i);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final long mailboxId = getIntent().getLongExtra(EXTRA_MAILBOX_ID, Mailbox.NO_MAILBOX);
        if (mailboxId == Mailbox.NO_MAILBOX) {
            finish();
            return;
        }

        addPreferencesFromResource(R.xml.mailbox_preferences);

        mSyncIntervalPref = (ListPreference) findPreference(PREF_CHECK_FREQUENCY_KEY);
        mSyncLookbackPref = (ListPreference) findPreference(PREF_SYNC_WINDOW_KEY);

        mSyncIntervalPref.setOnPreferenceChangeListener(mPreferenceChanged);
        mSyncLookbackPref.setOnPreferenceChangeListener(mPreferenceChanged);

        // Make them disabled until we load data
        enablePreferences(false);

        if (savedInstanceState != null) {
            mAccount = savedInstanceState.getParcelable(BUNDLE_ACCOUNT);
            mMailbox = savedInstanceState.getParcelable(BUNDLE_MAILBOX);
            mNeedsSave = savedInstanceState.getBoolean(BUNDLE_NEEDS_SAVE);
        }
        if (mAccount == null) {
            new LoadMailboxTask(mailboxId).executeParallel((Void[]) null);
        } else {
            onDataLoaded();
        }

        // Always show ""app up"" as we expect our parent to be an Email activity.
        ActionBar actionBar = getActionBar();
        if (actionBar != null) {
            actionBar.setDisplayOptions(ActionBar.DISPLAY_HOME_AS_UP, ActionBar.DISPLAY_HOME_AS_UP);
        }
    }

    private void enablePreferences(boolean enabled) {
        mSyncIntervalPref.setEnabled(enabled);
        mSyncLookbackPref.setEnabled(enabled);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putParcelable(BUNDLE_ACCOUNT, mAccount);
        outState.putParcelable(BUNDLE_MAILBOX, mMailbox);
        outState.putBoolean(BUNDLE_NEEDS_SAVE, mNeedsSave);
    }

    /**
     * We save all the settings in onDestroy, *unless it's for configuration changes*.
     */
    @Override
    protected void onDestroy() {
        mTaskTracker.cancellAllInterrupt();
        if (!isChangingConfigurations()) {
            saveToDatabase();
        }
        super.onDestroy();
    }

    /**
     * Loads {@link #mAccount} and {@link #mMailbox}.
     */
    private class LoadMailboxTask extends EmailAsyncTask<Void, Void, Void> {
        private final long mMailboxId;

        public LoadMailboxTask(long mailboxId) {
            super(mTaskTracker);
            mMailboxId = mailboxId;
        }

        @Override
        protected Void doInBackground(Void... params) {
            final Context c = MailboxSettings.this;
            mMailbox = Mailbox.restoreMailboxWithId(c, mMailboxId);
            if (mMailbox != null) {
                mAccount = Account.restoreAccountWithId(c, mMailbox.mAccountKey);
            }
            return null;
        }

        @Override
        protected void onSuccess(Void result) {
            if ((mAccount == null) || (mMailbox == null)) {
                finish(); // Account or mailbox removed.
                return;
            }
            onDataLoaded();
        }
    }

    /**
     * Called when {@link #mAccount} and {@link #mMailbox} are loaded (either by the async task
     * or from the saved state).
     */
    private void onDataLoaded() {
        Preconditions.checkNotNull(mAccount);
        Preconditions.checkNotNull(mMailbox);

        // Update the title with the mailbox name.
        ActionBar actionBar = getActionBar();
        String mailboxName = FolderProperties.getInstance(this).getDisplayName(mMailbox);
        if (actionBar != null) {
            actionBar.setTitle(mailboxName);
            actionBar.setSubtitle(getString(R.string.mailbox_settings_activity_title));
        } else {
            setTitle(getString(R.string.mailbox_settings_activity_title_with_mailbox, mailboxName));
        }


        // Special case: If setting inbox, don't show ""Use account's default"".
        if (mMailbox.mType == Mailbox.TYPE_INBOX) {
            mSyncLookbackPref.setEntries(R.array.account_settings_mail_window_entries);
            mSyncLookbackPref.setEntryValues(R.array.account_settings_mail_window_values);
        }

        // Set default value & update summary
        mSyncIntervalPref.setValue(String.valueOf(getSyncInterval()));
        mSyncLookbackPref.setValue(String.valueOf(getSyncLookback()));

        updatePreferenceSummary();

        // Make then enabled
        enablePreferences(true);

    }

    private void updatePreferenceSummary() {
        mSyncIntervalPref.setSummary(mSyncIntervalPref.getEntry());
        mSyncLookbackPref.setSummary(mSyncLookbackPref.getEntry());
    }

    /**
     * @return current sync interval setting from the objects
     */
    private int getSyncInterval() {
        int syncInterval;
        if (mMailbox.mType == Mailbox.TYPE_INBOX) {
            syncInterval = mAccount.mSyncInterval;
        } else {
            if (mMailbox.mSyncInterval == 0) {
                // 0 is the default value, and it means ""don't sync"" (for non-inbox mailboxes)
                syncInterval = Mailbox.CHECK_INTERVAL_NEVER;
            } else {
                syncInterval = mMailbox.mSyncInterval;
            }
        }
        // In the case of the internal push states, use ""push""
        if (syncInterval == Mailbox.CHECK_INTERVAL_PING ||
                syncInterval == Mailbox.CHECK_INTERVAL_PUSH_HOLD) {
            syncInterval = Mailbox.CHECK_INTERVAL_PUSH;
        }
        return syncInterval;
    }

    /**
     * @return current sync lookback setting from the objects
     */
    private int getSyncLookback() {
        if (mMailbox.mType == Mailbox.TYPE_INBOX) {
            return mAccount.mSyncLookback;
        } else {
            // Here, 0 is valid and means ""use the account default sync window"".
            return mMailbox.mSyncLookback;
        }
    }

    private final OnPreferenceChangeListener mPreferenceChanged = new OnPreferenceChangeListener() {
        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            final ListPreference lp = (ListPreference) preference;
            if (Objects.equal(lp.getValue(), newValue)) {
                return false;
            }
            mNeedsSave = true;
            if (Email.DEBUG) {
                Log.i(Logging.LOG_TAG, ""Setting changed"");
            }
            // In order to set the current entry to the summary, we need to udpate the value
            // manually, rather than letting the framework do that (by returning true).
            lp.setValue((String) newValue);
            updatePreferenceSummary();
            updateObjects();
            return false;
        }
    };

    /**
     * Updates {@link #mAccount}/{@link #mMailbox}, but doesn't save to the database yet.
     */
    private void updateObjects() {
        final int syncInterval = Integer.valueOf(mSyncIntervalPref.getValue());
        final int syncLookback = Integer.valueOf(mSyncLookbackPref.getValue());
        if (Email.DEBUG) {
            Log.i(Logging.LOG_TAG, ""Updating object: "" + syncInterval + "","" + syncLookback);
        }
        if (mMailbox.mType == Mailbox.TYPE_INBOX) {
            mAccount.mSyncInterval = syncInterval;
            mAccount.mSyncLookback = syncLookback;
        } else {
            mMailbox.mSyncInterval = syncInterval;
            mMailbox.mSyncLookback = syncLookback;
        }
    }

    /**
     * Save changes to the database.
     *
     * Note it's called from {@link #onDestroy()}, which is called on the UI thread where we're not
     * allowed to touch the database, so it uses {@link EmailAsyncTask} to do the save on a bg
     * thread. This unfortunately means there's a chance that the app gets killed before the save is
     * finished.
     */
    private void saveToDatabase() {
        if (!mNeedsSave) {
            return;
        }
        Log.i(Logging.LOG_TAG, ""Saving mailbox settings..."");
        enablePreferences(false);

        // Since the activity will be destroyed...
        // Create local references (Although it's really okay to touch members of a destroyed
        // activity...)
        final Account account = mAccount;
        final Mailbox mailbox = mMailbox;
        final Context context = getApplicationContext();

        new EmailAsyncTask<Void, Void, Void> (null /* no cancel */) {
            @Override
            protected Void doInBackground(Void... params) {
                final ContentValues cv = new ContentValues();
                final Uri uri;

                if (mailbox.mType == Mailbox.TYPE_INBOX) {
                    cv.put(AccountColumns.SYNC_INTERVAL, account.mSyncInterval);
                    cv.put(AccountColumns.SYNC_LOOKBACK, account.mSyncLookback);
                    uri = ContentUris.withAppendedId(Account.CONTENT_URI, account.mId);
                } else {
                    cv.put(MailboxColumns.SYNC_INTERVAL, mailbox.mSyncInterval);
                    cv.put(MailboxColumns.SYNC_LOOKBACK, mailbox.mSyncLookback);
                    uri = ContentUris.withAppendedId(Mailbox.CONTENT_URI, mailbox.mId);
                }
                context.getContentResolver().update(uri, cv, null, null);

                Log.i(Logging.LOG_TAG, ""Saved: "" + uri);
                return null;
            }

            @Override
            protected void onSuccess(Void result) {
                // must be called on the ui thread
                RefreshManager.getInstance(context).refreshMessageList(account.mId, mailbox.mId,
                        true);
            }
        }.executeSerial((Void [])null);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == android.R.id.home) {
            onBackPressed();
            return true;
        }
        return super.onOptionsItemSelected(item);
    }
}
",False,267,0,0,11,44,1,8,L6
77,com.android.email.activity.setup.AccountSetupOptions.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.accounts.AccountManagerCallback;
import android.accounts.AccountManagerFuture;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.Spinner;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.activity.ActivityHelper;
import com.android.email.activity.UiUtilities;
import com.android.email.service.EmailServiceUtils;
import com.android.email.service.MailService;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.service.SyncWindow;
import com.android.emailcommon.utility.Utility;

import java.io.IOException;

/**
 * TODO: Cleanup the manipulation of Account.FLAGS_INCOMPLETE and make sure it's never left set.
 */
public class AccountSetupOptions extends AccountSetupActivity implements OnClickListener {

    private Spinner mCheckFrequencyView;
    private Spinner mSyncWindowView;
    private CheckBox mDefaultView;
    private CheckBox mNotifyView;
    private CheckBox mSyncContactsView;
    private CheckBox mSyncCalendarView;
    private CheckBox mSyncEmailView;
    private CheckBox mBackgroundAttachmentsView;
    private View mAccountSyncWindowRow;
    private boolean mDonePressed = false;

    public static final int REQUEST_CODE_ACCEPT_POLICIES = 1;

    /** Default sync window for new EAS accounts */
    private static final int SYNC_WINDOW_EAS_DEFAULT = SyncWindow.SYNC_WINDOW_AUTO;

    public static void actionOptions(Activity fromActivity) {
        fromActivity.startActivity(new Intent(fromActivity, AccountSetupOptions.class));
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(R.layout.account_setup_options);

        mCheckFrequencyView = (Spinner) UiUtilities.getView(this, R.id.account_check_frequency);
        mSyncWindowView = (Spinner) UiUtilities.getView(this, R.id.account_sync_window);
        mDefaultView = (CheckBox) UiUtilities.getView(this, R.id.account_default);
        mNotifyView = (CheckBox) UiUtilities.getView(this, R.id.account_notify);
        mSyncContactsView = (CheckBox) UiUtilities.getView(this, R.id.account_sync_contacts);
        mSyncCalendarView = (CheckBox) UiUtilities.getView(this, R.id.account_sync_calendar);
        mSyncEmailView = (CheckBox) UiUtilities.getView(this, R.id.account_sync_email);
        mSyncEmailView.setChecked(true);
        mBackgroundAttachmentsView = (CheckBox) UiUtilities.getView(this,
                R.id.account_background_attachments);
        mBackgroundAttachmentsView.setChecked(true);
        UiUtilities.getView(this, R.id.previous).setOnClickListener(this);
        UiUtilities.getView(this, R.id.next).setOnClickListener(this);
        mAccountSyncWindowRow = UiUtilities.getView(this, R.id.account_sync_window_row);

        // Generate spinner entries using XML arrays used by the preferences
        int frequencyValuesId;
        int frequencyEntriesId;
        Account account = SetupData.getAccount();
        String protocol = account.mHostAuthRecv.mProtocol;
        boolean eas = HostAuth.SCHEME_EAS.equals(protocol);
        if (eas) {
            frequencyValuesId = R.array.account_settings_check_frequency_values_push;
            frequencyEntriesId = R.array.account_settings_check_frequency_entries_push;
        } else {
            frequencyValuesId = R.array.account_settings_check_frequency_values;
            frequencyEntriesId = R.array.account_settings_check_frequency_entries;
        }
        CharSequence[] frequencyValues = getResources().getTextArray(frequencyValuesId);
        CharSequence[] frequencyEntries = getResources().getTextArray(frequencyEntriesId);

        // Now create the array used by the Spinner
        SpinnerOption[] checkFrequencies = new SpinnerOption[frequencyEntries.length];
        for (int i = 0; i < frequencyEntries.length; i++) {
            checkFrequencies[i] = new SpinnerOption(
                    Integer.valueOf(frequencyValues[i].toString()), frequencyEntries[i].toString());
        }

        ArrayAdapter<SpinnerOption> checkFrequenciesAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, checkFrequencies);
        checkFrequenciesAdapter
                .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mCheckFrequencyView.setAdapter(checkFrequenciesAdapter);

        if (eas) {
            enableEASSyncWindowSpinner();
        }

        // Note:  It is OK to use mAccount.mIsDefault here *only* because the account
        // has not been written to the DB yet.  Ordinarily, call Account.getDefaultAccountId().
        if (account.mIsDefault || SetupData.isDefault()) {
            mDefaultView.setChecked(true);
        }
        mNotifyView.setChecked(
                (account.getFlags() & Account.FLAGS_NOTIFY_NEW_MAIL) != 0);
        SpinnerOption.setSpinnerOptionValue(mCheckFrequencyView, account.getSyncInterval());

        // Setup any additional items to support EAS & EAS flow mode
        if (eas) {
            // ""also sync contacts"" == ""true""
            mSyncContactsView.setVisibility(View.VISIBLE);
            mSyncContactsView.setChecked(true);
            mSyncCalendarView.setVisibility(View.VISIBLE);
            mSyncCalendarView.setChecked(true);
            // Show the associated dividers
            UiUtilities.setVisibilitySafe(this, R.id.account_sync_contacts_divider, View.VISIBLE);
            UiUtilities.setVisibilitySafe(this, R.id.account_sync_calendar_divider, View.VISIBLE);
        }

        // If we are in POP3, hide the ""Background Attachments"" mode
        if (HostAuth.SCHEME_POP3.equals(protocol)) {
            mBackgroundAttachmentsView.setVisibility(View.GONE);
            UiUtilities.setVisibilitySafe(this, R.id.account_background_attachments_divider,
                    View.GONE);
        }

        // If we are just visiting here to fill in details, exit immediately
        if (SetupData.isAutoSetup() ||
                SetupData.getFlowMode() == SetupData.FLOW_MODE_FORCE_CREATE) {
            onDone();
        }
    }

    @Override
    public void finish() {
        // If the account manager initiated the creation, and success was not reported,
        // then we assume that we're giving up (for any reason) - report failure.
        AccountAuthenticatorResponse authenticatorResponse =
            SetupData.getAccountAuthenticatorResponse();
        if (authenticatorResponse != null) {
            authenticatorResponse.onError(AccountManager.ERROR_CODE_CANCELED, ""canceled"");
            SetupData.setAccountAuthenticatorResponse(null);
        }
        super.finish();
    }

    /**
     * Respond to clicks in the ""Next"" or ""Previous"" buttons
     */
    @Override
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.next:
                // Don't allow this more than once (Exchange accounts call an async method
                // before finish()'ing the Activity, which allows this code to potentially be
                // executed multiple times
                if (!mDonePressed) {
                    onDone();
                    mDonePressed = true;
                }
                break;
            case R.id.previous:
                onBackPressed();
                break;
        }
    }

    /**
     * Ths is called when the user clicks the ""done"" button.
     * It collects the data from the UI, updates the setup account record, and commits
     * the account to the database (making it real for the first time.)
     * Finally, we call setupAccountManagerAccount(), which will eventually complete via callback.
     */
    private void onDone() {
        final Account account = SetupData.getAccount();
        if (account.isSaved()) {
            // Disrupting the normal flow could get us here, but if the account is already
            // saved, we've done this work
            return;
        }
        account.setDisplayName(account.getEmailAddress());
        int newFlags = account.getFlags() &
            ~(Account.FLAGS_NOTIFY_NEW_MAIL | Account.FLAGS_BACKGROUND_ATTACHMENTS);
        if (mNotifyView.isChecked()) {
            newFlags |= Account.FLAGS_NOTIFY_NEW_MAIL;
        }
        if (mBackgroundAttachmentsView.isChecked()) {
            newFlags |= Account.FLAGS_BACKGROUND_ATTACHMENTS;
        }
        account.setFlags(newFlags);
        account.setSyncInterval((Integer)((SpinnerOption)mCheckFrequencyView
                .getSelectedItem()).value);
        if (mAccountSyncWindowRow.getVisibility() == View.VISIBLE) {
            int window = (Integer)((SpinnerOption)mSyncWindowView.getSelectedItem()).value;
            account.setSyncLookback(window);
        }
        account.setDefaultAccount(mDefaultView.isChecked());

        if (account.mHostAuthRecv == null) {
            throw new IllegalStateException(""in AccountSetupOptions with null mHostAuthRecv"");
        }

        // Finish setting up the account, and commit it to the database
        // Set the incomplete flag here to avoid reconciliation issues in ExchangeService
        account.mFlags |= Account.FLAGS_INCOMPLETE;
        boolean calendar = false;
        boolean contacts = false;
        boolean email = mSyncEmailView.isChecked();
        if (account.mHostAuthRecv.mProtocol.equals(""eas"")) {
            if (SetupData.getPolicy() != null) {
                account.mFlags |= Account.FLAGS_SECURITY_HOLD;
                account.mPolicy = SetupData.getPolicy();
            }
            // Get flags for contacts/calendar sync
            contacts = mSyncContactsView.isChecked();
            calendar = mSyncCalendarView.isChecked();
        }

        // Finally, write the completed account (for the first time) and then
        // install it into the Account manager as well.  These are done off-thread.
        // The account manager will report back via the callback, which will take us to
        // the next operations.
        final boolean email2 = email;
        final boolean calendar2 = calendar;
        final boolean contacts2 = contacts;
        Utility.runAsync(new Runnable() {
            @Override
            public void run() {
                Context context = AccountSetupOptions.this;
                AccountSettingsUtils.commitSettings(context, account);
                MailService.setupAccountManagerAccount(context, account,
                        email2, calendar2, contacts2, mAccountManagerCallback);
            }
        });
    }

    /**
     * This is called at the completion of MailService.setupAccountManagerAccount()
     */
    AccountManagerCallback<Bundle> mAccountManagerCallback = new AccountManagerCallback<Bundle>() {
        public void run(AccountManagerFuture<Bundle> future) {
            try {
                Bundle bundle = future.getResult();
                bundle.keySet();
                AccountSetupOptions.this.runOnUiThread(new Runnable() {
                    public void run() {
                        optionsComplete();
                    }
                });
                return;
            } catch (OperationCanceledException e) {
                Log.d(Logging.LOG_TAG, ""addAccount was canceled"");
            } catch (IOException e) {
                Log.d(Logging.LOG_TAG, ""addAccount failed: "" + e);
            } catch (AuthenticatorException e) {
                Log.d(Logging.LOG_TAG, ""addAccount failed: "" + e);
            }
            showErrorDialog(R.string.account_setup_failed_dlg_auth_message,
                    R.string.system_account_create_failed);
        }
    };

    /**
     * This is called if MailService.setupAccountManagerAccount() fails for some reason
     */
    private void showErrorDialog(final int msgResId, final Object... args) {
        runOnUiThread(new Runnable() {
            public void run() {
                new AlertDialog.Builder(AccountSetupOptions.this)
                        .setIconAttribute(android.R.attr.alertDialogIcon)
                        .setTitle(getString(R.string.account_setup_failed_dlg_title))
                        .setMessage(getString(msgResId, args))
                        .setCancelable(true)
                        .setPositiveButton(
                                getString(R.string.account_setup_failed_dlg_edit_details_action),
                                new DialogInterface.OnClickListener() {
                                    public void onClick(DialogInterface dialog, int which) {
                                       finish();
                                    }
                                })
                        .show();
            }
        });
    }

    /**
     * This is called after the account manager creates the new account.
     */
    private void optionsComplete() {
        // If the account manager initiated the creation, report success at this point
        AccountAuthenticatorResponse authenticatorResponse =
            SetupData.getAccountAuthenticatorResponse();
        if (authenticatorResponse != null) {
            authenticatorResponse.onResult(null);
            SetupData.setAccountAuthenticatorResponse(null);
        }

        // Now that AccountManager account creation is complete, clear the INCOMPLETE flag
        Account account = SetupData.getAccount();
        account.mFlags &= ~Account.FLAGS_INCOMPLETE;
        AccountSettingsUtils.commitSettings(AccountSetupOptions.this, account);

        // If we've got policies for this account, ask the user to accept.
        if ((account.mFlags & Account.FLAGS_SECURITY_HOLD) != 0) {
            Intent intent = AccountSecurity.actionUpdateSecurityIntent(this, account.mId, false);
            startActivityForResult(intent, AccountSetupOptions.REQUEST_CODE_ACCEPT_POLICIES);
            return;
        }
        saveAccountAndFinish();
    }

    /**
     * This is called after the AccountSecurity activity completes.
     */
    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        saveAccountAndFinish();
    }

    /**
     * These are the final cleanup steps when creating an account:
     *  Clear incomplete & security hold flags
     *  Update account in DB
     *  Enable email services
     *  Enable exchange services
     *  Move to final setup screen
     */
    private void saveAccountAndFinish() {
        Utility.runAsync(new Runnable() {
            @Override
            public void run() {
                AccountSetupOptions context = AccountSetupOptions.this;
                // Clear the security hold flag now
                Account account = SetupData.getAccount();
                account.mFlags &= ~Account.FLAGS_SECURITY_HOLD;
                AccountSettingsUtils.commitSettings(context, account);
                // Start up services based on new account(s)
                Email.setServicesEnabledSync(context);
                EmailServiceUtils.startExchangeService(context);
                // Move to final setup screen
                AccountSetupNames.actionSetNames(context);
                finish();
            }
        });
    }

    /**
     * Enable an additional spinner using the arrays normally handled by preferences
     */
    private void enableEASSyncWindowSpinner() {
        // Show everything
        mAccountSyncWindowRow.setVisibility(View.VISIBLE);

        // Generate spinner entries using XML arrays used by the preferences
        CharSequence[] windowValues = getResources().getTextArray(
                R.array.account_settings_mail_window_values);
        CharSequence[] windowEntries = getResources().getTextArray(
                R.array.account_settings_mail_window_entries);

        // Now create the array used by the Spinner
        SpinnerOption[] windowOptions = new SpinnerOption[windowEntries.length];
        int defaultIndex = -1;
        for (int i = 0; i < windowEntries.length; i++) {
            final int value = Integer.valueOf(windowValues[i].toString());
            windowOptions[i] = new SpinnerOption(value, windowEntries[i].toString());
            if (value == SYNC_WINDOW_EAS_DEFAULT) {
                defaultIndex = i;
            }
        }

        ArrayAdapter<SpinnerOption> windowOptionsAdapter = new ArrayAdapter<SpinnerOption>(this,
                android.R.layout.simple_spinner_item, windowOptions);
        windowOptionsAdapter
                .setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSyncWindowView.setAdapter(windowOptionsAdapter);

        SpinnerOption.setSpinnerOptionValue(mSyncWindowView,
                SetupData.getAccount().getSyncLookback());
        if (defaultIndex >= 0) {
            mSyncWindowView.setSelection(defaultIndex);
        }
    }
}
",True,268,1,1,11,43,4,17,L6
78,com.android.email.activity.setup.AccountSetupOutgoingFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.Spinner;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.activity.UiUtilities;
import com.android.email.provider.AccountBackupRestore;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.Utility;

/**
 * Provides UI for SMTP account settings (for IMAP/POP accounts).
 *
 * This fragment is used by AccountSetupOutgoing (for creating accounts) and by AccountSettingsXL
 * (for editing existing accounts).
 */
public class AccountSetupOutgoingFragment extends AccountServerBaseFragment
        implements OnCheckedChangeListener {

    private final static String STATE_KEY_LOADED = ""AccountSetupOutgoingFragment.loaded"";

    private static final int SMTP_PORT_NORMAL = 587;
    private static final int SMTP_PORT_SSL    = 465;

    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private EditText mPortView;
    private CheckBox mRequireLoginView;
    private Spinner mSecurityTypeView;

    // Support for lifecycle
    private boolean mStarted;
    private boolean mLoaded;

    /**
     * Called to do initial creation of a fragment.  This is called after
     * {@link #onAttach(Activity)} and before {@link #onActivityCreated(Bundle)}.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onCreate"");
        }
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            mLoaded = savedInstanceState.getBoolean(STATE_KEY_LOADED, false);
        }
        mBaseScheme = HostAuth.SCHEME_SMTP;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onCreateView"");
        }
        int layoutId = mSettingsMode
                ? R.layout.account_settings_outgoing_fragment
                : R.layout.account_setup_outgoing_fragment;

        View view = inflater.inflate(layoutId, container, false);
        Context context = getActivity();

        mUsernameView = (EditText) UiUtilities.getView(view, R.id.account_username);
        mPasswordView = (EditText) UiUtilities.getView(view, R.id.account_password);
        mServerView = (EditText) UiUtilities.getView(view, R.id.account_server);
        mPortView = (EditText) UiUtilities.getView(view, R.id.account_port);
        mRequireLoginView = (CheckBox) UiUtilities.getView(view, R.id.account_require_login);
        mSecurityTypeView = (Spinner) UiUtilities.getView(view, R.id.account_security_type);
        mRequireLoginView.setOnCheckedChangeListener(this);

        // Note:  Strings are shared with AccountSetupIncomingFragment
        SpinnerOption securityTypes[] = {
            new SpinnerOption(HostAuth.FLAG_NONE, context.getString(
                    R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(HostAuth.FLAG_SSL, context.getString(
                    R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(HostAuth.FLAG_SSL | HostAuth.FLAG_TRUST_ALL, context.getString(
                    R.string.account_setup_incoming_security_ssl_trust_certificates_label)),
            new SpinnerOption(HostAuth.FLAG_TLS, context.getString(
                    R.string.account_setup_incoming_security_tls_label)),
            new SpinnerOption(HostAuth.FLAG_TLS | HostAuth.FLAG_TRUST_ALL, context.getString(
                    R.string.account_setup_incoming_security_tls_trust_certificates_label)),
        };

        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(context,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        // Updates the port when the user changes the security type. This allows
        // us to show a reasonable default which the user can change.
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> arg0) { }
        });

        // Calls validateFields() which enables or disables the Next button
        TextWatcher validationTextWatcher = new TextWatcher() {
            public void afterTextChanged(Editable s) {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after) { }
            public void onTextChanged(CharSequence s, int start, int before, int count) { }
        };
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        // Only allow digits in the port field.
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        // Additional setup only used while in ""settings"" mode
        onCreateViewSettingsMode(view);

        return view;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onActivityCreated"");
        }
        super.onActivityCreated(savedInstanceState);
    }

    /**
     * Called when the Fragment is visible to the user.
     */
    @Override
    public void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onStart"");
        }
        super.onStart();
        mStarted = true;
        loadSettings();
    }

    /**
     * Called when the fragment is visible to the user and actively running.
     */
    @Override
    public void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onResume"");
        }
        super.onResume();
        validateFields();
    }

    @Override
    public void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onPause"");
        }
        super.onPause();
    }

    /**
     * Called when the Fragment is no longer started.
     */
    @Override
    public void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onStop"");
        }
        super.onStop();
        mStarted = false;
    }

    /**
     * Called when the fragment is no longer in use.
     */
    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onDestroy"");
        }
        super.onDestroy();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupOutgoingFragment onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);

        outState.putBoolean(STATE_KEY_LOADED, mLoaded);
    }

    /**
     * Activity provides callbacks here.  This also triggers loading and setting up the UX
     */
    @Override
    public void setCallback(Callback callback) {
        super.setCallback(callback);
        if (mStarted) {
            loadSettings();
        }
    }

    /**
     * Load the current settings into the UI
     */
    private void loadSettings() {
        if (mLoaded) return;

        HostAuth sendAuth = SetupData.getAccount().getOrCreateHostAuthSend(mContext);
        if ((sendAuth.mFlags & HostAuth.FLAG_AUTHENTICATE) != 0) {
            String username = sendAuth.mLogin;
            if (username != null) {
                mUsernameView.setText(username);
                mRequireLoginView.setChecked(true);
            }

            String password = sendAuth.mPassword;
            if (password != null) {
                mPasswordView.setText(password);
            }
        }

        int flags = sendAuth.mFlags & ~HostAuth.FLAG_AUTHENTICATE;
        SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, flags);

        String hostname = sendAuth.mAddress;
        if (hostname != null) {
            mServerView.setText(hostname);
        }

        int port = sendAuth.mPort;
        if (port != -1) {
            mPortView.setText(Integer.toString(port));
        } else {
            updatePortFromSecurityType();
        }

        mLoadedSendAuth = sendAuth;
        mLoaded = true;
        validateFields();
    }

    /**
     * Preflight the values in the fields and decide if it makes sense to enable the ""next"" button
     */
    private void validateFields() {
        if (!mLoaded) return;
        boolean enabled =
            Utility.isServerNameValid(mServerView) && Utility.isPortFieldValid(mPortView);

        if (enabled && mRequireLoginView.isChecked()) {
            enabled = (Utility.isTextViewNotEmpty(mUsernameView)
                    && Utility.isTextViewNotEmpty(mPasswordView));
        }
        enableNextButton(enabled);
        // Warn (but don't prevent) if password has leading/trailing spaces
        AccountSettingsUtils.checkPasswordSpaces(mContext, mPasswordView);
   }

    /**
     * implements OnCheckedChangeListener
     */
    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        final int visibility = isChecked ? View.VISIBLE : View.GONE;
        UiUtilities.setVisibilitySafe(getView(), R.id.account_require_login_settings, visibility);
        UiUtilities.setVisibilitySafe(getView(), R.id.account_require_login_settings_2, visibility);
        validateFields();
    }

    private int getPortFromSecurityType() {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        int port = (securityType & HostAuth.FLAG_SSL) != 0 ? SMTP_PORT_SSL : SMTP_PORT_NORMAL;
        return port;
    }

    private void updatePortFromSecurityType() {
        int port = getPortFromSecurityType();
        mPortView.setText(Integer.toString(port));
    }

    /**
     * Entry point from Activity after editing settings and verifying them.  Must be FLOW_MODE_EDIT.
     * Blocking - do not call from UI Thread.
     */
    @Override
    public void saveSettingsAfterEdit() {
        Account account = SetupData.getAccount();
        account.mHostAuthSend.update(mContext, account.mHostAuthSend.toContentValues());
        // Update the backup (side copy) of the accounts
        AccountBackupRestore.backup(mContext);
    }

    /**
     * Entry point from Activity after entering new settings and verifying them.  For setup mode.
     */
    @Override
    public void saveSettingsAfterSetup() {
    }

    /**
     * Entry point from Activity, when ""next"" button is clicked
     */
    @Override
    public void onNext() {
        Account account = SetupData.getAccount();
        HostAuth sendAuth = account.getOrCreateHostAuthSend(mContext);

        if (mRequireLoginView.isChecked()) {
            String userName = mUsernameView.getText().toString().trim();
            String userPassword = mPasswordView.getText().toString();
            sendAuth.setLogin(userName, userPassword);
        } else {
            sendAuth.setLogin(null, null);
        }

        String serverAddress = mServerView.getText().toString().trim();
        int serverPort;
        try {
            serverPort = Integer.parseInt(mPortView.getText().toString().trim());
        } catch (NumberFormatException e) {
            serverPort = getPortFromSecurityType();
            Log.d(Logging.LOG_TAG, ""Non-integer server port; using '"" + serverPort + ""'"");
        }
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        sendAuth.setConnection(mBaseScheme, serverAddress, serverPort, securityType);
        sendAuth.mDomain = null;

        mCallback.onProceedNext(SetupData.CHECK_OUTGOING, this);
    }
}
",True,268,1,1,11,49,2,12,L6
79,com.android.email.activity.setup.SetupData.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Policy;

import android.accounts.AccountAuthenticatorResponse;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;

public class SetupData implements Parcelable {
    // The ""extra"" name for the Bundle saved with SetupData
    public static final String EXTRA_SETUP_DATA = ""com.android.email.setupdata"";

    // NORMAL is the standard entry from the Email app; EAS and POP_IMAP are used when entering via
    // Settings -> Accounts
    public static final int FLOW_MODE_UNSPECIFIED = -1;
    public static final int FLOW_MODE_NORMAL = 0;
    public static final int FLOW_MODE_ACCOUNT_MANAGER_EAS = 1;
    public static final int FLOW_MODE_ACCOUNT_MANAGER_POP_IMAP = 2;
    public static final int FLOW_MODE_EDIT = 3;
    public static final int FLOW_MODE_FORCE_CREATE = 4;
    // The following two modes are used to ""pop the stack"" and return from the setup flow.  We
    // either return to the caller (if we're in an account type flow) or go to the message list
    public static final int FLOW_MODE_RETURN_TO_CALLER = 5;
    public static final int FLOW_MODE_RETURN_TO_MESSAGE_LIST = 6;

    // For debug logging
    private static final String[] FLOW_MODES = {""normal"", ""eas"", ""pop/imap"", ""edit"", ""force"",
            ""rtc"", ""rtl""};

    // Mode bits for AccountSetupCheckSettings, indicating the type of check requested
    public static final int CHECK_INCOMING = 1;
    public static final int CHECK_OUTGOING = 2;
    public static final int CHECK_AUTODISCOVER = 4;

    // All access will be through getters/setters
    private int mFlowMode = FLOW_MODE_NORMAL;
    private Account mAccount;
    private String mUsername;
    private String mPassword;
    private int mCheckSettingsMode = 0;
    private boolean mAllowAutodiscover = true;
    private Policy mPolicy;
    private boolean mAutoSetup = false;
    private boolean mDefault = false;
    private AccountAuthenticatorResponse mAccountAuthenticatorResponse = null;

    // We only have one instance of SetupData; if/when the process is destroyed, this data will be
    // saved in the savedInstanceState Bundle
    private static SetupData INSTANCE = null;

    public static synchronized SetupData getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new SetupData();
        }
        return INSTANCE;
    }

    // Don't allow instantiation outside of this class
    private SetupData() {
    }

    static public int getFlowMode() {
        return getInstance().mFlowMode;
    }

    static public void setFlowMode(int mFlowMode) {
        getInstance().mFlowMode = mFlowMode;
    }

    static public Account getAccount() {
        return getInstance().mAccount;
    }

    static public void setAccount(Account mAccount) {
        getInstance().mAccount = mAccount;
    }

    static public String getUsername() {
        return getInstance().mUsername;
    }

    static public void setUsername(String mUsername) {
        getInstance().mUsername = mUsername;
    }

    static public String getPassword() {
        return getInstance().mPassword;
    }

    static public void setPassword(String mPassword) {
        getInstance().mPassword = mPassword;
    }

    static public void setCheckSettingsMode(int mCheckSettingsMode) {
        getInstance().mCheckSettingsMode = mCheckSettingsMode;
    }

    static public boolean isCheckIncoming() {
        return (getInstance().mCheckSettingsMode & CHECK_INCOMING) != 0;
    }

    static public boolean isCheckOutgoing() {
        return (getInstance().mCheckSettingsMode & CHECK_OUTGOING) != 0;
    }
    static public boolean isCheckAutodiscover() {
        return (getInstance().mCheckSettingsMode & CHECK_AUTODISCOVER) != 0;
    }
    static public boolean isAllowAutodiscover() {
        return getInstance().mAllowAutodiscover;
    }

    static public void setAllowAutodiscover(boolean mAllowAutodiscover) {
        getInstance().mAllowAutodiscover = mAllowAutodiscover;
    }

    static public Policy getPolicy() {
        return getInstance().mPolicy;
    }

    static public void setPolicy(Policy policy) {
        SetupData data = getInstance();
        data.mPolicy = policy;
        data.mAccount.mPolicy = policy;
    }

    static public boolean isAutoSetup() {
        return getInstance().mAutoSetup;
    }

    static public void setAutoSetup(boolean autoSetup) {
        getInstance().mAutoSetup = autoSetup;
    }

    static public boolean isDefault() {
        return getInstance().mDefault;
    }

    static public void setDefault(boolean _default) {
        getInstance().mDefault = _default;
    }

    static public AccountAuthenticatorResponse getAccountAuthenticatorResponse() {
        return getInstance().mAccountAuthenticatorResponse;
    }

    static public void setAccountAuthenticatorResponse(AccountAuthenticatorResponse response) {
        getInstance().mAccountAuthenticatorResponse = response;
    }

    public static void init(int flowMode) {
        SetupData data = getInstance();
        data.commonInit();
        data.mFlowMode = flowMode;
    }

    public static void init(int flowMode, Account account) {
        SetupData data = getInstance();
        data.commonInit();
        data.mFlowMode = flowMode;
        data.mAccount = account;
    }

    void commonInit() {
        mPolicy = null;
        mAutoSetup = false;
        mAllowAutodiscover = true;
        mCheckSettingsMode = 0;
        mAccount = new Account();
        mDefault = false;
        mUsername = null;
        mPassword = null;
        mAccountAuthenticatorResponse = null;
    }

    // Parcelable methods
    public int describeContents() {
        return 0;
    }

    public static final Parcelable.Creator<SetupData> CREATOR =
            new Parcelable.Creator<SetupData>() {
        public SetupData createFromParcel(Parcel in) {
            return new SetupData(in);
        }

        public SetupData[] newArray(int size) {
            return new SetupData[size];
        }
    };

    public void writeToParcel(Parcel dest, int flags) {
        dest.writeInt(mFlowMode);
        dest.writeParcelable(mAccount, 0);
        dest.writeString(mUsername);
        dest.writeString(mPassword);
        dest.writeInt(mCheckSettingsMode);
        dest.writeInt(mAllowAutodiscover ? 1 : 0);
        dest.writeParcelable(mPolicy, 0);
        dest.writeInt(mAutoSetup ? 1 : 0);
        dest.writeInt(mDefault ? 1 : 0);
        dest.writeParcelable(mAccountAuthenticatorResponse, 0);
    }

    public SetupData(Parcel in) {
        ClassLoader loader = getClass().getClassLoader();
        mFlowMode = in.readInt();
        mAccount = in.readParcelable(loader);
        mUsername = in.readString();
        mPassword = in.readString();
        mCheckSettingsMode = in.readInt();
        mAllowAutodiscover = in.readInt() == 1;
        mPolicy = in.readParcelable(loader);
        mAutoSetup = in.readInt() == 1;
        mDefault = in.readInt() == 1;
        mAccountAuthenticatorResponse = in.readParcelable(loader);
    }

    // Save/restore our SetupData (used in AccountSetupActivity)
    static public void save(Bundle bundle) {
        bundle.putParcelable(EXTRA_SETUP_DATA, getInstance());
    }

    static public synchronized SetupData restore(Bundle bundle) {
        if (bundle != null && bundle.containsKey(EXTRA_SETUP_DATA)) {
            INSTANCE = bundle.getParcelable(EXTRA_SETUP_DATA);
            return INSTANCE;
        } else {
            return getInstance();
        }
    }

    public static String debugString() {
        StringBuilder sb = new StringBuilder(""SetupData"");
        SetupData data = getInstance();
        sb.append("":flow="" + FLOW_MODES[data.mFlowMode]);
        sb.append("":acct="" + (data.mAccount == null ? ""none"" : data.mAccount.mId));
        if (data.mUsername != null) {
            sb.append("":user="" + data.mUsername);
        }
        if (data.mPassword != null) {
            sb.append("":pass="" + data.mPassword);
        }
        sb.append("":a/d="" + data.mAllowAutodiscover);
        sb.append("":auto="" + data.mAutoSetup);
        sb.append("":default="" + data.mDefault);
        sb.append("":check="");
        if (SetupData.isCheckIncoming()) sb.append(""in+"");
        if (SetupData.isCheckOutgoing()) sb.append(""out+"");
        if (SetupData.isCheckAutodiscover()) sb.append(""a/d"");
        sb.append("":policy="" + (data.mPolicy == null ? ""none"" : ""exists""));
        return sb.toString();
    }
}
",False,160,8,38,4,5,19,3,L6
80,com.android.email.activity.setup.AccountSetupActivity.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;

/**
 * Superclass of all of the account setup activities; ensures that SetupData state is saved/restored
 * automatically as required
 */
public class AccountSetupActivity extends Activity {
    private static final boolean DEBUG_SETUP_FLOWS = false;  // Don't check in set to true

    @Override
    public void onCreate(Bundle savedInstanceState) {
        SetupData.restore(savedInstanceState);
        super.onCreate(savedInstanceState);
        if (DEBUG_SETUP_FLOWS) {
            Log.d(getClass().getName(), SetupData.debugString());
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        SetupData.save(outState);
    }
}
",True,160,9,39,5,5,6,1,L6
81,com.android.email.activity.setup.EditQuickResponseDialog.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package com.android.email.activity.setup;

import com.android.email.R;
import com.android.emailcommon.provider.QuickResponse;
import com.android.emailcommon.provider.EmailContent.QuickResponseColumns;
import com.android.emailcommon.utility.EmailAsyncTask;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.WindowManager;
import android.widget.EditText;

/**
 * Dialog to edit the text of a given or new quick response
 */
public class EditQuickResponseDialog extends DialogFragment
        implements DialogInterface.OnClickListener, TextWatcher {
    private EditText mQuickResponseEditText;
    private QuickResponse mQuickResponse;
    private AlertDialog mDialog;

    private static final String QUICK_RESPONSE_EDITED_STRING = ""quick_response_edited_string"";
    private static final String QUICK_RESPONSE = ""quick_response"";

    /**
     * Creates a new dialog to edit an existing QuickResponse or create a new
     * one.
     *
     * @param quickResponse - The QuickResponse fwhich the user is editing;
     *        null if user is creating a new QuickResponse.
     * @param accountId - The accountId for the account which holds this QuickResponse
     */
    public static EditQuickResponseDialog newInstance(
            QuickResponse quickResponse, long accountId) {
        final EditQuickResponseDialog dialog = new EditQuickResponseDialog();

        Bundle args = new Bundle();
        args.putLong(""accountId"", accountId);
        if (quickResponse != null) {
            args.putParcelable(QUICK_RESPONSE, quickResponse);
        }

        dialog.setArguments(args);
        return dialog;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        final Context context = getActivity();
        mQuickResponse = (QuickResponse) getArguments().getParcelable(QUICK_RESPONSE);

        mQuickResponseEditText = new EditText(context);
        if (savedInstanceState != null) {
            String quickResponseSavedString =
                    savedInstanceState.getString(QUICK_RESPONSE_EDITED_STRING);
            if (quickResponseSavedString != null) {
                mQuickResponseEditText.setText(quickResponseSavedString);
            }
        } else if (mQuickResponse != null) {
            mQuickResponseEditText.setText(mQuickResponse.toString());
        }
        mQuickResponseEditText.setSelection(mQuickResponseEditText.length());
        mQuickResponseEditText.addTextChangedListener(this);

        final AlertDialog.Builder b = new AlertDialog.Builder(context);
        b.setTitle(getResources().getString(R.string.edit_quick_response_dialog))
                .setView(mQuickResponseEditText)
                .setNegativeButton(R.string.cancel_action, this)
                .setPositiveButton(R.string.save_action, this);
        mDialog = b.create();
        return mDialog;
    }

    @Override
    public void onResume() {
        super.onResume();
        mDialog.getWindow()
                .setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);
        if (mQuickResponseEditText.length() == 0) {
            mDialog.getButton(AlertDialog.BUTTON_POSITIVE).setEnabled(false);
        }
    }

    // implements TextWatcher
    @Override
    public void afterTextChanged(Editable s) {
            mDialog.getButton(AlertDialog.BUTTON_POSITIVE).setEnabled(s.length() > 0);
    }

    // implements TextWatcher
    @Override
    public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

    // implements TextWatcher
    @Override
    public void onTextChanged(CharSequence s, int start, int before, int count) {}

    // Saves contents during orientation change
    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putString(
                QUICK_RESPONSE_EDITED_STRING, mQuickResponseEditText.getText().toString());
    }

    /**
     * Implements DialogInterface.OnClickListener
     */
    @Override
    public void onClick(DialogInterface dialog, int which) {
        switch (which) {
            case DialogInterface.BUTTON_NEGATIVE:
                dialog.cancel();
                break;
            case DialogInterface.BUTTON_POSITIVE:
                final long accountId = getArguments().getLong(""accountId"");
                final String text = mQuickResponseEditText.getText().toString();
                final Context context = getActivity();
                if (mQuickResponse == null) {
                    mQuickResponse = new QuickResponse(accountId, text);
                }

                // Insert the new QuickResponse into the database. Content watchers used to
                // update the ListView of QuickResponses upon insertion.
                EmailAsyncTask.runAsyncParallel(new Runnable() {
                    @Override
                    public void run() {
                        if (!mQuickResponse.isSaved()) {
                            mQuickResponse.save(context);
                        } else {
                            ContentValues values = new ContentValues();
                            values.put(QuickResponseColumns.TEXT, text);
                            mQuickResponse.update(context, values);
                        }
                    }

                });
                break;
        }
    }
}
",False,160,9,62,5,5,1,3,L6
82,com.android.email.activity.setup.GeneralPreferences.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.os.Bundle;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.PreferenceCategory;
import android.preference.Preference.OnPreferenceChangeListener;
import android.preference.PreferenceFragment;
import android.preference.PreferenceScreen;
import android.widget.Toast;

import com.android.email.Preferences;
import com.android.email.R;
import com.android.email.activity.UiUtilities;

public class GeneralPreferences extends PreferenceFragment implements OnPreferenceChangeListener  {

    private static final String PREFERENCE_CATEGORY_KEY = ""category_general_preferences"";

    private static final String PREFERENCE_KEY_AUTO_ADVANCE = ""auto_advance"";
    private static final String PREFERENCE_KEY_TEXT_ZOOM = ""text_zoom"";
    private static final String PREFERENCE_KEY_REPLY_ALL = Preferences.REPLY_ALL;
    private static final String PREFERENCE_KEY_CLEAR_TRUSTED_SENDERS = ""clear_trusted_senders"";

    private Preferences mPreferences;
    private ListPreference mAutoAdvance;
    private ListPreference mTextZoom;

    CharSequence[] mSizeSummaries;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        getPreferenceManager().setSharedPreferencesName(Preferences.PREFERENCES_FILE);

        // Load the preferences from an XML resource
        addPreferencesFromResource(R.xml.general_preferences);

        if (UiUtilities.useTwoPane(getActivity())) {
            // ""Reply All"" should only be shown on phones
            PreferenceCategory pc = (PreferenceCategory) findPreference(PREFERENCE_CATEGORY_KEY);
            pc.removePreference(findPreference(PREFERENCE_KEY_REPLY_ALL));
        }
    }

    @Override
    public void onResume() {
        loadSettings();
        super.onResume();
    }

    @Override
    public boolean onPreferenceChange(Preference preference, Object newValue) {
        String key = preference.getKey();

        if (PREFERENCE_KEY_AUTO_ADVANCE.equals(key)) {
            mPreferences.setAutoAdvanceDirection(mAutoAdvance.findIndexOfValue((String) newValue));
            return true;
        } else if (PREFERENCE_KEY_TEXT_ZOOM.equals(key)) {
            mPreferences.setTextZoom(mTextZoom.findIndexOfValue((String) newValue));
            reloadDynamicSummaries();
            return true;
        }
        return false;
    }

    @Override
    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
        if (getActivity() == null) {
            // Guard against monkeys.
            return false;
        }

        String key = preference.getKey();
        if (key.equals(PREFERENCE_KEY_CLEAR_TRUSTED_SENDERS)) {
            mPreferences.clearTrustedSenders();
            Toast.makeText(
                    getActivity(), R.string.trusted_senders_cleared, Toast.LENGTH_SHORT).show();
            return true;
        }

        return false;
    }

    private void loadSettings() {
        mPreferences = Preferences.getPreferences(getActivity());
        mAutoAdvance = (ListPreference) findPreference(PREFERENCE_KEY_AUTO_ADVANCE);
        mAutoAdvance.setValueIndex(mPreferences.getAutoAdvanceDirection());
        mAutoAdvance.setOnPreferenceChangeListener(this);

        mTextZoom = (ListPreference) findPreference(PREFERENCE_KEY_TEXT_ZOOM);
        mTextZoom.setValueIndex(mPreferences.getTextZoom());
        mTextZoom.setOnPreferenceChangeListener(this);

        reloadDynamicSummaries();
    }

    /**
     * Reload any preference summaries that are updated dynamically
     */
    private void reloadDynamicSummaries() {
        int textZoomIndex = mPreferences.getTextZoom();
        // Update summary - but only load the array once
        if (mSizeSummaries == null) {
            mSizeSummaries = getActivity().getResources()
                    .getTextArray(R.array.general_preference_text_zoom_summary_array);
        }
        CharSequence summary = null;
        if (textZoomIndex >= 0 && textZoomIndex < mSizeSummaries.length) {
            summary = mSizeSummaries[textZoomIndex];
        }
        mTextZoom.setSummary(summary);
    }
}
",False,162,8,49,5,6,1,2,L6
83,com.android.email.activity.setup.AccountSecurity.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.FragmentManager;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.os.Bundle;
import android.util.Log;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.SecurityPolicy;
import com.android.email.activity.ActivityHelper;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.Utility;

/**
 * Psuedo-activity (no UI) to bootstrap the user up to a higher desired security level.  This
 * bootstrap requires the following steps.
 *
 * 1.  Confirm the account of interest has any security policies defined - exit early if not
 * 2.  If not actively administrating the device, ask Device Policy Manager to start that
 * 3.  When we are actively administrating, check current policies and see if they're sufficient
 * 4.  If not, set policies
 * 5.  If necessary, request for user to update device password
 * 6.  If necessary, request for user to activate device encryption
 */
public class AccountSecurity extends Activity {
    private static final String TAG = ""Email/AccountSecurity"";

    private static final String EXTRA_ACCOUNT_ID = ""ACCOUNT_ID"";
    private static final String EXTRA_SHOW_DIALOG = ""SHOW_DIALOG"";
    private static final String EXTRA_PASSWORD_EXPIRING = ""EXPIRING"";
    private static final String EXTRA_PASSWORD_EXPIRED = ""EXPIRED"";

    private static final int REQUEST_ENABLE = 1;
    private static final int REQUEST_PASSWORD = 2;
    private static final int REQUEST_ENCRYPTION = 3;

    private boolean mTriedAddAdministrator = false;
    private boolean mTriedSetPassword = false;
    private boolean mTriedSetEncryption = false;
    private Account mAccount;

    /**
     * Used for generating intent for this activity (which is intended to be launched
     * from a notification.)
     *
     * @param context Calling context for building the intent
     * @param accountId The account of interest
     * @param showDialog If true, a simple warning dialog will be shown before kicking off
     * the necessary system settings.  Should be true anywhere the context of the security settings
     * is not clear (e.g. any time after the account has been set up).
     * @return an Intent which can be used to view that account
     */
    public static Intent actionUpdateSecurityIntent(Context context, long accountId,
            boolean showDialog) {
        Intent intent = new Intent(context, AccountSecurity.class);
        intent.putExtra(EXTRA_ACCOUNT_ID, accountId);
        intent.putExtra(EXTRA_SHOW_DIALOG, showDialog);
        return intent;
    }

    /**
     * Used for generating intent for this activity (which is intended to be launched
     * from a notification.)  This is a special mode of this activity which exists only
     * to give the user a dialog (for context) about a device pin/password expiration event.
     */
    public static Intent actionDevicePasswordExpirationIntent(Context context, long accountId,
            boolean expired) {
        Intent intent = new Intent(context, AccountSecurity.class);
        intent.putExtra(EXTRA_ACCOUNT_ID, accountId);
        intent.putExtra(expired ? EXTRA_PASSWORD_EXPIRED : EXTRA_PASSWORD_EXPIRING, true);
        return intent;
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);

        Intent i = getIntent();
        final long accountId = i.getLongExtra(EXTRA_ACCOUNT_ID, -1);
        final boolean showDialog = i.getBooleanExtra(EXTRA_SHOW_DIALOG, false);
        final boolean passwordExpiring = i.getBooleanExtra(EXTRA_PASSWORD_EXPIRING, false);
        final boolean passwordExpired = i.getBooleanExtra(EXTRA_PASSWORD_EXPIRED, false);
        SecurityPolicy security = SecurityPolicy.getInstance(this);
        security.clearNotification();
        if (accountId == -1) {
            finish();
            return;
        }

        mAccount = Account.restoreAccountWithId(AccountSecurity.this, accountId);
        if (mAccount == null) {
            finish();
            return;
        }
        // Special handling for password expiration events
        if (passwordExpiring || passwordExpired) {
            FragmentManager fm = getFragmentManager();
            if (fm.findFragmentByTag(""password_expiration"") == null) {
                PasswordExpirationDialog dialog =
                    PasswordExpirationDialog.newInstance(mAccount.getDisplayName(),
                            passwordExpired);
                dialog.show(fm, ""password_expiration"");
            }
            return;
        }
        // Otherwise, handle normal security settings flow
        if (mAccount.mPolicyKey != 0) {
            // This account wants to control security
            if (showDialog) {
                // Show dialog first, unless already showing (e.g. after rotation)
                FragmentManager fm = getFragmentManager();
                if (fm.findFragmentByTag(""security_needed"") == null) {
                    SecurityNeededDialog dialog =
                        SecurityNeededDialog.newInstance(mAccount.getDisplayName());
                    dialog.show(fm, ""security_needed"");
                }
            } else {
                // Go directly to security settings
                tryAdvanceSecurity(mAccount);
            }
            return;
        }
        finish();
    }

    /**
     * After any of the activities return, try to advance to the ""next step""
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        tryAdvanceSecurity(mAccount);
        super.onActivityResult(requestCode, resultCode, data);
    }

    /**
     * Walk the user through the required steps to become an active administrator and with
     * the requisite security settings for the given account.
     *
     * These steps will be repeated each time we return from a given attempt (e.g. asking the
     * user to choose a device pin/password).  In a typical activation, we may repeat these
     * steps a few times.  It may go as far as step 5 (password) or step 6 (encryption), but it
     * will terminate when step 2 (isActive()) succeeds.
     *
     * If at any point we do not advance beyond a given user step, (e.g. the user cancels
     * instead of setting a password) we simply repost the security notification, and exit.
     * We never want to loop here.
     */
    private void tryAdvanceSecurity(Account account) {
        SecurityPolicy security = SecurityPolicy.getInstance(this);
        // Step 1.  Check if we are an active device administrator, and stop here to activate
        if (!security.isActiveAdmin()) {
            if (mTriedAddAdministrator) {
                if (Email.DEBUG) {
                    Log.d(TAG, ""Not active admin: repost notification"");
                }
                repostNotification(account, security);
                finish();
            } else {
                mTriedAddAdministrator = true;
                // retrieve name of server for the format string
                HostAuth hostAuth = HostAuth.restoreHostAuthWithId(this, account.mHostAuthKeyRecv);
                if (hostAuth == null) {
                    if (Email.DEBUG) {
                        Log.d(TAG, ""No HostAuth: repost notification"");
                    }
                    repostNotification(account, security);
                    finish();
                } else {
                    if (Email.DEBUG) {
                        Log.d(TAG, ""Not active admin: post initial notification"");
                    }
                    // try to become active - must happen here in activity, to get result
                    Intent intent = new Intent(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN);
                    intent.putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN,
                            security.getAdminComponent());
                    intent.putExtra(DevicePolicyManager.EXTRA_ADD_EXPLANATION,
                            this.getString(R.string.account_security_policy_explanation_fmt,
                                    hostAuth.mAddress));
                    startActivityForResult(intent, REQUEST_ENABLE);
                }
            }
            return;
        }

        // Step 2.  Check if the current aggregate security policy is being satisfied by the
        // DevicePolicyManager (the current system security level).
        if (security.isActive(null)) {
            if (Email.DEBUG) {
                Log.d(TAG, ""Security active; clear holds"");
            }
            Account.clearSecurityHoldOnAllAccounts(this);
            security.clearNotification();
            finish();
            return;
        }

        // Step 3.  Try to assert the current aggregate security requirements with the system.
        security.setActivePolicies();

        // Step 4.  Recheck the security policy, and determine what changes are needed (if any)
        // to satisfy the requirements.
        int inactiveReasons = security.getInactiveReasons(null);

        // Step 5.  If password is needed, try to have the user set it
        if ((inactiveReasons & SecurityPolicy.INACTIVE_NEED_PASSWORD) != 0) {
            if (mTriedSetPassword) {
                if (Email.DEBUG) {
                    Log.d(TAG, ""Password needed; repost notification"");
                }
                repostNotification(account, security);
                finish();
            } else {
                if (Email.DEBUG) {
                    Log.d(TAG, ""Password needed; request it via DPM"");
                }
                mTriedSetPassword = true;
                // launch the activity to have the user set a new password.
                Intent intent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);
                startActivityForResult(intent, REQUEST_PASSWORD);
            }
            return;
        }

        // Step 6.  If encryption is needed, try to have the user set it
        if ((inactiveReasons & SecurityPolicy.INACTIVE_NEED_ENCRYPTION) != 0) {
            if (mTriedSetEncryption) {
                if (Email.DEBUG) {
                    Log.d(TAG, ""Encryption needed; repost notification"");
                }
                repostNotification(account, security);
                finish();
            } else {
                if (Email.DEBUG) {
                    Log.d(TAG, ""Encryption needed; request it via DPM"");
                }
                mTriedSetEncryption = true;
                // launch the activity to start up encryption.
                Intent intent = new Intent(DevicePolicyManager.ACTION_START_ENCRYPTION);
                startActivityForResult(intent, REQUEST_ENCRYPTION);
            }
            return;
        }

        // Step 7.  No problems were found, so clear holds and exit
        if (Email.DEBUG) {
            Log.d(TAG, ""Policies enforced; clear holds"");
        }
        Account.clearSecurityHoldOnAllAccounts(this);
        security.clearNotification();
        finish();
    }

    /**
     * Mark an account as not-ready-for-sync and post a notification to bring the user back here
     * eventually.
     */
    private void repostNotification(final Account account, final SecurityPolicy security) {
        if (account == null) return;
        Utility.runAsync(new Runnable() {
            @Override
            public void run() {
                security.policiesRequired(account.mId);
            }
        });
    }

    /**
     * Dialog briefly shown in some cases, to indicate the user that a security update is needed.
     * If the user clicks OK, we proceed into the ""tryAdvanceSecurity"" flow.  If the user cancels,
     * we repost the notification and finish() the activity.
     */
    public static class SecurityNeededDialog extends DialogFragment
            implements DialogInterface.OnClickListener {
        private static final String BUNDLE_KEY_ACCOUNT_NAME = ""account_name"";

        /**
         * Create a new dialog.
         */
        public static SecurityNeededDialog newInstance(String accountName) {
            final SecurityNeededDialog dialog = new SecurityNeededDialog();
            Bundle b = new Bundle();
            b.putString(BUNDLE_KEY_ACCOUNT_NAME, accountName);
            dialog.setArguments(b);
            return dialog;
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            final String accountName = getArguments().getString(BUNDLE_KEY_ACCOUNT_NAME);

            final Context context = getActivity();
            final Resources res = context.getResources();
            final AlertDialog.Builder b = new AlertDialog.Builder(context);
            b.setTitle(R.string.account_security_dialog_title);
            b.setIconAttribute(android.R.attr.alertDialogIcon);
            b.setMessage(res.getString(R.string.account_security_dialog_content_fmt, accountName));
            b.setPositiveButton(R.string.okay_action, this);
            b.setNegativeButton(R.string.cancel_action, this);
            if (Email.DEBUG) {
                Log.d(TAG, ""Posting security needed dialog"");
            }
            return b.create();
        }

        @Override
        public void onClick(DialogInterface dialog, int which) {
            dismiss();
            AccountSecurity activity = (AccountSecurity) getActivity();
            if (activity.mAccount == null) {
                // Clicked before activity fully restored - probably just monkey - exit quickly
                activity.finish();
                return;
            }
            switch (which) {
                case DialogInterface.BUTTON_POSITIVE:
                    if (Email.DEBUG) {
                        Log.d(TAG, ""User accepts; advance to next step"");
                    }
                    activity.tryAdvanceSecurity(activity.mAccount);
                    break;
                case DialogInterface.BUTTON_NEGATIVE:
                    if (Email.DEBUG) {
                        Log.d(TAG, ""User declines; repost notification"");
                    }
                    activity.repostNotification(
                            activity.mAccount, SecurityPolicy.getInstance(activity));
                    activity.finish();
                    break;
            }
        }
    }

    /**
     * Dialog briefly shown in some cases, to indicate the user that the PIN/Password is expiring
     * or has expired.  If the user clicks OK, we launch the password settings screen.
     */
    public static class PasswordExpirationDialog extends DialogFragment
            implements DialogInterface.OnClickListener {
        private static final String BUNDLE_KEY_ACCOUNT_NAME = ""account_name"";
        private static final String BUNDLE_KEY_EXPIRED = ""expired"";

        /**
         * Create a new dialog.
         */
        public static PasswordExpirationDialog newInstance(String accountName, boolean expired) {
            final PasswordExpirationDialog dialog = new PasswordExpirationDialog();
            Bundle b = new Bundle();
            b.putString(BUNDLE_KEY_ACCOUNT_NAME, accountName);
            b.putBoolean(BUNDLE_KEY_EXPIRED, expired);
            dialog.setArguments(b);
            return dialog;
        }

        /**
         * Note, this actually creates two slightly different dialogs (for expiring vs. expired)
         */
        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            final String accountName = getArguments().getString(BUNDLE_KEY_ACCOUNT_NAME);
            final boolean expired = getArguments().getBoolean(BUNDLE_KEY_EXPIRED);
            final int titleId = expired
                    ? R.string.password_expired_dialog_title
                    : R.string.password_expire_warning_dialog_title;
            final int contentId = expired
                    ? R.string.password_expired_dialog_content_fmt
                    : R.string.password_expire_warning_dialog_content_fmt;

            final Context context = getActivity();
            final Resources res = context.getResources();
            final AlertDialog.Builder b = new AlertDialog.Builder(context);
            b.setTitle(titleId);
            b.setIconAttribute(android.R.attr.alertDialogIcon);
            b.setMessage(res.getString(contentId, accountName));
            b.setPositiveButton(R.string.okay_action, this);
            b.setNegativeButton(R.string.cancel_action, this);
            return b.create();
        }

        @Override
        public void onClick(DialogInterface dialog, int which) {
            dismiss();
            AccountSecurity activity = (AccountSecurity) getActivity();
            if (which == DialogInterface.BUTTON_POSITIVE) {
                Intent intent = new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD);
                activity.startActivity(intent);
            }
            activity.finish();
        }
    }
}
",True,267,0,0,11,44,4,7,L6
84,com.android.email.activity.setup.AccountSetupNames.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.provider.ContactsContract.Profile;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.text.method.TextKeyListener;
import android.text.method.TextKeyListener.Capitalize;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.EditText;

import com.android.email.R;
import com.android.email.activity.ActivityHelper;
import com.android.email.activity.UiUtilities;
import com.android.email.activity.Welcome;
import com.android.email.provider.AccountBackupRestore;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.android.emailcommon.utility.Utility;

/**
 * Final screen of setup process.  Collect account nickname and/or username.
 */
public class AccountSetupNames extends AccountSetupActivity implements OnClickListener {
    private static final int REQUEST_SECURITY = 0;

    private static final Uri PROFILE_URI = Profile.CONTENT_URI;

    private EditText mDescription;
    private EditText mName;
    private Button mNextButton;
    private boolean mEasAccount = false;

    public static void actionSetNames(Activity fromActivity) {
        fromActivity.startActivity(new Intent(fromActivity, AccountSetupNames.class));
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(R.layout.account_setup_names);
        mDescription = (EditText) UiUtilities.getView(this, R.id.account_description);
        mName = (EditText) UiUtilities.getView(this, R.id.account_name);
        View accountNameLabel = UiUtilities.getView(this, R.id.account_name_label);
        mNextButton = (Button) UiUtilities.getView(this, R.id.next);
        mNextButton.setOnClickListener(this);

        TextWatcher validationTextWatcher = new TextWatcher() {
            @Override
            public void afterTextChanged(Editable s) {
                validateFields();
            }

            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            }

            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
            }
        };
        mName.addTextChangedListener(validationTextWatcher);
        mName.setKeyListener(TextKeyListener.getInstance(false, Capitalize.WORDS));

        Account account = SetupData.getAccount();
        if (account == null) {
            throw new IllegalStateException(""unexpected null account"");
        }
        if (account.mHostAuthRecv == null) {
            throw new IllegalStateException(""unexpected null hostauth"");
        }
        int flowMode = SetupData.getFlowMode();

        if (flowMode != SetupData.FLOW_MODE_FORCE_CREATE
                && flowMode != SetupData.FLOW_MODE_EDIT) {
            String accountEmail = account.mEmailAddress;
            mDescription.setText(accountEmail);

            // Move cursor to the end so it's easier to erase in case the user doesn't like it.
            mDescription.setSelection(accountEmail.length());
        }

        // Remember whether we're an EAS account, since it doesn't require the user name field
        mEasAccount = HostAuth.SCHEME_EAS.equals(account.mHostAuthRecv.mProtocol);
        if (mEasAccount) {
            mName.setVisibility(View.GONE);
            accountNameLabel.setVisibility(View.GONE);
        } else {
            if (account != null && account.getSenderName() != null) {
                mName.setText(account.getSenderName());
            } else if (flowMode != SetupData.FLOW_MODE_FORCE_CREATE
                    && flowMode != SetupData.FLOW_MODE_EDIT) {
                // Attempt to prefill the name field from the profile if we don't have it,
                prefillNameFromProfile();
            }
        }

        // Make sure the ""done"" button is in the proper state
        validateFields();

        // Proceed immediately if in account creation mode
        if (flowMode == SetupData.FLOW_MODE_FORCE_CREATE) {
            onNext();
        }
    }

    private void prefillNameFromProfile() {
        new EmailAsyncTask<Void, Void, String>(null) {
            @Override
            protected String doInBackground(Void... params) {
                String[] projection = new String[] { Profile.DISPLAY_NAME };
                return Utility.getFirstRowString(
                        AccountSetupNames.this, PROFILE_URI, projection, null, null, null, 0);
            }

            @Override
            public void onSuccess(String result) {
                // Views can only be modified on the main thread.
                mName.setText(result);
            }
        }.executeParallel((Void[]) null);
    }

    /**
     * Implements OnClickListener
     */
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.next:
                onNext();
                break;
        }
    }

    /**
     * Check input fields for legal values and enable/disable next button
     */
    private void validateFields() {
        boolean enableNextButton = true;
        // Validation is based only on the ""user name"" field, not shown for EAS accounts
        if (!mEasAccount) {
            String userName = mName.getText().toString().trim();
            if (TextUtils.isEmpty(userName)) {
                enableNextButton = false;
                mName.setError(getString(R.string.account_setup_names_user_name_empty_error));
            } else {
                mName.setError(null);
            }
        }
        mNextButton.setEnabled(enableNextButton);
    }

    /**
     * Block the back key if we are currently processing the ""next"" key""
     */
    @Override
    public void onBackPressed() {
        if (mNextButton.isEnabled()) {
            finishActivity();
        }
    }

    private void finishActivity() {
        if (SetupData.getFlowMode() != SetupData.FLOW_MODE_NORMAL) {
            AccountSetupBasics.actionAccountCreateFinishedAccountFlow(this);
        } else {
            Account account = SetupData.getAccount();
            if (account != null) {
                AccountSetupBasics.actionAccountCreateFinished(this, account.mId);
            } else {
                // Safety check here;  If mAccount is null (due to external issues or bugs)
                // just rewind back to Welcome, which can handle any configuration of accounts
                Welcome.actionStart(this);
            }
        }
        finish();
    }

    /**
     * After clicking the next button, we'll start an async task to commit the data
     * and other steps to finish the creation of the account.
     */
    private void onNext() {
        mNextButton.setEnabled(false); // Protect against double-tap.

        // Update account object from UI
        Account account = SetupData.getAccount();
        String description = mDescription.getText().toString().trim();
        if (!TextUtils.isEmpty(description)) {
            account.setDisplayName(description);
        }
        account.setSenderName(mName.getText().toString().trim());

        // Launch async task for final commit work
        // Sicne it's a write task, use the serial executor so even if we ran the task twice
        // with different values the result would be consistent.
        new FinalSetupTask(account).executeOnExecutor(AsyncTask.SERIAL_EXECUTOR);
    }

    /**
     * Final account setup work is handled in this AsyncTask:
     *   Commit final values to provider
     *   Trigger account backup
     *   Check for security hold
     *
     * When this completes, we return to UI thread for the following steps:
     *   If security hold, dispatch to AccountSecurity activity
     *   Otherwise, return to AccountSetupBasics for conclusion.
     *
     * TODO: If there was *any* indication that security might be required, we could at least
     * force the DeviceAdmin activation step, without waiting for the initial sync/handshake
     * to fail.
     * TODO: If the user doesn't update the security, don't go to the MessageList.
     */
    private class FinalSetupTask extends AsyncTask<Void, Void, Boolean> {

        private final Account mAccount;
        private final Context mContext;

        public FinalSetupTask(Account account) {
            mAccount = account;
            mContext = AccountSetupNames.this;
        }

        @Override
        protected Boolean doInBackground(Void... params) {
            // Update the account in the database
            ContentValues cv = new ContentValues();
            cv.put(AccountColumns.DISPLAY_NAME, mAccount.getDisplayName());
            cv.put(AccountColumns.SENDER_NAME, mAccount.getSenderName());
            mAccount.update(mContext, cv);

            // Update the backup (side copy) of the accounts
            AccountBackupRestore.backup(AccountSetupNames.this);

            return Account.isSecurityHold(mContext, mAccount.mId);
        }

        @Override
        protected void onPostExecute(Boolean isSecurityHold) {
            if (!isCancelled()) {
                if (isSecurityHold) {
                    Intent i = AccountSecurity.actionUpdateSecurityIntent(
                            AccountSetupNames.this, mAccount.mId, false);
                    startActivityForResult(i, REQUEST_SECURITY);
                } else {
                    finishActivity();
                }
            }
        }
    }

    /**
     * Handle the eventual result from the security update activity
     *
     * TODO: If the user doesn't update the security, don't go to the MessageList.
     */
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_SECURITY:
                finishActivity();
        }
        super.onActivityResult(requestCode, resultCode, data);
    }

}
",True,267,0,0,11,54,1,13,L6
85,com.android.email.activity.setup.SpinnerOption.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.widget.Spinner;

public class SpinnerOption {
    public final Object value;

    public final String label;

    public static void setSpinnerOptionValue(Spinner spinner, Object value) {
        for (int i = 0, count = spinner.getCount(); i < count; i++) {
            SpinnerOption so = (SpinnerOption)spinner.getItemAtPosition(i);
            if (so.value.equals(value)) {
                spinner.setSelection(i, true);
                return;
            }
        }
    }

    public SpinnerOption(Object value, String label) {
        this.value = value;
        this.label = label;
    }

    @Override
    public String toString() {
        return label;
    }
}
",True,147,10,36,0,0,4,0,L6
86,com.android.email.activity.setup.AccountSettingsEditQuickResponsesFragment.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.activity.UiUtilities;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.QuickResponse;
import com.android.emailcommon.utility.EmailAsyncTask;

import android.app.Activity;
import android.app.Fragment;
import android.app.FragmentManager;
import android.content.Context;
import android.database.ContentObserver;
import android.os.Bundle;
import android.os.Handler;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.TextView;

/**
 * Lists quick responses associated with the specified email account. Allows users to create,
 * edit, and delete quick responses. Owning activity must:
 * <ul>
 *   <li>Launch this fragment using startPreferencePanel().</li>
 *   <li>Provide an Account as an argument named ""account"". This account's quick responses
 *   will be read and potentially modified.</li>
 * </ul>
 *
 * <p>This fragment is run as a preference panel from AccountSettings.</p>
 */
public class AccountSettingsEditQuickResponsesFragment extends Fragment
        implements OnClickListener {
    private ListView mQuickResponsesView;
    private Account mAccount;
    private Context mContext;
    private EmailAsyncTask.Tracker mTaskTracker;

    private static final String BUNDLE_KEY_ACTIVITY_TITLE
            = ""AccountSettingsEditQuickResponsesFragment.title"";

    // Helper class to place a TextView alongside ""Delete"" icon in the ListView
    // displaying the QuickResponses
    private static class ArrayAdapterWithButtons extends ArrayAdapter<QuickResponse> {
        private QuickResponse[] mQuickResponses;
        private final long mAccountId;
        private final Context mContext;
        private final FragmentManager mFragmentManager;

        private OnClickListener mOnEditListener = new OnClickListener() {
            @Override
            public void onClick(View view) {
                    QuickResponse quickResponse = (QuickResponse) (view.getTag());
                    EditQuickResponseDialog
                            .newInstance(quickResponse, mAccountId)
                            .show(mFragmentManager, null);
            }
        };

        private OnClickListener mOnDeleteListener = new OnClickListener() {
            @Override
            public void onClick(View view) {
                final QuickResponse quickResponse = (QuickResponse) view.getTag();

                // Delete the QuickResponse from the database. Content watchers used to
                // update the ListView of QuickResponses upon deletion.
                EmailAsyncTask.runAsyncParallel(new Runnable() {
                    @Override
                    public void run() {
                        EmailContent.delete(mContext, quickResponse.getBaseUri(),
                                quickResponse.getId());
                    }
                });
            }
        };

        private static final int resourceId = R.layout.quick_response_item;
        private static final int textViewId = R.id.quick_response_text;

        /**
         * Instantiates the custom ArrayAdapter, allowing editing and deletion of QuickResponses.
         * @param context - context of owning activity
         * @param quickResponses - the QuickResponses to represent in the ListView.
         * @param fragmentManager - fragmentManager to which an EditQuickResponseDialog will
         * attach itself.
         * @param accountId - accountId of the QuickResponses
         */
        public ArrayAdapterWithButtons(
                Context context, QuickResponse[] quickResponses,
                FragmentManager fragmentManager, long accountId) {
            super(context, resourceId, textViewId, quickResponses);
            mQuickResponses = quickResponses;
            mAccountId = accountId;
            mContext = context;
            mFragmentManager = fragmentManager;
        }

        @Override
        public View getView(final int position, View convertView, ViewGroup parent) {
            convertView = super.getView(position, convertView, parent);
            convertView.setTag(mQuickResponses[position]);
            convertView.setOnClickListener(mOnEditListener);

            ImageView deleteIcon = (ImageView) convertView.findViewById(R.id.delete_icon);
            deleteIcon.setTag(mQuickResponses[position]);
            deleteIcon.setOnClickListener(mOnDeleteListener);

            return convertView;
        }
    }

    /**
     *  Finds existing QuickResponses for the specified account and attaches the contents to
     *  a ListView. Optionally allows for editing and deleting of QuickResposnes from ListView.
     */
    public static class QuickResponseFinder extends EmailAsyncTask<Void, Void, QuickResponse[]> {
        private final long mAccountId;
        private final ListView mQuickResponsesView;
        private final Context mContext;
        private final FragmentManager mFragmentManager;
        private final OnItemClickListener mListener;
        private final boolean mIsEditable;

        /**
         * Finds all QuickResponses for the given account. Creates either a standard ListView
         * with a caller-implemented listener or one with a custom adapter that allows deleting
         * and editing of QuickResponses via EditQuickResponseDialog.
         *
         * @param tracker - tracks the finding and listing of QuickResponses. Should be canceled
         * onDestroy() or when the results are no longer needed.
         * @param accountId - id of the account whose QuickResponses are to be returned
         * @param quickResponsesView - ListView to which an ArrayAdapter with the QuickResponses
         * will be attached.
         * @param context - context of the owning activity
         * @param fragmentManager - required when isEditable is true so that an EditQuickResponse
         * dialog may properly attach itself. Unused when isEditable is false.
         * @param listener - optional when isEditable is true, unused when false.
         * @param isEditable - specifies whether the ListView will allow for user editing of
         * QuickResponses
         */
        public QuickResponseFinder(EmailAsyncTask.Tracker tracker, long accountId,
                ListView quickResponsesView, Context context, FragmentManager fragmentManager,
                OnItemClickListener listener, boolean isEditable) {
            super(tracker);
            mAccountId = accountId;
            mQuickResponsesView = quickResponsesView;
            mContext = context;
            mFragmentManager = fragmentManager;
            mListener = listener;
            mIsEditable = isEditable;
        }

        @Override
        protected QuickResponse[] doInBackground(Void... params) {
            QuickResponse[] quickResponses = QuickResponse.restoreQuickResponsesWithAccountId(
                    mContext, mAccountId);
            return quickResponses;
        }

        @Override
        protected void onSuccess(QuickResponse[] quickResponseItems) {
            ArrayAdapter<QuickResponse> adapter;
            if (mIsEditable) {
                    adapter = new ArrayAdapterWithButtons(
                    mContext,
                    quickResponseItems,
                    mFragmentManager,
                    mAccountId);
            } else {
                adapter = new ArrayAdapter<QuickResponse>(
                        mContext,
                        R.layout.insert_quick_response,
                        quickResponseItems
                        );
                mQuickResponsesView.setOnItemClickListener(mListener);
            }
            mQuickResponsesView.setAdapter(adapter);
        }
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        // startPreferencePanel launches this fragment with the right title initially, but
        // if the device is rotate we must set the title ourselves
        if (savedInstanceState != null) {
            getActivity().setTitle(savedInstanceState.getString(BUNDLE_KEY_ACTIVITY_TITLE));
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        outState.putString(BUNDLE_KEY_ACTIVITY_TITLE, (String) getActivity().getTitle());
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsEditQuickResponsesFragment onCreate"");
        }
        super.onCreate(savedInstanceState);

        Bundle args = getArguments();
        mAccount = args.getParcelable(""account"");
        mTaskTracker = new EmailAsyncTask.Tracker();
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsEditQuickResponsesFragment onCreateView"");
        }
        int layoutId = R.layout.account_settings_edit_quick_responses_fragment;
        View view = inflater.inflate(layoutId, container, false);
        mContext = getActivity();

        mQuickResponsesView = UiUtilities.getView(view,
                R.id.account_settings_quick_responses_list);
        TextView emptyView = (TextView)
                UiUtilities.getView(((ViewGroup) mQuickResponsesView.getParent()), R.id.empty_view);
        mQuickResponsesView.setEmptyView(emptyView);

        new QuickResponseFinder(mTaskTracker, mAccount.mId, mQuickResponsesView,
                mContext, getFragmentManager(), null, true)
                .executeParallel();

        this.getActivity().getContentResolver().registerContentObserver(
                QuickResponse.CONTENT_URI, false, new ContentObserver(new Handler()) {
                    @Override
                    public void onChange(boolean selfChange) {
                        new QuickResponseFinder(mTaskTracker, mAccount.mId, mQuickResponsesView,
                                mContext, getFragmentManager(), null, true)
                                .executeParallel();
                    }
                });

        UiUtilities.getView(view, R.id.create_new).setOnClickListener(this);

        return view;
    }

    @Override
    public void onDestroy() {
        mTaskTracker.cancellAllInterrupt();
        super.onDestroy();
    }

    /**
     * Implements OnClickListener
     */
    @Override
    public void onClick(View v) {
        if (v.getId() == R.id.create_new) {
            EditQuickResponseDialog
                    .newInstance(null, mAccount.mId)
                    .show(getFragmentManager(), null);
        }
    }
}",False,267,0,0,11,44,1,8,L6
87,com.android.email.activity.setup.AccountSettings.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.ActionBar;
import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.Fragment;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.Resources;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.preference.PreferenceActivity;
import android.util.Log;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;

import com.android.email.Controller;
import com.android.email.R;
import com.android.email.activity.ActivityHelper;
import com.android.email.mail.Sender;
import com.android.email.mail.Store;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.utility.IntentUtilities;
import com.android.emailcommon.utility.Utility;

import java.util.List;

/**
 * Handles account preferences, using multi-pane arrangement when possible.
 *
 * This activity uses the following fragments:
 *   AccountSettingsFragment
 *   Account{Incoming/Outgoing/Exchange}Fragment
 *   AccountCheckSettingsFragment
 *   GeneralPreferences
 *   DebugFragment
 *
 * TODO: Delete account - on single-pane view (phone UX) the account list doesn't update properly
 * TODO: Handle dynamic changes to the account list (exit if necessary).  It probably makes
 *       sense to use a loader for the accounts list, because it would provide better support for
 *       dealing with accounts being added/deleted and triggering the header reload.
 */
public class AccountSettings extends PreferenceActivity {
    /*
     * Intent to open account settings for account=1
        adb shell am start -a android.intent.action.EDIT \
            -d '""content://ui.email.android.com/settings?ACCOUNT_ID=1""'
     */

    // Intent extras for our internal activity launch
    private static final String EXTRA_ENABLE_DEBUG = ""AccountSettings.enable_debug"";
    private static final String EXTRA_LOGIN_WARNING_FOR_ACCOUNT = ""AccountSettings.for_account"";
    private static final String EXTRA_TITLE = ""AccountSettings.title"";

    // Intent extras for launch directly from system account manager
    // NOTE: This string must match the one in res/xml/account_preferences.xml
    private static final String ACTION_ACCOUNT_MANAGER_ENTRY =
        ""com.android.email.activity.setup.ACCOUNT_MANAGER_ENTRY"";
    // NOTE: This constant should eventually be defined in android.accounts.Constants
    private static final String EXTRA_ACCOUNT_MANAGER_ACCOUNT = ""account"";

    // Key for arguments bundle for QuickResponse editing
    private static final String QUICK_RESPONSE_ACCOUNT_KEY = ""account"";

    // Key codes used to open a debug settings fragment.
    private static final int[] SECRET_KEY_CODES = {
            KeyEvent.KEYCODE_D, KeyEvent.KEYCODE_E, KeyEvent.KEYCODE_B, KeyEvent.KEYCODE_U,
            KeyEvent.KEYCODE_G
            };
    private int mSecretKeyCodeIndex = 0;

    // Support for account-by-name lookup
    private static final String SELECTION_ACCOUNT_EMAIL_ADDRESS =
        AccountColumns.EMAIL_ADDRESS + ""=?"";

    // When the user taps ""Email Preferences"" 10 times in a row, we'll enable the debug settings.
    private int mNumGeneralHeaderClicked = 0;

    private long mRequestedAccountId;
    private Header mRequestedAccountHeader;
    private Header[] mAccountListHeaders;
    private Header mAppPreferencesHeader;
    /* package */ Fragment mCurrentFragment;
    private long mDeletingAccountId = -1;
    private boolean mShowDebugMenu;
    private List<Header> mGeneratedHeaders;

    // Async Tasks
    private LoadAccountListTask mLoadAccountListTask;
    private GetAccountIdFromAccountTask mGetAccountIdFromAccountTask;
    private ContentObserver mAccountObserver;

    // Specific callbacks used by settings fragments
    private final AccountSettingsFragmentCallback mAccountSettingsFragmentCallback
            = new AccountSettingsFragmentCallback();
    private final AccountServerSettingsFragmentCallback mAccountServerSettingsFragmentCallback
            = new AccountServerSettingsFragmentCallback();

    /**
     * Display (and edit) settings for a specific account, or -1 for any/all accounts
     */
    public static void actionSettings(Activity fromActivity, long accountId) {
        fromActivity.startActivity(createAccountSettingsIntent(fromActivity, accountId, null));
    }

    /**
     * Create and return an intent to display (and edit) settings for a specific account, or -1
     * for any/all accounts.  If an account name string is provided, a warning dialog will be
     * displayed as well.
     */
    public static Intent createAccountSettingsIntent(Context context, long accountId,
            String loginWarningAccountName) {
        final Uri.Builder b = IntentUtilities.createActivityIntentUrlBuilder(""settings"");
        IntentUtilities.setAccountId(b, accountId);
        Intent i = new Intent(Intent.ACTION_EDIT, b.build());
        if (loginWarningAccountName != null) {
            i.putExtra(EXTRA_LOGIN_WARNING_FOR_ACCOUNT, loginWarningAccountName);
        }
        return i;
    }

    /**
     * Launch generic settings and pre-enable the debug preferences
     */
    public static void actionSettingsWithDebug(Context fromContext) {
        Intent i = new Intent(fromContext, AccountSettings.class);
        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        i.putExtra(EXTRA_ENABLE_DEBUG, true);
        fromContext.startActivity(i);
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);

        Intent i = getIntent();
        if (savedInstanceState == null) {
            // If we are not restarting from a previous instance, we need to
            // figure out the initial prefs to show.  (Otherwise, we want to
            // continue showing whatever the user last selected.)
            if (ACTION_ACCOUNT_MANAGER_ENTRY.equals(i.getAction())) {
                // This case occurs if we're changing account settings from Settings -> Accounts
                mGetAccountIdFromAccountTask =
                        (GetAccountIdFromAccountTask) new GetAccountIdFromAccountTask()
                        .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, i);
            } else {
                // Otherwise, we're called from within the Email app and look for our extras
                mRequestedAccountId = IntentUtilities.getAccountIdFromIntent(i);
                String loginWarningAccount = i.getStringExtra(EXTRA_LOGIN_WARNING_FOR_ACCOUNT);
                if (loginWarningAccount != null) {
                    // Show dialog (first time only - don't re-show on a rotation)
                    LoginWarningDialog dialog = LoginWarningDialog.newInstance(loginWarningAccount);
                    dialog.show(getFragmentManager(), ""loginwarning"");
                }
            }
        }
        mShowDebugMenu = i.getBooleanExtra(EXTRA_ENABLE_DEBUG, false);

        String title = i.getStringExtra(EXTRA_TITLE);
        if (title != null) {
            setTitle(title);
        }

        getActionBar().setDisplayOptions(
                ActionBar.DISPLAY_HOME_AS_UP, ActionBar.DISPLAY_HOME_AS_UP);

        mAccountObserver = new ContentObserver(Utility.getMainThreadHandler()) {
            @Override
            public void onChange(boolean selfChange) {
                updateAccounts();
            }
        };
    }

    @Override
    public void onResume() {
        super.onResume();
        getContentResolver().registerContentObserver(Account.NOTIFIER_URI, true, mAccountObserver);
        updateAccounts();
    }

    @Override
    public void onPause() {
        super.onPause();
        getContentResolver().unregisterContentObserver(mAccountObserver);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        Utility.cancelTaskInterrupt(mLoadAccountListTask);
        mLoadAccountListTask = null;
        Utility.cancelTaskInterrupt(mGetAccountIdFromAccountTask);
        mGetAccountIdFromAccountTask = null;
    }

    /**
     * Listen for secret sequence and, if heard, enable debug menu
     */
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (event.getKeyCode() == SECRET_KEY_CODES[mSecretKeyCodeIndex]) {
            mSecretKeyCodeIndex++;
            if (mSecretKeyCodeIndex == SECRET_KEY_CODES.length) {
                mSecretKeyCodeIndex = 0;
                enableDebugMenu();
            }
        } else {
            mSecretKeyCodeIndex = 0;
        }
        return super.onKeyDown(keyCode, event);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        getMenuInflater().inflate(R.menu.account_settings_add_account_option, menu);
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        return shouldShowNewAccount();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                // The app icon on the action bar is pressed.  Just emulate a back press.
                // TODO: this should navigate to the main screen, even if a sub-setting is open.
                // But we shouldn't just finish(), as we want to show ""discard changes?"" dialog
                // when necessary.
                onBackPressed();
                break;
            case R.id.add_new_account:
                onAddNewAccount();
                break;
            default:
                return super.onOptionsItemSelected(item);
        }
        return true;
    }

    @Override
    public Intent onBuildStartFragmentIntent(String fragmentName, Bundle args,
            int titleRes, int shortTitleRes) {
        Intent result = super.onBuildStartFragmentIntent(
                fragmentName, args, titleRes, shortTitleRes);

        // When opening a sub-settings page (e.g. account specific page), see if we want to modify
        // the activity title.
        String title = AccountSettingsFragment.getTitleFromArgs(args);
        if ((titleRes == 0) && (title != null)) {
            result.putExtra(EXTRA_TITLE, title);
        }
        return result;
    }

    /**
     * Any time we exit via this pathway, and we are showing a server settings fragment,
     * we put up the exit-save-changes dialog.  This will work for the following cases:
     *   Cancel button
     *   Back button
     *   Up arrow in application icon
     * It will *not* apply in the following cases:
     *   Click the parent breadcrumb - need to find a hook for this
     *   Click in the header list (e.g. another account) - handled elsewhere
     */
    @Override
    public void onBackPressed() {
        if (mCurrentFragment instanceof AccountServerBaseFragment) {
            boolean changed = ((AccountServerBaseFragment) mCurrentFragment).haveSettingsChanged();
            if (changed) {
                UnsavedChangesDialogFragment dialogFragment =
                        UnsavedChangesDialogFragment.newInstanceForBack();
                dialogFragment.show(getFragmentManager(), UnsavedChangesDialogFragment.TAG);
                return; // Prevent ""back"" from being handled
            }
        }
        super.onBackPressed();
    }

    /**
     * If the caller requested a specific account to be edited, switch to it.  This is a one-shot,
     * so the user is free to edit another account as well.
     */
    @Override
    public Header onGetNewHeader() {
        Header result = mRequestedAccountHeader;
        mRequestedAccountHeader = null;
        return result;
    }

    private void enableDebugMenu() {
        mShowDebugMenu = true;
        invalidateHeaders();
    }

    /**
     * Decide if ""add account"" should be shown
     */
    private boolean shouldShowNewAccount() {
        // If in single pane mode, only add accounts at top level
        if (!onIsMultiPane()) {
            return hasHeaders();
        } else {
            // If in multi pane mode, only add accounts when showing a top level fragment
            // Note: null is OK; This is the case when we first launch the activity
            if ((mCurrentFragment != null)
                && !(mCurrentFragment instanceof GeneralPreferences)
                && !(mCurrentFragment instanceof DebugFragment)
                && !(mCurrentFragment instanceof AccountSettingsFragment)) return false;
        }
        return true;
    }

    private void onAddNewAccount() {
        AccountSetupBasics.actionNewAccount(this);
    }

    /**
     * Start the async reload of the accounts list (if the headers are being displayed)
     */
    private void updateAccounts() {
        if (hasHeaders()) {
            Utility.cancelTaskInterrupt(mLoadAccountListTask);
            mLoadAccountListTask = (LoadAccountListTask)
                    new LoadAccountListTask().executeOnExecutor(
                            AsyncTask.THREAD_POOL_EXECUTOR, mDeletingAccountId);
        }
    }

    /**
     * Write the current header (accounts) array into the one provided by the PreferenceActivity.
     * Skip any headers that match mDeletingAccountId (this is a quick-hide algorithm while a
     * background thread works on deleting the account).  Also sets mRequestedAccountHeader if
     * we find the requested account (by id).
     */
    @Override
    public void onBuildHeaders(List<Header> target) {
        // Assume the account is unspecified
        mRequestedAccountHeader = null;

        // Always add app preferences as first header
        target.clear();
        target.add(getAppPreferencesHeader());

        // Then add zero or more account headers as necessary
        if (mAccountListHeaders != null) {
            int headerCount = mAccountListHeaders.length;
            for (int index = 0; index < headerCount; index++) {
                Header header = mAccountListHeaders[index];
                if (header != null && header.id != HEADER_ID_UNDEFINED) {
                    if (header.id != mDeletingAccountId) {
                        target.add(header);
                        if (header.id == mRequestedAccountId) {
                            mRequestedAccountHeader = header;
                            mRequestedAccountId = -1;
                        }
                    }
                }
            }
        }

        // finally, if debug header is enabled, show it
        if (mShowDebugMenu) {
            // setup lightweight header for debugging
            Header debugHeader = new Header();
            debugHeader.title = getText(R.string.debug_title);
            debugHeader.summary = null;
            debugHeader.iconRes = 0;
            debugHeader.fragment = DebugFragment.class.getCanonicalName();
            debugHeader.fragmentArguments = null;
            target.add(debugHeader);
        }

        // Save for later use (see forceSwitch)
        mGeneratedHeaders = target;
    }

    /**
     * Generate and return the first header, for app preferences
     */
    private Header getAppPreferencesHeader() {
        // Set up fixed header for general settings
        if (mAppPreferencesHeader == null) {
            mAppPreferencesHeader = new Header();
            mAppPreferencesHeader.title = getText(R.string.header_label_general_preferences);
            mAppPreferencesHeader.summary = null;
            mAppPreferencesHeader.iconRes = 0;
            mAppPreferencesHeader.fragment = GeneralPreferences.class.getCanonicalName();
            mAppPreferencesHeader.fragmentArguments = null;
        }
        return mAppPreferencesHeader;
    }

    /**
     * This AsyncTask reads the accounts list and generates the headers.  When the headers are
     * ready, we'll trigger PreferenceActivity to refresh the account list with them.
     *
     * The array generated and stored in mAccountListHeaders may be sparse so any readers should
     * check for and skip over null entries, and should not assume array length is # of accounts.
     *
     * TODO: Smaller projection
     * TODO: Convert to Loader
     * TODO: Write a test, including operation of deletingAccountId param
     */
    private class LoadAccountListTask extends AsyncTask<Long, Void, Object[]> {

        @Override
        protected Object[] doInBackground(Long... params) {
            Header[] result = null;
            Boolean deletingAccountFound = false;
            long deletingAccountId = params[0];

            Cursor c = getContentResolver().query(
                    Account.CONTENT_URI,
                    Account.CONTENT_PROJECTION, null, null, null);
            try {
                int index = 0;
                int headerCount = c.getCount();
                result = new Header[headerCount];

                while (c.moveToNext()) {
                    long accountId = c.getLong(Account.CONTENT_ID_COLUMN);
                    if (accountId == deletingAccountId) {
                        deletingAccountFound = true;
                        continue;
                    }
                    String name = c.getString(Account.CONTENT_DISPLAY_NAME_COLUMN);
                    String email = c.getString(Account.CONTENT_EMAIL_ADDRESS_COLUMN);
                    Header newHeader = new Header();
                    newHeader.id = accountId;
                    newHeader.title = name;
                    newHeader.summary = email;
                    newHeader.fragment = AccountSettingsFragment.class.getCanonicalName();
                    newHeader.fragmentArguments =
                            AccountSettingsFragment.buildArguments(accountId, email);

                    result[index++] = newHeader;
                }
            } finally {
                if (c != null) {
                    c.close();
                }
            }
            return new Object[] { result, deletingAccountFound };
        }

        @Override
        protected void onPostExecute(Object[] result) {
            if (isCancelled() || result == null) return;
            // Extract the results
            Header[] headers = (Header[]) result[0];
            boolean deletingAccountFound = (Boolean) result[1];
            // report the settings
            mAccountListHeaders = headers;
            invalidateHeaders();
            if (!deletingAccountFound) {
                mDeletingAccountId = -1;
            }
        }
    }

    /**
     * Called when the user selects an item in the header list.  Handles save-data cases as needed
     *
     * @param header The header that was selected.
     * @param position The header's position in the list.
     */
    @Override
    public void onHeaderClick(Header header, int position) {
        // special case when exiting the server settings fragments
        if (mCurrentFragment instanceof AccountServerBaseFragment) {
            boolean changed = ((AccountServerBaseFragment)mCurrentFragment).haveSettingsChanged();
            if (changed) {
                UnsavedChangesDialogFragment dialogFragment =
                    UnsavedChangesDialogFragment.newInstanceForHeader(position);
                dialogFragment.show(getFragmentManager(), UnsavedChangesDialogFragment.TAG);
                return;
            }
        }

        // Secret keys:  Click 10x to enable debug settings
        if (position == 0) {
            mNumGeneralHeaderClicked++;
            if (mNumGeneralHeaderClicked == 10) {
                enableDebugMenu();
            }
        } else {
            mNumGeneralHeaderClicked = 0;
        }

        // Process header click normally
        super.onHeaderClick(header, position);
    }

    /**
     * Switch to a specific header without checking for server settings fragments as done
     * in {@link #onHeaderClick(Header, int)}.  Called after we interrupted a header switch
     * with a dialog, and the user OK'd it.
     */
    private void forceSwitchHeader(int position) {
        // Clear the current fragment; we're navigating away
        mCurrentFragment = null;
        // Ensure the UI visually shows the correct header selected
        setSelection(position);
        Header header = mGeneratedHeaders.get(position);
        switchToHeader(header);
    }

    /**
     * Forcefully go backward in the stack. This may potentially discard unsaved settings.
     */
    private void forceBack() {
        // Clear the current fragment; we're navigating away
        mCurrentFragment = null;
        onBackPressed();
    }

    @Override
    public void onAttachFragment(Fragment f) {
        super.onAttachFragment(f);

        if (f instanceof AccountSettingsFragment) {
            AccountSettingsFragment asf = (AccountSettingsFragment) f;
            asf.setCallback(mAccountSettingsFragmentCallback);
        } else if (f instanceof AccountServerBaseFragment) {
            AccountServerBaseFragment asbf = (AccountServerBaseFragment) f;
            asbf.setCallback(mAccountServerSettingsFragmentCallback);
        } else {
            // Possibly uninteresting fragment, such as a dialog.
            return;
        }
        mCurrentFragment = f;

        // When we're changing fragments, enable/disable the add account button
        invalidateOptionsMenu();
    }

    /**
     * Callbacks for AccountSettingsFragment
     */
    private class AccountSettingsFragmentCallback implements AccountSettingsFragment.Callback {
        @Override
        public void onSettingsChanged(Account account, String preference, Object value) {
            AccountSettings.this.onSettingsChanged(account, preference, value);
        }
        @Override
        public void onEditQuickResponses(Account account) {
            AccountSettings.this.onEditQuickResponses(account);
        }
        @Override
        public void onIncomingSettings(Account account) {
            AccountSettings.this.onIncomingSettings(account);
        }
        @Override
        public void onOutgoingSettings(Account account) {
            AccountSettings.this.onOutgoingSettings(account);
        }
        @Override
        public void abandonEdit() {
            finish();
        }
        @Override
        public void deleteAccount(Account account) {
            AccountSettings.this.deleteAccount(account);
        }
    }

    /**
     * Callbacks for AccountServerSettingsFragmentCallback
     */
    private class AccountServerSettingsFragmentCallback
            implements AccountServerBaseFragment.Callback {
        @Override
        public void onEnableProceedButtons(boolean enable) {
            // This is not used - it's a callback for the legacy activities
        }

        @Override
        public void onProceedNext(int checkMode, AccountServerBaseFragment target) {
            AccountCheckSettingsFragment checkerFragment =
                AccountCheckSettingsFragment.newInstance(checkMode, target);
            startPreferenceFragment(checkerFragment, true);
        }

        /**
         * After verifying a new server configuration as OK, we return here and continue.  This
         * simply does a ""back"" to exit the settings screen.
         */
        @Override
        public void onCheckSettingsComplete(int result, int setupMode) {
            if (result == AccountCheckSettingsFragment.CHECK_SETTINGS_OK) {
                // Settings checked & saved; clear current fragment
                mCurrentFragment = null;
                onBackPressed();
            }
        }
    }

    /**
     * Some of the settings have changed. Update internal state as necessary.
     */
    public void onSettingsChanged(Account account, String preference, Object value) {
        if (AccountSettingsFragment.PREFERENCE_DESCRIPTION.equals(preference)) {
            for (Header header : mAccountListHeaders) {
                if (header.id == account.mId) {
                    // Manually tweak the header title. We cannot rebuild the header list from
                    // an account cursor as the account database has not been saved yet.
                    header.title = value.toString();
                    invalidateHeaders();
                    break;
                }
            }
        }
    }

    /**
     * Dispatch to edit quick responses.
     */
    public void onEditQuickResponses(Account account) {
        try {
            Bundle args = new Bundle();
            args.putParcelable(QUICK_RESPONSE_ACCOUNT_KEY, account);
            startPreferencePanel(AccountSettingsEditQuickResponsesFragment.class.getName(), args,
                    R.string.account_settings_edit_quick_responses_label, null, null, 0);
        } catch (Exception e) {
            Log.d(Logging.LOG_TAG, ""Error while trying to invoke edit quick responses."", e);
        }
    }

    /**
     * Dispatch to edit incoming settings.
     *
     * TODO: Make things less hardwired
     */
    public void onIncomingSettings(Account account) {
        try {
            Store store = Store.getInstance(account, getApplication());
            if (store != null) {
                Class<? extends android.app.Activity> setting = store.getSettingActivityClass();
                if (setting != null) {
                    SetupData.init(SetupData.FLOW_MODE_EDIT, account);
                    if (setting.equals(AccountSetupIncoming.class)) {
                        startPreferencePanel(AccountSetupIncomingFragment.class.getName(),
                                AccountSetupIncomingFragment.getSettingsModeArgs(),
                                R.string.account_settings_incoming_label, null, null, 0);
                    } else if (setting.equals(AccountSetupExchange.class)) {
                        startPreferencePanel(AccountSetupExchangeFragment.class.getName(),
                                AccountSetupExchangeFragment.getSettingsModeArgs(),
                                R.string.account_settings_incoming_label, null, null, 0);
                    }
                }
            }
        } catch (Exception e) {
            Log.d(Logging.LOG_TAG, ""Error while trying to invoke store settings."", e);
        }
    }

    /**
     * Dispatch to edit outgoing settings.
     *
     * TODO: Make things less hardwired
     */
    public void onOutgoingSettings(Account account) {
        try {
            Sender sender = Sender.getInstance(getApplication(), account);
            if (sender != null) {
                Class<? extends android.app.Activity> setting = sender.getSettingActivityClass();
                if (setting != null) {
                    SetupData.init(SetupData.FLOW_MODE_EDIT, account);
                    if (setting.equals(AccountSetupOutgoing.class)) {
                        startPreferencePanel(AccountSetupOutgoingFragment.class.getName(),
                                AccountSetupOutgoingFragment.getSettingsModeArgs(),
                                R.string.account_settings_outgoing_label, null, null, 0);
                    }
                }
            }
        } catch (Exception e) {
            Log.d(Logging.LOG_TAG, ""Error while trying to invoke sender settings."", e);
        }
    }

    /**
     * Delete the selected account
     */
    public void deleteAccount(Account account) {
        // Kick off the work to actually delete the account
        // Delete the account (note, this is async.  Would be nice to get a callback.
        Controller.getInstance(this).deleteAccount(account.mId);

        // Then update the UI as appropriate:
        // If single pane, return to the header list.  If multi, rebuild header list
        if (onIsMultiPane()) {
            Header prefsHeader = getAppPreferencesHeader();
            this.switchToHeader(prefsHeader.fragment, prefsHeader.fragmentArguments);
            mDeletingAccountId = account.mId;
            updateAccounts();
        } else {
            // We should only be calling this while showing AccountSettingsFragment,
            // so a finish() should bring us back to headers.  No point hiding the deleted account.
            finish();
        }
    }

    /**
     * This AsyncTask looks up an account based on its email address (which is what we get from
     * the Account Manager).  When the account id is determined, we refresh the header list,
     * which will select the preferences for that account.
     */
    private class GetAccountIdFromAccountTask extends AsyncTask<Intent, Void, Long> {

        @Override
        protected Long doInBackground(Intent... params) {
            Intent intent = params[0];
            android.accounts.Account acct =
                (android.accounts.Account) intent.getParcelableExtra(EXTRA_ACCOUNT_MANAGER_ACCOUNT);
            return Utility.getFirstRowLong(AccountSettings.this, Account.CONTENT_URI,
                    Account.ID_PROJECTION, SELECTION_ACCOUNT_EMAIL_ADDRESS,
                    new String[] {acct.name}, null, Account.ID_PROJECTION_COLUMN, -1L);
        }

        @Override
        protected void onPostExecute(Long accountId) {
            if (accountId != -1 && !isCancelled()) {
                mRequestedAccountId = accountId;
                invalidateHeaders();
            }
        }
    }

    /**
     * Dialog fragment to show ""exit with unsaved changes?"" dialog
     */
    /* package */ static class UnsavedChangesDialogFragment extends DialogFragment {
        private final static String TAG = ""UnsavedChangesDialogFragment"";

        // Argument bundle keys
        private final static String BUNDLE_KEY_HEADER = ""UnsavedChangesDialogFragment.Header"";
        private final static String BUNDLE_KEY_BACK = ""UnsavedChangesDialogFragment.Back"";

        /**
         * Creates a save changes dialog when the user selects a new header
         * @param position The new header index to make active if the user accepts the dialog. This
         * must be a valid header index although there is no error checking.
         */
        public static UnsavedChangesDialogFragment newInstanceForHeader(int position) {
            UnsavedChangesDialogFragment f = new UnsavedChangesDialogFragment();
            Bundle b = new Bundle();
            b.putInt(BUNDLE_KEY_HEADER, position);
            f.setArguments(b);
            return f;
        }

        /**
         * Creates a save changes dialog when the user navigates ""back"".
         * {@link #onBackPressed()} defines in which case this may be triggered.
         */
        public static UnsavedChangesDialogFragment newInstanceForBack() {
            UnsavedChangesDialogFragment f = new UnsavedChangesDialogFragment();
            Bundle b = new Bundle();
            b.putBoolean(BUNDLE_KEY_BACK, true);
            f.setArguments(b);
            return f;
        }

        // Force usage of newInstance()
        private UnsavedChangesDialogFragment() {
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            final AccountSettings activity = (AccountSettings) getActivity();
            final int position = getArguments().getInt(BUNDLE_KEY_HEADER);
            final boolean isBack = getArguments().getBoolean(BUNDLE_KEY_BACK);

            return new AlertDialog.Builder(activity)
                .setIconAttribute(android.R.attr.alertDialogIcon)
                .setTitle(android.R.string.dialog_alert_title)
                .setMessage(R.string.account_settings_exit_server_settings)
                .setPositiveButton(
                        R.string.okay_action,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                if (isBack) {
                                    activity.forceBack();
                                } else {
                                    activity.forceSwitchHeader(position);
                                }
                                dismiss();
                            }
                        })
                .setNegativeButton(
                        activity.getString(R.string.cancel_action), null)
                .create();
        }
    }

    /**
     * Dialog briefly shown in some cases, to indicate the user that login failed.  If the user
     * clicks OK, we simply dismiss the dialog, leaving the user in the account settings for
     * that account;  If the user clicks ""cancel"", we exit account settings.
     */
    public static class LoginWarningDialog extends DialogFragment
            implements DialogInterface.OnClickListener {
        private static final String BUNDLE_KEY_ACCOUNT_NAME = ""account_name"";

        /**
         * Create a new dialog.
         */
        public static LoginWarningDialog newInstance(String accountName) {
            final LoginWarningDialog dialog = new LoginWarningDialog();
            Bundle b = new Bundle();
            b.putString(BUNDLE_KEY_ACCOUNT_NAME, accountName);
            dialog.setArguments(b);
            return dialog;
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            final String accountName = getArguments().getString(BUNDLE_KEY_ACCOUNT_NAME);

            final Context context = getActivity();
            final Resources res = context.getResources();
            final AlertDialog.Builder b = new AlertDialog.Builder(context);
            b.setTitle(R.string.account_settings_login_dialog_title);
            b.setIconAttribute(android.R.attr.alertDialogIcon);
            b.setMessage(res.getString(R.string.account_settings_login_dialog_content_fmt,
                    accountName));
            b.setPositiveButton(R.string.okay_action, this);
            b.setNegativeButton(R.string.cancel_action, this);
            return b.create();
        }

        @Override
        public void onClick(DialogInterface dialog, int which) {
            dismiss();
            if (which == DialogInterface.BUTTON_NEGATIVE) {
                getActivity().finish();
            }
        }
    }
}
",True,268,1,1,10,55,7,16,L6
88,com.android.email.activity.setup.AccountSetupIncoming.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import com.android.email.R;
import com.android.email.activity.ActivityHelper;
import com.android.email.activity.UiUtilities;
import com.android.emailcommon.provider.Account;

import android.app.Activity;
import android.app.FragmentTransaction;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

/**
 * Provides setup flow for IMAP/POP accounts.
 *
 * Uses AccountSetupIncomingFragment for primary UI.  Uses AccountCheckSettingsFragment to validate
 * the settings as entered.  If the account is OK, proceeds to AccountSetupOutgoing.
 */
public class AccountSetupIncoming extends AccountSetupActivity
        implements AccountSetupIncomingFragment.Callback, OnClickListener {

    /* package */ AccountSetupIncomingFragment mFragment;
    private Button mNextButton;
    /* package */ boolean mNextButtonEnabled;

    public static void actionIncomingSettings(Activity fromActivity, int mode, Account account) {
        SetupData.setFlowMode(mode);
        SetupData.setAccount(account);
        fromActivity.startActivity(new Intent(fromActivity, AccountSetupIncoming.class));
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(R.layout.account_setup_incoming);

        mFragment = (AccountSetupIncomingFragment)
                getFragmentManager().findFragmentById(R.id.setup_fragment);

        // Configure fragment
        mFragment.setCallback(this);

        mNextButton = (Button) UiUtilities.getView(this, R.id.next);
        mNextButton.setOnClickListener(this);
        UiUtilities.getView(this, R.id.previous).setOnClickListener(this);
   }

    /**
     * Implements View.OnClickListener
     */
    @Override
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.next:
                mFragment.onNext();
                break;
            case R.id.previous:
                onBackPressed();
                break;
        }
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     *
     * Launches the account checker.  Positive results are reported to onCheckSettingsOk().
     */
    public void onProceedNext(int checkMode, AccountServerBaseFragment target) {
        AccountCheckSettingsFragment checkerFragment =
            AccountCheckSettingsFragment.newInstance(checkMode, target);
        FragmentTransaction transaction = getFragmentManager().beginTransaction();
        transaction.add(checkerFragment, AccountCheckSettingsFragment.TAG);
        transaction.addToBackStack(""back"");
        transaction.commit();
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     */
    public void onEnableProceedButtons(boolean enable) {
        mNextButtonEnabled = enable;
        mNextButton.setEnabled(enable);
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     *
     * If the checked settings are OK, proceed to outgoing settings screen
     */
    public void onCheckSettingsComplete(int result, int setupMode) {
        if (result == AccountCheckSettingsFragment.CHECK_SETTINGS_OK) {
            AccountSetupOutgoing.actionOutgoingSettings(this, SetupData.getFlowMode(),
                    SetupData.getAccount());
            finish();
        }
    }
}
",True,268,1,1,11,59,3,9,L6
89,com.android.email.activity.setup.AccountSetupOutgoing.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import com.android.email.R;
import com.android.email.activity.ActivityHelper;
import com.android.email.activity.UiUtilities;
import com.android.emailcommon.provider.Account;

import android.app.Activity;
import android.app.FragmentTransaction;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

/**
 * Provides setup flow for SMTP (for IMAP/POP accounts).
 *
 * Uses AccountSetupOutgoingFragment for primary UI.  Uses AccountCheckSettingsFragment to validate
 * the settings as entered.  If the account is OK, proceeds to AccountSetupOptions.
 */
public class AccountSetupOutgoing extends Activity
        implements AccountSetupOutgoingFragment.Callback, OnClickListener {

    /* package */ AccountSetupOutgoingFragment mFragment;
    private Button mNextButton;
    /* package */ boolean mNextButtonEnabled;

    public static void actionOutgoingSettings(Activity fromActivity, int mode, Account account) {
        SetupData.setFlowMode(mode);
        SetupData.setAccount(account);
        fromActivity.startActivity(new Intent(fromActivity, AccountSetupOutgoing.class));
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(R.layout.account_setup_outgoing);

        mFragment = (AccountSetupOutgoingFragment)
                getFragmentManager().findFragmentById(R.id.setup_fragment);

        // Configure fragment
        mFragment.setCallback(this);

        mNextButton = (Button) UiUtilities.getView(this, R.id.next);
        mNextButton.setOnClickListener(this);
        UiUtilities.getView(this, R.id.previous).setOnClickListener(this);
    }

    /**
     * Implements View.OnClickListener
     */
    @Override
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.next:
                mFragment.onNext();
                break;
            case R.id.previous:
                onBackPressed();
                break;
        }
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     *
     * Launches the account checker.  Positive results are reported to onCheckSettingsOk().
     */
    public void onProceedNext(int checkMode, AccountServerBaseFragment target) {
        AccountCheckSettingsFragment checkerFragment =
            AccountCheckSettingsFragment.newInstance(checkMode, target);
        FragmentTransaction transaction = getFragmentManager().beginTransaction();
        transaction.add(checkerFragment, AccountCheckSettingsFragment.TAG);
        transaction.addToBackStack(""back"");
        transaction.commit();
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     */
    public void onEnableProceedButtons(boolean enable) {
        mNextButtonEnabled = enable;
        mNextButton.setEnabled(enable);
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     *
     * If the checked settings are OK, proceed to options screen
     */
    public void onCheckSettingsComplete(int result, int setupMode) {
        if (result == AccountCheckSettingsFragment.CHECK_SETTINGS_OK) {
            AccountSetupOptions.actionOptions(this);
            finish();
        }
    }
}
",False,268,1,1,11,56,3,8,L6
90,com.android.email.activity.setup.AccountSetupExchangeFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.RemoteException;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.TextView;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.activity.UiUtilities;
import com.android.email.provider.AccountBackupRestore;
import com.android.email.service.EmailServiceUtils;
import com.android.email.view.CertificateSelector;
import com.android.email.view.CertificateSelector.HostCallback;
import com.android.emailcommon.Device;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.CertificateRequestor;
import com.android.emailcommon.utility.Utility;

import java.io.IOException;

/**
 * Provides generic setup for Exchange accounts.
 *
 * This fragment is used by AccountSetupExchange (for creating accounts) and by AccountSettingsXL
 * (for editing existing accounts).
 */
public class AccountSetupExchangeFragment extends AccountServerBaseFragment
        implements OnCheckedChangeListener, HostCallback {

    private static final int CERTIFICATE_REQUEST = 0;
    private final static String STATE_KEY_CREDENTIAL = ""AccountSetupExchangeFragment.credential"";
    private final static String STATE_KEY_LOADED = ""AccountSetupExchangeFragment.loaded"";

    private EditText mUsernameView;
    private EditText mPasswordView;
    private EditText mServerView;
    private CheckBox mSslSecurityView;
    private CheckBox mTrustCertificatesView;
    private CertificateSelector mClientCertificateSelector;

    // Support for lifecycle
    private boolean mStarted;
    /* package */ boolean mLoaded;
    private String mCacheLoginCredential;

    /**
     * Called to do initial creation of a fragment.  This is called after
     * {@link #onAttach(Activity)} and before {@link #onActivityCreated(Bundle)}.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onCreate"");
        }
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            mCacheLoginCredential = savedInstanceState.getString(STATE_KEY_CREDENTIAL);
            mLoaded = savedInstanceState.getBoolean(STATE_KEY_LOADED, false);
        }
        mBaseScheme = HostAuth.SCHEME_EAS;
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onCreateView"");
        }
        int layoutId = mSettingsMode
                ? R.layout.account_settings_exchange_fragment
                : R.layout.account_setup_exchange_fragment;

        View view = inflater.inflate(layoutId, container, false);
        final Context context = getActivity();

        mUsernameView = UiUtilities.getView(view, R.id.account_username);
        mPasswordView = UiUtilities.getView(view, R.id.account_password);
        mServerView = UiUtilities.getView(view, R.id.account_server);
        mSslSecurityView = UiUtilities.getView(view, R.id.account_ssl);
        mSslSecurityView.setOnCheckedChangeListener(this);
        mTrustCertificatesView = UiUtilities.getView(view, R.id.account_trust_certificates);
        mClientCertificateSelector = UiUtilities.getView(view, R.id.client_certificate_selector);

        // Calls validateFields() which enables or disables the Next button
        // based on the fields' validity.
        TextWatcher validationTextWatcher = new TextWatcher() {
            public void afterTextChanged(Editable s) {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after) { }
            public void onTextChanged(CharSequence s, int start, int before, int count) { }
        };
        // We're editing an existing account; don't allow modification of the user name
        if (mSettingsMode) {
            makeTextViewUneditable(mUsernameView,
                    getString(R.string.account_setup_username_uneditable_error));
        }
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);

        EditText lastView = mServerView;
        lastView.setOnEditorActionListener(mDismissImeOnDoneListener);

        String deviceId = """";
        try {
            deviceId = Device.getDeviceId(context);
        } catch (IOException e) {
            // Not required
        }
        ((TextView) UiUtilities.getView(view, R.id.device_id)).setText(deviceId);

        // Additional setup only used while in ""settings"" mode
        onCreateViewSettingsMode(view);

        return view;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onActivityCreated"");
        }
        super.onActivityCreated(savedInstanceState);
        mClientCertificateSelector.setHostActivity(this);
    }

    /**
     * Called when the Fragment is visible to the user.
     */
    @Override
    public void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onStart"");
        }
        super.onStart();
        mStarted = true;
        loadSettings(SetupData.getAccount());
    }

    /**
     * Called when the fragment is visible to the user and actively running.
     */
    @Override
    public void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onResume"");
        }
        super.onResume();
        validateFields();
    }

    @Override
    public void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onPause"");
        }
        super.onPause();
    }

    /**
     * Called when the Fragment is no longer started.
     */
    @Override
    public void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onStop"");
        }
        super.onStop();
        mStarted = false;
    }

    /**
     * Called when the fragment is no longer in use.
     */
    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onDestroy"");
        }
        super.onDestroy();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupExchangeFragment onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);

        outState.putString(STATE_KEY_CREDENTIAL, mCacheLoginCredential);
        outState.putBoolean(STATE_KEY_LOADED, mLoaded);
    }

    /**
     * Activity provides callbacks here.  This also triggers loading and setting up the UX
     */
    @Override
    public void setCallback(Callback callback) {
        super.setCallback(callback);
        if (mStarted) {
            loadSettings(SetupData.getAccount());
        }
    }

    /**
     * Force the given account settings to be loaded using {@link #loadSettings(Account)}.
     *
     * @return true if the loaded values pass validation
     */
    private boolean forceLoadSettings(Account account) {
        mLoaded = false;
        return loadSettings(account);
    }

    /**
     * Load the given account settings into the UI and then ensure the settings are valid.
     * As an optimization, if the settings have already been loaded, the UI will not be
     * updated, but, the account fields will still be validated.
     *
     * @return true if the loaded values pass validation
     */
    /*package*/ boolean loadSettings(Account account) {
        if (mLoaded) return validateFields();

        HostAuth hostAuth = account.mHostAuthRecv;

        String userName = hostAuth.mLogin;
        if (userName != null) {
            // Add a backslash to the start of the username, but only if the username has no
            // backslash in it.
            if (userName.indexOf('\\') < 0) {
                userName = ""\\"" + userName;
            }
            mUsernameView.setText(userName);
        }

        if (hostAuth.mPassword != null) {
            mPasswordView.setText(hostAuth.mPassword);
            // Since username is uneditable, focus on the next editable field
            if (mSettingsMode) {
                mPasswordView.requestFocus();
            }
        }

        String protocol = hostAuth.mProtocol;
        if (protocol == null || !protocol.startsWith(""eas"")) {
            throw new Error(""Unknown account type: "" + protocol);
        }

        if (hostAuth.mAddress != null) {
            mServerView.setText(hostAuth.mAddress);
        }

        boolean ssl = 0 != (hostAuth.mFlags & HostAuth.FLAG_SSL);
        boolean trustCertificates = 0 != (hostAuth.mFlags & HostAuth.FLAG_TRUST_ALL);
        mSslSecurityView.setChecked(ssl);
        mTrustCertificatesView.setChecked(trustCertificates);
        if (hostAuth.mClientCertAlias != null) {
            mClientCertificateSelector.setCertificate(hostAuth.mClientCertAlias);
        }
        onUseSslChanged(ssl);

        mLoadedRecvAuth = hostAuth;
        mLoaded = true;
        return validateFields();
    }

    private boolean usernameFieldValid(EditText usernameView) {
        return Utility.isTextViewNotEmpty(usernameView) &&
            !usernameView.getText().toString().equals(""\\"");
    }

    /**
     * Check the values in the fields and decide if it makes sense to enable the ""next"" button
     * @return true if all fields are valid, false if any fields are incomplete
     */
    private boolean validateFields() {
        if (!mLoaded) return false;
        boolean enabled = usernameFieldValid(mUsernameView)
                && Utility.isTextViewNotEmpty(mPasswordView)
                && Utility.isServerNameValid(mServerView);
        enableNextButton(enabled);

        // Warn (but don't prevent) if password has leading/trailing spaces
        AccountSettingsUtils.checkPasswordSpaces(mContext, mPasswordView);

        return enabled;
    }

    @Override
    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
        if (buttonView.getId() == R.id.account_ssl) {
            onUseSslChanged(isChecked);
        }
    }

    public void onUseSslChanged(boolean useSsl) {
        int mode = useSsl ? View.VISIBLE : View.GONE;
        mTrustCertificatesView.setVisibility(mode);
        UiUtilities.setVisibilitySafe(getView(), R.id.account_trust_certificates_divider, mode);
        mClientCertificateSelector.setVisibility(mode);
        UiUtilities.setVisibilitySafe(getView(), R.id.client_certificate_divider, mode);
    }

    @Override
    public void onCheckSettingsComplete(final int result) {
        if (result == AccountCheckSettingsFragment.CHECK_SETTINGS_CLIENT_CERTIFICATE_NEEDED) {
            mSslSecurityView.setChecked(true);
            onCertificateRequested();
            return;
        }
        super.onCheckSettingsComplete(result);
    }


    /**
     * Entry point from Activity after editing settings and verifying them.  Must be FLOW_MODE_EDIT.
     * Blocking - do not call from UI Thread.
     */
    @Override
    public void saveSettingsAfterEdit() {
        Account account = SetupData.getAccount();
        account.mHostAuthRecv.update(mContext, account.mHostAuthRecv.toContentValues());
        account.mHostAuthSend.update(mContext, account.mHostAuthSend.toContentValues());
        // For EAS, notify ExchangeService that the password has changed
        try {
            EmailServiceUtils.getExchangeService(mContext, null).hostChanged(account.mId);
        } catch (RemoteException e) {
            // Nothing to be done if this fails
        }
        // Update the backup (side copy) of the accounts
        AccountBackupRestore.backup(mContext);
    }

    /**
     * Entry point from Activity after entering new settings and verifying them.  For setup mode.
     */
    @Override
    public void saveSettingsAfterSetup() {
    }

    /**
     * Entry point from Activity after entering new settings and verifying them.  For setup mode.
     */
    public boolean setHostAuthFromAutodiscover(HostAuth newHostAuth) {
        Account account = SetupData.getAccount();
        account.mHostAuthSend = newHostAuth;
        account.mHostAuthRecv = newHostAuth;
        // Auto discovery may have changed the auth settings; force load them
        return forceLoadSettings(account);
    }

    /**
     * Implements AccountCheckSettingsFragment.Callbacks
     */
    @Override
    public void onAutoDiscoverComplete(int result, HostAuth hostAuth) {
        AccountSetupExchange activity = (AccountSetupExchange) getActivity();
        activity.onAutoDiscoverComplete(result, hostAuth);
    }

    /**
     * Entry point from Activity, when ""next"" button is clicked
     */
    @Override
    public void onNext() {
        Account account = SetupData.getAccount();

        String userName = mUsernameView.getText().toString().trim();
        if (userName.startsWith(""\\"")) {
            userName = userName.substring(1);
        }
        mCacheLoginCredential = userName;
        String userPassword = mPasswordView.getText().toString();

        int flags = 0;
        if (mSslSecurityView.isChecked()) {
            flags |= HostAuth.FLAG_SSL;
        }
        if (mTrustCertificatesView.isChecked()) {
            flags |= HostAuth.FLAG_TRUST_ALL;
        }
        String certAlias = mClientCertificateSelector.getCertificate();
        String serverAddress = mServerView.getText().toString().trim();

        int port = mSslSecurityView.isChecked() ? 443 : 80;
        HostAuth sendAuth = account.getOrCreateHostAuthSend(mContext);
        sendAuth.setLogin(userName, userPassword);
        sendAuth.setConnection(mBaseScheme, serverAddress, port, flags, certAlias);
        sendAuth.mDomain = null;

        HostAuth recvAuth = account.getOrCreateHostAuthRecv(mContext);
        recvAuth.setLogin(userName, userPassword);
        recvAuth.setConnection(mBaseScheme, serverAddress, port, flags, certAlias);
        recvAuth.mDomain = null;

        // Check for a duplicate account (requires async DB work) and if OK, proceed with check
        startDuplicateTaskCheck(account.mId, serverAddress, mCacheLoginCredential,
                SetupData.CHECK_INCOMING);
    }

    @Override
    public void onCertificateRequested() {
        Intent intent = new Intent(CertificateRequestor.ACTION_REQUEST_CERT);
        intent.setData(Uri.parse(""eas://com.android.emailcommon/certrequest""));
        startActivityForResult(intent, CERTIFICATE_REQUEST);
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == CERTIFICATE_REQUEST && resultCode == Activity.RESULT_OK) {
            String certAlias = data.getStringExtra(CertificateRequestor.RESULT_ALIAS);
            if (certAlias != null) {
                mClientCertificateSelector.setCertificate(certAlias);
            }
        }
    }

}
",True,268,1,1,11,48,2,17,L6
91,com.android.email.activity.setup.AccountSetupAccountType.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

import com.android.email.R;
import com.android.email.VendorPolicyLoader;
import com.android.email.activity.ActivityHelper;
import com.android.email.activity.UiUtilities;
import com.android.email.service.EmailServiceUtils;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;

/**
 * Prompts the user to select an account type. The account type, along with the
 * passed in email address, password and makeDefault are then passed on to the
 * AccountSetupIncoming activity.
 */
public class AccountSetupAccountType extends AccountSetupActivity implements OnClickListener {

    public static void actionSelectAccountType(Activity fromActivity) {
        fromActivity.startActivity(new Intent(fromActivity, AccountSetupAccountType.class));
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        int flowMode = SetupData.getFlowMode();

        // If we're in account setup flow mode, for EAS, skip this screen and ""click"" EAS
        if (flowMode == SetupData.FLOW_MODE_ACCOUNT_MANAGER_EAS) {
            onExchange();
            return;
        }

        // Otherwise proceed into this screen
        setContentView(R.layout.account_setup_account_type);
        UiUtilities.getView(this, R.id.pop).setOnClickListener(this);
        UiUtilities.getView(this, R.id.imap).setOnClickListener(this);
        final Button exchangeButton = (Button) UiUtilities.getView(this, R.id.exchange);
        exchangeButton.setVisibility(View.INVISIBLE);
        final Button previousButton = (Button) findViewById(R.id.previous); // xlarge only
        if (previousButton != null) previousButton.setOnClickListener(this);

        // TODO If we decide to exclude the Exchange option in POP_IMAP mode, use the following line
        // instead of the line that follows it
        //if (ExchangeUtils.isExchangeAvailable(this) && flowMode != SetupData.FLOW_MODE_POP_IMAP) {
        if (EmailServiceUtils.isExchangeAvailable(this)) {
            exchangeButton.setOnClickListener(this);
            exchangeButton.setVisibility(View.VISIBLE);
            if (VendorPolicyLoader.getInstance(this).useAlternateExchangeStrings()) {
                exchangeButton.setText(
                        R.string.account_setup_account_type_exchange_action_alternate);
            }
        }
        // TODO: Dynamic creation of buttons, instead of just hiding things we don't need
    }

    /**
     * For POP accounts, we rewrite the username to the full user@domain, and we set the
     * default server name to pop3.domain
     */
    private void onPop() {
        Account account = SetupData.getAccount();
        HostAuth hostAuth = account.mHostAuthRecv;
        hostAuth.mProtocol = HostAuth.SCHEME_POP3;
        hostAuth.mLogin = hostAuth.mLogin + ""@"" + hostAuth.mAddress;
        hostAuth.mAddress = AccountSettingsUtils.inferServerName(hostAuth.mAddress,
                HostAuth.SCHEME_POP3, null);
        AccountSetupBasics.setFlagsForProtocol(account, HostAuth.SCHEME_POP3);
        SetupData.setCheckSettingsMode(SetupData.CHECK_INCOMING | SetupData.CHECK_OUTGOING);
        AccountSetupIncoming.actionIncomingSettings(this, SetupData.getFlowMode(), account);
        finish();
    }

    /**
     * The user has selected an IMAP account type.  Try to put together a URI using the entered
     * email address.  Also set the mail delete policy here, because there is no UI (for IMAP).
     */
    private void onImap() {
        Account account = SetupData.getAccount();
        HostAuth hostAuth = account.mHostAuthRecv;
        hostAuth.mProtocol = HostAuth.SCHEME_IMAP;
        hostAuth.mLogin = hostAuth.mLogin + ""@"" + hostAuth.mAddress;
        hostAuth.mAddress = AccountSettingsUtils.inferServerName(hostAuth.mAddress,
                HostAuth.SCHEME_IMAP, null);
        AccountSetupBasics.setFlagsForProtocol(account, HostAuth.SCHEME_IMAP);
        SetupData.setCheckSettingsMode(SetupData.CHECK_INCOMING | SetupData.CHECK_OUTGOING);
        AccountSetupIncoming.actionIncomingSettings(this, SetupData.getFlowMode(), account);
        finish();
    }

    /**
     * The user has selected an exchange account type. Set the mail delete policy here, because
     * there is no UI (for exchange), and switch the default sync interval to ""push"".
     */
    private void onExchange() {
        Account account = SetupData.getAccount();
        HostAuth recvAuth = account.getOrCreateHostAuthRecv(this);
        recvAuth.setConnection(HostAuth.SCHEME_EAS, recvAuth.mAddress, recvAuth.mPort,
                recvAuth.mFlags | HostAuth.FLAG_SSL);
        HostAuth sendAuth = account.getOrCreateHostAuthSend(this);
        sendAuth.setConnection(HostAuth.SCHEME_EAS, sendAuth.mAddress, sendAuth.mPort,
                sendAuth.mFlags | HostAuth.FLAG_SSL);
        AccountSetupBasics.setFlagsForProtocol(account, HostAuth.SCHEME_EAS);
        SetupData.setCheckSettingsMode(SetupData.CHECK_AUTODISCOVER);
        AccountSetupExchange.actionIncomingSettings(this, SetupData.getFlowMode(), account);
        finish();
    }

    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.pop:
                onPop();
                break;
            case R.id.imap:
                onImap();
                break;
            case R.id.exchange:
                onExchange();
                break;
            case R.id.previous:
                finish();
                break;
        }
    }
}
",True,268,1,1,11,50,2,12,L6
92,com.android.email.activity.setup.DuplicateAccountDialogFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import com.android.email.R;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.Context;
import android.content.DialogInterface;
import android.os.Bundle;

/**
 * Dialog fragment to show ""duplicate account"" dialog
 */
public class DuplicateAccountDialogFragment extends DialogFragment {
    public final static String TAG = ""DuplicateAccountDialogFragment"";

    // Argument bundle keys
    private final static String BUNDLE_KEY_ACCOUNT_NAME = ""NoteDialogFragment.AccountName"";

    /**
     * Create the dialog with parameters
     */
    public static DuplicateAccountDialogFragment newInstance(String note) {
        DuplicateAccountDialogFragment f = new DuplicateAccountDialogFragment();
        Bundle b = new Bundle();
        b.putString(BUNDLE_KEY_ACCOUNT_NAME, note);
        f.setArguments(b);
        return f;
    }

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        Context context = getActivity();
        String accountName = getArguments().getString(BUNDLE_KEY_ACCOUNT_NAME);

        return new AlertDialog.Builder(context)
            .setIconAttribute(android.R.attr.alertDialogIcon)
            .setTitle(R.string.account_duplicate_dlg_title)
            .setMessage(context.getString(
                    R.string.account_duplicate_dlg_message_fmt, accountName))
            .setPositiveButton(
                    R.string.okay_action,
                    new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog, int which) {
                            dismiss();
                        }
                    })
            .create();
    }
}
",False,147,9,40,0,0,2,0,L6
93,com.android.email.activity.setup.AccountSettingsUtils.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.content.ContentValues;
import android.content.Context;
import android.content.res.XmlResourceParser;
import android.text.Editable;
import android.util.Log;
import android.widget.EditText;

import com.android.email.R;
import com.android.email.VendorPolicyLoader;
import com.android.email.provider.AccountBackupRestore;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.google.common.annotations.VisibleForTesting;

import java.io.Serializable;

public class AccountSettingsUtils {

    /** Pattern to match any part of a domain */
    private final static String WILD_STRING = ""*"";
    /** Will match any, single character */
    private final static char WILD_CHARACTER = '?';
    private final static String DOMAIN_SEPARATOR = ""\\."";

    /**
     * Commits the UI-related settings of an account to the provider.  This is static so that it
     * can be used by the various account activities.  If the account has never been saved, this
     * method saves it; otherwise, it just saves the settings.
     * @param context the context of the caller
     * @param account the account whose settings will be committed
     */
    public static void commitSettings(Context context, Account account) {
        if (!account.isSaved()) {
            account.save(context);
        } else {
            ContentValues cv = getAccountContentValues(account);
            account.update(context, cv);
        }
        // Update the backup (side copy) of the accounts
        AccountBackupRestore.backup(context);
    }

    /**
     * Returns a set of content values to commit account changes (not including the foreign keys
     * for the two host auth's and policy) to the database.  Does not actually commit anything.
     */
    public static ContentValues getAccountContentValues(Account account) {
        ContentValues cv = new ContentValues();
        cv.put(AccountColumns.IS_DEFAULT, account.mIsDefault);
        cv.put(AccountColumns.DISPLAY_NAME, account.getDisplayName());
        cv.put(AccountColumns.SENDER_NAME, account.getSenderName());
        cv.put(AccountColumns.SIGNATURE, account.getSignature());
        cv.put(AccountColumns.SYNC_INTERVAL, account.mSyncInterval);
        cv.put(AccountColumns.RINGTONE_URI, account.mRingtoneUri);
        cv.put(AccountColumns.FLAGS, account.mFlags);
        cv.put(AccountColumns.SYNC_LOOKBACK, account.mSyncLookback);
        cv.put(AccountColumns.SECURITY_SYNC_KEY, account.mSecuritySyncKey);
        return cv;
    }

    /**
     * Search the list of known Email providers looking for one that matches the user's email
     * domain.  We check for vendor supplied values first, then we look in providers_product.xml,
     * and finally by the entries in platform providers.xml.  This provides a nominal override
     * capability.
     *
     * A match is defined as any provider entry for which the ""domain"" attribute matches.
     *
     * @param domain The domain portion of the user's email address
     * @return suitable Provider definition, or null if no match found
     */
    public static Provider findProviderForDomain(Context context, String domain) {
        Provider p = VendorPolicyLoader.getInstance(context).findProviderForDomain(domain);
        if (p == null) {
            p = findProviderForDomain(context, domain, R.xml.providers_product);
        }
        if (p == null) {
            p = findProviderForDomain(context, domain, R.xml.providers);
        }
        return p;
    }

    /**
     * Search a single resource containing known Email provider definitions.
     *
     * @param domain The domain portion of the user's email address
     * @param resourceId Id of the provider resource to scan
     * @return suitable Provider definition, or null if no match found
     */
    /*package*/ static Provider findProviderForDomain(
            Context context, String domain, int resourceId) {
        try {
            XmlResourceParser xml = context.getResources().getXml(resourceId);
            int xmlEventType;
            Provider provider = null;
            while ((xmlEventType = xml.next()) != XmlResourceParser.END_DOCUMENT) {
                if (xmlEventType == XmlResourceParser.START_TAG
                        && ""provider"".equals(xml.getName())) {
                    String providerDomain = getXmlAttribute(context, xml, ""domain"");
                    try {
                        if (matchProvider(domain, providerDomain)) {
                            provider = new Provider();
                            provider.id = getXmlAttribute(context, xml, ""id"");
                            provider.label = getXmlAttribute(context, xml, ""label"");
                            provider.domain = domain.toLowerCase();
                            provider.note = getXmlAttribute(context, xml, ""note"");
                        }
                    } catch (IllegalArgumentException e) {
                        Log.w(Logging.LOG_TAG, ""providers line: "" + xml.getLineNumber() +
                                ""; Domain contains multiple globals"");
                    }
                }
                else if (xmlEventType == XmlResourceParser.START_TAG
                        && ""incoming"".equals(xml.getName())
                        && provider != null) {
                    provider.incomingUriTemplate = getXmlAttribute(context, xml, ""uri"");
                    provider.incomingUsernameTemplate = getXmlAttribute(context, xml, ""username"");
                }
                else if (xmlEventType == XmlResourceParser.START_TAG
                        && ""outgoing"".equals(xml.getName())
                        && provider != null) {
                    provider.outgoingUriTemplate = getXmlAttribute(context, xml, ""uri"");
                    provider.outgoingUsernameTemplate = getXmlAttribute(context, xml, ""username"");
                }
                else if (xmlEventType == XmlResourceParser.END_TAG
                        && ""provider"".equals(xml.getName())
                        && provider != null) {
                    return provider;
                }
            }
        }
        catch (Exception e) {
            Log.e(Logging.LOG_TAG, ""Error while trying to load provider settings."", e);
        }
        return null;
    }

    /**
     * Returns true if the string <code>s1</code> matches the string <code>s2</code>. The string
     * <code>s2</code> may contain any number of wildcards -- a '?' character -- and/or asterisk
     * characters -- '*'. Wildcards match any single character, while the asterisk matches a domain
     * part (i.e. substring demarcated by a period, '.')
     */
    @VisibleForTesting
    static boolean matchProvider(String testDomain, String providerDomain) {
        String[] testParts = testDomain.split(DOMAIN_SEPARATOR);
        String[] providerParts = providerDomain.split(DOMAIN_SEPARATOR);
        if (testParts.length != providerParts.length) {
            return false;
        }
        for (int i = 0; i < testParts.length; i++) {
            String testPart = testParts[i].toLowerCase();
            String providerPart = providerParts[i].toLowerCase();
            if (!providerPart.equals(WILD_STRING) &&
                    !matchWithWildcards(testPart, providerPart)) {
                return false;
            }
        }
        return true;
    }

    private static boolean matchWithWildcards(String testPart, String providerPart) {
        int providerLength = providerPart.length();
        if (testPart.length() != providerLength){
            return false;
        }
        for (int i = 0; i < providerLength; i++) {
            char testChar = testPart.charAt(i);
            char providerChar = providerPart.charAt(i);
            if (testChar != providerChar && providerChar != WILD_CHARACTER) {
                return false;
            }
        }
        return true;
    }

    /**
     * Attempts to get the given attribute as a String resource first, and if it fails
     * returns the attribute as a simple String value.
     * @param xml
     * @param name
     * @return the requested resource
     */
    private static String getXmlAttribute(Context context, XmlResourceParser xml, String name) {
        int resId = xml.getAttributeResourceValue(null, name, 0);
        if (resId == 0) {
            return xml.getAttributeValue(null, name);
        }
        else {
            return context.getString(resId);
        }
    }

    public static class Provider implements Serializable {
        private static final long serialVersionUID = 8511656164616538989L;

        public String id;
        public String label;
        public String domain;
        public String incomingUriTemplate;
        public String incomingUsernameTemplate;
        public String outgoingUriTemplate;
        public String outgoingUsernameTemplate;
        public String incomingUri;
        public String incomingUsername;
        public String outgoingUri;
        public String outgoingUsername;
        public String note;

        /**
         * Expands templates in all of the  provider fields that support them. Currently,
         * templates are used in 4 fields -- incoming and outgoing URI and user name.
         * @param email user-specified data used to replace template values
         */
        public void expandTemplates(String email) {
            String[] emailParts = email.split(""@"");
            String user = emailParts[0];

            incomingUri = expandTemplate(incomingUriTemplate, email, user);
            incomingUsername = expandTemplate(incomingUsernameTemplate, email, user);
            outgoingUri = expandTemplate(outgoingUriTemplate, email, user);
            outgoingUsername = expandTemplate(outgoingUsernameTemplate, email, user);
        }

        /**
         * Replaces all parameterized values in the given template. The values replaced are
         * $domain, $user and $email.
         */
        private String expandTemplate(String template, String email, String user) {
            String returnString = template;
            returnString = returnString.replaceAll(""\\$email"", email);
            returnString = returnString.replaceAll(""\\$user"", user);
            returnString = returnString.replaceAll(""\\$domain"", domain);
            return returnString;
        }
    }

    /**
     * Infer potential email server addresses from domain names
     *
     * Incoming: Prepend ""imap"" or ""pop3"" to domain, unless ""pop"", ""pop3"",
     *          ""imap"", or ""mail"" are found.
     * Outgoing: Prepend ""smtp"" if ""pop"", ""pop3"", ""imap"" are found.
     *          Leave ""mail"" as-is.
     * TBD: Are there any useful defaults for exchange?
     *
     * @param server name as we know it so far
     * @param incoming ""pop3"" or ""imap"" (or null)
     * @param outgoing ""smtp"" or null
     * @return the post-processed name for use in the UI
     */
    public static String inferServerName(String server, String incoming, String outgoing) {
        // Default values cause entire string to be kept, with prepended server string
        int keepFirstChar = 0;
        int firstDotIndex = server.indexOf('.');
        if (firstDotIndex != -1) {
            // look at first word and decide what to do
            String firstWord = server.substring(0, firstDotIndex).toLowerCase();
            boolean isImapOrPop = ""imap"".equals(firstWord)
                    || ""pop3"".equals(firstWord) || ""pop"".equals(firstWord);
            boolean isMail = ""mail"".equals(firstWord);
            // Now decide what to do
            if (incoming != null) {
                // For incoming, we leave imap/pop/pop3/mail alone, or prepend incoming
                if (isImapOrPop || isMail) {
                    return server;
                }
            } else {
                // For outgoing, replace imap/pop/pop3 with outgoing, leave mail alone, or
                // prepend outgoing
                if (isImapOrPop) {
                    keepFirstChar = firstDotIndex + 1;
                } else if (isMail) {
                    return server;
                } else {
                    // prepend
                }
            }
        }
        return ((incoming != null) ? incoming : outgoing) + '.' + server.substring(keepFirstChar);
    }

    /**
     * Helper to set error status on password fields that have leading or trailing spaces
     */
    public static void checkPasswordSpaces(Context context, EditText passwordField) {
        Editable password = passwordField.getText();
        int length = password.length();
        if (length > 0) {
            if (password.charAt(0) == ' ' || password.charAt(length-1) == ' ') {
                passwordField.setError(context.getString(R.string.account_password_spaces_error));
            }
        }
    }

}
",True,269,1,2,13,41,10,5,L6
94,com.android.email.activity.setup.AccountSetupExchange.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import com.android.email.R;
import com.android.email.activity.ActivityHelper;
import com.android.email.activity.UiUtilities;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;

import android.app.Activity;
import android.app.FragmentTransaction;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;

/**
 * Provides generic setup for Exchange accounts.  The following fields are supported:
 *
 *  Email Address   (from previous setup screen)
 *  Server
 *  Domain
 *  Requires SSL?
 *  User (login)
 *  Password
 *
 * There are two primary paths through this activity:
 *   Edit existing:
 *     Load existing values from account into fields
 *     When user clicks 'next':
 *       Confirm not a duplicate account
 *       Try new values (check settings)
 *       If new values are OK:
 *         Write new values (save to provider)
 *         finish() (pop to previous)
 *
 *   Creating New:
 *     Try Auto-discover to get details from server
 *     If Auto-discover reports an authentication failure:
 *       finish() (pop to previous, to re-enter username & password)
 *     If Auto-discover succeeds:
 *       write server's account details into account
 *     Load values from account into fields
 *     Confirm not a duplicate account
 *     Try new values (check settings)
 *     If new values are OK:
 *       Write new values (save to provider)
 *       Proceed to options screen
 *       finish() (removes self from back stack)
 */
public class AccountSetupExchange extends AccountSetupActivity
        implements AccountSetupExchangeFragment.Callback, OnClickListener {

    // Keys for savedInstanceState
    private final static String STATE_STARTED_AUTODISCOVERY =
            ""AccountSetupExchange.StartedAutoDiscovery"";

    boolean mStartedAutoDiscovery;
    /* package */ AccountSetupExchangeFragment mFragment;
    private Button mNextButton;
    /* package */ boolean mNextButtonEnabled;

    public static void actionIncomingSettings(Activity fromActivity, int mode, Account account) {
        SetupData.setFlowMode(mode);
        SetupData.setAccount(account);
        fromActivity.startActivity(new Intent(fromActivity, AccountSetupExchange.class));
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);
        setContentView(R.layout.account_setup_exchange);

        mFragment = (AccountSetupExchangeFragment)
                getFragmentManager().findFragmentById(R.id.setup_fragment);
        mFragment.setCallback(this);

        mNextButton = (Button) UiUtilities.getView(this, R.id.next);
        mNextButton.setOnClickListener(this);
        UiUtilities.getView(this, R.id.previous).setOnClickListener(this);

        // One-shot to launch autodiscovery at the entry to this activity (but not if it restarts)
        mStartedAutoDiscovery = false;
        if (savedInstanceState != null) {
            mStartedAutoDiscovery = savedInstanceState.getBoolean(STATE_STARTED_AUTODISCOVERY);
        }
        if (!mStartedAutoDiscovery) {
            startAutoDiscover();
        }
    }

    /**
     * Implements View.OnClickListener
     */
    @Override
    public void onClick(View view) {
        switch (view.getId()) {
            case R.id.next:
                mFragment.onNext();
                break;
            case R.id.previous:
                onBackPressed();
                break;
        }
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putBoolean(STATE_STARTED_AUTODISCOVERY, mStartedAutoDiscovery);
    }

    /**
     * If the conditions are right, launch the autodiscover fragment.  If it succeeds (even
     * partially) it will prefill the setup fields and we can proceed as if the user entered them.
     *
     * Conditions for skipping:
     *  Editing existing account
     *  AutoDiscover blocked (used for unit testing only)
     *  Username or password not entered yet
     */
    private void startAutoDiscover() {
        // Note that we've started autodiscovery - even if we decide not to do it,
        // this prevents repeating.
        mStartedAutoDiscovery = true;

        if (!SetupData.isAllowAutodiscover()) {
            return;
        }

        Account account = SetupData.getAccount();
        // If we've got a username and password and we're NOT editing, try autodiscover
        String username = account.mHostAuthRecv.mLogin;
        String password = account.mHostAuthRecv.mPassword;
        if (username != null && password != null) {
            onProceedNext(SetupData.CHECK_AUTODISCOVER, mFragment);
        }
    }

    /**
     * Implements AccountCheckSettingsFragment.Callbacks
     *
     * @param result configuration data returned by AD server, or null if no data available
     */
    public void onAutoDiscoverComplete(int result, HostAuth hostAuth) {
        // If authentication failed, exit immediately (to re-enter credentials)
        if (result == AccountCheckSettingsFragment.AUTODISCOVER_AUTHENTICATION) {
            finish();
            return;
        }

        // If data was returned, populate the account & populate the UI fields and validate it
        if (result == AccountCheckSettingsFragment.AUTODISCOVER_OK) {
            boolean valid = mFragment.setHostAuthFromAutodiscover(hostAuth);
            if (valid) {
                // ""click"" next to launch server verification
                mFragment.onNext();
            }
        }
        // Otherwise, proceed into this activity for manual setup
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     */
    public void onProceedNext(int checkMode, AccountServerBaseFragment target) {
        AccountCheckSettingsFragment checkerFragment =
            AccountCheckSettingsFragment.newInstance(checkMode, target);
        FragmentTransaction transaction = getFragmentManager().beginTransaction();
        transaction.add(checkerFragment, AccountCheckSettingsFragment.TAG);
        transaction.addToBackStack(""back"");
        transaction.commit();
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     */
    public void onEnableProceedButtons(boolean enable) {
        mNextButtonEnabled = enable;
        mNextButton.setEnabled(enable);
    }

    /**
     * Implements AccountServerBaseFragment.Callback
     *
     * If the checked settings are OK, proceed to options screen.  If the user rejects security,
     * exit this screen.  For all other errors, remain here for editing.
     */
    public void onCheckSettingsComplete(int result, int setupMode) {
        switch (result) {
            case AccountCheckSettingsFragment.CHECK_SETTINGS_OK:
                AccountSetupOptions.actionOptions(this);
                finish();
                break;
            case AccountCheckSettingsFragment.CHECK_SETTINGS_SECURITY_USER_DENY:
                finish();
                break;
            default:
            case AccountCheckSettingsFragment.CHECK_SETTINGS_SERVER_ERROR:
                // Do nothing - remain in this screen
                break;
        }
    }
}
",True,268,1,1,11,55,4,10,L6
95,com.android.email.activity.setup.AccountSetupIncomingFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.text.method.DigitsKeyListener;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.EditorInfo;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.Spinner;
import android.widget.TextView;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.activity.UiUtilities;
import com.android.email.provider.AccountBackupRestore;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.Utility;

/**
 * Provides UI for IMAP/POP account settings.
 *
 * This fragment is used by AccountSetupIncoming (for creating accounts) and by AccountSettingsXL
 * (for editing existing accounts).
 */
public class AccountSetupIncomingFragment extends AccountServerBaseFragment {

    private final static String STATE_KEY_CREDENTIAL = ""AccountSetupIncomingFragment.credential"";
    private final static String STATE_KEY_LOADED = ""AccountSetupIncomingFragment.loaded"";

    private static final int POP3_PORT_NORMAL = 110;
    private static final int POP3_PORT_SSL = 995;

    private static final int IMAP_PORT_NORMAL = 143;
    private static final int IMAP_PORT_SSL = 993;

    private EditText mUsernameView;
    private EditText mPasswordView;
    private TextView mServerLabelView;
    private EditText mServerView;
    private EditText mPortView;
    private Spinner mSecurityTypeView;
    private TextView mDeletePolicyLabelView;
    private Spinner mDeletePolicyView;
    private View mImapPathPrefixSectionView;
    private EditText mImapPathPrefixView;
    // Delete policy as loaded from the device
    private int mLoadedDeletePolicy;

    // Support for lifecycle
    private boolean mStarted;
    private boolean mConfigured;
    private boolean mLoaded;
    private String mCacheLoginCredential;

    /**
     * Called to do initial creation of a fragment.  This is called after
     * {@link #onAttach(Activity)} and before {@link #onActivityCreated(Bundle)}.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onCreate"");
        }
        super.onCreate(savedInstanceState);

        if (savedInstanceState != null) {
            mCacheLoginCredential = savedInstanceState.getString(STATE_KEY_CREDENTIAL);
            mLoaded = savedInstanceState.getBoolean(STATE_KEY_LOADED, false);
        }
    }

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onCreateView"");
        }
        int layoutId = mSettingsMode
                ? R.layout.account_settings_incoming_fragment
                : R.layout.account_setup_incoming_fragment;

        View view = inflater.inflate(layoutId, container, false);
        Context context = getActivity();

        mUsernameView = (EditText) UiUtilities.getView(view, R.id.account_username);
        mPasswordView = (EditText) UiUtilities.getView(view, R.id.account_password);
        mServerLabelView = (TextView) UiUtilities.getView(view, R.id.account_server_label);
        mServerView = (EditText) UiUtilities.getView(view, R.id.account_server);
        mPortView = (EditText) UiUtilities.getView(view, R.id.account_port);
        mSecurityTypeView = (Spinner) UiUtilities.getView(view, R.id.account_security_type);
        mDeletePolicyLabelView = (TextView) UiUtilities.getView(view,
                R.id.account_delete_policy_label);
        mDeletePolicyView = (Spinner) UiUtilities.getView(view, R.id.account_delete_policy);
        mImapPathPrefixSectionView = UiUtilities.getView(view, R.id.imap_path_prefix_section);
        mImapPathPrefixView = (EditText) UiUtilities.getView(view, R.id.imap_path_prefix);

        // Set up spinners
        SpinnerOption securityTypes[] = {
            new SpinnerOption(HostAuth.FLAG_NONE, context.getString(
                    R.string.account_setup_incoming_security_none_label)),
            new SpinnerOption(HostAuth.FLAG_SSL, context.getString(
                    R.string.account_setup_incoming_security_ssl_label)),
            new SpinnerOption(HostAuth.FLAG_SSL | HostAuth.FLAG_TRUST_ALL, context.getString(
                    R.string.account_setup_incoming_security_ssl_trust_certificates_label)),
            new SpinnerOption(HostAuth.FLAG_TLS, context.getString(
                    R.string.account_setup_incoming_security_tls_label)),
            new SpinnerOption(HostAuth.FLAG_TLS | HostAuth.FLAG_TRUST_ALL, context.getString(
                    R.string.account_setup_incoming_security_tls_trust_certificates_label)),
        };

        SpinnerOption deletePolicies[] = {
            new SpinnerOption(Account.DELETE_POLICY_NEVER,
                    context.getString(R.string.account_setup_incoming_delete_policy_never_label)),
            new SpinnerOption(Account.DELETE_POLICY_ON_DELETE,
                    context.getString(R.string.account_setup_incoming_delete_policy_delete_label)),
        };

        ArrayAdapter<SpinnerOption> securityTypesAdapter = new ArrayAdapter<SpinnerOption>(context,
                android.R.layout.simple_spinner_item, securityTypes);
        securityTypesAdapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        mSecurityTypeView.setAdapter(securityTypesAdapter);

        ArrayAdapter<SpinnerOption> deletePoliciesAdapter = new ArrayAdapter<SpinnerOption>(context,
                android.R.layout.simple_spinner_item, deletePolicies);
        deletePoliciesAdapter.setDropDownViewResource(
                android.R.layout.simple_spinner_dropdown_item);
        mDeletePolicyView.setAdapter(deletePoliciesAdapter);

        // Updates the port when the user changes the security type. This allows
        // us to show a reasonable default which the user can change.
        mSecurityTypeView.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
            public void onItemSelected(AdapterView<?> arg0, View arg1, int arg2, long arg3) {
                updatePortFromSecurityType();
            }

            public void onNothingSelected(AdapterView<?> arg0) { }
        });

        // After any text edits, call validateFields() which enables or disables the Next button
        TextWatcher validationTextWatcher = new TextWatcher() {
            public void afterTextChanged(Editable s) {
                validateFields();
            }

            public void beforeTextChanged(CharSequence s, int start, int count, int after) { }
            public void onTextChanged(CharSequence s, int start, int before, int count) { }
        };
        // We're editing an existing account; don't allow modification of the user name
        if (mSettingsMode) {
            makeTextViewUneditable(mUsernameView,
                    getString(R.string.account_setup_username_uneditable_error));
        }
        mUsernameView.addTextChangedListener(validationTextWatcher);
        mPasswordView.addTextChangedListener(validationTextWatcher);
        mServerView.addTextChangedListener(validationTextWatcher);
        mPortView.addTextChangedListener(validationTextWatcher);

        // Only allow digits in the port field.
        mPortView.setKeyListener(DigitsKeyListener.getInstance(""0123456789""));

        // Additional setup only used while in ""settings"" mode
        onCreateViewSettingsMode(view);

        return view;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onActivityCreated"");
        }
        super.onActivityCreated(savedInstanceState);
    }

    /**
     * Called when the Fragment is visible to the user.
     */
    @Override
    public void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onStart"");
        }
        super.onStart();
        mStarted = true;
        configureEditor();
        loadSettings();
    }

    /**
     * Called when the fragment is visible to the user and actively running.
     */
    @Override
    public void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onResume"");
        }
        super.onResume();
        validateFields();
    }

    @Override
    public void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onPause"");
        }
        super.onPause();
    }

    /**
     * Called when the Fragment is no longer started.
     */
    @Override
    public void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onStop"");
        }
        super.onStop();
        mStarted = false;
    }

    /**
     * Called when the fragment is no longer in use.
     */
    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onDestroy"");
        }
        super.onDestroy();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSetupIncomingFragment onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);

        outState.putString(STATE_KEY_CREDENTIAL, mCacheLoginCredential);
        outState.putBoolean(STATE_KEY_LOADED, mLoaded);
    }

    /**
     * Activity provides callbacks here.  This also triggers loading and setting up the UX
     */
    @Override
    public void setCallback(Callback callback) {
        super.setCallback(callback);
        if (mStarted) {
            configureEditor();
            loadSettings();
        }
    }

    /**
     * Configure the editor for the account type
     */
    private void configureEditor() {
        if (mConfigured) return;
        Account account = SetupData.getAccount();
        TextView lastView = mImapPathPrefixView;
        mBaseScheme = account.mHostAuthRecv.mProtocol;
        if (HostAuth.SCHEME_POP3.equals(mBaseScheme)) {
            mServerLabelView.setText(R.string.account_setup_incoming_pop_server_label);
            mServerView.setContentDescription(
                    getResources().getString(R.string.account_setup_incoming_pop_server_label));
            mImapPathPrefixSectionView.setVisibility(View.GONE);
            lastView = mPortView;
        } else if (HostAuth.SCHEME_IMAP.equals(mBaseScheme)) {
            mServerLabelView.setText(R.string.account_setup_incoming_imap_server_label);
            mServerView.setContentDescription(
                    getResources().getString(R.string.account_setup_incoming_imap_server_label));
            mDeletePolicyLabelView.setVisibility(View.GONE);
            mDeletePolicyView.setVisibility(View.GONE);
            mPortView.setImeOptions(EditorInfo.IME_ACTION_NEXT);
        } else {
            throw new Error(""Unknown account type: "" + account);
        }
        lastView.setOnEditorActionListener(mDismissImeOnDoneListener);
        mConfigured = true;
    }

    /**
     * Load the current settings into the UI
     */
    private void loadSettings() {
        if (mLoaded) return;

        Account account = SetupData.getAccount();
        HostAuth recvAuth = account.getOrCreateHostAuthRecv(mContext);

        String username = recvAuth.mLogin;
        if (username != null) {
            mUsernameView.setText(username);
        }
        String password = recvAuth.mPassword;
        if (password != null) {
            mPasswordView.setText(password);
            // Since username is uneditable, focus on the next editable field
            if (mSettingsMode) {
                mPasswordView.requestFocus();
            }
        }

        if (HostAuth.SCHEME_IMAP.equals(recvAuth.mProtocol)) {
            String prefix = recvAuth.mDomain;
            if (prefix != null && prefix.length() > 0) {
                mImapPathPrefixView.setText(prefix.substring(1));
            }
        } else if (!HostAuth.SCHEME_POP3.equals(recvAuth.mProtocol)) {
            // Account must either be IMAP or POP3
            throw new Error(""Unknown account type: "" + recvAuth.mProtocol);
        }

        // The delete policy is set for all legacy accounts. For POP3 accounts, the user sets
        // the policy explicitly. For IMAP accounts, the policy is set when the Account object
        // is created. @see AccountSetupBasics#populateSetupData
        mLoadedDeletePolicy = account.getDeletePolicy();
        SpinnerOption.setSpinnerOptionValue(mDeletePolicyView, mLoadedDeletePolicy);

        int flags = recvAuth.mFlags;
        flags &= ~HostAuth.FLAG_AUTHENTICATE;
        SpinnerOption.setSpinnerOptionValue(mSecurityTypeView, flags);

        String hostname = recvAuth.mAddress;
        if (hostname != null) {
            mServerView.setText(hostname);
        }

        int port = recvAuth.mPort;
        if (port != HostAuth.PORT_UNKNOWN) {
            mPortView.setText(Integer.toString(port));
        } else {
            updatePortFromSecurityType();
        }

        mLoadedRecvAuth = recvAuth;
        mLoaded = true;
        validateFields();
    }

    /**
     * Check the values in the fields and decide if it makes sense to enable the ""next"" button
     */
    private void validateFields() {
        if (!mConfigured || !mLoaded) return;
        boolean enabled = Utility.isTextViewNotEmpty(mUsernameView)
                && Utility.isTextViewNotEmpty(mPasswordView)
                && Utility.isServerNameValid(mServerView)
                && Utility.isPortFieldValid(mPortView);
        enableNextButton(enabled);

        String userName = mUsernameView.getText().toString().trim();
        mCacheLoginCredential = userName;

        // Warn (but don't prevent) if password has leading/trailing spaces
        AccountSettingsUtils.checkPasswordSpaces(mContext, mPasswordView);
    }

    private int getPortFromSecurityType() {
        int securityType = (Integer)((SpinnerOption)mSecurityTypeView.getSelectedItem()).value;
        boolean useSsl = ((securityType & HostAuth.FLAG_SSL) != 0);
        int port = useSsl ? IMAP_PORT_SSL : IMAP_PORT_NORMAL;     // default to IMAP
        if (HostAuth.SCHEME_POP3.equals(mBaseScheme)) {
            port = useSsl ? POP3_PORT_SSL : POP3_PORT_NORMAL;
        }
        return port;
    }

    private void updatePortFromSecurityType() {
        int port = getPortFromSecurityType();
        mPortView.setText(Integer.toString(port));
    }

    /**
     * Entry point from Activity after editing settings and verifying them.  Must be FLOW_MODE_EDIT.
     * Note, we update account here (as well as the account.mHostAuthRecv) because we edit
     * account's delete policy here.
     * Blocking - do not call from UI Thread.
     */
    @Override
    public void saveSettingsAfterEdit() {
        Account account = SetupData.getAccount();
        account.update(mContext, account.toContentValues());
        account.mHostAuthRecv.update(mContext, account.mHostAuthRecv.toContentValues());
        // Update the backup (side copy) of the accounts
        AccountBackupRestore.backup(mContext);
    }

    /**
     * Entry point from Activity after entering new settings and verifying them.  For setup mode.
     */
    @Override
    public void saveSettingsAfterSetup() {
        Account account = SetupData.getAccount();
        HostAuth recvAuth = account.getOrCreateHostAuthRecv(mContext);
        HostAuth sendAuth = account.getOrCreateHostAuthSend(mContext);

        // Set the username and password for the outgoing settings to the username and
        // password the user just set for incoming.  Use the verified host address to try and
        // pick a smarter outgoing address.
        String hostName = AccountSettingsUtils.inferServerName(recvAuth.mAddress, null, ""smtp"");
        sendAuth.setLogin(recvAuth.mLogin, recvAuth.mPassword);
        sendAuth.setConnection(sendAuth.mProtocol, hostName, sendAuth.mPort, sendAuth.mFlags);
    }

    /**
     * Entry point from Activity, when ""next"" button is clicked
     */
    @Override
    public void onNext() {
        Account account = SetupData.getAccount();

        // Make sure delete policy is an valid option before using it; otherwise, the results are
        // indeterminate, I suspect...
        if (mDeletePolicyView.getVisibility() == View.VISIBLE) {
            account.setDeletePolicy(
                    (Integer) ((SpinnerOption) mDeletePolicyView.getSelectedItem()).value);
        }

        HostAuth recvAuth = account.getOrCreateHostAuthRecv(mContext);
        String userName = mUsernameView.getText().toString().trim();
        String userPassword = mPasswordView.getText().toString();
        recvAuth.setLogin(userName, userPassword);

        String serverAddress = mServerView.getText().toString().trim();
        int serverPort;
        try {
            serverPort = Integer.parseInt(mPortView.getText().toString().trim());
        } catch (NumberFormatException e) {
            serverPort = getPortFromSecurityType();
            Log.d(Logging.LOG_TAG, ""Non-integer server port; using '"" + serverPort + ""'"");
        }
        int securityType = (Integer) ((SpinnerOption) mSecurityTypeView.getSelectedItem()).value;
        recvAuth.setConnection(mBaseScheme, serverAddress, serverPort, securityType);
        if (HostAuth.SCHEME_IMAP.equals(recvAuth.mProtocol)) {
            String prefix = mImapPathPrefixView.getText().toString().trim();
            recvAuth.mDomain = TextUtils.isEmpty(prefix) ? null : (""/"" + prefix);
        } else {
            recvAuth.mDomain = null;
        }

        // Check for a duplicate account (requires async DB work) and if OK,
        // proceed with check
        startDuplicateTaskCheck(
                account.mId, serverAddress, mCacheLoginCredential, SetupData.CHECK_INCOMING);
    }

    @Override
    public boolean haveSettingsChanged() {
        boolean deletePolicyChanged = false;

        // Only verify the delete policy if the control is visible (i.e. is a pop3 account)
        if (mDeletePolicyView.getVisibility() == View.VISIBLE) {
            int newDeletePolicy =
                (Integer)((SpinnerOption)mDeletePolicyView.getSelectedItem()).value;
            deletePolicyChanged = mLoadedDeletePolicy != newDeletePolicy;
        }

        return deletePolicyChanged || super.haveSettingsChanged();
    }
}
",True,268,1,1,11,49,2,12,L6
96,com.android.email.activity.setup.AccountSetupBasics.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.FragmentTransaction;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import com.android.email.EmailAddressValidator;
import com.android.email.R;
import com.android.email.VendorPolicyLoader;
import com.android.email.activity.ActivityHelper;
import com.android.email.activity.UiUtilities;
import com.android.email.activity.Welcome;
import com.android.email.activity.setup.AccountSettingsUtils.Provider;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.service.SyncWindow;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.net.URISyntaxException;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * Prompts the user for the email address and password. Also prompts for ""Use this account as
 * default"" if this is the 2nd+ account being set up.
 *
 * If the domain is well-known, the account is configured fully and checked immediately
 * using AccountCheckSettingsFragment.  If this succeeds we proceed directly to AccountSetupOptions.
 *
 * If the domain is not known, or the user selects Manual setup, we invoke the
 * AccountSetupAccountType activity where the user can begin to manually configure the account.
 *
 * === Support for automated testing ==
 * This activity can also be launched directly via ACTION_CREATE_ACCOUNT.  This is intended
 * only for use by continuous test systems, and is currently only available when
 * {@link ActivityManager#isRunningInTestHarness()} is set.  To use this mode, you must construct
 * an intent which contains all necessary information to create the account.  No connection
 * checking is done, so the account may or may not actually work.  Here is a sample command, for a
 * gmail account ""test_account"" with a password of ""test_password"".
 *
 *      $ adb shell am start -a com.android.email.CREATE_ACCOUNT \
 *          -e EMAIL test_account@gmail.com \
 *          -e USER ""Test Account Name"" \
 *          -e INCOMING imap+ssl+://test_account:test_password@imap.gmail.com \
 *          -e OUTGOING smtp+ssl+://test_account:test_password@smtp.gmail.com
 *
 * Note: For accounts that require the full email address in the login, encode the @ as %40.
 * Note: Exchange accounts that require device security policies cannot be created automatically.
 */
public class AccountSetupBasics extends AccountSetupActivity
        implements OnClickListener, TextWatcher, AccountCheckSettingsFragment.Callbacks {

    private final static boolean ENTER_DEBUG_SCREEN = true;

    /**
     * Direct access for forcing account creation
     * For use by continuous automated test system (e.g. in conjunction with monkey tests)
     */
    private static final String ACTION_CREATE_ACCOUNT = ""com.android.email.CREATE_ACCOUNT"";
    private static final String EXTRA_FLOW_MODE = ""FLOW_MODE"";
    private static final String EXTRA_CREATE_ACCOUNT_EMAIL = ""EMAIL"";
    private static final String EXTRA_CREATE_ACCOUNT_USER = ""USER"";
    private static final String EXTRA_CREATE_ACCOUNT_INCOMING = ""INCOMING"";
    private static final String EXTRA_CREATE_ACCOUNT_OUTGOING = ""OUTGOING"";
    private static final Boolean DEBUG_ALLOW_NON_TEST_HARNESS_CREATION = false;

    private static final String STATE_KEY_PROVIDER = ""AccountSetupBasics.provider"";

    // NOTE: If you change this value, confirm that the new interval exists in arrays.xml
    private static final int DEFAULT_ACCOUNT_CHECK_INTERVAL = 15;

    // Support for UI
    private TextView mWelcomeView;
    private EditText mEmailView;
    private EditText mPasswordView;
    private CheckBox mDefaultView;
    private final EmailAddressValidator mEmailValidator = new EmailAddressValidator();
    private Provider mProvider;
    private Button mManualButton;
    private Button mNextButton;
    private boolean mNextButtonInhibit;
    private boolean mPaused;
    private boolean mReportAccountAuthenticatorError;

    // FutureTask to look up the owner
    FutureTask<String> mOwnerLookupTask;

    public static void actionNewAccount(Activity fromActivity) {
        Intent i = new Intent(fromActivity, AccountSetupBasics.class);
        i.putExtra(EXTRA_FLOW_MODE, SetupData.FLOW_MODE_NORMAL);
        fromActivity.startActivity(i);
    }

    /**
     * This generates setup data that can be used to start a self-contained account creation flow
     * for exchange accounts.
     */
    public static Intent actionSetupExchangeIntent(Context context) {
        Intent i = new Intent(context, AccountSetupBasics.class);
        i.putExtra(EXTRA_FLOW_MODE, SetupData.FLOW_MODE_ACCOUNT_MANAGER_EAS);
        return i;
    }

    /**
     * This generates setup data that can be used to start a self-contained account creation flow
     * for pop/imap accounts.
     */
    public static Intent actionSetupPopImapIntent(Context context) {
        Intent i = new Intent(context, AccountSetupBasics.class);
        i.putExtra(EXTRA_FLOW_MODE, SetupData.FLOW_MODE_ACCOUNT_MANAGER_POP_IMAP);
        return i;
    }

    public static void actionAccountCreateFinishedAccountFlow(Activity fromActivity) {
        // TODO: handle this case - modifying state on SetupData when instantiating an Intent
        // is not safe, since it's not guaranteed that an Activity will run with the Intent, and
        // information can get lost.

        Intent i= new Intent(fromActivity, AccountSetupBasics.class);
        // If we're in the ""account flow"" (from AccountManager), we want to return to the caller
        // (in the settings app)
        SetupData.init(SetupData.FLOW_MODE_RETURN_TO_CALLER);
        i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        fromActivity.startActivity(i);
    }

    public static void actionAccountCreateFinished(final Activity fromActivity,
            final long accountId) {
        Utility.runAsync(new Runnable() {
           public void run() {
               Intent i = new Intent(fromActivity, AccountSetupBasics.class);
               // If we're not in the ""account flow"" (from AccountManager), we want to show the
               // message list for the new inbox
               Account account = Account.restoreAccountWithId(fromActivity, accountId);
               SetupData.init(SetupData.FLOW_MODE_RETURN_TO_MESSAGE_LIST, account);
               i.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
               fromActivity.startActivity(i);
            }});
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        ActivityHelper.debugSetWindowFlags(this);

        // Check for forced account creation first, as it comes from an externally-generated
        // intent and won't have any SetupData prepared.
        String action = getIntent().getAction();
        if (ACTION_CREATE_ACCOUNT.equals(action)) {
            SetupData.init(SetupData.FLOW_MODE_FORCE_CREATE);
        }

        int flowMode = getIntent().getIntExtra(EXTRA_FLOW_MODE, SetupData.FLOW_MODE_UNSPECIFIED);
        if (flowMode != SetupData.FLOW_MODE_UNSPECIFIED) {
            SetupData.init(flowMode);
        } else {
            // TODO: get rid of this case. It's not safe to rely on this global static state. It
            // should be specified in the Intent always.
            flowMode = SetupData.getFlowMode();
        }

        if (flowMode == SetupData.FLOW_MODE_RETURN_TO_CALLER) {
            // Return to the caller who initiated account creation
            finish();
            return;
        } else if (flowMode == SetupData.FLOW_MODE_RETURN_TO_MESSAGE_LIST) {
            Account account = SetupData.getAccount();
            if (account != null && account.mId >= 0) {
                // Show the message list for the new account
                Welcome.actionOpenAccountInbox(this, account.mId);
                finish();
                return;
            }
        }

        setContentView(R.layout.account_setup_basics);

        mWelcomeView = (TextView) UiUtilities.getView(this, R.id.instructions);
        mEmailView = (EditText) UiUtilities.getView(this, R.id.account_email);
        mPasswordView = (EditText) UiUtilities.getView(this, R.id.account_password);
        mDefaultView = (CheckBox) UiUtilities.getView(this, R.id.account_default);

        mEmailView.addTextChangedListener(this);
        mPasswordView.addTextChangedListener(this);

        // If there are one or more accounts already in existence, then display
        // the ""use as default"" checkbox (it defaults to hidden).
        new DisplayCheckboxTask().executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);

        boolean manualButtonDisplayed = true;
        boolean alternateStrings = false;
        if (flowMode == SetupData.FLOW_MODE_ACCOUNT_MANAGER_EAS) {
            // No need for manual button -> next is appropriate
            manualButtonDisplayed = false;
            // Swap welcome text for EAS-specific text
            alternateStrings = VendorPolicyLoader.getInstance(this).useAlternateExchangeStrings();
            setTitle(alternateStrings
                    ? R.string.account_setup_basics_exchange_title_alternate
                    : R.string.account_setup_basics_exchange_title);
            mWelcomeView.setText(alternateStrings
                    ? R.string.accounts_welcome_exchange_alternate
                    : R.string.accounts_welcome_exchange);
        }

        // Configure buttons
        mManualButton = (Button) UiUtilities.getView(this, R.id.manual_setup);
        mNextButton = (Button) UiUtilities.getView(this, R.id.next);
        mManualButton.setVisibility(manualButtonDisplayed ? View.VISIBLE : View.INVISIBLE);
        mManualButton.setOnClickListener(this);
        mNextButton.setOnClickListener(this);
        // Force disabled until validator notifies otherwise
        onEnableProceedButtons(false);
        // Lightweight debounce while Async tasks underway
        mNextButtonInhibit = false;

        // Set aside incoming AccountAuthenticatorResponse, if there was any
        AccountAuthenticatorResponse authenticatorResponse =
            getIntent().getParcelableExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE);
        SetupData.setAccountAuthenticatorResponse(authenticatorResponse);
        if (authenticatorResponse != null) {
            // When this Activity is called as part of account authentification flow,
            // we are responsible for eventually reporting the result (success or failure) to
            // the account manager.  Most exit paths represent an failed or abandoned setup,
            // so the default is to report the error.  Success will be reported by the code in
            // AccountSetupOptions that commits the finally created account.
            mReportAccountAuthenticatorError = true;
        }

        // Load fields, but only once
        String userName = SetupData.getUsername();
        if (userName != null) {
            mEmailView.setText(userName);
            SetupData.setUsername(null);
        }
        String password = SetupData.getPassword();
        if (userName != null) {
            mPasswordView.setText(password);
            SetupData.setPassword(null);
        }

        // Handle force account creation immediately (now that fragment is set up)
        // This is never allowed in a normal user build and will exit immediately.
        if (SetupData.getFlowMode() == SetupData.FLOW_MODE_FORCE_CREATE) {
            if (!DEBUG_ALLOW_NON_TEST_HARNESS_CREATION &&
                    !ActivityManager.isRunningInTestHarness()) {
                Log.e(Logging.LOG_TAG,
                        ""ERROR: Force account create only allowed while in test harness"");
                finish();
                return;
            }
            Intent intent = getIntent();
            String email = intent.getStringExtra(EXTRA_CREATE_ACCOUNT_EMAIL);
            String user = intent.getStringExtra(EXTRA_CREATE_ACCOUNT_USER);
            String incoming = intent.getStringExtra(EXTRA_CREATE_ACCOUNT_INCOMING);
            String outgoing = intent.getStringExtra(EXTRA_CREATE_ACCOUNT_OUTGOING);
            if (TextUtils.isEmpty(email) || TextUtils.isEmpty(user) ||
                    TextUtils.isEmpty(incoming) || TextUtils.isEmpty(outgoing)) {
                Log.e(Logging.LOG_TAG, ""ERROR: Force account create requires extras EMAIL, USER, "" +
                        ""INCOMING, OUTGOING"");
                finish();
                return;
            }
            forceCreateAccount(email, user, incoming, outgoing);
            onCheckSettingsComplete(AccountCheckSettingsFragment.CHECK_SETTINGS_OK); // calls finish
            return;
        }

        if (savedInstanceState != null && savedInstanceState.containsKey(STATE_KEY_PROVIDER)) {
            mProvider = (Provider) savedInstanceState.getSerializable(STATE_KEY_PROVIDER);
        }

        // Launch a worker to look up the owner name.  It should be ready well in advance of
        // the time the user clicks next or manual.
        mOwnerLookupTask = new FutureTask<String>(mOwnerLookupCallable);
        Utility.runAsync(mOwnerLookupTask);
    }

    @Override
    public void onPause() {
        super.onPause();
        mPaused = true;
    }

    @Override
    public void onResume() {
        super.onResume();
        mPaused = false;
    }

    @Override
    public void finish() {
        // If the account manager initiated the creation, and success was not reported,
        // then we assume that we're giving up (for any reason) - report failure.
        if (mReportAccountAuthenticatorError) {
            AccountAuthenticatorResponse authenticatorResponse =
                    SetupData.getAccountAuthenticatorResponse();
            if (authenticatorResponse != null) {
                authenticatorResponse.onError(AccountManager.ERROR_CODE_CANCELED, ""canceled"");
                SetupData.setAccountAuthenticatorResponse(null);
            }
        }
        super.finish();
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        if (mProvider != null) {
            outState.putSerializable(STATE_KEY_PROVIDER, mProvider);
        }
    }

    /**
     * Implements OnClickListener
     */
    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.next:
                // Simple debounce - just ignore while async checks are underway
                if (mNextButtonInhibit) {
                    return;
                }
                onNext();
                break;
            case R.id.manual_setup:
                onManualSetup(false);
                break;
        }
    }

    /**
     * Implements TextWatcher
     */
    public void afterTextChanged(Editable s) {
        validateFields();
    }

    /**
     * Implements TextWatcher
     */
    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
    }

    /**
     * Implements TextWatcher
     */
    public void onTextChanged(CharSequence s, int start, int before, int count) {
    }

    private void validateFields() {
        boolean valid = Utility.isTextViewNotEmpty(mEmailView)
                && Utility.isTextViewNotEmpty(mPasswordView)
                && mEmailValidator.isValid(mEmailView.getText().toString().trim());
        onEnableProceedButtons(valid);

        // Warn (but don't prevent) if password has leading/trailing spaces
        AccountSettingsUtils.checkPasswordSpaces(this, mPasswordView);
    }

    /**
     * Return an existing username if found, or null.  This is the result of the Callable (below).
     */
    private String getOwnerName() {
        String result = null;
        try {
            result = mOwnerLookupTask.get();
        } catch (InterruptedException e) {
        } catch (ExecutionException e) {
        }
        return result;
    }

    /**
     * Callable that returns the username (based on other accounts) or null.
     */
    private final Callable<String> mOwnerLookupCallable = new Callable<String>() {
        public String call() {
            Context context = AccountSetupBasics.this;
            String name = null;
            long defaultId = Account.getDefaultAccountId(context);
            if (defaultId != -1) {
                Account account = Account.restoreAccountWithId(context, defaultId);
                if (account != null) {
                    name = account.getSenderName();
                }
            }
            return name;
        }
    };

    /**
     * Finish the auto setup process, in some cases after showing a warning dialog.
     */
    private void finishAutoSetup() {
        String email = mEmailView.getText().toString().trim();
        String password = mPasswordView.getText().toString();

        try {
            mProvider.expandTemplates(email);

            Account account = SetupData.getAccount();
            HostAuth recvAuth = account.getOrCreateHostAuthRecv(this);
            HostAuth.setHostAuthFromString(recvAuth, mProvider.incomingUri);
            recvAuth.setLogin(mProvider.incomingUsername, password);

            HostAuth sendAuth = account.getOrCreateHostAuthSend(this);
            HostAuth.setHostAuthFromString(sendAuth, mProvider.outgoingUri);
            sendAuth.setLogin(mProvider.outgoingUsername, password);

            // Populate the setup data, assuming that the duplicate account check will succeed
            populateSetupData(getOwnerName(), email, mDefaultView.isChecked());

            // Stop here if the login credentials duplicate an existing account
            // Launch an Async task to do the work
            new DuplicateCheckTask(this, recvAuth.mAddress, mProvider.incomingUsername)
                    .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
        } catch (URISyntaxException e) {
            /*
             * If there is some problem with the URI we give up and go on to manual setup.
             * Technically speaking, AutoDiscover is OK here, since the user clicked ""Next""
             * to get here. This will not happen in practice because we don't expect to
             * find any EAS accounts in the providers list.
             */
            onManualSetup(true);
        }
    }

    /**
     * Async task that continues the work of finishAutoSetup().  Checks for a duplicate
     * account and then either alerts the user, or continues.
     */
    private class DuplicateCheckTask extends AsyncTask<Void, Void, Account> {
        private final Context mContext;
        private final String mCheckHost;
        private final String mCheckLogin;

        public DuplicateCheckTask(Context context, String checkHost, String checkLogin) {
            mContext = context;
            mCheckHost = checkHost;
            mCheckLogin = checkLogin;
            // Prevent additional clicks on the next button during Async lookup
            mNextButtonInhibit = true;
        }

        @Override
        protected Account doInBackground(Void... params) {
            Account account = Utility.findExistingAccount(mContext, -1,
                    mCheckHost, mCheckLogin);
            return account;
        }

        @Override
        protected void onPostExecute(Account duplicateAccount) {
            mNextButtonInhibit = false;
            // Exit immediately if the user left before we finished
            if (mPaused) return;
            // Show duplicate account warning, or proceed
            if (duplicateAccount != null) {
                DuplicateAccountDialogFragment dialogFragment =
                    DuplicateAccountDialogFragment.newInstance(duplicateAccount.mDisplayName);
                dialogFragment.show(getFragmentManager(), DuplicateAccountDialogFragment.TAG);
                return;
            } else {
                AccountCheckSettingsFragment checkerFragment =
                    AccountCheckSettingsFragment.newInstance(
                        SetupData.CHECK_INCOMING | SetupData.CHECK_OUTGOING, null);
                FragmentTransaction transaction = getFragmentManager().beginTransaction();
                transaction.add(checkerFragment, AccountCheckSettingsFragment.TAG);
                transaction.addToBackStack(""back"");
                transaction.commit();
            }
        }
    }


    /**
     * When ""next"" button is clicked
     */
    private void onNext() {
        // Try auto-configuration from XML providers (unless in EAS mode, we can skip it)
        if (SetupData.getFlowMode() != SetupData.FLOW_MODE_ACCOUNT_MANAGER_EAS) {
            String email = mEmailView.getText().toString().trim();
            String[] emailParts = email.split(""@"");
            String domain = emailParts[1].trim();
            mProvider = AccountSettingsUtils.findProviderForDomain(this, domain);
            if (mProvider != null) {
                if (mProvider.note != null) {
                    NoteDialogFragment dialogFragment =
                            NoteDialogFragment.newInstance(mProvider.note);
                    dialogFragment.show(getFragmentManager(), NoteDialogFragment.TAG);
                } else {
                    finishAutoSetup();
                }
                return;
            }
        }
        // Can't use auto setup (although EAS accounts may still be able to AutoDiscover)
        onManualSetup(true);
    }

    /**
     * When ""manual setup"" button is clicked
     *
     * @param allowAutoDiscover - true if the user clicked 'next' and (if the account is EAS)
     * it's OK to use autodiscover.  false to prevent autodiscover and go straight to manual setup.
     * Ignored for IMAP & POP accounts.
     */
    private void onManualSetup(boolean allowAutoDiscover) {
        String email = mEmailView.getText().toString().trim();
        String password = mPasswordView.getText().toString();
        String[] emailParts = email.split(""@"");
        String user = emailParts[0].trim();
        String domain = emailParts[1].trim();

        // Alternate entry to the debug options screen (for devices without a physical keyboard:
        //  Username: d@d.d
        //  Password: debug
        if (ENTER_DEBUG_SCREEN && ""d@d.d"".equals(email) && ""debug"".equals(password)) {
            mEmailView.setText("""");
            mPasswordView.setText("""");
            AccountSettings.actionSettingsWithDebug(this);
            return;
        }

        Account account = SetupData.getAccount();
        HostAuth recvAuth = account.getOrCreateHostAuthRecv(this);
        recvAuth.setLogin(user, password);
        recvAuth.setConnection(""placeholder"", domain, HostAuth.PORT_UNKNOWN, HostAuth.FLAG_NONE);

        HostAuth sendAuth = account.getOrCreateHostAuthSend(this);
        sendAuth.setLogin(user, password);
        sendAuth.setConnection(""placeholder"", domain, HostAuth.PORT_UNKNOWN, HostAuth.FLAG_NONE);

        populateSetupData(getOwnerName(), email, mDefaultView.isChecked());

        SetupData.setAllowAutodiscover(allowAutoDiscover);
        AccountSetupAccountType.actionSelectAccountType(this);
    }

    /**
     * To support continuous testing, we allow the forced creation of accounts.
     * This works in a manner fairly similar to automatic setup, in which the complete server
     * Uri's are available, except that we will also skip checking (as if both checks were true)
     * and all other UI.
     *
     * @param email The email address for the new account
     * @param user The user name for the new account
     * @param incoming The URI-style string defining the incoming account
     * @param outgoing The URI-style string defining the outgoing account
     */
    private void forceCreateAccount(String email, String user, String incoming, String outgoing) {
        Account account = SetupData.getAccount();
        try {
            HostAuth recvAuth = account.getOrCreateHostAuthRecv(this);
            HostAuth.setHostAuthFromString(recvAuth, incoming);

            HostAuth sendAuth = account.getOrCreateHostAuthSend(this);
            HostAuth.setHostAuthFromString(sendAuth, outgoing);

            populateSetupData(user, email, false);
        } catch (URISyntaxException e) {
            // If we can't set up the URL, don't continue - account setup pages will fail too
            Toast.makeText(
                    this, R.string.account_setup_username_password_toast, Toast.LENGTH_LONG).show();
        }
    }

    /**
     * Populate SetupData's account with complete setup info.
     */
    private void populateSetupData(String senderName, String senderEmail, boolean isDefault) {
        Account account = SetupData.getAccount();
        account.setSenderName(senderName);
        account.setEmailAddress(senderEmail);
        account.setDisplayName(senderEmail);
        account.setDefaultAccount(isDefault);
        SetupData.setDefault(isDefault);        // TODO - why duplicated, if already set in account

        String protocol = account.mHostAuthRecv.mProtocol;
        setFlagsForProtocol(account, protocol);
    }

    /**
     * Sets the account sync, delete, and other misc flags not captured in {@code HostAuth}
     * information for the specified account based on the protocol type.
     */
    @VisibleForTesting
    static void setFlagsForProtocol(Account account, String protocol) {
        if (HostAuth.SCHEME_IMAP.equals(protocol)) {
            // Delete policy must be set explicitly, because IMAP does not provide a UI selection
            // for it.
            account.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);
            account.mFlags |= Account.FLAGS_SUPPORTS_SEARCH;
        }

        if (HostAuth.SCHEME_EAS.equals(protocol)) {
            account.setDeletePolicy(Account.DELETE_POLICY_ON_DELETE);
            account.setSyncInterval(Account.CHECK_INTERVAL_PUSH);
            account.setSyncLookback(SyncWindow.SYNC_WINDOW_AUTO);
        } else {
            account.setSyncInterval(DEFAULT_ACCOUNT_CHECK_INTERVAL);
        }
    }

    /**
     * Implements AccountCheckSettingsFragment.Callbacks
     *
     * This is used in automatic setup mode to jump directly down to the options screen.
     *
     * This is the only case where we finish() this activity but account setup is continuing,
     * so we inhibit reporting any error back to the Account manager.
     */
    @Override
    public void onCheckSettingsComplete(int result) {
        if (result == AccountCheckSettingsFragment.CHECK_SETTINGS_OK) {
            AccountSetupOptions.actionOptions(this);
            mReportAccountAuthenticatorError = false;
            finish();
        }
    }

    /**
     * Implements AccountCheckSettingsFragment.Callbacks
     * This is overridden only by AccountSetupExchange
     */
    @Override
    public void onAutoDiscoverComplete(int result, HostAuth hostAuth) {
        throw new IllegalStateException();
    }

    /**
     * AsyncTask checks count of accounts and displays ""use this account as default"" checkbox
     * if there are more than one.
     */
    private class DisplayCheckboxTask extends AsyncTask<Void, Void, Integer> {

        @Override
        protected Integer doInBackground(Void... params) {
            return EmailContent.count(AccountSetupBasics.this, Account.CONTENT_URI);
        }

        @Override
        protected void onPostExecute(Integer numAccounts) {
            if (numAccounts > 0) {
                Activity a = AccountSetupBasics.this;
                UiUtilities.setVisibilitySafe(mDefaultView, View.VISIBLE);
                UiUtilities.setVisibilitySafe(a, R.id.account_default_divider_1, View.VISIBLE);
                UiUtilities.setVisibilitySafe(a, R.id.account_default_divider_2, View.VISIBLE);
            }
        }
    }

    private void onEnableProceedButtons(boolean enabled) {
        mManualButton.setEnabled(enabled);
        mNextButton.setEnabled(enabled);
    }

    /**
     * Dialog fragment to show ""setup note"" dialog
     */
    public static class NoteDialogFragment extends DialogFragment {
        private final static String TAG = ""NoteDialogFragment"";

        // Argument bundle keys
        private final static String BUNDLE_KEY_NOTE = ""NoteDialogFragment.Note"";

        /**
         * Create the dialog with parameters
         */
        public static NoteDialogFragment newInstance(String note) {
            NoteDialogFragment f = new NoteDialogFragment();
            Bundle b = new Bundle();
            b.putString(BUNDLE_KEY_NOTE, note);
            f.setArguments(b);
            return f;
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            Context context = getActivity();
            final String note = getArguments().getString(BUNDLE_KEY_NOTE);

            return new AlertDialog.Builder(context)
                .setIconAttribute(android.R.attr.alertDialogIcon)
                .setTitle(android.R.string.dialog_alert_title)
                .setMessage(note)
                .setPositiveButton(
                        R.string.okay_action,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                Activity a = getActivity();
                                if (a instanceof AccountSetupBasics) {
                                    ((AccountSetupBasics)a).finishAutoSetup();
                                }
                                dismiss();
                            }
                        })
                .setNegativeButton(
                        context.getString(R.string.cancel_action),
                        null)
                .create();
        }
    }
}
",True,269,1,2,11,61,7,19,L6
97,com.android.email.activity.setup.AccountSettingsFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.Fragment;
import android.app.FragmentTransaction;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Vibrator;
import android.preference.CheckBoxPreference;
import android.preference.EditTextPreference;
import android.preference.ListPreference;
import android.preference.Preference;
import android.preference.PreferenceCategory;
import android.preference.PreferenceFragment;
import android.preference.RingtonePreference;
import android.provider.ContactsContract;
import android.text.TextUtils;
import android.util.Log;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.mail.Sender;
import com.android.emailcommon.AccountManagerTypes;
import com.android.emailcommon.CalendarProviderStub;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.Utility;

/**
 * Fragment containing the main logic for account settings.  This also calls out to other
 * fragments for server settings.
 *
 * TODO: Remove or make async the mAccountDirty reload logic.  Probably no longer needed.
 * TODO: Can we defer calling addPreferencesFromResource() until after we load the account?  This
 *       could reduce flicker.
 */
public class AccountSettingsFragment extends PreferenceFragment {

    // Keys used for arguments bundle
    private static final String BUNDLE_KEY_ACCOUNT_ID = ""AccountSettingsFragment.AccountId"";
    private static final String BUNDLE_KEY_ACCOUNT_EMAIL = ""AccountSettingsFragment.Email"";

    public static final String PREFERENCE_DESCRIPTION = ""account_description"";
    private static final String PREFERENCE_NAME = ""account_name"";
    private static final String PREFERENCE_SIGNATURE = ""account_signature"";
    private static final String PREFERENCE_QUICK_RESPONSES = ""account_quick_responses"";
    private static final String PREFERENCE_FREQUENCY = ""account_check_frequency"";
    private static final String PREFERENCE_BACKGROUND_ATTACHMENTS =
            ""account_background_attachments"";
    private static final String PREFERENCE_DEFAULT = ""account_default"";
    private static final String PREFERENCE_CATEGORY_DATA_USAGE = ""data_usage"";
    private static final String PREFERENCE_CATEGORY_NOTIFICATIONS = ""account_notifications"";
    private static final String PREFERENCE_NOTIFY = ""account_notify"";
    private static final String PREFERENCE_VIBRATE_WHEN = ""account_settings_vibrate_when"";
    private static final String PREFERENCE_RINGTONE = ""account_ringtone"";
    private static final String PREFERENCE_CATEGORY_SERVER = ""account_servers"";
    private static final String PREFERENCE_INCOMING = ""incoming"";
    private static final String PREFERENCE_OUTGOING = ""outgoing"";
    private static final String PREFERENCE_SYNC_CONTACTS = ""account_sync_contacts"";
    private static final String PREFERENCE_SYNC_CALENDAR = ""account_sync_calendar"";
    private static final String PREFERENCE_SYNC_EMAIL = ""account_sync_email"";
    private static final String PREFERENCE_DELETE_ACCOUNT = ""delete_account"";

    // These strings must match account_settings_vibrate_when_* strings in strings.xml
    private static final String PREFERENCE_VALUE_VIBRATE_WHEN_ALWAYS = ""always"";
    private static final String PREFERENCE_VALUE_VIBRATE_WHEN_SILENT = ""silent"";
    private static final String PREFERENCE_VALUE_VIBRATE_WHEN_NEVER = ""never"";

    private EditTextPreference mAccountDescription;
    private EditTextPreference mAccountName;
    private EditTextPreference mAccountSignature;
    private ListPreference mCheckFrequency;
    private ListPreference mSyncWindow;
    private CheckBoxPreference mAccountBackgroundAttachments;
    private CheckBoxPreference mAccountDefault;
    private CheckBoxPreference mAccountNotify;
    private ListPreference mAccountVibrateWhen;
    private RingtonePreference mAccountRingtone;
    private CheckBoxPreference mSyncContacts;
    private CheckBoxPreference mSyncCalendar;
    private CheckBoxPreference mSyncEmail;

    private Context mContext;
    private Account mAccount;
    private boolean mAccountDirty;
    private long mDefaultAccountId;
    private Callback mCallback = EmptyCallback.INSTANCE;
    private boolean mStarted;
    private boolean mLoaded;
    private boolean mSaveOnExit;

    /** The e-mail of the account being edited. */
    private String mAccountEmail;

    // Async Tasks
    private AsyncTask<?,?,?> mLoadAccountTask;

    /**
     * Callback interface that owning activities must provide
     */
    public interface Callback {
        public void onSettingsChanged(Account account, String preference, Object value);
        public void onEditQuickResponses(Account account);
        public void onIncomingSettings(Account account);
        public void onOutgoingSettings(Account account);
        public void abandonEdit();
        public void deleteAccount(Account account);
    }

    private static class EmptyCallback implements Callback {
        public static final Callback INSTANCE = new EmptyCallback();
        @Override public void onSettingsChanged(Account account, String preference, Object value) {}
        @Override public void onEditQuickResponses(Account account) {}
        @Override public void onIncomingSettings(Account account) {}
        @Override public void onOutgoingSettings(Account account) {}
        @Override public void abandonEdit() {}
        @Override public void deleteAccount(Account account) {}
    }

    /**
     * If launching with an arguments bundle, use this method to build the arguments.
     */
    public static Bundle buildArguments(long accountId, String email) {
        Bundle b = new Bundle();
        b.putLong(BUNDLE_KEY_ACCOUNT_ID, accountId);
        b.putString(BUNDLE_KEY_ACCOUNT_EMAIL, email);
        return b;
    }

    public static String getTitleFromArgs(Bundle args) {
        return (args == null) ? null : args.getString(BUNDLE_KEY_ACCOUNT_EMAIL);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);
        mContext = activity;
    }

    /**
     * Called to do initial creation of a fragment.  This is called after
     * {@link #onAttach(Activity)} and before {@link #onActivityCreated(Bundle)}.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onCreate"");
        }
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource(R.xml.account_settings_preferences);

        // Start loading the account data, if provided in the arguments
        // If not, activity must call startLoadingAccount() directly
        Bundle b = getArguments();
        if (b != null) {
            long accountId = b.getLong(BUNDLE_KEY_ACCOUNT_ID, -1);
            mAccountEmail = b.getString(BUNDLE_KEY_ACCOUNT_EMAIL);
            if (accountId >= 0 && !mLoaded) {
                startLoadingAccount(accountId);
            }
        }

        mAccountDirty = false;
    }

    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onActivityCreated"");
        }
        super.onActivityCreated(savedInstanceState);
    }

    /**
     * Called when the Fragment is visible to the user.
     */
    @Override
    public void onStart() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onStart"");
        }
        super.onStart();
        mStarted = true;

        // If the loaded account is ready now, load the UI
        if (mAccount != null && !mLoaded) {
            loadSettings();
        }
    }

    /**
     * Called when the fragment is visible to the user and actively running.
     * TODO: Don't read account data on UI thread.  This should be fixed by removing the need
     * to do this, not by spinning up yet another thread.
     */
    @Override
    public void onResume() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onResume"");
        }
        super.onResume();

        if (mAccountDirty) {
            // if we are coming back from editing incoming or outgoing settings,
            // we need to refresh them here so we don't accidentally overwrite the
            // old values we're still holding here
            mAccount.mHostAuthRecv =
                HostAuth.restoreHostAuthWithId(mContext, mAccount.mHostAuthKeyRecv);
            mAccount.mHostAuthSend =
                HostAuth.restoreHostAuthWithId(mContext, mAccount.mHostAuthKeySend);
            // Because ""delete policy"" UI is on edit incoming settings, we have
            // to refresh that as well.
            Account refreshedAccount = Account.restoreAccountWithId(mContext, mAccount.mId);
            if (refreshedAccount == null || mAccount.mHostAuthRecv == null
                    || mAccount.mHostAuthSend == null) {
                mSaveOnExit = false;
                mCallback.abandonEdit();
                return;
            }
            mAccount.setDeletePolicy(refreshedAccount.getDeletePolicy());
            mAccountDirty = false;
        }
    }

    @Override
    public void onPause() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onPause"");
        }
        super.onPause();
        if (mSaveOnExit) {
            saveSettings();
        }
    }

    /**
     * Called when the Fragment is no longer started.
     */
    @Override
    public void onStop() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onStop"");
        }
        super.onStop();
        mStarted = false;
    }

    /**
     * Called when the fragment is no longer in use.
     */
    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onDestroy"");
        }
        super.onDestroy();

        Utility.cancelTaskInterrupt(mLoadAccountTask);
        mLoadAccountTask = null;
    }

    @Override
    public void onSaveInstanceState(Bundle outState) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""AccountSettingsFragment onSaveInstanceState"");
        }
        super.onSaveInstanceState(outState);
    }

    /**
     * Activity provides callbacks here
     */
    public void setCallback(Callback callback) {
        mCallback = (callback == null) ? EmptyCallback.INSTANCE : callback;
    }

    /**
     * Start loading a single account in preparation for editing it
     */
    public void startLoadingAccount(long accountId) {
        Utility.cancelTaskInterrupt(mLoadAccountTask);
        mLoadAccountTask = new LoadAccountTask().executeOnExecutor(
                AsyncTask.THREAD_POOL_EXECUTOR, accountId);
    }

    /**
     * Async task to load account in order to view/edit it
     */
    private class LoadAccountTask extends AsyncTask<Long, Void, Object[]> {
        @Override
        protected Object[] doInBackground(Long... params) {
            long accountId = params[0];
            Account account = Account.restoreAccountWithId(mContext, accountId);
            if (account != null) {
                account.mHostAuthRecv =
                    HostAuth.restoreHostAuthWithId(mContext, account.mHostAuthKeyRecv);
                account.mHostAuthSend =
                    HostAuth.restoreHostAuthWithId(mContext, account.mHostAuthKeySend);
                if (account.mHostAuthRecv == null || account.mHostAuthSend == null) {
                    account = null;
                }
            }
            long defaultAccountId = Account.getDefaultAccountId(mContext);
            return new Object[] { account, Long.valueOf(defaultAccountId) };
        }

        @Override
        protected void onPostExecute(Object[] results) {
            if (results != null && !isCancelled()) {
                Account account = (Account) results[0];
                if (account == null) {
                    mSaveOnExit = false;
                    mCallback.abandonEdit();
                } else {
                    mAccount = account;
                    mDefaultAccountId = (Long) results[1];
                    if (mStarted && !mLoaded) {
                        loadSettings();
                    }
                }
            }
        }
    }

    /**
     * Load account data into preference UI
     */
    private void loadSettings() {
        // We can only do this once, so prevent repeat
        mLoaded = true;
        // Once loaded the data is ready to be saved, as well
        mSaveOnExit = false;

        mAccountDescription = (EditTextPreference) findPreference(PREFERENCE_DESCRIPTION);
        mAccountDescription.setSummary(mAccount.getDisplayName());
        mAccountDescription.setText(mAccount.getDisplayName());
        mAccountDescription.setOnPreferenceChangeListener(
            new Preference.OnPreferenceChangeListener() {
                public boolean onPreferenceChange(Preference preference, Object newValue) {
                    String summary = newValue.toString().trim();
                    if (TextUtils.isEmpty(summary)) {
                        summary = mAccount.mEmailAddress;
                    }
                    mAccountDescription.setSummary(summary);
                    mAccountDescription.setText(summary);
                    onPreferenceChanged(PREFERENCE_DESCRIPTION, summary);
                    return false;
                }
            }
        );

        mAccountName = (EditTextPreference) findPreference(PREFERENCE_NAME);
        String senderName = mAccount.getSenderName();
        // In rare cases, sendername will be null;  Change this to empty string to avoid NPE's
        if (senderName == null) senderName = """";
        mAccountName.setSummary(senderName);
        mAccountName.setText(senderName);
        mAccountName.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString().trim();
                if (!TextUtils.isEmpty(summary)) {
                    mAccountName.setSummary(summary);
                    mAccountName.setText(summary);
                    onPreferenceChanged(PREFERENCE_NAME, summary);
                }
                return false;
            }
        });

        mAccountSignature = (EditTextPreference) findPreference(PREFERENCE_SIGNATURE);
        String signature = mAccount.getSignature();
        mAccountSignature.setText(mAccount.getSignature());
        mAccountSignature.setOnPreferenceChangeListener(
            new Preference.OnPreferenceChangeListener() {
                public boolean onPreferenceChange(Preference preference, Object newValue) {
                    // Clean up signature if it's only whitespace (which is easy to do on a
                    // soft keyboard) but leave whitespace in place otherwise, to give the user
                    // maximum flexibility, e.g. the ability to indent
                    String signature = newValue.toString();
                    if (signature.trim().isEmpty()) {
                        signature = """";
                    }
                    mAccountSignature.setText(signature);
                    onPreferenceChanged(PREFERENCE_SIGNATURE, signature);
                    return false;
                }
            });

        mCheckFrequency = (ListPreference) findPreference(PREFERENCE_FREQUENCY);

        // TODO Move protocol into Account to avoid retrieving the HostAuth (implicitly)
        String protocol = Account.getProtocol(mContext, mAccount.mId);
        if (HostAuth.SCHEME_EAS.equals(protocol)) {
            mCheckFrequency.setEntries(R.array.account_settings_check_frequency_entries_push);
            mCheckFrequency.setEntryValues(R.array.account_settings_check_frequency_values_push);
        }

        mCheckFrequency.setValue(String.valueOf(mAccount.getSyncInterval()));
        mCheckFrequency.setSummary(mCheckFrequency.getEntry());
        mCheckFrequency.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final String summary = newValue.toString();
                int index = mCheckFrequency.findIndexOfValue(summary);
                mCheckFrequency.setSummary(mCheckFrequency.getEntries()[index]);
                mCheckFrequency.setValue(summary);
                onPreferenceChanged(PREFERENCE_FREQUENCY, newValue);
                return false;
            }
        });

        findPreference(PREFERENCE_QUICK_RESPONSES).setOnPreferenceClickListener(
                new Preference.OnPreferenceClickListener() {
                    @Override
                    public boolean onPreferenceClick(Preference preference) {
                        mAccountDirty = true;
                        mCallback.onEditQuickResponses(mAccount);
                        return true;
                    }
                });

        // Add check window preference
        PreferenceCategory dataUsageCategory =
                (PreferenceCategory) findPreference(PREFERENCE_CATEGORY_DATA_USAGE);

        mSyncWindow = null;
        if (HostAuth.SCHEME_EAS.equals(protocol)) {
            mSyncWindow = new ListPreference(mContext);
            mSyncWindow.setTitle(R.string.account_setup_options_mail_window_label);
            mSyncWindow.setEntries(R.array.account_settings_mail_window_entries);
            mSyncWindow.setEntryValues(R.array.account_settings_mail_window_values);
            mSyncWindow.setValue(String.valueOf(mAccount.getSyncLookback()));
            mSyncWindow.setSummary(mSyncWindow.getEntry());

            // Must correspond to the hole in the XML file that's reserved.
            mSyncWindow.setOrder(2);
            mSyncWindow.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {
                public boolean onPreferenceChange(Preference preference, Object newValue) {
                    final String summary = newValue.toString();
                    int index = mSyncWindow.findIndexOfValue(summary);
                    mSyncWindow.setSummary(mSyncWindow.getEntries()[index]);
                    mSyncWindow.setValue(summary);
                    onPreferenceChanged(preference.getKey(), newValue);
                    return false;
                }
            });
            dataUsageCategory.addPreference(mSyncWindow);
        }

        // Show ""background attachments"" for IMAP & EAS - hide it for POP3.
        mAccountBackgroundAttachments = (CheckBoxPreference)
                findPreference(PREFERENCE_BACKGROUND_ATTACHMENTS);
        if (HostAuth.SCHEME_POP3.equals(mAccount.mHostAuthRecv.mProtocol)) {
            dataUsageCategory.removePreference(mAccountBackgroundAttachments);
        } else {
            mAccountBackgroundAttachments.setChecked(
                    0 != (mAccount.getFlags() & Account.FLAGS_BACKGROUND_ATTACHMENTS));
            mAccountBackgroundAttachments.setOnPreferenceChangeListener(mPreferenceChangeListener);
        }

        mAccountDefault = (CheckBoxPreference) findPreference(PREFERENCE_DEFAULT);
        mAccountDefault.setChecked(mAccount.mId == mDefaultAccountId);
        mAccountDefault.setOnPreferenceChangeListener(mPreferenceChangeListener);

        mAccountNotify = (CheckBoxPreference) findPreference(PREFERENCE_NOTIFY);
        mAccountNotify.setChecked(0 != (mAccount.getFlags() & Account.FLAGS_NOTIFY_NEW_MAIL));
        mAccountNotify.setOnPreferenceChangeListener(mPreferenceChangeListener);

        mAccountRingtone = (RingtonePreference) findPreference(PREFERENCE_RINGTONE);
        mAccountRingtone.setOnPreferenceChangeListener(mPreferenceChangeListener);

        // The following two lines act as a workaround for the RingtonePreference
        // which does not let us set/get the value programmatically
        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        prefs.edit().putString(PREFERENCE_RINGTONE, mAccount.getRingtone()).apply();

        // Set the vibrator value, or hide it on devices w/o a vibrator
        mAccountVibrateWhen = (ListPreference) findPreference(PREFERENCE_VIBRATE_WHEN);
        Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
        if (vibrator.hasVibrator()) {
            // Calculate the value to set based on the choices, and set the value.
            final boolean vibrateAlways = 0 != (mAccount.getFlags() & Account.FLAGS_VIBRATE_ALWAYS);
            final boolean vibrateWhenSilent =
                    0 != (mAccount.getFlags() & Account.FLAGS_VIBRATE_WHEN_SILENT);
            final String vibrateSetting =
                    vibrateAlways ? PREFERENCE_VALUE_VIBRATE_WHEN_ALWAYS :
                        vibrateWhenSilent ? PREFERENCE_VALUE_VIBRATE_WHEN_SILENT :
                            PREFERENCE_VALUE_VIBRATE_WHEN_NEVER;
            mAccountVibrateWhen.setValue(vibrateSetting);

            // Update the summary string.
            final int index = mAccountVibrateWhen.findIndexOfValue(vibrateSetting);
            mAccountVibrateWhen.setSummary(mAccountVibrateWhen.getEntries()[index]);

            // When the value is changed, update the summary in addition to the setting.
            mAccountVibrateWhen.setOnPreferenceChangeListener(
                    new Preference.OnPreferenceChangeListener() {
                        @Override
                        public boolean onPreferenceChange(Preference preference, Object newValue) {
                            final String vibrateSetting = newValue.toString();
                            final int index = mAccountVibrateWhen.findIndexOfValue(vibrateSetting);
                            mAccountVibrateWhen.setSummary(mAccountVibrateWhen.getEntries()[index]);
                            mAccountVibrateWhen.setValue(vibrateSetting);
                            onPreferenceChanged(PREFERENCE_VIBRATE_WHEN, newValue);
                            return false;
                        }
                    });
        } else {
            // No vibrator present. Remove the preference altogether.
            PreferenceCategory notificationsCategory = (PreferenceCategory)
                    findPreference(PREFERENCE_CATEGORY_NOTIFICATIONS);
            notificationsCategory.removePreference(mAccountVibrateWhen);
        }

        findPreference(PREFERENCE_INCOMING).setOnPreferenceClickListener(
                new Preference.OnPreferenceClickListener() {
                    public boolean onPreferenceClick(Preference preference) {
                        mAccountDirty = true;
                        mCallback.onIncomingSettings(mAccount);
                        return true;
                    }
                });

        // Hide the outgoing account setup link if it's not activated
        Preference prefOutgoing = findPreference(PREFERENCE_OUTGOING);
        boolean showOutgoing = true;
        try {
            Sender sender = Sender.getInstance(mContext, mAccount);
            if (sender != null) {
                Class<? extends android.app.Activity> setting = sender.getSettingActivityClass();
                showOutgoing = (setting != null);
            }
        } catch (MessagingException me) {
            // just leave showOutgoing as true - bias towards showing it, so user can fix it
        }
        if (showOutgoing) {
            prefOutgoing.setOnPreferenceClickListener(
                    new Preference.OnPreferenceClickListener() {
                        public boolean onPreferenceClick(Preference preference) {
                            mAccountDirty = true;
                            mCallback.onOutgoingSettings(mAccount);
                            return true;
                        }
                    });
        } else {
            PreferenceCategory serverCategory = (PreferenceCategory) findPreference(
                    PREFERENCE_CATEGORY_SERVER);
            serverCategory.removePreference(prefOutgoing);
        }

        mSyncContacts = (CheckBoxPreference) findPreference(PREFERENCE_SYNC_CONTACTS);
        mSyncCalendar = (CheckBoxPreference) findPreference(PREFERENCE_SYNC_CALENDAR);
        mSyncEmail = (CheckBoxPreference) findPreference(PREFERENCE_SYNC_EMAIL);
        if (mAccount.mHostAuthRecv.mProtocol.equals(HostAuth.SCHEME_EAS)) {
            android.accounts.Account acct = new android.accounts.Account(mAccount.mEmailAddress,
                    AccountManagerTypes.TYPE_EXCHANGE);
            mSyncContacts.setChecked(ContentResolver
                    .getSyncAutomatically(acct, ContactsContract.AUTHORITY));
            mSyncContacts.setOnPreferenceChangeListener(mPreferenceChangeListener);
            mSyncCalendar.setChecked(ContentResolver
                    .getSyncAutomatically(acct, CalendarProviderStub.AUTHORITY));
            mSyncCalendar.setOnPreferenceChangeListener(mPreferenceChangeListener);
            mSyncEmail.setChecked(ContentResolver
                    .getSyncAutomatically(acct, EmailContent.AUTHORITY));
            mSyncEmail.setOnPreferenceChangeListener(mPreferenceChangeListener);
        } else {
            dataUsageCategory.removePreference(mSyncContacts);
            dataUsageCategory.removePreference(mSyncCalendar);
            dataUsageCategory.removePreference(mSyncEmail);
        }

        // Temporary home for delete account
        Preference prefDeleteAccount = findPreference(PREFERENCE_DELETE_ACCOUNT);
        prefDeleteAccount.setOnPreferenceClickListener(
                new Preference.OnPreferenceClickListener() {
                    public boolean onPreferenceClick(Preference preference) {
                        DeleteAccountFragment dialogFragment = DeleteAccountFragment.newInstance(
                                mAccount, AccountSettingsFragment.this);
                        FragmentTransaction ft = getFragmentManager().beginTransaction();
                        ft.addToBackStack(null);
                        dialogFragment.show(ft, DeleteAccountFragment.TAG);
                        return true;
                    }
                });
    }

    /**
     * Generic onPreferenceChanged listener for the preferences (above) that just need
     * to be written, without extra tweaks
     */
    private final Preference.OnPreferenceChangeListener mPreferenceChangeListener =
        new Preference.OnPreferenceChangeListener() {
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                onPreferenceChanged(preference.getKey(), newValue);
                return true;
            }
    };

    /**
     * Called any time a preference is changed.
     */
    private void onPreferenceChanged(String preference, Object value) {
        mCallback.onSettingsChanged(mAccount, preference, value);
        mSaveOnExit = true;
    }

    /*
     * Note: This writes the settings on the UI thread.  This has to be done so the settings are
     * committed before we might be killed.
     */
    private void saveSettings() {
        // Turn off all controlled flags - will turn them back on while checking UI elements
        int newFlags = mAccount.getFlags() &
                ~(Account.FLAGS_NOTIFY_NEW_MAIL |
                        Account.FLAGS_VIBRATE_ALWAYS | Account.FLAGS_VIBRATE_WHEN_SILENT |
                        Account.FLAGS_BACKGROUND_ATTACHMENTS);

        newFlags |= mAccountBackgroundAttachments.isChecked() ?
                Account.FLAGS_BACKGROUND_ATTACHMENTS : 0;
        mAccount.setDefaultAccount(mAccountDefault.isChecked());
        // If the display name has been cleared, we'll reset it to the default value (email addr)
        mAccount.setDisplayName(mAccountDescription.getText().trim());
        // The sender name must never be empty (this is enforced by the preference editor)
        mAccount.setSenderName(mAccountName.getText().trim());
        mAccount.setSignature(mAccountSignature.getText());
        newFlags |= mAccountNotify.isChecked() ? Account.FLAGS_NOTIFY_NEW_MAIL : 0;
        mAccount.setSyncInterval(Integer.parseInt(mCheckFrequency.getValue()));
        if (mSyncWindow != null) {
            mAccount.setSyncLookback(Integer.parseInt(mSyncWindow.getValue()));
        }
        if (mAccountVibrateWhen.getValue().equals(PREFERENCE_VALUE_VIBRATE_WHEN_ALWAYS)) {
            newFlags |= Account.FLAGS_VIBRATE_ALWAYS;
        } else if (mAccountVibrateWhen.getValue().equals(PREFERENCE_VALUE_VIBRATE_WHEN_SILENT)) {
            newFlags |= Account.FLAGS_VIBRATE_WHEN_SILENT;
        }
        SharedPreferences prefs = mAccountRingtone.getPreferenceManager().getSharedPreferences();
        mAccount.setRingtone(prefs.getString(PREFERENCE_RINGTONE, null));
        mAccount.setFlags(newFlags);

        if (mAccount.mHostAuthRecv.mProtocol.equals(""eas"")) {
            android.accounts.Account acct = new android.accounts.Account(mAccount.mEmailAddress,
                    AccountManagerTypes.TYPE_EXCHANGE);
            ContentResolver.setSyncAutomatically(acct, ContactsContract.AUTHORITY,
                    mSyncContacts.isChecked());
            ContentResolver.setSyncAutomatically(acct, CalendarProviderStub.AUTHORITY,
                    mSyncCalendar.isChecked());
            ContentResolver.setSyncAutomatically(acct, EmailContent.AUTHORITY,
                    mSyncEmail.isChecked());
        }

        // Commit the changes
        // Note, this is done in the UI thread because at this point, we must commit
        // all changes - any time after onPause completes, we could be killed.  This is analogous
        // to the way that SharedPreferences tries to work off-thread in apply(), but will pause
        // until completion in onPause().
        ContentValues cv = AccountSettingsUtils.getAccountContentValues(mAccount);
        mAccount.update(mContext, cv);

        // Run the remaining changes off-thread
        Email.setServicesEnabledAsync(mContext);
    }

    /**
     * Dialog fragment to show ""remove account?"" dialog
     */
    public static class DeleteAccountFragment extends DialogFragment {
        private final static String TAG = ""DeleteAccountFragment"";

        // Argument bundle keys
        private final static String BUNDLE_KEY_ACCOUNT_NAME = ""DeleteAccountFragment.Name"";

        /**
         * Create the dialog with parameters
         */
        public static DeleteAccountFragment newInstance(Account account, Fragment parentFragment) {
            DeleteAccountFragment f = new DeleteAccountFragment();
            Bundle b = new Bundle();
            b.putString(BUNDLE_KEY_ACCOUNT_NAME, account.getDisplayName());
            f.setArguments(b);
            f.setTargetFragment(parentFragment, 0);
            return f;
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            Context context = getActivity();
            final String name = getArguments().getString(BUNDLE_KEY_ACCOUNT_NAME);

            return new AlertDialog.Builder(context)
                .setIconAttribute(android.R.attr.alertDialogIcon)
                .setTitle(R.string.account_delete_dlg_title)
                .setMessage(context.getString(R.string.account_delete_dlg_instructions_fmt, name))
                .setPositiveButton(
                        R.string.okay_action,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int whichButton) {
                                Fragment f = getTargetFragment();
                                if (f instanceof AccountSettingsFragment) {
                                    ((AccountSettingsFragment)f).finishDeleteAccount();
                                }
                                dismiss();
                            }
                        })
                .setNegativeButton(
                        R.string.cancel_action,
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int whichButton) {
                                dismiss();
                            }
                        })
                .create();
        }
    }

    /**
     * Callback from delete account dialog - passes the delete command up to the activity
     */
    private void finishDeleteAccount() {
        mSaveOnExit = false;
        mCallback.deleteAccount(mAccount);
    }

    public String getAccountEmail() {
        // Get the e-mail address of the account being editted, if this is for an existing account.
        return mAccountEmail;
    }
}
",True,267,0,0,11,49,1,11,L6
98,com.android.email.activity.setup.AccountCheckSettingsFragment.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.activity.setup;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.DialogFragment;
import android.app.Fragment;
import android.app.FragmentManager;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.os.AsyncTask;
import android.os.Bundle;
import android.text.TextUtils;
import android.util.Log;

import com.android.email.R;
import com.android.email.mail.Sender;
import com.android.email.mail.Store;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Policy;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.utility.Utility;

/**
 * Check incoming or outgoing settings, or perform autodiscovery.
 *
 * There are three components that work together.  1. This fragment is retained and non-displayed,
 * and controls the overall process.  2. An AsyncTask that works with the stores/services to
 * check the accounts settings.  3. A stateless progress dialog (which will be recreated on
 * orientation changes).
 *
 * There are also two lightweight error dialogs which are used for notification of terminal
 * conditions.
 */
public class AccountCheckSettingsFragment extends Fragment {

    public final static String TAG = ""AccountCheckSettingsFragment"";

    // Debugging flags - for debugging the UI
    // If true, use a ""fake"" account check cycle
    private static final boolean DEBUG_FAKE_CHECK_CYCLE = false;            // DO NOT CHECK IN TRUE
    // If true, use fake check cycle, return failure
    private static final boolean DEBUG_FAKE_CHECK_ERR = false;              // DO NOT CHECK IN TRUE
    // If true, use fake check cycle, return ""security required""
    private static final boolean DEBUG_FORCE_SECURITY_REQUIRED = false;     // DO NOT CHECK IN TRUE

    // State
    private final static int STATE_START = 0;
    private final static int STATE_CHECK_AUTODISCOVER = 1;
    private final static int STATE_CHECK_INCOMING = 2;
    private final static int STATE_CHECK_OUTGOING = 3;
    private final static int STATE_CHECK_OK = 4;                    // terminal
    private final static int STATE_CHECK_SHOW_SECURITY = 5;         // terminal
    private final static int STATE_CHECK_ERROR = 6;                 // terminal
    private final static int STATE_AUTODISCOVER_AUTH_DIALOG = 7;    // terminal
    private final static int STATE_AUTODISCOVER_RESULT = 8;         // terminal
    private int mState = STATE_START;

    // Support for UI
    private boolean mAttached;
    private CheckingDialog mCheckingDialog;
    private MessagingException mProgressException;

    // Support for AsyncTask and account checking
    AccountCheckTask mAccountCheckTask;

    // Result codes returned by onCheckSettingsComplete.
    /** Check settings returned successfully */
    public final static int CHECK_SETTINGS_OK = 0;
    /** Check settings failed due to connection, authentication, or other server error */
    public final static int CHECK_SETTINGS_SERVER_ERROR = 1;
    /** Check settings failed due to user refusing to accept security requirements */
    public final static int CHECK_SETTINGS_SECURITY_USER_DENY = 2;
    /** Check settings failed due to certificate being required - user needs to pick immediately. */
    public final static int CHECK_SETTINGS_CLIENT_CERTIFICATE_NEEDED = 3;

    // Result codes returned by onAutoDiscoverComplete.
    /** AutoDiscover completed successfully with server setup data */
    public final static int AUTODISCOVER_OK = 0;
    /** AutoDiscover completed with no data (no server or AD not supported) */
    public final static int AUTODISCOVER_NO_DATA = 1;
    /** AutoDiscover reported authentication error */
    public final static int AUTODISCOVER_AUTHENTICATION = 2;

    /**
     * Callback interface for any target or activity doing account check settings
     */
    public interface Callbacks {
        /**
         * Called when CheckSettings completed
         * @param result check settings result code - success is CHECK_SETTINGS_OK
         */
        public void onCheckSettingsComplete(int result);

        /**
         * Called when autodiscovery completes.
         * @param result autodiscovery result code - success is AUTODISCOVER_OK
         * @param hostAuth configuration data returned by AD server, or null if no data available
         */
        public void onAutoDiscoverComplete(int result, HostAuth hostAuth);
    }

    /**
     * Create a retained, invisible fragment that checks accounts
     *
     * @param mode incoming or outgoing
     */
    public static AccountCheckSettingsFragment newInstance(int mode, Fragment parentFragment) {
        AccountCheckSettingsFragment f = new AccountCheckSettingsFragment();
        f.setTargetFragment(parentFragment, mode);
        return f;
    }

    /**
     * Fragment initialization.  Because we never implement onCreateView, and call
     * setRetainInstance here, this creates an invisible, persistent, ""worker"" fragment.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setRetainInstance(true);
    }

    /**
     * This is called when the Fragment's Activity is ready to go, after
     * its content view has been installed; it is called both after
     * the initial fragment creation and after the fragment is re-attached
     * to a new activity.
     */
    @Override
    public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);
        mAttached = true;

        // If this is the first time, start the AsyncTask
        if (mAccountCheckTask == null) {
            int checkMode = getTargetRequestCode();
            Account checkAccount = SetupData.getAccount();
            mAccountCheckTask = (AccountCheckTask)
                    new AccountCheckTask(checkMode, checkAccount)
                    .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
        }
    }

    /**
     * When resuming, restart the progress/error UI if necessary by re-reporting previous values
     */
    @Override
    public void onResume() {
        super.onResume();

        if (mState != STATE_START) {
            reportProgress(mState, mProgressException);
        }
    }

    /**
     * This is called when the fragment is going away.  It is NOT called
     * when the fragment is being propagated between activity instances.
     */
    @Override
    public void onDestroy() {
        super.onDestroy();
        Utility.cancelTaskInterrupt(mAccountCheckTask);
        mAccountCheckTask = null;
    }

    /**
     * This is called right before the fragment is detached from its current activity instance.
     * All reporting and callbacks are halted until we reattach.
     */
    @Override
    public void onDetach() {
        super.onDetach();
        mAttached = false;
    }

    /**
     * The worker (AsyncTask) will call this (in the UI thread) to report progress.  If we are
     * attached to an activity, update the progress immediately;  If not, simply hold the
     * progress for later.
     * @param newState The new progress state being reported
     */
    private void reportProgress(int newState, MessagingException ex) {
        mState = newState;
        mProgressException = ex;

        // If we are attached, create, recover, and/or update the dialog
        if (mAttached) {
            FragmentManager fm = getFragmentManager();

            switch (newState) {
                case STATE_CHECK_OK:
                    // immediately terminate, clean up, and report back
                    // 1. get rid of progress dialog (if any)
                    recoverAndDismissCheckingDialog();
                    // 2. exit self
                    fm.popBackStack();
                    // 3. report OK back to target fragment or activity
                    getCallbackTarget().onCheckSettingsComplete(CHECK_SETTINGS_OK);
                    break;
                case STATE_CHECK_SHOW_SECURITY:
                    // 1. get rid of progress dialog (if any)
                    recoverAndDismissCheckingDialog();
                    // 2. launch the error dialog, if needed
                    if (fm.findFragmentByTag(SecurityRequiredDialog.TAG) == null) {
                        String message = ex.getMessage();
                        if (message != null) {
                            message = message.trim();
                        }
                        SecurityRequiredDialog securityRequiredDialog =
                                SecurityRequiredDialog.newInstance(this, message);
                        fm.beginTransaction()
                                .add(securityRequiredDialog, SecurityRequiredDialog.TAG)
                                .commit();
                    }
                    break;
                case STATE_CHECK_ERROR:
                case STATE_AUTODISCOVER_AUTH_DIALOG:
                    // 1. get rid of progress dialog (if any)
                    recoverAndDismissCheckingDialog();
                    // 2. launch the error dialog, if needed
                    if (fm.findFragmentByTag(ErrorDialog.TAG) == null) {
                        ErrorDialog errorDialog = ErrorDialog.newInstance(
                                getActivity(), this, mProgressException);
                        fm.beginTransaction()
                                .add(errorDialog, ErrorDialog.TAG)
                                .commit();
                    }
                    break;
                case STATE_AUTODISCOVER_RESULT:
                    HostAuth autoDiscoverResult = ((AutoDiscoverResults) ex).mHostAuth;
                    // 1. get rid of progress dialog (if any)
                    recoverAndDismissCheckingDialog();
                    // 2. exit self
                    fm.popBackStack();
                    // 3. report back to target fragment or activity
                    getCallbackTarget().onAutoDiscoverComplete(
                            (autoDiscoverResult != null) ? AUTODISCOVER_OK : AUTODISCOVER_NO_DATA,
                            autoDiscoverResult);
                    break;
                default:
                    // Display a normal progress message
                    mCheckingDialog = (CheckingDialog) fm.findFragmentByTag(CheckingDialog.TAG);

                    if (mCheckingDialog == null) {
                        mCheckingDialog = CheckingDialog.newInstance(this, mState);
                        fm.beginTransaction()
                                .add(mCheckingDialog, CheckingDialog.TAG)
                                .commit();
                    } else {
                        mCheckingDialog.updateProgress(mState);
                    }
                    break;
            }
        }
    }

    /**
     * Find the callback target, either a target fragment or the activity
     */
    private Callbacks getCallbackTarget() {
        Fragment target = getTargetFragment();
        if (target instanceof Callbacks) {
            return (Callbacks) target;
        }
        Activity activity = getActivity();
        if (activity instanceof Callbacks) {
            return (Callbacks) activity;
        }
        throw new IllegalStateException();
    }

    /**
     * Recover and dismiss the progress dialog fragment
     */
    private void recoverAndDismissCheckingDialog() {
        if (mCheckingDialog == null) {
            mCheckingDialog = (CheckingDialog)
                    getFragmentManager().findFragmentByTag(CheckingDialog.TAG);
        }
        if (mCheckingDialog != null) {
            mCheckingDialog.dismissAllowingStateLoss();
            mCheckingDialog = null;
        }
    }

    /**
     * This is called when the user clicks ""cancel"" on the progress dialog.  Shuts everything
     * down and dismisses everything.
     * This should cause us to remain in the current screen (not accepting the settings)
     */
    private void onCheckingDialogCancel() {
        // 1. kill the checker
        Utility.cancelTaskInterrupt(mAccountCheckTask);
        mAccountCheckTask = null;
        // 2. kill self with no report - this is ""cancel""
        finish();
    }

    private void onEditCertificateOk() {
        Callbacks callbackTarget = getCallbackTarget();
        getCallbackTarget().onCheckSettingsComplete(CHECK_SETTINGS_CLIENT_CERTIFICATE_NEEDED);
        finish();
    }

    /**
     * This is called when the user clicks ""edit"" from the error dialog.  The error dialog
     * should have already dismissed itself.
     * Depending on the context, the target will remain in the current activity (e.g. editing
     * settings) or return to its own parent (e.g. enter new credentials).
     */
    private void onErrorDialogEditButton() {
        // 1. handle ""edit"" - notify callback that we had a problem with the test
        Callbacks callbackTarget = getCallbackTarget();
        if (mState == STATE_AUTODISCOVER_AUTH_DIALOG) {
            // report auth error to target fragment or activity
            callbackTarget.onAutoDiscoverComplete(AUTODISCOVER_AUTHENTICATION, null);
        } else {
            // report check settings failure to target fragment or activity
            callbackTarget.onCheckSettingsComplete(CHECK_SETTINGS_SERVER_ERROR);
        }
        finish();
    }

    /** Kill self if not already killed. */
    private void finish() {
        FragmentManager fm = getFragmentManager();
        if (fm != null) {
            fm.popBackStack();
        }
    }

    /**
     * This is called when the user clicks ""ok"" or ""cancel"" on the ""security required"" dialog.
     * Shuts everything down and dismisses everything, and reports the result appropriately.
     */
    private void onSecurityRequiredDialogResultOk(boolean okPressed) {
        // 1. handle OK/cancel - notify that security is OK and we can proceed
        Callbacks callbackTarget = getCallbackTarget();
        callbackTarget.onCheckSettingsComplete(
                okPressed ? CHECK_SETTINGS_OK : CHECK_SETTINGS_SECURITY_USER_DENY);

        // 2. kill self if not already killed by callback
        FragmentManager fm = getFragmentManager();
        if (fm != null) {
            fm.popBackStack();
        }
    }

    /**
     * This exception class is used to report autodiscover results via the reporting mechanism.
     */
    public static class AutoDiscoverResults extends MessagingException {
        public final HostAuth mHostAuth;

        /**
         * @param authenticationError true if auth failure, false for result (or no response)
         * @param hostAuth null for ""no autodiscover"", non-null for server info to return
         */
        public AutoDiscoverResults(boolean authenticationError, HostAuth hostAuth) {
            super(null);
            if (authenticationError) {
                mExceptionType = AUTODISCOVER_AUTHENTICATION_FAILED;
            } else {
                mExceptionType = AUTODISCOVER_AUTHENTICATION_RESULT;
            }
            mHostAuth = hostAuth;
        }
    }

    /**
     * This AsyncTask does the actual account checking
     *
     * TODO: It would be better to remove the UI complete from here (the exception->string
     * conversions).
     */
    private class AccountCheckTask extends AsyncTask<Void, Integer, MessagingException> {

        final Context mContext;
        final int mMode;
        final Account mAccount;
        final String mStoreHost;
        final String mCheckEmail;
        final String mCheckPassword;

        /**
         * Create task and parameterize it
         * @param mode bits request operations
         * @param checkAccount account holding values to be checked
         */
        public AccountCheckTask(int mode, Account checkAccount) {
            mContext = getActivity().getApplicationContext();
            mMode = mode;
            mAccount = checkAccount;
            mStoreHost = checkAccount.mHostAuthRecv.mAddress;
            mCheckEmail = checkAccount.mEmailAddress;
            mCheckPassword = checkAccount.mHostAuthRecv.mPassword;
        }

        @Override
        protected MessagingException doInBackground(Void... params) {
            if (DEBUG_FAKE_CHECK_CYCLE) {
                return fakeChecker();
            }

            try {
                if ((mMode & SetupData.CHECK_AUTODISCOVER) != 0) {
                    if (isCancelled()) return null;
                    publishProgress(STATE_CHECK_AUTODISCOVER);
                    Log.d(Logging.LOG_TAG, ""Begin auto-discover for "" + mCheckEmail);
                    Store store = Store.getInstance(mAccount, mContext);
                    Bundle result = store.autoDiscover(mContext, mCheckEmail, mCheckPassword);
                    // Result will be one of:
                    //  null: remote exception - proceed to manual setup
                    //  MessagingException.AUTHENTICATION_FAILED: username/password rejected
                    //  Other error: proceed to manual setup
                    //  No error: return autodiscover results
                    if (result == null) {
                        return new AutoDiscoverResults(false, null);
                    }
                    int errorCode =
                            result.getInt(EmailServiceProxy.AUTO_DISCOVER_BUNDLE_ERROR_CODE);
                    if (errorCode == MessagingException.AUTODISCOVER_AUTHENTICATION_FAILED) {
                        return new AutoDiscoverResults(true, null);
                    } else if (errorCode != MessagingException.NO_ERROR) {
                        return new AutoDiscoverResults(false, null);
                    } else {
                        HostAuth serverInfo = (HostAuth)
                            result.getParcelable(EmailServiceProxy.AUTO_DISCOVER_BUNDLE_HOST_AUTH);
                        return new AutoDiscoverResults(false, serverInfo);
                    }
                }

                // Check Incoming Settings
                if ((mMode & SetupData.CHECK_INCOMING) != 0) {
                    if (isCancelled()) return null;
                    Log.d(Logging.LOG_TAG, ""Begin check of incoming email settings"");
                    publishProgress(STATE_CHECK_INCOMING);
                    Store store = Store.getInstance(mAccount, mContext);
                    Bundle bundle = store.checkSettings();
                    int resultCode = MessagingException.UNSPECIFIED_EXCEPTION;
                    if (bundle != null) {
                        resultCode = bundle.getInt(
                                EmailServiceProxy.VALIDATE_BUNDLE_RESULT_CODE);
                    }
                    if (resultCode == MessagingException.SECURITY_POLICIES_REQUIRED) {
                        SetupData.setPolicy((Policy)bundle.getParcelable(
                                EmailServiceProxy.VALIDATE_BUNDLE_POLICY_SET));
                        return new MessagingException(resultCode, mStoreHost);
                    } else if (resultCode == MessagingException.SECURITY_POLICIES_UNSUPPORTED) {
                        String[] data = bundle.getStringArray(
                                EmailServiceProxy.VALIDATE_BUNDLE_UNSUPPORTED_POLICIES);
                        return new MessagingException(resultCode, mStoreHost, data);
                    } else if (resultCode != MessagingException.NO_ERROR) {
                        String errorMessage =
                            bundle.getString(EmailServiceProxy.VALIDATE_BUNDLE_ERROR_MESSAGE);
                        return new MessagingException(resultCode, errorMessage);
                    }
                }

                // Check Outgoing Settings
                if ((mMode & SetupData.CHECK_OUTGOING) != 0) {
                    if (isCancelled()) return null;
                    Log.d(Logging.LOG_TAG, ""Begin check of outgoing email settings"");
                    publishProgress(STATE_CHECK_OUTGOING);
                    Sender sender = Sender.getInstance(mContext, mAccount);
                    sender.close();
                    sender.open();
                    sender.close();
                }

                // If we reached the end, we completed the check(s) successfully
                return null;
            } catch (final MessagingException me) {
                // Some of the legacy account checkers return errors by throwing MessagingException,
                // which we catch and return here.
                return me;
            }
        }

        /**
         * Dummy background worker, for testing UI only.
         */
        private MessagingException fakeChecker() {
            // Dummy:  Publish a series of progress setups, 2 sec delays between them;
            // then return ""ok"" (null)
            final int DELAY = 2*1000;
            if (isCancelled()) return null;
            if ((mMode & SetupData.CHECK_AUTODISCOVER) != 0) {
                publishProgress(STATE_CHECK_AUTODISCOVER);
                try {
                    Thread.sleep(DELAY);
                } catch (InterruptedException e) { }
                if (DEBUG_FAKE_CHECK_ERR) {
                    return new MessagingException(MessagingException.AUTHENTICATION_FAILED);
                }
                // Return ""real"" AD results
                HostAuth auth = new HostAuth();
                auth.setLogin(""user"", ""password"");
                auth.setConnection(HostAuth.SCHEME_EAS, ""testserver.com"", 0);
                return new AutoDiscoverResults(false, auth);
            }
            if (isCancelled()) return null;
            if ((mMode & SetupData.CHECK_INCOMING) != 0) {
                publishProgress(STATE_CHECK_INCOMING);
                try {
                    Thread.sleep(DELAY);
                } catch (InterruptedException e) { }
                if (DEBUG_FAKE_CHECK_ERR) {
                    return new MessagingException(MessagingException.IOERROR);
                } else if (DEBUG_FORCE_SECURITY_REQUIRED) {
                    return new MessagingException(MessagingException.SECURITY_POLICIES_REQUIRED);
                }
            }
            if (isCancelled()) return null;
            if ((mMode & SetupData.CHECK_OUTGOING) != 0) {
                publishProgress(STATE_CHECK_OUTGOING);
                try {
                    Thread.sleep(DELAY);
                } catch (InterruptedException e) { }
                if (DEBUG_FAKE_CHECK_ERR) {
                    return new MessagingException(MessagingException.TLS_REQUIRED);
                }
            }
            return null;
        }

        /**
         * Progress reports (runs in UI thread).  This should be used for real progress only
         * (not for errors).
         */
        @Override
        protected void onProgressUpdate(Integer... progress) {
            if (isCancelled()) return;
            reportProgress(progress[0], null);
        }

        /**
         * Result handler (runs in UI thread).
         *
         * AutoDiscover authentication errors are handled a bit differently than the
         * other errors;  If encountered, we display the error dialog, but we return with
         * a different callback used only for AutoDiscover.
         *
         * @param result null for a successful check;  exception for various errors
         */
        @Override
        protected void onPostExecute(MessagingException result) {
            if (isCancelled()) return;
            if (result == null) {
                reportProgress(STATE_CHECK_OK, null);
            } else {
                int progressState = STATE_CHECK_ERROR;
                int exceptionType = result.getExceptionType();

                switch (exceptionType) {
                    // NOTE: AutoDiscover reports have their own reporting state, handle differently
                    // from the other exception types
                    case MessagingException.AUTODISCOVER_AUTHENTICATION_FAILED:
                        progressState = STATE_AUTODISCOVER_AUTH_DIALOG;
                        break;
                    case MessagingException.AUTODISCOVER_AUTHENTICATION_RESULT:
                        progressState = STATE_AUTODISCOVER_RESULT;
                        break;
                    // NOTE: Security policies required has its own report state, handle it a bit
                    // differently from the other exception types.
                    case MessagingException.SECURITY_POLICIES_REQUIRED:
                        progressState = STATE_CHECK_SHOW_SECURITY;
                        break;
                }
                reportProgress(progressState, result);
            }
        }
    }

    private static String getErrorString(Context context, MessagingException ex) {
        int id;
        String message = ex.getMessage();
        if (message != null) {
            message = message.trim();
        }
        switch (ex.getExceptionType()) {
            // The remaining exception types are handled by setting the state to
            // STATE_CHECK_ERROR (above, default) and conversion to specific error strings.
            case MessagingException.CERTIFICATE_VALIDATION_ERROR:
                id = TextUtils.isEmpty(message)
                        ? R.string.account_setup_failed_dlg_certificate_message
                        : R.string.account_setup_failed_dlg_certificate_message_fmt;
                break;
            case MessagingException.AUTHENTICATION_FAILED:
            case MessagingException.AUTODISCOVER_AUTHENTICATION_FAILED:
                id = TextUtils.isEmpty(message)
                        ? R.string.account_setup_failed_dlg_auth_message
                        : R.string.account_setup_failed_dlg_auth_message_fmt;
                break;
            case MessagingException.AUTHENTICATION_FAILED_OR_SERVER_ERROR:
                id = R.string.account_setup_failed_check_credentials_message;
                break;
            case MessagingException.IOERROR:
                id = R.string.account_setup_failed_ioerror;
                break;
            case MessagingException.TLS_REQUIRED:
                id = R.string.account_setup_failed_tls_required;
                break;
            case MessagingException.AUTH_REQUIRED:
                id = R.string.account_setup_failed_auth_required;
                break;
            case MessagingException.SECURITY_POLICIES_UNSUPPORTED:
                id = R.string.account_setup_failed_security_policies_unsupported;
                // Belt and suspenders here; there should always be a non-empty array here
                String[] unsupportedPolicies = (String[]) ex.getExceptionData();
                if (unsupportedPolicies == null) {
                    Log.w(TAG, ""No data for unsupported policies?"");
                    break;
                }
                // Build a string, concatenating policies we don't support
                StringBuilder sb = new StringBuilder();
                boolean first = true;
                for (String policyName: unsupportedPolicies) {
                    if (first) {
                        first = false;
                    } else {
                        sb.append("", "");
                    }
                    sb.append(policyName);
                }
                message = sb.toString();
                break;
            case MessagingException.ACCESS_DENIED:
                id = R.string.account_setup_failed_access_denied;
                break;
            case MessagingException.PROTOCOL_VERSION_UNSUPPORTED:
                id = R.string.account_setup_failed_protocol_unsupported;
                break;
            case MessagingException.GENERAL_SECURITY:
                id = R.string.account_setup_failed_security;
                break;
            case MessagingException.CLIENT_CERTIFICATE_REQUIRED:
                id = R.string.account_setup_failed_certificate_required;
                break;
            case MessagingException.CLIENT_CERTIFICATE_ERROR:
                id = R.string.account_setup_failed_certificate_inaccessible;
                break;
            default:
                id = TextUtils.isEmpty(message)
                        ? R.string.account_setup_failed_dlg_server_message
                        : R.string.account_setup_failed_dlg_server_message_fmt;
                break;
        }
        return TextUtils.isEmpty(message)
                ? context.getString(id)
                : context.getString(id, message);
    }

    /**
     * Simple dialog that shows progress as we work through the settings checks.
     * This is stateless except for its UI (e.g. current strings) and can be torn down or
     * recreated at any time without affecting the account checking progress.
     */
    public static class CheckingDialog extends DialogFragment {
        @SuppressWarnings(""hiding"")
        public final static String TAG = ""CheckProgressDialog"";

        // Extras for saved instance state
        private final String EXTRA_PROGRESS_STRING = ""CheckProgressDialog.Progress"";

        // UI
        private String mProgressString;

        /**
         * Create a dialog that reports progress
         * @param progress initial progress indication
         */
        public static CheckingDialog newInstance(AccountCheckSettingsFragment parentFragment,
                int progress) {
            CheckingDialog f = new CheckingDialog();
            f.setTargetFragment(parentFragment, progress);
            return f;
        }

        /**
         * Update the progress of an existing dialog
         * @param progress latest progress to be displayed
         */
        public void updateProgress(int progress) {
            mProgressString = getProgressString(progress);
            AlertDialog dialog = (AlertDialog) getDialog();
            dialog.setMessage(mProgressString);
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            Context context = getActivity();
            if (savedInstanceState != null) {
                mProgressString = savedInstanceState.getString(EXTRA_PROGRESS_STRING);
            }
            if (mProgressString == null) {
                mProgressString = getProgressString(getTargetRequestCode());
            }
            final AccountCheckSettingsFragment target =
                (AccountCheckSettingsFragment) getTargetFragment();

            ProgressDialog dialog = new ProgressDialog(context);
            dialog.setIndeterminate(true);
            dialog.setMessage(mProgressString);
            dialog.setButton(DialogInterface.BUTTON_NEGATIVE,
                    context.getString(R.string.cancel_action),
                    new DialogInterface.OnClickListener() {
                        public void onClick(DialogInterface dialog, int which) {
                            dismiss();
                            target.onCheckingDialogCancel();
                        }
                    });
            return dialog;
        }

        /**
         * Listen for cancellation, which can happen from places other than the
         * negative button (e.g. touching outside the dialog), and stop the checker
         */
        @Override
        public void onCancel(DialogInterface dialog) {
            AccountCheckSettingsFragment target =
                (AccountCheckSettingsFragment) getTargetFragment();
            target.onCheckingDialogCancel();
            super.onCancel(dialog);
        }

        @Override
        public void onSaveInstanceState(Bundle outState) {
            super.onSaveInstanceState(outState);
            outState.putString(EXTRA_PROGRESS_STRING, mProgressString);
        }

        /**
         * Convert progress to message
         */
        private String getProgressString(int progress) {
            int stringId = 0;
            switch (progress) {
                case STATE_CHECK_AUTODISCOVER:
                    stringId = R.string.account_setup_check_settings_retr_info_msg;
                    break;
                case STATE_CHECK_INCOMING:
                    stringId = R.string.account_setup_check_settings_check_incoming_msg;
                    break;
                case STATE_CHECK_OUTGOING:
                    stringId = R.string.account_setup_check_settings_check_outgoing_msg;
                    break;
            }
            return getActivity().getString(stringId);
        }
    }

    /**
     * The standard error dialog.  Calls back to onErrorDialogButton().
     */
    public static class ErrorDialog extends DialogFragment {
        @SuppressWarnings(""hiding"")
        public final static String TAG = ""ErrorDialog"";

        // Bundle keys for arguments
        private final static String ARGS_MESSAGE = ""ErrorDialog.Message"";
        private final static String ARGS_EXCEPTION_ID = ""ErrorDialog.ExceptionId"";

        /**
         * Use {@link #newInstance} This public constructor is still required so
         * that DialogFragment state can be automatically restored by the
         * framework.
         */
        public ErrorDialog() {
        }

        public static ErrorDialog newInstance(Context context, AccountCheckSettingsFragment target,
                MessagingException ex) {
            ErrorDialog fragment = new ErrorDialog();
            Bundle arguments = new Bundle();
            arguments.putString(ARGS_MESSAGE, getErrorString(context, ex));
            arguments.putInt(ARGS_EXCEPTION_ID, ex.getExceptionType());
            fragment.setArguments(arguments);
            fragment.setTargetFragment(target, 0);
            return fragment;
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            final Context context = getActivity();
            final Bundle arguments = getArguments();
            final String message = arguments.getString(ARGS_MESSAGE);
            final int exceptionId = arguments.getInt(ARGS_EXCEPTION_ID);
            final AccountCheckSettingsFragment target =
                    (AccountCheckSettingsFragment) getTargetFragment();

            AlertDialog.Builder builder = new AlertDialog.Builder(context)
                .setIconAttribute(android.R.attr.alertDialogIcon)
                .setTitle(context.getString(R.string.account_setup_failed_dlg_title))
                .setMessage(message)
                .setCancelable(true);

            if (exceptionId == MessagingException.CLIENT_CERTIFICATE_REQUIRED) {
                // Certificate error - show two buttons so the host fragment can auto pop
                // into the appropriate flow.
                builder.setPositiveButton(
                        context.getString(android.R.string.ok),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                dismiss();
                                target.onEditCertificateOk();
                            }
                        });
                builder.setNegativeButton(
                        context.getString(android.R.string.cancel),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                dismiss();
                                target.onErrorDialogEditButton();
                            }
                        });

            } else {
                // ""Normal"" error - just use a single ""Edit details"" button.
                builder.setPositiveButton(
                        context.getString(R.string.account_setup_failed_dlg_edit_details_action),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                dismiss();
                                target.onErrorDialogEditButton();
                            }
                        });
            }

            return builder.create();
        }

    }

    /**
     * The ""security required"" error dialog.  This is presented whenever an exchange account
     * reports that it will require security policy control, and provide the user with the
     * opportunity to accept or deny this.
     *
     * If the user clicks OK, calls onSecurityRequiredDialogResultOk(true) which reports back
     * to the target as if the settings check was ""ok"".  If the user clicks ""cancel"", calls
     * onSecurityRequiredDialogResultOk(false) which simply closes the checker (this is the
     * same as any other failed check.)
     */
    public static class SecurityRequiredDialog extends DialogFragment {
        @SuppressWarnings(""hiding"")
        public final static String TAG = ""SecurityRequiredDialog"";

        // Bundle keys for arguments
        private final static String ARGS_HOST_NAME = ""SecurityRequiredDialog.HostName"";

        public static SecurityRequiredDialog newInstance(AccountCheckSettingsFragment target,
                String hostName) {
            SecurityRequiredDialog fragment = new SecurityRequiredDialog();
            Bundle arguments = new Bundle();
            arguments.putString(ARGS_HOST_NAME, hostName);
            fragment.setArguments(arguments);
            fragment.setTargetFragment(target, 0);
            return fragment;
        }

        @Override
        public Dialog onCreateDialog(Bundle savedInstanceState) {
            final Context context = getActivity();
            final Bundle arguments = getArguments();
            final String hostName = arguments.getString(ARGS_HOST_NAME);
            final AccountCheckSettingsFragment target =
                    (AccountCheckSettingsFragment) getTargetFragment();

            return new AlertDialog.Builder(context)
                .setIconAttribute(android.R.attr.alertDialogIcon)
                .setTitle(context.getString(R.string.account_setup_security_required_title))
                .setMessage(context.getString(
                        R.string.account_setup_security_policies_required_fmt, hostName))
                .setCancelable(true)
                .setPositiveButton(
                        context.getString(R.string.okay_action),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                dismiss();
                                target.onSecurityRequiredDialogResultOk(true);
                            }
                        })
                .setNegativeButton(
                        context.getString(R.string.cancel_action),
                        new DialogInterface.OnClickListener() {
                            public void onClick(DialogInterface dialog, int which) {
                                dismiss();
                                target.onSecurityRequiredDialogResultOk(false);
                            }
                        })
                 .create();
        }

    }

}
",True,267,0,0,10,62,7,10,L6
99,com.android.email.provider.ContentCache.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.provider;

import android.content.ContentValues;
import android.database.CrossProcessCursor;
import android.database.Cursor;
import android.database.CursorWindow;
import android.database.CursorWrapper;
import android.database.MatrixCursor;
import android.net.Uri;
import android.util.Log;
import android.util.LruCache;

import com.android.email.Email;
import com.google.common.annotations.VisibleForTesting;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * An LRU cache for EmailContent (Account, HostAuth, Mailbox, and Message, thus far).  The intended
 * user of this cache is EmailProvider itself; caching is entirely transparent to users of the
 * provider.
 *
 * Usage examples; id is a String representation of a row id (_id), as it might be retrieved from
 * a uri via getPathSegment
 *
 * To create a cache:
 *    ContentCache cache = new ContentCache(name, projection, max);
 *
 * To (try to) get a cursor from a cache:
 *    Cursor cursor = cache.getCursor(id, projection);
 *
 * To read from a table and cache the resulting cursor:
 * 1. Get a CacheToken: CacheToken token = cache.getToken(id);
 * 2. Get a cursor from the database: Cursor cursor = db.query(....);
 * 3. Put the cursor in the cache: cache.putCursor(cursor, id, token);
 * Only cursors with the projection given in the definition of the cache can be cached
 *
 * To delete one or more rows or update multiple rows from a table that uses cached data:
 * 1. Lock the row in the cache: cache.lock(id);
 * 2. Delete/update the row(s): db.delete(...);
 * 3. Invalidate any other caches that might be affected by the delete/update:
 *      The entire cache: affectedCache.invalidate()*
 *      A specific row in a cache: affectedCache.invalidate(rowId)
 * 4. Unlock the row in the cache: cache.unlock(id);
 *
 * To update a single row from a table that uses cached data:
 * 1. Lock the row in the cache: cache.lock(id);
 * 2. Update the row: db.update(...);
 * 3. Unlock the row in the cache, passing in the new values: cache.unlock(id, values);
 *
 * Synchronization note: All of the public methods in ContentCache are synchronized (i.e. on the
 * cache itself) except for methods that are solely used for debugging and do not modify the cache.
 * All references to ContentCache that are external to the ContentCache class MUST synchronize on
 * the ContentCache instance (e.g. CachedCursor.close())
 */
public final class ContentCache {
    private static final boolean DEBUG_CACHE = false;  // DO NOT CHECK IN TRUE
    private static final boolean DEBUG_TOKENS = false;  // DO NOT CHECK IN TRUE
    private static final boolean DEBUG_NOT_CACHEABLE = false;  // DO NOT CHECK IN TRUE
    private static final boolean DEBUG_STATISTICS = false; // DO NOT CHECK THIS IN TRUE

    // If false, reads will not use the cache; this is intended for debugging only
    private static final boolean READ_CACHE_ENABLED = true;  // DO NOT CHECK IN FALSE

    // Count of non-cacheable queries (debug only)
    private static int sNotCacheable = 0;
    // A map of queries that aren't cacheable (debug only)
    private static final CounterMap<String> sNotCacheableMap = new CounterMap<String>();

    private final LruCache<String, Cursor> mLruCache;

    // All defined caches
    private static final ArrayList<ContentCache> sContentCaches = new ArrayList<ContentCache>();
    // A set of all unclosed, cached cursors; this will typically be a very small set, as cursors
    // tend to be closed quickly after use.  The value, for each cursor, is its reference count
    /*package*/ static final CounterMap<Cursor> sActiveCursors = new CounterMap<Cursor>(24);

    // A set of locked content id's
    private final CounterMap<String> mLockMap = new CounterMap<String>(4);
    // A set of active tokens
    /*package*/ TokenList mTokenList;

    // The name of the cache (used for logging)
    private final String mName;
    // The base projection (only queries in which all columns exist in this projection will be
    // able to avoid a cache miss)
    private final String[] mBaseProjection;
    // The tag used for logging
    private final String mLogTag;
    // Cache statistics
    private final Statistics mStats;
    /** If {@code true}, lock the cache for all writes */
    private static boolean sLockCache;

    /**
     * A synchronized reference counter for arbitrary objects
     */
    /*package*/ static class CounterMap<T> {
        private HashMap<T, Integer> mMap;

        /*package*/ CounterMap(int maxSize) {
            mMap = new HashMap<T, Integer>(maxSize);
        }

        /*package*/ CounterMap() {
            mMap = new HashMap<T, Integer>();
        }

        /*package*/ synchronized int subtract(T object) {
            Integer refCount = mMap.get(object);
            int newCount;
            if (refCount == null || refCount.intValue() == 0) {
                throw new IllegalStateException();
            }
            if (refCount > 1) {
                newCount = refCount - 1;
                mMap.put(object, newCount);
            } else {
                newCount = 0;
                mMap.remove(object);
            }
            return newCount;
        }

        /*package*/ synchronized void add(T object) {
            Integer refCount = mMap.get(object);
            if (refCount == null) {
                mMap.put(object, 1);
            } else {
                mMap.put(object, refCount + 1);
            }
        }

        /*package*/ synchronized boolean contains(T object) {
            return mMap.containsKey(object);
        }

        /*package*/ synchronized int getCount(T object) {
            Integer refCount = mMap.get(object);
            return (refCount == null) ? 0 : refCount.intValue();
        }

        synchronized int size() {
            return mMap.size();
        }

        /**
         * For Debugging Only - not efficient
         */
        synchronized Set<HashMap.Entry<T, Integer>> entrySet() {
            return mMap.entrySet();
        }
    }

    /**
     * A list of tokens that are in use at any moment; there can be more than one token for an id
     */
    /*package*/ static class TokenList extends ArrayList<CacheToken> {
        private static final long serialVersionUID = 1L;
        private final String mLogTag;

        /*package*/ TokenList(String name) {
            mLogTag = ""TokenList-"" + name;
        }

        /*package*/ int invalidateTokens(String id) {
            if (Email.DEBUG && DEBUG_TOKENS) {
                Log.d(mLogTag, ""============ Invalidate tokens for: "" + id);
            }
            ArrayList<CacheToken> removeList = new ArrayList<CacheToken>();
            int count = 0;
            for (CacheToken token: this) {
                if (token.getId().equals(id)) {
                    token.invalidate();
                    removeList.add(token);
                    count++;
                }
            }
            for (CacheToken token: removeList) {
                remove(token);
            }
            return count;
        }

        /*package*/ void invalidate() {
            if (Email.DEBUG && DEBUG_TOKENS) {
                Log.d(mLogTag, ""============ List invalidated"");
            }
            for (CacheToken token: this) {
                token.invalidate();
            }
            clear();
        }

        /*package*/ boolean remove(CacheToken token) {
            boolean result = super.remove(token);
            if (Email.DEBUG && DEBUG_TOKENS) {
                if (result) {
                    Log.d(mLogTag, ""============ Removing token for: "" + token.mId);
                } else {
                    Log.d(mLogTag, ""============ No token found for: "" + token.mId);
                }
            }
            return result;
        }

        public CacheToken add(String id) {
            CacheToken token = new CacheToken(id);
            super.add(token);
            if (Email.DEBUG && DEBUG_TOKENS) {
                Log.d(mLogTag, ""============ Taking token for: "" + token.mId);
            }
            return token;
        }
    }

    /**
     * A CacheToken is an opaque object that must be passed into putCursor in order to attempt to
     * write into the cache.  The token becomes invalidated by any intervening write to the cached
     * record.
     */
    public static final class CacheToken {
        private final String mId;
        private boolean mIsValid = READ_CACHE_ENABLED;

        /*package*/ CacheToken(String id) {
            mId = id;
        }

        /*package*/ String getId() {
            return mId;
        }

        /*package*/ boolean isValid() {
            return mIsValid;
        }

        /*package*/ void invalidate() {
            mIsValid = false;
        }

        @Override
        public boolean equals(Object token) {
            return ((token instanceof CacheToken) && ((CacheToken)token).mId.equals(mId));
        }

        @Override
        public int hashCode() {
            return mId.hashCode();
        }
    }

    /**
     * The cached cursor is simply a CursorWrapper whose underlying cursor contains zero or one
     * rows.  We handle simple movement (moveToFirst(), moveToNext(), etc.), and override close()
     * to keep the underlying cursor alive (unless it's no longer cached due to an invalidation).
     * Multiple CachedCursor's can use the same underlying cursor, so we override the various
     * moveX methods such that each CachedCursor can have its own position information
     */
    public static final class CachedCursor extends CursorWrapper implements CrossProcessCursor {
        // The cursor we're wrapping
        private final Cursor mCursor;
        // The cache which generated this cursor
        private final ContentCache mCache;
        private final String mId;
        // The current position of the cursor (can only be 0 or 1)
        private int mPosition = -1;
        // The number of rows in this cursor (-1 = not determined)
        private int mCount = -1;
        private boolean isClosed = false;

        public CachedCursor(Cursor cursor, ContentCache cache, String id) {
            super(cursor);
            mCursor = cursor;
            mCache = cache;
            mId = id;
            // Add this to our set of active cursors
            sActiveCursors.add(cursor);
        }

        /**
         * Close this cursor; if the cursor's cache no longer contains the underlying cursor, and
         * there are no other users of that cursor, we'll close it here. In any event,
         * we'll remove the cursor from our set of active cursors.
         */
        @Override
        public void close() {
            synchronized(mCache) {
                int count = sActiveCursors.subtract(mCursor);
                if ((count == 0) && mCache.mLruCache.get(mId) != (mCursor)) {
                    super.close();
                }
            }
            isClosed = true;
        }

        @Override
        public boolean isClosed() {
            return isClosed;
        }

        @Override
        public int getCount() {
            if (mCount < 0) {
                mCount = super.getCount();
            }
            return mCount;
        }

        /**
         * We'll be happy to move to position 0 or -1
         */
        @Override
        public boolean moveToPosition(int pos) {
            if (pos >= getCount() || pos < -1) {
                return false;
            }
            mPosition = pos;
            return true;
        }

        @Override
        public boolean moveToFirst() {
            return moveToPosition(0);
        }

        @Override
        public boolean moveToNext() {
            return moveToPosition(mPosition + 1);
        }

        @Override
        public boolean moveToPrevious() {
            return moveToPosition(mPosition - 1);
        }

        @Override
        public int getPosition() {
            return mPosition;
        }

        @Override
        public final boolean move(int offset) {
            return moveToPosition(mPosition + offset);
        }

        @Override
        public final boolean moveToLast() {
            return moveToPosition(getCount() - 1);
        }

        @Override
        public final boolean isLast() {
            return mPosition == (getCount() - 1);
        }

        @Override
        public final boolean isBeforeFirst() {
            return mPosition == -1;
        }

        @Override
        public final boolean isAfterLast() {
            return mPosition == 1;
        }

        @Override
        public CursorWindow getWindow() {
           return ((CrossProcessCursor)mCursor).getWindow();
        }

        @Override
        public void fillWindow(int pos, CursorWindow window) {
            ((CrossProcessCursor)mCursor).fillWindow(pos, window);
        }

        @Override
        public boolean onMove(int oldPosition, int newPosition) {
            return true;
        }
    }

    /**
     * Public constructor
     * @param name the name of the cache (used for logging)
     * @param baseProjection the projection used for cached cursors; queries whose columns are not
     *  included in baseProjection will always generate a cache miss
     * @param maxSize the maximum number of content cursors to cache
     */
    public ContentCache(String name, String[] baseProjection, int maxSize) {
        mName = name;
        mLruCache = new LruCache<String, Cursor>(maxSize) {
            @Override
            protected void entryRemoved(
                    boolean evicted, String key, Cursor oldValue, Cursor newValue) {
                // Close this cursor if it's no longer being used
                if (evicted && !sActiveCursors.contains(oldValue)) {
                    oldValue.close();
                }
            }
        };
        mBaseProjection = baseProjection;
        mLogTag = ""ContentCache-"" + name;
        sContentCaches.add(this);
        mTokenList = new TokenList(mName);
        mStats = new Statistics(this);
    }

    /**
     * Return the base projection for cached rows
     * Get the projection used for cached rows (typically, the largest possible projection)
     * @return
     */
    public String[] getProjection() {
        return mBaseProjection;
    }


    /**
     * Get a CacheToken for a row as specified by its id (_id column)
     * @param id the id of the record
     * @return a CacheToken needed in order to write data for the record back to the cache
     */
    public synchronized CacheToken getCacheToken(String id) {
        // If another thread is already writing the data, return an invalid token
        CacheToken token = mTokenList.add(id);
        if (mLockMap.contains(id)) {
            token.invalidate();
        }
        return token;
    }

    public int size() {
        return mLruCache.size();
    }

    @VisibleForTesting
    Cursor get(String id) {
        return mLruCache.get(id);
    }

    protected Map<String, Cursor> getSnapshot() {
        return mLruCache.snapshot();
    }
    /**
     * Try to cache a cursor for the given id and projection; returns a valid cursor, either a
     * cached cursor (if caching was successful) or the original cursor
     *
     * @param c the cursor to be cached
     * @param id the record id (_id) of the content
     * @param projection the projection represented by the cursor
     * @return whether or not the cursor was cached
     */
    public Cursor putCursor(Cursor c, String id, String[] projection, CacheToken token) {
        // Make sure the underlying cursor is at the first row, and do this without synchronizing,
        // to prevent deadlock with a writing thread (which might, for example, be calling into
        // CachedCursor.invalidate)
        c.moveToPosition(0);
        return putCursorImpl(c, id, projection, token);
    }
    public synchronized Cursor putCursorImpl(Cursor c, String id, String[] projection,
            CacheToken token) {
        try {
            if (!token.isValid()) {
                if (Email.DEBUG && DEBUG_CACHE) {
                    Log.d(mLogTag, ""============ Stale token for "" + id);
                }
                mStats.mStaleCount++;
                return c;
            }
            if (c != null && Arrays.equals(projection, mBaseProjection) && !sLockCache) {
                if (Email.DEBUG && DEBUG_CACHE) {
                    Log.d(mLogTag, ""============ Caching cursor for: "" + id);
                }
                // If we've already cached this cursor, invalidate the older one
                Cursor existingCursor = get(id);
                if (existingCursor != null) {
                   unlockImpl(id, null, false);
                }
                mLruCache.put(id, c);
                return new CachedCursor(c, this, id);
            }
            return c;
        } finally {
            mTokenList.remove(token);
        }
    }

    /**
     * Find and, if found, return a cursor, based on cached values, for the supplied id
     * @param id the _id column of the desired row
     * @param projection the requested projection for a query
     * @return a cursor based on cached values, or null if the row is not cached
     */
    public synchronized Cursor getCachedCursor(String id, String[] projection) {
        if (Email.DEBUG && DEBUG_STATISTICS) {
            // Every 200 calls to getCursor, report cache statistics
            dumpOnCount(200);
        }
        if (projection == mBaseProjection) {
            return getCachedCursorImpl(id);
        } else {
            return getMatrixCursor(id, projection);
        }
    }

    private CachedCursor getCachedCursorImpl(String id) {
        Cursor c = get(id);
        if (c != null) {
            mStats.mHitCount++;
            return new CachedCursor(c, this, id);
        }
        mStats.mMissCount++;
        return null;
    }

    private MatrixCursor getMatrixCursor(String id, String[] projection) {
        return getMatrixCursor(id, projection, null);
    }

    private MatrixCursor getMatrixCursor(String id, String[] projection,
            ContentValues values) {
        Cursor c = get(id);
        if (c != null) {
            // Make a new MatrixCursor with the requested columns
            MatrixCursor mc = new MatrixCursor(projection, 1);
            if (c.getCount() == 0) {
                return mc;
            }
            Object[] row = new Object[projection.length];
            if (values != null) {
                // Make a copy; we don't want to change the original
                values = new ContentValues(values);
            }
            int i = 0;
            for (String column: projection) {
                int columnIndex = c.getColumnIndex(column);
                if (columnIndex < 0) {
                    mStats.mProjectionMissCount++;
                    return null;
                } else {
                    String value;
                    if (values != null && values.containsKey(column)) {
                        Object val = values.get(column);
                        if (val instanceof Boolean) {
                            value = (val == Boolean.TRUE) ? ""1"" : ""0"";
                        } else {
                            value = values.getAsString(column);
                        }
                        values.remove(column);
                    } else {
                        value = c.getString(columnIndex);
                    }
                    row[i++] = value;
                }
            }
            if (values != null && values.size() != 0) {
                return null;
            }
            mc.addRow(row);
            mStats.mHitCount++;
            return mc;
        }
        mStats.mMissCount++;
        return null;
    }

    /**
     * Lock a given row, such that no new valid CacheTokens can be created for the passed-in id.
     * @param id the id of the row to lock
     */
    public synchronized void lock(String id) {
        // Prevent new valid tokens from being created
        mLockMap.add(id);
        // Invalidate current tokens
        int count = mTokenList.invalidateTokens(id);
        if (Email.DEBUG && DEBUG_TOKENS) {
            Log.d(mTokenList.mLogTag, ""============ Lock invalidated "" + count +
                    "" tokens for: "" + id);
        }
    }

    /**
     * Unlock a given row, allowing new valid CacheTokens to be created for the passed-in id.
     * @param id the id of the item whose cursor is cached
     */
    public synchronized void unlock(String id) {
        unlockImpl(id, null, true);
    }

    /**
     * If the row with id is currently cached, replaces the cached values with the supplied
     * ContentValues.  Then, unlock the row, so that new valid CacheTokens can be created.
     *
     * @param id the id of the item whose cursor is cached
     * @param values updated values for this row
     */
    public synchronized void unlock(String id, ContentValues values) {
        unlockImpl(id, values, true);
    }

    /**
     * If values are passed in, replaces any cached cursor with one containing new values, and
     * then closes the previously cached one (if any, and if not in use)
     * If values are not passed in, removes the row from cache
     * If the row was locked, unlock it
     * @param id the id of the row
     * @param values new ContentValues for the row (or null if row should simply be removed)
     * @param wasLocked whether or not the row was locked; if so, the lock will be removed
     */
    private void unlockImpl(String id, ContentValues values, boolean wasLocked) {
        Cursor c = get(id);
        if (c != null) {
            if (Email.DEBUG && DEBUG_CACHE) {
                Log.d(mLogTag, ""=========== Unlocking cache for: "" + id);
            }
            if (values != null && !sLockCache) {
                MatrixCursor cursor = getMatrixCursor(id, mBaseProjection, values);
                if (cursor != null) {
                    if (Email.DEBUG && DEBUG_CACHE) {
                        Log.d(mLogTag, ""=========== Recaching with new values: "" + id);
                    }
                    cursor.moveToFirst();
                    mLruCache.put(id, cursor);
                } else {
                    mLruCache.remove(id);
                }
            } else {
                mLruCache.remove(id);
            }
            // If there are no cursors using the old cached cursor, close it
            if (!sActiveCursors.contains(c)) {
                c.close();
            }
        }
        if (wasLocked) {
            mLockMap.subtract(id);
        }
    }

    /**
     * Invalidate the entire cache, without logging
     */
    public synchronized void invalidate() {
        invalidate(null, null, null);
    }

    /**
     * Invalidate the entire cache; the arguments are used for logging only, and indicate the
     * write operation that caused the invalidation
     *
     * @param operation a string describing the operation causing the invalidate (or null)
     * @param uri the uri causing the invalidate (or null)
     * @param selection the selection used with the uri (or null)
     */
    public synchronized void invalidate(String operation, Uri uri, String selection) {
        if (DEBUG_CACHE && (operation != null)) {
            Log.d(mLogTag, ""============ INVALIDATED BY "" + operation + "": "" + uri +
                    "", SELECTION: "" + selection);
        }
        mStats.mInvalidateCount++;
        // Close all cached cursors that are no longer in use
        mLruCache.evictAll();
        // Invalidate all current tokens
        mTokenList.invalidate();
    }

    // Debugging code below

    private void dumpOnCount(int num) {
        mStats.mOpCount++;
        if ((mStats.mOpCount % num) == 0) {
            dumpStats();
        }
    }

    /*package*/ void recordQueryTime(Cursor c, long nanoTime) {
        if (c instanceof CachedCursor) {
            mStats.hitTimes += nanoTime;
            mStats.hits++;
        } else {
            if (c.getCount() == 1) {
                mStats.missTimes += nanoTime;
                mStats.miss++;
            }
        }
    }

    public static synchronized void notCacheable(Uri uri, String selection) {
        if (DEBUG_NOT_CACHEABLE) {
            sNotCacheable++;
            String str = uri.toString() + ""$"" + selection;
            sNotCacheableMap.add(str);
        }
    }

    private static class CacheCounter implements Comparable<CacheCounter> {
        String uri;
        Integer count;

        CacheCounter(String _uri, Integer _count) {
            uri = _uri;
            count = _count;
        }

        @Override
        public int compareTo(CacheCounter another) {
            return another.count > count ? 1 : another.count == count ? 0 : -1;
        }
    }

    private static void dumpNotCacheableQueries() {
        int size = sNotCacheableMap.size();
        CacheCounter[] array = new CacheCounter[size];

        int i = 0;
        for (Map.Entry<String, Integer> entry: sNotCacheableMap.entrySet()) {
            array[i++] = new CacheCounter(entry.getKey(), entry.getValue());
        }
        Arrays.sort(array);
        for (CacheCounter cc: array) {
            Log.d(""NotCacheable"", cc.count + "": "" + cc.uri);
        }
    }

    // For use with unit tests
    public static void invalidateAllCaches() {
        for (ContentCache cache: sContentCaches) {
            cache.invalidate();
        }
    }

    /** Sets the cache lock. If the lock is {@code true}, also invalidates all cached items. */
    public static void setLockCacheForTest(boolean lock) {
        sLockCache = lock;
        if (sLockCache) {
            invalidateAllCaches();
        }
    }

    static class Statistics {
        private final ContentCache mCache;
        private final String mName;

        // Cache statistics
        // The item is in the cache AND is used to create a cursor
        private int mHitCount = 0;
        // Basic cache miss (the item is not cached)
        private int mMissCount = 0;
        // Incremented when a cachePut is invalid due to an intervening write
        private int mStaleCount = 0;
        // A projection miss occurs when the item is cached, but not all requested columns are
        // available in the base projection
        private int mProjectionMissCount = 0;
        // Incremented whenever the entire cache is invalidated
        private int mInvalidateCount = 0;
        // Count of operations put/get
        private int mOpCount = 0;
        // The following are for timing statistics
        private long hits = 0;
        private long hitTimes = 0;
        private long miss = 0;
        private long missTimes = 0;

        // Used in toString() and addCacheStatistics()
        private int mCursorCount = 0;
        private int mTokenCount = 0;

        Statistics(ContentCache cache) {
            mCache = cache;
            mName = mCache.mName;
        }

        Statistics(String name) {
            mCache = null;
            mName = name;
        }

        private void addCacheStatistics(ContentCache cache) {
            if (cache != null) {
                mHitCount += cache.mStats.mHitCount;
                mMissCount += cache.mStats.mMissCount;
                mProjectionMissCount += cache.mStats.mProjectionMissCount;
                mStaleCount += cache.mStats.mStaleCount;
                hitTimes += cache.mStats.hitTimes;
                missTimes += cache.mStats.missTimes;
                hits += cache.mStats.hits;
                miss += cache.mStats.miss;
                mCursorCount += cache.size();
                mTokenCount += cache.mTokenList.size();
            }
        }

        private void append(StringBuilder sb, String name, Object value) {
            sb.append("", "");
            sb.append(name);
            sb.append("": "");
            sb.append(value);
        }

        @Override
        public String toString() {
            if (mHitCount + mMissCount == 0) return ""No cache"";
            int totalTries = mMissCount + mProjectionMissCount + mHitCount;
            StringBuilder sb = new StringBuilder();
            sb.append(""Cache "" + mName);
            append(sb, ""Cursors"", mCache == null ? mCursorCount : mCache.size());
            append(sb, ""Hits"", mHitCount);
            append(sb, ""Misses"", mMissCount + mProjectionMissCount);
            append(sb, ""Inval"", mInvalidateCount);
            append(sb, ""Tokens"", mCache == null ? mTokenCount : mCache.mTokenList.size());
            append(sb, ""Hit%"", mHitCount * 100 / totalTries);
            append(sb, ""\nHit time"", hitTimes / 1000000.0 / hits);
            append(sb, ""Miss time"", missTimes / 1000000.0 / miss);
            return sb.toString();
        }
    }

    public static void dumpStats() {
        Statistics totals = new Statistics(""Totals"");

        for (ContentCache cache: sContentCaches) {
            if (cache != null) {
                Log.d(cache.mName, cache.mStats.toString());
                totals.addCacheStatistics(cache);
            }
        }
        Log.d(totals.mName, totals.toString());
    }
}
",True,290,2,14,11,50,10,1,L6
100,com.android.email.provider.AccountReconciler.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.provider;

import android.accounts.AccountManager;
import android.accounts.AccountManagerFuture;
import android.accounts.AuthenticatorException;
import android.accounts.OperationCanceledException;
import android.content.Context;
import android.util.Log;

import com.android.email.Controller;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.google.common.annotations.VisibleForTesting;

import java.io.IOException;
import java.util.List;

public class AccountReconciler {
    // AccountManager accounts with a name beginning with this constant are ignored for purposes
    // of reconcilation.  This is for unit test purposes only; the caller may NOT be in the same
    // package as this class, so we make the constant public.
    @VisibleForTesting
    static final String ACCOUNT_MANAGER_ACCOUNT_TEST_PREFIX = "" _"";

    /**
     * Checks two account lists to see if there is any reconciling to be done. Can be done on the
     * UI thread.
     * @param context the app context
     * @param emailProviderAccounts accounts as reported in the Email provider
     * @param accountManagerAccounts accounts as reported by the system account manager, for the
     *     particular protocol types that match emailProviderAccounts
     */
    public static boolean accountsNeedReconciling(
            final Context context,
            List<Account> emailProviderAccounts,
            android.accounts.Account[] accountManagerAccounts) {

        return reconcileAccountsInternal(
                context, emailProviderAccounts, accountManagerAccounts,
                context, false /* performReconciliation */);
    }

    /**
     * Compare our account list (obtained from EmailProvider) with the account list owned by
     * AccountManager.  If there are any orphans (an account in one list without a corresponding
     * account in the other list), delete the orphan, as these must remain in sync.
     *
     * Note that the duplication of account information is caused by the Email application's
     * incomplete integration with AccountManager.
     *
     * This function may not be called from the main/UI thread, because it makes blocking calls
     * into the account manager.
     *
     * @param context The context in which to operate
     * @param emailProviderAccounts the exchange provider accounts to work from
     * @param accountManagerAccounts The account manager accounts to work from
     * @param providerContext application provider context
     */
    public static void reconcileAccounts(
            Context context,
            List<Account> emailProviderAccounts,
            android.accounts.Account[] accountManagerAccounts,
            Context providerContext) {
        reconcileAccountsInternal(
                context, emailProviderAccounts, accountManagerAccounts,
                providerContext, true /* performReconciliation */);
    }

    /**
     * Internal method to actually perform reconciliation, or simply check that it needs to be done
     * and avoid doing any heavy work, depending on the value of the passed in
     * {@code performReconciliation}.
     */
    private static boolean reconcileAccountsInternal(
            Context context,
            List<Account> emailProviderAccounts,
            android.accounts.Account[] accountManagerAccounts,
            Context providerContext,
            boolean performReconciliation) {
        boolean needsReconciling = false;

        // First, look through our EmailProvider accounts to make sure there's a corresponding
        // AccountManager account
        for (Account providerAccount: emailProviderAccounts) {
            String providerAccountName = providerAccount.mEmailAddress;
            boolean found = false;
            for (android.accounts.Account accountManagerAccount: accountManagerAccounts) {
                if (accountManagerAccount.name.equalsIgnoreCase(providerAccountName)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                if ((providerAccount.mFlags & Account.FLAGS_INCOMPLETE) != 0) {
                    Log.w(Logging.LOG_TAG,
                            ""Account reconciler noticed incomplete account; ignoring"");
                    continue;
                }

                needsReconciling = true;
                if (performReconciliation) {
                    // This account has been deleted in the AccountManager!
                    Log.d(Logging.LOG_TAG,
                            ""Account deleted in AccountManager; deleting from provider: "" +
                            providerAccountName);
                    Controller.getInstance(context).deleteAccountSync(providerAccount.mId,
                            providerContext);
                }
            }
        }
        // Now, look through AccountManager accounts to make sure we have a corresponding cached EAS
        // account from EmailProvider
        for (android.accounts.Account accountManagerAccount: accountManagerAccounts) {
            String accountManagerAccountName = accountManagerAccount.name;
            boolean found = false;
            for (Account cachedEasAccount: emailProviderAccounts) {
                if (cachedEasAccount.mEmailAddress.equalsIgnoreCase(accountManagerAccountName)) {
                    found = true;
                }
            }
            if (accountManagerAccountName.startsWith(ACCOUNT_MANAGER_ACCOUNT_TEST_PREFIX)) {
                found = true;
            }
            if (!found) {
                // This account has been deleted from the EmailProvider database
                needsReconciling = true;

                if (performReconciliation) {
                    Log.d(Logging.LOG_TAG,
                            ""Account deleted from provider; deleting from AccountManager: "" +
                            accountManagerAccountName);
                    // Delete the account
                    AccountManagerFuture<Boolean> blockingResult = AccountManager.get(context)
                    .removeAccount(accountManagerAccount, null, null);
                    try {
                        // Note: All of the potential errors from removeAccount() are simply logged
                        // here, as there is nothing to actually do about them.
                        blockingResult.getResult();
                    } catch (OperationCanceledException e) {
                        Log.w(Logging.LOG_TAG, e.toString());
                    } catch (AuthenticatorException e) {
                        Log.w(Logging.LOG_TAG, e.toString());
                    } catch (IOException e) {
                        Log.w(Logging.LOG_TAG, e.toString());
                    }
                }
            }
        }

        return needsReconciling;
    }
}
",True,270,1,3,10,49,4,3,L6
101,com.android.email.provider.EmailProvider.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.provider;

import android.accounts.AccountManager;
import android.content.ContentProvider;
import android.content.ContentProviderOperation;
import android.content.ContentProviderResult;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.OperationApplicationException;
import android.content.UriMatcher;
import android.database.ContentObserver;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.net.Uri;
import android.provider.ContactsContract;
import android.text.TextUtils;
import android.util.Log;

import com.android.email.Email;
import com.android.email.Preferences;
import com.android.email.provider.ContentCache.CacheToken;
import com.android.email.service.AttachmentDownloadService;
import com.android.emailcommon.AccountManagerTypes;
import com.android.emailcommon.CalendarProviderStub;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.AttachmentColumns;
import com.android.emailcommon.provider.EmailContent.Body;
import com.android.emailcommon.provider.EmailContent.BodyColumns;
import com.android.emailcommon.provider.EmailContent.HostAuthColumns;
import com.android.emailcommon.provider.EmailContent.MailboxColumns;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.EmailContent.PolicyColumns;
import com.android.emailcommon.provider.EmailContent.QuickResponseColumns;
import com.android.emailcommon.provider.EmailContent.SyncColumns;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.provider.Policy;
import com.android.emailcommon.provider.QuickResponse;
import com.android.emailcommon.service.LegacyPolicySet;
import com.google.common.annotations.VisibleForTesting;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class EmailProvider extends ContentProvider {

    private static final String TAG = ""EmailProvider"";

    protected static final String DATABASE_NAME = ""EmailProvider.db"";
    protected static final String BODY_DATABASE_NAME = ""EmailProviderBody.db"";
    protected static final String BACKUP_DATABASE_NAME = ""EmailProviderBackup.db"";

    public static final String ACTION_ATTACHMENT_UPDATED = ""com.android.email.ATTACHMENT_UPDATED"";
    public static final String ATTACHMENT_UPDATED_EXTRA_FLAGS =
        ""com.android.email.ATTACHMENT_UPDATED_FLAGS"";

    public static final String EMAIL_MESSAGE_MIME_TYPE =
        ""vnd.android.cursor.item/email-message"";
    public static final String EMAIL_ATTACHMENT_MIME_TYPE =
        ""vnd.android.cursor.item/email-attachment"";

    public static final Uri INTEGRITY_CHECK_URI =
        Uri.parse(""content://"" + EmailContent.AUTHORITY + ""/integrityCheck"");
    public static final Uri ACCOUNT_BACKUP_URI =
        Uri.parse(""content://"" + EmailContent.AUTHORITY + ""/accountBackup"");

    /** Appended to the notification URI for delete operations */
    public static final String NOTIFICATION_OP_DELETE = ""delete"";
    /** Appended to the notification URI for insert operations */
    public static final String NOTIFICATION_OP_INSERT = ""insert"";
    /** Appended to the notification URI for update operations */
    public static final String NOTIFICATION_OP_UPDATE = ""update"";

    // Definitions for our queries looking for orphaned messages
    private static final String[] ORPHANS_PROJECTION
        = new String[] {MessageColumns.ID, MessageColumns.MAILBOX_KEY};
    private static final int ORPHANS_ID = 0;
    private static final int ORPHANS_MAILBOX_KEY = 1;

    private static final String WHERE_ID = EmailContent.RECORD_ID + ""=?"";

    // This is not a hard limit on accounts, per se, but beyond this, we can't guarantee that all
    // critical mailboxes, host auth's, accounts, and policies are cached
    private static final int MAX_CACHED_ACCOUNTS = 16;
    // Inbox, Drafts, Sent, Outbox, Trash, and Search (these boxes are cached when possible)
    private static final int NUM_ALWAYS_CACHED_MAILBOXES = 6;

    // We'll cache the following four tables; sizes are best estimates of effective values
    private final ContentCache mCacheAccount =
        new ContentCache(""Account"", Account.CONTENT_PROJECTION, MAX_CACHED_ACCOUNTS);
    private final ContentCache mCacheHostAuth =
        new ContentCache(""HostAuth"", HostAuth.CONTENT_PROJECTION, MAX_CACHED_ACCOUNTS * 2);
    /*package*/ final ContentCache mCacheMailbox =
        new ContentCache(""Mailbox"", Mailbox.CONTENT_PROJECTION,
                MAX_CACHED_ACCOUNTS * (NUM_ALWAYS_CACHED_MAILBOXES + 2));
    private final ContentCache mCacheMessage =
        new ContentCache(""Message"", Message.CONTENT_PROJECTION, 8);
    private final ContentCache mCachePolicy =
        new ContentCache(""Policy"", Policy.CONTENT_PROJECTION, MAX_CACHED_ACCOUNTS);

    // Any changes to the database format *must* include update-in-place code.
    // Original version: 3
    // Version 4: Database wipe required; changing AccountManager interface w/Exchange
    // Version 5: Database wipe required; changing AccountManager interface w/Exchange
    // Version 6: Adding Message.mServerTimeStamp column
    // Version 7: Replace the mailbox_delete trigger with a version that removes orphaned messages
    //            from the Message_Deletes and Message_Updates tables
    // Version 8: Add security flags column to accounts table
    // Version 9: Add security sync key and signature to accounts table
    // Version 10: Add meeting info to message table
    // Version 11: Add content and flags to attachment table
    // Version 12: Add content_bytes to attachment table. content is deprecated.
    // Version 13: Add messageCount to Mailbox table.
    // Version 14: Add snippet to Message table
    // Version 15: Fix upgrade problem in version 14.
    // Version 16: Add accountKey to Attachment table
    // Version 17: Add parentKey to Mailbox table
    // Version 18: Copy Mailbox.displayName to Mailbox.serverId for all IMAP & POP3 mailboxes.
    //             Column Mailbox.serverId is used for the server-side pathname of a mailbox.
    // Version 19: Add Policy table; add policyKey to Account table and trigger to delete an
    //             Account's policy when the Account is deleted
    // Version 20: Add new policies to Policy table
    // Version 21: Add lastSeenMessageKey column to Mailbox table
    // Version 22: Upgrade path for IMAP/POP accounts to integrate with AccountManager
    // Version 23: Add column to mailbox table for time of last access
    // Version 24: Add column to hostauth table for client cert alias
    // Version 25: Added QuickResponse table
    // Version 26: Update IMAP accounts to add FLAG_SUPPORTS_SEARCH flag
    // Version 27: Add protocolSearchInfo to Message table
    // Version 28: Add notifiedMessageId and notifiedMessageCount to Account

    public static final int DATABASE_VERSION = 28;

    // Any changes to the database format *must* include update-in-place code.
    // Original version: 2
    // Version 3: Add ""sourceKey"" column
    // Version 4: Database wipe required; changing AccountManager interface w/Exchange
    // Version 5: Database wipe required; changing AccountManager interface w/Exchange
    // Version 6: Adding Body.mIntroText column
    public static final int BODY_DATABASE_VERSION = 6;

    private static final int ACCOUNT_BASE = 0;
    private static final int ACCOUNT = ACCOUNT_BASE;
    private static final int ACCOUNT_ID = ACCOUNT_BASE + 1;
    private static final int ACCOUNT_ID_ADD_TO_FIELD = ACCOUNT_BASE + 2;
    private static final int ACCOUNT_RESET_NEW_COUNT = ACCOUNT_BASE + 3;
    private static final int ACCOUNT_RESET_NEW_COUNT_ID = ACCOUNT_BASE + 4;
    private static final int ACCOUNT_DEFAULT_ID = ACCOUNT_BASE + 5;

    private static final int MAILBOX_BASE = 0x1000;
    private static final int MAILBOX = MAILBOX_BASE;
    private static final int MAILBOX_ID = MAILBOX_BASE + 1;
    private static final int MAILBOX_ID_FROM_ACCOUNT_AND_TYPE = MAILBOX_BASE + 2;
    private static final int MAILBOX_ID_ADD_TO_FIELD = MAILBOX_BASE + 2;

    private static final int MESSAGE_BASE = 0x2000;
    private static final int MESSAGE = MESSAGE_BASE;
    private static final int MESSAGE_ID = MESSAGE_BASE + 1;
    private static final int SYNCED_MESSAGE_ID = MESSAGE_BASE + 2;

    private static final int ATTACHMENT_BASE = 0x3000;
    private static final int ATTACHMENT = ATTACHMENT_BASE;
    private static final int ATTACHMENT_ID = ATTACHMENT_BASE + 1;
    private static final int ATTACHMENTS_MESSAGE_ID = ATTACHMENT_BASE + 2;

    private static final int HOSTAUTH_BASE = 0x4000;
    private static final int HOSTAUTH = HOSTAUTH_BASE;
    private static final int HOSTAUTH_ID = HOSTAUTH_BASE + 1;

    private static final int UPDATED_MESSAGE_BASE = 0x5000;
    private static final int UPDATED_MESSAGE = UPDATED_MESSAGE_BASE;
    private static final int UPDATED_MESSAGE_ID = UPDATED_MESSAGE_BASE + 1;

    private static final int DELETED_MESSAGE_BASE = 0x6000;
    private static final int DELETED_MESSAGE = DELETED_MESSAGE_BASE;
    private static final int DELETED_MESSAGE_ID = DELETED_MESSAGE_BASE + 1;

    private static final int POLICY_BASE = 0x7000;
    private static final int POLICY = POLICY_BASE;
    private static final int POLICY_ID = POLICY_BASE + 1;

    private static final int QUICK_RESPONSE_BASE = 0x8000;
    private static final int QUICK_RESPONSE = QUICK_RESPONSE_BASE;
    private static final int QUICK_RESPONSE_ID = QUICK_RESPONSE_BASE + 1;
    private static final int QUICK_RESPONSE_ACCOUNT_ID = QUICK_RESPONSE_BASE + 2;

    // MUST ALWAYS EQUAL THE LAST OF THE PREVIOUS BASE CONSTANTS
    private static final int LAST_EMAIL_PROVIDER_DB_BASE = QUICK_RESPONSE_BASE;

    // DO NOT CHANGE BODY_BASE!!
    private static final int BODY_BASE = LAST_EMAIL_PROVIDER_DB_BASE + 0x1000;
    private static final int BODY = BODY_BASE;
    private static final int BODY_ID = BODY_BASE + 1;

    private static final int BASE_SHIFT = 12;  // 12 bits to the base type: 0, 0x1000, 0x2000, etc.

    // TABLE_NAMES MUST remain in the order of the BASE constants above (e.g. ACCOUNT_BASE = 0x0000,
    // MESSAGE_BASE = 0x1000, etc.)
    private static final String[] TABLE_NAMES = {
        Account.TABLE_NAME,
        Mailbox.TABLE_NAME,
        Message.TABLE_NAME,
        Attachment.TABLE_NAME,
        HostAuth.TABLE_NAME,
        Message.UPDATED_TABLE_NAME,
        Message.DELETED_TABLE_NAME,
        Policy.TABLE_NAME,
        QuickResponse.TABLE_NAME,
        Body.TABLE_NAME
    };

    // CONTENT_CACHES MUST remain in the order of the BASE constants above
    private final ContentCache[] mContentCaches = {
        mCacheAccount,
        mCacheMailbox,
        mCacheMessage,
        null, // Attachment
        mCacheHostAuth,
        null, // Updated message
        null, // Deleted message
        mCachePolicy,
        null, // Quick response
        null  // Body
    };

    // CACHE_PROJECTIONS MUST remain in the order of the BASE constants above
    private static final String[][] CACHE_PROJECTIONS = {
        Account.CONTENT_PROJECTION,
        Mailbox.CONTENT_PROJECTION,
        Message.CONTENT_PROJECTION,
        null, // Attachment
        HostAuth.CONTENT_PROJECTION,
        null, // Updated message
        null, // Deleted message
        Policy.CONTENT_PROJECTION,
        null,  // Quick response
        null  // Body
    };

    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);

    private static final String MAILBOX_PRE_CACHE_SELECTION = MailboxColumns.TYPE + "" IN ("" +
        Mailbox.TYPE_INBOX + "","" + Mailbox.TYPE_DRAFTS + "","" + Mailbox.TYPE_TRASH + "","" +
        Mailbox.TYPE_SENT + "","" + Mailbox.TYPE_SEARCH + "","" + Mailbox.TYPE_OUTBOX + "")"";

    /**
     * Let's only generate these SQL strings once, as they are used frequently
     * Note that this isn't relevant for table creation strings, since they are used only once
     */
    private static final String UPDATED_MESSAGE_INSERT = ""insert or ignore into "" +
        Message.UPDATED_TABLE_NAME + "" select * from "" + Message.TABLE_NAME + "" where "" +
        EmailContent.RECORD_ID + '=';

    private static final String UPDATED_MESSAGE_DELETE = ""delete from "" +
        Message.UPDATED_TABLE_NAME + "" where "" + EmailContent.RECORD_ID + '=';

    private static final String DELETED_MESSAGE_INSERT = ""insert or replace into "" +
        Message.DELETED_TABLE_NAME + "" select * from "" + Message.TABLE_NAME + "" where "" +
        EmailContent.RECORD_ID + '=';

    private static final String DELETE_ORPHAN_BODIES = ""delete from "" + Body.TABLE_NAME +
        "" where "" + BodyColumns.MESSAGE_KEY + "" in "" + ""(select "" + BodyColumns.MESSAGE_KEY +
        "" from "" + Body.TABLE_NAME + "" except select "" + EmailContent.RECORD_ID + "" from "" +
        Message.TABLE_NAME + ')';

    private static final String DELETE_BODY = ""delete from "" + Body.TABLE_NAME +
        "" where "" + BodyColumns.MESSAGE_KEY + '=';

    private static final String ID_EQUALS = EmailContent.RECORD_ID + ""=?"";

    private static final String TRIGGER_MAILBOX_DELETE =
        ""create trigger mailbox_delete before delete on "" + Mailbox.TABLE_NAME +
        "" begin"" +
        "" delete from "" + Message.TABLE_NAME +
        ""  where "" + MessageColumns.MAILBOX_KEY + ""=old."" + EmailContent.RECORD_ID +
        ""; delete from "" + Message.UPDATED_TABLE_NAME +
        ""  where "" + MessageColumns.MAILBOX_KEY + ""=old."" + EmailContent.RECORD_ID +
        ""; delete from "" + Message.DELETED_TABLE_NAME +
        ""  where "" + MessageColumns.MAILBOX_KEY + ""=old."" + EmailContent.RECORD_ID +
        ""; end"";

    private static final String TRIGGER_ACCOUNT_DELETE =
        ""create trigger account_delete before delete on "" + Account.TABLE_NAME +
        "" begin delete from "" + Mailbox.TABLE_NAME +
        "" where "" + MailboxColumns.ACCOUNT_KEY + ""=old."" + EmailContent.RECORD_ID +
        ""; delete from "" + HostAuth.TABLE_NAME +
        "" where "" + EmailContent.RECORD_ID + ""=old."" + AccountColumns.HOST_AUTH_KEY_RECV +
        ""; delete from "" + HostAuth.TABLE_NAME +
        "" where "" + EmailContent.RECORD_ID + ""=old."" + AccountColumns.HOST_AUTH_KEY_SEND +
        ""; delete from "" + Policy.TABLE_NAME +
        "" where "" + EmailContent.RECORD_ID + ""=old."" + AccountColumns.POLICY_KEY +
        ""; end"";

    private static final ContentValues CONTENT_VALUES_RESET_NEW_MESSAGE_COUNT;

    public static final String MESSAGE_URI_PARAMETER_MAILBOX_ID = ""mailboxId"";

    static {
        // Email URI matching table
        UriMatcher matcher = sURIMatcher;

        // All accounts
        matcher.addURI(EmailContent.AUTHORITY, ""account"", ACCOUNT);
        // A specific account
        // insert into this URI causes a mailbox to be added to the account
        matcher.addURI(EmailContent.AUTHORITY, ""account/#"", ACCOUNT_ID);
        matcher.addURI(EmailContent.AUTHORITY, ""account/default"", ACCOUNT_DEFAULT_ID);

        // Special URI to reset the new message count.  Only update works, and content values
        // will be ignored.
        matcher.addURI(EmailContent.AUTHORITY, ""resetNewMessageCount"",
                ACCOUNT_RESET_NEW_COUNT);
        matcher.addURI(EmailContent.AUTHORITY, ""resetNewMessageCount/#"",
                ACCOUNT_RESET_NEW_COUNT_ID);

        // All mailboxes
        matcher.addURI(EmailContent.AUTHORITY, ""mailbox"", MAILBOX);
        // A specific mailbox
        // insert into this URI causes a message to be added to the mailbox
        // ** NOTE For now, the accountKey must be set manually in the values!
        matcher.addURI(EmailContent.AUTHORITY, ""mailbox/#"", MAILBOX_ID);
        matcher.addURI(EmailContent.AUTHORITY, ""mailboxIdFromAccountAndType/#/#"",
                MAILBOX_ID_FROM_ACCOUNT_AND_TYPE);
        // All messages
        matcher.addURI(EmailContent.AUTHORITY, ""message"", MESSAGE);
        // A specific message
        // insert into this URI causes an attachment to be added to the message
        matcher.addURI(EmailContent.AUTHORITY, ""message/#"", MESSAGE_ID);

        // A specific attachment
        matcher.addURI(EmailContent.AUTHORITY, ""attachment"", ATTACHMENT);
        // A specific attachment (the header information)
        matcher.addURI(EmailContent.AUTHORITY, ""attachment/#"", ATTACHMENT_ID);
        // The attachments of a specific message (query only) (insert & delete TBD)
        matcher.addURI(EmailContent.AUTHORITY, ""attachment/message/#"",
                ATTACHMENTS_MESSAGE_ID);

        // All mail bodies
        matcher.addURI(EmailContent.AUTHORITY, ""body"", BODY);
        // A specific mail body
        matcher.addURI(EmailContent.AUTHORITY, ""body/#"", BODY_ID);

        // All hostauth records
        matcher.addURI(EmailContent.AUTHORITY, ""hostauth"", HOSTAUTH);
        // A specific hostauth
        matcher.addURI(EmailContent.AUTHORITY, ""hostauth/#"", HOSTAUTH_ID);

        // Atomically a constant value to a particular field of a mailbox/account
        matcher.addURI(EmailContent.AUTHORITY, ""mailboxIdAddToField/#"",
                MAILBOX_ID_ADD_TO_FIELD);
        matcher.addURI(EmailContent.AUTHORITY, ""accountIdAddToField/#"",
                ACCOUNT_ID_ADD_TO_FIELD);

        /**
         * THIS URI HAS SPECIAL SEMANTICS
         * ITS USE IS INTENDED FOR THE UI APPLICATION TO MARK CHANGES THAT NEED TO BE SYNCED BACK
         * TO A SERVER VIA A SYNC ADAPTER
         */
        matcher.addURI(EmailContent.AUTHORITY, ""syncedMessage/#"", SYNCED_MESSAGE_ID);

        /**
         * THE URIs BELOW THIS POINT ARE INTENDED TO BE USED BY SYNC ADAPTERS ONLY
         * THEY REFER TO DATA CREATED AND MAINTAINED BY CALLS TO THE SYNCED_MESSAGE_ID URI
         * BY THE UI APPLICATION
         */
        // All deleted messages
        matcher.addURI(EmailContent.AUTHORITY, ""deletedMessage"", DELETED_MESSAGE);
        // A specific deleted message
        matcher.addURI(EmailContent.AUTHORITY, ""deletedMessage/#"", DELETED_MESSAGE_ID);

        // All updated messages
        matcher.addURI(EmailContent.AUTHORITY, ""updatedMessage"", UPDATED_MESSAGE);
        // A specific updated message
        matcher.addURI(EmailContent.AUTHORITY, ""updatedMessage/#"", UPDATED_MESSAGE_ID);

        CONTENT_VALUES_RESET_NEW_MESSAGE_COUNT = new ContentValues();
        CONTENT_VALUES_RESET_NEW_MESSAGE_COUNT.put(Account.NEW_MESSAGE_COUNT, 0);

        matcher.addURI(EmailContent.AUTHORITY, ""policy"", POLICY);
        matcher.addURI(EmailContent.AUTHORITY, ""policy/#"", POLICY_ID);

        // All quick responses
        matcher.addURI(EmailContent.AUTHORITY, ""quickresponse"", QUICK_RESPONSE);
        // A specific quick response
        matcher.addURI(EmailContent.AUTHORITY, ""quickresponse/#"", QUICK_RESPONSE_ID);
        // All quick responses associated with a particular account id
        matcher.addURI(EmailContent.AUTHORITY, ""quickresponse/account/#"",
                QUICK_RESPONSE_ACCOUNT_ID);
    }

    /**
     * Wrap the UriMatcher call so we can throw a runtime exception if an unknown Uri is passed in
     * @param uri the Uri to match
     * @return the match value
     */
    private static int findMatch(Uri uri, String methodName) {
        int match = sURIMatcher.match(uri);
        if (match < 0) {
            throw new IllegalArgumentException(""Unknown uri: "" + uri);
        } else if (Logging.LOGD) {
            Log.v(TAG, methodName + "": uri="" + uri + "", match is "" + match);
        }
        return match;
    }

    /*
     * Internal helper method for index creation.
     * Example:
     * ""create index message_"" + MessageColumns.FLAG_READ
     * + "" on "" + Message.TABLE_NAME + "" ("" + MessageColumns.FLAG_READ + "");""
     */
    /* package */
    static String createIndex(String tableName, String columnName) {
        return ""create index "" + tableName.toLowerCase() + '_' + columnName
            + "" on "" + tableName + "" ("" + columnName + "");"";
    }

    static void createMessageTable(SQLiteDatabase db) {
        String messageColumns = MessageColumns.DISPLAY_NAME + "" text, ""
            + MessageColumns.TIMESTAMP + "" integer, ""
            + MessageColumns.SUBJECT + "" text, ""
            + MessageColumns.FLAG_READ + "" integer, ""
            + MessageColumns.FLAG_LOADED + "" integer, ""
            + MessageColumns.FLAG_FAVORITE + "" integer, ""
            + MessageColumns.FLAG_ATTACHMENT + "" integer, ""
            + MessageColumns.FLAGS + "" integer, ""
            + MessageColumns.CLIENT_ID + "" integer, ""
            + MessageColumns.MESSAGE_ID + "" text, ""
            + MessageColumns.MAILBOX_KEY + "" integer, ""
            + MessageColumns.ACCOUNT_KEY + "" integer, ""
            + MessageColumns.FROM_LIST + "" text, ""
            + MessageColumns.TO_LIST + "" text, ""
            + MessageColumns.CC_LIST + "" text, ""
            + MessageColumns.BCC_LIST + "" text, ""
            + MessageColumns.REPLY_TO_LIST + "" text, ""
            + MessageColumns.MEETING_INFO + "" text, ""
            + MessageColumns.SNIPPET + "" text, ""
            + MessageColumns.PROTOCOL_SEARCH_INFO + "" text""
            + "");"";

        // This String and the following String MUST have the same columns, except for the type
        // of those columns!
        String createString = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
            + SyncColumns.SERVER_ID + "" text, ""
            + SyncColumns.SERVER_TIMESTAMP + "" integer, ""
            + messageColumns;

        // For the updated and deleted tables, the id is assigned, but we do want to keep track
        // of the ORDER of updates using an autoincrement primary key.  We use the DATA column
        // at this point; it has no other function
        String altCreateString = "" ("" + EmailContent.RECORD_ID + "" integer unique, ""
            + SyncColumns.SERVER_ID + "" text, ""
            + SyncColumns.SERVER_TIMESTAMP + "" integer, ""
            + messageColumns;

        // The three tables have the same schema
        db.execSQL(""create table "" + Message.TABLE_NAME + createString);
        db.execSQL(""create table "" + Message.UPDATED_TABLE_NAME + altCreateString);
        db.execSQL(""create table "" + Message.DELETED_TABLE_NAME + altCreateString);

        String indexColumns[] = {
            MessageColumns.TIMESTAMP,
            MessageColumns.FLAG_READ,
            MessageColumns.FLAG_LOADED,
            MessageColumns.MAILBOX_KEY,
            SyncColumns.SERVER_ID
        };

        for (String columnName : indexColumns) {
            db.execSQL(createIndex(Message.TABLE_NAME, columnName));
        }

        // Deleting a Message deletes all associated Attachments
        // Deleting the associated Body cannot be done in a trigger, because the Body is stored
        // in a separate database, and trigger cannot operate on attached databases.
        db.execSQL(""create trigger message_delete before delete on "" + Message.TABLE_NAME +
                "" begin delete from "" + Attachment.TABLE_NAME +
                ""  where "" + AttachmentColumns.MESSAGE_KEY + ""=old."" + EmailContent.RECORD_ID +
                ""; end"");

        // Add triggers to keep unread count accurate per mailbox

        // NOTE: SQLite's before triggers are not safe when recursive triggers are involved.
        // Use caution when changing them.

        // Insert a message; if flagRead is zero, add to the unread count of the message's mailbox
        db.execSQL(""create trigger unread_message_insert before insert on "" + Message.TABLE_NAME +
                "" when NEW."" + MessageColumns.FLAG_READ + ""=0"" +
                "" begin update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.UNREAD_COUNT +
                '=' + MailboxColumns.UNREAD_COUNT + ""+1"" +
                ""  where "" + EmailContent.RECORD_ID + ""=NEW."" + MessageColumns.MAILBOX_KEY +
                ""; end"");

        // Delete a message; if flagRead is zero, decrement the unread count of the msg's mailbox
        db.execSQL(""create trigger unread_message_delete before delete on "" + Message.TABLE_NAME +
                "" when OLD."" + MessageColumns.FLAG_READ + ""=0"" +
                "" begin update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.UNREAD_COUNT +
                '=' + MailboxColumns.UNREAD_COUNT + ""-1"" +
                ""  where "" + EmailContent.RECORD_ID + ""=OLD."" + MessageColumns.MAILBOX_KEY +
                ""; end"");

        // Change a message's mailbox
        db.execSQL(""create trigger unread_message_move before update of "" +
                MessageColumns.MAILBOX_KEY + "" on "" + Message.TABLE_NAME +
                "" when OLD."" + MessageColumns.FLAG_READ + ""=0"" +
                "" begin update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.UNREAD_COUNT +
                '=' + MailboxColumns.UNREAD_COUNT + ""-1"" +
                ""  where "" + EmailContent.RECORD_ID + ""=OLD."" + MessageColumns.MAILBOX_KEY +
                ""; update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.UNREAD_COUNT +
                '=' + MailboxColumns.UNREAD_COUNT + ""+1"" +
                "" where "" + EmailContent.RECORD_ID + ""=NEW."" + MessageColumns.MAILBOX_KEY +
                ""; end"");

        // Change a message's read state
        db.execSQL(""create trigger unread_message_read before update of "" +
                MessageColumns.FLAG_READ + "" on "" + Message.TABLE_NAME +
                "" when OLD."" + MessageColumns.FLAG_READ + ""!=NEW."" + MessageColumns.FLAG_READ +
                "" begin update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.UNREAD_COUNT +
                '=' + MailboxColumns.UNREAD_COUNT + ""+ case OLD."" + MessageColumns.FLAG_READ +
                "" when 0 then -1 else 1 end"" +
                ""  where "" + EmailContent.RECORD_ID + ""=OLD."" + MessageColumns.MAILBOX_KEY +
                ""; end"");

        // Add triggers to update message count per mailbox

        // Insert a message.
        db.execSQL(""create trigger message_count_message_insert after insert on "" +
                Message.TABLE_NAME +
                "" begin update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.MESSAGE_COUNT +
                '=' + MailboxColumns.MESSAGE_COUNT + ""+1"" +
                ""  where "" + EmailContent.RECORD_ID + ""=NEW."" + MessageColumns.MAILBOX_KEY +
                ""; end"");

        // Delete a message; if flagRead is zero, decrement the unread count of the msg's mailbox
        db.execSQL(""create trigger message_count_message_delete after delete on "" +
                Message.TABLE_NAME +
                "" begin update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.MESSAGE_COUNT +
                '=' + MailboxColumns.MESSAGE_COUNT + ""-1"" +
                ""  where "" + EmailContent.RECORD_ID + ""=OLD."" + MessageColumns.MAILBOX_KEY +
                ""; end"");

        // Change a message's mailbox
        db.execSQL(""create trigger message_count_message_move after update of "" +
                MessageColumns.MAILBOX_KEY + "" on "" + Message.TABLE_NAME +
                "" begin update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.MESSAGE_COUNT +
                '=' + MailboxColumns.MESSAGE_COUNT + ""-1"" +
                ""  where "" + EmailContent.RECORD_ID + ""=OLD."" + MessageColumns.MAILBOX_KEY +
                ""; update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.MESSAGE_COUNT +
                '=' + MailboxColumns.MESSAGE_COUNT + ""+1"" +
                "" where "" + EmailContent.RECORD_ID + ""=NEW."" + MessageColumns.MAILBOX_KEY +
                ""; end"");
    }

    static void resetMessageTable(SQLiteDatabase db, int oldVersion, int newVersion) {
        try {
            db.execSQL(""drop table "" + Message.TABLE_NAME);
            db.execSQL(""drop table "" + Message.UPDATED_TABLE_NAME);
            db.execSQL(""drop table "" + Message.DELETED_TABLE_NAME);
        } catch (SQLException e) {
        }
        createMessageTable(db);
    }

    @SuppressWarnings(""deprecation"")
    static void createAccountTable(SQLiteDatabase db) {
        String s = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
            + AccountColumns.DISPLAY_NAME + "" text, ""
            + AccountColumns.EMAIL_ADDRESS + "" text, ""
            + AccountColumns.SYNC_KEY + "" text, ""
            + AccountColumns.SYNC_LOOKBACK + "" integer, ""
            + AccountColumns.SYNC_INTERVAL + "" text, ""
            + AccountColumns.HOST_AUTH_KEY_RECV + "" integer, ""
            + AccountColumns.HOST_AUTH_KEY_SEND + "" integer, ""
            + AccountColumns.FLAGS + "" integer, ""
            + AccountColumns.IS_DEFAULT + "" integer, ""
            + AccountColumns.COMPATIBILITY_UUID + "" text, ""
            + AccountColumns.SENDER_NAME + "" text, ""
            + AccountColumns.RINGTONE_URI + "" text, ""
            + AccountColumns.PROTOCOL_VERSION + "" text, ""
            + AccountColumns.NEW_MESSAGE_COUNT + "" integer, ""
            + AccountColumns.SECURITY_FLAGS + "" integer, ""
            + AccountColumns.SECURITY_SYNC_KEY + "" text, ""
            + AccountColumns.SIGNATURE + "" text, ""
            + AccountColumns.POLICY_KEY + "" integer, ""
            + AccountColumns.NOTIFIED_MESSAGE_ID + "" integer, ""
            + AccountColumns.NOTIFIED_MESSAGE_COUNT + "" integer""
            + "");"";
        db.execSQL(""create table "" + Account.TABLE_NAME + s);
        // Deleting an account deletes associated Mailboxes and HostAuth's
        db.execSQL(TRIGGER_ACCOUNT_DELETE);
    }

    static void resetAccountTable(SQLiteDatabase db, int oldVersion, int newVersion) {
        try {
            db.execSQL(""drop table "" +  Account.TABLE_NAME);
        } catch (SQLException e) {
        }
        createAccountTable(db);
    }

    static void createPolicyTable(SQLiteDatabase db) {
        String s = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
            + PolicyColumns.PASSWORD_MODE + "" integer, ""
            + PolicyColumns.PASSWORD_MIN_LENGTH + "" integer, ""
            + PolicyColumns.PASSWORD_EXPIRATION_DAYS + "" integer, ""
            + PolicyColumns.PASSWORD_HISTORY + "" integer, ""
            + PolicyColumns.PASSWORD_COMPLEX_CHARS + "" integer, ""
            + PolicyColumns.PASSWORD_MAX_FAILS + "" integer, ""
            + PolicyColumns.MAX_SCREEN_LOCK_TIME + "" integer, ""
            + PolicyColumns.REQUIRE_REMOTE_WIPE + "" integer, ""
            + PolicyColumns.REQUIRE_ENCRYPTION + "" integer, ""
            + PolicyColumns.REQUIRE_ENCRYPTION_EXTERNAL + "" integer, ""
            + PolicyColumns.REQUIRE_MANUAL_SYNC_WHEN_ROAMING + "" integer, ""
            + PolicyColumns.DONT_ALLOW_CAMERA + "" integer, ""
            + PolicyColumns.DONT_ALLOW_ATTACHMENTS + "" integer, ""
            + PolicyColumns.DONT_ALLOW_HTML + "" integer, ""
            + PolicyColumns.MAX_ATTACHMENT_SIZE + "" integer, ""
            + PolicyColumns.MAX_TEXT_TRUNCATION_SIZE + "" integer, ""
            + PolicyColumns.MAX_HTML_TRUNCATION_SIZE + "" integer, ""
            + PolicyColumns.MAX_EMAIL_LOOKBACK + "" integer, ""
            + PolicyColumns.MAX_CALENDAR_LOOKBACK + "" integer, ""
            + PolicyColumns.PASSWORD_RECOVERY_ENABLED + "" integer""
            + "");"";
        db.execSQL(""create table "" + Policy.TABLE_NAME + s);
    }

    static void createHostAuthTable(SQLiteDatabase db) {
        String s = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
            + HostAuthColumns.PROTOCOL + "" text, ""
            + HostAuthColumns.ADDRESS + "" text, ""
            + HostAuthColumns.PORT + "" integer, ""
            + HostAuthColumns.FLAGS + "" integer, ""
            + HostAuthColumns.LOGIN + "" text, ""
            + HostAuthColumns.PASSWORD + "" text, ""
            + HostAuthColumns.DOMAIN + "" text, ""
            + HostAuthColumns.ACCOUNT_KEY + "" integer,""
            + HostAuthColumns.CLIENT_CERT_ALIAS + "" text""
            + "");"";
        db.execSQL(""create table "" + HostAuth.TABLE_NAME + s);
    }

    static void resetHostAuthTable(SQLiteDatabase db, int oldVersion, int newVersion) {
        try {
            db.execSQL(""drop table "" + HostAuth.TABLE_NAME);
        } catch (SQLException e) {
        }
        createHostAuthTable(db);
    }

    static void createMailboxTable(SQLiteDatabase db) {
        String s = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
            + MailboxColumns.DISPLAY_NAME + "" text, ""
            + MailboxColumns.SERVER_ID + "" text, ""
            + MailboxColumns.PARENT_SERVER_ID + "" text, ""
            + MailboxColumns.PARENT_KEY + "" integer, ""
            + MailboxColumns.ACCOUNT_KEY + "" integer, ""
            + MailboxColumns.TYPE + "" integer, ""
            + MailboxColumns.DELIMITER + "" integer, ""
            + MailboxColumns.SYNC_KEY + "" text, ""
            + MailboxColumns.SYNC_LOOKBACK + "" integer, ""
            + MailboxColumns.SYNC_INTERVAL + "" integer, ""
            + MailboxColumns.SYNC_TIME + "" integer, ""
            + MailboxColumns.UNREAD_COUNT + "" integer, ""
            + MailboxColumns.FLAG_VISIBLE + "" integer, ""
            + MailboxColumns.FLAGS + "" integer, ""
            + MailboxColumns.VISIBLE_LIMIT + "" integer, ""
            + MailboxColumns.SYNC_STATUS + "" text, ""
            + MailboxColumns.MESSAGE_COUNT + "" integer not null default 0, ""
            + MailboxColumns.LAST_SEEN_MESSAGE_KEY + "" integer, ""
            + MailboxColumns.LAST_TOUCHED_TIME + "" integer default 0""
            + "");"";
        db.execSQL(""create table "" + Mailbox.TABLE_NAME + s);
        db.execSQL(""create index mailbox_"" + MailboxColumns.SERVER_ID
                + "" on "" + Mailbox.TABLE_NAME + "" ("" + MailboxColumns.SERVER_ID + "")"");
        db.execSQL(""create index mailbox_"" + MailboxColumns.ACCOUNT_KEY
                + "" on "" + Mailbox.TABLE_NAME + "" ("" + MailboxColumns.ACCOUNT_KEY + "")"");
        // Deleting a Mailbox deletes associated Messages in all three tables
        db.execSQL(TRIGGER_MAILBOX_DELETE);
    }

    static void resetMailboxTable(SQLiteDatabase db, int oldVersion, int newVersion) {
        try {
            db.execSQL(""drop table "" + Mailbox.TABLE_NAME);
        } catch (SQLException e) {
        }
        createMailboxTable(db);
    }

    static void createAttachmentTable(SQLiteDatabase db) {
        String s = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
            + AttachmentColumns.FILENAME + "" text, ""
            + AttachmentColumns.MIME_TYPE + "" text, ""
            + AttachmentColumns.SIZE + "" integer, ""
            + AttachmentColumns.CONTENT_ID + "" text, ""
            + AttachmentColumns.CONTENT_URI + "" text, ""
            + AttachmentColumns.MESSAGE_KEY + "" integer, ""
            + AttachmentColumns.LOCATION + "" text, ""
            + AttachmentColumns.ENCODING + "" text, ""
            + AttachmentColumns.CONTENT + "" text, ""
            + AttachmentColumns.FLAGS + "" integer, ""
            + AttachmentColumns.CONTENT_BYTES + "" blob, ""
            + AttachmentColumns.ACCOUNT_KEY + "" integer""
            + "");"";
        db.execSQL(""create table "" + Attachment.TABLE_NAME + s);
        db.execSQL(createIndex(Attachment.TABLE_NAME, AttachmentColumns.MESSAGE_KEY));
    }

    static void resetAttachmentTable(SQLiteDatabase db, int oldVersion, int newVersion) {
        try {
            db.execSQL(""drop table "" + Attachment.TABLE_NAME);
        } catch (SQLException e) {
        }
        createAttachmentTable(db);
    }

    static void createQuickResponseTable(SQLiteDatabase db) {
        String s = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
                + QuickResponseColumns.TEXT + "" text, ""
                + QuickResponseColumns.ACCOUNT_KEY + "" integer""
                + "");"";
        db.execSQL(""create table "" + QuickResponse.TABLE_NAME + s);
    }

    static void createBodyTable(SQLiteDatabase db) {
        String s = "" ("" + EmailContent.RECORD_ID + "" integer primary key autoincrement, ""
            + BodyColumns.MESSAGE_KEY + "" integer, ""
            + BodyColumns.HTML_CONTENT + "" text, ""
            + BodyColumns.TEXT_CONTENT + "" text, ""
            + BodyColumns.HTML_REPLY + "" text, ""
            + BodyColumns.TEXT_REPLY + "" text, ""
            + BodyColumns.SOURCE_MESSAGE_KEY + "" text, ""
            + BodyColumns.INTRO_TEXT + "" text""
            + "");"";
        db.execSQL(""create table "" + Body.TABLE_NAME + s);
        db.execSQL(createIndex(Body.TABLE_NAME, BodyColumns.MESSAGE_KEY));
    }

    static void upgradeBodyTable(SQLiteDatabase db, int oldVersion, int newVersion) {
        if (oldVersion < 5) {
            try {
                db.execSQL(""drop table "" + Body.TABLE_NAME);
                createBodyTable(db);
            } catch (SQLException e) {
            }
        } else if (oldVersion == 5) {
            try {
                db.execSQL(""alter table "" + Body.TABLE_NAME
                        + "" add "" + BodyColumns.INTRO_TEXT + "" text"");
            } catch (SQLException e) {
                // Shouldn't be needed unless we're debugging and interrupt the process
                Log.w(TAG, ""Exception upgrading EmailProviderBody.db from v5 to v6"", e);
            }
            oldVersion = 6;
        }
    }

    private SQLiteDatabase mDatabase;
    private SQLiteDatabase mBodyDatabase;

    /**
     * Orphan record deletion utility.  Generates a sqlite statement like:
     *  delete from <table> where <column> not in (select <foreignColumn> from <foreignTable>)
     * @param db the EmailProvider database
     * @param table the table whose orphans are to be removed
     * @param column the column deletion will be based on
     * @param foreignColumn the column in the foreign table whose absence will trigger the deletion
     * @param foreignTable the foreign table
     */
    @VisibleForTesting
    void deleteUnlinked(SQLiteDatabase db, String table, String column, String foreignColumn,
            String foreignTable) {
        int count = db.delete(table, column + "" not in (select "" + foreignColumn + "" from "" +
                foreignTable + "")"", null);
        if (count > 0) {
            Log.w(TAG, ""Found "" + count + "" orphaned row(s) in "" + table);
        }
    }

    @VisibleForTesting
    synchronized SQLiteDatabase getDatabase(Context context) {
        // Always return the cached database, if we've got one
        if (mDatabase != null) {
            return mDatabase;
        }

        // Whenever we create or re-cache the databases, make sure that we haven't lost one
        // to corruption
        checkDatabases();

        DatabaseHelper helper = new DatabaseHelper(context, DATABASE_NAME);
        mDatabase = helper.getWritableDatabase();
        mDatabase.setLockingEnabled(true);
        BodyDatabaseHelper bodyHelper = new BodyDatabaseHelper(context, BODY_DATABASE_NAME);
        mBodyDatabase = bodyHelper.getWritableDatabase();
        if (mBodyDatabase != null) {
            mBodyDatabase.setLockingEnabled(true);
            String bodyFileName = mBodyDatabase.getPath();
            mDatabase.execSQL(""attach \"""" + bodyFileName + ""\"" as BodyDatabase"");
        }

        // Restore accounts if the database is corrupted...
        restoreIfNeeded(context, mDatabase);

        if (Email.DEBUG) {
            Log.d(TAG, ""Deleting orphans..."");
        }
        // Check for any orphaned Messages in the updated/deleted tables
        deleteMessageOrphans(mDatabase, Message.UPDATED_TABLE_NAME);
        deleteMessageOrphans(mDatabase, Message.DELETED_TABLE_NAME);
        // Delete orphaned mailboxes/messages/policies (account no longer exists)
        deleteUnlinked(mDatabase, Mailbox.TABLE_NAME, MailboxColumns.ACCOUNT_KEY, AccountColumns.ID,
                Account.TABLE_NAME);
        deleteUnlinked(mDatabase, Message.TABLE_NAME, MessageColumns.ACCOUNT_KEY, AccountColumns.ID,
                Account.TABLE_NAME);
        deleteUnlinked(mDatabase, Policy.TABLE_NAME, PolicyColumns.ID, AccountColumns.POLICY_KEY,
                Account.TABLE_NAME);

        if (Email.DEBUG) {
            Log.d(TAG, ""EmailProvider pre-caching..."");
        }
        preCacheData();
        if (Email.DEBUG) {
            Log.d(TAG, ""EmailProvider ready."");
        }
        return mDatabase;
    }

    /**
     * Pre-cache all of the items in a given table meeting the selection criteria
     * @param tableUri the table uri
     * @param baseProjection the base projection of that table
     * @param selection the selection criteria
     */
    private void preCacheTable(Uri tableUri, String[] baseProjection, String selection) {
        Cursor c = query(tableUri, EmailContent.ID_PROJECTION, selection, null, null);
        try {
            while (c.moveToNext()) {
                long id = c.getLong(EmailContent.ID_PROJECTION_COLUMN);
                Cursor cachedCursor = query(ContentUris.withAppendedId(
                        tableUri, id), baseProjection, null, null, null);
                if (cachedCursor != null) {
                    // For accounts, create a mailbox type map entry (if necessary)
                    if (tableUri == Account.CONTENT_URI) {
                        getOrCreateAccountMailboxTypeMap(id);
                    }
                    cachedCursor.close();
                }
            }
        } finally {
            c.close();
        }
    }

    private final HashMap<Long, HashMap<Integer, Long>> mMailboxTypeMap =
        new HashMap<Long, HashMap<Integer, Long>>();

    private HashMap<Integer, Long> getOrCreateAccountMailboxTypeMap(long accountId) {
        synchronized(mMailboxTypeMap) {
            HashMap<Integer, Long> accountMailboxTypeMap = mMailboxTypeMap.get(accountId);
            if (accountMailboxTypeMap == null) {
                accountMailboxTypeMap = new HashMap<Integer, Long>();
                mMailboxTypeMap.put(accountId, accountMailboxTypeMap);
            }
            return accountMailboxTypeMap;
        }
    }

    private void addToMailboxTypeMap(Cursor c) {
        long accountId = c.getLong(Mailbox.CONTENT_ACCOUNT_KEY_COLUMN);
        int type = c.getInt(Mailbox.CONTENT_TYPE_COLUMN);
        synchronized(mMailboxTypeMap) {
            HashMap<Integer, Long> accountMailboxTypeMap =
                getOrCreateAccountMailboxTypeMap(accountId);
            accountMailboxTypeMap.put(type, c.getLong(Mailbox.CONTENT_ID_COLUMN));
        }
    }

    private long getMailboxIdFromMailboxTypeMap(long accountId, int type) {
        synchronized(mMailboxTypeMap) {
            HashMap<Integer, Long> accountMap = mMailboxTypeMap.get(accountId);
            Long mailboxId = null;
            if (accountMap != null) {
                mailboxId = accountMap.get(type);
            }
            if (mailboxId == null) return Mailbox.NO_MAILBOX;
            return mailboxId;
        }
    }

    private void preCacheData() {
        synchronized(mMailboxTypeMap) {
            mMailboxTypeMap.clear();

            // Pre-cache accounts, host auth's, policies, and special mailboxes
            preCacheTable(Account.CONTENT_URI, Account.CONTENT_PROJECTION, null);
            preCacheTable(HostAuth.CONTENT_URI, HostAuth.CONTENT_PROJECTION, null);
            preCacheTable(Policy.CONTENT_URI, Policy.CONTENT_PROJECTION, null);
            preCacheTable(Mailbox.CONTENT_URI, Mailbox.CONTENT_PROJECTION,
                    MAILBOX_PRE_CACHE_SELECTION);

            // Create a map from account,type to a mailbox
            Map<String, Cursor> snapshot = mCacheMailbox.getSnapshot();
            Collection<Cursor> values = snapshot.values();
            if (values != null) {
                for (Cursor c: values) {
                    if (c.moveToFirst()) {
                        addToMailboxTypeMap(c);
                    }
                }
            }
        }
    }

    /*package*/ static SQLiteDatabase getReadableDatabase(Context context) {
        DatabaseHelper helper = new DatabaseHelper(context, DATABASE_NAME);
        return helper.getReadableDatabase();
    }

    /**
     * Restore user Account and HostAuth data from our backup database
     */
    public static void restoreIfNeeded(Context context, SQLiteDatabase mainDatabase) {
        if (Email.DEBUG) {
            Log.w(TAG, ""restoreIfNeeded..."");
        }
        // Check for legacy backup
        String legacyBackup = Preferences.getLegacyBackupPreference(context);
        // If there's a legacy backup, create a new-style backup and delete the legacy backup
        // In the 1:1000000000 chance that the user gets an app update just as his database becomes
        // corrupt, oh well...
        if (!TextUtils.isEmpty(legacyBackup)) {
            backupAccounts(context, mainDatabase);
            Preferences.clearLegacyBackupPreference(context);
            Log.w(TAG, ""Created new EmailProvider backup database"");
            return;
        }

        // If we have accounts, we're done
        Cursor c = mainDatabase.query(Account.TABLE_NAME, EmailContent.ID_PROJECTION, null, null,
                null, null, null);
        if (c.moveToFirst()) {
            if (Email.DEBUG) {
                Log.w(TAG, ""restoreIfNeeded: Account exists."");
            }
            return; // At least one account exists.
        }
        restoreAccounts(context, mainDatabase);
    }

    /** {@inheritDoc} */
    @Override
    public void shutdown() {
        if (mDatabase != null) {
            mDatabase.close();
            mDatabase = null;
        }
        if (mBodyDatabase != null) {
            mBodyDatabase.close();
            mBodyDatabase = null;
        }
    }

    /*package*/ static void deleteMessageOrphans(SQLiteDatabase database, String tableName) {
        if (database != null) {
            // We'll look at all of the items in the table; there won't be many typically
            Cursor c = database.query(tableName, ORPHANS_PROJECTION, null, null, null, null, null);
            // Usually, there will be nothing in these tables, so make a quick check
            try {
                if (c.getCount() == 0) return;
                ArrayList<Long> foundMailboxes = new ArrayList<Long>();
                ArrayList<Long> notFoundMailboxes = new ArrayList<Long>();
                ArrayList<Long> deleteList = new ArrayList<Long>();
                String[] bindArray = new String[1];
                while (c.moveToNext()) {
                    // Get the mailbox key and see if we've already found this mailbox
                    // If so, we're fine
                    long mailboxId = c.getLong(ORPHANS_MAILBOX_KEY);
                    // If we already know this mailbox doesn't exist, mark the message for deletion
                    if (notFoundMailboxes.contains(mailboxId)) {
                        deleteList.add(c.getLong(ORPHANS_ID));
                    // If we don't know about this mailbox, we'll try to find it
                    } else if (!foundMailboxes.contains(mailboxId)) {
                        bindArray[0] = Long.toString(mailboxId);
                        Cursor boxCursor = database.query(Mailbox.TABLE_NAME,
                                Mailbox.ID_PROJECTION, WHERE_ID, bindArray, null, null, null);
                        try {
                            // If it exists, we'll add it to the ""found"" mailboxes
                            if (boxCursor.moveToFirst()) {
                                foundMailboxes.add(mailboxId);
                            // Otherwise, we'll add to ""not found"" and mark the message for deletion
                            } else {
                                notFoundMailboxes.add(mailboxId);
                                deleteList.add(c.getLong(ORPHANS_ID));
                            }
                        } finally {
                            boxCursor.close();
                        }
                    }
                }
                // Now, delete the orphan messages
                for (long messageId: deleteList) {
                    bindArray[0] = Long.toString(messageId);
                    database.delete(tableName, WHERE_ID, bindArray);
                }
            } finally {
                c.close();
            }
        }
    }

    private class BodyDatabaseHelper extends SQLiteOpenHelper {
        BodyDatabaseHelper(Context context, String name) {
            super(context, name, null, BODY_DATABASE_VERSION);
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            Log.d(TAG, ""Creating EmailProviderBody database"");
            createBodyTable(db);
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            upgradeBodyTable(db, oldVersion, newVersion);
        }

        @Override
        public void onOpen(SQLiteDatabase db) {
        }
    }

    private static class DatabaseHelper extends SQLiteOpenHelper {
        Context mContext;

        DatabaseHelper(Context context, String name) {
            super(context, name, null, DATABASE_VERSION);
            mContext = context;
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            Log.d(TAG, ""Creating EmailProvider database"");
            // Create all tables here; each class has its own method
            createMessageTable(db);
            createAttachmentTable(db);
            createMailboxTable(db);
            createHostAuthTable(db);
            createAccountTable(db);
            createPolicyTable(db);
            createQuickResponseTable(db);
        }

        @Override
        @SuppressWarnings(""deprecation"")
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            // For versions prior to 5, delete all data
            // Versions >= 5 require that data be preserved!
            if (oldVersion < 5) {
                android.accounts.Account[] accounts = AccountManager.get(mContext)
                        .getAccountsByType(AccountManagerTypes.TYPE_EXCHANGE);
                for (android.accounts.Account account: accounts) {
                    AccountManager.get(mContext).removeAccount(account, null, null);
                }
                resetMessageTable(db, oldVersion, newVersion);
                resetAttachmentTable(db, oldVersion, newVersion);
                resetMailboxTable(db, oldVersion, newVersion);
                resetHostAuthTable(db, oldVersion, newVersion);
                resetAccountTable(db, oldVersion, newVersion);
                return;
            }
            if (oldVersion == 5) {
                // Message Tables: Add SyncColumns.SERVER_TIMESTAMP
                try {
                    db.execSQL(""alter table "" + Message.TABLE_NAME
                            + "" add column "" + SyncColumns.SERVER_TIMESTAMP + "" integer"" + "";"");
                    db.execSQL(""alter table "" + Message.UPDATED_TABLE_NAME
                            + "" add column "" + SyncColumns.SERVER_TIMESTAMP + "" integer"" + "";"");
                    db.execSQL(""alter table "" + Message.DELETED_TABLE_NAME
                            + "" add column "" + SyncColumns.SERVER_TIMESTAMP + "" integer"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from v5 to v6"", e);
                }
                oldVersion = 6;
            }
            if (oldVersion == 6) {
                // Use the newer mailbox_delete trigger
                db.execSQL(""drop trigger mailbox_delete;"");
                db.execSQL(TRIGGER_MAILBOX_DELETE);
                oldVersion = 7;
            }
            if (oldVersion == 7) {
                // add the security (provisioning) column
                try {
                    db.execSQL(""alter table "" + Account.TABLE_NAME
                            + "" add column "" + AccountColumns.SECURITY_FLAGS + "" integer"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 7 to 8 "" + e);
                }
                oldVersion = 8;
            }
            if (oldVersion == 8) {
                // accounts: add security sync key & user signature columns
                try {
                    db.execSQL(""alter table "" + Account.TABLE_NAME
                            + "" add column "" + AccountColumns.SECURITY_SYNC_KEY + "" text"" + "";"");
                    db.execSQL(""alter table "" + Account.TABLE_NAME
                            + "" add column "" + AccountColumns.SIGNATURE + "" text"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 8 to 9 "" + e);
                }
                oldVersion = 9;
            }
            if (oldVersion == 9) {
                // Message: add meeting info column into Message tables
                try {
                    db.execSQL(""alter table "" + Message.TABLE_NAME
                            + "" add column "" + MessageColumns.MEETING_INFO + "" text"" + "";"");
                    db.execSQL(""alter table "" + Message.UPDATED_TABLE_NAME
                            + "" add column "" + MessageColumns.MEETING_INFO + "" text"" + "";"");
                    db.execSQL(""alter table "" + Message.DELETED_TABLE_NAME
                            + "" add column "" + MessageColumns.MEETING_INFO + "" text"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 9 to 10 "" + e);
                }
                oldVersion = 10;
            }
            if (oldVersion == 10) {
                // Attachment: add content and flags columns
                try {
                    db.execSQL(""alter table "" + Attachment.TABLE_NAME
                            + "" add column "" + AttachmentColumns.CONTENT + "" text"" + "";"");
                    db.execSQL(""alter table "" + Attachment.TABLE_NAME
                            + "" add column "" + AttachmentColumns.FLAGS + "" integer"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 10 to 11 "" + e);
                }
                oldVersion = 11;
            }
            if (oldVersion == 11) {
                // Attachment: add content_bytes
                try {
                    db.execSQL(""alter table "" + Attachment.TABLE_NAME
                            + "" add column "" + AttachmentColumns.CONTENT_BYTES + "" blob"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 11 to 12 "" + e);
                }
                oldVersion = 12;
            }
            if (oldVersion == 12) {
                try {
                    db.execSQL(""alter table "" + Mailbox.TABLE_NAME
                            + "" add column "" + Mailbox.MESSAGE_COUNT
                                    +"" integer not null default 0"" + "";"");
                    recalculateMessageCount(db);
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 12 to 13 "" + e);
                }
                oldVersion = 13;
            }
            if (oldVersion == 13) {
                try {
                    db.execSQL(""alter table "" + Message.TABLE_NAME
                            + "" add column "" + Message.SNIPPET
                                    +"" text"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 13 to 14 "" + e);
                }
                oldVersion = 14;
            }
            if (oldVersion == 14) {
                try {
                    db.execSQL(""alter table "" + Message.DELETED_TABLE_NAME
                            + "" add column "" + Message.SNIPPET +"" text"" + "";"");
                    db.execSQL(""alter table "" + Message.UPDATED_TABLE_NAME
                            + "" add column "" + Message.SNIPPET +"" text"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 14 to 15 "" + e);
                }
                oldVersion = 15;
            }
            if (oldVersion == 15) {
                try {
                    db.execSQL(""alter table "" + Attachment.TABLE_NAME
                            + "" add column "" + Attachment.ACCOUNT_KEY +"" integer"" + "";"");
                    // Update all existing attachments to add the accountKey data
                    db.execSQL(""update "" + Attachment.TABLE_NAME + "" set "" +
                            Attachment.ACCOUNT_KEY + ""= (SELECT "" + Message.TABLE_NAME + ""."" +
                            Message.ACCOUNT_KEY + "" from "" + Message.TABLE_NAME + "" where "" +
                            Message.TABLE_NAME + ""."" + Message.RECORD_ID + "" = "" +
                            Attachment.TABLE_NAME + ""."" + Attachment.MESSAGE_KEY + "")"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 15 to 16 "" + e);
                }
                oldVersion = 16;
            }
            if (oldVersion == 16) {
                try {
                    db.execSQL(""alter table "" + Mailbox.TABLE_NAME
                            + "" add column "" + Mailbox.PARENT_KEY + "" integer;"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 16 to 17 "" + e);
                }
                oldVersion = 17;
            }
            if (oldVersion == 17) {
                upgradeFromVersion17ToVersion18(db);
                oldVersion = 18;
            }
            if (oldVersion == 18) {
                try {
                    db.execSQL(""alter table "" + Account.TABLE_NAME
                            + "" add column "" + Account.POLICY_KEY + "" integer;"");
                    db.execSQL(""drop trigger account_delete;"");
                    db.execSQL(TRIGGER_ACCOUNT_DELETE);
                    createPolicyTable(db);
                    convertPolicyFlagsToPolicyTable(db);
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 18 to 19 "" + e);
                }
                oldVersion = 19;
            }
            if (oldVersion == 19) {
                try {
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.REQUIRE_MANUAL_SYNC_WHEN_ROAMING +
                            "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.DONT_ALLOW_CAMERA + "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.DONT_ALLOW_ATTACHMENTS + "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.DONT_ALLOW_HTML + "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.MAX_ATTACHMENT_SIZE + "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.MAX_TEXT_TRUNCATION_SIZE +
                            "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.MAX_HTML_TRUNCATION_SIZE +
                            "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.MAX_EMAIL_LOOKBACK + "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.MAX_CALENDAR_LOOKBACK + "" integer;"");
                    db.execSQL(""alter table "" + Policy.TABLE_NAME
                            + "" add column "" + PolicyColumns.PASSWORD_RECOVERY_ENABLED +
                            "" integer;"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 19 to 20 "" + e);
                }
                oldVersion = 20;
            }
            if (oldVersion == 20) {
                upgradeFromVersion20ToVersion21(db);
                oldVersion = 21;
            }
            if (oldVersion == 21) {
                upgradeFromVersion21ToVersion22(db, mContext);
                oldVersion = 22;
            }
            if (oldVersion == 22) {
                upgradeFromVersion22ToVersion23(db);
                oldVersion = 23;
            }
            if (oldVersion == 23) {
                upgradeFromVersion23ToVersion24(db);
                oldVersion = 24;
            }
            if (oldVersion == 24) {
                upgradeFromVersion24ToVersion25(db);
                oldVersion = 25;
            }
            if (oldVersion == 25) {
                upgradeFromVersion25ToVersion26(db);
                oldVersion = 26;
            }
            if (oldVersion == 26) {
                try {
                    db.execSQL(""alter table "" + Message.TABLE_NAME
                            + "" add column "" + Message.PROTOCOL_SEARCH_INFO + "" text;"");
                    db.execSQL(""alter table "" + Message.DELETED_TABLE_NAME
                            + "" add column "" + Message.PROTOCOL_SEARCH_INFO +"" text"" + "";"");
                    db.execSQL(""alter table "" + Message.UPDATED_TABLE_NAME
                            + "" add column "" + Message.PROTOCOL_SEARCH_INFO +"" text"" + "";"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 26 to 27 "" + e);
                }
                oldVersion = 27;
            }
            if (oldVersion == 27) {
                try {
                    db.execSQL(""alter table "" + Account.TABLE_NAME
                            + "" add column "" + Account.NOTIFIED_MESSAGE_ID + "" integer;"");
                    db.execSQL(""alter table "" + Account.TABLE_NAME
                            + "" add column "" + Account.NOTIFIED_MESSAGE_COUNT + "" integer;"");
                } catch (SQLException e) {
                    // Shouldn't be needed unless we're debugging and interrupt the process
                    Log.w(TAG, ""Exception upgrading EmailProvider.db from 27 to 27 "" + e);
                }
                oldVersion = 28;
            }
        }

        @Override
        public void onOpen(SQLiteDatabase db) {
        }
    }

    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        final int match = findMatch(uri, ""delete"");
        Context context = getContext();
        // Pick the correct database for this operation
        // If we're in a transaction already (which would happen during applyBatch), then the
        // body database is already attached to the email database and any attempt to use the
        // body database directly will result in a SQLiteException (the database is locked)
        SQLiteDatabase db = getDatabase(context);
        int table = match >> BASE_SHIFT;
        String id = ""0"";
        boolean messageDeletion = false;
        ContentResolver resolver = context.getContentResolver();

        ContentCache cache = mContentCaches[table];
        String tableName = TABLE_NAMES[table];
        int result = -1;

        try {
            switch (match) {
                // These are cases in which one or more Messages might get deleted, either by
                // cascade or explicitly
                case MAILBOX_ID:
                case MAILBOX:
                case ACCOUNT_ID:
                case ACCOUNT:
                case MESSAGE:
                case SYNCED_MESSAGE_ID:
                case MESSAGE_ID:
                    // Handle lost Body records here, since this cannot be done in a trigger
                    // The process is:
                    //  1) Begin a transaction, ensuring that both databases are affected atomically
                    //  2) Do the requested deletion, with cascading deletions handled in triggers
                    //  3) End the transaction, committing all changes atomically
                    //
                    // Bodies are auto-deleted here;  Attachments are auto-deleted via trigger
                    messageDeletion = true;
                    db.beginTransaction();
                    break;
            }
            switch (match) {
                case BODY_ID:
                case DELETED_MESSAGE_ID:
                case SYNCED_MESSAGE_ID:
                case MESSAGE_ID:
                case UPDATED_MESSAGE_ID:
                case ATTACHMENT_ID:
                case MAILBOX_ID:
                case ACCOUNT_ID:
                case HOSTAUTH_ID:
                case POLICY_ID:
                case QUICK_RESPONSE_ID:
                    id = uri.getPathSegments().get(1);
                    if (match == SYNCED_MESSAGE_ID) {
                        // For synced messages, first copy the old message to the deleted table and
                        // delete it from the updated table (in case it was updated first)
                        // Note that this is all within a transaction, for atomicity
                        db.execSQL(DELETED_MESSAGE_INSERT + id);
                        db.execSQL(UPDATED_MESSAGE_DELETE + id);
                    }
                    if (cache != null) {
                        cache.lock(id);
                    }
                    try {
                        result = db.delete(tableName, whereWithId(id, selection), selectionArgs);
                        if (cache != null) {
                            switch(match) {
                                case ACCOUNT_ID:
                                    // Account deletion will clear all of the caches, as HostAuth's,
                                    // Mailboxes, and Messages will be deleted in the process
                                    mCacheMailbox.invalidate(""Delete"", uri, selection);
                                    mCacheHostAuth.invalidate(""Delete"", uri, selection);
                                    mCachePolicy.invalidate(""Delete"", uri, selection);
                                    //$FALL-THROUGH$
                                case MAILBOX_ID:
                                    // Mailbox deletion will clear the Message cache
                                    mCacheMessage.invalidate(""Delete"", uri, selection);
                                    //$FALL-THROUGH$
                                case SYNCED_MESSAGE_ID:
                                case MESSAGE_ID:
                                case HOSTAUTH_ID:
                                case POLICY_ID:
                                    cache.invalidate(""Delete"", uri, selection);
                                    // Make sure all data is properly cached
                                    if (match != MESSAGE_ID) {
                                        preCacheData();
                                    }
                                    break;
                            }
                        }
                    } finally {
                        if (cache != null) {
                            cache.unlock(id);
                        }
                    }
                    break;
                case ATTACHMENTS_MESSAGE_ID:
                    // All attachments for the given message
                    id = uri.getPathSegments().get(2);
                    result = db.delete(tableName,
                            whereWith(Attachment.MESSAGE_KEY + ""="" + id, selection), selectionArgs);
                    break;

                case BODY:
                case MESSAGE:
                case DELETED_MESSAGE:
                case UPDATED_MESSAGE:
                case ATTACHMENT:
                case MAILBOX:
                case ACCOUNT:
                case HOSTAUTH:
                case POLICY:
                    switch(match) {
                        // See the comments above for deletion of ACCOUNT_ID, etc
                        case ACCOUNT:
                            mCacheMailbox.invalidate(""Delete"", uri, selection);
                            mCacheHostAuth.invalidate(""Delete"", uri, selection);
                            mCachePolicy.invalidate(""Delete"", uri, selection);
                            //$FALL-THROUGH$
                        case MAILBOX:
                            mCacheMessage.invalidate(""Delete"", uri, selection);
                            //$FALL-THROUGH$
                        case MESSAGE:
                        case HOSTAUTH:
                        case POLICY:
                            cache.invalidate(""Delete"", uri, selection);
                            break;
                    }
                    result = db.delete(tableName, selection, selectionArgs);
                    switch(match) {
                        case ACCOUNT:
                        case MAILBOX:
                        case HOSTAUTH:
                        case POLICY:
                            // Make sure all data is properly cached
                            preCacheData();
                            break;
                    }
                    break;

                default:
                    throw new IllegalArgumentException(""Unknown URI "" + uri);
            }
            if (messageDeletion) {
                if (match == MESSAGE_ID) {
                    // Delete the Body record associated with the deleted message
                    db.execSQL(DELETE_BODY + id);
                } else {
                    // Delete any orphaned Body records
                    db.execSQL(DELETE_ORPHAN_BODIES);
                }
                db.setTransactionSuccessful();
            }
        } catch (SQLiteException e) {
            checkDatabases();
            throw e;
        } finally {
            if (messageDeletion) {
                db.endTransaction();
            }
        }

        // Notify all notifier cursors
        sendNotifierChange(getBaseNotificationUri(match), NOTIFICATION_OP_DELETE, id);

        // Notify all email content cursors
        resolver.notifyChange(EmailContent.CONTENT_URI, null);
        return result;
    }

    @Override
    // Use the email- prefix because message, mailbox, and account are so generic (e.g. SMS, IM)
    public String getType(Uri uri) {
        int match = findMatch(uri, ""getType"");
        switch (match) {
            case BODY_ID:
                return ""vnd.android.cursor.item/email-body"";
            case BODY:
                return ""vnd.android.cursor.dir/email-body"";
            case UPDATED_MESSAGE_ID:
            case MESSAGE_ID:
                // NOTE: According to the framework folks, we're supposed to invent mime types as
                // a way of passing information to drag & drop recipients.
                // If there's a mailboxId parameter in the url, we respond with a mime type that
                // has -n appended, where n is the mailboxId of the message.  The drag & drop code
                // uses this information to know not to allow dragging the item to its own mailbox
                String mimeType = EMAIL_MESSAGE_MIME_TYPE;
                String mailboxId = uri.getQueryParameter(MESSAGE_URI_PARAMETER_MAILBOX_ID);
                if (mailboxId != null) {
                    mimeType += ""-"" + mailboxId;
                }
                return mimeType;
            case UPDATED_MESSAGE:
            case MESSAGE:
                return ""vnd.android.cursor.dir/email-message"";
            case MAILBOX:
                return ""vnd.android.cursor.dir/email-mailbox"";
            case MAILBOX_ID:
                return ""vnd.android.cursor.item/email-mailbox"";
            case ACCOUNT:
                return ""vnd.android.cursor.dir/email-account"";
            case ACCOUNT_ID:
                return ""vnd.android.cursor.item/email-account"";
            case ATTACHMENTS_MESSAGE_ID:
            case ATTACHMENT:
                return ""vnd.android.cursor.dir/email-attachment"";
            case ATTACHMENT_ID:
                return EMAIL_ATTACHMENT_MIME_TYPE;
            case HOSTAUTH:
                return ""vnd.android.cursor.dir/email-hostauth"";
            case HOSTAUTH_ID:
                return ""vnd.android.cursor.item/email-hostauth"";
            default:
                throw new IllegalArgumentException(""Unknown URI "" + uri);
        }
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        int match = findMatch(uri, ""insert"");
        Context context = getContext();
        ContentResolver resolver = context.getContentResolver();

        // See the comment at delete(), above
        SQLiteDatabase db = getDatabase(context);
        int table = match >> BASE_SHIFT;
        String id = ""0"";
        long longId;

        // We do NOT allow setting of unreadCount/messageCount via the provider
        // These columns are maintained via triggers
        if (match == MAILBOX_ID || match == MAILBOX) {
            values.put(MailboxColumns.UNREAD_COUNT, 0);
            values.put(MailboxColumns.MESSAGE_COUNT, 0);
        }

        Uri resultUri = null;

        try {
            switch (match) {
                // NOTE: It is NOT legal for production code to insert directly into UPDATED_MESSAGE
                // or DELETED_MESSAGE; see the comment below for details
                case UPDATED_MESSAGE:
                case DELETED_MESSAGE:
                case MESSAGE:
                case BODY:
                case ATTACHMENT:
                case MAILBOX:
                case ACCOUNT:
                case HOSTAUTH:
                case POLICY:
                case QUICK_RESPONSE:
                    longId = db.insert(TABLE_NAMES[table], ""foo"", values);
                    resultUri = ContentUris.withAppendedId(uri, longId);
                    switch(match) {
                        case MAILBOX:
                            if (values.containsKey(MailboxColumns.TYPE)) {
                                // Only cache special mailbox types
                                int type = values.getAsInteger(MailboxColumns.TYPE);
                                if (type != Mailbox.TYPE_INBOX && type != Mailbox.TYPE_OUTBOX &&
                                        type != Mailbox.TYPE_DRAFTS && type != Mailbox.TYPE_SENT &&
                                        type != Mailbox.TYPE_TRASH && type != Mailbox.TYPE_SEARCH) {
                                    break;
                                }
                            }
                            //$FALL-THROUGH$
                        case ACCOUNT:
                        case HOSTAUTH:
                        case POLICY:
                            // Cache new account, host auth, policy, and some mailbox rows
                            Cursor c = query(resultUri, CACHE_PROJECTIONS[table], null, null, null);
                            if (c != null) {
                                if (match == MAILBOX) {
                                    addToMailboxTypeMap(c);
                                } else if (match == ACCOUNT) {
                                    getOrCreateAccountMailboxTypeMap(longId);
                                }
                                c.close();
                            }
                            break;
                    }
                    // Clients shouldn't normally be adding rows to these tables, as they are
                    // maintained by triggers.  However, we need to be able to do this for unit
                    // testing, so we allow the insert and then throw the same exception that we
                    // would if this weren't allowed.
                    if (match == UPDATED_MESSAGE || match == DELETED_MESSAGE) {
                        throw new IllegalArgumentException(""Unknown URL "" + uri);
                    }
                    if (match == ATTACHMENT) {
                        int flags = 0;
                        if (values.containsKey(Attachment.FLAGS)) {
                            flags = values.getAsInteger(Attachment.FLAGS);
                        }
                        // Report all new attachments to the download service
                        mAttachmentService.attachmentChanged(getContext(), longId, flags);
                    }
                    break;
                case MAILBOX_ID:
                    // This implies adding a message to a mailbox
                    // Hmm, a problem here is that we can't link the account as well, so it must be
                    // already in the values...
                    longId = Long.parseLong(uri.getPathSegments().get(1));
                    values.put(MessageColumns.MAILBOX_KEY, longId);
                    return insert(Message.CONTENT_URI, values); // Recurse
                case MESSAGE_ID:
                    // This implies adding an attachment to a message.
                    id = uri.getPathSegments().get(1);
                    longId = Long.parseLong(id);
                    values.put(AttachmentColumns.MESSAGE_KEY, longId);
                    return insert(Attachment.CONTENT_URI, values); // Recurse
                case ACCOUNT_ID:
                    // This implies adding a mailbox to an account.
                    longId = Long.parseLong(uri.getPathSegments().get(1));
                    values.put(MailboxColumns.ACCOUNT_KEY, longId);
                    return insert(Mailbox.CONTENT_URI, values); // Recurse
                case ATTACHMENTS_MESSAGE_ID:
                    longId = db.insert(TABLE_NAMES[table], ""foo"", values);
                    resultUri = ContentUris.withAppendedId(Attachment.CONTENT_URI, longId);
                    break;
                default:
                    throw new IllegalArgumentException(""Unknown URL "" + uri);
            }
        } catch (SQLiteException e) {
            checkDatabases();
            throw e;
        }

        // Notify all notifier cursors
        sendNotifierChange(getBaseNotificationUri(match), NOTIFICATION_OP_INSERT, id);

        // Notify all existing cursors.
        resolver.notifyChange(EmailContent.CONTENT_URI, null);
        return resultUri;
    }

    @Override
    public boolean onCreate() {
        checkDatabases();
        return false;
    }

    /**
     * The idea here is that the two databases (EmailProvider.db and EmailProviderBody.db must
     * always be in sync (i.e. there are two database or NO databases).  This code will delete
     * any ""orphan"" database, so that both will be created together.  Note that an ""orphan"" database
     * will exist after either of the individual databases is deleted due to data corruption.
     */
    public void checkDatabases() {
        // Uncache the databases
        if (mDatabase != null) {
            mDatabase = null;
        }
        if (mBodyDatabase != null) {
            mBodyDatabase = null;
        }
        // Look for orphans, and delete as necessary; these must always be in sync
        File databaseFile = getContext().getDatabasePath(DATABASE_NAME);
        File bodyFile = getContext().getDatabasePath(BODY_DATABASE_NAME);

        // TODO Make sure attachments are deleted
        if (databaseFile.exists() && !bodyFile.exists()) {
            Log.w(TAG, ""Deleting orphaned EmailProvider database..."");
            databaseFile.delete();
        } else if (bodyFile.exists() && !databaseFile.exists()) {
            Log.w(TAG, ""Deleting orphaned EmailProviderBody database..."");
            bodyFile.delete();
        }
    }

    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
            String sortOrder) {
        long time = 0L;
        if (Email.DEBUG) {
            time = System.nanoTime();
        }
        Cursor c = null;
        int match;
        try {
            match = findMatch(uri, ""query"");
        } catch (IllegalArgumentException e) {
            String uriString = uri.toString();
            // If we were passed an illegal uri, see if it ends in /-1
            // if so, and if substituting 0 for -1 results in a valid uri, return an empty cursor
            if (uriString != null && uriString.endsWith(""/-1"")) {
                uri = Uri.parse(uriString.substring(0, uriString.length() - 2) + ""0"");
                match = findMatch(uri, ""query"");
                switch (match) {
                    case BODY_ID:
                    case MESSAGE_ID:
                    case DELETED_MESSAGE_ID:
                    case UPDATED_MESSAGE_ID:
                    case ATTACHMENT_ID:
                    case MAILBOX_ID:
                    case ACCOUNT_ID:
                    case HOSTAUTH_ID:
                    case POLICY_ID:
                        return new MatrixCursor(projection, 0);
                }
            }
            throw e;
        }
        Context context = getContext();
        // See the comment at delete(), above
        SQLiteDatabase db = getDatabase(context);
        int table = match >> BASE_SHIFT;
        String limit = uri.getQueryParameter(EmailContent.PARAMETER_LIMIT);
        String id;

        // Find the cache for this query's table (if any)
        ContentCache cache = null;
        String tableName = TABLE_NAMES[table];
        // We can only use the cache if there's no selection
        if (selection == null) {
            cache = mContentCaches[table];
        }
        if (cache == null) {
            ContentCache.notCacheable(uri, selection);
        }

        try {
            switch (match) {
                case ACCOUNT_DEFAULT_ID:
                    // Start with a snapshot of the cache
                    Map<String, Cursor> accountCache = mCacheAccount.getSnapshot();
                    long accountId = Account.NO_ACCOUNT;
                    // Find the account with ""isDefault"" set, or the lowest account ID otherwise.
                    // Note that the snapshot from the cached isn't guaranteed to be sorted in any
                    // way.
                    Collection<Cursor> accounts = accountCache.values();
                    for (Cursor accountCursor: accounts) {
                        // For now, at least, we can have zero count cursors (e.g. if someone looks
                        // up a non-existent id); we need to skip these
                        if (accountCursor.moveToFirst()) {
                            boolean isDefault =
                                accountCursor.getInt(Account.CONTENT_IS_DEFAULT_COLUMN) == 1;
                            long iterId = accountCursor.getLong(Account.CONTENT_ID_COLUMN);
                            // We'll remember this one if it's the default or the first one we see
                            if (isDefault) {
                                accountId = iterId;
                                break;
                            } else if ((accountId == Account.NO_ACCOUNT) || (iterId < accountId)) {
                                accountId = iterId;
                            }
                        }
                    }
                    // Return a cursor with an id projection
                    MatrixCursor mc = new MatrixCursor(EmailContent.ID_PROJECTION);
                    mc.addRow(new Object[] {accountId});
                    c = mc;
                    break;
                case MAILBOX_ID_FROM_ACCOUNT_AND_TYPE:
                    // Get accountId and type and find the mailbox in our map
                    List<String> pathSegments = uri.getPathSegments();
                    accountId = Long.parseLong(pathSegments.get(1));
                    int type = Integer.parseInt(pathSegments.get(2));
                    long mailboxId = getMailboxIdFromMailboxTypeMap(accountId, type);
                    // Return a cursor with an id projection
                    mc = new MatrixCursor(EmailContent.ID_PROJECTION);
                    mc.addRow(new Object[] {mailboxId});
                    c = mc;
                    break;
                case BODY:
                case MESSAGE:
                case UPDATED_MESSAGE:
                case DELETED_MESSAGE:
                case ATTACHMENT:
                case MAILBOX:
                case ACCOUNT:
                case HOSTAUTH:
                case POLICY:
                case QUICK_RESPONSE:
                    // Special-case ""count of accounts""; it's common and we always know it
                    if (match == ACCOUNT && Arrays.equals(projection, EmailContent.COUNT_COLUMNS) &&
                            selection == null && limit.equals(""1"")) {
                        int accountCount = mMailboxTypeMap.size();
                        // In the rare case there are MAX_CACHED_ACCOUNTS or more, we can't do this
                        if (accountCount < MAX_CACHED_ACCOUNTS) {
                            mc = new MatrixCursor(projection, 1);
                            mc.addRow(new Object[] {accountCount});
                            c = mc;
                            break;
                        }
                    }
                    c = db.query(tableName, projection,
                            selection, selectionArgs, null, null, sortOrder, limit);
                    break;
                case BODY_ID:
                case MESSAGE_ID:
                case DELETED_MESSAGE_ID:
                case UPDATED_MESSAGE_ID:
                case ATTACHMENT_ID:
                case MAILBOX_ID:
                case ACCOUNT_ID:
                case HOSTAUTH_ID:
                case POLICY_ID:
                case QUICK_RESPONSE_ID:
                    id = uri.getPathSegments().get(1);
                    if (cache != null) {
                        c = cache.getCachedCursor(id, projection);
                    }
                    if (c == null) {
                        CacheToken token = null;
                        if (cache != null) {
                            token = cache.getCacheToken(id);
                        }
                        c = db.query(tableName, projection, whereWithId(id, selection),
                                selectionArgs, null, null, sortOrder, limit);
                        if (cache != null) {
                            c = cache.putCursor(c, id, projection, token);
                        }
                    }
                    break;
                case ATTACHMENTS_MESSAGE_ID:
                    // All attachments for the given message
                    id = uri.getPathSegments().get(2);
                    c = db.query(Attachment.TABLE_NAME, projection,
                            whereWith(Attachment.MESSAGE_KEY + ""="" + id, selection),
                            selectionArgs, null, null, sortOrder, limit);
                    break;
                case QUICK_RESPONSE_ACCOUNT_ID:
                    // All quick responses for the given account
                    id = uri.getPathSegments().get(2);
                    c = db.query(QuickResponse.TABLE_NAME, projection,
                            whereWith(QuickResponse.ACCOUNT_KEY + ""="" + id, selection),
                            selectionArgs, null, null, sortOrder);
                    break;
                default:
                    throw new IllegalArgumentException(""Unknown URI "" + uri);
            }
        } catch (SQLiteException e) {
            checkDatabases();
            throw e;
        } catch (RuntimeException e) {
            checkDatabases();
            e.printStackTrace();
            throw e;
        } finally {
            if (cache != null && c != null && Email.DEBUG) {
                cache.recordQueryTime(c, System.nanoTime() - time);
            }
            if (c == null) {
                // This should never happen, but let's be sure to log it...
                Log.e(TAG, ""Query returning null for uri: "" + uri + "", selection: "" + selection);
            }
        }

        if ((c != null) && !isTemporary()) {
            c.setNotificationUri(getContext().getContentResolver(), uri);
        }
        return c;
    }

    private String whereWithId(String id, String selection) {
        StringBuilder sb = new StringBuilder(256);
        sb.append(""_id="");
        sb.append(id);
        if (selection != null) {
            sb.append("" AND ("");
            sb.append(selection);
            sb.append(')');
        }
        return sb.toString();
    }

    /**
     * Combine a locally-generated selection with a user-provided selection
     *
     * This introduces risk that the local selection might insert incorrect chars
     * into the SQL, so use caution.
     *
     * @param where locally-generated selection, must not be null
     * @param selection user-provided selection, may be null
     * @return a single selection string
     */
    private String whereWith(String where, String selection) {
        if (selection == null) {
            return where;
        }
        StringBuilder sb = new StringBuilder(where);
        sb.append("" AND ("");
        sb.append(selection);
        sb.append(')');

        return sb.toString();
    }

    /**
     * Restore a HostAuth from a database, given its unique id
     * @param db the database
     * @param id the unique id (_id) of the row
     * @return a fully populated HostAuth or null if the row does not exist
     */
    private static HostAuth restoreHostAuth(SQLiteDatabase db, long id) {
        Cursor c = db.query(HostAuth.TABLE_NAME, HostAuth.CONTENT_PROJECTION,
                HostAuth.RECORD_ID + ""=?"", new String[] {Long.toString(id)}, null, null, null);
        try {
            if (c.moveToFirst()) {
                HostAuth hostAuth = new HostAuth();
                hostAuth.restore(c);
                return hostAuth;
            }
            return null;
        } finally {
            c.close();
        }
    }

    /**
     * Copy the Account and HostAuth tables from one database to another
     * @param fromDatabase the source database
     * @param toDatabase the destination database
     * @return the number of accounts copied, or -1 if an error occurred
     */
    private static int copyAccountTables(SQLiteDatabase fromDatabase, SQLiteDatabase toDatabase) {
        if (fromDatabase == null || toDatabase == null) return -1;
        int copyCount = 0;
        try {
            // Lock both databases; for the ""from"" database, we don't want anyone changing it from
            // under us; for the ""to"" database, we want to make the operation atomic
            fromDatabase.beginTransaction();
            toDatabase.beginTransaction();
            // Delete anything hanging around here
            toDatabase.delete(Account.TABLE_NAME, null, null);
            toDatabase.delete(HostAuth.TABLE_NAME, null, null);
            // Get our account cursor
            Cursor c = fromDatabase.query(Account.TABLE_NAME, Account.CONTENT_PROJECTION,
                    null, null, null, null, null);
            boolean noErrors = true;
            try {
                // Loop through accounts, copying them and associated host auth's
                while (c.moveToNext()) {
                    Account account = new Account();
                    account.restore(c);

                    // Clear security sync key and sync key, as these were specific to the state of
                    // the account, and we've reset that...
                    // Clear policy key so that we can re-establish policies from the server
                    // TODO This is pretty EAS specific, but there's a lot of that around
                    account.mSecuritySyncKey = null;
                    account.mSyncKey = null;
                    account.mPolicyKey = 0;

                    // Copy host auth's and update foreign keys
                    HostAuth hostAuth = restoreHostAuth(fromDatabase, account.mHostAuthKeyRecv);
                    // The account might have gone away, though very unlikely
                    if (hostAuth == null) continue;
                    account.mHostAuthKeyRecv = toDatabase.insert(HostAuth.TABLE_NAME, null,
                            hostAuth.toContentValues());
                    // EAS accounts have no send HostAuth
                    if (account.mHostAuthKeySend > 0) {
                        hostAuth = restoreHostAuth(fromDatabase, account.mHostAuthKeySend);
                        // Belt and suspenders; I can't imagine that this is possible, since we
                        // checked the validity of the account above, and the database is now locked
                        if (hostAuth == null) continue;
                        account.mHostAuthKeySend = toDatabase.insert(HostAuth.TABLE_NAME, null,
                                hostAuth.toContentValues());
                    }
                    // Now, create the account in the ""to"" database
                    toDatabase.insert(Account.TABLE_NAME, null, account.toContentValues());
                    copyCount++;
                }
            } catch (SQLiteException e) {
                noErrors = false;
                copyCount = -1;
            } finally {
                fromDatabase.endTransaction();
                if (noErrors) {
                    // Say it's ok to commit
                    toDatabase.setTransactionSuccessful();
                }
                toDatabase.endTransaction();
                c.close();
            }
        } catch (SQLiteException e) {
            copyCount = -1;
        }
        return copyCount;
    }

    private static SQLiteDatabase getBackupDatabase(Context context) {
        DatabaseHelper helper = new DatabaseHelper(context, BACKUP_DATABASE_NAME);
        return helper.getWritableDatabase();
    }

    /**
     * Backup account data, returning the number of accounts backed up
     */
    private static int backupAccounts(Context context, SQLiteDatabase mainDatabase) {
        if (Email.DEBUG) {
            Log.d(TAG, ""backupAccounts..."");
        }
        SQLiteDatabase backupDatabase = getBackupDatabase(context);
        try {
            int numBackedUp = copyAccountTables(mainDatabase, backupDatabase);
            if (numBackedUp < 0) {
                Log.e(TAG, ""Account backup failed!"");
            } else if (Email.DEBUG) {
                Log.d(TAG, ""Backed up "" + numBackedUp + "" accounts..."");
            }
            return numBackedUp;
        } finally {
            if (backupDatabase != null) {
                backupDatabase.close();
            }
        }
    }

    /**
     * Restore account data, returning the number of accounts restored
     */
    private static int restoreAccounts(Context context, SQLiteDatabase mainDatabase) {
        if (Email.DEBUG) {
            Log.d(TAG, ""restoreAccounts..."");
        }
        SQLiteDatabase backupDatabase = getBackupDatabase(context);
        try {
            int numRecovered = copyAccountTables(backupDatabase, mainDatabase);
            if (numRecovered > 0) {
                Log.e(TAG, ""Recovered "" + numRecovered + "" accounts!"");
            } else if (numRecovered < 0) {
                Log.e(TAG, ""Account recovery failed?"");
            } else if (Email.DEBUG) {
                Log.d(TAG, ""No accounts to restore..."");
            }
            return numRecovered;
        } finally {
            if (backupDatabase != null) {
                backupDatabase.close();
            }
        }
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        // Handle this special case the fastest possible way
        if (uri == INTEGRITY_CHECK_URI) {
            checkDatabases();
            return 0;
        } else if (uri == ACCOUNT_BACKUP_URI) {
            return backupAccounts(getContext(), getDatabase(getContext()));
        }

        // Notify all existing cursors, except for ACCOUNT_RESET_NEW_COUNT(_ID)
        Uri notificationUri = EmailContent.CONTENT_URI;

        int match = findMatch(uri, ""update"");
        Context context = getContext();
        ContentResolver resolver = context.getContentResolver();
        // See the comment at delete(), above
        SQLiteDatabase db = getDatabase(context);
        int table = match >> BASE_SHIFT;
        int result;

        // We do NOT allow setting of unreadCount/messageCount via the provider
        // These columns are maintained via triggers
        if (match == MAILBOX_ID || match == MAILBOX) {
            values.remove(MailboxColumns.UNREAD_COUNT);
            values.remove(MailboxColumns.MESSAGE_COUNT);
        }

        ContentCache cache = mContentCaches[table];
        String tableName = TABLE_NAMES[table];
        String id = ""0"";

        try {
outer:
            switch (match) {
                case MAILBOX_ID_ADD_TO_FIELD:
                case ACCOUNT_ID_ADD_TO_FIELD:
                    id = uri.getPathSegments().get(1);
                    String field = values.getAsString(EmailContent.FIELD_COLUMN_NAME);
                    Long add = values.getAsLong(EmailContent.ADD_COLUMN_NAME);
                    if (field == null || add == null) {
                        throw new IllegalArgumentException(""No field/add specified "" + uri);
                    }
                    ContentValues actualValues = new ContentValues();
                    if (cache != null) {
                        cache.lock(id);
                    }
                    try {
                        db.beginTransaction();
                        try {
                            Cursor c = db.query(tableName,
                                    new String[] {EmailContent.RECORD_ID, field},
                                    whereWithId(id, selection),
                                    selectionArgs, null, null, null);
                            try {
                                result = 0;
                                String[] bind = new String[1];
                                if (c.moveToNext()) {
                                    bind[0] = c.getString(0); // _id
                                    long value = c.getLong(1) + add;
                                    actualValues.put(field, value);
                                    result = db.update(tableName, actualValues, ID_EQUALS, bind);
                                }
                                db.setTransactionSuccessful();
                            } finally {
                                c.close();
                            }
                        } finally {
                            db.endTransaction();
                        }
                    } finally {
                        if (cache != null) {
                            cache.unlock(id, actualValues);
                        }
                    }
                    break;
                case SYNCED_MESSAGE_ID:
                case UPDATED_MESSAGE_ID:
                case MESSAGE_ID:
                case BODY_ID:
                case ATTACHMENT_ID:
                case MAILBOX_ID:
                case ACCOUNT_ID:
                case HOSTAUTH_ID:
                case QUICK_RESPONSE_ID:
                case POLICY_ID:
                    id = uri.getPathSegments().get(1);
                    if (cache != null) {
                        cache.lock(id);
                    }
                    try {
                        if (match == SYNCED_MESSAGE_ID) {
                            // For synced messages, first copy the old message to the updated table
                            // Note the insert or ignore semantics, guaranteeing that only the first
                            // update will be reflected in the updated message table; therefore this
                            // row will always have the ""original"" data
                            db.execSQL(UPDATED_MESSAGE_INSERT + id);
                        } else if (match == MESSAGE_ID) {
                            db.execSQL(UPDATED_MESSAGE_DELETE + id);
                        }
                        result = db.update(tableName, values, whereWithId(id, selection),
                                selectionArgs);
                    } catch (SQLiteException e) {
                        // Null out values (so they aren't cached) and re-throw
                        values = null;
                        throw e;
                    } finally {
                        if (cache != null) {
                            cache.unlock(id, values);
                        }
                    }
                    if (match == ATTACHMENT_ID) {
                        if (values.containsKey(Attachment.FLAGS)) {
                            int flags = values.getAsInteger(Attachment.FLAGS);
                            mAttachmentService.attachmentChanged(getContext(),
                                    Integer.parseInt(id), flags);
                        }
                    }
                    break;
                case BODY:
                case MESSAGE:
                case UPDATED_MESSAGE:
                case ATTACHMENT:
                case MAILBOX:
                case ACCOUNT:
                case HOSTAUTH:
                case POLICY:
                    switch(match) {
                        // To avoid invalidating the cache on updates, we execute them one at a
                        // time using the XXX_ID uri; these are all executed atomically
                        case ACCOUNT:
                        case MAILBOX:
                        case HOSTAUTH:
                        case POLICY:
                            Cursor c = db.query(tableName, EmailContent.ID_PROJECTION,
                                    selection, selectionArgs, null, null, null);
                            db.beginTransaction();
                            result = 0;
                            try {
                                while (c.moveToNext()) {
                                    update(ContentUris.withAppendedId(
                                                uri, c.getLong(EmailContent.ID_PROJECTION_COLUMN)),
                                            values, null, null);
                                    result++;
                                }
                                db.setTransactionSuccessful();
                            } finally {
                                db.endTransaction();
                                c.close();
                            }
                            break outer;
                        // Any cached table other than those above should be invalidated here
                        case MESSAGE:
                            // If we're doing some generic update, the whole cache needs to be
                            // invalidated.  This case should be quite rare
                            cache.invalidate(""Update"", uri, selection);
                            //$FALL-THROUGH$
                        default:
                            result = db.update(tableName, values, selection, selectionArgs);
                            break outer;
                    }
                case ACCOUNT_RESET_NEW_COUNT_ID:
                    id = uri.getPathSegments().get(1);
                    if (cache != null) {
                        cache.lock(id);
                    }
                    ContentValues newMessageCount = CONTENT_VALUES_RESET_NEW_MESSAGE_COUNT;
                    if (values != null) {
                        Long set = values.getAsLong(EmailContent.SET_COLUMN_NAME);
                        if (set != null) {
                            newMessageCount = new ContentValues();
                            newMessageCount.put(Account.NEW_MESSAGE_COUNT, set);
                        }
                    }
                    try {
                        result = db.update(tableName, newMessageCount,
                                whereWithId(id, selection), selectionArgs);
                    } finally {
                        if (cache != null) {
                            cache.unlock(id, values);
                        }
                    }
                    notificationUri = Account.CONTENT_URI; // Only notify account cursors.
                    break;
                case ACCOUNT_RESET_NEW_COUNT:
                    result = db.update(tableName, CONTENT_VALUES_RESET_NEW_MESSAGE_COUNT,
                            selection, selectionArgs);
                    // Affects all accounts.  Just invalidate all account cache.
                    cache.invalidate(""Reset all new counts"", null, null);
                    notificationUri = Account.CONTENT_URI; // Only notify account cursors.
                    break;
                default:
                    throw new IllegalArgumentException(""Unknown URI "" + uri);
            }
        } catch (SQLiteException e) {
            checkDatabases();
            throw e;
        }

        // Notify all notifier cursors
        sendNotifierChange(getBaseNotificationUri(match), NOTIFICATION_OP_UPDATE, id);

        resolver.notifyChange(notificationUri, null);
        return result;
    }

    /**
     * Returns the base notification URI for the given content type.
     *
     * @param match The type of content that was modified.
     */
    private Uri getBaseNotificationUri(int match) {
        Uri baseUri = null;
        switch (match) {
            case MESSAGE:
            case MESSAGE_ID:
            case SYNCED_MESSAGE_ID:
                baseUri = Message.NOTIFIER_URI;
                break;
            case ACCOUNT:
            case ACCOUNT_ID:
                baseUri = Account.NOTIFIER_URI;
                break;
        }
        return baseUri;
    }

    /**
     * Sends a change notification to any cursors observers of the given base URI. The final
     * notification URI is dynamically built to contain the specified information. It will be
     * of the format <<baseURI>>/<<op>>/<<id>>; where <<op>> and <<id>> are optional depending
     * upon the given values.
     * NOTE: If <<op>> is specified, notifications for <<baseURI>>/<<id>> will NOT be invoked.
     * If this is necessary, it can be added. However, due to the implementation of
     * {@link ContentObserver}, observers of <<baseURI>> will receive multiple notifications.
     *
     * @param baseUri The base URI to send notifications to. Must be able to take appended IDs.
     * @param op Optional operation to be appended to the URI.
     * @param id If a positive value, the ID to append to the base URI. Otherwise, no ID will be
     *           appended to the base URI.
     */
    private void sendNotifierChange(Uri baseUri, String op, String id) {
        if (baseUri == null) return;

        final ContentResolver resolver = getContext().getContentResolver();

        // Append the operation, if specified
        if (op != null) {
            baseUri = baseUri.buildUpon().appendEncodedPath(op).build();
        }

        long longId = 0L;
        try {
            longId = Long.valueOf(id);
        } catch (NumberFormatException ignore) {}
        if (longId > 0) {
            resolver.notifyChange(ContentUris.withAppendedId(baseUri, longId), null);
        } else {
            resolver.notifyChange(baseUri, null);
        }
    }

    @Override
    public ContentProviderResult[] applyBatch(ArrayList<ContentProviderOperation> operations)
            throws OperationApplicationException {
        Context context = getContext();
        SQLiteDatabase db = getDatabase(context);
        db.beginTransaction();
        try {
            ContentProviderResult[] results = super.applyBatch(operations);
            db.setTransactionSuccessful();
            return results;
        } finally {
            db.endTransaction();
        }
    }

    /** Counts the number of messages in each mailbox, and updates the message count column. */
    @VisibleForTesting
    static void recalculateMessageCount(SQLiteDatabase db) {
        db.execSQL(""update "" + Mailbox.TABLE_NAME + "" set "" + MailboxColumns.MESSAGE_COUNT +
                ""= (select count(*) from "" + Message.TABLE_NAME +
                "" where "" + Message.MAILBOX_KEY + "" = "" +
                    Mailbox.TABLE_NAME + ""."" + EmailContent.RECORD_ID + "")"");
    }

    @VisibleForTesting
    @SuppressWarnings(""deprecation"")
    static void convertPolicyFlagsToPolicyTable(SQLiteDatabase db) {
        Cursor c = db.query(Account.TABLE_NAME,
                new String[] {EmailContent.RECORD_ID /*0*/, AccountColumns.SECURITY_FLAGS /*1*/},
                AccountColumns.SECURITY_FLAGS + "">0"", null, null, null, null);
        ContentValues cv = new ContentValues();
        String[] args = new String[1];
        while (c.moveToNext()) {
            long securityFlags = c.getLong(1 /*SECURITY_FLAGS*/);
            Policy policy = LegacyPolicySet.flagsToPolicy(securityFlags);
            long policyId = db.insert(Policy.TABLE_NAME, null, policy.toContentValues());
            cv.put(AccountColumns.POLICY_KEY, policyId);
            cv.putNull(AccountColumns.SECURITY_FLAGS);
            args[0] = Long.toString(c.getLong(0 /*RECORD_ID*/));
            db.update(Account.TABLE_NAME, cv, EmailContent.RECORD_ID + ""=?"", args);
        }
    }

    /** Upgrades the database from v17 to v18 */
    @VisibleForTesting
    static void upgradeFromVersion17ToVersion18(SQLiteDatabase db) {
        // Copy the displayName column to the serverId column. In v18 of the database,
        // we use the serverId for IMAP/POP3 mailboxes instead of overloading the
        // display name.
        //
        // For posterity; this is the command we're executing:
        //sqlite> UPDATE mailbox SET serverid=displayname WHERE mailbox._id in (
        //        ...> SELECT mailbox._id FROM mailbox,account,hostauth WHERE
        //        ...> (mailbox.parentkey isnull OR mailbox.parentkey=0) AND
        //        ...> mailbox.accountkey=account._id AND
        //        ...> account.hostauthkeyrecv=hostauth._id AND
        //        ...> (hostauth.protocol='imap' OR hostauth.protocol='pop3'));
        try {
            db.execSQL(
                    ""UPDATE "" + Mailbox.TABLE_NAME + "" SET ""
                    + MailboxColumns.SERVER_ID + ""="" + MailboxColumns.DISPLAY_NAME
                    + "" WHERE ""
                    + Mailbox.TABLE_NAME + ""."" + MailboxColumns.ID + "" IN ( SELECT ""
                    + Mailbox.TABLE_NAME + ""."" + MailboxColumns.ID + "" FROM ""
                    + Mailbox.TABLE_NAME + "","" + Account.TABLE_NAME + "",""
                    + HostAuth.TABLE_NAME + "" WHERE ""
                    + ""(""
                    + Mailbox.TABLE_NAME + ""."" + MailboxColumns.PARENT_KEY + "" isnull OR ""
                    + Mailbox.TABLE_NAME + ""."" + MailboxColumns.PARENT_KEY + ""=0 ""
                    + "") AND ""
                    + Mailbox.TABLE_NAME + ""."" + MailboxColumns.ACCOUNT_KEY + ""=""
                    + Account.TABLE_NAME + ""."" + AccountColumns.ID + "" AND ""
                    + Account.TABLE_NAME + ""."" + AccountColumns.HOST_AUTH_KEY_RECV + ""=""
                    + HostAuth.TABLE_NAME + ""."" + HostAuthColumns.ID + "" AND ( ""
                    + HostAuth.TABLE_NAME + ""."" + HostAuthColumns.PROTOCOL + ""='imap' OR ""
                    + HostAuth.TABLE_NAME + ""."" + HostAuthColumns.PROTOCOL + ""='pop3' ) )"");
        } catch (SQLException e) {
            // Shouldn't be needed unless we're debugging and interrupt the process
            Log.w(TAG, ""Exception upgrading EmailProvider.db from 17 to 18 "" + e);
        }
        ContentCache.invalidateAllCaches();
    }

    /** Upgrades the database from v20 to v21 */
    private static void upgradeFromVersion20ToVersion21(SQLiteDatabase db) {
        try {
            db.execSQL(""alter table "" + Mailbox.TABLE_NAME
                    + "" add column "" + Mailbox.LAST_SEEN_MESSAGE_KEY + "" integer;"");
        } catch (SQLException e) {
            // Shouldn't be needed unless we're debugging and interrupt the process
            Log.w(TAG, ""Exception upgrading EmailProvider.db from 20 to 21 "" + e);
        }
    }

    /**
     * Upgrade the database from v21 to v22
     * This entails creating AccountManager accounts for all pop3 and imap accounts
     */

    private static final String[] V21_ACCOUNT_PROJECTION =
        new String[] {AccountColumns.HOST_AUTH_KEY_RECV, AccountColumns.EMAIL_ADDRESS};
    private static final int V21_ACCOUNT_RECV = 0;
    private static final int V21_ACCOUNT_EMAIL = 1;

    private static final String[] V21_HOSTAUTH_PROJECTION =
        new String[] {HostAuthColumns.PROTOCOL, HostAuthColumns.PASSWORD};
    private static final int V21_HOSTAUTH_PROTOCOL = 0;
    private static final int V21_HOSTAUTH_PASSWORD = 1;

    static private void createAccountManagerAccount(Context context, String login,
            String password) {
        AccountManager accountManager = AccountManager.get(context);
        android.accounts.Account amAccount =
            new android.accounts.Account(login, AccountManagerTypes.TYPE_POP_IMAP);
        accountManager.addAccountExplicitly(amAccount, password, null);
        ContentResolver.setIsSyncable(amAccount, EmailContent.AUTHORITY, 1);
        ContentResolver.setSyncAutomatically(amAccount, EmailContent.AUTHORITY, true);
        ContentResolver.setIsSyncable(amAccount, ContactsContract.AUTHORITY, 0);
        ContentResolver.setIsSyncable(amAccount, CalendarProviderStub.AUTHORITY, 0);
    }

    @VisibleForTesting
    static void upgradeFromVersion21ToVersion22(SQLiteDatabase db, Context accountManagerContext) {
        try {
            // Loop through accounts, looking for pop/imap accounts
            Cursor accountCursor = db.query(Account.TABLE_NAME, V21_ACCOUNT_PROJECTION, null,
                    null, null, null, null);
            try {
                String[] hostAuthArgs = new String[1];
                while (accountCursor.moveToNext()) {
                    hostAuthArgs[0] = accountCursor.getString(V21_ACCOUNT_RECV);
                    // Get the ""receive"" HostAuth for this account
                    Cursor hostAuthCursor = db.query(HostAuth.TABLE_NAME,
                            V21_HOSTAUTH_PROJECTION, HostAuth.RECORD_ID + ""=?"", hostAuthArgs,
                            null, null, null);
                    try {
                        if (hostAuthCursor.moveToFirst()) {
                            String protocol = hostAuthCursor.getString(V21_HOSTAUTH_PROTOCOL);
                            // If this is a pop3 or imap account, create the account manager account
                            if (HostAuth.SCHEME_IMAP.equals(protocol) ||
                                    HostAuth.SCHEME_POP3.equals(protocol)) {
                                if (Email.DEBUG) {
                                    Log.d(TAG, ""Create AccountManager account for "" + protocol +
                                            ""account: "" +
                                            accountCursor.getString(V21_ACCOUNT_EMAIL));
                                }
                                createAccountManagerAccount(accountManagerContext,
                                        accountCursor.getString(V21_ACCOUNT_EMAIL),
                                        hostAuthCursor.getString(V21_HOSTAUTH_PASSWORD));
                            // If an EAS account, make Email sync automatically (equivalent of
                            // checking the ""Sync Email"" box in settings
                            } else if (HostAuth.SCHEME_EAS.equals(protocol)) {
                                android.accounts.Account amAccount =
                                        new android.accounts.Account(
                                                accountCursor.getString(V21_ACCOUNT_EMAIL),
                                                AccountManagerTypes.TYPE_EXCHANGE);
                                ContentResolver.setIsSyncable(amAccount, EmailContent.AUTHORITY, 1);
                                ContentResolver.setSyncAutomatically(amAccount,
                                        EmailContent.AUTHORITY, true);

                            }
                        }
                    } finally {
                        hostAuthCursor.close();
                    }
                }
            } finally {
                accountCursor.close();
            }
        } catch (SQLException e) {
            // Shouldn't be needed unless we're debugging and interrupt the process
            Log.w(TAG, ""Exception upgrading EmailProvider.db from 20 to 21 "" + e);
        }
    }

    /** Upgrades the database from v22 to v23 */
    private static void upgradeFromVersion22ToVersion23(SQLiteDatabase db) {
        try {
            db.execSQL(""alter table "" + Mailbox.TABLE_NAME
                    + "" add column "" + Mailbox.LAST_TOUCHED_TIME + "" integer default 0;"");
        } catch (SQLException e) {
            // Shouldn't be needed unless we're debugging and interrupt the process
            Log.w(TAG, ""Exception upgrading EmailProvider.db from 22 to 23 "" + e);
        }
    }

    /** Adds in a column for information about a client certificate to use. */
    private static void upgradeFromVersion23ToVersion24(SQLiteDatabase db) {
        try {
            db.execSQL(""alter table "" + HostAuth.TABLE_NAME
                    + "" add column "" + HostAuth.CLIENT_CERT_ALIAS + "" text;"");
        } catch (SQLException e) {
            // Shouldn't be needed unless we're debugging and interrupt the process
            Log.w(TAG, ""Exception upgrading EmailProvider.db from 23 to 24 "" + e);
        }
    }

    /** Upgrades the database from v24 to v25 by creating table for quick responses */
    private static void upgradeFromVersion24ToVersion25(SQLiteDatabase db) {
        try {
            createQuickResponseTable(db);
        } catch (SQLException e) {
            // Shouldn't be needed unless we're debugging and interrupt the process
            Log.w(TAG, ""Exception upgrading EmailProvider.db from 24 to 25 "" + e);
        }
    }

    private static final String[] V25_ACCOUNT_PROJECTION =
        new String[] {AccountColumns.ID, AccountColumns.FLAGS, AccountColumns.HOST_AUTH_KEY_RECV};
    private static final int V25_ACCOUNT_ID = 0;
    private static final int V25_ACCOUNT_FLAGS = 1;
    private static final int V25_ACCOUNT_RECV = 2;

    private static final String[] V25_HOSTAUTH_PROJECTION = new String[] {HostAuthColumns.PROTOCOL};
    private static final int V25_HOSTAUTH_PROTOCOL = 0;

    /** Upgrades the database from v25 to v26 by adding FLAG_SUPPORTS_SEARCH to IMAP accounts */
    private static void upgradeFromVersion25ToVersion26(SQLiteDatabase db) {
        try {
            // Loop through accounts, looking for imap accounts
            Cursor accountCursor = db.query(Account.TABLE_NAME, V25_ACCOUNT_PROJECTION, null,
                    null, null, null, null);
            ContentValues cv = new ContentValues();
            try {
                String[] hostAuthArgs = new String[1];
                while (accountCursor.moveToNext()) {
                    hostAuthArgs[0] = accountCursor.getString(V25_ACCOUNT_RECV);
                    // Get the ""receive"" HostAuth for this account
                    Cursor hostAuthCursor = db.query(HostAuth.TABLE_NAME,
                            V25_HOSTAUTH_PROJECTION, HostAuth.RECORD_ID + ""=?"", hostAuthArgs,
                            null, null, null);
                    try {
                        if (hostAuthCursor.moveToFirst()) {
                            String protocol = hostAuthCursor.getString(V25_HOSTAUTH_PROTOCOL);
                            // If this is an imap account, add the search flag
                            if (HostAuth.SCHEME_IMAP.equals(protocol)) {
                                String id = accountCursor.getString(V25_ACCOUNT_ID);
                                int flags = accountCursor.getInt(V25_ACCOUNT_FLAGS);
                                cv.put(AccountColumns.FLAGS, flags | Account.FLAGS_SUPPORTS_SEARCH);
                                db.update(Account.TABLE_NAME, cv, Account.RECORD_ID + ""=?"",
                                        new String[] {id});
                            }
                        }
                    } finally {
                        hostAuthCursor.close();
                    }
                }
            } finally {
                accountCursor.close();
            }
        } catch (SQLException e) {
            // Shouldn't be needed unless we're debugging and interrupt the process
            Log.w(TAG, ""Exception upgrading EmailProvider.db from 25 to 26 "" + e);
        }
    }

        /**
     * For testing purposes, check whether a given row is cached
     * @param baseUri the base uri of the EmailContent
     * @param id the row id of the EmailContent
     * @return whether or not the row is currently cached
     */
    @VisibleForTesting
    protected boolean isCached(Uri baseUri, long id) {
        int match = findMatch(baseUri, ""isCached"");
        int table = match >> BASE_SHIFT;
        ContentCache cache = mContentCaches[table];
        if (cache == null) return false;
        Cursor cc = cache.get(Long.toString(id));
        return (cc != null);
    }

    public static interface AttachmentService {
        /**
         * Notify the service that an attachment has changed.
         */
        void attachmentChanged(Context context, long id, int flags);
    }

    private final AttachmentService DEFAULT_ATTACHMENT_SERVICE = new AttachmentService() {
        @Override
        public void attachmentChanged(Context context, long id, int flags) {
            // The default implementation delegates to the real service.
            AttachmentDownloadService.attachmentChanged(context, id, flags);
        }
    };
    private AttachmentService mAttachmentService = DEFAULT_ATTACHMENT_SERVICE;

    /**
     * Injects a custom attachment service handler. If null is specified, will reset to the
     * default service.
     */
    public void injectAttachmentService(AttachmentService as) {
        mAttachmentService = (as == null) ? DEFAULT_ATTACHMENT_SERVICE : as;
    }
}
",True,302,2,19,11,41,22,14,L6
102,com.android.email.provider.WidgetProvider.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.provider;

import android.app.Service;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.widget.RemoteViewsService;

import com.android.email.Email;
import com.android.email.widget.EmailWidget;
import com.android.email.widget.WidgetManager;
import com.android.emailcommon.Logging;

import java.io.FileDescriptor;
import java.io.PrintWriter;

public class WidgetProvider extends AppWidgetProvider {
    @Override
    public void onEnabled(final Context context) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(EmailWidget.TAG, ""onEnabled"");
        }
        super.onEnabled(context);
    }

    @Override
    public void onDisabled(Context context) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(EmailWidget.TAG, ""onDisabled"");
        }
        context.stopService(new Intent(context, WidgetService.class));
        super.onDisabled(context);
    }

    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(EmailWidget.TAG, ""onUpdate"");
        }
        super.onUpdate(context, appWidgetManager, appWidgetIds);
        WidgetManager.getInstance().updateWidgets(context, appWidgetIds);
    }

    @Override
    public void onDeleted(Context context, int[] appWidgetIds) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(EmailWidget.TAG, ""onDeleted"");
        }
        WidgetManager.getInstance().deleteWidgets(context, appWidgetIds);
        super.onDeleted(context, appWidgetIds);
    }

    @Override
    public void onReceive(final Context context, Intent intent) {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(EmailWidget.TAG, ""onReceive"");
        }
        super.onReceive(context, intent);
    }

    /**
     * We use the WidgetService for two purposes:
     *  1) To provide a widget factory for RemoteViews, and
     *  2) Catch our command Uri's (i.e. take actions on user clicks) and let EmailWidget
     *     handle them.
     */
    public static class WidgetService extends RemoteViewsService {
        @Override
        public RemoteViewsFactory onGetViewFactory(Intent intent) {
            // Which widget do we want (nice alliteration, huh?)
            int widgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1);
            if (widgetId == -1) return null;
            // Find the existing widget or create it
            return WidgetManager.getInstance().getOrCreateWidget(this, widgetId);
        }

        @Override
        public int onStartCommand(Intent intent, int flags, int startId) {
            if (intent.getData() != null) {
                // EmailWidget creates intents, so it knows how to handle them.
                EmailWidget.processIntent(this, intent);
            }
            return Service.START_NOT_STICKY;
        }

        @Override
        protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
            WidgetManager.getInstance().dump(fd, writer, args);
        }
    }
 }
",False,267,0,0,11,51,1,4,L6
103,com.android.email.provider.AccountBackupRestore.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.provider;

import android.content.ContentResolver;
import android.content.Context;

/**
 * Helper class to facilitate EmailProvider's account backup/restore facility.
 *
 * Account backup/restore was implemented entirely for the purpose of recovering from database
 * corruption errors that were/are sporadic and of undetermined cause (though the prevailing wisdom
 * is that this is due to some kind of memory issue).  Rather than have the offending database get
 * deleted by SQLiteDatabase and forcing the user to recreate his accounts from scratch, it was
 * decided to backup accounts when created/modified and then restore them if 1) there are no
 * accounts in the database and 2) there are backup accounts.  This, at least, would cause user's
 * email data for IMAP/EAS to be re-synced and prevent the worst outcomes from occurring.
 *
 * To accomplish backup/restore, we use the facility now built in to EmailProvider to store a
 * backup version of the Account and HostAuth tables in a second database (EmailProviderBackup.db)
 *
 * TODO: We might look into having our own DatabaseErrorHandler that tries to be clever about
 * determining whether or not a ""corrupt"" database is truly corrupt; the problem here is that it
 * has proven impossible to reproduce the bug, and therefore any ""solution"" of this kind of utterly
 * impossible to test in the wild.
 */
public class AccountBackupRestore {
    /**
     * Backup user Account and HostAuth data into our backup database
     *
     * TODO Make EmailProvider do this automatically.
     */
    public static void backup(Context context) {
        ContentResolver resolver = context.getContentResolver();
        resolver.update(EmailProvider.ACCOUNT_BACKUP_URI, null, null, null);
    }
}
",False,268,1,1,12,41,7,1,L6
104,com.android.email.provider.AttachmentProvider.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.provider;

import com.android.emailcommon.Logging;
import com.android.emailcommon.internet.MimeUtility;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.AttachmentColumns;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.emailcommon.utility.AttachmentUtilities.Columns;

import android.content.ContentProvider;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.database.MatrixCursor;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.os.Binder;
import android.os.ParcelFileDescriptor;
import android.util.Log;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;

/*
 * A simple ContentProvider that allows file access to Email's attachments.
 *
 * The URI scheme is as follows.  For raw file access:
 *   content://com.android.email.attachmentprovider/acct#/attach#/RAW
 *
 * And for access to thumbnails:
 *   content://com.android.email.attachmentprovider/acct#/attach#/THUMBNAIL/width#/height#
 *
 * The on-disk (storage) schema is as follows.
 *
 * Attachments are stored at:  <database-path>/account#.db_att/item#
 * Thumbnails are stored at:   <cache-path>/thmb_account#_item#
 *
 * Using the standard application context, account #10 and attachment # 20, this would be:
 *      /data/data/com.android.email/databases/10.db_att/20
 *      /data/data/com.android.email/cache/thmb_10_20
 */
public class AttachmentProvider extends ContentProvider {

    private static final String[] MIME_TYPE_PROJECTION = new String[] {
            AttachmentColumns.MIME_TYPE, AttachmentColumns.FILENAME };
    private static final int MIME_TYPE_COLUMN_MIME_TYPE = 0;
    private static final int MIME_TYPE_COLUMN_FILENAME = 1;

    private static final String[] PROJECTION_QUERY = new String[] { AttachmentColumns.FILENAME,
            AttachmentColumns.SIZE, AttachmentColumns.CONTENT_URI };

    @Override
    public boolean onCreate() {
        /*
         * We use the cache dir as a temporary directory (since Android doesn't give us one) so
         * on startup we'll clean up any .tmp files from the last run.
         */
        File[] files = getContext().getCacheDir().listFiles();
        for (File file : files) {
            String filename = file.getName();
            if (filename.endsWith("".tmp"") || filename.startsWith(""thmb_"")) {
                file.delete();
            }
        }
        return true;
    }

    /**
     * Returns the mime type for a given attachment.  There are three possible results:
     *  - If thumbnail Uri, always returns ""image/png"" (even if there's no attachment)
     *  - If the attachment does not exist, returns null
     *  - Returns the mime type of the attachment
     */
    @Override
    public String getType(Uri uri) {
        long callingId = Binder.clearCallingIdentity();
        try {
            List<String> segments = uri.getPathSegments();
            String id = segments.get(1);
            String format = segments.get(2);
            if (AttachmentUtilities.FORMAT_THUMBNAIL.equals(format)) {
                return ""image/png"";
            } else {
                uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, Long.parseLong(id));
                Cursor c = getContext().getContentResolver().query(uri, MIME_TYPE_PROJECTION, null,
                        null, null);
                try {
                    if (c.moveToFirst()) {
                        String mimeType = c.getString(MIME_TYPE_COLUMN_MIME_TYPE);
                        String fileName = c.getString(MIME_TYPE_COLUMN_FILENAME);
                        mimeType = AttachmentUtilities.inferMimeType(fileName, mimeType);
                        return mimeType;
                    }
                } finally {
                    c.close();
                }
                return null;
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    /**
     * Open an attachment file.  There are two ""formats"" - ""raw"", which returns an actual file,
     * and ""thumbnail"", which attempts to generate a thumbnail image.
     *
     * Thumbnails are cached for easy space recovery and cleanup.
     *
     * TODO:  The thumbnail format returns null for its failure cases, instead of throwing
     * FileNotFoundException, and should be fixed for consistency.
     *
     *  @throws FileNotFoundException
     */
    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
        // If this is a write, the caller must have the EmailProvider permission, which is
        // based on signature only
        if (mode.equals(""w"")) {
            Context context = getContext();
            if (context.checkCallingPermission(EmailContent.PROVIDER_PERMISSION)
                    != PackageManager.PERMISSION_GRANTED) {
                throw new FileNotFoundException();
            }
            List<String> segments = uri.getPathSegments();
            String accountId = segments.get(0);
            String id = segments.get(1);
            File saveIn =
                AttachmentUtilities.getAttachmentDirectory(context, Long.parseLong(accountId));
            if (!saveIn.exists()) {
                saveIn.mkdirs();
            }
            File newFile = new File(saveIn, id);
            return ParcelFileDescriptor.open(
                    newFile, ParcelFileDescriptor.MODE_READ_WRITE |
                        ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE);
        }
        long callingId = Binder.clearCallingIdentity();
        try {
            List<String> segments = uri.getPathSegments();
            String accountId = segments.get(0);
            String id = segments.get(1);
            String format = segments.get(2);
            if (AttachmentUtilities.FORMAT_THUMBNAIL.equals(format)) {
                int width = Integer.parseInt(segments.get(3));
                int height = Integer.parseInt(segments.get(4));
                String filename = ""thmb_"" + accountId + ""_"" + id;
                File dir = getContext().getCacheDir();
                File file = new File(dir, filename);
                if (!file.exists()) {
                    Uri attachmentUri = AttachmentUtilities.
                        getAttachmentUri(Long.parseLong(accountId), Long.parseLong(id));
                    Cursor c = query(attachmentUri,
                            new String[] { Columns.DATA }, null, null, null);
                    if (c != null) {
                        try {
                            if (c.moveToFirst()) {
                                attachmentUri = Uri.parse(c.getString(0));
                            } else {
                                return null;
                            }
                        } finally {
                            c.close();
                        }
                    }
                    String type = getContext().getContentResolver().getType(attachmentUri);
                    try {
                        InputStream in =
                            getContext().getContentResolver().openInputStream(attachmentUri);
                        Bitmap thumbnail = createThumbnail(type, in);
                        if (thumbnail == null) {
                            return null;
                        }
                        thumbnail = Bitmap.createScaledBitmap(thumbnail, width, height, true);
                        FileOutputStream out = new FileOutputStream(file);
                        thumbnail.compress(Bitmap.CompressFormat.PNG, 100, out);
                        out.close();
                        in.close();
                    } catch (IOException ioe) {
                        Log.d(Logging.LOG_TAG, ""openFile/thumbnail failed with "" +
                                ioe.getMessage());
                        return null;
                    } catch (OutOfMemoryError oome) {
                        Log.d(Logging.LOG_TAG, ""openFile/thumbnail failed with "" +
                                oome.getMessage());
                        return null;
                    }
                }
                return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
            }
            else {
                return ParcelFileDescriptor.open(
                        new File(getContext().getDatabasePath(accountId + "".db_att""), id),
                        ParcelFileDescriptor.MODE_READ_ONLY);
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    @Override
    public int delete(Uri uri, String arg1, String[] arg2) {
        return 0;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        return null;
    }

    /**
     * Returns a cursor based on the data in the attachments table, or null if the attachment
     * is not recorded in the table.
     *
     * Supports REST Uri only, for a single row - selection, selection args, and sortOrder are
     * ignored (non-null values should probably throw an exception....)
     */
    @Override
    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
            String sortOrder) {
        long callingId = Binder.clearCallingIdentity();
        try {
            if (projection == null) {
                projection =
                    new String[] {
                        Columns._ID,
                        Columns.DATA,
                };
            }

            List<String> segments = uri.getPathSegments();
            String accountId = segments.get(0);
            String id = segments.get(1);
            String format = segments.get(2);
            String name = null;
            int size = -1;
            String contentUri = null;

            uri = ContentUris.withAppendedId(Attachment.CONTENT_URI, Long.parseLong(id));
            Cursor c = getContext().getContentResolver().query(uri, PROJECTION_QUERY,
                    null, null, null);
            try {
                if (c.moveToFirst()) {
                    name = c.getString(0);
                    size = c.getInt(1);
                    contentUri = c.getString(2);
                } else {
                    return null;
                }
            } finally {
                c.close();
            }

            MatrixCursor ret = new MatrixCursor(projection);
            Object[] values = new Object[projection.length];
            for (int i = 0, count = projection.length; i < count; i++) {
                String column = projection[i];
                if (Columns._ID.equals(column)) {
                    values[i] = id;
                }
                else if (Columns.DATA.equals(column)) {
                    values[i] = contentUri;
                }
                else if (Columns.DISPLAY_NAME.equals(column)) {
                    values[i] = name;
                }
                else if (Columns.SIZE.equals(column)) {
                    values[i] = size;
                }
            }
            ret.addRow(values);
            return ret;
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }

    @Override
    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
        return 0;
    }

    private Bitmap createThumbnail(String type, InputStream data) {
        if(MimeUtility.mimeTypeMatches(type, ""image/*"")) {
            return createImageThumbnail(data);
        }
        return null;
    }

    private Bitmap createImageThumbnail(InputStream data) {
        try {
            Bitmap bitmap = BitmapFactory.decodeStream(data);
            return bitmap;
        } catch (OutOfMemoryError oome) {
            Log.d(Logging.LOG_TAG, ""createImageThumbnail failed with "" + oome.getMessage());
            return null;
        } catch (Exception e) {
            Log.d(Logging.LOG_TAG, ""createImageThumbnail failed with "" + e.getMessage());
            return null;
        }
    }

    /**
     * Need this to suppress warning in unit tests.
     */
    @Override
    public void shutdown() {
        // Don't call super.shutdown(), which emits a warning...
    }
}
",True,58,2,15,5,17,2,4,L5
105,com.android.email.service.EasAuthenticatorServiceAlternate.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

/**
 * {@link EasAuthenticatorService} used with the alternative label.
 *
 * <p>Functionality wise, it's a 100% clone of {@link EasAuthenticatorService}, but in order to
 * independently disable/enable each service we need to give it a different class name.
 */
public class EasAuthenticatorServiceAlternate extends EasAuthenticatorService {

}
",False,268,0,0,13,61,0,1,L8
106,com.android.email.service.EmailBroadcastProcessorService.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.accounts.AccountManager;
import android.app.IntentService;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.util.Log;

import com.android.email.Email;
import com.android.email.Preferences;
import com.android.email.SecurityPolicy;
import com.android.email.VendorPolicyLoader;
import com.android.email.activity.setup.AccountSettings;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.HostAuth;

/**
 * The service that really handles broadcast intents on a worker thread.
 *
 * We make it a service, because:
 * <ul>
 *   <li>So that it's less likely for the process to get killed.
 *   <li>Even if it does, the Intent that have started it will be re-delivered by the system,
 *   and we can start the process again.  (Using {@link #setIntentRedelivery}).
 * </ul>
 *
 * This also handles the DeviceAdminReceiver in SecurityPolicy, because it is also
 * a BroadcastReceiver and requires the same processing semantics.
 */
public class EmailBroadcastProcessorService extends IntentService {
    // Action used for BroadcastReceiver entry point
    private static final String ACTION_BROADCAST = ""broadcast_receiver"";

    // Dialing ""*#*#36245#*#*"" to open the debug screen.   ""36245"" = ""email""
    private static final String ACTION_SECRET_CODE = ""android.provider.Telephony.SECRET_CODE"";
    private static final String SECRET_CODE_HOST_DEBUG_SCREEN = ""36245"";

    // This is a helper used to process DeviceAdminReceiver messages
    private static final String ACTION_DEVICE_POLICY_ADMIN = ""com.android.email.devicepolicy"";
    private static final String EXTRA_DEVICE_POLICY_ADMIN = ""message_code"";

    public EmailBroadcastProcessorService() {
        // Class name will be the thread name.
        super(EmailBroadcastProcessorService.class.getName());

        // Intent should be redelivered if the process gets killed before completing the job.
        setIntentRedelivery(true);
    }

    /**
     * Entry point for {@link EmailBroadcastReceiver}.
     */
    public static void processBroadcastIntent(Context context, Intent broadcastIntent) {
        Intent i = new Intent(context, EmailBroadcastProcessorService.class);
        i.setAction(ACTION_BROADCAST);
        i.putExtra(Intent.EXTRA_INTENT, broadcastIntent);
        context.startService(i);
    }

    /**
     * Entry point for {@link com.android.email.SecurityPolicy.PolicyAdmin}.  These will
     * simply callback to {@link
     * com.android.email.SecurityPolicy#onDeviceAdminReceiverMessage(Context, int)}.
     */
    public static void processDevicePolicyMessage(Context context, int message) {
        Intent i = new Intent(context, EmailBroadcastProcessorService.class);
        i.setAction(ACTION_DEVICE_POLICY_ADMIN);
        i.putExtra(EXTRA_DEVICE_POLICY_ADMIN, message);
        context.startService(i);
    }

    @Override
    protected void onHandleIntent(Intent intent) {
        // This method is called on a worker thread.

        // Dispatch from entry point
        final String action = intent.getAction();
        if (ACTION_BROADCAST.equals(action)) {
            final Intent broadcastIntent = intent.getParcelableExtra(Intent.EXTRA_INTENT);
            final String broadcastAction = broadcastIntent.getAction();

            if (Intent.ACTION_BOOT_COMPLETED.equals(broadcastAction)) {
                onBootCompleted();

            // TODO: Do a better job when we get ACTION_DEVICE_STORAGE_LOW.
            //       The code below came from very old code....
            } else if (Intent.ACTION_DEVICE_STORAGE_LOW.equals(broadcastAction)) {
                // Stop IMAP/POP3 poll.
                MailService.actionCancel(this);
            } else if (Intent.ACTION_DEVICE_STORAGE_OK.equals(broadcastAction)) {
                enableComponentsIfNecessary();
            } else if (ACTION_SECRET_CODE.equals(broadcastAction)
                    && SECRET_CODE_HOST_DEBUG_SCREEN.equals(broadcastIntent.getData().getHost())) {
                AccountSettings.actionSettingsWithDebug(this);
            } else if (AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION.equals(broadcastAction)) {
                onSystemAccountChanged();
            }
        } else if (ACTION_DEVICE_POLICY_ADMIN.equals(action)) {
            int message = intent.getIntExtra(EXTRA_DEVICE_POLICY_ADMIN, -1);
            SecurityPolicy.onDeviceAdminReceiverMessage(this, message);
        }
    }

    private void enableComponentsIfNecessary() {
        if (Email.setServicesEnabledSync(this)) {
            // At least one account exists.
            // TODO probably we should check if it's a POP/IMAP account.
            MailService.actionReschedule(this);
        }
    }

    /**
     * Handles {@link Intent#ACTION_BOOT_COMPLETED}.  Called on a worker thread.
     */
    private void onBootCompleted() {
        performOneTimeInitialization();

        enableComponentsIfNecessary();

        // Starts the service for Exchange, if supported.
        EmailServiceUtils.startExchangeService(this);
    }

    private void performOneTimeInitialization() {
        final Preferences pref = Preferences.getPreferences(this);
        int progress = pref.getOneTimeInitializationProgress();
        final int initialProgress = progress;

        if (progress < 1) {
            Log.i(Logging.LOG_TAG, ""Onetime initialization: 1"");
            progress = 1;
            if (VendorPolicyLoader.getInstance(this).useAlternateExchangeStrings()) {
                setComponentEnabled(EasAuthenticatorServiceAlternate.class, true);
                setComponentEnabled(EasAuthenticatorService.class, false);
            }
        }

        if (progress < 2) {
            Log.i(Logging.LOG_TAG, ""Onetime initialization: 2"");
            progress = 2;
            setImapDeletePolicy(this);
        }

        // Add your initialization steps here.
        // Use ""progress"" to skip the initializations that's already done before.
        // Using this preference also makes it safe when a user skips an upgrade.  (i.e. upgrading
        // version N to version N+2)

        if (progress != initialProgress) {
            pref.setOneTimeInitializationProgress(progress);
            Log.i(Logging.LOG_TAG, ""Onetime initialization: completed."");
        }
    }

    /**
     * Sets the delete policy to the correct value for all IMAP accounts. This will have no
     * effect on either EAS or POP3 accounts.
     */
    /*package*/ static void setImapDeletePolicy(Context context) {
        ContentResolver resolver = context.getContentResolver();
        Cursor c = resolver.query(Account.CONTENT_URI, Account.CONTENT_PROJECTION,
                null, null, null);
        try {
            while (c.moveToNext()) {
                long recvAuthKey = c.getLong(Account.CONTENT_HOST_AUTH_KEY_RECV_COLUMN);
                HostAuth recvAuth = HostAuth.restoreHostAuthWithId(context, recvAuthKey);
                if (HostAuth.SCHEME_IMAP.equals(recvAuth.mProtocol)) {
                    int flags = c.getInt(Account.CONTENT_FLAGS_COLUMN);
                    flags &= ~Account.FLAGS_DELETE_POLICY_MASK;
                    flags |= Account.DELETE_POLICY_ON_DELETE << Account.FLAGS_DELETE_POLICY_SHIFT;
                    ContentValues cv = new ContentValues();
                    cv.put(AccountColumns.FLAGS, flags);
                    long accountId = c.getLong(Account.CONTENT_ID_COLUMN);
                    Uri uri = ContentUris.withAppendedId(Account.CONTENT_URI, accountId);
                    resolver.update(uri, cv, null, null);
                }
            }
        } finally {
            c.close();
        }
    }

    private void setComponentEnabled(Class<?> clazz, boolean enabled) {
        final ComponentName c = new ComponentName(this, clazz.getName());
        getPackageManager().setComponentEnabledSetting(c,
                enabled ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED
                        : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);
    }

    private void onSystemAccountChanged() {
        Log.i(Logging.LOG_TAG, ""System accounts updated."");
        MailService.reconcilePopImapAccountsSync(this);

        // If the exchange service wasn't already running, starting it will cause exchange account
        // reconciliation to be performed.  The service stops itself it there are no EAS accounts.
        EmailServiceUtils.startExchangeService(this);
    }
}
",True,269,1,2,11,45,3,11,L6
107,com.android.email.service.AttachmentDownloadService.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.accounts.AccountManager;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.format.DateUtils;
import android.util.Log;

import com.android.email.AttachmentInfo;
import com.android.email.Controller.ControllerService;
import com.android.email.Email;
import com.android.email.EmailConnectivityManager;
import com.android.email.NotificationController;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Attachment;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.service.EmailServiceStatus;
import com.android.emailcommon.service.IEmailServiceCallback;
import com.android.emailcommon.utility.AttachmentUtilities;
import com.android.emailcommon.utility.Utility;

import java.io.File;
import java.io.FileDescriptor;
import java.io.PrintWriter;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.TreeSet;
import java.util.concurrent.ConcurrentHashMap;

public class AttachmentDownloadService extends Service implements Runnable {
    public static final String TAG = ""AttachmentService"";

    // Our idle time, waiting for notifications; this is something of a failsafe
    private static final int PROCESS_QUEUE_WAIT_TIME = 30 * ((int)DateUtils.MINUTE_IN_MILLIS);
    // How often our watchdog checks for callback timeouts
    private static final int WATCHDOG_CHECK_INTERVAL = 15 * ((int)DateUtils.SECOND_IN_MILLIS);
    // How long we'll wait for a callback before canceling a download and retrying
    private static final int CALLBACK_TIMEOUT = 30 * ((int)DateUtils.SECOND_IN_MILLIS);
    // Try to download an attachment in the background this many times before giving up
    private static final int MAX_DOWNLOAD_RETRIES = 5;
    private static final int PRIORITY_NONE = -1;
    @SuppressWarnings(""unused"")
    // Low priority will be used for opportunistic downloads
    private static final int PRIORITY_BACKGROUND = 0;
    // Normal priority is for forwarded downloads in outgoing mail
    private static final int PRIORITY_SEND_MAIL = 1;
    // High priority is for user requests
    private static final int PRIORITY_FOREGROUND = 2;

    // Minimum free storage in order to perform prefetch (25% of total memory)
    private static final float PREFETCH_MINIMUM_STORAGE_AVAILABLE = 0.25F;
    // Maximum prefetch storage (also 25% of total memory)
    private static final float PREFETCH_MAXIMUM_ATTACHMENT_STORAGE = 0.25F;

    // We can try various values here; I think 2 is completely reasonable as a first pass
    private static final int MAX_SIMULTANEOUS_DOWNLOADS = 2;
    // Limit on the number of simultaneous downloads per account
    // Note that a limit of 1 is currently enforced by both Services (MailService and Controller)
    private static final int MAX_SIMULTANEOUS_DOWNLOADS_PER_ACCOUNT = 1;
    // Limit on the number of attachments we'll check for background download
    private static final int MAX_ATTACHMENTS_TO_CHECK = 25;

    private static final String EXTRA_ATTACHMENT =
        ""com.android.email.AttachmentDownloadService.attachment"";

    // sRunningService is only set in the UI thread; it's visibility elsewhere is guaranteed
    // by the use of ""volatile""
    /*package*/ static volatile AttachmentDownloadService sRunningService = null;

    /*package*/ Context mContext;
    /*package*/ EmailConnectivityManager mConnectivityManager;

    /*package*/ final DownloadSet mDownloadSet = new DownloadSet(new DownloadComparator());

    private final HashMap<Long, Intent> mAccountServiceMap = new HashMap<Long, Intent>();
    // A map of attachment storage used per account
    // NOTE: This map is not kept current in terms of deletions (i.e. it stores the last calculated
    // amount plus the size of any new attachments laoded).  If and when we reach the per-account
    // limit, we recalculate the actual usage
    /*package*/ final HashMap<Long, Long> mAttachmentStorageMap = new HashMap<Long, Long>();
    // A map of attachment ids to the number of failed attempts to download the attachment
    // NOTE: We do not want to persist this. This allows us to retry background downloading
    // if any transient network errors are fixed & and the app is restarted
    /* package */ final HashMap<Long, Integer> mAttachmentFailureMap = new HashMap<Long, Integer>();
    private final ServiceCallback mServiceCallback = new ServiceCallback();

    private final Object mLock = new Object();
    private volatile boolean mStop = false;

    /*package*/ AccountManagerStub mAccountManagerStub;

    /**
     * We only use the getAccounts() call from AccountManager, so this class wraps that call and
     * allows us to build a mock account manager stub in the unit tests
     */
    /*package*/ static class AccountManagerStub {
        private int mNumberOfAccounts;
        private final AccountManager mAccountManager;

        AccountManagerStub(Context context) {
            if (context != null) {
                mAccountManager = AccountManager.get(context);
            } else {
                mAccountManager = null;
            }
        }

        /*package*/ int getNumberOfAccounts() {
            if (mAccountManager != null) {
                return mAccountManager.getAccounts().length;
            } else {
                return mNumberOfAccounts;
            }
        }

        /*package*/ void setNumberOfAccounts(int numberOfAccounts) {
            mNumberOfAccounts = numberOfAccounts;
        }
    }

    /**
     * Watchdog alarm receiver; responsible for making sure that downloads in progress are not
     * stalled, as determined by the timing of the most recent service callback
     */
    public static class Watchdog extends BroadcastReceiver {
        @Override
        public void onReceive(final Context context, Intent intent) {
            new Thread(new Runnable() {
                public void run() {
                    watchdogAlarm();
                }
            }, ""AttachmentDownloadService Watchdog"").start();
        }
    }

    public static class DownloadRequest {
        final int priority;
        final long time;
        final long attachmentId;
        final long messageId;
        final long accountId;
        boolean inProgress = false;
        int lastStatusCode;
        int lastProgress;
        long lastCallbackTime;
        long startTime;

        private DownloadRequest(Context context, Attachment attachment) {
            attachmentId = attachment.mId;
            Message msg = Message.restoreMessageWithId(context, attachment.mMessageKey);
            if (msg != null) {
                accountId = msg.mAccountKey;
                messageId = msg.mId;
            } else {
                accountId = messageId = -1;
            }
            priority = getPriority(attachment);
            time = System.currentTimeMillis();
        }

        @Override
        public int hashCode() {
            return (int)attachmentId;
        }

        /**
         * Two download requests are equals if their attachment id's are equals
         */
        @Override
        public boolean equals(Object object) {
            if (!(object instanceof DownloadRequest)) return false;
            DownloadRequest req = (DownloadRequest)object;
            return req.attachmentId == attachmentId;
        }
    }

    /**
     * Comparator class for the download set; we first compare by priority.  Requests with equal
     * priority are compared by the time the request was created (older requests come first)
     */
    /*protected*/ static class DownloadComparator implements Comparator<DownloadRequest> {
        @Override
        public int compare(DownloadRequest req1, DownloadRequest req2) {
            int res;
            if (req1.priority != req2.priority) {
                res = (req1.priority < req2.priority) ? -1 : 1;
            } else {
                if (req1.time == req2.time) {
                    res = 0;
                } else {
                    res = (req1.time > req2.time) ? -1 : 1;
                }
            }
            return res;
        }
    }

    /**
     * The DownloadSet is a TreeSet sorted by priority class (e.g. low, high, etc.) and the
     * time of the request.  Higher priority requests
     * are always processed first; among equals, the oldest request is processed first.  The
     * priority key represents this ordering.  Note: All methods that change the attachment map are
     * synchronized on the map itself
     */
    /*package*/ class DownloadSet extends TreeSet<DownloadRequest> {
        private static final long serialVersionUID = 1L;
        private PendingIntent mWatchdogPendingIntent;
        private AlarmManager mAlarmManager;

        /*package*/ DownloadSet(Comparator<? super DownloadRequest> comparator) {
            super(comparator);
        }

        /**
         * Maps attachment id to DownloadRequest
         */
        /*package*/ final ConcurrentHashMap<Long, DownloadRequest> mDownloadsInProgress =
            new ConcurrentHashMap<Long, DownloadRequest>();

        /**
         * onChange is called by the AttachmentReceiver upon receipt of a valid notification from
         * EmailProvider that an attachment has been inserted or modified.  It's not strictly
         * necessary that we detect a deleted attachment, as the code always checks for the
         * existence of an attachment before acting on it.
         */
        public synchronized void onChange(Context context, Attachment att) {
            DownloadRequest req = findDownloadRequest(att.mId);
            long priority = getPriority(att);
            if (priority == PRIORITY_NONE) {
                if (Email.DEBUG) {
                    Log.d(TAG, ""== Attachment changed: "" + att.mId);
                }
                // In this case, there is no download priority for this attachment
                if (req != null) {
                    // If it exists in the map, remove it
                    // NOTE: We don't yet support deleting downloads in progress
                    if (Email.DEBUG) {
                        Log.d(TAG, ""== Attachment "" + att.mId + "" was in queue, removing"");
                    }
                    remove(req);
                }
            } else {
                // Ignore changes that occur during download
                if (mDownloadsInProgress.containsKey(att.mId)) return;
                // If this is new, add the request to the queue
                if (req == null) {
                    req = new DownloadRequest(context, att);
                    add(req);
                }
                // If the request already existed, we'll update the priority (so that the time is
                // up-to-date); otherwise, we create a new request
                if (Email.DEBUG) {
                    Log.d(TAG, ""== Download queued for attachment "" + att.mId + "", class "" +
                            req.priority + "", priority time "" + req.time);
                }
            }
            // Process the queue if we're in a wait
            kick();
        }

        /**
         * Find a queued DownloadRequest, given the attachment's id
         * @param id the id of the attachment
         * @return the DownloadRequest for that attachment (or null, if none)
         */
        /*package*/ synchronized DownloadRequest findDownloadRequest(long id) {
            Iterator<DownloadRequest> iterator = iterator();
            while(iterator.hasNext()) {
                DownloadRequest req = iterator.next();
                if (req.attachmentId == id) {
                    return req;
                }
            }
            return null;
        }

        @Override
        public synchronized boolean isEmpty() {
            return super.isEmpty() && mDownloadsInProgress.isEmpty();
        }

        /**
         * Run through the AttachmentMap and find DownloadRequests that can be executed, enforcing
         * the limit on maximum downloads
         */
        /*package*/ synchronized void processQueue() {
            if (Email.DEBUG) {
                Log.d(TAG, ""== Checking attachment queue, "" + mDownloadSet.size() + "" entries"");
            }

            Iterator<DownloadRequest> iterator = mDownloadSet.descendingIterator();
            // First, start up any required downloads, in priority order
            while (iterator.hasNext() &&
                    (mDownloadsInProgress.size() < MAX_SIMULTANEOUS_DOWNLOADS)) {
                DownloadRequest req = iterator.next();
                 // Enforce per-account limit here
                if (downloadsForAccount(req.accountId) >= MAX_SIMULTANEOUS_DOWNLOADS_PER_ACCOUNT) {
                    if (Email.DEBUG) {
                        Log.d(TAG, ""== Skip #"" + req.attachmentId + ""; maxed for acct #"" +
                                req.accountId);
                    }
                    continue;
                }

                if (!req.inProgress) {
                    mDownloadSet.tryStartDownload(req);
                }
            }

            // Don't prefetch if background downloading is disallowed
            EmailConnectivityManager ecm = mConnectivityManager;
            if (ecm == null) return;
            if (!ecm.isAutoSyncAllowed()) return;
            // Don't prefetch unless we're on a WiFi network
            if (ecm.getActiveNetworkType() != ConnectivityManager.TYPE_WIFI) {
                return;
            }
            // Then, try opportunistic download of appropriate attachments
            int backgroundDownloads = MAX_SIMULTANEOUS_DOWNLOADS - mDownloadsInProgress.size();
            // Always leave one slot for user requested download
            if (backgroundDownloads > (MAX_SIMULTANEOUS_DOWNLOADS - 1)) {
                // We'll load up the newest 25 attachments that aren't loaded or queued
                Uri lookupUri = EmailContent.uriWithLimit(Attachment.CONTENT_URI,
                        MAX_ATTACHMENTS_TO_CHECK);
                Cursor c = mContext.getContentResolver().query(lookupUri, AttachmentInfo.PROJECTION,
                        EmailContent.Attachment.PRECACHE_INBOX_SELECTION,
                        null, Attachment.RECORD_ID + "" DESC"");
                File cacheDir = mContext.getCacheDir();
                try {
                    while (c.moveToNext()) {
                        long accountKey = c.getLong(AttachmentInfo.COLUMN_ACCOUNT_KEY);
                        long id = c.getLong(AttachmentInfo.COLUMN_ID);
                        Account account = Account.restoreAccountWithId(mContext, accountKey);
                        if (account == null) {
                            // Clean up this orphaned attachment; there's no point in keeping it
                            // around; then try to find another one
                            EmailContent.delete(mContext, Attachment.CONTENT_URI, id);
                        } else if (canPrefetchForAccount(account, cacheDir)) {
                            // Check that the attachment meets system requirements for download
                            AttachmentInfo info = new AttachmentInfo(mContext, c);
                            if (info.isEligibleForDownload()) {
                                Attachment att = Attachment.restoreAttachmentWithId(mContext, id);
                                if (att != null) {
                                    Integer tryCount;
                                    tryCount = mAttachmentFailureMap.get(att.mId);
                                    if (tryCount != null && tryCount > MAX_DOWNLOAD_RETRIES) {
                                        // move onto the next attachment
                                        continue;
                                    }
                                    // Start this download and we're done
                                    DownloadRequest req = new DownloadRequest(mContext, att);
                                    mDownloadSet.tryStartDownload(req);
                                    break;
                                }
                            }
                        }
                    }
                } finally {
                    c.close();
                }
            }
        }

        /**
         * Count the number of running downloads in progress for this account
         * @param accountId the id of the account
         * @return the count of running downloads
         */
        /*package*/ synchronized int downloadsForAccount(long accountId) {
            int count = 0;
            for (DownloadRequest req: mDownloadsInProgress.values()) {
                if (req.accountId == accountId) {
                    count++;
                }
            }
            return count;
        }

        /**
         * Watchdog for downloads; we use this in case we are hanging on a download, which might
         * have failed silently (the connection dropped, for example)
         */
        private void onWatchdogAlarm() {
            // If our service instance is gone, just leave...
            if (mStop) return;
            long now = System.currentTimeMillis();
            for (DownloadRequest req: mDownloadsInProgress.values()) {
                // Check how long it's been since receiving a callback
                long timeSinceCallback = now - req.lastCallbackTime;
                if (timeSinceCallback > CALLBACK_TIMEOUT) {
                    if (Email.DEBUG) {
                        Log.d(TAG, ""== Download of "" + req.attachmentId + "" timed out"");
                    }
                   cancelDownload(req);
                }
            }
            // If there are downloads in progress, reset alarm
            if (mDownloadsInProgress.isEmpty()) {
                if (mAlarmManager != null && mWatchdogPendingIntent != null) {
                    mAlarmManager.cancel(mWatchdogPendingIntent);
                }
            }
            // Check whether we can start new downloads...
            if (mConnectivityManager != null && mConnectivityManager.hasConnectivity()) {
                processQueue();
            }
        }

        /**
         * Attempt to execute the DownloadRequest, enforcing the maximum downloads per account
         * parameter
         * @param req the DownloadRequest
         * @return whether or not the download was started
         */
        /*package*/ synchronized boolean tryStartDownload(DownloadRequest req) {
            Intent intent = getServiceIntentForAccount(req.accountId);
            if (intent == null) return false;

            // Do not download the same attachment multiple times
            boolean alreadyInProgress = mDownloadsInProgress.get(req.attachmentId) != null;
            if (alreadyInProgress) return false;

            try {
                if (Email.DEBUG) {
                    Log.d(TAG, "">> Starting download for attachment #"" + req.attachmentId);
                }
                startDownload(intent, req);
            } catch (RemoteException e) {
                // TODO: Consider whether we need to do more in this case...
                // For now, fix up our data to reflect the failure
                cancelDownload(req);
            }
            return true;
        }

        private synchronized DownloadRequest getDownloadInProgress(long attachmentId) {
            return mDownloadsInProgress.get(attachmentId);
        }

        /**
         * Do the work of starting an attachment download using the EmailService interface, and
         * set our watchdog alarm
         *
         * @param serviceClass the class that will attempt the download
         * @param req the DownloadRequest
         * @throws RemoteException
         */
        private void startDownload(Intent intent, DownloadRequest req)
                throws RemoteException {
            req.startTime = System.currentTimeMillis();
            req.inProgress = true;
            mDownloadsInProgress.put(req.attachmentId, req);
            EmailServiceProxy proxy =
                new EmailServiceProxy(mContext, intent, mServiceCallback);
            proxy.loadAttachment(req.attachmentId, req.priority != PRIORITY_FOREGROUND);
            // Lazily initialize our (reusable) pending intent
            if (mWatchdogPendingIntent == null) {
                createWatchdogPendingIntent(mContext);
            }
            // Set the alarm
            mAlarmManager.setRepeating(AlarmManager.RTC_WAKEUP,
                    System.currentTimeMillis() + WATCHDOG_CHECK_INTERVAL, WATCHDOG_CHECK_INTERVAL,
                    mWatchdogPendingIntent);
        }

        /*package*/ void createWatchdogPendingIntent(Context context) {
            Intent alarmIntent = new Intent(context, Watchdog.class);
            mWatchdogPendingIntent = PendingIntent.getBroadcast(context, 0, alarmIntent, 0);
            mAlarmManager = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
        }

        private void cancelDownload(DownloadRequest req) {
            mDownloadsInProgress.remove(req.attachmentId);
            req.inProgress = false;
        }

        /**
         * Called when a download is finished; we get notified of this via our EmailServiceCallback
         * @param attachmentId the id of the attachment whose download is finished
         * @param statusCode the EmailServiceStatus code returned by the Service
         */
        /*package*/ synchronized void endDownload(long attachmentId, int statusCode) {
            // Say we're no longer downloading this
            mDownloadsInProgress.remove(attachmentId);

            // TODO: This code is conservative and treats connection issues as failures.
            // Since we have no mechanism to throttle reconnection attempts, it makes
            // sense to be cautious here. Once logic is in place to prevent connecting
            // in a tight loop, we can exclude counting connection issues as ""failures"".

            // Update the attachment failure list if needed
            Integer downloadCount;
            downloadCount = mAttachmentFailureMap.remove(attachmentId);
            if (statusCode != EmailServiceStatus.SUCCESS) {
                if (downloadCount == null) {
                    downloadCount = 0;
                }
                downloadCount += 1;
                mAttachmentFailureMap.put(attachmentId, downloadCount);
            }

            DownloadRequest req = mDownloadSet.findDownloadRequest(attachmentId);
            if (statusCode == EmailServiceStatus.CONNECTION_ERROR) {
                // If this needs to be retried, just process the queue again
                if (Email.DEBUG) {
                    Log.d(TAG, ""== The download for attachment #"" + attachmentId +
                            "" will be retried"");
                }
                if (req != null) {
                    req.inProgress = false;
                }
                kick();
                return;
            }

            // If the request is still in the queue, remove it
            if (req != null) {
                remove(req);
            }
            if (Email.DEBUG) {
                long secs = 0;
                if (req != null) {
                    secs = (System.currentTimeMillis() - req.time) / 1000;
                }
                String status = (statusCode == EmailServiceStatus.SUCCESS) ? ""Success"" :
                    ""Error "" + statusCode;
                Log.d(TAG, ""<< Download finished for attachment #"" + attachmentId + ""; "" + secs +
                           "" seconds from request, status: "" + status);
            }

            Attachment attachment = Attachment.restoreAttachmentWithId(mContext, attachmentId);
            if (attachment != null) {
                long accountId = attachment.mAccountKey;
                // Update our attachment storage for this account
                Long currentStorage = mAttachmentStorageMap.get(accountId);
                if (currentStorage == null) {
                    currentStorage = 0L;
                }
                mAttachmentStorageMap.put(accountId, currentStorage + attachment.mSize);
                boolean deleted = false;
                if ((attachment.mFlags & Attachment.FLAG_DOWNLOAD_FORWARD) != 0) {
                    if (statusCode == EmailServiceStatus.ATTACHMENT_NOT_FOUND) {
                        // If this is a forwarding download, and the attachment doesn't exist (or
                        // can't be downloaded) delete it from the outgoing message, lest that
                        // message never get sent
                        EmailContent.delete(mContext, Attachment.CONTENT_URI, attachment.mId);
                        // TODO: Talk to UX about whether this is even worth doing
                        NotificationController nc = NotificationController.getInstance(mContext);
                        nc.showDownloadForwardFailedNotification(attachment);
                        deleted = true;
                    }
                    // If we're an attachment on forwarded mail, and if we're not still blocked,
                    // try to send pending mail now (as mediated by MailService)
                    if ((req != null) &&
                            !Utility.hasUnloadedAttachments(mContext, attachment.mMessageKey)) {
                        if (Email.DEBUG) {
                            Log.d(TAG, ""== Downloads finished for outgoing msg #"" + req.messageId);
                        }
                        MailService.actionSendPendingMail(mContext, req.accountId);
                    }
                }
                if (statusCode == EmailServiceStatus.MESSAGE_NOT_FOUND) {
                    Message msg = Message.restoreMessageWithId(mContext, attachment.mMessageKey);
                    if (msg == null) {
                        // If there's no associated message, delete the attachment
                        EmailContent.delete(mContext, Attachment.CONTENT_URI, attachment.mId);
                    } else {
                        // If there really is a message, retry
                        kick();
                        return;
                    }
                } else if (!deleted) {
                    // Clear the download flags, since we're done for now.  Note that this happens
                    // only for non-recoverable errors.  When these occur for forwarded mail, we can
                    // ignore it and continue; otherwise, it was either 1) a user request, in which
                    // case the user can retry manually or 2) an opportunistic download, in which
                    // case the download wasn't critical
                    ContentValues cv = new ContentValues();
                    int flags =
                        Attachment.FLAG_DOWNLOAD_FORWARD | Attachment.FLAG_DOWNLOAD_USER_REQUEST;
                    cv.put(Attachment.FLAGS, attachment.mFlags &= ~flags);
                    attachment.update(mContext, cv);
                }
            }
            // Process the queue
            kick();
        }
    }

    /**
     * Calculate the download priority of an Attachment.  A priority of zero means that the
     * attachment is not marked for download.
     * @param att the Attachment
     * @return the priority key of the Attachment
     */
    private static int getPriority(Attachment att) {
        int priorityClass = PRIORITY_NONE;
        int flags = att.mFlags;
        if ((flags & Attachment.FLAG_DOWNLOAD_FORWARD) != 0) {
            priorityClass = PRIORITY_SEND_MAIL;
        } else if ((flags & Attachment.FLAG_DOWNLOAD_USER_REQUEST) != 0) {
            priorityClass = PRIORITY_FOREGROUND;
        }
        return priorityClass;
    }

    private void kick() {
        synchronized(mLock) {
            mLock.notify();
        }
    }

    /**
     * We use an EmailServiceCallback to keep track of the progress of downloads.  These callbacks
     * come from either Controller (IMAP) or ExchangeService (EAS).  Note that we only implement the
     * single callback that's defined by the EmailServiceCallback interface.
     */
    private class ServiceCallback extends IEmailServiceCallback.Stub {
        public void loadAttachmentStatus(long messageId, long attachmentId, int statusCode,
                int progress) {
            // Record status and progress
            DownloadRequest req = mDownloadSet.getDownloadInProgress(attachmentId);
            if (req != null) {
                if (Email.DEBUG) {
                    String code;
                    switch(statusCode) {
                        case EmailServiceStatus.SUCCESS: code = ""Success""; break;
                        case EmailServiceStatus.IN_PROGRESS: code = ""In progress""; break;
                        default: code = Integer.toString(statusCode); break;
                    }
                    if (statusCode != EmailServiceStatus.IN_PROGRESS) {
                        Log.d(TAG, "">> Attachment "" + attachmentId + "": "" + code);
                    } else if (progress >= (req.lastProgress + 15)) {
                        Log.d(TAG, "">> Attachment "" + attachmentId + "": "" + progress + ""%"");
                    }
                }
                req.lastStatusCode = statusCode;
                req.lastProgress = progress;
                req.lastCallbackTime = System.currentTimeMillis();
            }
            switch (statusCode) {
                case EmailServiceStatus.IN_PROGRESS:
                    break;
                default:
                    mDownloadSet.endDownload(attachmentId, statusCode);
                    break;
            }
        }

        @Override
        public void sendMessageStatus(long messageId, String subject, int statusCode, int progress)
                throws RemoteException {
        }

        @Override
        public void syncMailboxListStatus(long accountId, int statusCode, int progress)
                throws RemoteException {
        }

        @Override
        public void syncMailboxStatus(long mailboxId, int statusCode, int progress)
                throws RemoteException {
        }
    }

    /**
     * Return an Intent to be used used based on the account type of the provided account id.  We
     * cache the results to avoid repeated database access
     * @param accountId the id of the account
     * @return the Intent to be used for the account or null (if the account no longer exists)
     */
    private synchronized Intent getServiceIntentForAccount(long accountId) {
        // TODO: We should have some more data-driven way of determining the service intent.
        Intent serviceIntent = mAccountServiceMap.get(accountId);
        if (serviceIntent == null) {
            String protocol = Account.getProtocol(mContext, accountId);
            if (protocol == null) return null;
            serviceIntent = new Intent(mContext, ControllerService.class);
            if (protocol.equals(""eas"")) {
                serviceIntent = new Intent(EmailServiceProxy.EXCHANGE_INTENT);
            }
            mAccountServiceMap.put(accountId, serviceIntent);
        }
        return serviceIntent;
    }

    /*package*/ void addServiceIntentForTest(long accountId, Intent intent) {
        mAccountServiceMap.put(accountId, intent);
    }

    /*package*/ void onChange(Attachment att) {
        mDownloadSet.onChange(this, att);
    }

    /*package*/ boolean isQueued(long attachmentId) {
        return mDownloadSet.findDownloadRequest(attachmentId) != null;
    }

    /*package*/ int getSize() {
        return mDownloadSet.size();
    }

    /*package*/ boolean dequeue(long attachmentId) {
        DownloadRequest req = mDownloadSet.findDownloadRequest(attachmentId);
        if (req != null) {
            if (Email.DEBUG) {
                Log.d(TAG, ""Dequeued attachmentId:  "" + attachmentId);
            }
            mDownloadSet.remove(req);
            return true;
        }
        return false;
    }

    /**
     * Ask the service for the number of items in the download queue
     * @return the number of items queued for download
     */
    public static int getQueueSize() {
        AttachmentDownloadService service = sRunningService;
        if (service != null) {
            return service.getSize();
        }
        return 0;
    }

    /**
     * Ask the service whether a particular attachment is queued for download
     * @param attachmentId the id of the Attachment (as stored by EmailProvider)
     * @return whether or not the attachment is queued for download
     */
    public static boolean isAttachmentQueued(long attachmentId) {
        AttachmentDownloadService service = sRunningService;
        if (service != null) {
            return service.isQueued(attachmentId);
        }
        return false;
    }

    /**
     * Ask the service to remove an attachment from the download queue
     * @param attachmentId the id of the Attachment (as stored by EmailProvider)
     * @return whether or not the attachment was removed from the queue
     */
    public static boolean cancelQueuedAttachment(long attachmentId) {
        AttachmentDownloadService service = sRunningService;
        if (service != null) {
            return service.dequeue(attachmentId);
        }
        return false;
    }

    public static void watchdogAlarm() {
        AttachmentDownloadService service = sRunningService;
        if (service != null) {
            service.mDownloadSet.onWatchdogAlarm();
        }
    }

    /**
     * Called directly by EmailProvider whenever an attachment is inserted or changed
     * @param context the caller's context
     * @param id the attachment's id
     * @param flags the new flags for the attachment
     */
    public static void attachmentChanged(final Context context, final long id, final int flags) {
        Utility.runAsync(new Runnable() {
            public void run() {
                Attachment attachment = Attachment.restoreAttachmentWithId(context, id);
                if (attachment != null) {
                    // Store the flags we got from EmailProvider; given that all of this
                    // activity is asynchronous, we need to use the newest data from
                    // EmailProvider
                    attachment.mFlags = flags;
                    Intent intent = new Intent(context, AttachmentDownloadService.class);
                    intent.putExtra(EXTRA_ATTACHMENT, attachment);
                    context.startService(intent);
                }
            }});
    }

    /**
     * Determine whether an attachment can be prefetched for the given account
     * @return true if download is allowed, false otherwise
     */
    public boolean canPrefetchForAccount(Account account, File dir) {
        // Check account, just in case
        if (account == null) return false;
        // First, check preference and quickly return if prefetch isn't allowed
        if ((account.mFlags & Account.FLAGS_BACKGROUND_ATTACHMENTS) == 0) return false;

        long totalStorage = dir.getTotalSpace();
        long usableStorage = dir.getUsableSpace();
        long minAvailable = (long)(totalStorage * PREFETCH_MINIMUM_STORAGE_AVAILABLE);

        // If there's not enough overall storage available, stop now
        if (usableStorage < minAvailable) {
            return false;
        }

        int numberOfAccounts = mAccountManagerStub.getNumberOfAccounts();
        long perAccountMaxStorage =
            (long)(totalStorage * PREFETCH_MAXIMUM_ATTACHMENT_STORAGE / numberOfAccounts);

        // Retrieve our idea of currently used attachment storage; since we don't track deletions,
        // this number is the ""worst case"".  If the number is greater than what's allowed per
        // account, we walk the directory to determine the actual number
        Long accountStorage = mAttachmentStorageMap.get(account.mId);
        if (accountStorage == null || (accountStorage > perAccountMaxStorage)) {
            // Calculate the exact figure for attachment storage for this account
            accountStorage = 0L;
            File[] files = dir.listFiles();
            if (files != null) {
                for (File file : files) {
                    accountStorage += file.length();
                }
            }
            // Cache the value
            mAttachmentStorageMap.put(account.mId, accountStorage);
        }

        // Return true if we're using less than the maximum per account
        if (accountStorage < perAccountMaxStorage) {
            return true;
        } else {
            if (Email.DEBUG) {
                Log.d(TAG, "">> Prefetch not allowed for account "" + account.mId + ""; used "" +
                        accountStorage + "", limit "" + perAccountMaxStorage);
            }
            return false;
        }
    }

    public void run() {
        // These fields are only used within the service thread
        mContext = this;
        mConnectivityManager = new EmailConnectivityManager(this, TAG);
        mAccountManagerStub = new AccountManagerStub(this);

        // Run through all attachments in the database that require download and add them to
        // the queue
        int mask = Attachment.FLAG_DOWNLOAD_FORWARD | Attachment.FLAG_DOWNLOAD_USER_REQUEST;
        Cursor c = getContentResolver().query(Attachment.CONTENT_URI,
                EmailContent.ID_PROJECTION, ""("" + Attachment.FLAGS + "" & ?) != 0"",
                new String[] {Integer.toString(mask)}, null);
        try {
            Log.d(TAG, ""Count: "" + c.getCount());
            while (c.moveToNext()) {
                Attachment attachment = Attachment.restoreAttachmentWithId(
                        this, c.getLong(EmailContent.ID_PROJECTION_COLUMN));
                if (attachment != null) {
                    mDownloadSet.onChange(this, attachment);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        finally {
            c.close();
        }

        // Loop until stopped, with a 30 minute wait loop
        while (!mStop) {
            // Here's where we run our attachment loading logic...
            mConnectivityManager.waitForConnectivity();
            mDownloadSet.processQueue();
            if (mDownloadSet.isEmpty()) {
                Log.d(TAG, ""*** All done; shutting down service"");
                stopSelf();
                break;
            }
            synchronized(mLock) {
                try {
                    mLock.wait(PROCESS_QUEUE_WAIT_TIME);
                } catch (InterruptedException e) {
                    // That's ok; we'll just keep looping
                }
            }
        }

        // Unregister now that we're done
        if (mConnectivityManager != null) {
            mConnectivityManager.unregister();
        }
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (sRunningService == null) {
            sRunningService = this;
        }
        if (intent != null && intent.hasExtra(EXTRA_ATTACHMENT)) {
            Attachment att = (Attachment)intent.getParcelableExtra(EXTRA_ATTACHMENT);
            onChange(att);
        }
        return Service.START_STICKY;
    }

    @Override
    public void onCreate() {
        // Start up our service thread
        new Thread(this, ""AttachmentDownloadService"").start();
    }
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        // Mark this instance of the service as stopped
        mStop = true;
        if (sRunningService != null) {
            kick();
            sRunningService = null;
        }
        if (mConnectivityManager != null) {
            mConnectivityManager.unregister();
            mConnectivityManager = null;
        }
    }

    @Override
    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        pw.println(""AttachmentDownloadService"");
        long time = System.currentTimeMillis();
        synchronized(mDownloadSet) {
            pw.println(""  Queue, "" + mDownloadSet.size() + "" entries"");
            Iterator<DownloadRequest> iterator = mDownloadSet.descendingIterator();
            // First, start up any required downloads, in priority order
            while (iterator.hasNext()) {
                DownloadRequest req = iterator.next();
                pw.println(""    Account: "" + req.accountId + "", Attachment: "" + req.attachmentId);
                pw.println(""      Priority: "" + req.priority + "", Time: "" + req.time +
                        (req.inProgress ? "" [In progress]"" : """"));
                Attachment att = Attachment.restoreAttachmentWithId(this, req.attachmentId);
                if (att == null) {
                    pw.println(""      Attachment not in database?"");
                } else if (att.mFileName != null) {
                    String fileName = att.mFileName;
                    String suffix = ""[none]"";
                    int lastDot = fileName.lastIndexOf('.');
                    if (lastDot >= 0) {
                        suffix = fileName.substring(lastDot);
                    }
                    pw.print(""      Suffix: "" + suffix);
                    if (att.mContentUri != null) {
                        pw.print("" ContentUri: "" + att.mContentUri);
                    }
                    pw.print("" Mime: "");
                    if (att.mMimeType != null) {
                        pw.print(att.mMimeType);
                    } else {
                        pw.print(AttachmentUtilities.inferMimeType(fileName, null));
                        pw.print("" [inferred]"");
                    }
                    pw.println("" Size: "" + att.mSize);
                }
                if (req.inProgress) {
                    pw.println(""      Status: "" + req.lastStatusCode + "", Progress: "" +
                            req.lastProgress);
                    pw.println(""      Started: "" + req.startTime + "", Callback: "" +
                            req.lastCallbackTime);
                    pw.println(""      Elapsed: "" + ((time - req.startTime) / 1000L) + ""s"");
                    if (req.lastCallbackTime > 0) {
                        pw.println(""      CB: "" + ((time - req.lastCallbackTime) / 1000L) + ""s"");
                    }
                }
            }
        }
    }
}
",True,268,1,1,10,54,4,12,L6
108,com.android.email.service.MailService.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.accounts.AccountManager;
import android.accounts.AccountManagerCallback;
import android.app.AlarmManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.Context;
import android.content.Intent;
import android.content.SyncStatusObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.IBinder;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Log;

import com.android.email.Controller;
import com.android.email.Email;
import com.android.email.Preferences;
import com.android.email.SingleRunningTask;
import com.android.email.provider.AccountReconciler;
import com.android.emailcommon.AccountManagerTypes;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;
import com.google.common.annotations.VisibleForTesting;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Background service for refreshing non-push email accounts.
 *
 * TODO: Convert to IntentService to move *all* work off the UI thread, serialize work, and avoid
 * possible problems with out-of-order startId processing.
 */
public class MailService extends Service {
    private static final String LOG_TAG = ""Email-MailService"";

    private static final String ACTION_CHECK_MAIL =
        ""com.android.email.intent.action.MAIL_SERVICE_WAKEUP"";
    private static final String ACTION_RESCHEDULE =
        ""com.android.email.intent.action.MAIL_SERVICE_RESCHEDULE"";
    private static final String ACTION_CANCEL =
        ""com.android.email.intent.action.MAIL_SERVICE_CANCEL"";
    private static final String ACTION_SEND_PENDING_MAIL =
        ""com.android.email.intent.action.MAIL_SERVICE_SEND_PENDING"";
    private static final String ACTION_DELETE_EXCHANGE_ACCOUNTS =
        ""com.android.email.intent.action.MAIL_SERVICE_DELETE_EXCHANGE_ACCOUNTS"";

    private static final String EXTRA_ACCOUNT = ""com.android.email.intent.extra.ACCOUNT"";
    private static final String EXTRA_ACCOUNT_INFO = ""com.android.email.intent.extra.ACCOUNT_INFO"";
    private static final String EXTRA_DEBUG_WATCHDOG = ""com.android.email.intent.extra.WATCHDOG"";

    /** Time between watchdog checks; in milliseconds */
    private static final long WATCHDOG_DELAY = 10 * 60 * 1000;   // 10 minutes

    /** Sentinel value asking to update mSyncReports if it's currently empty */
    @VisibleForTesting
    static final int SYNC_REPORTS_ALL_ACCOUNTS_IF_EMPTY = -1;
    /** Sentinel value asking that mSyncReports be rebuilt */
    @VisibleForTesting
    static final int SYNC_REPORTS_RESET = -2;

    @VisibleForTesting
    Controller mController;
    private final Controller.Result mControllerCallback = new ControllerResults();
    private ContentResolver mContentResolver;
    private Context mContext;

    private int mStartId;

    /**
     * Access must be synchronized, because there are accesses from the Controller callback
     */
    /*package*/ static HashMap<Long,AccountSyncReport> mSyncReports =
        new HashMap<Long,AccountSyncReport>();

    public static void actionReschedule(Context context) {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_RESCHEDULE);
        context.startService(i);
    }

    public static void actionCancel(Context context)  {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_CANCEL);
        context.startService(i);
    }

    public static void actionDeleteExchangeAccounts(Context context)  {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_DELETE_EXCHANGE_ACCOUNTS);
        context.startService(i);
    }

    /**
     * Entry point for AttachmentDownloadService to ask that pending mail be sent
     * @param context the caller's context
     * @param accountId the account whose pending mail should be sent
     */
    public static void actionSendPendingMail(Context context, long accountId)  {
        Intent i = new Intent();
        i.setClass(context, MailService.class);
        i.setAction(MailService.ACTION_SEND_PENDING_MAIL);
        i.putExtra(MailService.EXTRA_ACCOUNT, accountId);
        context.startService(i);
    }

    @Override
    public int onStartCommand(final Intent intent, int flags, final int startId) {
        super.onStartCommand(intent, flags, startId);

        EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
            public void run() {
                reconcilePopImapAccountsSync(MailService.this);
            }
        });

        // TODO this needs to be passed through the controller and back to us
        mStartId = startId;
        String action = intent.getAction();
        final long accountId = intent.getLongExtra(EXTRA_ACCOUNT, -1);

        mController = Controller.getInstance(this);
        mController.addResultCallback(mControllerCallback);
        mContentResolver = getContentResolver();
        mContext = this;

        final AlarmManager alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);

        if (ACTION_CHECK_MAIL.equals(action)) {
            // DB access required to satisfy this intent, so offload from UI thread
            EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
                public void run() {
                    // If we have the data, restore the last-sync-times for each account
                    // These are cached in the wakeup intent in case the process was killed.
                    restoreSyncReports(intent);

                    // Sync a specific account if given
                    if (Email.DEBUG) {
                        Log.d(LOG_TAG, ""action: check mail for id="" + accountId);
                    }
                    if (accountId >= 0) {
                        setWatchdog(accountId, alarmManager);
                    }

                    // Start sync if account is given && auto-sync is allowed
                    boolean syncStarted = false;
                    if (accountId != -1 && ContentResolver.getMasterSyncAutomatically()) {
                        synchronized(mSyncReports) {
                            for (AccountSyncReport report: mSyncReports.values()) {
                                if (report.accountId == accountId) {
                                    if (report.syncEnabled) {
                                        syncStarted = syncOneAccount(mController, accountId,
                                                startId);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Reschedule if we didn't start sync.
                    if (!syncStarted) {
                        // Prevent runaway on the current account by pretending it updated
                        if (accountId != -1) {
                            updateAccountReport(accountId, 0);
                        }
                        // Find next account to sync, and reschedule
                        reschedule(alarmManager);
                        // Stop the service, unless actually syncing (which will stop the service)
                        stopSelf(startId);
                    }
                }
            });
        }
        else if (ACTION_CANCEL.equals(action)) {
            if (Email.DEBUG) {
                Log.d(LOG_TAG, ""action: cancel"");
            }
            cancel();
            stopSelf(startId);
        }
        else if (ACTION_DELETE_EXCHANGE_ACCOUNTS.equals(action)) {
            if (Email.DEBUG) {
                Log.d(LOG_TAG, ""action: delete exchange accounts"");
            }
            EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
                public void run() {
                    Cursor c = mContentResolver.query(Account.CONTENT_URI, Account.ID_PROJECTION,
                            null, null, null);
                    try {
                        while (c.moveToNext()) {
                            long accountId = c.getLong(Account.ID_PROJECTION_COLUMN);
                            if (""eas"".equals(Account.getProtocol(mContext, accountId))) {
                                // Always log this
                                Log.d(LOG_TAG, ""Deleting EAS account: "" + accountId);
                                mController.deleteAccountSync(accountId, mContext);
                            }
                       }
                    } finally {
                        c.close();
                    }
                }
            });
            stopSelf(startId);
        }
        else if (ACTION_SEND_PENDING_MAIL.equals(action)) {
            if (Email.DEBUG) {
                Log.d(LOG_TAG, ""action: send pending mail"");
            }
            EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
                public void run() {
                    mController.sendPendingMessages(accountId);
                }
            });
            stopSelf(startId);
        }
        else if (ACTION_RESCHEDULE.equals(action)) {
            if (Email.DEBUG) {
                Log.d(LOG_TAG, ""action: reschedule"");
            }
            // DB access required to satisfy this intent, so offload from UI thread
            EmailAsyncTask.runAsyncParallel(new Runnable() {
                @Override
                public void run() {
                    // When called externally, we refresh the sync reports table to pick up
                    // any changes in the account list or account settings
                    refreshSyncReports();
                    // Finally, scan for the next needing update, and set an alarm for it
                    reschedule(alarmManager);
                    stopSelf(startId);
                }
            });
        }

        // Returning START_NOT_STICKY means that if a mail check is killed (e.g. due to memory
        // pressure, there will be no explicit restart.  This is OK;  Note that we set a watchdog
        // alarm before each mailbox check.  If the mailbox check never completes, the watchdog
        // will fire and get things running again.
        return START_NOT_STICKY;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        Controller.getInstance(getApplication()).removeResultCallback(mControllerCallback);
    }

    private void cancel() {
        AlarmManager alarmMgr = (AlarmManager)getSystemService(Context.ALARM_SERVICE);
        PendingIntent pi = createAlarmIntent(-1, null, false);
        alarmMgr.cancel(pi);
    }

    /**
     * Refresh the sync reports, to pick up any changes in the account list or account settings.
     */
    private void refreshSyncReports() {
        synchronized (mSyncReports) {
            // Make shallow copy of sync reports so we can recover the prev sync times
            HashMap<Long,AccountSyncReport> oldSyncReports =
                new HashMap<Long,AccountSyncReport>(mSyncReports);

            // Delete the sync reports to force a refresh from live account db data
            setupSyncReportsLocked(SYNC_REPORTS_RESET, this);

            // Restore prev-sync & next-sync times for any reports in the new list
            for (AccountSyncReport newReport : mSyncReports.values()) {
                AccountSyncReport oldReport = oldSyncReports.get(newReport.accountId);
                if (oldReport != null) {
                    newReport.prevSyncTime = oldReport.prevSyncTime;
                    newReport.setNextSyncTime();
                }
            }
        }
    }

    /**
     * Create and send an alarm with the entire list.  This also sends a list of known last-sync
     * times with the alarm, so if we are killed between alarms, we don't lose this info.
     *
     * @param alarmMgr passed in so we can mock for testing.
     */
    private void reschedule(AlarmManager alarmMgr) {
        // restore the reports if lost
        setupSyncReports(SYNC_REPORTS_ALL_ACCOUNTS_IF_EMPTY);
        synchronized (mSyncReports) {
            int numAccounts = mSyncReports.size();
            long[] accountInfo = new long[numAccounts * 2];     // pairs of { accountId, lastSync }
            int accountInfoIndex = 0;

            long nextCheckTime = Long.MAX_VALUE;
            AccountSyncReport nextAccount = null;
            long timeNow = SystemClock.elapsedRealtime();

            for (AccountSyncReport report : mSyncReports.values()) {
                if (report.syncInterval <= 0) {                         // no timed checks - skip
                    continue;
                }
                long prevSyncTime = report.prevSyncTime;
                long nextSyncTime = report.nextSyncTime;

                // select next account to sync
                if ((prevSyncTime == 0) || (nextSyncTime < timeNow)) {  // never checked, or overdue
                    nextCheckTime = 0;
                    nextAccount = report;
                } else if (nextSyncTime < nextCheckTime) {              // next to be checked
                    nextCheckTime = nextSyncTime;
                    nextAccount = report;
                }
                // collect last-sync-times for all accounts
                // this is using pairs of {long,long} to simplify passing in a bundle
                accountInfo[accountInfoIndex++] = report.accountId;
                accountInfo[accountInfoIndex++] = report.prevSyncTime;
            }

            // Clear out any unused elements in the array
            while (accountInfoIndex < accountInfo.length) {
                accountInfo[accountInfoIndex++] = -1;
            }

            // set/clear alarm as needed
            long idToCheck = (nextAccount == null) ? -1 : nextAccount.accountId;
            PendingIntent pi = createAlarmIntent(idToCheck, accountInfo, false);

            if (nextAccount == null) {
                alarmMgr.cancel(pi);
                if (Email.DEBUG) {
                    Log.d(LOG_TAG, ""reschedule: alarm cancel - no account to check"");
                }
            } else {
                alarmMgr.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, nextCheckTime, pi);
                if (Email.DEBUG) {
                    Log.d(LOG_TAG, ""reschedule: alarm set at "" + nextCheckTime
                            + "" for "" + nextAccount);
                }
            }
        }
    }

    /**
     * Create a watchdog alarm and set it.  This is used in case a mail check fails (e.g. we are
     * killed by the system due to memory pressure.)  Normally, a mail check will complete and
     * the watchdog will be replaced by the call to reschedule().
    * @param accountId the account we were trying to check
     * @param alarmMgr system alarm manager
     */
    private void setWatchdog(long accountId, AlarmManager alarmMgr) {
        PendingIntent pi = createAlarmIntent(accountId, null, true);
        long timeNow = SystemClock.elapsedRealtime();
        long nextCheckTime = timeNow + WATCHDOG_DELAY;
        alarmMgr.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, nextCheckTime, pi);
    }

    /**
     * Return a pending intent for use by this alarm.  Most of the fields must be the same
     * (in order for the intent to be recognized by the alarm manager) but the extras can
     * be different, and are passed in here as parameters.
     */
    private PendingIntent createAlarmIntent(long checkId, long[] accountInfo, boolean isWatchdog) {
        Intent i = new Intent();
        i.setClass(this, MailService.class);
        i.setAction(ACTION_CHECK_MAIL);
        i.putExtra(EXTRA_ACCOUNT, checkId);
        i.putExtra(EXTRA_ACCOUNT_INFO, accountInfo);
        if (isWatchdog) {
            i.putExtra(EXTRA_DEBUG_WATCHDOG, true);
        }
        PendingIntent pi = PendingIntent.getService(this, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
        return pi;
    }

    /**
     * Start a controller sync for a specific account
     *
     * @param controller The controller to do the sync work
     * @param checkAccountId the account Id to try and check
     * @param startId the id of this service launch
     * @return true if mail checking has started, false if it could not (e.g. bad account id)
     */
    private boolean syncOneAccount(Controller controller, long checkAccountId, int startId) {
        long inboxId = Mailbox.findMailboxOfType(this, checkAccountId, Mailbox.TYPE_INBOX);
        if (inboxId == Mailbox.NO_MAILBOX) {
            return false;
        } else {
            controller.serviceCheckMail(checkAccountId, inboxId, startId);
            return true;
        }
    }

    /**
     * Note:  Times are relative to SystemClock.elapsedRealtime()
     *
     * TODO:  Look more closely at syncEnabled and see if we can simply coalesce it into
     * syncInterval (e.g. if !syncEnabled, set syncInterval to -1).
     */
    @VisibleForTesting
    static class AccountSyncReport {
        long accountId;
        /** The time of the last sync, or, {@code 0}, the last sync time is unknown. */
        long prevSyncTime;
        /** The time of the next sync. If {@code 0}, sync ASAP. If {@code 1}, don't sync. */
        long nextSyncTime;
        /** Minimum time between syncs; in minutes. */
        int syncInterval;
        /** If {@code true}, auto sync is enabled. */
        boolean syncEnabled;

        /**
         * Sets the next sync time using the previous sync time and sync interval.
         */
        private void setNextSyncTime() {
            if (syncInterval > 0 && prevSyncTime != 0) {
                nextSyncTime = prevSyncTime + (syncInterval * 1000 * 60);
            }
        }

        @Override
        public String toString() {
            return ""id="" + accountId + "" prevSync="" + prevSyncTime + "" nextSync="" + nextSyncTime;
        }
    }

    /**
     * scan accounts to create a list of { acct, prev sync, next sync, #new }
     * use this to create a fresh copy.  assumes all accounts need sync
     *
     * @param accountId -1 will rebuild the list if empty.  other values will force loading
     *   of a single account (e.g if it was created after the original list population)
     */
    private void setupSyncReports(long accountId) {
        synchronized (mSyncReports) {
            setupSyncReportsLocked(accountId, mContext);
        }
    }

    /**
     * Handle the work of setupSyncReports.  Must be synchronized on mSyncReports.
     */
    @VisibleForTesting
    void setupSyncReportsLocked(long accountId, Context context) {
        ContentResolver resolver = context.getContentResolver();
        if (accountId == SYNC_REPORTS_RESET) {
            // For test purposes, force refresh of mSyncReports
            mSyncReports.clear();
            accountId = SYNC_REPORTS_ALL_ACCOUNTS_IF_EMPTY;
        } else if (accountId == SYNC_REPORTS_ALL_ACCOUNTS_IF_EMPTY) {
            // -1 == reload the list if empty, otherwise exit immediately
            if (mSyncReports.size() > 0) {
                return;
            }
        } else {
            // load a single account if it doesn't already have a sync record
            if (mSyncReports.containsKey(accountId)) {
                return;
            }
        }

        // setup to add a single account or all accounts
        Uri uri;
        if (accountId == SYNC_REPORTS_ALL_ACCOUNTS_IF_EMPTY) {
            uri = Account.CONTENT_URI;
        } else {
            uri = ContentUris.withAppendedId(Account.CONTENT_URI, accountId);
        }

        final boolean oneMinuteRefresh
                = Preferences.getPreferences(this).getForceOneMinuteRefresh();
        if (oneMinuteRefresh) {
            Log.w(LOG_TAG, ""One-minute refresh enabled."");
        }

        // We use a full projection here because we'll restore each account object from it
        Cursor c = resolver.query(uri, Account.CONTENT_PROJECTION, null, null, null);
        try {
            while (c.moveToNext()) {
                Account account = Account.getContent(c, Account.class);
                // The following sanity checks are primarily for the sake of ignoring non-user
                // accounts that may have been left behind e.g. by failed unit tests.
                // Properly-formed accounts will always pass these simple checks.
                if (TextUtils.isEmpty(account.mEmailAddress)
                        || account.mHostAuthKeyRecv <= 0
                        || account.mHostAuthKeySend <= 0) {
                    continue;
                }

                // The account is OK, so proceed
                AccountSyncReport report = new AccountSyncReport();
                int syncInterval = account.mSyncInterval;

                // If we're not using MessagingController (EAS at this point), don't schedule syncs
                if (!mController.isMessagingController(account.mId)) {
                    syncInterval = Account.CHECK_INTERVAL_NEVER;
                } else if (oneMinuteRefresh && syncInterval >= 0) {
                    syncInterval = 1;
                }

                report.accountId = account.mId;
                report.prevSyncTime = 0;
                report.nextSyncTime = (syncInterval > 0) ? 0 : -1;  // 0 == ASAP -1 == no sync

                report.syncInterval = syncInterval;

                // See if the account is enabled for sync in AccountManager
                android.accounts.Account accountManagerAccount =
                    new android.accounts.Account(account.mEmailAddress,
                            AccountManagerTypes.TYPE_POP_IMAP);
                report.syncEnabled = ContentResolver.getSyncAutomatically(accountManagerAccount,
                        EmailContent.AUTHORITY);

                // TODO lookup # new in inbox
                mSyncReports.put(report.accountId, report);
            }
        } finally {
            c.close();
        }
    }

    /**
     * Update list with a single account's sync times and unread count
     *
     * @param accountId the account being updated
     * @param newCount the number of new messages, or -1 if not being reported (don't update)
     * @return the report for the updated account, or null if it doesn't exist (e.g. deleted)
     */
    private AccountSyncReport updateAccountReport(long accountId, int newCount) {
        // restore the reports if lost
        setupSyncReports(accountId);
        synchronized (mSyncReports) {
            AccountSyncReport report = mSyncReports.get(accountId);
            if (report == null) {
                // discard result - there is no longer an account with this id
                Log.d(LOG_TAG, ""No account to update for id="" + Long.toString(accountId));
                return null;
            }

            // report found - update it (note - editing the report while in-place in the hashmap)
            report.prevSyncTime = SystemClock.elapsedRealtime();
            report.setNextSyncTime();
            if (Email.DEBUG) {
                Log.d(LOG_TAG, ""update account "" + report.toString());
            }
            return report;
        }
    }

    /**
     * when we receive an alarm, update the account sync reports list if necessary
     * this will be the case when if we have restarted the process and lost the data
     * in the global.
     *
     * @param restoreIntent the intent with the list
     */
    private void restoreSyncReports(Intent restoreIntent) {
        // restore the reports if lost
        setupSyncReports(SYNC_REPORTS_ALL_ACCOUNTS_IF_EMPTY);
        synchronized (mSyncReports) {
            long[] accountInfo = restoreIntent.getLongArrayExtra(EXTRA_ACCOUNT_INFO);
            if (accountInfo == null) {
                Log.d(LOG_TAG, ""no data in intent to restore"");
                return;
            }
            int accountInfoIndex = 0;
            int accountInfoLimit = accountInfo.length;
            while (accountInfoIndex < accountInfoLimit) {
                long accountId = accountInfo[accountInfoIndex++];
                long prevSync = accountInfo[accountInfoIndex++];
                AccountSyncReport report = mSyncReports.get(accountId);
                if (report != null) {
                    if (report.prevSyncTime == 0) {
                        report.prevSyncTime = prevSync;
                        report.setNextSyncTime();
                    }
                }
            }
        }
    }

    class ControllerResults extends Controller.Result {
        @Override
        public void updateMailboxCallback(MessagingException result, long accountId,
                long mailboxId, int progress, int numNewMessages,
                ArrayList<Long> addedMessages) {
            // First, look for authentication failures and notify
           //checkAuthenticationStatus(result, accountId);
           if (result != null || progress == 100) {
                // We only track the inbox here in the service - ignore other mailboxes
                long inboxId = Mailbox.findMailboxOfType(MailService.this,
                        accountId, Mailbox.TYPE_INBOX);
                if (mailboxId == inboxId) {
                    if (progress == 100) {
                        updateAccountReport(accountId, numNewMessages);
                    } else {
                        updateAccountReport(accountId, -1);
                    }
                }
            }
        }

        @Override
        public void serviceCheckMailCallback(MessagingException result, long accountId,
                long mailboxId, int progress, long tag) {
            if (result != null || progress == 100) {
                if (result != null) {
                    // the checkmail ended in an error.  force an update of the refresh
                    // time, so we don't just spin on this account
                    updateAccountReport(accountId, -1);
                }
                AlarmManager alarmManager = (AlarmManager)getSystemService(Context.ALARM_SERVICE);
                reschedule(alarmManager);
                int serviceId = mStartId;
                if (tag != 0) {
                    serviceId = (int) tag;
                }
                stopSelf(serviceId);
            }
        }
    }

    public class EmailSyncStatusObserver implements SyncStatusObserver {
        @Override
        public void onStatusChanged(int which) {
            // We ignore the argument (we can only get called in one case - when settings change)
        }
    }

    public static ArrayList<Account> getPopImapAccountList(Context context) {
        ArrayList<Account> providerAccounts = new ArrayList<Account>();
        Cursor c = context.getContentResolver().query(Account.CONTENT_URI, Account.ID_PROJECTION,
                null, null, null);
        try {
            while (c.moveToNext()) {
                long accountId = c.getLong(Account.CONTENT_ID_COLUMN);
                String protocol = Account.getProtocol(context, accountId);
                if ((protocol != null) && (""pop3"".equals(protocol) || ""imap"".equals(protocol))) {
                    Account account = Account.restoreAccountWithId(context, accountId);
                    if (account != null) {
                        providerAccounts.add(account);
                    }
                }
            }
        } finally {
            c.close();
        }
        return providerAccounts;
    }

    private static final SingleRunningTask<Context> sReconcilePopImapAccountsSyncExecutor =
            new SingleRunningTask<Context>(""ReconcilePopImapAccountsSync"") {
                @Override
                protected void runInternal(Context context) {
                    android.accounts.Account[] accountManagerAccounts = AccountManager.get(context)
                            .getAccountsByType(AccountManagerTypes.TYPE_POP_IMAP);
                    ArrayList<Account> providerAccounts = getPopImapAccountList(context);
                    MailService.reconcileAccountsWithAccountManager(context, providerAccounts,
                            accountManagerAccounts, context);

                }
    };

    /**
     * Reconcile POP/IMAP accounts.
     */
    public static void reconcilePopImapAccountsSync(Context context) {
        sReconcilePopImapAccountsSyncExecutor.run(context);
    }

    /**
     * Determines whether or not POP/IMAP accounts need reconciling or not. This is a safe operation
     * to perform on the UI thread.
     */
    public static boolean hasMismatchInPopImapAccounts(Context context) {
        android.accounts.Account[] accountManagerAccounts = AccountManager.get(context)
                .getAccountsByType(AccountManagerTypes.TYPE_POP_IMAP);
        ArrayList<Account> providerAccounts = getPopImapAccountList(context);
        return AccountReconciler.accountsNeedReconciling(
                context, providerAccounts, accountManagerAccounts);
    }

    /**
     * See Utility.reconcileAccounts for details
     * @param context The context in which to operate
     * @param emailProviderAccounts the exchange provider accounts to work from
     * @param accountManagerAccounts The account manager accounts to work from
     * @param providerContext the provider's context (in unit tests, this may differ from context)
     */
    @VisibleForTesting
    public static void reconcileAccountsWithAccountManager(Context context,
            List<Account> emailProviderAccounts, android.accounts.Account[] accountManagerAccounts,
            Context providerContext) {
        AccountReconciler.reconcileAccounts(context, emailProviderAccounts, accountManagerAccounts,
                providerContext);
    }

    public static void setupAccountManagerAccount(Context context, Account account,
            boolean email, boolean calendar, boolean contacts,
            AccountManagerCallback<Bundle> callback) {
        Bundle options = new Bundle();
        HostAuth hostAuthRecv = HostAuth.restoreHostAuthWithId(context, account.mHostAuthKeyRecv);
        if (hostAuthRecv == null) return;
        // Set up username/password
        options.putString(EasAuthenticatorService.OPTIONS_USERNAME, account.mEmailAddress);
        options.putString(EasAuthenticatorService.OPTIONS_PASSWORD, hostAuthRecv.mPassword);
        options.putBoolean(EasAuthenticatorService.OPTIONS_CONTACTS_SYNC_ENABLED, contacts);
        options.putBoolean(EasAuthenticatorService.OPTIONS_CALENDAR_SYNC_ENABLED, calendar);
        options.putBoolean(EasAuthenticatorService.OPTIONS_EMAIL_SYNC_ENABLED, email);
        String accountType = hostAuthRecv.mProtocol.equals(""eas"") ?
                AccountManagerTypes.TYPE_EXCHANGE :
                AccountManagerTypes.TYPE_POP_IMAP;
        AccountManager.get(context).addAccount(accountType, null, null, options, null, callback,
                null);
    }
}
",False,268,1,1,10,57,8,13,L6
109,com.android.email.service.PopImapAuthenticatorService.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import com.android.email.activity.setup.AccountSetupBasics;
import com.android.emailcommon.AccountManagerTypes;
import com.android.emailcommon.CalendarProviderStub;
import com.android.emailcommon.provider.EmailContent;

import android.accounts.AbstractAccountAuthenticator;
import android.accounts.Account;
import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.accounts.NetworkErrorException;
import android.app.Service;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;
import android.provider.ContactsContract;

/**
 * A very basic authenticator service for POP/IMAP.  At the moment, it has no UI hooks.  When called
 * with addAccount, it simply adds the account to AccountManager directly with a username and
 * password.
 */
public class PopImapAuthenticatorService extends Service {
    public static final String OPTIONS_USERNAME = ""username"";
    public static final String OPTIONS_PASSWORD = ""password"";
    public static final String OPTIONS_CONTACTS_SYNC_ENABLED = ""contacts"";
    public static final String OPTIONS_CALENDAR_SYNC_ENABLED = ""calendar"";
    public static final String OPTIONS_EMAIL_SYNC_ENABLED = ""email"";

    class PopImapAuthenticator extends AbstractAccountAuthenticator {

        public PopImapAuthenticator(Context context) {
            super(context);
        }

        @Override
        public Bundle addAccount(AccountAuthenticatorResponse response, String accountType,
                String authTokenType, String[] requiredFeatures, Bundle options)
                throws NetworkErrorException {
            // There are two cases here:
            // 1) We are called with a username/password; this comes from the traditional email
            //    app UI; we simply create the account and return the proper bundle
            if (options != null && options.containsKey(OPTIONS_PASSWORD)
                    && options.containsKey(OPTIONS_USERNAME)) {
                final Account account = new Account(options.getString(OPTIONS_USERNAME),
                        AccountManagerTypes.TYPE_POP_IMAP);
                AccountManager.get(PopImapAuthenticatorService.this).addAccountExplicitly(
                            account, options.getString(OPTIONS_PASSWORD), null);

                // Set up email syncing
                boolean syncEmail = false;
                if (options.containsKey(OPTIONS_EMAIL_SYNC_ENABLED) &&
                        options.getBoolean(OPTIONS_EMAIL_SYNC_ENABLED)) {
                    syncEmail = true;
                }
                ContentResolver.setIsSyncable(account, EmailContent.AUTHORITY, 1);
                ContentResolver.setSyncAutomatically(account, EmailContent.AUTHORITY, syncEmail);
                ContentResolver.setIsSyncable(account, ContactsContract.AUTHORITY, 0);
                ContentResolver.setIsSyncable(account, CalendarProviderStub.AUTHORITY, 0);

                Bundle b = new Bundle();
                b.putString(AccountManager.KEY_ACCOUNT_NAME, options.getString(OPTIONS_USERNAME));
                b.putString(AccountManager.KEY_ACCOUNT_TYPE, AccountManagerTypes.TYPE_POP_IMAP);
                return b;
            // 2) The other case is that we're creating a new account from an Account manager
            //    activity.  In this case, we add an intent that will be used to gather the
            //    account information...
            } else {
                Bundle b = new Bundle();
                Intent intent =
                    AccountSetupBasics.actionSetupPopImapIntent(PopImapAuthenticatorService.this);
                intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
                b.putParcelable(AccountManager.KEY_INTENT, intent);
                return b;
            }
        }

        @Override
        public Bundle confirmCredentials(AccountAuthenticatorResponse response, Account account,
                Bundle options) {
            return null;
        }

        @Override
        public Bundle editProperties(AccountAuthenticatorResponse response, String accountType) {
            return null;
        }

        @Override
        public Bundle getAuthToken(AccountAuthenticatorResponse response, Account account,
                String authTokenType, Bundle loginOptions) throws NetworkErrorException {
            return null;
        }

        @Override
        public String getAuthTokenLabel(String authTokenType) {
            // null means we don't have compartmentalized authtoken types
            return null;
        }

        @Override
        public Bundle hasFeatures(AccountAuthenticatorResponse response, Account account,
                String[] features) throws NetworkErrorException {
            return null;
        }

        @Override
        public Bundle updateCredentials(AccountAuthenticatorResponse response, Account account,
                String authTokenType, Bundle loginOptions) {
            return null;
        }

    }

    @Override
    public IBinder onBind(Intent intent) {
        if (AccountManager.ACTION_AUTHENTICATOR_INTENT.equals(intent.getAction())) {
            return new PopImapAuthenticator(this).getIBinder();
        } else {
            return null;
        }
    }
}
",True,268,0,0,12,61,0,4,L8
110,com.android.email.service.PopImapSyncAdapterService.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.accounts.Account;
import android.accounts.OperationCanceledException;
import android.app.Service;
import android.content.AbstractThreadedSyncAdapter;
import android.content.ContentProviderClient;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.SyncResult;
import android.database.Cursor;
import android.os.Bundle;
import android.os.IBinder;
import android.util.Log;

import com.android.email.Controller;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.AccountColumns;
import com.android.emailcommon.provider.Mailbox;

public class PopImapSyncAdapterService extends Service {
    private static final String TAG = ""PopImapSyncAdapterService"";
    private static SyncAdapterImpl sSyncAdapter = null;
    private static final Object sSyncAdapterLock = new Object();

    public PopImapSyncAdapterService() {
        super();
    }

    private static class SyncAdapterImpl extends AbstractThreadedSyncAdapter {
        private Context mContext;

        public SyncAdapterImpl(Context context) {
            super(context, true /* autoInitialize */);
            mContext = context;
        }

        @Override
        public void onPerformSync(Account account, Bundle extras,
                String authority, ContentProviderClient provider, SyncResult syncResult) {
            try {
                PopImapSyncAdapterService.performSync(mContext, account, extras,
                        authority, provider, syncResult);
            } catch (OperationCanceledException e) {
            }
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
        synchronized (sSyncAdapterLock) {
            if (sSyncAdapter == null) {
                sSyncAdapter = new SyncAdapterImpl(getApplicationContext());
            }
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return sSyncAdapter.getSyncAdapterBinder();
    }

    /**
     * Partial integration with system SyncManager; we initiate manual syncs upon request
     */
    private static void performSync(Context context, Account account, Bundle extras,
            String authority, ContentProviderClient provider, SyncResult syncResult)
            throws OperationCanceledException {
        if (extras.getBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, false)) {
            String emailAddress = account.name;
            // Find an EmailProvider account with the Account's email address
            Cursor c = context.getContentResolver().query(
                    com.android.emailcommon.provider.Account.CONTENT_URI,
                    EmailContent.ID_PROJECTION, AccountColumns.EMAIL_ADDRESS + ""=?"",
                    new String[] {emailAddress}, null);
            if (c.moveToNext()) {
                // If we have one, find the inbox and start it syncing
                long accountId = c.getLong(EmailContent.ID_PROJECTION_COLUMN);
                long mailboxId = Mailbox.findMailboxOfType(context, accountId,
                        Mailbox.TYPE_INBOX);
                if (mailboxId > 0) {
                    Log.d(TAG, ""Starting manual sync for account "" + emailAddress);
                    Controller.getInstance(context).updateMailbox(accountId, mailboxId, false);
                }
            }
        }
    }
}",True,268,0,0,10,49,0,4,L8
111,com.android.email.service.AccountService.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.accounts.AccountManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.database.Cursor;
import android.os.Bundle;
import android.os.IBinder;

import com.android.email.Email;
import com.android.email.NotificationController;
import com.android.email.ResourceHelper;
import com.android.email.VendorPolicyLoader;
import com.android.email.provider.AccountReconciler;
import com.android.emailcommon.Configuration;
import com.android.emailcommon.Device;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.service.IAccountService;
import com.android.emailcommon.utility.EmailAsyncTask;

import java.io.IOException;
import java.util.ArrayList;

public class AccountService extends Service {

    // Save context
    private Context mContext;

    private final IAccountService.Stub mBinder = new IAccountService.Stub() {

        @Override
        public void notifyLoginFailed(long accountId) {
            NotificationController.getInstance(mContext).showLoginFailedNotification(accountId);
        }

        @Override
        public void notifyLoginSucceeded(long accountId) {
            NotificationController.getInstance(mContext).cancelLoginFailedNotification(accountId);
        }

        private ArrayList<Account> getAccountList(String forProtocol) {
            ArrayList<Account> providerAccounts = new ArrayList<Account>();
            Cursor c = mContext.getContentResolver().query(Account.CONTENT_URI,
                    Account.ID_PROJECTION, null, null, null);
            try {
                while (c.moveToNext()) {
                    long accountId = c.getLong(Account.CONTENT_ID_COLUMN);
                    String protocol = Account.getProtocol(mContext, accountId);
                    if ((protocol != null) && forProtocol.equals(protocol)) {
                        Account account = Account.restoreAccountWithId(mContext, accountId);
                        if (account != null) {
                            providerAccounts.add(account);
                        }
                    }
                }
            } finally {
                c.close();
            }
            return providerAccounts;
        }

        @Override
        public void reconcileAccounts(String protocol, String accountManagerType) {
            ArrayList<Account> providerList = getAccountList(protocol);
            android.accounts.Account[] accountMgrList =
                AccountManager.get(mContext).getAccountsByType(accountManagerType);
            AccountReconciler.reconcileAccounts(mContext, providerList, accountMgrList, mContext);
        }

        @Override
        public int getAccountColor(long accountId) {
            return ResourceHelper.getInstance(mContext).getAccountColor(accountId);
        }

        @Override
        public Bundle getConfigurationData(String accountType) {
            Bundle bundle = new Bundle();
            bundle.putBoolean(Configuration.EXCHANGE_CONFIGURATION_USE_ALTERNATE_STRINGS,
                    VendorPolicyLoader.getInstance(mContext).useAlternateExchangeStrings());
            return bundle;
        }

        @Override
        public String getDeviceId() {
            try {
                EmailAsyncTask.runAsyncSerial(new Runnable() {
                    @Override
                    public void run() {
                        // Make sure the service is properly running (re: lifecycle)
                        EmailServiceUtils.startExchangeService(mContext);
                        // Send current logging flags
                        Email.updateLoggingFlags(mContext);
                    }});
                return Device.getDeviceId(mContext);
            } catch (IOException e) {
                return null;
            }
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        if (mContext == null) {
            mContext = this;
        }
        // Make sure we have a valid deviceId (just retrieves a static String except first time)
        try {
            Device.getDeviceId(this);
        } catch (IOException e) {
        }
        return mBinder;
    }
}",True,269,0,0,11,50,0,10,L8
112,com.android.email.service.EasAuthenticatorService.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import com.android.email.activity.setup.AccountSetupBasics;
import com.android.emailcommon.AccountManagerTypes;
import com.android.emailcommon.CalendarProviderStub;
import com.android.emailcommon.provider.EmailContent;

import android.accounts.AbstractAccountAuthenticator;
import android.accounts.Account;
import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.accounts.NetworkErrorException;
import android.app.Service;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;
import android.provider.ContactsContract;

/**
 * A very basic authenticator service for EAS.  At the moment, it has no UI hooks.  When called
 * with addAccount, it simply adds the account to AccountManager directly with a username and
 * password.
 */
public class EasAuthenticatorService extends Service {
    public static final String OPTIONS_USERNAME = ""username"";
    public static final String OPTIONS_PASSWORD = ""password"";
    public static final String OPTIONS_CONTACTS_SYNC_ENABLED = ""contacts"";
    public static final String OPTIONS_CALENDAR_SYNC_ENABLED = ""calendar"";
    public static final String OPTIONS_EMAIL_SYNC_ENABLED = ""email"";

    class EasAuthenticator extends AbstractAccountAuthenticator {
        private Context mContext;

        public EasAuthenticator(Context context) {
            super(context);
            mContext = context;
        }

        @Override
        public Bundle addAccount(AccountAuthenticatorResponse response, String accountType,
                String authTokenType, String[] requiredFeatures, Bundle options)
                throws NetworkErrorException {
            // There are two cases here:
            // 1) We are called with a username/password; this comes from the traditional email
            //    app UI; we simply create the account and return the proper bundle
            if (options != null && options.containsKey(OPTIONS_PASSWORD)
                    && options.containsKey(OPTIONS_USERNAME)) {
                final Account account = new Account(options.getString(OPTIONS_USERNAME),
                        AccountManagerTypes.TYPE_EXCHANGE);
                AccountManager.get(EasAuthenticatorService.this).addAccountExplicitly(
                            account, options.getString(OPTIONS_PASSWORD), null);

                // Set up contacts syncing.  ExchangeService will use info from ContentResolver
                // to determine syncability of Contacts for Exchange
                boolean syncContacts = false;
                if (options.containsKey(OPTIONS_CONTACTS_SYNC_ENABLED) &&
                        options.getBoolean(OPTIONS_CONTACTS_SYNC_ENABLED)) {
                    syncContacts = true;
                }
                ContentResolver.setIsSyncable(account, ContactsContract.AUTHORITY, 1);
                ContentResolver.setSyncAutomatically(account, ContactsContract.AUTHORITY,
                        syncContacts);

                // Set up calendar syncing, as above
                boolean syncCalendar = false;
                if (options.containsKey(OPTIONS_CALENDAR_SYNC_ENABLED) &&
                        options.getBoolean(OPTIONS_CALENDAR_SYNC_ENABLED)) {
                    syncCalendar = true;
                }
                ContentResolver.setIsSyncable(account, CalendarProviderStub.AUTHORITY, 1);
                ContentResolver.setSyncAutomatically(account, CalendarProviderStub.AUTHORITY,
                        syncCalendar);

                // Set up email syncing, as above
                boolean syncEmail = false;
                if (options.containsKey(OPTIONS_EMAIL_SYNC_ENABLED) &&
                        options.getBoolean(OPTIONS_EMAIL_SYNC_ENABLED)) {
                    syncEmail = true;
                }
                ContentResolver.setIsSyncable(account, EmailContent.AUTHORITY, 1);
                ContentResolver.setSyncAutomatically(account, EmailContent.AUTHORITY,
                        syncEmail);

                Bundle b = new Bundle();
                b.putString(AccountManager.KEY_ACCOUNT_NAME, options.getString(OPTIONS_USERNAME));
                b.putString(AccountManager.KEY_ACCOUNT_TYPE, AccountManagerTypes.TYPE_EXCHANGE);
                return b;
            // 2) The other case is that we're creating a new account from an Account manager
            //    activity.  In this case, we add an intent that will be used to gather the
            //    account information...
            } else {
                Bundle b = new Bundle();
                Intent intent =
                    AccountSetupBasics.actionSetupExchangeIntent(EasAuthenticatorService.this);
                intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
                b.putParcelable(AccountManager.KEY_INTENT, intent);
                return b;
            }
        }

        @Override
        public Bundle confirmCredentials(AccountAuthenticatorResponse response, Account account,
                Bundle options) {
            return null;
        }

        @Override
        public Bundle editProperties(AccountAuthenticatorResponse response, String accountType) {
            return null;
        }

        @Override
        public Bundle getAuthToken(AccountAuthenticatorResponse response, Account account,
                String authTokenType, Bundle loginOptions) throws NetworkErrorException {
            return null;
        }

        @Override
        public String getAuthTokenLabel(String authTokenType) {
            // null means we don't have compartmentalized authtoken types
            return null;
        }

        @Override
        public Bundle hasFeatures(AccountAuthenticatorResponse response, Account account,
                String[] features) throws NetworkErrorException {
            return null;
        }

        @Override
        public Bundle updateCredentials(AccountAuthenticatorResponse response, Account account,
                String authTokenType, Bundle loginOptions) {
            return null;
        }

    }

    @Override
    public IBinder onBind(Intent intent) {
        if (AccountManager.ACTION_AUTHENTICATOR_INTENT.equals(intent.getAction())) {
            return new EasAuthenticator(this).getIBinder();
        } else {
            return null;
        }
    }
}
",True,268,1,1,12,61,2,4,L6
113,com.android.email.service.PolicyService.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import com.android.email.SecurityPolicy;
import com.android.emailcommon.provider.Policy;
import com.android.emailcommon.service.IPolicyService;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;

public class PolicyService extends Service {

    private SecurityPolicy mSecurityPolicy;
    private Context mContext;

    private final IPolicyService.Stub mBinder = new IPolicyService.Stub() {
        public boolean isActive(Policy policy) {
            return mSecurityPolicy.isActive(policy);
        }

        public void policiesRequired(long accountId) {
            mSecurityPolicy.policiesRequired(accountId);
        }

        public void policiesUpdated(long accountId) {
            mSecurityPolicy.policiesUpdated(accountId);
        }

        public void setAccountHoldFlag(long accountId, boolean newState) {
            SecurityPolicy.setAccountHoldFlag(mContext, accountId, newState);
        }

        public boolean isActiveAdmin() {
            return mSecurityPolicy.isActiveAdmin();
        }

        public void remoteWipe() {
            mSecurityPolicy.remoteWipe();
        }

        public boolean isSupported(Policy policy) {
            return mSecurityPolicy.isSupported(policy);
        }

        public Policy clearUnsupportedPolicies(Policy policy) {
            return mSecurityPolicy.clearUnsupportedPolicies(policy);
        }
    };

    @Override
    public IBinder onBind(Intent intent) {
        // When we bind this service, save the context and SecurityPolicy singleton
        mContext = this;
        mSecurityPolicy = SecurityPolicy.getInstance(this);
        return mBinder;
    }
}",False,268,0,0,11,58,0,2,L8
114,com.android.email.service.EasTestAuthenticatorService.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.accounts.AbstractAccountAuthenticator;
import android.accounts.Account;
import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.accounts.NetworkErrorException;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;

import com.android.email.activity.setup.AccountSetupBasics;

/**
 * Anauthenticator service for reconciliation tests; it simply adds the account to AccountManager
 * directly with a username and password.
 */
public class EasTestAuthenticatorService extends Service {
    public static final String OPTIONS_USERNAME = ""username"";
    public static final String OPTIONS_PASSWORD = ""password"";
    private static final String TEST_ACCOUNT_TYPE = ""com.android.test_exchange"";

    class EasAuthenticator extends AbstractAccountAuthenticator {

        public EasAuthenticator(Context context) {
            super(context);
        }

        @Override
        public Bundle addAccount(AccountAuthenticatorResponse response, String accountType,
                String authTokenType, String[] requiredFeatures, Bundle options)
                throws NetworkErrorException {
            // There are two cases here:
            // 1) We are called with a username/password; this comes from the traditional email
            //    app UI; we simply create the account and return the proper bundle
            if (options != null && options.containsKey(OPTIONS_PASSWORD)
                    && options.containsKey(OPTIONS_USERNAME)) {
                final Account account = new Account(options.getString(OPTIONS_USERNAME),
                        TEST_ACCOUNT_TYPE);
                AccountManager.get(EasTestAuthenticatorService.this).addAccountExplicitly(
                            account, options.getString(OPTIONS_PASSWORD), null);

                Bundle b = new Bundle();
                b.putString(AccountManager.KEY_ACCOUNT_NAME, TEST_ACCOUNT_TYPE);
                return b;
            // 2) The other case is that we're creating a new account from an Account manager
            //    activity.  In this case, we add an intent that will be used to gather the
            //    account information...
            } else {
                Bundle b = new Bundle();
                Intent intent =
                    AccountSetupBasics.actionSetupExchangeIntent(EasTestAuthenticatorService.this);
                intent.putExtra(AccountManager.KEY_ACCOUNT_AUTHENTICATOR_RESPONSE, response);
                b.putParcelable(AccountManager.KEY_INTENT, intent);
                return b;
            }
        }

        @Override
        public Bundle confirmCredentials(AccountAuthenticatorResponse response, Account account,
                Bundle options) {
            return null;
        }

        @Override
        public Bundle editProperties(AccountAuthenticatorResponse response, String accountType) {
            return null;
        }

        @Override
        public Bundle getAuthToken(AccountAuthenticatorResponse response, Account account,
                String authTokenType, Bundle loginOptions) throws NetworkErrorException {
            return null;
        }

        @Override
        public String getAuthTokenLabel(String authTokenType) {
            // null means we don't have compartmentalized authtoken types
            return null;
        }

        @Override
        public Bundle hasFeatures(AccountAuthenticatorResponse response, Account account,
                String[] features) throws NetworkErrorException {
            return null;
        }

        @Override
        public Bundle updateCredentials(AccountAuthenticatorResponse response, Account account,
                String authTokenType, Bundle loginOptions) {
            return null;
        }

    }

    @Override
    public IBinder onBind(Intent intent) {
        if (AccountManager.ACTION_AUTHENTICATOR_INTENT.equals(intent.getAction())) {
            return new EasAuthenticator(this).getIBinder();
        } else {
            return null;
        }
    }
}
",True,268,0,0,12,61,0,1,L8
115,com.android.email.service.EmailServiceUtils.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;

import com.android.emailcommon.Api;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.service.IEmailService;
import com.android.emailcommon.service.IEmailServiceCallback;
import com.android.emailcommon.service.SearchParams;

/**
 * Utility functions for EmailService support.
 */
public class EmailServiceUtils {
    /**
     * Starts an EmailService by name
     */
    public static void startService(Context context, String intentAction) {
        context.startService(new Intent(intentAction));
    }

    /**
     * Returns an {@link IEmailService} for the service; otherwise returns an empty
     * {@link IEmailService} implementation.
     *
     * @param context
     * @param callback Object to get callback, or can be null
     */
    public static IEmailService getService(Context context, String intentAction,
            IEmailServiceCallback callback) {
        return new EmailServiceProxy(context, intentAction, callback);
    }

    /**
     * Determine if the EmailService is available
     */
    public static boolean isServiceAvailable(Context context, String intentAction) {
        return new EmailServiceProxy(context, intentAction, null).test();
    }

    public static void startExchangeService(Context context) {
        startService(context, EmailServiceProxy.EXCHANGE_INTENT);
    }

    public static IEmailService getExchangeService(Context context,
            IEmailServiceCallback callback) {
        return getService(context, EmailServiceProxy.EXCHANGE_INTENT, callback);
    }

    public static boolean isExchangeAvailable(Context context) {
        return isServiceAvailable(context, EmailServiceProxy.EXCHANGE_INTENT);
    }

    /**
     * An empty {@link IEmailService} implementation which is used instead of
     * {@link com.android.exchange.ExchangeService} on the build with no exchange support.
     *
     * <p>In theory, the service in question isn't used on the no-exchange-support build,
     * because we won't have any exchange accounts in that case, so we wouldn't have to have this
     * class.  However, there are a few places we do use the service even if there's no exchange
     * accounts (e.g. setLogging), so this class is added for safety and simplicity.
     */
    public static class NullEmailService extends Service implements IEmailService {
        public static final NullEmailService INSTANCE = new NullEmailService();

        public int getApiLevel() {
            return Api.LEVEL;
        }

        public Bundle autoDiscover(String userName, String password) throws RemoteException {
            return Bundle.EMPTY;
        }

        public boolean createFolder(long accountId, String name) throws RemoteException {
            return false;
        }

        public boolean deleteFolder(long accountId, String name) throws RemoteException {
            return false;
        }

        public void hostChanged(long accountId) throws RemoteException {
        }

        public void loadAttachment(long attachmentId, boolean background) throws RemoteException {
        }

        public void loadMore(long messageId) throws RemoteException {
        }

        public boolean renameFolder(long accountId, String oldName, String newName)
                throws RemoteException {
            return false;
        }

        public void sendMeetingResponse(long messageId, int response) throws RemoteException {
        }

        public void setCallback(IEmailServiceCallback cb) throws RemoteException {
        }

        public void setLogging(int flags) throws RemoteException {
        }

        public void startSync(long mailboxId, boolean userRequest) throws RemoteException {
        }

        public void stopSync(long mailboxId) throws RemoteException {
        }

        public void updateFolderList(long accountId) throws RemoteException {
        }

        public Bundle validate(HostAuth hostAuth) throws RemoteException {
            return null;
        }

        public void deleteAccountPIMData(long accountId) throws RemoteException {
        }

        public int searchMessages(long accountId, SearchParams searchParams, long destMailboxId) {
            return 0;
        }

        public IBinder asBinder() {
            return null;
        }

        @Override
        public IBinder onBind(Intent intent) {
            return null;
        }
    }
}
",False,166,7,50,3,8,10,5,L6
116,com.android.email.service.EmailBroadcastReceiver.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.service;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

/**
 * The broadcast receiver.  The actual job is done in EmailBroadcastProcessor on a worker thread.
 */
public class EmailBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        EmailBroadcastProcessorService.processBroadcastIntent(context, intent);
    }
}
",False,268,0,0,12,45,0,1,L8
117,com.android.email.mail.Sender.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail;

import android.content.Context;
import android.content.res.XmlResourceParser;
import android.util.Log;

import com.android.email.R;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;

import org.xmlpull.v1.XmlPullParserException;

import java.io.IOException;

public abstract class Sender {
    protected static final int SOCKET_CONNECT_TIMEOUT = 10000;

    /**
     * Static named constructor.  It should be overrode by extending class.
     * Because this method will be called through reflection, it can not be protected.
     */
    public static Sender newInstance(Context context, Account account)
            throws MessagingException {
        throw new MessagingException(""Sender.newInstance: Unknown scheme in ""
                + account.mDisplayName);
    }

    private static Sender instantiateSender(Context context, String className, Account account)
        throws MessagingException {
        Object o = null;
        try {
            Class<?> c = Class.forName(className);
            // and invoke ""newInstance"" class method and instantiate sender object.
            java.lang.reflect.Method m =
                c.getMethod(""newInstance"", Account.class, Context.class);
            o = m.invoke(null, account, context);
        } catch (Exception e) {
            Log.d(Logging.LOG_TAG, String.format(
                    ""exception %s invoking method %s#newInstance(Account, Context) for %s"",
                    e.toString(), className, account.mDisplayName));
            throw new MessagingException(""can not instantiate Sender for "" + account.mDisplayName);
        }
        if (!(o instanceof Sender)) {
            throw new MessagingException(
                    account.mDisplayName + "": "" + className + "" create incompatible object"");
        }
        return (Sender) o;
    }

    /**
     * Find Sender implementation consulting with sender.xml file.
     */
    private static Sender findSender(Context context, int resourceId, Account account)
            throws MessagingException {
        Sender sender = null;
        try {
            XmlResourceParser xml = context.getResources().getXml(resourceId);
            int xmlEventType;
            HostAuth sendAuth = account.getOrCreateHostAuthSend(context);
            // walk through senders.xml file.
            while ((xmlEventType = xml.next()) != XmlResourceParser.END_DOCUMENT) {
                if (xmlEventType == XmlResourceParser.START_TAG &&
                    ""sender"".equals(xml.getName())) {
                    String xmlScheme = xml.getAttributeValue(null, ""scheme"");
                    if (sendAuth.mProtocol != null && sendAuth.mProtocol.startsWith(xmlScheme)) {
                        // found sender entry whose scheme is matched with uri.
                        // then load sender class.
                        String className = xml.getAttributeValue(null, ""class"");
                        sender = instantiateSender(context, className, account);
                    }
                }
            }
        } catch (XmlPullParserException e) {
            // ignore
        } catch (IOException e) {
            // ignore
        }
        return sender;
    }

    /**
     * Get an instance of a mail sender for the given account. The account must be valid (i.e. has
     * at least an outgoing server name).
     *
     * @param context the caller's context
     * @param account the account of the sender.
     * @return an initialized sender of the appropriate class
     * @throws MessagingException If the sender cannot be obtained or if the account is invalid.
     */
    public synchronized static Sender getInstance(Context context, Account account)
            throws MessagingException {
        Context appContext = context.getApplicationContext();
        Sender sender = findSender(appContext, R.xml.senders_product, account);
        if (sender == null) {
            sender = findSender(appContext, R.xml.senders, account);
        }
        if (sender == null) {
            throw new MessagingException(""Cannot find sender for account "" + account.mDisplayName);
        }
        return sender;
    }

    /**
     * Get class of SettingActivity for this Sender class.
     * @return Activity class that has class method actionEditOutgoingSettings().
     */
    public Class<? extends android.app.Activity> getSettingActivityClass() {
        // default SettingActivity class
        return com.android.email.activity.setup.AccountSetupOutgoing.class;
    }

    public abstract void open() throws MessagingException;

    public abstract void sendMessage(long messageId) throws MessagingException;

    public abstract void close() throws MessagingException;
}
",True,270,2,2,12,55,6,5,L6
118,com.android.email.mail.Transport.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail;

import com.android.emailcommon.mail.CertificateValidationException;
import com.android.emailcommon.mail.MessagingException;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.SocketException;

/**
 * This interface defines a ""transport"", which is defined here as being one layer below the
 * specific wire protocols such as POP3, IMAP, or SMTP.
 *
 * Practically speaking, it provides a definition of the common functionality between them
 * (dealing with sockets & streams, SSL, logging, and so forth), and provides a seam just below
 * the individual protocols to enable better testing.
 *
 * The following features are supported and presumed to be common:
 *
 *  Interpretation of URI
 *  Support for SSL and TLS wireline security
 */
public interface Transport extends Cloneable {

    /**
     * Connection security options for transport that supports SSL and/or TLS
     */
    public static final int CONNECTION_SECURITY_NONE = 0;
    public static final int CONNECTION_SECURITY_SSL = 1;
    public static final int CONNECTION_SECURITY_TLS = 2;

    /**
     * Get a new transport, using an existing one as a model.  The new transport is configured as if
     * setUri() and setSecurity() have been called, but not opened or connected in any way.
     * @return a new Transport ready to open()
     */
    public Transport clone();

    /**
     * Sets the host
     */
    public void setHost(String host);

    /**
     * Sets the port
     */
    public void setPort(int port);

    /**
     * Returns the host or {@code null} if none was specified.
     */
    public String getHost();

    /**
     * Returns the port or {@code 0} if none was specified.
     */
    public int getPort();

    /**
     * Set the desired security mode for this connection.
     * @param connectionSecurity A value indicating the desired security mode.
     * @param trustAllCertificates true to allow unverifiable certificates to be used
     */
    public void setSecurity(int connectionSecurity, boolean trustAllCertificates);

    /**
     * @return Returns the desired security mode for this connection.
     */
    public int getSecurity();

    /**
     * @return true if the security mode indicates that SSL is possible
     */
    public boolean canTrySslSecurity();

    /**
     * @return true if the security mode indicates that TLS is possible
     */
    public boolean canTryTlsSecurity();

    /**
     * @return true if the security mode indicates that all certificates can be trusted
     */
    public boolean canTrustAllCertificates();

    /**
     * Set the socket timeout.
     * @param timeoutMilliseconds the read timeout value if greater than {@code 0}, or
     *            {@code 0} for an infinite timeout.
     */
    public void setSoTimeout(int timeoutMilliseconds) throws SocketException;

        /**
     * Attempts to open the connection using the supplied parameters, and using SSL if indicated.
     */
    public void open() throws MessagingException, CertificateValidationException;

    /**
     * Attempts to reopen the connection using TLS.
     */
    public void reopenTls() throws MessagingException;

    /**
     * @return true if the connection is open
     */
    public boolean isOpen();

    /**
     * Closes the connection.  Does not send any closure messages, simply closes the socket and the
     * associated streams.  Best effort only.  Catches all exceptions and always returns.
     *
     * MUST NOT throw any exceptions.
     */
    public void close();

    /**
     * @return returns the active input stream
     */
    public InputStream getInputStream();

    /**
     * @return returns the active output stream
     */
    public OutputStream getOutputStream();

    /**
     * Write a single line to the server, and may generate a log entry (if enabled).
     * @param s The text to send to the server.
     * @param sensitiveReplacement If the command includes sensitive data (e.g. authentication)
     * please pass a replacement string here (for logging).  Most callers simply pass null,
     */
    void writeLine(String s, String sensitiveReplacement) throws IOException;

    /**
     * Reads a single line from the server.  Any delimiter characters will not be included in the
     * result.  May generate a log entry, if enabled.
     * @return Returns the string from the server.
     * @throws IOException
     */
    String readLine() throws IOException;

    /**
     * @return The local address.  If we have an open socket, get the local address from this.
     *     Otherwise simply use {@link InetAddress#getLocalHost}.
     */
    InetAddress getLocalAddress() throws IOException;
}
",False,150,8,54,1,2,11,2,L6
119,com.android.email.mail.Store.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail;

import android.content.Context;
import android.os.Bundle;
import android.util.Log;

import com.android.email.Email;
import com.android.email.mail.store.ExchangeStore;
import com.android.email.mail.store.ImapStore;
import com.android.email.mail.store.Pop3Store;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.Folder;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.google.common.annotations.VisibleForTesting;

import java.lang.reflect.Method;
import java.util.HashMap;

/**
 * Store is the legacy equivalent of the Account class
 */
public abstract class Store {
    /**
     * A global suggestion to Store implementors on how much of the body
     * should be returned on FetchProfile.Item.BODY_SANE requests.
     */
    public static final int FETCH_BODY_SANE_SUGGESTED_SIZE = (50 * 1024);

    @VisibleForTesting
    static final HashMap<HostAuth, Store> sStores = new HashMap<HostAuth, Store>();
    protected Context mContext;
    protected Account mAccount;
    protected Transport mTransport;
    protected String mUsername;
    protected String mPassword;

    static final HashMap<String, Class<? extends Store>> sStoreClasses =
        new HashMap<String, Class<? extends Store>>();

    static {
        sStoreClasses.put(HostAuth.SCHEME_EAS, ExchangeStore.class);
        sStoreClasses.put(HostAuth.SCHEME_IMAP, ImapStore.class);
        sStoreClasses.put(HostAuth.SCHEME_POP3, Pop3Store.class);
    }

    /**
     * Static named constructor.  It should be overrode by extending class.
     * Because this method will be called through reflection, it can not be protected.
     */
    static Store newInstance(Account account, Context context) throws MessagingException {
        throw new MessagingException(""Store#newInstance: Unknown scheme in ""
                + account.mDisplayName);
    }

    /**
     * Get an instance of a mail store for the given account. The account must be valid (i.e. has
     * at least an incoming server name).
     *
     * NOTE: The internal algorithm used to find a cached store depends upon the account's
     * HostAuth row. If this ever changes (e.g. such as the user updating the
     * host name or port), we will leak entries. This should not be typical, so, it is not
     * a critical problem. However, it is something we should consider fixing.
     *
     * @param account The account of the store.
     * @return an initialized store of the appropriate class
     * @throws MessagingException If the store cannot be obtained or if the account is invalid.
     */
    public synchronized static Store getInstance(Account account, Context context)
            throws MessagingException {
        HostAuth hostAuth = account.getOrCreateHostAuthRecv(context);
        // An existing account might have been deleted
        if (hostAuth == null) return null;
        Store store = sStores.get(hostAuth);
        if (store == null) {
            Context appContext = context.getApplicationContext();
            Class<? extends Store> klass = sStoreClasses.get(hostAuth.mProtocol);
            try {
                // invoke ""newInstance"" class method
                Method m = klass.getMethod(""newInstance"", Account.class, Context.class);
                store = (Store)m.invoke(null, account, appContext);
            } catch (Exception e) {
                Log.d(Logging.LOG_TAG, String.format(
                        ""exception %s invoking method %s#newInstance(Account, Context) for %s"",
                        e.toString(), klass.getName(), account.mDisplayName));
                throw new MessagingException(""Can't instantiate Store for "" + account.mDisplayName);
            }
            // Don't cache this unless it's we've got a saved HostAuth
            if (hostAuth.mId != EmailContent.NOT_SAVED) {
                sStores.put(hostAuth, store);
            }
        }
        return store;
    }

    /**
     * Delete the mail store associated with the given account. The account must be valid (i.e. has
     * at least an incoming server name).
     *
     * The store should have been notified already by calling delete(), and the caller should
     * also take responsibility for deleting the matching LocalStore, etc.
     *
     * @throws MessagingException If the store cannot be removed or if the account is invalid.
     */
    public synchronized static Store removeInstance(Account account, Context context)
            throws MessagingException {
        return sStores.remove(HostAuth.restoreHostAuthWithId(context, account.mHostAuthKeyRecv));
    }

    /**
     * Get class of SettingActivity for this Store class.
     * @return Activity class that has class method actionEditIncomingSettings().
     */
    public Class<? extends android.app.Activity> getSettingActivityClass() {
        // default SettingActivity class
        return com.android.email.activity.setup.AccountSetupIncoming.class;
    }

    /**
     * Some protocols require that a sent message be copied (uploaded) into the Sent folder
     * while others can take care of it automatically (ideally, on the server).  This function
     * allows a given store to indicate which mode(s) it supports.
     * @return true if the store requires an upload into ""sent"", false if this happens automatically
     * for any sent message.
     */
    public boolean requireCopyMessageToSentFolder() {
        return true;
    }

    public Folder getFolder(String name) throws MessagingException {
        return null;
    }

    /**
     * Updates the local list of mailboxes according to what is located on the remote server.
     * <em>Note: This does not perform folder synchronization and it will not remove mailboxes
     * that are stored locally but not remotely.</em>
     * @return The set of remote folders
     * @throws MessagingException If there was a problem connecting to the remote server
     */
    public Folder[] updateFolders() throws MessagingException {
        return null;
    }

    public abstract Bundle checkSettings() throws MessagingException;

    /**
     * Handle discovery of account settings using only the user's email address and password
     * @param context the context of the caller
     * @param emailAddress the email address of the exchange user
     * @param password the password of the exchange user
     * @return a Bundle containing an error code and a HostAuth (if successful)
     * @throws MessagingException
     */
    public Bundle autoDiscover(Context context, String emailAddress, String password)
            throws MessagingException {
        return null;
    }

    /**
     * Updates the fields within the given mailbox. Only the fields that are important to
     * non-EAS accounts are modified.
     */
    protected static void updateMailbox(Mailbox mailbox, long accountId, String mailboxPath,
            char delimiter, boolean selectable, int type) {
        mailbox.mAccountKey = accountId;
        mailbox.mDelimiter = delimiter;
        String displayPath = mailboxPath;
        int pathIndex = mailboxPath.lastIndexOf(delimiter);
        if (pathIndex > 0) {
            displayPath = mailboxPath.substring(pathIndex + 1);
        }
        mailbox.mDisplayName = displayPath;
        if (selectable) {
            mailbox.mFlags = Mailbox.FLAG_HOLDS_MAIL | Mailbox.FLAG_ACCEPTS_MOVED_MAIL;
        }
        mailbox.mFlagVisible = true;
        //mailbox.mParentKey;
        //mailbox.mParentServerId;
        mailbox.mServerId = mailboxPath;
        //mailbox.mServerId;
        //mailbox.mSyncFrequency;
        //mailbox.mSyncKey;
        //mailbox.mSyncLookback;
        //mailbox.mSyncTime;
        mailbox.mType = type;
        //box.mUnreadCount;
        mailbox.mVisibleLimit = Email.VISIBLE_LIMIT_DEFAULT;
    }
}
",True,270,1,3,9,68,11,13,L6
120,com.android.email.mail.transport.SmtpSender.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.transport;

import android.content.Context;
import android.util.Base64;
import android.util.Log;

import com.android.email.Email;
import com.android.email.mail.Sender;
import com.android.email.mail.Transport;
import com.android.emailcommon.Logging;
import com.android.emailcommon.internet.Rfc822Output;
import com.android.emailcommon.mail.Address;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.CertificateValidationException;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.HostAuth;

import java.io.IOException;
import java.net.Inet6Address;
import java.net.InetAddress;

import javax.net.ssl.SSLException;

/**
 * This class handles all of the protocol-level aspects of sending messages via SMTP.
 * TODO Remove dependence upon URI; there's no reason why we need it here
 */
public class SmtpSender extends Sender {

    private final Context mContext;
    private Transport mTransport;
    private String mUsername;
    private String mPassword;

    /**
     * Static named constructor.
     */
    public static Sender newInstance(Account account, Context context) throws MessagingException {
        return new SmtpSender(context, account);
    }

    /**
     * Creates a new sender for the given account.
     */
    private SmtpSender(Context context, Account account) throws MessagingException {
        mContext = context;
        HostAuth sendAuth = account.getOrCreateHostAuthSend(context);
        if (sendAuth == null || !""smtp"".equalsIgnoreCase(sendAuth.mProtocol)) {
            throw new MessagingException(""Unsupported protocol"");
        }
        // defaults, which can be changed by security modifiers
        int connectionSecurity = Transport.CONNECTION_SECURITY_NONE;
        int defaultPort = 587;

        // check for security flags and apply changes
        if ((sendAuth.mFlags & HostAuth.FLAG_SSL) != 0) {
            connectionSecurity = Transport.CONNECTION_SECURITY_SSL;
            defaultPort = 465;
        } else if ((sendAuth.mFlags & HostAuth.FLAG_TLS) != 0) {
            connectionSecurity = Transport.CONNECTION_SECURITY_TLS;
        }
        boolean trustCertificates = ((sendAuth.mFlags & HostAuth.FLAG_TRUST_ALL) != 0);
        int port = defaultPort;
        if (sendAuth.mPort != HostAuth.PORT_UNKNOWN) {
            port = sendAuth.mPort;
        }
        mTransport = new MailTransport(""IMAP"");
        mTransport.setHost(sendAuth.mAddress);
        mTransport.setPort(port);
        mTransport.setSecurity(connectionSecurity, trustCertificates);

        String[] userInfoParts = sendAuth.getLogin();
        if (userInfoParts != null) {
            mUsername = userInfoParts[0];
            mPassword = userInfoParts[1];
        }
    }

    /**
     * For testing only.  Injects a different transport.  The transport should already be set
     * up and ready to use.  Do not use for real code.
     * @param testTransport The Transport to inject and use for all future communication.
     */
    /* package */ void setTransport(Transport testTransport) {
        mTransport = testTransport;
    }

    @Override
    public void open() throws MessagingException {
        try {
            mTransport.open();

            // Eat the banner
            executeSimpleCommand(null);

            String localHost = ""localhost"";
            // Try to get local address in the proper format.
            InetAddress localAddress = mTransport.getLocalAddress();
            if (localAddress != null) {
                // Address Literal formatted in accordance to RFC2821 Sec. 4.1.3
                StringBuilder sb = new StringBuilder();
                sb.append('[');
                if (localAddress instanceof Inet6Address) {
                    sb.append(""IPv6:"");
                }
                sb.append(localAddress.getHostAddress());
                sb.append(']');
                localHost = sb.toString();
            }
            String result = executeSimpleCommand(""EHLO "" + localHost);

            /*
             * TODO may need to add code to fall back to HELO I switched it from
             * using HELO on non STARTTLS connections because of AOL's mail
             * server. It won't let you use AUTH without EHLO.
             * We should really be paying more attention to the capabilities
             * and only attempting auth if it's available, and warning the user
             * if not.
             */
            if (mTransport.canTryTlsSecurity()) {
                if (result.contains(""-STARTTLS"")) {
                    executeSimpleCommand(""STARTTLS"");
                    mTransport.reopenTls();
                    /*
                     * Now resend the EHLO. Required by RFC2487 Sec. 5.2, and more specifically,
                     * Exim.
                     */
                    result = executeSimpleCommand(""EHLO "" + localHost);
                } else {
                    if (Email.DEBUG) {
                        Log.d(Logging.LOG_TAG, ""TLS not supported but required"");
                    }
                    throw new MessagingException(MessagingException.TLS_REQUIRED);
                }
            }

            /*
             * result contains the results of the EHLO in concatenated form
             */
            boolean authLoginSupported = result.matches("".*AUTH.*LOGIN.*$"");
            boolean authPlainSupported = result.matches("".*AUTH.*PLAIN.*$"");

            if (mUsername != null && mUsername.length() > 0 && mPassword != null
                    && mPassword.length() > 0) {
                if (authPlainSupported) {
                    saslAuthPlain(mUsername, mPassword);
                }
                else if (authLoginSupported) {
                    saslAuthLogin(mUsername, mPassword);
                }
                else {
                    if (Email.DEBUG) {
                        Log.d(Logging.LOG_TAG, ""No valid authentication mechanism found."");
                    }
                    throw new MessagingException(MessagingException.AUTH_REQUIRED);
                }
            }
        } catch (SSLException e) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, e.toString());
            }
            throw new CertificateValidationException(e.getMessage(), e);
        } catch (IOException ioe) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ioe.toString());
            }
            throw new MessagingException(MessagingException.IOERROR, ioe.toString());
        }
    }

    @Override
    public void sendMessage(long messageId) throws MessagingException {
        close();
        open();

        Message message = Message.restoreMessageWithId(mContext, messageId);
        if (message == null) {
            throw new MessagingException(""Trying to send non-existent message id=""
                    + Long.toString(messageId));
        }
        Address from = Address.unpackFirst(message.mFrom);
        Address[] to = Address.unpack(message.mTo);
        Address[] cc = Address.unpack(message.mCc);
        Address[] bcc = Address.unpack(message.mBcc);

        try {
            executeSimpleCommand(""MAIL FROM: "" + ""<"" + from.getAddress() + "">"");
            for (Address address : to) {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            for (Address address : cc) {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            for (Address address : bcc) {
                executeSimpleCommand(""RCPT TO: "" + ""<"" + address.getAddress() + "">"");
            }
            executeSimpleCommand(""DATA"");
            // TODO byte stuffing
            Rfc822Output.writeTo(mContext, messageId,
                    new EOLConvertingOutputStream(mTransport.getOutputStream()),
                    false /* do not use smart reply */,
                    false /* do not send BCC */);
            executeSimpleCommand(""\r\n."");
        } catch (IOException ioe) {
            throw new MessagingException(""Unable to send message"", ioe);
        }
    }

    /**
     * Close the protocol (and the transport below it).
     *
     * MUST NOT return any exceptions.
     */
    @Override
    public void close() {
        mTransport.close();
    }

    /**
     * Send a single command and wait for a single response.  Handles responses that continue
     * onto multiple lines.  Throws MessagingException if response code is 4xx or 5xx.  All traffic
     * is logged (if debug logging is enabled) so do not use this function for user ID or password.
     *
     * @param command The command string to send to the server.
     * @return Returns the response string from the server.
     */
    private String executeSimpleCommand(String command) throws IOException, MessagingException {
        return executeSensitiveCommand(command, null);
    }

    /**
     * Send a single command and wait for a single response.  Handles responses that continue
     * onto multiple lines.  Throws MessagingException if response code is 4xx or 5xx.
     *
     * @param command The command string to send to the server.
     * @param sensitiveReplacement If the command includes sensitive data (e.g. authentication)
     * please pass a replacement string here (for logging).
     * @return Returns the response string from the server.
     */
    private String executeSensitiveCommand(String command, String sensitiveReplacement)
            throws IOException, MessagingException {
        if (command != null) {
            mTransport.writeLine(command, sensitiveReplacement);
        }

        String line = mTransport.readLine();

        String result = line;

        while (line.length() >= 4 && line.charAt(3) == '-') {
            line = mTransport.readLine();
            result += line.substring(3);
        }

        if (result.length() > 0) {
            char c = result.charAt(0);
            if ((c == '4') || (c == '5')) {
                throw new MessagingException(result);
            }
        }

        return result;
    }


//    C: AUTH LOGIN
//    S: 334 VXNlcm5hbWU6
//    C: d2VsZG9u
//    S: 334 UGFzc3dvcmQ6
//    C: dzNsZDBu
//    S: 235 2.0.0 OK Authenticated
//
//    Lines 2-5 of the conversation contain base64-encoded information. The same conversation, with base64 strings decoded, reads:
//
//
//    C: AUTH LOGIN
//    S: 334 Username:
//    C: weldon
//    S: 334 Password:
//    C: w3ld0n
//    S: 235 2.0.0 OK Authenticated

    private void saslAuthLogin(String username, String password) throws MessagingException,
        AuthenticationFailedException, IOException {
        try {
            executeSimpleCommand(""AUTH LOGIN"");
            executeSensitiveCommand(
                    Base64.encodeToString(username.getBytes(), Base64.NO_WRAP),
                    ""/username redacted/"");
            executeSensitiveCommand(
                    Base64.encodeToString(password.getBytes(), Base64.NO_WRAP),
                    ""/password redacted/"");
        }
        catch (MessagingException me) {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3') {
                throw new AuthenticationFailedException(me.getMessage());
            }
            throw me;
        }
    }

    private void saslAuthPlain(String username, String password) throws MessagingException,
            AuthenticationFailedException, IOException {
        byte[] data = (""\000"" + username + ""\000"" + password).getBytes();
        data = Base64.encode(data, Base64.NO_WRAP);
        try {
            executeSensitiveCommand(""AUTH PLAIN "" + new String(data), ""AUTH PLAIN /redacted/"");
        }
        catch (MessagingException me) {
            if (me.getMessage().length() > 1 && me.getMessage().charAt(1) == '3') {
                throw new AuthenticationFailedException(me.getMessage());
            }
            throw me;
        }
    }
}
",True,270,1,1,11,59,1,14,L8
121,com.android.email.mail.transport.EOLConvertingOutputStream.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.transport;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class EOLConvertingOutputStream extends FilterOutputStream {
    int lastChar;

    public EOLConvertingOutputStream(OutputStream out) {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException {
        if (oneByte == '\n') {
            if (lastChar != '\r') {
                super.write('\r');
            }
        }
        super.write(oneByte);
        lastChar = oneByte;
    }

    @Override
    public void flush() throws IOException {
        if (lastChar == '\r') {
            super.write('\n');
            lastChar = '\n';
        }
        super.flush();
    }
}
",True,147,11,51,0,0,2,0,L6
122,com.android.email.mail.transport.StatusOutputStream.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.transport;

import com.android.emailcommon.Logging;

import android.util.Log;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class StatusOutputStream extends FilterOutputStream {
    private long mCount = 0;
    
    public StatusOutputStream(OutputStream out) {
        super(out);
    }

    @Override
    public void write(int oneByte) throws IOException {
        super.write(oneByte);
        mCount++;
        if (Logging.LOGD) {
            if (mCount % 1024 == 0) {
                Log.v(Logging.LOG_TAG, ""# "" + mCount);
            }
        }
    }
}
",True,2,0,0,1,1,0,1,L8
123,com.android.email.mail.transport.MailTransport.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.transport;

import com.android.email.Email;
import com.android.email.mail.Transport;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.CertificateValidationException;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.utility.SSLUtils;

import android.util.Log;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.net.SocketException;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;

/**
 * This class implements the common aspects of ""transport"", one layer below the
 * specific wire protocols such as POP3, IMAP, or SMTP.
 */
public class MailTransport implements Transport {

    // TODO protected eventually
    /*protected*/ public static final int SOCKET_CONNECT_TIMEOUT = 10000;
    /*protected*/ public static final int SOCKET_READ_TIMEOUT = 60000;

    private static final HostnameVerifier HOSTNAME_VERIFIER =
            HttpsURLConnection.getDefaultHostnameVerifier();

    private String mDebugLabel;

    private String mHost;
    private int mPort;
    private String[] mUserInfoParts;

    /**
     * One of the {@code Transport.CONNECTION_SECURITY_*} values.
     */
    private int mConnectionSecurity;

    /**
     * Whether or not to trust all server certificates (i.e. skip host verification) in SSL
     * handshakes
     */
    private boolean mTrustCertificates;

    private Socket mSocket;
    private InputStream mIn;
    private OutputStream mOut;

    /**
     * Simple constructor for starting from scratch.  Call setUri() and setSecurity() to
     * complete the configuration.
     * @param debugLabel Label used for Log.d calls
     */
    public MailTransport(String debugLabel) {
        super();
        mDebugLabel = debugLabel;
    }

    /**
     * Returns a new transport, using the current transport as a model. The new transport is
     * configured identically (as if {@link #setSecurity(int, boolean)}, {@link #setPort(int)}
     * and {@link #setHost(String)} were invoked), but not opened or connected in any way.
     */
    @Override
    public Transport clone() {
        MailTransport newObject = new MailTransport(mDebugLabel);

        newObject.mDebugLabel = mDebugLabel;
        newObject.mHost = mHost;
        newObject.mPort = mPort;
        if (mUserInfoParts != null) {
            newObject.mUserInfoParts = mUserInfoParts.clone();
        }
        newObject.mConnectionSecurity = mConnectionSecurity;
        newObject.mTrustCertificates = mTrustCertificates;
        return newObject;
    }

    @Override
    public void setHost(String host) {
        mHost = host;
    }

    @Override
    public void setPort(int port) {
        mPort = port;
    }

    @Override
    public String getHost() {
        return mHost;
    }

    @Override
    public int getPort() {
        return mPort;
    }

    @Override
    public void setSecurity(int connectionSecurity, boolean trustAllCertificates) {
        mConnectionSecurity = connectionSecurity;
        mTrustCertificates = trustAllCertificates;
    }

    @Override
    public int getSecurity() {
        return mConnectionSecurity;
    }

    @Override
    public boolean canTrySslSecurity() {
        return mConnectionSecurity == Transport.CONNECTION_SECURITY_SSL;
    }

    @Override
    public boolean canTryTlsSecurity() {
        return mConnectionSecurity == Transport.CONNECTION_SECURITY_TLS;
    }

    @Override
    public boolean canTrustAllCertificates() {
        return mTrustCertificates;
    }

    /**
     * Attempts to open a connection using the Uri supplied for connection parameters.  Will attempt
     * an SSL connection if indicated.
     */
    @Override
    public void open() throws MessagingException, CertificateValidationException {
        if (Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""*** "" + mDebugLabel + "" open "" +
                    getHost() + "":"" + String.valueOf(getPort()));
        }

        try {
            SocketAddress socketAddress = new InetSocketAddress(getHost(), getPort());
            if (canTrySslSecurity()) {
                mSocket = SSLUtils.getSSLSocketFactory(canTrustAllCertificates()).createSocket();
            } else {
                mSocket = new Socket();
            }
            mSocket.connect(socketAddress, SOCKET_CONNECT_TIMEOUT);
            // After the socket connects to an SSL server, confirm that the hostname is as expected
            if (canTrySslSecurity() && !canTrustAllCertificates()) {
                verifyHostname(mSocket, getHost());
            }
            mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
            mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);

        } catch (SSLException e) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, e.toString());
            }
            throw new CertificateValidationException(e.getMessage(), e);
        } catch (IOException ioe) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ioe.toString());
            }
            throw new MessagingException(MessagingException.IOERROR, ioe.toString());
        }
    }

    /**
     * Attempts to reopen a TLS connection using the Uri supplied for connection parameters.
     *
     * NOTE: No explicit hostname verification is required here, because it's handled automatically
     * by the call to createSocket().
     *
     * TODO should we explicitly close the old socket?  This seems funky to abandon it.
     */
    @Override
    public void reopenTls() throws MessagingException {
        try {
            mSocket = SSLUtils.getSSLSocketFactory(canTrustAllCertificates())
                    .createSocket(mSocket, getHost(), getPort(), true);
            mSocket.setSoTimeout(SOCKET_READ_TIMEOUT);
            mIn = new BufferedInputStream(mSocket.getInputStream(), 1024);
            mOut = new BufferedOutputStream(mSocket.getOutputStream(), 512);

        } catch (SSLException e) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, e.toString());
            }
            throw new CertificateValidationException(e.getMessage(), e);
        } catch (IOException ioe) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ioe.toString());
            }
            throw new MessagingException(MessagingException.IOERROR, ioe.toString());
        }
    }

    /**
     * Lightweight version of SSLCertificateSocketFactory.verifyHostname, which provides this
     * service but is not in the public API.
     *
     * Verify the hostname of the certificate used by the other end of a
     * connected socket.  You MUST call this if you did not supply a hostname
     * to SSLCertificateSocketFactory.createSocket().  It is harmless to call this method
     * redundantly if the hostname has already been verified.
     *
     * <p>Wildcard certificates are allowed to verify any matching hostname,
     * so ""foo.bar.example.com"" is verified if the peer has a certificate
     * for ""*.example.com"".
     *
     * @param socket An SSL socket which has been connected to a server
     * @param hostname The expected hostname of the remote server
     * @throws IOException if something goes wrong handshaking with the server
     * @throws SSLPeerUnverifiedException if the server cannot prove its identity
      */
    private void verifyHostname(Socket socket, String hostname) throws IOException {
        // The code at the start of OpenSSLSocketImpl.startHandshake()
        // ensures that the call is idempotent, so we can safely call it.
        SSLSocket ssl = (SSLSocket) socket;
        ssl.startHandshake();

        SSLSession session = ssl.getSession();
        if (session == null) {
            throw new SSLException(""Cannot verify SSL socket without session"");
        }
        // TODO: Instead of reporting the name of the server we think we're connecting to,
        // we should be reporting the bad name in the certificate.  Unfortunately this is buried
        // in the verifier code and is not available in the verifier API, and extracting the
        // CN & alts is beyond the scope of this patch.
        if (!HOSTNAME_VERIFIER.verify(hostname, session)) {
            throw new SSLPeerUnverifiedException(
                    ""Certificate hostname not useable for server: "" + hostname);
        }
    }

    /**
     * Set the socket timeout.
     * @param timeoutMilliseconds the read timeout value if greater than {@code 0}, or
     *            {@code 0} for an infinite timeout.
     */
    @Override
    public void setSoTimeout(int timeoutMilliseconds) throws SocketException {
        mSocket.setSoTimeout(timeoutMilliseconds);
    }

    @Override
    public boolean isOpen() {
        return (mIn != null && mOut != null &&
                mSocket != null && mSocket.isConnected() && !mSocket.isClosed());
    }

    /**
     * Close the connection.  MUST NOT return any exceptions - must be ""best effort"" and safe.
     */
    @Override
    public void close() {
        try {
            mIn.close();
        } catch (Exception e) {
            // May fail if the connection is already closed.
        }
        try {
            mOut.close();
        } catch (Exception e) {
            // May fail if the connection is already closed.
        }
        try {
            mSocket.close();
        } catch (Exception e) {
            // May fail if the connection is already closed.
        }
        mIn = null;
        mOut = null;
        mSocket = null;
    }

    @Override
    public InputStream getInputStream() {
        return mIn;
    }

    @Override
    public OutputStream getOutputStream() {
        return mOut;
    }

    /**
     * Writes a single line to the server using \r\n termination.
     */
    @Override
    public void writeLine(String s, String sensitiveReplacement) throws IOException {
        if (Email.DEBUG) {
            if (sensitiveReplacement != null && !Logging.DEBUG_SENSITIVE) {
                Log.d(Logging.LOG_TAG, "">>> "" + sensitiveReplacement);
            } else {
                Log.d(Logging.LOG_TAG, "">>> "" + s);
            }
        }

        OutputStream out = getOutputStream();
        out.write(s.getBytes());
        out.write('\r');
        out.write('\n');
        out.flush();
    }

    /**
     * Reads a single line from the server, using either \r\n or \n as the delimiter.  The
     * delimiter char(s) are not included in the result.
     */
    @Override
    public String readLine() throws IOException {
        StringBuffer sb = new StringBuffer();
        InputStream in = getInputStream();
        int d;
        while ((d = in.read()) != -1) {
            if (((char)d) == '\r') {
                continue;
            } else if (((char)d) == '\n') {
                break;
            } else {
                sb.append((char)d);
            }
        }
        if (d == -1 && Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""End of stream reached while trying to read line."");
        }
        String ret = sb.toString();
        if (Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""<<< "" + ret);
        }
        return ret;
    }

    @Override
    public InetAddress getLocalAddress() {
        if (isOpen()) {
            return mSocket.getLocalAddress();
        } else {
            return null;
        }
    }
}
",True,269,2,1,11,49,4,6,L6
124,com.android.email.mail.transport.ExchangeSender.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.transport;

import com.android.email.mail.Sender;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;

import android.content.Context;

/**
 * Our Exchange service does not use the sender/store model.  This class exists for exactly one
 * purpose, which is to return ""null"" for getSettingActivityClass().
 */
public class ExchangeSender extends Sender {

    /**
     * Factory method.
     */
    public static Sender newInstance(Account account, Context context) throws MessagingException {
        return new ExchangeSender(context, account);
    }

    private ExchangeSender(Context context, Account account) {
    }

    @Override
    public void close() {
    }

    @Override
    public void open() {
    }

    @Override
    public void sendMessage(long messageId) {
    }

    /**
     * Get class of SettingActivity for this Sender class.
     * @return Activity class that has class method actionEditOutgoingSettings(), or null if
     * outgoing settings should not be presented (e.g. they're handled by the incoming settings
     * screen).
     */
    @Override
    public Class<? extends android.app.Activity> getSettingActivityClass() {
        return null;
    }

}
",False,268,0,0,13,55,0,3,L8
125,com.android.email.mail.transport.CountingOutputStream.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.transport;

import java.io.IOException;
import java.io.OutputStream;

/**
 * A simple OutputStream that does nothing but count how many bytes are written to it and
 * makes that count available to callers.
 */
public class CountingOutputStream extends OutputStream {
    private long mCount;

    public CountingOutputStream() {
    }

    public long getCount() {
        return mCount;
    }

    @Override
    public void write(int oneByte) throws IOException {
        mCount++;
    }
}
",False,147,11,51,0,0,1,0,L6
126,com.android.email.mail.transport.DiscourseLogger.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.transport;

import com.android.emailcommon.Logging;

import android.util.Log;

import java.util.ArrayList;

/**
 * A class to keep last N of lines sent to the server and responses received from the server.
 * They are sent to logcat when {@link #logLastDiscourse} is called.
 *
 * <p>This class is used to log the recent network activities when a response parser crashes.
 */
public class DiscourseLogger {
    private final int mBufferSize;
    private String[] mBuffer;
    private int mPos;
    private final StringBuilder mReceivingLine = new StringBuilder(100);

    public DiscourseLogger(int bufferSize) {
        mBufferSize = bufferSize;
        initBuffer();
    }

    private void initBuffer() {
        mBuffer = new String[mBufferSize];
    }

    /** Add a single line to {@link #mBuffer}. */
    private void addLine(String s) {
        mBuffer[mPos] = s;
        mPos++;
        if (mPos >= mBufferSize) {
            mPos = 0;
        }
    }

    private void addReceivingLineToBuffer() {
        if (mReceivingLine.length() > 0) {
            addLine(mReceivingLine.toString());
            mReceivingLine.delete(0, Integer.MAX_VALUE);
        }
    }

    /**
     * Store a single byte received from the server in {@link #mReceivingLine}.  When LF is
     * received, the content of {@link #mReceivingLine} is added to {@link #mBuffer}.
     */
    public void addReceivedByte(int b) {
        if (0x20 <= b && b <= 0x7e) { // Append only printable ASCII chars.
            mReceivingLine.append((char) b);
        } else if (b == '\n') { // LF
            addReceivingLineToBuffer();
        } else if (b == '\r') { // CR
        } else {
            final String hex = ""00"" + Integer.toHexString(b);
            mReceivingLine.append(""\\x"" + hex.substring(hex.length() - 2, hex.length()));
        }
    }

    /** Add a line sent to the server to {@link #mBuffer}. */
    public void addSentCommand(String command) {
        addLine(command);
    }

    /** @return the contents of {@link #mBuffer} as a String array. */
    /* package for testing */ String[] getLines() {
        addReceivingLineToBuffer();

        ArrayList<String> list = new ArrayList<String>();

        final int start = mPos;
        int pos = mPos;
        do {
            String s = mBuffer[pos];
            if (s != null) {
                list.add(s);
            }
            pos = (pos + 1) % mBufferSize;
        } while (pos != start);

        String[] ret = new String[list.size()];
        list.toArray(ret);
        return ret;
    }

    /**
     * Log the contents of the {@link mBuffer}, and clears it out.  (So it's okay to call this
     * method successively more than once.  There will be no duplicate log.)
     */
    public void logLastDiscourse() {
        String[] lines = getLines();
        if (lines.length == 0) {
            return;
        }

        Log.w(Logging.LOG_TAG, ""Last network activities:"");
        for (String r : getLines()) {
            Log.w(Logging.LOG_TAG, r);
        }
        initBuffer();
    }
}
",False,149,11,49,1,1,5,1,L1
127,com.android.email.mail.internet.EmailHtmlUtil.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.internet;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class EmailHtmlUtil {

    // Regex that matches characters that have special meaning in HTML. '<', '>', '&' and
    // multiple continuous spaces.
    private static final Pattern PLAIN_TEXT_TO_ESCAPE = Pattern.compile(""[<>&]| {2,}|\r?\n"");

    /**
     * Escape some special character as HTML escape sequence.
     * 
     * @param text Text to be displayed using WebView.
     * @return Text correctly escaped.
     */
    public static String escapeCharacterToDisplay(String text) {
        Pattern pattern = PLAIN_TEXT_TO_ESCAPE;
        Matcher match = pattern.matcher(text);
        
        if (match.find()) {
            StringBuilder out = new StringBuilder();
            int end = 0;
            do {
                int start = match.start();
                out.append(text.substring(end, start));
                end = match.end();
                int c = text.codePointAt(start);
                if (c == ' ') {
                    // Escape successive spaces into series of ""&nbsp;"".
                    for (int i = 1, n = end - start; i < n; ++i) {
                        out.append(""&nbsp;"");
                    }
                    out.append(' ');
                } else if (c == '\r' || c == '\n') {
                    out.append(""<br>"");
                } else if (c == '<') {
                    out.append(""&lt;"");
                } else if (c == '>') {
                    out.append(""&gt;"");
                } else if (c == '&') {
                    out.append(""&amp;"");
                }
            } while (match.find());
            out.append(text.substring(end));
            text = out.toString();
        }        
        return text;
    }
}
",False,148,7,62,0,0,3,0,L0
128,com.android.email.mail.store.ExchangeStore.java,"/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store;

import android.content.Context;

import com.android.email.mail.Store;
import com.android.email.service.EmailServiceUtils;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.service.IEmailService;

/**
 * Our Exchange service does not use the sender/store model.
 */
public class ExchangeStore extends ServiceStore {

    /**
     * Static named constructor.
     */
    public static Store newInstance(Account account, Context context) throws MessagingException {
        return new ExchangeStore(account, context);
    }

    /**
     * Creates a new store for the given account.
     */
    public ExchangeStore(Account account, Context context) throws MessagingException {
        super(account, context);
    }

    @Override
    public Class<? extends android.app.Activity> getSettingActivityClass() {
        return com.android.email.activity.setup.AccountSetupExchange.class;
    }

    @Override
    protected IEmailService getService() {
        return EmailServiceUtils.getExchangeService(mContext, null);
    }
}
",False,267,0,0,10,57,1,6,L6
129,com.android.email.mail.store.Pop3Store.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store;

import android.content.Context;
import android.os.Bundle;
import android.util.Log;

import com.android.email.Controller;
import com.android.email.Email;
import com.android.email.mail.Store;
import com.android.email.mail.Transport;
import com.android.email.mail.transport.MailTransport;
import com.android.emailcommon.Logging;
import com.android.emailcommon.internet.MimeMessage;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.FetchProfile;
import com.android.emailcommon.mail.Flag;
import com.android.emailcommon.mail.Folder;
import com.android.emailcommon.mail.Folder.OpenMode;
import com.android.emailcommon.mail.Message;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.service.SearchParams;
import com.android.emailcommon.utility.LoggingInputStream;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class Pop3Store extends Store {
    // All flags defining debug or development code settings must be FALSE
    // when code is checked in or released.
    private static boolean DEBUG_FORCE_SINGLE_LINE_UIDL = false;
    private static boolean DEBUG_LOG_RAW_STREAM = false;

    private static final Flag[] PERMANENT_FLAGS = { Flag.DELETED };
    /** The name of the only mailbox available to POP3 accounts */
    private static final String POP3_MAILBOX_NAME = ""INBOX"";
    private final HashMap<String, Folder> mFolders = new HashMap<String, Folder>();

//    /**
//     * Detected latency, used for usage scaling.
//     * Usage scaling occurs when it is necessary to get information about
//     * messages that could result in large data loads. This value allows
//     * the code that loads this data to decide between using large downloads
//     * (high latency) or multiple round trips (low latency) to accomplish
//     * the same thing.
//     * Default is Integer.MAX_VALUE implying massive latency so that the large
//     * download method is used by default until latency data is collected.
//     */
//    private int mLatencyMs = Integer.MAX_VALUE;
//
//    /**
//     * Detected throughput, used for usage scaling.
//     * Usage scaling occurs when it is necessary to get information about
//     * messages that could result in large data loads. This value allows
//     * the code that loads this data to decide between using large downloads
//     * (high latency) or multiple round trips (low latency) to accomplish
//     * the same thing.
//     * Default is Integer.MAX_VALUE implying massive bandwidth so that the
//     * large download method is used by default until latency data is
//     * collected.
//     */
//    private int mThroughputKbS = Integer.MAX_VALUE;

    /**
     * Static named constructor.
     */
    public static Store newInstance(Account account, Context context) throws MessagingException {
        return new Pop3Store(context, account);
    }

    /**
     * Creates a new store for the given account.
     */
    private Pop3Store(Context context, Account account) throws MessagingException {
        mContext = context;
        mAccount = account;

        HostAuth recvAuth = account.getOrCreateHostAuthRecv(context);
        if (recvAuth == null || !HostAuth.SCHEME_POP3.equalsIgnoreCase(recvAuth.mProtocol)) {
            throw new MessagingException(""Unsupported protocol"");
        }
        // defaults, which can be changed by security modifiers
        int connectionSecurity = Transport.CONNECTION_SECURITY_NONE;
        int defaultPort = 110;

        // check for security flags and apply changes
        if ((recvAuth.mFlags & HostAuth.FLAG_SSL) != 0) {
            connectionSecurity = Transport.CONNECTION_SECURITY_SSL;
            defaultPort = 995;
        } else if ((recvAuth.mFlags & HostAuth.FLAG_TLS) != 0) {
            connectionSecurity = Transport.CONNECTION_SECURITY_TLS;
        }
        boolean trustCertificates = ((recvAuth.mFlags & HostAuth.FLAG_TRUST_ALL) != 0);

        int port = defaultPort;
        if (recvAuth.mPort != HostAuth.PORT_UNKNOWN) {
            port = recvAuth.mPort;
        }
        mTransport = new MailTransport(""POP3"");
        mTransport.setHost(recvAuth.mAddress);
        mTransport.setPort(port);
        mTransport.setSecurity(connectionSecurity, trustCertificates);

        String[] userInfoParts = recvAuth.getLogin();
        if (userInfoParts != null) {
            mUsername = userInfoParts[0];
            mPassword = userInfoParts[1];
        }
    }

    /**
     * For testing only.  Injects a different transport.  The transport should already be set
     * up and ready to use.  Do not use for real code.
     * @param testTransport The Transport to inject and use for all future communication.
     */
    /* package */ void setTransport(Transport testTransport) {
        mTransport = testTransport;
    }

    @Override
    public Folder getFolder(String name) {
        Folder folder = mFolders.get(name);
        if (folder == null) {
            folder = new Pop3Folder(name);
            mFolders.put(folder.getName(), folder);
        }
        return folder;
    }

    private final int[] DEFAULT_FOLDERS = {
            Mailbox.TYPE_DRAFTS,
            Mailbox.TYPE_OUTBOX,
            Mailbox.TYPE_SENT,
            Mailbox.TYPE_TRASH
    };

    @Override
    public Folder[] updateFolders() {
        Mailbox mailbox = Mailbox.getMailboxForPath(mContext, mAccount.mId, POP3_MAILBOX_NAME);
        updateMailbox(mailbox, mAccount.mId, POP3_MAILBOX_NAME, '\0', true, Mailbox.TYPE_INBOX);
        // Force the parent key to be ""no mailbox"" for the mail POP3 mailbox
        mailbox.mParentKey = Mailbox.NO_MAILBOX;
        if (mailbox.isSaved()) {
            mailbox.update(mContext, mailbox.toContentValues());
        } else {
            mailbox.save(mContext);
        }

        // Build default mailboxes as well, in case they're not already made.
        for (int type : DEFAULT_FOLDERS) {
            if (Mailbox.findMailboxOfType(mContext, mAccount.mId, type) == Mailbox.NO_MAILBOX) {
                String name = Controller.getMailboxServerName(mContext, type);
                Mailbox.newSystemMailbox(mAccount.mId, type, name).save(mContext);
            }
        }

        return new Folder[] { getFolder(POP3_MAILBOX_NAME) };
    }

    /**
     * Used by account setup to test if an account's settings are appropriate.  The definition
     * of ""checked"" here is simply, can you log into the account and does it meet some minimum set
     * of feature requirements?
     *
     * @throws MessagingException if there was some problem with the account
     */
    @Override
    public Bundle checkSettings() throws MessagingException {
        Pop3Folder folder = new Pop3Folder(POP3_MAILBOX_NAME);
        Bundle bundle = null;
        // Close any open or half-open connections - checkSettings should always be ""fresh""
        if (mTransport.isOpen()) {
            folder.close(false);
        }
        try {
            folder.open(OpenMode.READ_WRITE);
            bundle = folder.checkSettings();
        } finally {
            folder.close(false);    // false == don't expunge anything
        }
        return bundle;
    }

    class Pop3Folder extends Folder {
        private final HashMap<String, Pop3Message> mUidToMsgMap
                = new HashMap<String, Pop3Message>();
        private final HashMap<Integer, Pop3Message> mMsgNumToMsgMap
                = new HashMap<Integer, Pop3Message>();
        private final HashMap<String, Integer> mUidToMsgNumMap = new HashMap<String, Integer>();
        private final String mName;
        private int mMessageCount;
        private Pop3Capabilities mCapabilities;

        public Pop3Folder(String name) {
            if (name.equalsIgnoreCase(POP3_MAILBOX_NAME)) {
                mName = POP3_MAILBOX_NAME;
            } else {
                mName = name;
            }
        }

        /**
         * Used by account setup to test if an account's settings are appropriate.  Here, we run
         * an additional test to see if UIDL is supported on the server. If it's not we
         * can't service this account.
         *
         * @return Bundle containing validation data (code and, if appropriate, error message)
         * @throws MessagingException if the account is not going to be useable
         */
        public Bundle checkSettings() throws MessagingException {
            Bundle bundle = new Bundle();
            int result = MessagingException.NO_ERROR;
            if (!mCapabilities.uidl) {
                try {
                    UidlParser parser = new UidlParser();
                    executeSimpleCommand(""UIDL"");
                    // drain the entire output, so additional communications don't get confused.
                    String response;
                    while ((response = mTransport.readLine()) != null) {
                        parser.parseMultiLine(response);
                        if (parser.mEndOfMessage) {
                            break;
                        }
                    }
                } catch (IOException ioe) {
                    mTransport.close();
                    result = MessagingException.IOERROR;
                    bundle.putString(EmailServiceProxy.VALIDATE_BUNDLE_ERROR_MESSAGE,
                            ioe.getMessage());
                }
            }
            bundle.putInt(EmailServiceProxy.VALIDATE_BUNDLE_RESULT_CODE, result);
            return bundle;
        }

        @Override
        public synchronized void open(OpenMode mode) throws MessagingException {
            if (mTransport.isOpen()) {
                return;
            }

            if (!mName.equalsIgnoreCase(POP3_MAILBOX_NAME)) {
                throw new MessagingException(""Folder does not exist"");
            }

            try {
                mTransport.open();

                // Eat the banner
                executeSimpleCommand(null);

                mCapabilities = getCapabilities();

                if (mTransport.canTryTlsSecurity()) {
                    if (mCapabilities.stls) {
                        executeSimpleCommand(""STLS"");
                        mTransport.reopenTls();
                    } else {
                        if (Email.DEBUG) {
                            Log.d(Logging.LOG_TAG, ""TLS not supported but required"");
                        }
                        throw new MessagingException(MessagingException.TLS_REQUIRED);
                    }
                }

                try {
                    executeSensitiveCommand(""USER "" + mUsername, ""USER /redacted/"");
                    executeSensitiveCommand(""PASS "" + mPassword, ""PASS /redacted/"");
                } catch (MessagingException me) {
                    if (Email.DEBUG) {
                        Log.d(Logging.LOG_TAG, me.toString());
                    }
                    throw new AuthenticationFailedException(null, me);
                }
            } catch (IOException ioe) {
                mTransport.close();
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ioe.toString());
                }
                throw new MessagingException(MessagingException.IOERROR, ioe.toString());
            }

            Exception statException = null;
            try {
                String response = executeSimpleCommand(""STAT"");
                String[] parts = response.split("" "");
                if (parts.length < 2) {
                    statException = new IOException();
                } else {
                    mMessageCount = Integer.parseInt(parts[1]);
                }
            } catch (IOException ioe) {
                statException = ioe;
            } catch (NumberFormatException nfe) {
                statException = nfe;
            }
            if (statException != null) {
                mTransport.close();
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, statException.toString());
                }
                throw new MessagingException(""POP3 STAT"", statException);
            }
            mUidToMsgMap.clear();
            mMsgNumToMsgMap.clear();
            mUidToMsgNumMap.clear();
        }

        @Override
        public OpenMode getMode() {
            return OpenMode.READ_WRITE;
        }

        /**
         * Close the folder (and the transport below it).
         *
         * MUST NOT return any exceptions.
         *
         * @param expunge If true all deleted messages will be expunged (TODO - not implemented)
         */
        @Override
        public void close(boolean expunge) {
            try {
                executeSimpleCommand(""QUIT"");
            }
            catch (Exception e) {
                // ignore any problems here - just continue closing
            }
            mTransport.close();
        }

        @Override
        public String getName() {
            return mName;
        }

        // POP3 does not folder creation
        @Override
        public boolean canCreate(FolderType type) {
            return false;
        }

        @Override
        public boolean create(FolderType type) {
            return false;
        }

        @Override
        public boolean exists() {
            return mName.equalsIgnoreCase(POP3_MAILBOX_NAME);
        }

        @Override
        public int getMessageCount() {
            return mMessageCount;
        }

        @Override
        public int getUnreadMessageCount() {
            return -1;
        }

        @Override
        public Message getMessage(String uid) throws MessagingException {
            if (mUidToMsgNumMap.size() == 0) {
                try {
                    indexMsgNums(1, mMessageCount);
                } catch (IOException ioe) {
                    mTransport.close();
                    if (Email.DEBUG) {
                        Log.d(Logging.LOG_TAG, ""Unable to index during getMessage "" + ioe);
                    }
                    throw new MessagingException(""getMessages"", ioe);
                }
            }
            Pop3Message message = mUidToMsgMap.get(uid);
            return message;
        }

        @Override
        public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
                throws MessagingException {
            if (start < 1 || end < 1 || end < start) {
                throw new MessagingException(String.format(""Invalid message set %d %d"",
                        start, end));
            }
            try {
                indexMsgNums(start, end);
            } catch (IOException ioe) {
                mTransport.close();
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ioe.toString());
                }
                throw new MessagingException(""getMessages"", ioe);
            }
            ArrayList<Message> messages = new ArrayList<Message>();
            for (int msgNum = start; msgNum <= end; msgNum++) {
                Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                messages.add(message);
                if (listener != null) {
                    listener.messageRetrieved(message);
                }
            }
            return messages.toArray(new Message[messages.size()]);
        }

        /**
         * Ensures that the given message set (from start to end inclusive)
         * has been queried so that uids are available in the local cache.
         * @param start
         * @param end
         * @throws MessagingException
         * @throws IOException
         */
        private void indexMsgNums(int start, int end)
                throws MessagingException, IOException {
            int unindexedMessageCount = 0;
            for (int msgNum = start; msgNum <= end; msgNum++) {
                if (mMsgNumToMsgMap.get(msgNum) == null) {
                    unindexedMessageCount++;
                }
            }
            if (unindexedMessageCount == 0) {
                return;
            }
            UidlParser parser = new UidlParser();
            if (DEBUG_FORCE_SINGLE_LINE_UIDL ||
                    (unindexedMessageCount < 50 && mMessageCount > 5000)) {
                /*
                 * In extreme cases we'll do a UIDL command per message instead of a bulk
                 * download.
                 */
                for (int msgNum = start; msgNum <= end; msgNum++) {
                    Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                    if (message == null) {
                        String response = executeSimpleCommand(""UIDL "" + msgNum);
                        if (!parser.parseSingleLine(response)) {
                            throw new IOException();
                        }
                        message = new Pop3Message(parser.mUniqueId, this);
                        indexMessage(msgNum, message);
                    }
                }
            } else {
                String response = executeSimpleCommand(""UIDL"");
                while ((response = mTransport.readLine()) != null) {
                    if (!parser.parseMultiLine(response)) {
                        throw new IOException();
                    }
                    if (parser.mEndOfMessage) {
                        break;
                    }
                    int msgNum = parser.mMessageNumber;
                    if (msgNum >= start && msgNum <= end) {
                        Pop3Message message = mMsgNumToMsgMap.get(msgNum);
                        if (message == null) {
                            message = new Pop3Message(parser.mUniqueId, this);
                            indexMessage(msgNum, message);
                        }
                    }
                }
            }
        }

        private void indexUids(ArrayList<String> uids)
                throws MessagingException, IOException {
            HashSet<String> unindexedUids = new HashSet<String>();
            for (String uid : uids) {
                if (mUidToMsgMap.get(uid) == null) {
                    unindexedUids.add(uid);
                }
            }
            if (unindexedUids.size() == 0) {
                return;
            }
            /*
             * If we are missing uids in the cache the only sure way to
             * get them is to do a full UIDL list. A possible optimization
             * would be trying UIDL for the latest X messages and praying.
             */
            UidlParser parser = new UidlParser();
            String response = executeSimpleCommand(""UIDL"");
            while ((response = mTransport.readLine()) != null) {
                parser.parseMultiLine(response);
                if (parser.mEndOfMessage) {
                    break;
                }
                if (unindexedUids.contains(parser.mUniqueId)) {
                    Pop3Message message = mUidToMsgMap.get(parser.mUniqueId);
                    if (message == null) {
                        message = new Pop3Message(parser.mUniqueId, this);
                    }
                    indexMessage(parser.mMessageNumber, message);
                }
            }
        }

        /**
         * Simple parser class for UIDL messages.
         *
         * <p>NOTE:  In variance with RFC 1939, we allow multiple whitespace between the
         * message-number and unique-id fields.  This provides greater compatibility with some
         * non-compliant POP3 servers, e.g. mail.comcast.net.
         */
        /* package */ class UidlParser {

            /**
             * Caller can read back message-number from this field
             */
            public int mMessageNumber;
            /**
             * Caller can read back unique-id from this field
             */
            public String mUniqueId;
            /**
             * True if the response was ""end-of-message""
             */
            public boolean mEndOfMessage;
            /**
             * True if an error was reported
             */
            public boolean mErr;

            /**
             * Construct & Initialize
             */
            public UidlParser() {
                mErr = true;
            }

            /**
             * Parse a single-line response.  This is returned from a command of the form
             * ""UIDL msg-num"" and will be formatted as: ""+OK msg-num unique-id"" or
             * ""-ERR diagnostic text""
             *
             * @param response The string returned from the server
             * @return true if the string parsed as expected (e.g. no syntax problems)
             */
            public boolean parseSingleLine(String response) {
                mErr = false;
                if (response == null || response.length() == 0) {
                    return false;
                }
                char first = response.charAt(0);
                if (first == '+') {
                    String[] uidParts = response.split("" +"");
                    if (uidParts.length >= 3) {
                        try {
                            mMessageNumber = Integer.parseInt(uidParts[1]);
                        } catch (NumberFormatException nfe) {
                            return false;
                        }
                        mUniqueId = uidParts[2];
                        mEndOfMessage = true;
                        return true;
                    }
                } else if (first == '-') {
                    mErr = true;
                    return true;
                }
                return false;
            }

            /**
             * Parse a multi-line response.  This is returned from a command of the form
             * ""UIDL"" and will be formatted as: ""."" or ""msg-num unique-id"".
             *
             * @param response The string returned from the server
             * @return true if the string parsed as expected (e.g. no syntax problems)
             */
            public boolean parseMultiLine(String response) {
                mErr = false;
                if (response == null || response.length() == 0) {
                    return false;
                }
                char first = response.charAt(0);
                if (first == '.') {
                    mEndOfMessage = true;
                    return true;
                } else {
                    String[] uidParts = response.split("" +"");
                    if (uidParts.length >= 2) {
                        try {
                            mMessageNumber = Integer.parseInt(uidParts[0]);
                        } catch (NumberFormatException nfe) {
                            return false;
                        }
                        mUniqueId = uidParts[1];
                        mEndOfMessage = false;
                        return true;
                    }
                }
                return false;
            }
        }

        private void indexMessage(int msgNum, Pop3Message message) {
            mMsgNumToMsgMap.put(msgNum, message);
            mUidToMsgMap.put(message.getUid(), message);
            mUidToMsgNumMap.put(message.getUid(), msgNum);
        }

        @Override
        public Message[] getMessages(String[] uids, MessageRetrievalListener listener) {
            throw new UnsupportedOperationException(
                    ""Pop3Folder.getMessage(MessageRetrievalListener)"");
        }

        /**
         * Fetch the items contained in the FetchProfile into the given set of
         * Messages in as efficient a manner as possible.
         * @param messages
         * @param fp
         * @throws MessagingException
         */
        @Override
        public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
                throws MessagingException {
            if (messages == null || messages.length == 0) {
                return;
            }
            ArrayList<String> uids = new ArrayList<String>();
            for (Message message : messages) {
                uids.add(message.getUid());
            }
            try {
                indexUids(uids);
                if (fp.contains(FetchProfile.Item.ENVELOPE)) {
                    // Note: We never pass the listener for the ENVELOPE call, because we're going
                    // to be calling the listener below in the per-message loop.
                    fetchEnvelope(messages, null);
                }
            } catch (IOException ioe) {
                mTransport.close();
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ioe.toString());
                }
                throw new MessagingException(""fetch"", ioe);
            }
            for (int i = 0, count = messages.length; i < count; i++) {
                Message message = messages[i];
                if (!(message instanceof Pop3Message)) {
                    throw new MessagingException(""Pop3Store.fetch called with non-Pop3 Message"");
                }
                Pop3Message pop3Message = (Pop3Message)message;
                try {
                    if (fp.contains(FetchProfile.Item.BODY)) {
                        fetchBody(pop3Message, -1);
                    }
                    else if (fp.contains(FetchProfile.Item.BODY_SANE)) {
                        /*
                         * To convert the suggested download size we take the size
                         * divided by the maximum line size (76).
                         */
                        fetchBody(pop3Message,
                                FETCH_BODY_SANE_SUGGESTED_SIZE / 76);
                    }
                    else if (fp.contains(FetchProfile.Item.STRUCTURE)) {
                        /*
                         * If the user is requesting STRUCTURE we are required to set the body
                         * to null since we do not support the function.
                         */
                        pop3Message.setBody(null);
                    }
                    if (listener != null) {
                        listener.messageRetrieved(message);
                    }
                } catch (IOException ioe) {
                    mTransport.close();
                    if (Email.DEBUG) {
                        Log.d(Logging.LOG_TAG, ioe.toString());
                    }
                    throw new MessagingException(""Unable to fetch message"", ioe);
                }
            }
        }

        private void fetchEnvelope(Message[] messages,
                MessageRetrievalListener listener)  throws IOException, MessagingException {
            int unsizedMessages = 0;
            for (Message message : messages) {
                if (message.getSize() == -1) {
                    unsizedMessages++;
                }
            }
            if (unsizedMessages == 0) {
                return;
            }
            if (unsizedMessages < 50 && mMessageCount > 5000) {
                /*
                 * In extreme cases we'll do a command per message instead of a bulk request
                 * to hopefully save some time and bandwidth.
                 */
                for (int i = 0, count = messages.length; i < count; i++) {
                    Message message = messages[i];
                    if (!(message instanceof Pop3Message)) {
                        throw new MessagingException(
                                ""Pop3Store.fetch called with non-Pop3 Message"");
                    }
                    Pop3Message pop3Message = (Pop3Message)message;
                    String response = executeSimpleCommand(String.format(""LIST %d"",
                            mUidToMsgNumMap.get(pop3Message.getUid())));
                    try {
                        String[] listParts = response.split("" "");
                        int msgNum = Integer.parseInt(listParts[1]);
                        int msgSize = Integer.parseInt(listParts[2]);
                        pop3Message.setSize(msgSize);
                    } catch (NumberFormatException nfe) {
                        throw new IOException();
                    }
                    if (listener != null) {
                        listener.messageRetrieved(pop3Message);
                    }
                }
            } else {
                HashSet<String> msgUidIndex = new HashSet<String>();
                for (Message message : messages) {
                    msgUidIndex.add(message.getUid());
                }
                String response = executeSimpleCommand(""LIST"");
                while ((response = mTransport.readLine()) != null) {
                    if (response.equals(""."")) {
                        break;
                    }
                    Pop3Message pop3Message = null;
                    int msgSize = 0;
                    try {
                        String[] listParts = response.split("" "");
                        int msgNum = Integer.parseInt(listParts[0]);
                        msgSize = Integer.parseInt(listParts[1]);
                        pop3Message = mMsgNumToMsgMap.get(msgNum);
                    } catch (NumberFormatException nfe) {
                        throw new IOException();
                    }
                    if (pop3Message != null && msgUidIndex.contains(pop3Message.getUid())) {
                        pop3Message.setSize(msgSize);
                        if (listener != null) {
                            listener.messageRetrieved(pop3Message);
                        }
                    }
                }
            }
        }

        /**
         * Fetches the body of the given message, limiting the stored data
         * to the specified number of lines. If lines is -1 the entire message
         * is fetched. This is implemented with RETR for lines = -1 or TOP
         * for any other value. If the server does not support TOP it is
         * emulated with RETR and extra lines are thrown away.
         *
         * Note:  Some servers (e.g. live.com) don't support CAPA, but turn out to
         * support TOP after all.  For better performance on these servers, we'll always
         * probe TOP, and fall back to RETR when it's truly unsupported.
         *
         * @param message
         * @param lines
         */
        private void fetchBody(Pop3Message message, int lines)
                throws IOException, MessagingException {
            String response = null;
            int messageId = mUidToMsgNumMap.get(message.getUid());
            if (lines == -1) {
                // Fetch entire message
                response = executeSimpleCommand(String.format(""RETR %d"", messageId));
            } else {
                // Fetch partial message.  Try ""TOP"", and fall back to slower ""RETR"" if necessary
                try {
                    response = executeSimpleCommand(String.format(""TOP %d %d"", messageId,  lines));
                } catch (MessagingException me) {
                    response = executeSimpleCommand(String.format(""RETR %d"", messageId));
                }
            }
            if (response != null)  {
                try {
                    InputStream in = mTransport.getInputStream();
                    if (DEBUG_LOG_RAW_STREAM && Email.DEBUG) {
                        in = new LoggingInputStream(in);
                    }
                    message.parse(new Pop3ResponseInputStream(in));
                }
                catch (MessagingException me) {
                    /*
                     * If we're only downloading headers it's possible
                     * we'll get a broken MIME message which we're not
                     * real worried about. If we've downloaded the body
                     * and can't parse it we need to let the user know.
                     */
                    if (lines == -1) {
                        throw me;
                    }
                }
            }
        }

        @Override
        public Flag[] getPermanentFlags() {
            return PERMANENT_FLAGS;
        }

        @Override
        public void appendMessages(Message[] messages) {
        }

        @Override
        public void delete(boolean recurse) {
        }

        @Override
        public Message[] expunge() {
            return null;
        }

        @Override
        public void setFlags(Message[] messages, Flag[] flags, boolean value)
                throws MessagingException {
            if (!value || !Utility.arrayContains(flags, Flag.DELETED)) {
                /*
                 * The only flagging we support is setting the Deleted flag.
                 */
                return;
            }
            try {
                for (Message message : messages) {
                    executeSimpleCommand(String.format(""DELE %s"",
                            mUidToMsgNumMap.get(message.getUid())));
                }
            }
            catch (IOException ioe) {
                mTransport.close();
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ioe.toString());
                }
                throw new MessagingException(""setFlags()"", ioe);
            }
        }

        @Override
        public void copyMessages(Message[] msgs, Folder folder, MessageUpdateCallbacks callbacks) {
            throw new UnsupportedOperationException(""copyMessages is not supported in POP3"");
        }

//        private boolean isRoundTripModeSuggested() {
//            long roundTripMethodMs =
//                (uncachedMessageCount * 2 * mLatencyMs);
//            long bulkMethodMs =
//                    (mMessageCount * 58) / (mThroughputKbS * 1024 / 8) * 1000;
//        }

        private Pop3Capabilities getCapabilities() throws IOException {
            Pop3Capabilities capabilities = new Pop3Capabilities();
            try {
                String response = executeSimpleCommand(""CAPA"");
                while ((response = mTransport.readLine()) != null) {
                    if (response.equals(""."")) {
                        break;
                    }
                    if (response.equalsIgnoreCase(""STLS"")){
                        capabilities.stls = true;
                    }
                    else if (response.equalsIgnoreCase(""UIDL"")) {
                        capabilities.uidl = true;
                    }
                    else if (response.equalsIgnoreCase(""PIPELINING"")) {
                        capabilities.pipelining = true;
                    }
                    else if (response.equalsIgnoreCase(""USER"")) {
                        capabilities.user = true;
                    }
                    else if (response.equalsIgnoreCase(""TOP"")) {
                        capabilities.top = true;
                    }
                }
            }
            catch (MessagingException me) {
                /*
                 * The server may not support the CAPA command, so we just eat this Exception
                 * and allow the empty capabilities object to be returned.
                 */
            }
            return capabilities;
        }

        /**
         * Send a single command and wait for a single line response.  Reopens the connection,
         * if it is closed.  Leaves the connection open.
         *
         * @param command The command string to send to the server.
         * @return Returns the response string from the server.
         */
        private String executeSimpleCommand(String command) throws IOException, MessagingException {
            return executeSensitiveCommand(command, null);
        }

        /**
         * Send a single command and wait for a single line response.  Reopens the connection,
         * if it is closed.  Leaves the connection open.
         *
         * @param command The command string to send to the server.
         * @param sensitiveReplacement If the command includes sensitive data (e.g. authentication)
         * please pass a replacement string here (for logging).
         * @return Returns the response string from the server.
         */
        private String executeSensitiveCommand(String command, String sensitiveReplacement)
                throws IOException, MessagingException {
            open(OpenMode.READ_WRITE);

            if (command != null) {
                mTransport.writeLine(command, sensitiveReplacement);
            }

            String response = mTransport.readLine();

            if (response.length() > 1 && response.charAt(0) == '-') {
                throw new MessagingException(response);
            }

            return response;
        }

        @Override
        public boolean equals(Object o) {
            if (o instanceof Pop3Folder) {
                return ((Pop3Folder) o).mName.equals(mName);
            }
            return super.equals(o);
        }

        @Override
        @VisibleForTesting
        public boolean isOpen() {
            return mTransport.isOpen();
        }

        @Override
        public Message createMessage(String uid) {
            return new Pop3Message(uid, this);
        }

        @Override
        public Message[] getMessages(SearchParams params, MessageRetrievalListener listener) {
            return null;
        }
    }

    public static class Pop3Message extends MimeMessage {
        public Pop3Message(String uid, Pop3Folder folder) {
            mUid = uid;
            mFolder = folder;
            mSize = -1;
        }

        public void setSize(int size) {
            mSize = size;
        }

        @Override
        public void parse(InputStream in) throws IOException, MessagingException {
            super.parse(in);
        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }
    }

    /**
     * POP3 Capabilities as defined in RFC 2449.  This is not a complete list of CAPA
     * responses - just those that we use in this client.
     */
    class Pop3Capabilities {
        /** The STLS (start TLS) command is supported */
        public boolean stls;
        /** the TOP command (retrieve a partial message) is supported */
        public boolean top;
        /** USER and PASS login/auth commands are supported */
        public boolean user;
        /** the optional UIDL command is supported (unused) */
        public boolean uidl;
        /** the server is capable of accepting multiple commands at a time (unused) */
        public boolean pipelining;

        @Override
        public String toString() {
            return String.format(""STLS %b, TOP %b, USER %b, UIDL %b, PIPELINING %b"",
                    stls,
                    top,
                    user,
                    uidl,
                    pipelining);
        }
    }

    // TODO figure out what is special about this and merge it into MailTransport
    class Pop3ResponseInputStream extends InputStream {
        private final InputStream mIn;
        private boolean mStartOfLine = true;
        private boolean mFinished;

        public Pop3ResponseInputStream(InputStream in) {
            mIn = in;
        }

        @Override
        public int read() throws IOException {
            if (mFinished) {
                return -1;
            }
            int d = mIn.read();
            if (mStartOfLine && d == '.') {
                d = mIn.read();
                if (d == '\r') {
                    mFinished = true;
                    mIn.read();
                    return -1;
                }
            }

            mStartOfLine = (d == '\n');

            return d;
        }
    }
}
",True,268,1,1,8,66,3,22,L6
130,com.android.email.mail.store.ImapFolder.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store;

import android.content.Context;
import android.text.TextUtils;
import android.util.Base64DataException;
import android.util.Log;

import com.android.email.Email;
import com.android.email.mail.store.ImapStore.ImapException;
import com.android.email.mail.store.ImapStore.ImapMessage;
import com.android.email.mail.store.imap.ImapConstants;
import com.android.email.mail.store.imap.ImapElement;
import com.android.email.mail.store.imap.ImapList;
import com.android.email.mail.store.imap.ImapResponse;
import com.android.email.mail.store.imap.ImapString;
import com.android.email.mail.store.imap.ImapUtility;
import com.android.email.mail.transport.CountingOutputStream;
import com.android.email.mail.transport.EOLConvertingOutputStream;
import com.android.emailcommon.Logging;
import com.android.emailcommon.internet.BinaryTempFileBody;
import com.android.emailcommon.internet.MimeBodyPart;
import com.android.emailcommon.internet.MimeHeader;
import com.android.emailcommon.internet.MimeMultipart;
import com.android.emailcommon.internet.MimeUtility;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.Body;
import com.android.emailcommon.mail.FetchProfile;
import com.android.emailcommon.mail.Flag;
import com.android.emailcommon.mail.Folder;
import com.android.emailcommon.mail.Message;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.mail.Part;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.SearchParams;
import com.android.emailcommon.utility.Utility;
import com.google.common.annotations.VisibleForTesting;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;

class ImapFolder extends Folder {
    private final static Flag[] PERMANENT_FLAGS =
        { Flag.DELETED, Flag.SEEN, Flag.FLAGGED, Flag.ANSWERED };
    private static final int COPY_BUFFER_SIZE = 16*1024;

    private final ImapStore mStore;
    private final String mName;
    private int mMessageCount = -1;
    private ImapConnection mConnection;
    private OpenMode mMode;
    private boolean mExists;
    /** The local mailbox associated with this remote folder */
    Mailbox mMailbox;
    /** A set of hashes that can be used to track dirtiness */
    Object mHash[];

    /*package*/ ImapFolder(ImapStore store, String name) {
        mStore = store;
        mName = name;
    }

    private void destroyResponses() {
        if (mConnection != null) {
            mConnection.destroyResponses();
        }
    }

    @Override
    public void open(OpenMode mode)
            throws MessagingException {
        try {
            if (isOpen()) {
                if (mMode == mode) {
                    // Make sure the connection is valid.
                    // If it's not we'll close it down and continue on to get a new one.
                    try {
                        mConnection.executeSimpleCommand(ImapConstants.NOOP);
                        return;

                    } catch (IOException ioe) {
                        ioExceptionHandler(mConnection, ioe);
                    } finally {
                        destroyResponses();
                    }
                } else {
                    // Return the connection to the pool, if exists.
                    close(false);
                }
            }
            synchronized (this) {
                mConnection = mStore.getConnection();
            }
            // * FLAGS (\Answered \Flagged \Deleted \Seen \Draft NonJunk
            // $MDNSent)
            // * OK [PERMANENTFLAGS (\Answered \Flagged \Deleted \Seen \Draft
            // NonJunk $MDNSent \*)] Flags permitted.
            // * 23 EXISTS
            // * 0 RECENT
            // * OK [UIDVALIDITY 1125022061] UIDs valid
            // * OK [UIDNEXT 57576] Predicted next UID
            // 2 OK [READ-WRITE] Select completed.
            try {
                doSelect();
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            } finally {
                destroyResponses();
            }
        } catch (AuthenticationFailedException e) {
            // Don't cache this connection, so we're forced to try connecting/login again
            mConnection = null;
            close(false);
            throw e;
        } catch (MessagingException e) {
            mExists = false;
            close(false);
            throw e;
        }
    }

    @Override
    @VisibleForTesting
    public boolean isOpen() {
        return mExists && mConnection != null;
    }

    @Override
    public OpenMode getMode() {
        return mMode;
    }

    @Override
    public void close(boolean expunge) {
        // TODO implement expunge
        mMessageCount = -1;
        synchronized (this) {
            mStore.poolConnection(mConnection);
            mConnection = null;
        }
    }

    @Override
    public String getName() {
        return mName;
    }

    @Override
    public boolean exists() throws MessagingException {
        if (mExists) {
            return true;
        }
        /*
         * This method needs to operate in the unselected mode as well as the selected mode
         * so we must get the connection ourselves if it's not there. We are specifically
         * not calling checkOpen() since we don't care if the folder is open.
         */
        ImapConnection connection = null;
        synchronized(this) {
            if (mConnection == null) {
                connection = mStore.getConnection();
            } else {
                connection = mConnection;
            }
        }
        try {
            connection.executeSimpleCommand(String.format(
                    ImapConstants.STATUS + "" \""%s\"" ("" + ImapConstants.UIDVALIDITY + "")"",
                    ImapStore.encodeFolderName(mName, mStore.mPathPrefix)));
            mExists = true;
            return true;

        } catch (MessagingException me) {
            // Treat IOERROR messaging exception as IOException
            if (me.getExceptionType() == MessagingException.IOERROR) {
                throw me;
            }
            return false;

        } catch (IOException ioe) {
            throw ioExceptionHandler(connection, ioe);

        } finally {
            connection.destroyResponses();
            if (mConnection == null) {
                mStore.poolConnection(connection);
            }
        }
    }

    // IMAP supports folder creation
    @Override
    public boolean canCreate(FolderType type) {
        return true;
    }

    @Override
    public boolean create(FolderType type) throws MessagingException {
        /*
         * This method needs to operate in the unselected mode as well as the selected mode
         * so we must get the connection ourselves if it's not there. We are specifically
         * not calling checkOpen() since we don't care if the folder is open.
         */
        ImapConnection connection = null;
        synchronized(this) {
            if (mConnection == null) {
                connection = mStore.getConnection();
            } else {
                connection = mConnection;
            }
        }
        try {
            connection.executeSimpleCommand(String.format(ImapConstants.CREATE + "" \""%s\"""",
                    ImapStore.encodeFolderName(mName, mStore.mPathPrefix)));
            return true;

        } catch (MessagingException me) {
            return false;

        } catch (IOException ioe) {
            throw ioExceptionHandler(connection, ioe);

        } finally {
            connection.destroyResponses();
            if (mConnection == null) {
                mStore.poolConnection(connection);
            }
        }
    }

    @Override
    public void copyMessages(Message[] messages, Folder folder,
            MessageUpdateCallbacks callbacks) throws MessagingException {
        checkOpen();
        try {
            List<ImapResponse> responseList = mConnection.executeSimpleCommand(
                    String.format(ImapConstants.UID_COPY + "" %s \""%s\"""",
                            ImapStore.joinMessageUids(messages),
                            ImapStore.encodeFolderName(folder.getName(), mStore.mPathPrefix)));
            // Build a message map for faster UID matching
            HashMap<String, Message> messageMap = new HashMap<String, Message>();
            boolean handledUidPlus = false;
            for (Message m : messages) {
                messageMap.put(m.getUid(), m);
            }
            // Process response to get the new UIDs
            for (ImapResponse response : responseList) {
                // All ""BAD"" responses are bad. Only ""NO"", tagged responses are bad.
                if (response.isBad() || (response.isNo() && response.isTagged())) {
                    String responseText = response.getStatusResponseTextOrEmpty().getString();
                    throw new MessagingException(responseText);
                }
                // Skip untagged responses; they're just status
                if (!response.isTagged()) {
                    continue;
                }
                // No callback provided to report of UID changes; nothing more to do here
                // NOTE: We check this here to catch any server errors
                if (callbacks == null) {
                    continue;
                }
                ImapList copyResponse = response.getListOrEmpty(1);
                String responseCode = copyResponse.getStringOrEmpty(0).getString();
                if (ImapConstants.COPYUID.equals(responseCode)) {
                    handledUidPlus = true;
                    String origIdSet = copyResponse.getStringOrEmpty(2).getString();
                    String newIdSet = copyResponse.getStringOrEmpty(3).getString();
                    String[] origIdArray = ImapUtility.getImapSequenceValues(origIdSet);
                    String[] newIdArray = ImapUtility.getImapSequenceValues(newIdSet);
                    // There has to be a 1:1 mapping between old and new IDs
                    if (origIdArray.length != newIdArray.length) {
                        throw new MessagingException(""Set length mis-match; orig IDs \"""" +
                                origIdSet + ""\""  new IDs \"""" + newIdSet + ""\"""");
                    }
                    for (int i = 0; i < origIdArray.length; i++) {
                        final String id = origIdArray[i];
                        final Message m = messageMap.get(id);
                        if (m != null) {
                            callbacks.onMessageUidChange(m, newIdArray[i]);
                        }
                    }
                }
            }
            // If the server doesn't support UIDPLUS, try a different way to get the new UID(s)
            if (callbacks != null && !handledUidPlus) {
                ImapFolder newFolder = (ImapFolder)folder;
                try {
                    // Temporarily select the destination folder
                    newFolder.open(OpenMode.READ_WRITE);
                    // Do the search(es) ...
                    for (Message m : messages) {
                        String searchString = ""HEADER Message-Id \"""" + m.getMessageId() + ""\"""";
                        String[] newIdArray = newFolder.searchForUids(searchString);
                        if (newIdArray.length == 1) {
                            callbacks.onMessageUidChange(m, newIdArray[0]);
                        }
                    }
                } catch (MessagingException e) {
                    // Log, but, don't abort; failures here don't need to be propagated
                    Log.d(Logging.LOG_TAG, ""Failed to find message"", e);
                } finally {
                    newFolder.close(false);
                }
                // Re-select the original folder
                doSelect();
            }
        } catch (IOException ioe) {
            throw ioExceptionHandler(mConnection, ioe);
        } finally {
            destroyResponses();
        }
    }

    @Override
    public int getMessageCount() {
        return mMessageCount;
    }

    @Override
    public int getUnreadMessageCount() throws MessagingException {
        checkOpen();
        try {
            int unreadMessageCount = 0;
            List<ImapResponse> responses = mConnection.executeSimpleCommand(String.format(
                    ImapConstants.STATUS + "" \""%s\"" ("" + ImapConstants.UNSEEN + "")"",
                    ImapStore.encodeFolderName(mName, mStore.mPathPrefix)));
            // S: * STATUS mboxname (MESSAGES 231 UIDNEXT 44292)
            for (ImapResponse response : responses) {
                if (response.isDataResponse(0, ImapConstants.STATUS)) {
                    unreadMessageCount = response.getListOrEmpty(2)
                            .getKeyedStringOrEmpty(ImapConstants.UNSEEN).getNumberOrZero();
                }
            }
            return unreadMessageCount;
        } catch (IOException ioe) {
            throw ioExceptionHandler(mConnection, ioe);
        } finally {
            destroyResponses();
        }
    }

    @Override
    public void delete(boolean recurse) {
        throw new Error(""ImapStore.delete() not yet implemented"");
    }

    String[] getSearchUids(List<ImapResponse> responses) {
        // S: * SEARCH 2 3 6
        final ArrayList<String> uids = new ArrayList<String>();
        for (ImapResponse response : responses) {
            if (!response.isDataResponse(0, ImapConstants.SEARCH)) {
                continue;
            }
            // Found SEARCH response data
            for (int i = 1; i < response.size(); i++) {
                ImapString s = response.getStringOrEmpty(i);
                if (s.isString()) {
                    uids.add(s.getString());
                }
            }
        }
        return uids.toArray(Utility.EMPTY_STRINGS);
    }

    @VisibleForTesting
    String[] searchForUids(String searchCriteria) throws MessagingException {
        checkOpen();
        try {
            try {
                String command = ImapConstants.UID_SEARCH + "" "" + searchCriteria;
                return getSearchUids(mConnection.executeSimpleCommand(command));
            } catch (ImapException e) {
                Log.d(Logging.LOG_TAG, ""ImapException in search: "" + searchCriteria);
                return Utility.EMPTY_STRINGS; // not found;
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        } finally {
            destroyResponses();
        }
    }

    @Override
    @VisibleForTesting
    public Message getMessage(String uid) throws MessagingException {
        checkOpen();

        String[] uids = searchForUids(ImapConstants.UID + "" "" + uid);
        for (int i = 0; i < uids.length; i++) {
            if (uids[i].equals(uid)) {
                return new ImapMessage(uid, this);
            }
        }
        return null;
    }

    @VisibleForTesting
    protected static boolean isAsciiString(String str) {
        int len = str.length();
        for (int i = 0; i < len; i++) {
            char c = str.charAt(i);
            if (c >= 128) return false;
        }
        return true;
    }

    /**
     * Retrieve messages based on search parameters.  We search FROM, TO, CC, SUBJECT, and BODY
     * We send: SEARCH OR FROM ""foo"" (OR TO ""foo"" (OR CC ""foo"" (OR SUBJECT ""foo"" BODY ""foo""))), but
     * with the additional CHARSET argument and sending ""foo"" as a literal (e.g. {3}<CRLF>foo}
     */
    @Override
    @VisibleForTesting
    public Message[] getMessages(SearchParams params, MessageRetrievalListener listener)
            throws MessagingException {
        List<String> commands = new ArrayList<String>();
        String filter = params.mFilter;
        // All servers MUST accept US-ASCII, so we'll send this as the CHARSET unless we're really
        // dealing with a string that contains non-ascii characters
        String charset = ""US-ASCII"";
        if (!isAsciiString(filter)) {
            charset = ""UTF-8"";
        }
        // This is the length of the string in octets (bytes), formatted as a string literal {n}
        String octetLength = ""{"" + filter.getBytes().length + ""}"";
        // Break the command up into pieces ending with the string literal length
        commands.add(ImapConstants.UID_SEARCH + "" CHARSET "" + charset + "" OR FROM "" + octetLength);
        commands.add(filter + "" (OR TO "" + octetLength);
        commands.add(filter + "" (OR CC "" + octetLength);
        commands.add(filter + "" (OR SUBJECT "" + octetLength);
        commands.add(filter + "" BODY "" + octetLength);
        commands.add(filter + "")))"");
        return getMessagesInternal(complexSearchForUids(commands), listener);
    }

    /* package */ String[] complexSearchForUids(List<String> commands) throws MessagingException {
        checkOpen();
        try {
            try {
                return getSearchUids(mConnection.executeComplexCommand(commands, false));
            } catch (ImapException e) {
                return Utility.EMPTY_STRINGS; // not found;
            } catch (IOException ioe) {
                throw ioExceptionHandler(mConnection, ioe);
            }
        } finally {
            destroyResponses();
        }
    }

    @Override
    @VisibleForTesting
    public Message[] getMessages(int start, int end, MessageRetrievalListener listener)
            throws MessagingException {
        if (start < 1 || end < 1 || end < start) {
            throw new MessagingException(String.format(""Invalid range: %d %d"", start, end));
        }
        return getMessagesInternal(
                searchForUids(String.format(""%d:%d NOT DELETED"", start, end)), listener);
    }

    @Override
    @VisibleForTesting
    public Message[] getMessages(String[] uids, MessageRetrievalListener listener)
            throws MessagingException {
        if (uids == null) {
            uids = searchForUids(""1:* NOT DELETED"");
        }
        return getMessagesInternal(uids, listener);
    }

    public Message[] getMessagesInternal(String[] uids, MessageRetrievalListener listener) {
        final ArrayList<Message> messages = new ArrayList<Message>(uids.length);
        for (int i = 0; i < uids.length; i++) {
            final String uid = uids[i];
            final ImapMessage message = new ImapMessage(uid, this);
            messages.add(message);
            if (listener != null) {
                listener.messageRetrieved(message);
            }
        }
        return messages.toArray(Message.EMPTY_ARRAY);
    }

    @Override
    public void fetch(Message[] messages, FetchProfile fp, MessageRetrievalListener listener)
            throws MessagingException {
        try {
            fetchInternal(messages, fp, listener);
        } catch (RuntimeException e) { // Probably a parser error.
            Log.w(Logging.LOG_TAG, ""Exception detected: "" + e.getMessage());
            if (mConnection != null) {
                mConnection.logLastDiscourse();
            }
            throw e;
        }
    }

    public void fetchInternal(Message[] messages, FetchProfile fp,
            MessageRetrievalListener listener) throws MessagingException {
        if (messages.length == 0) {
            return;
        }
        checkOpen();
        HashMap<String, Message> messageMap = new HashMap<String, Message>();
        for (Message m : messages) {
            messageMap.put(m.getUid(), m);
        }

        /*
         * Figure out what command we are going to run:
         * FLAGS     - UID FETCH (FLAGS)
         * ENVELOPE  - UID FETCH (INTERNALDATE UID RFC822.SIZE FLAGS BODY.PEEK[
         *                            HEADER.FIELDS (date subject from content-type to cc)])
         * STRUCTURE - UID FETCH (BODYSTRUCTURE)
         * BODY_SANE - UID FETCH (BODY.PEEK[]<0.N>) where N = max bytes returned
         * BODY      - UID FETCH (BODY.PEEK[])
         * Part      - UID FETCH (BODY.PEEK[ID]) where ID = mime part ID
         */

        final LinkedHashSet<String> fetchFields = new LinkedHashSet<String>();

        fetchFields.add(ImapConstants.UID);
        if (fp.contains(FetchProfile.Item.FLAGS)) {
            fetchFields.add(ImapConstants.FLAGS);
        }
        if (fp.contains(FetchProfile.Item.ENVELOPE)) {
            fetchFields.add(ImapConstants.INTERNALDATE);
            fetchFields.add(ImapConstants.RFC822_SIZE);
            fetchFields.add(ImapConstants.FETCH_FIELD_HEADERS);
        }
        if (fp.contains(FetchProfile.Item.STRUCTURE)) {
            fetchFields.add(ImapConstants.BODYSTRUCTURE);
        }

        if (fp.contains(FetchProfile.Item.BODY_SANE)) {
            fetchFields.add(ImapConstants.FETCH_FIELD_BODY_PEEK_SANE);
        }
        if (fp.contains(FetchProfile.Item.BODY)) {
            fetchFields.add(ImapConstants.FETCH_FIELD_BODY_PEEK);
        }

        final Part fetchPart = fp.getFirstPart();
        if (fetchPart != null) {
            String[] partIds =
                    fetchPart.getHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA);
            if (partIds != null) {
                fetchFields.add(ImapConstants.FETCH_FIELD_BODY_PEEK_BARE
                        + ""["" + partIds[0] + ""]"");
            }
        }

        try {
            mConnection.sendCommand(String.format(
                    ImapConstants.UID_FETCH + "" %s (%s)"", ImapStore.joinMessageUids(messages),
                    Utility.combine(fetchFields.toArray(new String[fetchFields.size()]), ' ')
                    ), false);
            ImapResponse response;
            int messageNumber = 0;
            do {
                response = null;
                try {
                    response = mConnection.readResponse();

                    if (!response.isDataResponse(1, ImapConstants.FETCH)) {
                        continue; // Ignore
                    }
                    final ImapList fetchList = response.getListOrEmpty(2);
                    final String uid = fetchList.getKeyedStringOrEmpty(ImapConstants.UID)
                            .getString();
                    if (TextUtils.isEmpty(uid)) continue;

                    ImapMessage message = (ImapMessage) messageMap.get(uid);
                    if (message == null) continue;

                    if (fp.contains(FetchProfile.Item.FLAGS)) {
                        final ImapList flags =
                            fetchList.getKeyedListOrEmpty(ImapConstants.FLAGS);
                        for (int i = 0, count = flags.size(); i < count; i++) {
                            final ImapString flag = flags.getStringOrEmpty(i);
                            if (flag.is(ImapConstants.FLAG_DELETED)) {
                                message.setFlagInternal(Flag.DELETED, true);
                            } else if (flag.is(ImapConstants.FLAG_ANSWERED)) {
                                message.setFlagInternal(Flag.ANSWERED, true);
                            } else if (flag.is(ImapConstants.FLAG_SEEN)) {
                                message.setFlagInternal(Flag.SEEN, true);
                            } else if (flag.is(ImapConstants.FLAG_FLAGGED)) {
                                message.setFlagInternal(Flag.FLAGGED, true);
                            }
                        }
                    }
                    if (fp.contains(FetchProfile.Item.ENVELOPE)) {
                        final Date internalDate = fetchList.getKeyedStringOrEmpty(
                                ImapConstants.INTERNALDATE).getDateOrNull();
                        final int size = fetchList.getKeyedStringOrEmpty(
                                ImapConstants.RFC822_SIZE).getNumberOrZero();
                        final String header = fetchList.getKeyedStringOrEmpty(
                                ImapConstants.BODY_BRACKET_HEADER, true).getString();

                        message.setInternalDate(internalDate);
                        message.setSize(size);
                        message.parse(Utility.streamFromAsciiString(header));
                    }
                    if (fp.contains(FetchProfile.Item.STRUCTURE)) {
                        ImapList bs = fetchList.getKeyedListOrEmpty(
                                ImapConstants.BODYSTRUCTURE);
                        if (!bs.isEmpty()) {
                            try {
                                parseBodyStructure(bs, message, ImapConstants.TEXT);
                            } catch (MessagingException e) {
                                if (Logging.LOGD) {
                                    Log.v(Logging.LOG_TAG, ""Error handling message"", e);
                                }
                                message.setBody(null);
                            }
                        }
                    }
                    if (fp.contains(FetchProfile.Item.BODY)
                            || fp.contains(FetchProfile.Item.BODY_SANE)) {
                        // Body is keyed by ""BODY[]..."".
                        // Previously used ""BODY[..."" but this can be confused with ""BODY[HEADER...""
                        // TODO Should we accept ""RFC822"" as well??
                        ImapString body = fetchList.getKeyedStringOrEmpty(""BODY[]"", true);
                        String bodyText = body.getString();
                        InputStream bodyStream = body.getAsStream();
                        message.parse(bodyStream);
                    }
                    if (fetchPart != null && fetchPart.getSize() > 0) {
                        InputStream bodyStream =
                                fetchList.getKeyedStringOrEmpty(""BODY["", true).getAsStream();
                        String contentType = fetchPart.getContentType();
                        String contentTransferEncoding = fetchPart.getHeader(
                                MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING)[0];

                        // TODO Don't create 2 temp files.
                        // decodeBody creates BinaryTempFileBody, but we could avoid this
                        // if we implement ImapStringBody.
                        // (We'll need to share a temp file.  Protect it with a ref-count.)
                        fetchPart.setBody(decodeBody(bodyStream, contentTransferEncoding,
                                fetchPart.getSize(), listener));
                    }

                    if (listener != null) {
                        listener.messageRetrieved(message);
                    }
                } finally {
                    destroyResponses();
                }
            } while (!response.isTagged());
        } catch (IOException ioe) {
            throw ioExceptionHandler(mConnection, ioe);
        }
    }

    /**
     * Removes any content transfer encoding from the stream and returns a Body.
     * This code is taken/condensed from MimeUtility.decodeBody
     */
    private Body decodeBody(InputStream in, String contentTransferEncoding, int size,
            MessageRetrievalListener listener) throws IOException {
        // Get a properly wrapped input stream
        in = MimeUtility.getInputStreamForContentTransferEncoding(in, contentTransferEncoding);
        BinaryTempFileBody tempBody = new BinaryTempFileBody();
        OutputStream out = tempBody.getOutputStream();
        try {
            byte[] buffer = new byte[COPY_BUFFER_SIZE];
            int n = 0;
            int count = 0;
            while (-1 != (n = in.read(buffer))) {
                out.write(buffer, 0, n);
                count += n;
                if (listener != null) {
                    listener.loadAttachmentProgress(count * 100 / size);
                }
            }
        } catch (Base64DataException bde) {
            String warning = ""\n\n"" + Email.getMessageDecodeErrorString();
            out.write(warning.getBytes());
        } finally {
            out.close();
        }
        return tempBody;
    }

    @Override
    public Flag[] getPermanentFlags() {
        return PERMANENT_FLAGS;
    }

    /**
     * Handle any untagged responses that the caller doesn't care to handle themselves.
     * @param responses
     */
    private void handleUntaggedResponses(List<ImapResponse> responses) {
        for (ImapResponse response : responses) {
            handleUntaggedResponse(response);
        }
    }

    /**
     * Handle an untagged response that the caller doesn't care to handle themselves.
     * @param response
     */
    private void handleUntaggedResponse(ImapResponse response) {
        if (response.isDataResponse(1, ImapConstants.EXISTS)) {
            mMessageCount = response.getStringOrEmpty(0).getNumberOrZero();
        }
    }

    private static void parseBodyStructure(ImapList bs, Part part, String id)
            throws MessagingException {
        if (bs.getElementOrNone(0).isList()) {
            /*
             * This is a multipart/*
             */
            MimeMultipart mp = new MimeMultipart();
            for (int i = 0, count = bs.size(); i < count; i++) {
                ImapElement e = bs.getElementOrNone(i);
                if (e.isList()) {
                    /*
                     * For each part in the message we're going to add a new BodyPart and parse
                     * into it.
                     */
                    MimeBodyPart bp = new MimeBodyPart();
                    if (id.equals(ImapConstants.TEXT)) {
                        parseBodyStructure(bs.getListOrEmpty(i), bp, Integer.toString(i + 1));

                    } else {
                        parseBodyStructure(bs.getListOrEmpty(i), bp, id + ""."" + (i + 1));
                    }
                    mp.addBodyPart(bp);

                } else {
                    if (e.isString()) {
                        mp.setSubType(bs.getStringOrEmpty(i).getString().toLowerCase());
                    }
                    break; // Ignore the rest of the list.
                }
            }
            part.setBody(mp);
        } else {
            /*
             * This is a body. We need to add as much information as we can find out about
             * it to the Part.
             */

            /*
             body type
             body subtype
             body parameter parenthesized list
             body id
             body description
             body encoding
             body size
             */

            final ImapString type = bs.getStringOrEmpty(0);
            final ImapString subType = bs.getStringOrEmpty(1);
            final String mimeType =
                    (type.getString() + ""/"" + subType.getString()).toLowerCase();

            final ImapList bodyParams = bs.getListOrEmpty(2);
            final ImapString cid = bs.getStringOrEmpty(3);
            final ImapString encoding = bs.getStringOrEmpty(5);
            final int size = bs.getStringOrEmpty(6).getNumberOrZero();

            if (MimeUtility.mimeTypeMatches(mimeType, MimeUtility.MIME_TYPE_RFC822)) {
                // A body type of type MESSAGE and subtype RFC822
                // contains, immediately after the basic fields, the
                // envelope structure, body structure, and size in
                // text lines of the encapsulated message.
                // [MESSAGE, RFC822, [NAME, filename.eml], NIL, NIL, 7BIT, 5974, NIL,
                //     [INLINE, [FILENAME*0, Fwd: Xxx..., FILENAME*1, filename.eml]], NIL]
                /*
                 * This will be caught by fetch and handled appropriately.
                 */
                throw new MessagingException(""BODYSTRUCTURE "" + MimeUtility.MIME_TYPE_RFC822
                        + "" not yet supported."");
            }

            /*
             * Set the content type with as much information as we know right now.
             */
            final StringBuilder contentType = new StringBuilder(mimeType);

            /*
             * If there are body params we might be able to get some more information out
             * of them.
             */
            for (int i = 1, count = bodyParams.size(); i < count; i += 2) {

                // TODO We need to convert "" into %22, but
                // because MimeUtility.getHeaderParameter doesn't recognize it,
                // we can't fix it for now.
                contentType.append(String.format("";\n %s=\""%s\"""",
                        bodyParams.getStringOrEmpty(i - 1).getString(),
                        bodyParams.getStringOrEmpty(i).getString()));
            }

            part.setHeader(MimeHeader.HEADER_CONTENT_TYPE, contentType.toString());

            // Extension items
            final ImapList bodyDisposition;

            if (type.is(ImapConstants.TEXT) && bs.getElementOrNone(9).isList()) {
                // If media-type is TEXT, 9th element might be: [body-fld-lines] := number
                // So, if it's not a list, use 10th element.
                // (Couldn't find evidence in the RFC if it's ALWAYS 10th element.)
                bodyDisposition = bs.getListOrEmpty(9);
            } else {
                bodyDisposition = bs.getListOrEmpty(8);
            }

            final StringBuilder contentDisposition = new StringBuilder();

            if (bodyDisposition.size() > 0) {
                final String bodyDisposition0Str =
                        bodyDisposition.getStringOrEmpty(0).getString().toLowerCase();
                if (!TextUtils.isEmpty(bodyDisposition0Str)) {
                    contentDisposition.append(bodyDisposition0Str);
                }

                final ImapList bodyDispositionParams = bodyDisposition.getListOrEmpty(1);
                if (!bodyDispositionParams.isEmpty()) {
                    /*
                     * If there is body disposition information we can pull some more
                     * information about the attachment out.
                     */
                    for (int i = 1, count = bodyDispositionParams.size(); i < count; i += 2) {

                        // TODO We need to convert "" into %22.  See above.
                        contentDisposition.append(String.format("";\n %s=\""%s\"""",
                                bodyDispositionParams.getStringOrEmpty(i - 1)
                                        .getString().toLowerCase(),
                                bodyDispositionParams.getStringOrEmpty(i).getString()));
                    }
                }
            }

            if ((size > 0)
                    && (MimeUtility.getHeaderParameter(contentDisposition.toString(), ""size"")
                            == null)) {
                contentDisposition.append(String.format("";\n size=%d"", size));
            }

            if (contentDisposition.length() > 0) {
                /*
                 * Set the content disposition containing at least the size. Attachment
                 * handling code will use this down the road.
                 */
                part.setHeader(MimeHeader.HEADER_CONTENT_DISPOSITION,
                        contentDisposition.toString());
            }

            /*
             * Set the Content-Transfer-Encoding header. Attachment code will use this
             * to parse the body.
             */
            if (!encoding.isEmpty()) {
                part.setHeader(MimeHeader.HEADER_CONTENT_TRANSFER_ENCODING,
                        encoding.getString());
            }

            /*
             * Set the Content-ID header.
             */
            if (!cid.isEmpty()) {
                part.setHeader(MimeHeader.HEADER_CONTENT_ID, cid.getString());
            }

            if (size > 0) {
                if (part instanceof ImapMessage) {
                    ((ImapMessage) part).setSize(size);
                } else if (part instanceof MimeBodyPart) {
                    ((MimeBodyPart) part).setSize(size);
                } else {
                    throw new MessagingException(""Unknown part type "" + part.toString());
                }
            }
            part.setHeader(MimeHeader.HEADER_ANDROID_ATTACHMENT_STORE_DATA, id);
        }

    }

    /**
     * Appends the given messages to the selected folder. This implementation also determines
     * the new UID of the given message on the IMAP server and sets the Message's UID to the
     * new server UID.
     */
    @Override
    public void appendMessages(Message[] messages) throws MessagingException {
        checkOpen();
        try {
            for (Message message : messages) {
                // Create output count
                CountingOutputStream out = new CountingOutputStream();
                EOLConvertingOutputStream eolOut = new EOLConvertingOutputStream(out);
                message.writeTo(eolOut);
                eolOut.flush();
                // Create flag list (most often this will be ""\SEEN"")
                String flagList = """";
                Flag[] flags = message.getFlags();
                if (flags.length > 0) {
                    StringBuilder sb = new StringBuilder();
                    for (int i = 0, count = flags.length; i < count; i++) {
                        Flag flag = flags[i];
                        if (flag == Flag.SEEN) {
                            sb.append("" "" + ImapConstants.FLAG_SEEN);
                        } else if (flag == Flag.FLAGGED) {
                            sb.append("" "" + ImapConstants.FLAG_FLAGGED);
                        }
                    }
                    if (sb.length() > 0) {
                        flagList = sb.substring(1);
                    }
                }

                mConnection.sendCommand(
                        String.format(ImapConstants.APPEND + "" \""%s\"" (%s) {%d}"",
                                ImapStore.encodeFolderName(mName, mStore.mPathPrefix),
                                flagList,
                                out.getCount()), false);
                ImapResponse response;
                do {
                    response = mConnection.readResponse();
                    if (response.isContinuationRequest()) {
                        eolOut = new EOLConvertingOutputStream(
                                mConnection.mTransport.getOutputStream());
                        message.writeTo(eolOut);
                        eolOut.write('\r');
                        eolOut.write('\n');
                        eolOut.flush();
                    } else if (!response.isTagged()) {
                        handleUntaggedResponse(response);
                    }
                } while (!response.isTagged());

                // TODO Why not check the response?

                /*
                 * Try to recover the UID of the message from an APPENDUID response.
                 * e.g. 11 OK [APPENDUID 2 238268] APPEND completed
                 */
                final ImapList appendList = response.getListOrEmpty(1);
                if ((appendList.size() >= 3) && appendList.is(0, ImapConstants.APPENDUID)) {
                    String serverUid = appendList.getStringOrEmpty(2).getString();
                    if (!TextUtils.isEmpty(serverUid)) {
                        message.setUid(serverUid);
                        continue;
                    }
                }

                /*
                 * Try to find the UID of the message we just appended using the
                 * Message-ID header.  If there are more than one response, take the
                 * last one, as it's most likely the newest (the one we just uploaded).
                 */
                String messageId = message.getMessageId();
                if (messageId == null || messageId.length() == 0) {
                    continue;
                }
                // Most servers don't care about parenthesis in the search query [and, some
                // fail to work if they are used]
                String[] uids = searchForUids(String.format(""HEADER MESSAGE-ID %s"", messageId));
                if (uids.length > 0) {
                    message.setUid(uids[0]);
                }
                // However, there's at least one server [AOL] that fails to work unless there
                // are parenthesis, so, try this as a last resort
                uids = searchForUids(String.format(""(HEADER MESSAGE-ID %s)"", messageId));
                if (uids.length > 0) {
                    message.setUid(uids[0]);
                }
            }
        } catch (IOException ioe) {
            throw ioExceptionHandler(mConnection, ioe);
        } finally {
            destroyResponses();
        }
    }

    @Override
    public Message[] expunge() throws MessagingException {
        checkOpen();
        try {
            handleUntaggedResponses(mConnection.executeSimpleCommand(ImapConstants.EXPUNGE));
        } catch (IOException ioe) {
            throw ioExceptionHandler(mConnection, ioe);
        } finally {
            destroyResponses();
        }
        return null;
    }

    @Override
    public void setFlags(Message[] messages, Flag[] flags, boolean value)
            throws MessagingException {
        checkOpen();

        String allFlags = """";
        if (flags.length > 0) {
            StringBuilder flagList = new StringBuilder();
            for (int i = 0, count = flags.length; i < count; i++) {
                Flag flag = flags[i];
                if (flag == Flag.SEEN) {
                    flagList.append("" "" + ImapConstants.FLAG_SEEN);
                } else if (flag == Flag.DELETED) {
                    flagList.append("" "" + ImapConstants.FLAG_DELETED);
                } else if (flag == Flag.FLAGGED) {
                    flagList.append("" "" + ImapConstants.FLAG_FLAGGED);
                } else if (flag == Flag.ANSWERED) {
                    flagList.append("" "" + ImapConstants.FLAG_ANSWERED);
                }
            }
            allFlags = flagList.substring(1);
        }
        try {
            mConnection.executeSimpleCommand(String.format(
                    ImapConstants.UID_STORE + "" %s %s"" + ImapConstants.FLAGS_SILENT + "" (%s)"",
                    ImapStore.joinMessageUids(messages),
                    value ? ""+"" : ""-"",
                    allFlags));

        } catch (IOException ioe) {
            throw ioExceptionHandler(mConnection, ioe);
        } finally {
            destroyResponses();
        }
    }

    /**
     * Persists this folder. We will always perform the proper database operation (e.g.
     * 'save' or 'update'). As an optimization, if a folder has not been modified, no
     * database operations are performed.
     */
    void save(Context context) {
        final Mailbox mailbox = mMailbox;
        if (!mailbox.isSaved()) {
            mailbox.save(context);
            mHash = mailbox.getHashes();
        } else {
            Object[] hash = mailbox.getHashes();
            if (!Arrays.equals(mHash, hash)) {
                mailbox.update(context, mailbox.toContentValues());
                mHash = hash;  // Save updated hash
            }
        }
    }

    /**
     * Selects the folder for use. Before performing any operations on this folder, it
     * must be selected.
     */
    private void doSelect() throws IOException, MessagingException {
        List<ImapResponse> responses = mConnection.executeSimpleCommand(
                String.format(ImapConstants.SELECT + "" \""%s\"""",
                        ImapStore.encodeFolderName(mName, mStore.mPathPrefix)));

        // Assume the folder is opened read-write; unless we are notified otherwise
        mMode = OpenMode.READ_WRITE;
        int messageCount = -1;
        for (ImapResponse response : responses) {
            if (response.isDataResponse(1, ImapConstants.EXISTS)) {
                messageCount = response.getStringOrEmpty(0).getNumberOrZero();
            } else if (response.isOk()) {
                final ImapString responseCode = response.getResponseCodeOrEmpty();
                if (responseCode.is(ImapConstants.READ_ONLY)) {
                    mMode = OpenMode.READ_ONLY;
                } else if (responseCode.is(ImapConstants.READ_WRITE)) {
                    mMode = OpenMode.READ_WRITE;
                }
            } else if (response.isTagged()) { // Not OK
                throw new MessagingException(""Can't open mailbox: ""
                        + response.getStatusResponseTextOrEmpty());
            }
        }
        if (messageCount == -1) {
            throw new MessagingException(""Did not find message count during select"");
        }
        mMessageCount = messageCount;
        mExists = true;
    }

    private void checkOpen() throws MessagingException {
        if (!isOpen()) {
            throw new MessagingException(""Folder "" + mName + "" is not open."");
        }
    }

    private MessagingException ioExceptionHandler(ImapConnection connection, IOException ioe) {
        if (Email.DEBUG) {
            Log.d(Logging.LOG_TAG, ""IO Exception detected: "", ioe);
        }
        connection.close();
        if (connection == mConnection) {
            mConnection = null; // To prevent close() from returning the connection to the pool.
            close(false);
        }
        return new MessagingException(""IO Error"", ioe);
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof ImapFolder) {
            return ((ImapFolder)o).mName.equals(mName);
        }
        return super.equals(o);
    }

    @Override
    public Message createMessage(String uid) {
        return new ImapMessage(uid, this);
    }
}
",True,268,1,1,8,64,2,32,L6
131,com.android.email.mail.store.ServiceStore.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store;

import android.content.Context;
import android.os.Bundle;
import android.os.RemoteException;

import com.android.email.mail.Store;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.service.IEmailService;

/**
 * Base class for service-based stores
 */
public abstract class ServiceStore extends Store {
    protected final HostAuth mHostAuth;

    protected abstract IEmailService getService();

    /**
     * Creates a new store for the given account.
     */
    public ServiceStore(Account account, Context context) throws MessagingException {
        mContext = context;
        mHostAuth = account.getOrCreateHostAuthRecv(mContext);
    }

    @Override
    public Bundle checkSettings() throws MessagingException {
        /**
         * Here's where we check the settings
         * @throws MessagingException if we can't authenticate the account
         */
        try {
            IEmailService svc = getService();
            // Use a longer timeout for the validate command.  Note that the instanceof check
            // shouldn't be necessary; we'll do it anyway, just to be safe
            if (svc instanceof EmailServiceProxy) {
                ((EmailServiceProxy)svc).setTimeout(90);
            }
            return svc.validate(mHostAuth);
        } catch (RemoteException e) {
            throw new MessagingException(""Call to validate generated an exception"", e);
        }
    }

    /**
     * We handle AutoDiscover here, wrapping the EmailService call. The service call returns a
     * HostAuth and we return null if there was a service issue
     */
    @Override
    public Bundle autoDiscover(Context context, String username, String password) {
        try {
            return getService().autoDiscover(username, password);
        } catch (RemoteException e) {
            return null;
        }
    }
}
",False,267,0,0,10,63,1,6,L6
132,com.android.email.mail.store.ImapConnection.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store;

import android.text.TextUtils;
import android.util.Log;

import com.android.email.Email;
import com.android.email.mail.Transport;
import com.android.email.mail.store.ImapStore.ImapException;
import com.android.email.mail.store.imap.ImapConstants;
import com.android.email.mail.store.imap.ImapList;
import com.android.email.mail.store.imap.ImapResponse;
import com.android.email.mail.store.imap.ImapResponseParser;
import com.android.email.mail.store.imap.ImapUtility;
import com.android.email.mail.transport.DiscourseLogger;
import com.android.email.mail.transport.MailTransport;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.CertificateValidationException;
import com.android.emailcommon.mail.MessagingException;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import javax.net.ssl.SSLException;

/**
 * A cacheable class that stores the details for a single IMAP connection.
 */
class ImapConnection {
    // Always check in FALSE
    private static final boolean DEBUG_FORCE_SEND_ID = false;

    /** ID capability per RFC 2971*/
    public static final int CAPABILITY_ID        = 1 << 0;
    /** NAMESPACE capability per RFC 2342 */
    public static final int CAPABILITY_NAMESPACE = 1 << 1;
    /** STARTTLS capability per RFC 3501 */
    public static final int CAPABILITY_STARTTLS  = 1 << 2;
    /** UIDPLUS capability per RFC 4315 */
    public static final int CAPABILITY_UIDPLUS   = 1 << 3;

    /** The capabilities supported; a set of CAPABILITY_* values. */
    private int mCapabilities;
    private static final String IMAP_REDACTED_LOG = ""[IMAP command redacted]"";
    Transport mTransport;
    private ImapResponseParser mParser;
    private ImapStore mImapStore;
    private String mUsername;
    private String mLoginPhrase;
    private String mIdPhrase = null;
    /** # of command/response lines to log upon crash. */
    private static final int DISCOURSE_LOGGER_SIZE = 64;
    private final DiscourseLogger mDiscourse = new DiscourseLogger(DISCOURSE_LOGGER_SIZE);
    /**
     * Next tag to use.  All connections associated to the same ImapStore instance share the same
     * counter to make tests simpler.
     * (Some of the tests involve multiple connections but only have a single counter to track the
     * tag.)
     */
    private final AtomicInteger mNextCommandTag = new AtomicInteger(0);


    // Keep others from instantiating directly
    ImapConnection(ImapStore store, String username, String password) {
        setStore(store, username, password);
    }

    void setStore(ImapStore store, String username, String password) {
        if (username != null && password != null) {
            mUsername = username;

            // build the LOGIN string once (instead of over-and-over again.)
            // apply the quoting here around the built-up password
            mLoginPhrase = ImapConstants.LOGIN + "" "" + mUsername + "" ""
                    + ImapUtility.imapQuoted(password);
        }
        mImapStore = store;
    }
    void open() throws IOException, MessagingException {
        if (mTransport != null && mTransport.isOpen()) {
            return;
        }

        try {
            // copy configuration into a clean transport, if necessary
            if (mTransport == null) {
                mTransport = mImapStore.cloneTransport();
            }

            mTransport.open();
            mTransport.setSoTimeout(MailTransport.SOCKET_READ_TIMEOUT);

            createParser();

            // BANNER
            mParser.readResponse();

            // CAPABILITY
            ImapResponse capabilities = queryCapabilities();

            boolean hasStartTlsCapability =
                capabilities.contains(ImapConstants.STARTTLS);

            // TLS
            ImapResponse newCapabilities = doStartTls(hasStartTlsCapability);
            if (newCapabilities != null) {
                capabilities = newCapabilities;
            }

            // NOTE: An IMAP response MUST be processed before issuing any new IMAP
            // requests. Subsequent requests may destroy previous response data. As
            // such, we save away capability information here for future use.
            setCapabilities(capabilities);
            String capabilityString = capabilities.flatten();

            // ID
            doSendId(isCapable(CAPABILITY_ID), capabilityString);

            // LOGIN
            doLogin();

            // NAMESPACE (only valid in the Authenticated state)
            doGetNamespace(isCapable(CAPABILITY_NAMESPACE));

            // Gets the path separator from the server
            doGetPathSeparator();

            mImapStore.ensurePrefixIsValid();
        } catch (SSLException e) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, e.toString());
            }
            throw new CertificateValidationException(e.getMessage(), e);
        } catch (IOException ioe) {
            // NOTE:  Unlike similar code in POP3, I'm going to rethrow as-is.  There is a lot
            // of other code here that catches IOException and I don't want to break it.
            // This catch is only here to enhance logging of connection-time issues.
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ioe.toString());
            }
            throw ioe;
        } finally {
            destroyResponses();
        }
    }

    /**
     * Closes the connection and releases all resources. This connection can not be used again
     * until {@link #setStore(ImapStore, String, String)} is called.
     */
    void close() {
        if (mTransport != null) {
            mTransport.close();
            mTransport = null;
        }
        destroyResponses();
        mParser = null;
        mImapStore = null;
    }

    /**
     * Returns whether or not the specified capability is supported by the server.
     */
    private boolean isCapable(int capability) {
        return (mCapabilities & capability) != 0;
    }

    /**
     * Sets the capability flags according to the response provided by the server.
     * Note: We only set the capability flags that we are interested in. There are many IMAP
     * capabilities that we do not track.
     */
    private void setCapabilities(ImapResponse capabilities) {
        if (capabilities.contains(ImapConstants.ID)) {
            mCapabilities |= CAPABILITY_ID;
        }
        if (capabilities.contains(ImapConstants.NAMESPACE)) {
            mCapabilities |= CAPABILITY_NAMESPACE;
        }
        if (capabilities.contains(ImapConstants.UIDPLUS)) {
            mCapabilities |= CAPABILITY_UIDPLUS;
        }
        if (capabilities.contains(ImapConstants.STARTTLS)) {
            mCapabilities |= CAPABILITY_STARTTLS;
        }
    }

    /**
     * Create an {@link ImapResponseParser} from {@code mTransport.getInputStream()} and
     * set it to {@link #mParser}.
     *
     * If we already have an {@link ImapResponseParser}, we
     * {@link #destroyResponses()} and throw it away.
     */
    private void createParser() {
        destroyResponses();
        mParser = new ImapResponseParser(mTransport.getInputStream(), mDiscourse);
    }

    void destroyResponses() {
        if (mParser != null) {
            mParser.destroyResponses();
        }
    }

    boolean isTransportOpenForTest() {
        return mTransport != null ? mTransport.isOpen() : false;
    }

    ImapResponse readResponse() throws IOException, MessagingException {
        return mParser.readResponse();
    }

    /**
     * Send a single command to the server.  The command will be preceded by an IMAP command
     * tag and followed by \r\n (caller need not supply them).
     *
     * @param command The command to send to the server
     * @param sensitive If true, the command will not be logged
     * @return Returns the command tag that was sent
     */
    String sendCommand(String command, boolean sensitive)
        throws MessagingException, IOException {
        open();
        String tag = Integer.toString(mNextCommandTag.incrementAndGet());
        String commandToSend = tag + "" "" + command;
        mTransport.writeLine(commandToSend, sensitive ? IMAP_REDACTED_LOG : null);
        mDiscourse.addSentCommand(sensitive ? IMAP_REDACTED_LOG : commandToSend);
        return tag;
    }


    /**
     * Send a single, complex command to the server.  The command will be preceded by an IMAP
     * command tag and followed by \r\n (caller need not supply them).  After each piece of the
     * command, a response will be read which MUST be a continuation request.
     *
     * @param commands An array of Strings comprising the command to be sent to the server
     * @return Returns the command tag that was sent
     */
    String sendComplexCommand(List<String> commands, boolean sensitive) throws MessagingException,
            IOException {
        open();
        String tag = Integer.toString(mNextCommandTag.incrementAndGet());
        int len = commands.size();
        for (int i = 0; i < len; i++) {
            String commandToSend = commands.get(i);
            // The first part of the command gets the tag
            if (i == 0) {
                commandToSend = tag + "" "" + commandToSend;
            } else {
                // Otherwise, read the response from the previous part of the command
                ImapResponse response = readResponse();
                // If it isn't a continuation request, that's an error
                if (!response.isContinuationRequest()) {
                    throw new MessagingException(""Expected continuation request"");
                }
            }
            // Send the command
            mTransport.writeLine(commandToSend, null);
            mDiscourse.addSentCommand(sensitive ? IMAP_REDACTED_LOG : commandToSend);
        }
        return tag;
    }

    List<ImapResponse> executeSimpleCommand(String command) throws IOException,
            MessagingException {
        return executeSimpleCommand(command, false);
    }

    /**
     * Read and return all of the responses from the most recent command sent to the server
     *
     * @return a list of ImapResponses
     * @throws IOException
     * @throws MessagingException
     */
    List<ImapResponse> getCommandResponses() throws IOException, MessagingException {
        ArrayList<ImapResponse> responses = new ArrayList<ImapResponse>();
        ImapResponse response;
        do {
            response = mParser.readResponse();
            responses.add(response);
        } while (!response.isTagged());
        if (!response.isOk()) {
            final String toString = response.toString();
            final String alert = response.getAlertTextOrEmpty().getString();
            destroyResponses();
            throw new ImapException(toString, alert);
        }
        return responses;
    }

    /**
     * Execute a simple command at the server, a simple command being one that is sent in a single
     * line of text
     *
     * @param command the command to send to the server
     * @param sensitive whether the command should be redacted in logs (used for login)
     * @return a list of ImapResponses
     * @throws IOException
     * @throws MessagingException
     */
     List<ImapResponse> executeSimpleCommand(String command, boolean sensitive)
            throws IOException, MessagingException {
        sendCommand(command, sensitive);
        return getCommandResponses();
    }

     /**
      * Execute a complex command at the server, a complex command being one that must be sent in
      * multiple lines due to the use of string literals
      *
      * @param commands a list of strings that comprise the command to be sent to the server
      * @param sensitive whether the command should be redacted in logs (used for login)
      * @return a list of ImapResponses
      * @throws IOException
      * @throws MessagingException
      */
      List<ImapResponse> executeComplexCommand(List<String> commands, boolean sensitive)
            throws IOException, MessagingException {
        sendComplexCommand(commands, sensitive);
        return getCommandResponses();
    }

    /**
     * Query server for capabilities.
     */
    private ImapResponse queryCapabilities() throws IOException, MessagingException {
        ImapResponse capabilityResponse = null;
        for (ImapResponse r : executeSimpleCommand(ImapConstants.CAPABILITY)) {
            if (r.is(0, ImapConstants.CAPABILITY)) {
                capabilityResponse = r;
                break;
            }
        }
        if (capabilityResponse == null) {
            throw new MessagingException(""Invalid CAPABILITY response received"");
        }
        return capabilityResponse;
    }

    /**
     * Sends client identification information to the IMAP server per RFC 2971. If
     * the server does not support the ID command, this will perform no operation.
     *
     * Interoperability hack:  Never send ID to *.secureserver.net, which sends back a
     * malformed response that our parser can't deal with.
     */
    private void doSendId(boolean hasIdCapability, String capabilities)
            throws MessagingException {
        if (!hasIdCapability) return;

        // Never send ID to *.secureserver.net
        String host = mTransport.getHost();
        if (host.toLowerCase().endsWith("".secureserver.net"")) return;

        // Assign user-agent string (for RFC2971 ID command)
        String mUserAgent =
                ImapStore.getImapId(mImapStore.getContext(), mUsername, host, capabilities);

        if (mUserAgent != null) {
            mIdPhrase = ImapConstants.ID + "" ("" + mUserAgent + "")"";
        } else if (DEBUG_FORCE_SEND_ID) {
            mIdPhrase = ImapConstants.ID + "" "" + ImapConstants.NIL;
        }
        // else: mIdPhrase = null, no ID will be emitted

        // Send user-agent in an RFC2971 ID command
        if (mIdPhrase != null) {
            try {
                executeSimpleCommand(mIdPhrase);
            } catch (ImapException ie) {
                // Log for debugging, but this is not a fatal problem.
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ie.toString());
                }
            } catch (IOException ioe) {
                // Special case to handle malformed OK responses and ignore them.
                // A true IOException will recur on the following login steps
                // This can go away after the parser is fixed - see bug 2138981
            }
        }
    }

    /**
     * Gets the user's Personal Namespace from the IMAP server per RFC 2342. If the user
     * explicitly sets a namespace (using setup UI) or if the server does not support the
     * namespace command, this will perform no operation.
     */
    private void doGetNamespace(boolean hasNamespaceCapability) throws MessagingException {
        // user did not specify a hard-coded prefix; try to get it from the server
        if (hasNamespaceCapability && !mImapStore.isUserPrefixSet()) {
            List<ImapResponse> responseList = Collections.emptyList();

            try {
                responseList = executeSimpleCommand(ImapConstants.NAMESPACE);
            } catch (ImapException ie) {
                // Log for debugging, but this is not a fatal problem.
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ie.toString());
                }
            } catch (IOException ioe) {
                // Special case to handle malformed OK responses and ignore them.
            }

            for (ImapResponse response: responseList) {
                if (response.isDataResponse(0, ImapConstants.NAMESPACE)) {
                    ImapList namespaceList = response.getListOrEmpty(1);
                    ImapList namespace = namespaceList.getListOrEmpty(0);
                    String namespaceString = namespace.getStringOrEmpty(0).getString();
                    if (!TextUtils.isEmpty(namespaceString)) {
                        mImapStore.setPathPrefix(ImapStore.decodeFolderName(namespaceString, null));
                        mImapStore.setPathSeparator(namespace.getStringOrEmpty(1).getString());
                    }
                }
            }
        }
    }

    /**
     * Logs into the IMAP server
     */
    private void doLogin()
            throws IOException, MessagingException, AuthenticationFailedException {
        try {
            // TODO eventually we need to add additional authentication
            // options such as SASL
            executeSimpleCommand(mLoginPhrase, true);
        } catch (ImapException ie) {
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ie.toString());
            }
            throw new AuthenticationFailedException(ie.getAlertText(), ie);

        } catch (MessagingException me) {
            throw new AuthenticationFailedException(null, me);
        }
    }

    /**
     * Gets the path separator per the LIST command in RFC 3501. If the path separator
     * was obtained while obtaining the namespace or there is no prefix defined, this
     * will perform no operation.
     */
    private void doGetPathSeparator() throws MessagingException {
        // user did not specify a hard-coded prefix; try to get it from the server
        if (mImapStore.isUserPrefixSet()) {
            List<ImapResponse> responseList = Collections.emptyList();

            try {
                responseList = executeSimpleCommand(ImapConstants.LIST + "" \""\"" \""\"""");
            } catch (ImapException ie) {
                // Log for debugging, but this is not a fatal problem.
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ie.toString());
                }
            } catch (IOException ioe) {
                // Special case to handle malformed OK responses and ignore them.
            }

            for (ImapResponse response: responseList) {
                if (response.isDataResponse(0, ImapConstants.LIST)) {
                    mImapStore.setPathSeparator(response.getStringOrEmpty(2).getString());
                }
            }
        }
    }

    /**
     * Starts a TLS session with the IMAP server per RFC 3501. If the user has not opted
     * to use TLS or the server does not support the TLS capability, this will perform
     * no operation.
     */
    private ImapResponse doStartTls(boolean hasStartTlsCapability)
            throws IOException, MessagingException {
        if (mTransport.canTryTlsSecurity()) {
            if (hasStartTlsCapability) {
                // STARTTLS
                executeSimpleCommand(ImapConstants.STARTTLS);

                mTransport.reopenTls();
                mTransport.setSoTimeout(MailTransport.SOCKET_READ_TIMEOUT);
                createParser();
                // Per RFC requirement (3501-6.2.1) gather new capabilities
                return(queryCapabilities());
            } else {
                if (Email.DEBUG) {
                    Log.d(Logging.LOG_TAG, ""TLS not supported but required"");
                }
                throw new MessagingException(MessagingException.TLS_REQUIRED);
            }
        }
        return null;
    }

    /** @see DiscourseLogger#logLastDiscourse() */
    void logLastDiscourse() {
        mDiscourse.logLastDiscourse();
    }
}",True,268,1,1,9,68,3,15,L6
133,com.android.email.mail.store.ImapStore.java,"/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store;

import android.content.Context;
import android.os.Build;
import android.os.Bundle;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.Base64;
import android.util.Log;

import com.android.email.LegacyConversions;
import com.android.email.Preferences;
import com.android.email.VendorPolicyLoader;
import com.android.email.mail.Store;
import com.android.email.mail.Transport;
import com.android.email.mail.store.imap.ImapConstants;
import com.android.email.mail.store.imap.ImapResponse;
import com.android.email.mail.store.imap.ImapString;
import com.android.email.mail.transport.MailTransport;
import com.android.emailcommon.Logging;
import com.android.emailcommon.internet.MimeMessage;
import com.android.emailcommon.mail.AuthenticationFailedException;
import com.android.emailcommon.mail.Flag;
import com.android.emailcommon.mail.Folder;
import com.android.emailcommon.mail.Message;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.service.EmailServiceProxy;
import com.android.emailcommon.utility.Utility;
import com.beetstra.jutf7.CharsetProvider;
import com.google.common.annotations.VisibleForTesting;

import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.regex.Pattern;


/**
 * <pre>
 * TODO Need to start keeping track of UIDVALIDITY
 * TODO Need a default response handler for things like folder updates
 * TODO In fetch(), if we need a ImapMessage and were given
 *      something else we can try to do a pre-fetch first.
 * TODO Collect ALERT messages and show them to users.
 *
 * ftp://ftp.isi.edu/in-notes/rfc2683.txt When a client asks for
 * certain information in a FETCH command, the server may return the requested
 * information in any order, not necessarily in the order that it was requested.
 * Further, the server may return the information in separate FETCH responses
 * and may also return information that was not explicitly requested (to reflect
 * to the client changes in the state of the subject message).
 * </pre>
 */
public class ImapStore extends Store {
    /** Charset used for converting folder names to and from UTF-7 as defined by RFC 3501. */
    private static final Charset MODIFIED_UTF_7_CHARSET =
            new CharsetProvider().charsetForName(""X-RFC-3501"");

    @VisibleForTesting static String sImapId = null;
    @VisibleForTesting String mPathPrefix;
    @VisibleForTesting String mPathSeparator;

    private final ConcurrentLinkedQueue<ImapConnection> mConnectionPool =
            new ConcurrentLinkedQueue<ImapConnection>();

    /**
     * Static named constructor.
     */
    public static Store newInstance(Account account, Context context) throws MessagingException {
        return new ImapStore(context, account);
    }

    /**
     * Creates a new store for the given account. Always use
     * {@link #newInstance(Account, Context)} to create an IMAP store.
     */
    private ImapStore(Context context, Account account) throws MessagingException {
        mContext = context;
        mAccount = account;

        HostAuth recvAuth = account.getOrCreateHostAuthRecv(context);
        if (recvAuth == null || !HostAuth.SCHEME_IMAP.equalsIgnoreCase(recvAuth.mProtocol)) {
            throw new MessagingException(""Unsupported protocol"");
        }
        // defaults, which can be changed by security modifiers
        int connectionSecurity = Transport.CONNECTION_SECURITY_NONE;
        int defaultPort = 143;

        // check for security flags and apply changes
        if ((recvAuth.mFlags & HostAuth.FLAG_SSL) != 0) {
            connectionSecurity = Transport.CONNECTION_SECURITY_SSL;
            defaultPort = 993;
        } else if ((recvAuth.mFlags & HostAuth.FLAG_TLS) != 0) {
            connectionSecurity = Transport.CONNECTION_SECURITY_TLS;
        }
        boolean trustCertificates = ((recvAuth.mFlags & HostAuth.FLAG_TRUST_ALL) != 0);
        int port = defaultPort;
        if (recvAuth.mPort != HostAuth.PORT_UNKNOWN) {
            port = recvAuth.mPort;
        }
        mTransport = new MailTransport(""IMAP"");
        mTransport.setHost(recvAuth.mAddress);
        mTransport.setPort(port);
        mTransport.setSecurity(connectionSecurity, trustCertificates);

        String[] userInfo = recvAuth.getLogin();
        if (userInfo != null) {
            mUsername = userInfo[0];
            mPassword = userInfo[1];
        } else {
            mUsername = null;
            mPassword = null;
        }
        mPathPrefix = recvAuth.mDomain;
    }

    @VisibleForTesting
    Collection<ImapConnection> getConnectionPoolForTest() {
        return mConnectionPool;
    }

    /**
     * For testing only.  Injects a different root transport (it will be copied using
     * newInstanceWithConfiguration() each time IMAP sets up a new channel).  The transport
     * should already be set up and ready to use.  Do not use for real code.
     * @param testTransport The Transport to inject and use for all future communication.
     */
    @VisibleForTesting
    void setTransportForTest(Transport testTransport) {
        mTransport = testTransport;
    }

    /**
     * Return, or create and return, an string suitable for use in an IMAP ID message.
     * This is constructed similarly to the way the browser sets up its user-agent strings.
     * See RFC 2971 for more details.  The output of this command will be a series of key-value
     * pairs delimited by spaces (there is no point in returning a structured result because
     * this will be sent as-is to the IMAP server).  No tokens, parenthesis or ""ID"" are included,
     * because some connections may append additional values.
     *
     * The following IMAP ID keys may be included:
     *   name                   Android package name of the program
     *   os                     ""android""
     *   os-version             ""version; model; build-id""
     *   vendor                 Vendor of the client/server
     *   x-android-device-model Model (only revealed if release build)
     *   x-android-net-operator Mobile network operator (if known)
     *   AGUID                  A device+account UID
     *
     * In addition, a vendor policy .apk can append key/value pairs.
     *
     * @param userName the username of the account
     * @param host the host (server) of the account
     * @param capabilities a list of the capabilities from the server
     * @return a String for use in an IMAP ID message.
     */
    @VisibleForTesting
    static String getImapId(Context context, String userName, String host, String capabilities) {
        // The first section is global to all IMAP connections, and generates the fixed
        // values in any IMAP ID message
        synchronized (ImapStore.class) {
            if (sImapId == null) {
                TelephonyManager tm =
                        (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
                String networkOperator = tm.getNetworkOperatorName();
                if (networkOperator == null) networkOperator = """";

                sImapId = makeCommonImapId(context.getPackageName(), Build.VERSION.RELEASE,
                        Build.VERSION.CODENAME, Build.MODEL, Build.ID, Build.MANUFACTURER,
                        networkOperator);
            }
        }

        // This section is per Store, and adds in a dynamic elements like UID's.
        // We don't cache the result of this work, because the caller does anyway.
        StringBuilder id = new StringBuilder(sImapId);

        // Optionally add any vendor-supplied id keys
        String vendorId = VendorPolicyLoader.getInstance(context).getImapIdValues(userName, host,
                capabilities);
        if (vendorId != null) {
            id.append(' ');
            id.append(vendorId);
        }

        // Generate a UID that mixes a ""stable"" device UID with the email address
        try {
            String devUID = Preferences.getPreferences(context).getDeviceUID();
            MessageDigest messageDigest;
            messageDigest = MessageDigest.getInstance(""SHA-1"");
            messageDigest.update(userName.getBytes());
            messageDigest.update(devUID.getBytes());
            byte[] uid = messageDigest.digest();
            String hexUid = Base64.encodeToString(uid, Base64.NO_WRAP);
            id.append("" \""AGUID\"" \"""");
            id.append(hexUid);
            id.append('\""');
        } catch (NoSuchAlgorithmException e) {
            Log.d(Logging.LOG_TAG, ""couldn't obtain SHA-1 hash for device UID"");
        }
        return id.toString();
    }

    /**
     * Helper function that actually builds the static part of the IMAP ID string.  This is
     * separated from getImapId for testability.  There is no escaping or encoding in IMAP ID so
     * any rogue chars must be filtered here.
     *
     * @param packageName context.getPackageName()
     * @param version Build.VERSION.RELEASE
     * @param codeName Build.VERSION.CODENAME
     * @param model Build.MODEL
     * @param id Build.ID
     * @param vendor Build.MANUFACTURER
     * @param networkOperator TelephonyManager.getNetworkOperatorName()
     * @return the static (never changes) portion of the IMAP ID
     */
    @VisibleForTesting
    static String makeCommonImapId(String packageName, String version,
            String codeName, String model, String id, String vendor, String networkOperator) {

        // Before building up IMAP ID string, pre-filter the input strings for ""legal"" chars
        // This is using a fairly arbitrary char set intended to pass through most reasonable
        // version, model, and vendor strings: a-z A-Z 0-9 - _ + = ; : . , / <space>
        // The most important thing is *not* to pass parens, quotes, or CRLF, which would break
        // the format of the IMAP ID list.
        Pattern p = Pattern.compile(""[^a-zA-Z0-9-_\\+=;:\\.,/ ]"");
        packageName = p.matcher(packageName).replaceAll("""");
        version = p.matcher(version).replaceAll("""");
        codeName = p.matcher(codeName).replaceAll("""");
        model = p.matcher(model).replaceAll("""");
        id = p.matcher(id).replaceAll("""");
        vendor = p.matcher(vendor).replaceAll("""");
        networkOperator = p.matcher(networkOperator).replaceAll("""");

        // ""name"" ""com.android.email""
        StringBuffer sb = new StringBuffer(""\""name\"" \"""");
        sb.append(packageName);
        sb.append(""\"""");

        // ""os"" ""android""
        sb.append("" \""os\"" \""android\"""");

        // ""os-version"" ""version; build-id""
        sb.append("" \""os-version\"" \"""");
        if (version.length() > 0) {
            sb.append(version);
        } else {
            // default to ""1.0""
            sb.append(""1.0"");
        }
        // add the build ID or build #
        if (id.length() > 0) {
            sb.append(""; "");
            sb.append(id);
        }
        sb.append(""\"""");

        // ""vendor"" ""the vendor""
        if (vendor.length() > 0) {
            sb.append("" \""vendor\"" \"""");
            sb.append(vendor);
            sb.append(""\"""");
        }

        // ""x-android-device-model"" the device model (on release builds only)
        if (""REL"".equals(codeName)) {
            if (model.length() > 0) {
                sb.append("" \""x-android-device-model\"" \"""");
                sb.append(model);
                sb.append(""\"""");
            }
        }

        // ""x-android-mobile-net-operator"" ""name of network operator""
        if (networkOperator.length() > 0) {
            sb.append("" \""x-android-mobile-net-operator\"" \"""");
            sb.append(networkOperator);
            sb.append(""\"""");
        }

        return sb.toString();
    }


    @Override
    public Folder getFolder(String name) {
        return new ImapFolder(this, name);
    }

    /**
     * Creates a mailbox hierarchy out of the flat data provided by the server.
     */
    @VisibleForTesting
    static void createHierarchy(HashMap<String, ImapFolder> mailboxes) {
        Set<String> pathnames = mailboxes.keySet();
        for (String path : pathnames) {
            final ImapFolder folder = mailboxes.get(path);
            final Mailbox mailbox = folder.mMailbox;
            int delimiterIdx = mailbox.mServerId.lastIndexOf(mailbox.mDelimiter);
            long parentKey = Mailbox.NO_MAILBOX;
            if (delimiterIdx != -1) {
                String parentPath = path.substring(0, delimiterIdx);
                final ImapFolder parentFolder = mailboxes.get(parentPath);
                final Mailbox parentMailbox = (parentFolder == null) ? null : parentFolder.mMailbox;
                if (parentMailbox != null) {
                    parentKey = parentMailbox.mId;
                    parentMailbox.mFlags
                            |= (Mailbox.FLAG_HAS_CHILDREN | Mailbox.FLAG_CHILDREN_VISIBLE);
                }
            }
            mailbox.mParentKey = parentKey;
        }
    }

    /**
     * Creates a {@link Folder} and associated {@link Mailbox}. If the folder does not already
     * exist in the local database, a new row will immediately be created in the mailbox table.
     * Otherwise, the existing row will be used. Any changes to existing rows, will not be stored
     * to the database immediately.
     * @param accountId The ID of the account the mailbox is to be associated with
     * @param mailboxPath The path of the mailbox to add
     * @param delimiter A path delimiter. May be {@code null} if there is no delimiter.
     * @param selectable If {@code true}, the mailbox can be selected and used to store messages.
     */
    private ImapFolder addMailbox(Context context, long accountId, String mailboxPath,
            char delimiter, boolean selectable) {
        ImapFolder folder = (ImapFolder) getFolder(mailboxPath);
        Mailbox mailbox = Mailbox.getMailboxForPath(context, accountId, mailboxPath);
        if (mailbox.isSaved()) {
            // existing mailbox
            // mailbox retrieved from database; save hash _before_ updating fields
            folder.mHash = mailbox.getHashes();
        }
        updateMailbox(mailbox, accountId, mailboxPath, delimiter, selectable,
                LegacyConversions.inferMailboxTypeFromName(context, mailboxPath));
        if (folder.mHash == null) {
            // new mailbox
            // save hash after updating. allows tracking changes if the mailbox is saved
            // outside of #saveMailboxList()
            folder.mHash = mailbox.getHashes();
            // We must save this here to make sure we have a valid ID for later
            mailbox.save(mContext);
        }
        folder.mMailbox = mailbox;
        return folder;
    }

    /**
     * Persists the folders in the given list.
     */
    private static void saveMailboxList(Context context, HashMap<String, ImapFolder> folderMap) {
        for (ImapFolder imapFolder : folderMap.values()) {
            imapFolder.save(context);
        }
    }

    @Override
    public Folder[] updateFolders() throws MessagingException {
        ImapConnection connection = getConnection();
        try {
            HashMap<String, ImapFolder> mailboxes = new HashMap<String, ImapFolder>();
            // Establish a connection to the IMAP server; if necessary
            // This ensures a valid prefix if the prefix is automatically set by the server
            connection.executeSimpleCommand(ImapConstants.NOOP);
            String imapCommand = ImapConstants.LIST + "" \""\"" \""*\"""";
            if (mPathPrefix != null) {
                imapCommand = ImapConstants.LIST + "" \""\"" \"""" + mPathPrefix + ""*\"""";
            }
            List<ImapResponse> responses = connection.executeSimpleCommand(imapCommand);
            for (ImapResponse response : responses) {
                // S: * LIST (\Noselect) ""/"" ~/Mail/foo
                if (response.isDataResponse(0, ImapConstants.LIST)) {
                    // Get folder name.
                    ImapString encodedFolder = response.getStringOrEmpty(3);
                    if (encodedFolder.isEmpty()) continue;

                    String folderName = decodeFolderName(encodedFolder.getString(), mPathPrefix);
                    if (ImapConstants.INBOX.equalsIgnoreCase(folderName)) continue;

                    // Parse attributes.
                    boolean selectable =
                        !response.getListOrEmpty(1).contains(ImapConstants.FLAG_NO_SELECT);
                    String delimiter = response.getStringOrEmpty(2).getString();
                    char delimiterChar = '\0';
                    if (!TextUtils.isEmpty(delimiter)) {
                        delimiterChar = delimiter.charAt(0);
                    }
                    ImapFolder folder =
                        addMailbox(mContext, mAccount.mId, folderName, delimiterChar, selectable);
                    mailboxes.put(folderName, folder);
                }
            }
            Folder newFolder =
                addMailbox(mContext, mAccount.mId, ImapConstants.INBOX, '\0', true /*selectable*/);
            mailboxes.put(ImapConstants.INBOX, (ImapFolder)newFolder);
            createHierarchy(mailboxes);
            saveMailboxList(mContext, mailboxes);
            return mailboxes.values().toArray(new Folder[] {});
        } catch (IOException ioe) {
            connection.close();
            throw new MessagingException(""Unable to get folder list."", ioe);
        } catch (AuthenticationFailedException afe) {
            // We do NOT want this connection pooled, or we will continue to send NOOP and SELECT
            // commands to the server
            connection.destroyResponses();
            connection = null;
            throw afe;
        } finally {
            if (connection != null) {
                poolConnection(connection);
            }
        }
    }

    @Override
    public Bundle checkSettings() throws MessagingException {
        int result = MessagingException.NO_ERROR;
        Bundle bundle = new Bundle();
        ImapConnection connection = new ImapConnection(this, mUsername, mPassword);
        try {
            connection.open();
            connection.close();
        } catch (IOException ioe) {
            bundle.putString(EmailServiceProxy.VALIDATE_BUNDLE_ERROR_MESSAGE, ioe.getMessage());
            result = MessagingException.IOERROR;
        } finally {
            connection.destroyResponses();
        }
        bundle.putInt(EmailServiceProxy.VALIDATE_BUNDLE_RESULT_CODE, result);
        return bundle;
    }

    /**
     * Returns whether or not the prefix has been set by the user. This can be determined by
     * the fact that the prefix is set, but, the path separator is not set.
     */
    boolean isUserPrefixSet() {
        return TextUtils.isEmpty(mPathSeparator) && !TextUtils.isEmpty(mPathPrefix);
    }

    /** Sets the path separator */
    void setPathSeparator(String pathSeparator) {
        mPathSeparator = pathSeparator;
    }

    /** Sets the prefix */
    void setPathPrefix(String pathPrefix) {
        mPathPrefix = pathPrefix;
    }

    /** Gets the context for this store */
    Context getContext() {
        return mContext;
    }

    /** Returns a clone of the transport associated with this store. */
    Transport cloneTransport() {
        return mTransport.clone();
    }

    /**
     * Fixes the path prefix, if necessary. The path prefix must always end with the
     * path separator.
     */
    void ensurePrefixIsValid() {
        // Make sure the path prefix ends with the path separator
        if (!TextUtils.isEmpty(mPathPrefix) && !TextUtils.isEmpty(mPathSeparator)) {
            if (!mPathPrefix.endsWith(mPathSeparator)) {
                mPathPrefix = mPathPrefix + mPathSeparator;
            }
        }
    }

    /**
     * Gets a connection if one is available from the pool, or creates a new one if not.
     */
    ImapConnection getConnection() {
        ImapConnection connection = null;
        while ((connection = mConnectionPool.poll()) != null) {
            try {
                connection.setStore(this, mUsername, mPassword);
                connection.executeSimpleCommand(ImapConstants.NOOP);
                break;
            } catch (MessagingException e) {
                // Fall through
            } catch (IOException e) {
                // Fall through
            }
            connection.close();
            connection = null;
        }
        if (connection == null) {
            connection = new ImapConnection(this, mUsername, mPassword);
        }
        return connection;
    }

    /**
     * Save a {@link ImapConnection} in the pool for reuse. Any responses associated with the
     * connection are destroyed before adding the connection to the pool.
     */
    void poolConnection(ImapConnection connection) {
        if (connection != null) {
            connection.destroyResponses();
            mConnectionPool.add(connection);
        }
    }

    /**
     * Prepends the folder name with the given prefix and UTF-7 encodes it.
     */
    static String encodeFolderName(String name, String prefix) {
        // do NOT add the prefix to the special name ""INBOX""
        if (ImapConstants.INBOX.equalsIgnoreCase(name)) return name;

        // Prepend prefix
        if (prefix != null) {
            name = prefix + name;
        }

        // TODO bypass the conversion if name doesn't have special char.
        ByteBuffer bb = MODIFIED_UTF_7_CHARSET.encode(name);
        byte[] b = new byte[bb.limit()];
        bb.get(b);

        return Utility.fromAscii(b);
    }

    /**
     * UTF-7 decodes the folder name and removes the given path prefix.
     */
    static String decodeFolderName(String name, String prefix) {
        // TODO bypass the conversion if name doesn't have special char.
        String folder;
        folder = MODIFIED_UTF_7_CHARSET.decode(ByteBuffer.wrap(Utility.toAscii(name))).toString();
        if ((prefix != null) && folder.startsWith(prefix)) {
            folder = folder.substring(prefix.length());
        }
        return folder;
    }

    /**
     * Returns UIDs of Messages joined with "","" as the separator.
     */
    static String joinMessageUids(Message[] messages) {
        StringBuilder sb = new StringBuilder();
        boolean notFirst = false;
        for (Message m : messages) {
            if (notFirst) {
                sb.append(',');
            }
            sb.append(m.getUid());
            notFirst = true;
        }
        return sb.toString();
    }

    static class ImapMessage extends MimeMessage {
        ImapMessage(String uid, ImapFolder folder) {
            mUid = uid;
            mFolder = folder;
        }

        public void setSize(int size) {
            mSize = size;
        }

        @Override
        public void parse(InputStream in) throws IOException, MessagingException {
            super.parse(in);
        }

        public void setFlagInternal(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
        }

        @Override
        public void setFlag(Flag flag, boolean set) throws MessagingException {
            super.setFlag(flag, set);
            mFolder.setFlags(new Message[] { this }, new Flag[] { flag }, set);
        }
    }

    static class ImapException extends MessagingException {
        private static final long serialVersionUID = 1L;

        String mAlertText;

        public ImapException(String message, String alertText, Throwable throwable) {
            super(message, throwable);
            mAlertText = alertText;
        }

        public ImapException(String message, String alertText) {
            super(message);
            mAlertText = alertText;
        }

        public String getAlertText() {
            return mAlertText;
        }

        public void setAlertText(String alertText) {
            mAlertText = alertText;
        }
    }
}
",True,268,1,1,9,48,4,26,L6
134,com.android.email.mail.store.imap.ImapSimpleString.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import com.android.emailcommon.utility.Utility;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

/**
 * Subclass of {@link ImapString} used for non literals.
 */
public class ImapSimpleString extends ImapString {
    private String mString;

    /* package */  ImapSimpleString(String string) {
        mString = (string != null) ? string : """";
    }

    @Override
    public void destroy() {
        mString = null;
        super.destroy();
    }

    @Override
    public String getString() {
        return mString;
    }

    @Override
    public InputStream getAsStream() {
        return new ByteArrayInputStream(Utility.toAscii(mString));
    }

    @Override
    public String toString() {
        // Purposefully not return just mString, in order to prevent using it instead of getString.
        return ""\"""" + mString + ""\"""";
    }
}
",True,161,12,49,4,7,6,3,L6
135,com.android.email.mail.store.imap.ImapList.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import java.util.ArrayList;

/**
 * Class represents an IMAP list.
 */
public class ImapList extends ImapElement {
    /**
     * {@link ImapList} representing an empty list.
     */
    public static final ImapList EMPTY = new ImapList() {
        @Override public void destroy() {
            // Don't call super.destroy().
            // It's a shared object.  We don't want the mDestroyed to be set on this.
        }

        @Override void add(ImapElement e) {
            throw new RuntimeException();
        }
    };

    private ArrayList<ImapElement> mList = new ArrayList<ImapElement>();

    /* package */ void add(ImapElement e) {
        if (e == null) {
            throw new RuntimeException(""Can't add null"");
        }
        mList.add(e);
    }

    @Override
    public final boolean isString() {
        return false;
    }

    @Override
    public final boolean isList() {
        return true;
    }

    public final int size() {
        return mList.size();
    }

    public final boolean isEmpty() {
        return size() == 0;
    }

    /**
     * Return true if the element at {@code index} exists, is string, and equals to {@code s}.
     * (case insensitive)
     */
    public final boolean is(int index, String s) {
        return is(index, s, false);
    }

    /**
     * Same as {@link #is(int, String)}, but does the prefix match if {@code prefixMatch}.
     */
    public final boolean is(int index, String s, boolean prefixMatch) {
        if (!prefixMatch) {
            return getStringOrEmpty(index).is(s);
        } else {
            return getStringOrEmpty(index).startsWith(s);
        }
    }

    /**
     * Return the element at {@code index}.
     * If {@code index} is out of range, returns {@link ImapElement#NONE}.
     */
    public final ImapElement getElementOrNone(int index) {
        return (index >= mList.size()) ? ImapElement.NONE : mList.get(index);
    }

    /**
     * Return the element at {@code index} if it's a list.
     * If {@code index} is out of range or not a list, returns {@link ImapList#EMPTY}.
     */
    public final ImapList getListOrEmpty(int index) {
        ImapElement el = getElementOrNone(index);
        return el.isList() ? (ImapList) el : EMPTY;
    }

    /**
     * Return the element at {@code index} if it's a string.
     * If {@code index} is out of range or not a string, returns {@link ImapString#EMPTY}.
     */
    public final ImapString getStringOrEmpty(int index) {
        ImapElement el = getElementOrNone(index);
        return el.isString() ? (ImapString) el : ImapString.EMPTY;
    }

    /**
     * Return an element keyed by {@code key}.  Return null if not found.  {@code key} has to be
     * at an even index.
     */
    /* package */ final ImapElement getKeyedElementOrNull(String key, boolean prefixMatch) {
        for (int i = 1; i < size(); i += 2) {
            if (is(i-1, key, prefixMatch)) {
                return mList.get(i);
            }
        }
        return null;
    }

    /**
     * Return an {@link ImapList} keyed by {@code key}.
     * Return {@link ImapList#EMPTY} if not found.
     */
    public final ImapList getKeyedListOrEmpty(String key) {
        return getKeyedListOrEmpty(key, false);
    }

    /**
     * Return an {@link ImapList} keyed by {@code key}.
     * Return {@link ImapList#EMPTY} if not found.
     */
    public final ImapList getKeyedListOrEmpty(String key, boolean prefixMatch) {
        ImapElement e = getKeyedElementOrNull(key, prefixMatch);
        return (e != null) ? ((ImapList) e) : ImapList.EMPTY;
    }

    /**
     * Return an {@link ImapString} keyed by {@code key}.
     * Return {@link ImapString#EMPTY} if not found.
     */
    public final ImapString getKeyedStringOrEmpty(String key) {
        return getKeyedStringOrEmpty(key, false);
    }

    /**
     * Return an {@link ImapString} keyed by {@code key}.
     * Return {@link ImapString#EMPTY} if not found.
     */
    public final ImapString getKeyedStringOrEmpty(String key, boolean prefixMatch) {
        ImapElement e = getKeyedElementOrNull(key, prefixMatch);
        return (e != null) ? ((ImapString) e) : ImapString.EMPTY;
    }

    /**
     * Return true if it contains {@code s}.
     */
    public final boolean contains(String s) {
        for (int i = 0; i < size(); i++) {
            if (getStringOrEmpty(i).is(s)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void destroy() {
        if (mList != null) {
            for (ImapElement e : mList) {
                e.destroy();
            }
            mList = null;
        }
        super.destroy();
    }

    @Override
    public String toString() {
        return mList.toString();
    }

    /**
     * Return the text representations of the contents concatenated with "","".
     */
    public final String flatten() {
        return flatten(new StringBuilder()).toString();
    }

    /**
     * Returns text representations (i.e. getString()) of contents joined together with
     * "","" as the separator.
     *
     * Only used for building the capability string passed to vendor policies.
     *
     * We can't use toString(), because it's for debugging (meaning the format may change any time),
     * and it won't expand literals.
     */
    private final StringBuilder flatten(StringBuilder sb) {
        sb.append('[');
        for (int i = 0; i < mList.size(); i++) {
            if (i > 0) {
                sb.append(',');
            }
            final ImapElement e = getElementOrNone(i);
            if (e.isList()) {
                getListOrEmpty(i).flatten(sb);
            } else if (e.isString()) {
                sb.append(getStringOrEmpty(i).getString());
            }
        }
        sb.append(']');
        return sb;
    }

    @Override
    public boolean equalsForTest(ImapElement that) {
        if (!super.equalsForTest(that)) {
            return false;
        }
        ImapList thatList = (ImapList) that;
        if (size() != thatList.size()) {
            return false;
        }
        for (int i = 0; i < size(); i++) {
            if (!mList.get(i).equalsForTest(thatList.getElementOrNone(i))) {
                return false;
            }
        }
        return true;
    }
}
",False,150,10,49,2,2,9,2,L6
136,com.android.email.mail.store.imap.ImapElement.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

/**
 * Class representing ""element""s in IMAP responses.
 *
 * <p>Class hierarchy:
 * <pre>
 * ImapElement
 *   |
 *   |-- ImapElement.NONE (for 'index out of range')
 *   |
 *   |-- ImapList (isList() == true)
 *   |   |
 *   |   |-- ImapList.EMPTY
 *   |   |
 *   |   --- ImapResponse
 *   |
 *   --- ImapString (isString() == true)
 *       |
 *       |-- ImapString.EMPTY
 *       |
 *       |-- ImapSimpleString
 *       |
 *       |-- ImapMemoryLiteral
 *       |
 *       --- ImapTempFileLiteral
 * </pre>
 */
public abstract class ImapElement {
    /**
     * An element that is returned by {@link ImapList#getElementOrNone} to indicate an index
     * is out of range.
     */
    public static final ImapElement NONE = new ImapElement() {
        @Override public void destroy() {
            // Don't call super.destroy().
            // It's a shared object.  We don't want the mDestroyed to be set on this.
        }

        @Override public boolean isList() {
            return false;
        }

        @Override public boolean isString() {
            return false;
        }

        @Override public String toString() {
            return ""[NO ELEMENT]"";
        }

        @Override
        public boolean equalsForTest(ImapElement that) {
            return super.equalsForTest(that);
        }
    };

    private boolean mDestroyed = false;

    public abstract boolean isList();

    public abstract boolean isString();

    protected boolean isDestroyed() {
        return mDestroyed;
    }

    /**
     * Clean up the resources used by the instance.
     * It's for removing a temp file used by {@link ImapTempFileLiteral}.
     */
    public void destroy() {
        mDestroyed = true;
    }

    /**
     * Throws {@link RuntimeException} if it's already destroyed.
     */
    protected final void checkNotDestroyed() {
        if (mDestroyed) {
            throw new RuntimeException(""Already destroyed"");
        }
    }

    /**
     * Return a string that represents this object; it's purely for the debug purpose.  Don't
     * mistake it for {@link ImapString#getString}.
     *
     * Abstract to force subclasses to implement it.
     */
    @Override
    public abstract String toString();

    /**
     * The equals implementation that is intended to be used only for unit testing.
     * (Because it may be heavy and has a special sense of ""equal"" for testing.)
     */
    public boolean equalsForTest(ImapElement that) {
        if (that == null) {
            return false;
        }
        return this.getClass() == that.getClass(); // Has to be the same class.
    }
}
",False,152,11,49,0,0,11,0,L6
137,com.android.email.mail.store.imap.ImapMemoryLiteral.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import com.android.email.FixedLengthInputStream;
import com.android.emailcommon.Logging;
import com.android.emailcommon.utility.Utility;

import android.util.Log;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;

/**
 * Subclass of {@link ImapString} used for literals backed by an in-memory byte array.
 */
public class ImapMemoryLiteral extends ImapString {
    private byte[] mData;

    /* package */ ImapMemoryLiteral(FixedLengthInputStream in) throws IOException {
        // We could use ByteArrayOutputStream and IOUtils.copy, but it'd perform an unnecessary
        // copy....
        mData = new byte[in.getLength()];
        int pos = 0;
        while (pos < mData.length) {
            int read = in.read(mData, pos, mData.length - pos);
            if (read < 0) {
                break;
            }
            pos += read;
        }
        if (pos != mData.length) {
            Log.w(Logging.LOG_TAG, """");
        }
    }

    @Override
    public void destroy() {
        mData = null;
        super.destroy();
    }

    @Override
    public String getString() {
        return Utility.fromAscii(mData);
    }

    @Override
    public InputStream getAsStream() {
        return new ByteArrayInputStream(mData);
    }

    @Override
    public String toString() {
        return String.format(""{%d byte literal(memory)}"", mData.length);
    }
}
",True,162,12,49,4,6,3,5,L6
138,com.android.email.mail.store.imap.ImapResponseParser.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import com.android.email.Email;
import com.android.email.FixedLengthInputStream;
import com.android.email.PeekableInputStream;
import com.android.email.mail.transport.DiscourseLogger;
import com.android.emailcommon.Logging;
import com.android.emailcommon.mail.MessagingException;
import com.android.emailcommon.utility.LoggingInputStream;

import android.text.TextUtils;
import android.util.Log;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;

/**
 * IMAP response parser.
 */
public class ImapResponseParser {
    private static final boolean DEBUG_LOG_RAW_STREAM = false; // DO NOT RELEASE AS 'TRUE'

    /**
     * Literal larger than this will be stored in temp file.
     */
    private static final int LITERAL_KEEP_IN_MEMORY_THRESHOLD = 2 * 1024 * 1024;

    /** Input stream */
    private final PeekableInputStream mIn;

    /**
     * To log network activities when the parser crashes.
     *
     * <p>We log all bytes received from the server, except for the part sent as literals.
     */
    private final DiscourseLogger mDiscourseLogger;

    private final int mLiteralKeepInMemoryThreshold;

    /** StringBuilder used by readUntil() */
    private final StringBuilder mBufferReadUntil = new StringBuilder();

    /** StringBuilder used by parseBareString() */
    private final StringBuilder mParseBareString = new StringBuilder();

    /**
     * We store all {@link ImapResponse} in it.  {@link #destroyResponses()} must be called from
     * time to time to destroy them and clear it.
     */
    private final ArrayList<ImapResponse> mResponsesToDestroy = new ArrayList<ImapResponse>();

    /**
     * Exception thrown when we receive BYE.  It derives from IOException, so it'll be treated
     * in the same way EOF does.
     */
    public static class ByeException extends IOException {
        public static final String MESSAGE = ""Received BYE"";
        public ByeException() {
            super(MESSAGE);
        }
    }

    /**
     * Public constructor for normal use.
     */
    public ImapResponseParser(InputStream in, DiscourseLogger discourseLogger) {
        this(in, discourseLogger, LITERAL_KEEP_IN_MEMORY_THRESHOLD);
    }

    /**
     * Constructor for testing to override the literal size threshold.
     */
    /* package for test */ ImapResponseParser(InputStream in, DiscourseLogger discourseLogger,
            int literalKeepInMemoryThreshold) {
        if (DEBUG_LOG_RAW_STREAM && Email.DEBUG) {
            in = new LoggingInputStream(in);
        }
        mIn = new PeekableInputStream(in);
        mDiscourseLogger = discourseLogger;
        mLiteralKeepInMemoryThreshold = literalKeepInMemoryThreshold;
    }

    private static IOException newEOSException() {
        final String message = ""End of stream reached"";
        if (Email.DEBUG) {
            Log.d(Logging.LOG_TAG, message);
        }
        return new IOException(message);
    }

    /**
     * Peek next one byte.
     *
     * Throws IOException() if reaches EOF.  As long as logical response lines end with \r\n,
     * we shouldn't see EOF during parsing.
     */
    private int peek() throws IOException {
        final int next = mIn.peek();
        if (next == -1) {
            throw newEOSException();
        }
        return next;
    }

    /**
     * Read and return one byte from {@link #mIn}, and put it in {@link #mDiscourseLogger}.
     *
     * Throws IOException() if reaches EOF.  As long as logical response lines end with \r\n,
     * we shouldn't see EOF during parsing.
     */
    private int readByte() throws IOException {
        int next = mIn.read();
        if (next == -1) {
            throw newEOSException();
        }
        mDiscourseLogger.addReceivedByte(next);
        return next;
    }

    /**
     * Destroy all the {@link ImapResponse}s stored in the internal storage and clear it.
     *
     * @see #readResponse()
     */
    public void destroyResponses() {
        for (ImapResponse r : mResponsesToDestroy) {
            r.destroy();
        }
        mResponsesToDestroy.clear();
    }

    /**
     * Reads the next response available on the stream and returns an
     * {@link ImapResponse} object that represents it.
     *
     * <p>When this method successfully returns an {@link ImapResponse}, the {@link ImapResponse}
     * is stored in the internal storage.  When the {@link ImapResponse} is no longer used
     * {@link #destroyResponses} should be called to destroy all the responses in the array.
     *
     * @return the parsed {@link ImapResponse} object.
     * @exception ByeException when detects BYE.
     */
    public ImapResponse readResponse() throws IOException, MessagingException {
        ImapResponse response = null;
        try {
            response = parseResponse();
            if (Email.DEBUG) {
                Log.d(Logging.LOG_TAG, ""<<< "" + response.toString());
            }

        } catch (RuntimeException e) {
            // Parser crash -- log network activities.
            onParseError(e);
            throw e;
        } catch (IOException e) {
            // Network error, or received an unexpected char.
            onParseError(e);
            throw e;
        }

        // Handle this outside of try-catch.  We don't have to dump protocol log when getting BYE.
        if (response.is(0, ImapConstants.BYE)) {
            Log.w(Logging.LOG_TAG, ByeException.MESSAGE);
            response.destroy();
            throw new ByeException();
        }
        mResponsesToDestroy.add(response);
        return response;
    }

    private void onParseError(Exception e) {
        // Read a few more bytes, so that the log will contain some more context, even if the parser
        // crashes in the middle of a response.
        // This also makes sure the byte in question will be logged, no matter where it crashes.
        // e.g. when parseAtom() peeks and finds at an unexpected char, it throws an exception
        // before actually reading it.
        // However, we don't want to read too much, because then it may get into an email message.
        try {
            for (int i = 0; i < 4; i++) {
                int b = readByte();
                if (b == -1 || b == '\n') {
                    break;
                }
            }
        } catch (IOException ignore) {
        }
        Log.w(Logging.LOG_TAG, ""Exception detected: "" + e.getMessage());
        mDiscourseLogger.logLastDiscourse();
    }

    /**
     * Read next byte from stream and throw it away.  If the byte is different from {@code expected}
     * throw {@link MessagingException}.
     */
    /* package for test */ void expect(char expected) throws IOException {
        final int next = readByte();
        if (expected != next) {
            throw new IOException(String.format(""Expected %04x (%c) but got %04x (%c)"",
                    (int) expected, expected, next, (char) next));
        }
    }

    /**
     * Read bytes until we find {@code end}, and return all as string.
     * The {@code end} will be read (rather than peeked) and won't be included in the result.
     */
    /* package for test */ String readUntil(char end) throws IOException {
        mBufferReadUntil.setLength(0);
        for (;;) {
            final int ch = readByte();
            if (ch != end) {
                mBufferReadUntil.append((char) ch);
            } else {
                return mBufferReadUntil.toString();
            }
        }
    }

    /**
     * Read all bytes until \r\n.
     */
    /* package */ String readUntilEol() throws IOException {
        String ret = readUntil('\r');
        expect('\n'); // TODO Should this really be error?
        return ret;
    }

    /**
     * Parse and return the response line.
     */
    private ImapResponse parseResponse() throws IOException, MessagingException {
        // We need to destroy the response if we get an exception.
        // So, we first store the response that's being built in responseToDestroy, until it's
        // completely built, at which point we copy it into responseToReturn and null out
        // responseToDestroyt.
        // If responseToDestroy is not null in finally, we destroy it because that means
        // we got an exception somewhere.
        ImapResponse responseToDestroy = null;
        final ImapResponse responseToReturn;

        try {
            final int ch = peek();
            if (ch == '+') { // Continuation request
                readByte(); // skip +
                expect(' ');
                responseToDestroy = new ImapResponse(null, true);

                // If it's continuation request, we don't really care what's in it.
                responseToDestroy.add(new ImapSimpleString(readUntilEol()));

                // Response has successfully been built.  Let's return it.
                responseToReturn = responseToDestroy;
                responseToDestroy = null;
            } else {
                // Status response or response data
                final String tag;
                if (ch == '*') {
                    tag = null;
                    readByte(); // skip *
                    expect(' ');
                } else {
                    tag = readUntil(' ');
                }
                responseToDestroy = new ImapResponse(tag, false);

                final ImapString firstString = parseBareString();
                responseToDestroy.add(firstString);

                // parseBareString won't eat a space after the string, so we need to skip it,
                // if exists.
                // If the next char is not ' ', it should be EOL.
                if (peek() == ' ') {
                    readByte(); // skip ' '

                    if (responseToDestroy.isStatusResponse()) { // It's a status response

                        // Is there a response code?
                        final int next = peek();
                        if (next == '[') {
                            responseToDestroy.add(parseList('[', ']'));
                            if (peek() == ' ') { // Skip following space
                                readByte();
                            }
                        }

                        String rest = readUntilEol();
                        if (!TextUtils.isEmpty(rest)) {
                            // The rest is free-form text.
                            responseToDestroy.add(new ImapSimpleString(rest));
                        }
                    } else { // It's a response data.
                        parseElements(responseToDestroy, '\0');
                    }
                } else {
                    expect('\r');
                    expect('\n');
                }

                // Response has successfully been built.  Let's return it.
                responseToReturn = responseToDestroy;
                responseToDestroy = null;
            }
        } finally {
            if (responseToDestroy != null) {
                // We get an exception.
                responseToDestroy.destroy();
            }
        }

        return responseToReturn;
    }

    private ImapElement parseElement() throws IOException, MessagingException {
        final int next = peek();
        switch (next) {
            case '(':
                return parseList('(', ')');
            case '[':
                return parseList('[', ']');
            case '""':
                readByte(); // Skip ""
                return new ImapSimpleString(readUntil('""'));
            case '{':
                return parseLiteral();
            case '\r':  // CR
                readByte(); // Consume \r
                expect('\n'); // Should be followed by LF.
                return null;
            case '\n': // LF // There shouldn't be a bare LF, but just in case.
                readByte(); // Consume \n
                return null;
            default:
                return parseBareString();
        }
    }

    /**
     * Parses an atom.
     *
     * Special case: If an atom contains '[', everything until the next ']' will be considered
     * a part of the atom.
     * (e.g. ""BODY[HEADER.FIELDS (""DATE"" ...)]"" will become a single ImapString)
     *
     * If the value is ""NIL"", returns an empty string.
     */
    private ImapString parseBareString() throws IOException, MessagingException {
        mParseBareString.setLength(0);
        for (;;) {
            final int ch = peek();

            // TODO Can we clean this up?  (This condition is from the old parser.)
            if (ch == '(' || ch == ')' || ch == '{' || ch == ' ' ||
                    // ']' is not part of atom (it's in resp-specials)
                    ch == ']' ||
                    // docs claim that flags are \ atom but atom isn't supposed to
                    // contain
                    // * and some flags contain *
                    // ch == '%' || ch == '*' ||
                    ch == '%' ||
                    // TODO probably should not allow \ and should recognize
                    // it as a flag instead
                    // ch == '""' || ch == '\' ||
                    ch == '""' || (0x00 <= ch && ch <= 0x1f) || ch == 0x7f) {
                if (mParseBareString.length() == 0) {
                    throw new MessagingException(""Expected string, none found."");
                }
                String s = mParseBareString.toString();

                // NIL will be always converted into the empty string.
                if (ImapConstants.NIL.equalsIgnoreCase(s)) {
                    return ImapString.EMPTY;
                }
                return new ImapSimpleString(s);
            } else if (ch == '[') {
                // Eat all until next ']'
                mParseBareString.append((char) readByte());
                mParseBareString.append(readUntil(']'));
                mParseBareString.append(']'); // readUntil won't include the end char.
            } else {
                mParseBareString.append((char) readByte());
            }
        }
    }

    private void parseElements(ImapList list, char end)
            throws IOException, MessagingException {
        for (;;) {
            for (;;) {
                final int next = peek();
                if (next == end) {
                    return;
                }
                if (next != ' ') {
                    break;
                }
                // Skip space
                readByte();
            }
            final ImapElement el = parseElement();
            if (el == null) { // EOL
                return;
            }
            list.add(el);
        }
    }

    private ImapList parseList(char opening, char closing)
            throws IOException, MessagingException {
        expect(opening);
        final ImapList list = new ImapList();
        parseElements(list, closing);
        expect(closing);
        return list;
    }

    private ImapString parseLiteral() throws IOException, MessagingException {
        expect('{');
        final int size;
        try {
            size = Integer.parseInt(readUntil('}'));
        } catch (NumberFormatException nfe) {
            throw new MessagingException(""Invalid length in literal"");
        }
        expect('\r');
        expect('\n');
        FixedLengthInputStream in = new FixedLengthInputStream(mIn, size);
        if (size > mLiteralKeepInMemoryThreshold) {
            return new ImapTempFileLiteral(in);
        } else {
            return new ImapMemoryLiteral(in);
        }
    }
}
",True,274,2,5,11,55,3,15,L6
139,com.android.email.mail.store.imap.ImapConstants.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import com.android.email.mail.Store;

public final class ImapConstants {
    private ImapConstants() {}

    public static final String FETCH_FIELD_BODY_PEEK_BARE = ""BODY.PEEK"";
    public static final String FETCH_FIELD_BODY_PEEK = FETCH_FIELD_BODY_PEEK_BARE + ""[]"";
    public static final String FETCH_FIELD_BODY_PEEK_SANE
            = String.format(""BODY.PEEK[]<0.%d>"", Store.FETCH_BODY_SANE_SUGGESTED_SIZE);
    public static final String FETCH_FIELD_HEADERS =
            ""BODY.PEEK[HEADER.FIELDS (date subject from content-type to cc message-id)]"";

    public static final String ALERT = ""ALERT"";
    public static final String APPEND = ""APPEND"";
    public static final String BAD = ""BAD"";
    public static final String BADCHARSET = ""BADCHARSET"";
    public static final String BODY = ""BODY"";
    public static final String BODY_BRACKET_HEADER = ""BODY[HEADER"";
    public static final String BODYSTRUCTURE = ""BODYSTRUCTURE"";
    public static final String BYE = ""BYE"";
    public static final String CAPABILITY = ""CAPABILITY"";
    public static final String CHECK = ""CHECK"";
    public static final String CLOSE = ""CLOSE"";
    public static final String COPY = ""COPY"";
    public static final String COPYUID = ""COPYUID"";
    public static final String CREATE = ""CREATE"";
    public static final String DELETE = ""DELETE"";
    public static final String EXAMINE = ""EXAMINE"";
    public static final String EXISTS = ""EXISTS"";
    public static final String EXPUNGE = ""EXPUNGE"";
    public static final String FETCH = ""FETCH"";
    public static final String FLAG_ANSWERED = ""\\ANSWERED"";
    public static final String FLAG_DELETED = ""\\DELETED"";
    public static final String FLAG_FLAGGED = ""\\FLAGGED"";
    public static final String FLAG_NO_SELECT = ""\\NOSELECT"";
    public static final String FLAG_SEEN = ""\\SEEN"";
    public static final String FLAGS = ""FLAGS"";
    public static final String FLAGS_SILENT = ""FLAGS.SILENT"";
    public static final String ID = ""ID"";
    public static final String INBOX = ""INBOX"";
    public static final String INTERNALDATE = ""INTERNALDATE"";
    public static final String LIST = ""LIST"";
    public static final String LOGIN = ""LOGIN"";
    public static final String LOGOUT = ""LOGOUT"";
    public static final String LSUB = ""LSUB"";
    public static final String NAMESPACE = ""NAMESPACE"";
    public static final String NO = ""NO"";
    public static final String NOOP = ""NOOP"";
    public static final String OK = ""OK"";
    public static final String PARSE = ""PARSE"";
    public static final String PERMANENTFLAGS = ""PERMANENTFLAGS"";
    public static final String PREAUTH = ""PREAUTH"";
    public static final String READ_ONLY = ""READ-ONLY"";
    public static final String READ_WRITE = ""READ-WRITE"";
    public static final String RENAME = ""RENAME"";
    public static final String RFC822_SIZE = ""RFC822.SIZE"";
    public static final String SEARCH = ""SEARCH"";
    public static final String SELECT = ""SELECT"";
    public static final String STARTTLS = ""STARTTLS"";
    public static final String STATUS = ""STATUS"";
    public static final String STORE = ""STORE"";
    public static final String SUBSCRIBE = ""SUBSCRIBE"";
    public static final String TEXT = ""TEXT"";
    public static final String TRYCREATE = ""TRYCREATE"";
    public static final String UID = ""UID"";
    public static final String UID_COPY = ""UID COPY"";
    public static final String UID_FETCH = ""UID FETCH"";
    public static final String UID_SEARCH = ""UID SEARCH"";
    public static final String UID_STORE = ""UID STORE"";
    public static final String UIDNEXT = ""UIDNEXT"";
    public static final String UIDPLUS = ""UIDPLUS"";
    public static final String UIDVALIDITY = ""UIDVALIDITY"";
    public static final String UNSEEN = ""UNSEEN"";
    public static final String UNSUBSCRIBE = ""UNSUBSCRIBE"";
    public static final String APPENDUID = ""APPENDUID"";
    public static final String NIL = ""NIL"";
}
",False,268,1,1,10,68,6,1,L6
140,com.android.email.mail.store.imap.ImapResponse.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;


/**
 * Class represents an IMAP response.
 */
public class ImapResponse extends ImapList {
    private final String mTag;
    private final boolean mIsContinuationRequest;

    /* package */ ImapResponse(String tag, boolean isContinuationRequest) {
        mTag = tag;
        mIsContinuationRequest = isContinuationRequest;
    }

    /* package */ static boolean isStatusResponse(String symbol) {
        return     ImapConstants.OK.equalsIgnoreCase(symbol)
                || ImapConstants.NO.equalsIgnoreCase(symbol)
                || ImapConstants.BAD.equalsIgnoreCase(symbol)
                || ImapConstants.PREAUTH.equalsIgnoreCase(symbol)
                || ImapConstants.BYE.equalsIgnoreCase(symbol);
    }

    /**
     * @return whether it's a tagged response.
     */
    public boolean isTagged() {
        return mTag != null;
    }

    /**
     * @return whether it's a continuation request.
     */
    public boolean isContinuationRequest() {
        return mIsContinuationRequest;
    }

    public boolean isStatusResponse() {
        return isStatusResponse(getStringOrEmpty(0).getString());
    }

    /**
     * @return whether it's an OK response.
     */
    public boolean isOk() {
        return is(0, ImapConstants.OK);
    }

    /**
     * @return whether it's an BAD response.
     */
    public boolean isBad() {
        return is(0, ImapConstants.BAD);
    }

    /**
     * @return whether it's an NO response.
     */
    public boolean isNo() {
        return is(0, ImapConstants.NO);
    }

    /**
     * @return whether it's an {@code responseType} data response.  (i.e. not tagged).
     * @param index where {@code responseType} should appear.  e.g. 1 for ""FETCH""
     * @param responseType e.g. ""FETCH""
     */
    public final boolean isDataResponse(int index, String responseType) {
        return !isTagged() && getStringOrEmpty(index).is(responseType);
    }

    /**
     * @return Response code (RFC 3501 7.1) if it's a status response.
     *
     * e.g. ""ALERT"" for ""* OK [ALERT] System shutdown in 10 minutes""
     */
    public ImapString getResponseCodeOrEmpty() {
        if (!isStatusResponse()) {
            return ImapString.EMPTY; // Not a status response.
        }
        return getListOrEmpty(1).getStringOrEmpty(0);
    }

    /**
     * @return Alert message it it has ALERT response code.
     *
     * e.g. ""System shutdown in 10 minutes"" for ""* OK [ALERT] System shutdown in 10 minutes""
     */
    public ImapString getAlertTextOrEmpty() {
        if (!getResponseCodeOrEmpty().is(ImapConstants.ALERT)) {
            return ImapString.EMPTY; // Not an ALERT
        }
        // The 3rd element contains all the rest of line.
        return getStringOrEmpty(2);
    }

    /**
     * @return Response text in a status response.
     */
    public ImapString getStatusResponseTextOrEmpty() {
        if (!isStatusResponse()) {
            return ImapString.EMPTY;
        }
        return getStringOrEmpty(getElementOrNone(1).isList() ? 2 : 1);
    }

    @Override
    public String toString() {
        String tag = mTag;
        if (isContinuationRequest()) {
            tag = ""+"";
        }
        return ""#"" + tag + ""# "" + super.toString();
    }

    @Override
    public boolean equalsForTest(ImapElement that) {
        if (!super.equalsForTest(that)) {
            return false;
        }
        final ImapResponse thatResponse = (ImapResponse) that;
        if (mTag == null) {
            if (thatResponse.mTag != null) {
                return false;
            }
        } else {
            if (!mTag.equals(thatResponse.mTag)) {
                return false;
            }
        }
        if (mIsContinuationRequest != thatResponse.mIsContinuationRequest) {
            return false;
        }
        return true;
    }
}
",False,274,2,4,11,67,8,4,L6
141,com.android.email.mail.store.imap.ImapString.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import com.android.emailcommon.Logging;

import android.util.Log;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

/**
 * Class represents an IMAP ""element"" that is not a list.
 *
 * An atom, quoted string, literal, are all represented by this.  Values like OK, STATUS are too.
 * Also, this class class may contain more arbitrary value like ""BODY[HEADER.FIELDS (""DATE"")]"".
 * See {@link ImapResponseParser}.
 */
public abstract class ImapString extends ImapElement {
    private static final byte[] EMPTY_BYTES = new byte[0];

    public static final ImapString EMPTY = new ImapString() {
        @Override public void destroy() {
            // Don't call super.destroy().
            // It's a shared object.  We don't want the mDestroyed to be set on this.
        }

        @Override public String getString() {
            return """";
        }

        @Override public InputStream getAsStream() {
            return new ByteArrayInputStream(EMPTY_BYTES);
        }

        @Override public String toString() {
            return """";
        }
    };

    // This is used only for parsing IMAP's FETCH ENVELOPE command, in which
    // en_US-like date format is used like ""01-Jan-2009 11:20:39 -0800"", so this should be
    // handled by Locale.US
    private final static SimpleDateFormat DATE_TIME_FORMAT =
            new SimpleDateFormat(""dd-MMM-yyyy HH:mm:ss Z"", Locale.US);

    private boolean mIsInteger;
    private int mParsedInteger;
    private Date mParsedDate;

    @Override
    public final boolean isList() {
        return false;
    }

    @Override
    public final boolean isString() {
        return true;
    }

    /**
     * @return true if and only if the length of the string is larger than 0.
     *
     * Note: IMAP NIL is considered an empty string. See {@link ImapResponseParser
     * #parseBareString}.
     * On the other hand, a quoted/literal string with value NIL (i.e. ""NIL"" and {3}\r\nNIL) is
     * treated literally.
     */
    public final boolean isEmpty() {
        return getString().length() == 0;
    }

    public abstract String getString();

    public abstract InputStream getAsStream();

    /**
     * @return whether it can be parsed as a number.
     */
    public final boolean isNumber() {
        if (mIsInteger) {
            return true;
        }
        try {
            mParsedInteger = Integer.parseInt(getString());
            mIsInteger = true;
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }

    /**
     * @return value parsed as a number.
     */
    public final int getNumberOrZero() {
        if (!isNumber()) {
            return 0;
        }
        return mParsedInteger;
    }

    /**
     * @return whether it can be parsed as a date using {@link #DATE_TIME_FORMAT}.
     */
    public final boolean isDate() {
        if (mParsedDate != null) {
            return true;
        }
        if (isEmpty()) {
            return false;
        }
        try {
            mParsedDate = DATE_TIME_FORMAT.parse(getString());
            return true;
        } catch (ParseException e) {
            Log.w(Logging.LOG_TAG, getString() + "" can't be parsed as a date."");
            return false;
        }
    }

    /**
     * @return value it can be parsed as a {@link Date}, or null otherwise.
     */
    public final Date getDateOrNull() {
        if (!isDate()) {
            return null;
        }
        return mParsedDate;
    }

    /**
     * @return whether the value case-insensitively equals to {@code s}.
     */
    public final boolean is(String s) {
        if (s == null) {
            return false;
        }
        return getString().equalsIgnoreCase(s);
    }


    /**
     * @return whether the value case-insensitively starts with {@code s}.
     */
    public final boolean startsWith(String prefix) {
        if (prefix == null) {
            return false;
        }
        final String me = this.getString();
        if (me.length() < prefix.length()) {
            return false;
        }
        return me.substring(0, prefix.length()).equalsIgnoreCase(prefix);
    }

    // To force subclasses to implement it.
    @Override
    public abstract String toString();

    @Override
    public final boolean equalsForTest(ImapElement that) {
        if (!super.equalsForTest(that)) {
            return false;
        }
        ImapString thatString = (ImapString) that;
        return getString().equals(thatString.getString());
    }
}
",True,153,10,49,1,2,14,2,L6
142,com.android.email.mail.store.imap.ImapTempFileLiteral.java,"/*
 * Copyright (C) 2010 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import com.android.email.FixedLengthInputStream;
import com.android.emailcommon.Logging;
import com.android.emailcommon.TempDirectory;
import com.android.emailcommon.utility.Utility;

import org.apache.commons.io.IOUtils;

import android.util.Log;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * Subclass of {@link ImapString} used for literals backed by a temp file.
 */
public class ImapTempFileLiteral extends ImapString {
    /* package for test */ final File mFile;

    /** Size is purely for toString() */
    private final int mSize;

    /* package */  ImapTempFileLiteral(FixedLengthInputStream stream) throws IOException {
        mSize = stream.getLength();
        mFile = File.createTempFile(""imap"", "".tmp"", TempDirectory.getTempDirectory());

        // Unfortunately, we can't really use deleteOnExit(), because temp filenames are random
        // so it'd simply cause a memory leak.
        // deleteOnExit() simply adds filenames to a static list and the list will never shrink.
        // mFile.deleteOnExit();
        OutputStream out = new FileOutputStream(mFile);
        IOUtils.copy(stream, out);
        out.close();
    }

    /**
     * Make sure we delete the temp file.
     *
     * We should always be calling {@link ImapResponse#destroy()}, but it's here as a last resort.
     */
    @Override
    protected void finalize() throws Throwable {
        try {
            destroy();
        } finally {
            super.finalize();
        }
    }

    @Override
    public InputStream getAsStream() {
        checkNotDestroyed();
        try {
            return new FileInputStream(mFile);
        } catch (FileNotFoundException e) {
            // It's probably possible if we're low on storage and the system clears the cache dir.
            Log.w(Logging.LOG_TAG, ""ImapTempFileLiteral: Temp file not found"");

            // Return 0 byte stream as a dummy...
            return new ByteArrayInputStream(new byte[0]);
        }
    }

    @Override
    public String getString() {
        checkNotDestroyed();
        try {
            return Utility.fromAscii(IOUtils.toByteArray(getAsStream()));
        } catch (IOException e) {
            Log.w(Logging.LOG_TAG, ""ImapTempFileLiteral: Error while reading temp file"");
            return """";
        }
    }

    @Override
    public void destroy() {
        try {
            if (!isDestroyed() && mFile.exists()) {
                mFile.delete();
            }
        } catch (RuntimeException re) {
            // Just log and ignore.
            Log.w(Logging.LOG_TAG, ""Failed to remove temp file: "" + re.getMessage());
        }
        super.destroy();
    }

    @Override
    public String toString() {
        return String.format(""{%d byte literal(file)}"", mSize);
    }

    public boolean tempFileExistsForTest() {
        return mFile.exists();
    }
}
",True,166,12,49,4,8,3,7,L6
143,com.android.email.mail.store.imap.ImapUtility.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.mail.store.imap;

import com.android.emailcommon.Logging;

import android.util.Log;

import java.util.ArrayList;

/**
 * Utility methods for use with IMAP.
 */
public class ImapUtility {
    /**
     * Apply quoting rules per IMAP RFC,
     * quoted          = DQUOTE *QUOTED-CHAR DQUOTE
     * QUOTED-CHAR     = <any TEXT-CHAR except quoted-specials> / ""\"" quoted-specials
     * quoted-specials = DQUOTE / ""\""
     *
     * This is used primarily for IMAP login, but might be useful elsewhere.
     *
     * NOTE:  Not very efficient - you may wish to preflight this, or perhaps it should check
     * for trouble chars before calling the replace functions.
     *
     * @param s The string to be quoted.
     * @return A copy of the string, having undergone quoting as described above
     */
    public static String imapQuoted(String s) {

        // First, quote any backslashes by replacing \ with \\
        // regex Pattern:  \\    (Java string const = \\\\)
        // Substitute:     \\\\  (Java string const = \\\\\\\\)
        String result = s.replaceAll(""\\\\"", ""\\\\\\\\"");

        // Then, quote any double-quotes by replacing "" with \""
        // regex Pattern:  ""    (Java string const = \"")
        // Substitute:     \\""  (Java string const = \\\\\"")
        result = result.replaceAll(""\"""", ""\\\\\"""");

        // return string with quotes around it
        return ""\"""" + result + ""\"""";
    }

    /**
     * Gets all of the values in a sequence set per RFC 3501. Any ranges are expanded into a
     * list of individual numbers. If the set is invalid, an empty array is returned.
     * <pre>
     * sequence-number = nz-number / ""*""
     * sequence-range  = sequence-number "":"" sequence-number
     * sequence-set    = (sequence-number / sequence-range) *("","" sequence-set)
     * </pre>
     */
    public static String[] getImapSequenceValues(String set) {
        ArrayList<String> list = new ArrayList<String>();
        if (set != null) {
            String[] setItems = set.split("","");
            for (String item : setItems) {
                if (item.indexOf(':') == -1) {
                    // simple item
                    try {
                        Integer.parseInt(item); // Don't need the value; just ensure it's valid
                        list.add(item);
                    } catch (NumberFormatException e) {
                        Log.d(Logging.LOG_TAG, ""Invalid UID value"", e);
                    }
                } else {
                    // range
                    for (String rangeItem : getImapRangeValues(item)) {
                        list.add(rangeItem);
                    }
                }
            }
        }
        String[] stringList = new String[list.size()];
        return list.toArray(stringList);
    }

    /**
     * Expand the given number range into a list of individual numbers. If the range is not valid,
     * an empty array is returned.
     * <pre>
     * sequence-number = nz-number / ""*""
     * sequence-range  = sequence-number "":"" sequence-number
     * sequence-set    = (sequence-number / sequence-range) *("","" sequence-set)
     * </pre>
     */
    public static String[] getImapRangeValues(String range) {
        ArrayList<String> list = new ArrayList<String>();
        try {
            if (range != null) {
                int colonPos = range.indexOf(':');
                if (colonPos > 0) {
                    int first  = Integer.parseInt(range.substring(0, colonPos));
                    int second = Integer.parseInt(range.substring(colonPos + 1));
                    if (first < second) {
                        for (int i = first; i <= second; i++) {
                            list.add(Integer.toString(i));
                        }
                    } else {
                        for (int i = first; i >= second; i--) {
                            list.add(Integer.toString(i));
                        }
                    }
                }
            }
        } catch (NumberFormatException e) {
            Log.d(Logging.LOG_TAG, ""Invalid range value"", e);
        }
        String[] stringList = new String[list.size()];
        return list.toArray(stringList);
    }
}
",False,149,11,51,1,1,3,1,L1
144,com.android.email.widget.EmailWidgetLoader.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.widget;

import com.android.email.R;
import com.android.email.data.ThrottlingCursorLoader;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.EmailContent.MessageColumns;
import com.android.emailcommon.provider.Mailbox;

import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.CursorWrapper;

/**
 * Loader for {@link EmailWidget}.
 *
 * This loader not only loads the messages, but also:
 * - The number of accounts.
 * - The message count shown in the widget header.
 *   It's currently just the same as the message count, but this will be updated to the unread
 *   counts for inboxes.
 */
class EmailWidgetLoader extends ThrottlingCursorLoader {
    private static final String SORT_TIMESTAMP_DESCENDING = MessageColumns.TIMESTAMP + "" DESC"";

    // The projection to be used by the WidgetLoader
    private static final String[] WIDGET_PROJECTION = new String[] {
            EmailContent.RECORD_ID, MessageColumns.DISPLAY_NAME, MessageColumns.TIMESTAMP,
            MessageColumns.SUBJECT, MessageColumns.FLAG_READ, MessageColumns.FLAG_FAVORITE,
            MessageColumns.FLAG_ATTACHMENT, MessageColumns.MAILBOX_KEY, MessageColumns.SNIPPET,
            MessageColumns.ACCOUNT_KEY, MessageColumns.FLAGS
            };
    public static final int WIDGET_COLUMN_ID = 0;
    public static final int WIDGET_COLUMN_DISPLAY_NAME = 1;
    public static final int WIDGET_COLUMN_TIMESTAMP = 2;
    public static final int WIDGET_COLUMN_SUBJECT = 3;
    public static final int WIDGET_COLUMN_FLAG_READ = 4;
    public static final int WIDGET_COLUMN_FLAG_FAVORITE = 5;
    public static final int WIDGET_COLUMN_FLAG_ATTACHMENT = 6;
    public static final int WIDGET_COLUMN_MAILBOX_KEY = 7;
    public static final int WIDGET_COLUMN_SNIPPET = 8;
    public static final int WIDGET_COLUMN_ACCOUNT_KEY = 9;
    public static final int WIDGET_COLUMN_FLAGS = 10;

    private long mAccountId;
    private long mMailboxId;

    /**
     * Cursor data specifically for use by the Email widget. Contains a cursor of messages in
     * addition to a message count and account name. The later elements were opportunistically
     * placed in this cursor. We could have defined multiple loaders for these items.
     */
    static class WidgetCursor extends CursorWrapper {
        private final int mMessageCount;
        private final String mAccountName;
        private final String mMailboxName;

        public WidgetCursor(Cursor cursor, int messageCount, String accountName,
                String mailboxName) {
            super(cursor);
            mMessageCount = messageCount;
            mAccountName = accountName;
            mMailboxName = mailboxName;
        }

        /**
         * Gets the count to be shown on the widget header. If the currently viewed mailbox ID is
         * not {@link Mailbox#QUERY_ALL_FAVORITES}, it is the unread count, which is different from
         * number of records returned by {@link #getCount()}.
         */
        public int getMessageCount() {
            return mMessageCount;
        }
        /** Gets the display name of the account */
        public String getAccountName() {
            return mAccountName;
        }
        /** Gets the display name of the mailbox */
        public String getMailboxName() {
            return mMailboxName;
        }
    }

    private final Context mContext;

    EmailWidgetLoader(Context context) {
        super(context, Message.CONTENT_URI, WIDGET_PROJECTION, null,
                null, SORT_TIMESTAMP_DESCENDING);
        mContext = context;
    }

    @Override
    public Cursor loadInBackground() {
        final Cursor messagesCursor = super.loadInBackground();

        // Reset the notification Uri to our Message table notifier URI
        messagesCursor.setNotificationUri(mContext.getContentResolver(), Message.NOTIFIER_URI);

        final int messageCount;
        if (mMailboxId != Mailbox.QUERY_ALL_FAVORITES) {
            String selection = ""("" + getSelection() + "" ) AND "" + MessageColumns.FLAG_READ + "" = 0"";
            messageCount = EmailContent.count(mContext, Message.CONTENT_URI, selection,
                    getSelectionArgs());
        } else {
            // Just use the number of all messages shown.
            messageCount = messagesCursor.getCount();
        }
        Account account = Account.restoreAccountWithId(mContext, mAccountId);
        final String accountName;
        if (account != null) {
            accountName = account.mDisplayName;
        } else {
            if (mAccountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                int accountCount = EmailContent.count(mContext, Account.CONTENT_URI);
                Resources res = mContext.getResources();
                String countString =
                        res.getQuantityString(R.plurals.picker_combined_view_account_count,
                        accountCount, accountCount);
                accountName = res.getString(R.string.picker_combined_view_fmt, countString);
            } else {
                // TODO What to use here? ""unknown""? Account is real, but, doesn't exist.
                accountName = null;
            }
        }
        final String mailboxName;
        if (mMailboxId > 0) {
            Mailbox mailbox = Mailbox.restoreMailboxWithId(mContext, mMailboxId);
            if (mailbox != null) {
                mailboxName = mailbox.mDisplayName;    // regular mailbox
            } else {
                // TODO What use here? ""unknown""? Mailbox is ""real"", but, doesn't exist.
                mailboxName = null;
            }
        } else {
            if (mMailboxId == Mailbox.QUERY_ALL_INBOXES) {
                mailboxName = mContext.getString(R.string.picker_mailbox_name_all_inbox);
            } else { // default to all unread for the account's inbox
                mailboxName = mContext.getString(R.string.picker_mailbox_name_all_unread);
            }
        }

        return new WidgetCursor(messagesCursor, messageCount, accountName, mailboxName);
    }

    /**
     * Stop any pending load, reset selection parameters, and start loading.
     *
     * Must be called from the UI thread
     *
     * @param accountId The ID of the account. May be {@link Account#ACCOUNT_ID_COMBINED_VIEW}.
     * @param mailboxId The mailbox to load; may either be a real mailbox or the pseudo mailbox
     *          {@link Mailbox#QUERY_ALL_INBOXES} or {@link Mailbox#QUERY_ALL_UNREAD}. If it's
     *          neither of these pseudo mailboxes, {@link Mailbox#QUERY_ALL_UNREAD} will be used.
     */
    void load(long accountId, long mailboxId) {
        reset();
        mAccountId = accountId;
        mMailboxId = mailboxId;
        setSelectionAndArgs();
        startLoading();
    }

    /** Sets the loader's selection and arguments depending upon the account and mailbox */
    private void setSelectionAndArgs() {
        if (mAccountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
            if (mMailboxId == Mailbox.QUERY_ALL_INBOXES) {
                setSelection(Message.ALL_INBOX_SELECTION);
            } else { // default to all unread
                setSelection(Message.ALL_UNREAD_SELECTION);
            }
            setSelectionArgs(null);
        } else {
            if (mMailboxId > 0L) {
                // Simple mailbox selection
                setSelection(
                    MessageColumns.ACCOUNT_KEY + ""=? AND "" +
                    MessageColumns.MAILBOX_KEY + ""=?"");
                setSelectionArgs(
                        new String[] { Long.toString(mAccountId), Long.toString(mMailboxId) });
            } else {
                if (mMailboxId == Mailbox.QUERY_ALL_INBOXES) {
                    setSelection(Message.PER_ACCOUNT_INBOX_SELECTION);
                } else { // default to all unread for the account's inbox
                    setSelection(Message.PER_ACCOUNT_UNREAD_SELECTION);
                }
                setSelectionArgs(new String[] { Long.toString(mAccountId) });
            }
        }
    }
}
",False,162,8,67,4,7,1,4,L6
145,com.android.email.widget.EmailWidget.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.widget;

import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.content.Context;
import android.content.Intent;
import android.content.Loader;
import android.content.Loader.OnLoadCompleteListener;
import android.content.res.Resources;
import android.database.Cursor;
import android.graphics.Typeface;
import android.net.Uri;
import android.net.Uri.Builder;
import android.text.Spannable;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.TextUtils;
import android.text.format.DateUtils;
import android.text.style.AbsoluteSizeSpan;
import android.text.style.ForegroundColorSpan;
import android.text.style.StyleSpan;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;
import android.widget.RemoteViewsService;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.ResourceHelper;
import com.android.email.activity.MessageCompose;
import com.android.email.activity.UiUtilities;
import com.android.email.activity.Welcome;
import com.android.email.provider.WidgetProvider.WidgetService;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.EmailContent.Message;
import com.android.emailcommon.provider.Mailbox;
import com.android.emailcommon.utility.EmailAsyncTask;

import java.util.List;

/**
 * The email widget.
 * <p><em>NOTE</em>: All methods must be called on the UI thread so synchronization is NOT required
 * in this class)
 */
public class EmailWidget implements RemoteViewsService.RemoteViewsFactory,
        OnLoadCompleteListener<Cursor> {
    public static final String TAG = ""EmailWidget"";

    /**
     * When handling clicks in a widget ListView, a single PendingIntent template is provided to
     * RemoteViews, and the individual ""on click"" actions are distinguished via a ""fillInIntent""
     * on each list element; when a click is received, this ""fillInIntent"" is merged with the
     * PendingIntent using Intent.fillIn().  Since this mechanism does NOT preserve the Extras
     * Bundle, we instead encode information about the action (e.g. view, reply, etc.) and its
     * arguments (e.g. messageId, mailboxId, etc.) in an Uri which is added to the Intent via
     * Intent.setDataAndType()
     *
     * The mime type MUST be set in the Intent, even though we do not use it; therefore, it's value
     * is entirely arbitrary.
     *
     * Our ""command"" Uri is NOT used by the system in any manner, and is therefore constrained only
     * in the requirement that it be syntactically valid.
     *
     * We use the following convention for our commands:
     *     widget://command/<command>/<arg1>[/<arg2>]
     */
    private static final String WIDGET_DATA_MIME_TYPE = ""com.android.email/widget_data"";

    private static final Uri COMMAND_URI = Uri.parse(""widget://command"");

    // Command names and Uri's built upon COMMAND_URI
    private static final String COMMAND_NAME_VIEW_MESSAGE = ""view_message"";
    private static final Uri COMMAND_URI_VIEW_MESSAGE =
            COMMAND_URI.buildUpon().appendPath(COMMAND_NAME_VIEW_MESSAGE).build();

    // TODO Can this be moved to the loader and made a database 'LIMIT'?
    private static final int MAX_MESSAGE_LIST_COUNT = 25;

    private static String sSubjectSnippetDivider;
    private static int sSenderFontSize;
    private static int sSubjectFontSize;
    private static int sDateFontSize;
    private static int sDefaultTextColor;
    private static int sLightTextColor;

    private final Context mContext;
    private final AppWidgetManager mWidgetManager;

    // The widget identifier
    private final int mWidgetId;

    // The widget's loader (derived from ThrottlingCursorLoader)
    private final EmailWidgetLoader mLoader;
    private final ResourceHelper mResourceHelper;

    /** The account ID of this widget. May be {@link Account#ACCOUNT_ID_COMBINED_VIEW}. */
    private long mAccountId = Account.NO_ACCOUNT;
    /** The display name of this account */
    private String mAccountName;
    /** The display name of this mailbox */
    private String mMailboxName;

    /**
     * The cursor for the messages, with some extra info such as the number of accounts.
     *
     * Note this cursor can be closed any time by the loader.  Always use {@link #isCursorValid()}
     * before touching its contents.
     */
    private EmailWidgetLoader.WidgetCursor mCursor;

    public EmailWidget(Context context, int _widgetId) {
        super();
        if (Email.DEBUG) {
            Log.d(TAG, ""Creating EmailWidget with id = "" + _widgetId);
        }
        mContext = context.getApplicationContext();
        mWidgetManager = AppWidgetManager.getInstance(mContext);

        mWidgetId = _widgetId;
        mLoader = new EmailWidgetLoader(mContext);
        mLoader.registerListener(0, this);
        if (sSubjectSnippetDivider == null) {
            // Initialize string, color, dimension resources
            Resources res = mContext.getResources();
            sSubjectSnippetDivider =
                res.getString(R.string.message_list_subject_snippet_divider);
            sSenderFontSize = res.getDimensionPixelSize(R.dimen.widget_senders_font_size);
            sSubjectFontSize = res.getDimensionPixelSize(R.dimen.widget_subject_font_size);
            sDateFontSize = res.getDimensionPixelSize(R.dimen.widget_date_font_size);
            sDefaultTextColor = res.getColor(R.color.widget_default_text_color);
            sDefaultTextColor = res.getColor(R.color.widget_default_text_color);
            sLightTextColor = res.getColor(R.color.widget_light_text_color);
        }
        mResourceHelper = ResourceHelper.getInstance(mContext);
    }

    /**
     * Start loading the data.  At this point nothing on the widget changes -- the current view
     * will remain valid until the loader loads the latest data.
     */
    public void start() {
        long accountId = WidgetManager.loadAccountIdPref(mContext, mWidgetId);
        long mailboxId = WidgetManager.loadMailboxIdPref(mContext, mWidgetId);
        // Legacy support; if preferences haven't been saved for this widget, load something
        if (accountId == Account.NO_ACCOUNT) {
            accountId = Account.ACCOUNT_ID_COMBINED_VIEW;
            mailboxId = Mailbox.QUERY_ALL_INBOXES;
        }
        mAccountId = accountId;
        mLoader.load(mAccountId, mailboxId);
    }

    /**
     * Resets the data in the widget and forces a reload.
     */
    public void reset() {
        mLoader.reset();
        start();
    }

    private boolean isCursorValid() {
        return mCursor != null && !mCursor.isClosed();
    }

    /**
     * Called when the loader finished loading data.  Update the widget.
     */
    @Override
    public void onLoadComplete(Loader<Cursor> loader, Cursor cursor) {
        mCursor = (EmailWidgetLoader.WidgetCursor) cursor;   // Save away the cursor
        mAccountName = mCursor.getAccountName();
        mMailboxName = mCursor.getMailboxName();
        updateHeader();
        mWidgetManager.notifyAppWidgetViewDataChanged(mWidgetId, R.id.message_list);
    }

    /**
     * Convenience method for creating an onClickPendingIntent that launches another activity
     * directly.
     *
     * @param views The RemoteViews we're inflating
     * @param buttonId the id of the button view
     * @param intent The intent to be used when launching the activity
     */
    private void setActivityIntent(RemoteViews views, int buttonId, Intent intent) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // just in case intent comes without it
        PendingIntent pendingIntent =
                PendingIntent.getActivity(mContext, (int) mAccountId, intent,
                        PendingIntent.FLAG_UPDATE_CURRENT);
        views.setOnClickPendingIntent(buttonId, pendingIntent);
    }

    /**
     * Convenience method for constructing a fillInIntent for a given list view element.
     * Appends the command and any arguments to a base Uri.
     *
     * @param views the RemoteViews we are inflating
     * @param viewId the id of the view
     * @param baseUri the base uri for the command
     * @param args any arguments to the command
     */
    private void setFillInIntent(RemoteViews views, int viewId, Uri baseUri, String ... args) {
        Intent intent = new Intent();
        Builder builder = baseUri.buildUpon();
        for (String arg: args) {
            builder.appendPath(arg);
        }
        intent.setDataAndType(builder.build(), WIDGET_DATA_MIME_TYPE);
        views.setOnClickFillInIntent(viewId, intent);
    }

    /**
     * Called back by {@link com.android.email.provider.WidgetProvider.WidgetService} to
     * handle intents created by remote views.
     */
    public static boolean processIntent(Context context, Intent intent) {
        final Uri data = intent.getData();
        if (data == null) {
            return false;
        }
        List<String> pathSegments = data.getPathSegments();
        // Our path segments are <command>, <arg1> [, <arg2>]
        // First, a quick check of Uri validity
        if (pathSegments.size() < 2) {
            throw new IllegalArgumentException();
        }
        String command = pathSegments.get(0);
        // Ignore unknown action names
        try {
            final long arg1 = Long.parseLong(pathSegments.get(1));
            if (EmailWidget.COMMAND_NAME_VIEW_MESSAGE.equals(command)) {
                // ""view"", <message id>, <mailbox id>
                openMessage(context, Long.parseLong(pathSegments.get(2)), arg1);
            }
        } catch (NumberFormatException e) {
            // Shouldn't happen as we construct all of the Uri's
            return false;
        }
        return true;
    }

    private static void openMessage(final Context context, final long mailboxId,
            final long messageId) {
        EmailAsyncTask.runAsyncParallel(new Runnable() {
            @Override
            public void run() {
                Mailbox mailbox = Mailbox.restoreMailboxWithId(context, mailboxId);
                if (mailbox == null) return;
                context.startActivity(Welcome.createOpenMessageIntent(context, mailbox.mAccountKey,
                        mailboxId, messageId));
            }
        });
    }

    private void setTextViewTextAndDesc(RemoteViews views, final int id, String text) {
        views.setTextViewText(id, text);
        views.setContentDescription(id, text);
    }

    private void setupTitleAndCount(RemoteViews views) {
        // Set up the title (view type + count of messages)
        setTextViewTextAndDesc(views, R.id.widget_title, mMailboxName);
        views.setViewVisibility(R.id.widget_tap, View.VISIBLE);
        setTextViewTextAndDesc(views, R.id.widget_tap, mAccountName);
        String count = """";
        if (isCursorValid()) {
            count = UiUtilities.getMessageCountForUi(mContext, mCursor.getMessageCount(), false);
        }
        setTextViewTextAndDesc(views, R.id.widget_count, count);
    }

    /**
     * Update the ""header"" of the widget (i.e. everything that doesn't include the scrolling
     * message list)
     */
    private void updateHeader() {
        if (Email.DEBUG) {
            Log.d(TAG, ""#updateHeader(); widgetId: "" + mWidgetId);
        }

        // Get the widget layout
        RemoteViews views =
                new RemoteViews(mContext.getPackageName(), R.layout.widget);

        // Set up the list with an adapter
        Intent intent = new Intent(mContext, WidgetService.class);
        intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mWidgetId);
        intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));
        views.setRemoteAdapter(R.id.message_list, intent);

        setupTitleAndCount(views);

        if (isCursorValid()) {
            // Show compose icon & message list
            if (mAccountId == Account.ACCOUNT_ID_COMBINED_VIEW) {
                // Don't allow compose for ""combined"" view
                views.setViewVisibility(R.id.widget_compose, View.INVISIBLE);
            } else {
                views.setViewVisibility(R.id.widget_compose, View.VISIBLE);
            }
            views.setViewVisibility(R.id.message_list, View.VISIBLE);
            views.setViewVisibility(R.id.tap_to_configure, View.GONE);
            // Create click intent for ""compose email"" target
            intent = MessageCompose.getMessageComposeIntent(mContext, mAccountId);
            intent.putExtra(MessageCompose.EXTRA_FROM_WIDGET, true);
            setActivityIntent(views, R.id.widget_compose, intent);
            // Create click intent for logo to open inbox
            intent = Welcome.createOpenAccountInboxIntent(mContext, mAccountId);
            setActivityIntent(views, R.id.widget_logo, intent);
        } else {
            // TODO This really should never happen ... probably can remove the else block
            // Hide compose icon & show ""touch to configure"" text
            views.setViewVisibility(R.id.widget_compose, View.INVISIBLE);
            views.setViewVisibility(R.id.message_list, View.GONE);
            views.setViewVisibility(R.id.tap_to_configure, View.VISIBLE);
            // Create click intent for ""touch to configure"" target
            intent = Welcome.createOpenAccountInboxIntent(mContext, -1);
            setActivityIntent(views, R.id.tap_to_configure, intent);
        }

        // Use a bare intent for our template; we need to fill everything in
        intent = new Intent(mContext, WidgetService.class);
        PendingIntent pendingIntent = PendingIntent.getService(mContext, 0, intent,
                PendingIntent.FLAG_UPDATE_CURRENT);
        views.setPendingIntentTemplate(R.id.message_list, pendingIntent);

        // And finally update the widget
        mWidgetManager.updateAppWidget(mWidgetId, views);
    }

    /**
     * Add size and color styling to text
     *
     * @param text the text to style
     * @param size the font size for this text
     * @param color the color for this text
     * @return a CharSequence quitable for use in RemoteViews.setTextViewText()
     */
    private CharSequence addStyle(CharSequence text, int size, int color) {
        SpannableStringBuilder builder = new SpannableStringBuilder(text);
        builder.setSpan(
                new AbsoluteSizeSpan(size), 0, text.length(),
                Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        if (color != 0) {
            builder.setSpan(new ForegroundColorSpan(color), 0, text.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return builder;
    }

    /**
     * Create styled text for our combination subject and snippet
     *
     * @param subject the message's subject (or null)
     * @param snippet the message's snippet (or null)
     * @param read whether or not the message is read
     * @return a CharSequence suitable for use in RemoteViews.setTextViewText()
     */
    private CharSequence getStyledSubjectSnippet(String subject, String snippet, boolean read) {
        SpannableStringBuilder ssb = new SpannableStringBuilder();
        boolean hasSubject = false;
        if (!TextUtils.isEmpty(subject)) {
            SpannableString ss = new SpannableString(subject);
            ss.setSpan(new StyleSpan(read ? Typeface.NORMAL : Typeface.BOLD), 0, ss.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            ss.setSpan(new ForegroundColorSpan(sDefaultTextColor), 0, ss.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            ssb.append(ss);
            hasSubject = true;
        }
        if (!TextUtils.isEmpty(snippet)) {
            if (hasSubject) {
                ssb.append(sSubjectSnippetDivider);
            }
            SpannableString ss = new SpannableString(snippet);
            ss.setSpan(new ForegroundColorSpan(sLightTextColor), 0, snippet.length(),
                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
            ssb.append(ss);
        }
        return addStyle(ssb, sSubjectFontSize, 0);
    }

    @Override
    public RemoteViews getViewAt(int position) {
        // Use the cursor to set up the widget
        if (!isCursorValid() || !mCursor.moveToPosition(position)) {
            return getLoadingView();
        }
        RemoteViews views =
            new RemoteViews(mContext.getPackageName(), R.layout.widget_list_item);
        boolean isUnread = mCursor.getInt(EmailWidgetLoader.WIDGET_COLUMN_FLAG_READ) != 1;
        int drawableId = R.drawable.conversation_read_selector;
        if (isUnread) {
            drawableId = R.drawable.conversation_unread_selector;
        }
        views.setInt(R.id.widget_message, ""setBackgroundResource"", drawableId);

        // Add style to sender
        String rawSender =
                mCursor.isNull(EmailWidgetLoader.WIDGET_COLUMN_DISPLAY_NAME)
                    ? """"    // an empty string
                    : mCursor.getString(EmailWidgetLoader.WIDGET_COLUMN_DISPLAY_NAME);
        SpannableStringBuilder from = new SpannableStringBuilder(rawSender);
        from.setSpan(
                isUnread ? new StyleSpan(Typeface.BOLD) : new StyleSpan(Typeface.NORMAL), 0,
                from.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        CharSequence styledFrom = addStyle(from, sSenderFontSize, sDefaultTextColor);
        views.setTextViewText(R.id.widget_from, styledFrom);
        views.setContentDescription(R.id.widget_from, rawSender);

        long timestamp = mCursor.getLong(EmailWidgetLoader.WIDGET_COLUMN_TIMESTAMP);
        // Get a nicely formatted date string (relative to today)
        String date = DateUtils.getRelativeTimeSpanString(mContext, timestamp).toString();
        // Add style to date
        CharSequence styledDate = addStyle(date, sDateFontSize, sDefaultTextColor);
        views.setTextViewText(R.id.widget_date, styledDate);
        views.setContentDescription(R.id.widget_date, date);

        // Add style to subject/snippet
        String subject = mCursor.getString(EmailWidgetLoader.WIDGET_COLUMN_SUBJECT);
        String snippet = mCursor.getString(EmailWidgetLoader.WIDGET_COLUMN_SNIPPET);
        CharSequence subjectAndSnippet = getStyledSubjectSnippet(subject, snippet, !isUnread);
        views.setTextViewText(R.id.widget_subject, subjectAndSnippet);
        views.setContentDescription(R.id.widget_subject, subject);

        int messageFlags = mCursor.getInt(EmailWidgetLoader.WIDGET_COLUMN_FLAGS);
        boolean hasInvite = (messageFlags & Message.FLAG_INCOMING_MEETING_INVITE) != 0;
        views.setViewVisibility(R.id.widget_invite, hasInvite ? View.VISIBLE : View.GONE);

        boolean hasAttachment =
                mCursor.getInt(EmailWidgetLoader.WIDGET_COLUMN_FLAG_ATTACHMENT) != 0;
        views.setViewVisibility(R.id.widget_attachment,
                hasAttachment ? View.VISIBLE : View.GONE);

        if (mAccountId != Account.ACCOUNT_ID_COMBINED_VIEW) {
            views.setViewVisibility(R.id.color_chip, View.INVISIBLE);
        } else {
            long accountId = mCursor.getLong(EmailWidgetLoader.WIDGET_COLUMN_ACCOUNT_KEY);
            int colorId = mResourceHelper.getAccountColorId(accountId);
            if (colorId != ResourceHelper.UNDEFINED_RESOURCE_ID) {
                // Color defined by resource ID, so, use it
                views.setViewVisibility(R.id.color_chip, View.VISIBLE);
                views.setImageViewResource(R.id.color_chip, colorId);
            } else {
                // Color not defined by resource ID, nothing we can do, so, hide the chip
                views.setViewVisibility(R.id.color_chip, View.INVISIBLE);
            }
        }

        // Set button intents for view, reply, and delete
        String messageId = mCursor.getString(EmailWidgetLoader.WIDGET_COLUMN_ID);
        String mailboxId = mCursor.getString(EmailWidgetLoader.WIDGET_COLUMN_MAILBOX_KEY);
        setFillInIntent(views, R.id.widget_message, COMMAND_URI_VIEW_MESSAGE,
                messageId, mailboxId);

        return views;
    }

    @Override
    public int getCount() {
        if (!isCursorValid()) return 0;
        return Math.min(mCursor.getCount(), MAX_MESSAGE_LIST_COUNT);
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public RemoteViews getLoadingView() {
        RemoteViews view = new RemoteViews(mContext.getPackageName(), R.layout.widget_loading);
        view.setTextViewText(R.id.loading_text, mContext.getString(R.string.widget_loading));
        return view;
    }

    @Override
    public int getViewTypeCount() {
        // Regular list view and the ""loading"" view
        return 2;
    }

    @Override
    public boolean hasStableIds() {
        return true;
    }

    @Override
    public void onDataSetChanged() {
    }

    public void onDeleted() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(TAG, ""#onDeleted(); widgetId: "" + mWidgetId);
        }

        if (mLoader != null) {
            mLoader.reset();
        }
    }

    @Override
    public void onDestroy() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(TAG, ""#onDestroy(); widgetId: "" + mWidgetId);
        }

        if (mLoader != null) {
            mLoader.reset();
        }
    }

    @Override
    public void onCreate() {
        if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
            Log.d(TAG, ""#onCreate(); widgetId: "" + mWidgetId);
        }
    }

    @Override
    public String toString() {
        return ""View="" + mAccountName;
    }
}
",False,267,0,0,11,62,3,13,L6
146,com.android.email.widget.WidgetConfiguration.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.widget;

import android.app.Activity;
import android.appwidget.AppWidgetManager;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;

import com.android.email.Email;
import com.android.email.R;
import com.android.email.activity.ShortcutPickerFragment.AccountShortcutPickerFragment;
import com.android.email.activity.ShortcutPickerFragment.MailboxShortcutPickerFragment;
import com.android.email.activity.ShortcutPickerFragment.PickerCallback;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.HostAuth;
import com.android.emailcommon.utility.Utility;

/**
 * Activity to configure the Email widget.
 */
public class WidgetConfiguration extends Activity implements OnClickListener, PickerCallback {
    /** ID of the newly created application widget */
    private int mAppWidgetId;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setResult(RESULT_CANCELED);
        if (Email.DEBUG) {
            Log.i(Logging.LOG_TAG, ""WidgetConfiguration initiated"");
        }
        if (!AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(getIntent().getAction())) {
            // finish() immediately if we aren't supposed to be here
            finish();
            return;
        }

        Intent intent = getIntent();
        Bundle extras = intent.getExtras();
        if (extras != null) {
            mAppWidgetId = extras.getInt(
                    AppWidgetManager.EXTRA_APPWIDGET_ID,
                    AppWidgetManager.INVALID_APPWIDGET_ID);
        }

        // Set handler for the ""cancel"" button
        setContentView(R.layout.account_shortcut_picker);
        findViewById(R.id.cancel).setOnClickListener(this);

        if (getFragmentManager().findFragmentById(R.id.shortcut_list) == null) {
            // Load the account picking fragment if we haven't created a fragment yet
            // NOTE: do not add to history as this will be the first fragment in the flow
            AccountShortcutPickerFragment fragment = new AccountShortcutPickerFragment();
            getFragmentManager().beginTransaction().add(R.id.shortcut_list, fragment).commit();
        }
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.cancel:
                finish();
                break;
        }
    }

    @Override
    public Integer buildFilter(Account account) {
        if (!Account.isNormalAccount(account.mId)) {
            return MailboxShortcutPickerFragment.FILTER_INBOX_ONLY
                    | MailboxShortcutPickerFragment.FILTER_ALLOW_UNREAD;
        }

        // We can't synced non-Inbox mailboxes for non-EAS accounts, so they don't sync
        // right now and it doesn't make sense to put them in a widget.
        return HostAuth.SCHEME_EAS.equals(account.getProtocol(this))
                ? MailboxShortcutPickerFragment.FILTER_ALLOW_ALL
                : MailboxShortcutPickerFragment.FILTER_INBOX_ONLY;
    }

    @Override
    public void onSelected(Account account, long mailboxId) {
        setupWidget(account, mailboxId);
        finish();
    }

    @Override
    public void onMissingData(boolean missingAccount, boolean missingMailbox) {
        if (Email.DEBUG) {
            Log.i(Logging.LOG_TAG, ""WidgetConfiguration exited abnormally. Probably no accounts."");
        }
        Utility.showToast(this, R.string.widget_no_accounts);
        finish();
    }

    private void setupWidget(Account account, long mailboxId) {
        // save user selected preferences & create initial widget view
        WidgetManager.saveWidgetPrefs(this, mAppWidgetId, account.mId, mailboxId);
        WidgetManager.getInstance().getOrCreateWidget(this, mAppWidgetId).start();

        // Return ""OK"" result; make sure we pass along the original widget ID
        Intent resultValue = new Intent();
        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
        setResult(RESULT_OK, resultValue);
    }
}
",False,267,0,0,11,49,1,9,L6
147,com.android.email.widget.WidgetManager.java,"/*
 * Copyright (C) 2011 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.email.widget;

import android.content.Context;
import android.content.SharedPreferences;
import android.util.Log;

import com.android.email.Email;
import com.android.emailcommon.Logging;
import com.android.emailcommon.provider.Account;
import com.android.emailcommon.provider.Mailbox;

import java.io.FileDescriptor;
import java.io.PrintWriter;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Class that maintains references to all widgets.
 */
public class WidgetManager {
    private static final String PREFS_NAME = ""com.android.email.widget.WidgetManager"";
    private static final String ACCOUNT_ID_PREFIX = ""accountId_"";
    private static final String MAILBOX_ID_PREFIX = ""mailboxId_"";

    private final static WidgetManager sInstance = new WidgetManager();

    // Widget ID -> Widget
    private final static Map<Integer, EmailWidget> mWidgets =
            new ConcurrentHashMap<Integer, EmailWidget>();

    private WidgetManager() {
    }

    public static WidgetManager getInstance() {
        return sInstance;
    }

    public synchronized void createWidgets(Context context, int[] widgetIds) {
        for (int widgetId : widgetIds) {
            getOrCreateWidget(context, widgetId);
        }
    }

    public synchronized void deleteWidgets(Context context, int[] widgetIds) {
        for (int widgetId : widgetIds) {
            // Find the widget in the map
            final EmailWidget widget = WidgetManager.getInstance().get(widgetId);
            if (widget != null) {
                // Stop loading and remove the widget from the map
                widget.onDeleted();
            }
            remove(context, widgetId);
        }
    }

    public synchronized void updateWidgets(Context context, int[] widgetIds) {
        for (int widgetId : widgetIds) {
            // Find the widget in the map
            final EmailWidget widget = WidgetManager.getInstance().get(widgetId);
            if (widget != null) {
                widget.reset();
            } else {
                getOrCreateWidget(context, widgetId);
            }
        }
    }

    public synchronized EmailWidget getOrCreateWidget(Context context, int widgetId) {
        EmailWidget widget = WidgetManager.getInstance().get(widgetId);
        if (widget == null) {
            if (Logging.DEBUG_LIFECYCLE && Email.DEBUG) {
                Log.d(EmailWidget.TAG, ""Create email widget; ID: "" + widgetId);
            }
            widget = new EmailWidget(context, widgetId);
            put(widgetId, widget);
            widget.start();
        }
        return widget;
    }

    private EmailWidget get(int widgetId) {
        return mWidgets.get(widgetId);
    }

    private void put(int widgetId, EmailWidget widget) {
        mWidgets.put(widgetId, widget);
    }

    private void remove(Context context, int widgetId) {
        mWidgets.remove(widgetId);
        WidgetManager.removeWidgetPrefs(context, widgetId);
    }

    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
        int n = 0;
        for (EmailWidget widget : mWidgets.values()) {
            writer.println(""Widget #"" + (++n));
            writer.println(""    "" + widget.toString());
        }
    }

    /** Saves shared preferences for the given widget */
    static void saveWidgetPrefs(Context context, int appWidgetId, long accountId, long mailboxId) {
        SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, 0);
        prefs.edit()
            .putLong(ACCOUNT_ID_PREFIX + appWidgetId, accountId)
            .putLong(MAILBOX_ID_PREFIX + appWidgetId, mailboxId)
            .commit();    // preferences must be committed before we return
    }

    /** Removes shared preferences for the given widget */
    static void removeWidgetPrefs(Context context, int appWidgetId) {
        SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, 0);
        SharedPreferences.Editor editor = prefs.edit();
        for (String key : prefs.getAll().keySet()) {
            if (key.endsWith(""_"" + appWidgetId)) {
                editor.remove(key);
            }
        }
        editor.apply();   // just want to clean up; don't care when preferences are actually removed
    }

    /**
     * Returns the saved account ID for the given widget. Otherwise, {@link Account#NO_ACCOUNT} if
     * the account ID was not previously saved.
     */
    static long loadAccountIdPref(Context context, int appWidgetId) {
        SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, 0);
        long accountId = prefs.getLong(ACCOUNT_ID_PREFIX + appWidgetId, Account.NO_ACCOUNT);
        return accountId;
    }

    /**
     * Returns the saved mailbox ID for the given widget. Otherwise, {@link Mailbox#NO_MAILBOX} if
     * the mailbox ID was not previously saved.
     */
    static long loadMailboxIdPref(Context context, int appWidgetId) {
        SharedPreferences prefs = context.getSharedPreferences(PREFS_NAME, 0);
        long mailboxId = prefs.getLong(MAILBOX_ID_PREFIX + appWidgetId, Mailbox.NO_MAILBOX);
        return mailboxId;
    }
}
",False,267,0,0,11,50,3,5,L6
