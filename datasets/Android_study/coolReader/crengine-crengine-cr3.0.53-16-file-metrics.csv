,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.coolreader.CoolReader.java,"// Main Class
package org.coolreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.lang.reflect.Field;

import org.coolreader.crengine.AboutDialog;
import org.coolreader.crengine.BackgroundThread;
import org.coolreader.crengine.BaseDialog;
import org.coolreader.crengine.BookInfo;
import org.coolreader.crengine.BookmarksDlg;
import org.coolreader.crengine.CRDB;
import org.coolreader.crengine.DeviceInfo;
import org.coolreader.crengine.EinkScreen;
import org.coolreader.crengine.Engine;
import org.coolreader.crengine.Engine.HyphDict;
import org.coolreader.crengine.FileBrowser;
import org.coolreader.crengine.FileInfo;
import org.coolreader.crengine.History;
import org.coolreader.crengine.InterfaceTheme;
import org.coolreader.crengine.L;
import org.coolreader.crengine.Logger;
import org.coolreader.crengine.OptionsDialog;
import org.coolreader.crengine.Properties;
import org.coolreader.crengine.ReaderAction;
import org.coolreader.crengine.ReaderView;
import org.coolreader.crengine.Scanner;
import org.coolreader.crengine.Settings;
import org.coolreader.crengine.TTS;
import org.coolreader.crengine.TTS.OnTTSCreatedListener;
import org.coolreader.crengine.Utils;

import android.app.Activity;
import android.app.SearchManager;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.content.res.TypedArray;
import android.graphics.PixelFormat;
import android.media.AudioManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Debug;
import android.os.PowerManager;
import android.text.ClipboardManager;
import android.text.method.DigitsKeyListener;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.Toast;

public class CoolReader extends Activity
{
	public static final Logger log = L.create(""cr"");
	
	Engine mEngine;
	ReaderView mReaderView;
	Scanner mScanner;
	FileBrowser mBrowser;
	FrameLayout mFrame;
	//View startupView;
	History mHistory;
	CRDB mDB;
	private BackgroundThread mBackgroundThread;
	
	
	public CoolReader() {
	    brightnessHackError = DeviceInfo.SAMSUNG_BUTTONS_HIGHLIGHT_PATCH;
	}
	
	public Scanner getScanner()
	{
		return mScanner;
	}
	
	public History getHistory() 
	{
		return mHistory;
	}
	
	public Engine getEngine() {
		return mEngine;
	}
	
	public FileBrowser getBrowser() {
		return mBrowser;
	}
	
	public ReaderView getReaderView() 
	{
		return mReaderView;
	}
	
	public CRDB getDB()
	{
		return mDB;
	}
	
	private static String PREF_FILE = ""CR3LastBook"";
	private static String PREF_LAST_BOOK = ""LastBook"";
	public String getLastSuccessfullyOpenedBook()
	{
		SharedPreferences pref = getSharedPreferences(PREF_FILE, 0);
		String res = pref.getString(PREF_LAST_BOOK, null);
		pref.edit().putString(PREF_LAST_BOOK, null).commit();
		return res;
	}
	
	public void setLastSuccessfullyOpenedBook( String filename )
	{
		SharedPreferences pref = getSharedPreferences(PREF_FILE, 0);
		pref.edit().putString(PREF_LAST_BOOK, filename).commit();
	}
	
	private int mScreenUpdateMode = 0;
	public int getScreenUpdateMode() {
		return mScreenUpdateMode;
	}
	public void setScreenUpdateMode( int screenUpdateMode, View view ) {
		if (mReaderView != null) {
			mScreenUpdateMode = screenUpdateMode;
			if (EinkScreen.UpdateMode != screenUpdateMode || EinkScreen.UpdateMode == 2) {
				EinkScreen.ResetController(screenUpdateMode, view);
			}
		}
	}

	private int mScreenUpdateInterval = 0;
	public int getScreenUpdateInterval() {
		return mScreenUpdateInterval;
	}
	public void setScreenUpdateInterval( int screenUpdateInterval, View view ) {
		mScreenUpdateInterval = screenUpdateInterval;
		if (EinkScreen.UpdateModeInterval != screenUpdateInterval) {
			EinkScreen.UpdateModeInterval = screenUpdateInterval;
			EinkScreen.ResetController(mScreenUpdateMode, view);
		}
	}

	private boolean mNightMode = false;
	public boolean isNightMode() {
		return mNightMode;
	}
	public void setNightMode( boolean nightMode ) {
		mNightMode = nightMode;
	}
	
	private InterfaceTheme currentTheme = DeviceInfo.FORCE_LIGHT_THEME ? InterfaceTheme.WHITE : InterfaceTheme.LIGHT;
	
	public InterfaceTheme getCurrentTheme() {
		return currentTheme;
	}

	public void setCurrentTheme(String themeCode) {
		InterfaceTheme theme = InterfaceTheme.findByCode(themeCode);
		if (theme != null) {
			setCurrentTheme(theme);
		}
	}

	public void setCurrentTheme(InterfaceTheme theme) {
		currentTheme = theme;
		getApplication().setTheme(theme.getThemeId());
		setTheme(theme.getThemeId());
		if (mFrame != null) {
			TypedArray a = getTheme().obtainStyledAttributes(new int[] {android.R.attr.windowBackground, android.R.attr.background, android.R.attr.textColor, android.R.attr.colorBackground, android.R.attr.colorForeground});
			int bgRes = a.getResourceId(0, 0);
			//int clText = a.getColor(1, 0);
			int clBackground = a.getColor(2, 0);
			//int clForeground = a.getColor(3, 0);
			a.recycle();
			if (clBackground != 0)
				mFrame.setBackgroundColor(clBackground);
			if (bgRes != 0)
				mFrame.setBackgroundResource(bgRes);
		}
		if (mBrowser != null)
			mBrowser.onThemeChanged();
	}

	private boolean mFullscreen = false;
	public boolean isFullscreen() {
		return mFullscreen;
	}

	public void applyFullscreen( Window wnd )
	{
		if ( mFullscreen ) {
			//mActivity.getWindow().requestFeature(Window.)
			wnd.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, 
			        WindowManager.LayoutParams.FLAG_FULLSCREEN );
		} else {
			wnd.setFlags(0, 
			        WindowManager.LayoutParams.FLAG_FULLSCREEN );
		}
	}
	public void setFullscreen( boolean fullscreen )
	{
		if ( mFullscreen!=fullscreen ) {
			mFullscreen = fullscreen;
			applyFullscreen( getWindow() );
		}
	}
	
	private int sdkInt = 0;
	public int getSDKLevel() {
		if (sdkInt > 0)
			return sdkInt;
		// hack for Android 1.5
		sdkInt = 3;
		Field fld;
		try {
			Class<?> cl = android.os.Build.VERSION.class;
			fld = cl.getField(""SDK_INT"");
			sdkInt = fld.getInt(cl);
			log.i(""API LEVEL "" + sdkInt + "" detected"");
		} catch (SecurityException e) {
			// ignore
		} catch (NoSuchFieldException e) {
			// ignore
		} catch (IllegalArgumentException e) {
			// ignore
		} catch (IllegalAccessException e) {
			// ignore
		}
		return sdkInt;
	}
	
	public boolean isWakeLockEnabled() {
		return screenBacklightDuration > 0;
	}

	/**
	 * @param backlightDurationMinutes 0 = system default, 1 == 3 minutes, 2..5 == 2..5 minutes
	 */
	public void setScreenBacklightDuration(int backlightDurationMinutes)
	{
		if (backlightDurationMinutes == 1)
			backlightDurationMinutes = 3;
		if (screenBacklightDuration != backlightDurationMinutes * 60 * 1000) {
			screenBacklightDuration = backlightDurationMinutes * 60 * 1000;
			if (screenBacklightDuration == 0)
				backlightControl.release();
			else
				backlightControl.onUserActivity();
		}
	}
	
	int screenOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR;
	public void applyScreenOrientation( Window wnd )
	{
		if ( wnd!=null ) {
			WindowManager.LayoutParams attrs = wnd.getAttributes();
			attrs.screenOrientation = screenOrientation;
			wnd.setAttributes(attrs);
			if (DeviceInfo.EINK_SCREEN){
				EinkScreen.ResetController(mReaderView);
			}
			
		}
	}

	public int getScreenOrientation()
	{
		switch ( screenOrientation ) {
		case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
			return 0;
		case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
			return 1;
		case ActivityInfo_SCREEN_ORIENTATION_REVERSE_PORTRAIT:
			return 2;
		case ActivityInfo_SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
			return 3;
		default:
			return orientationFromSensor;
		}
	}

	public boolean isLandscape()
	{
		return screenOrientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE || screenOrientation == ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
	}

	// support pre API LEVEL 9
	final static public int ActivityInfo_SCREEN_ORIENTATION_SENSOR_PORTRAIT = 7;
	final static public int ActivityInfo_SCREEN_ORIENTATION_SENSOR_LANDSCAPE = 6;
	final static public int ActivityInfo_SCREEN_ORIENTATION_REVERSE_PORTRAIT = 9;
	final static public int ActivityInfo_SCREEN_ORIENTATION_REVERSE_LANDSCAPE = 8;
	final static public int ActivityInfo_SCREEN_ORIENTATION_FULL_SENSOR = 10;

	public void setScreenOrientation( int angle )
	{
		int newOrientation = screenOrientation;
		boolean level9 = getSDKLevel() >= 9;
		switch (angle) {
		case 0:
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT; // level9 ? ActivityInfo_SCREEN_ORIENTATION_SENSOR_PORTRAIT : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
			break;
		case 1:
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE; // level9 ? ActivityInfo_SCREEN_ORIENTATION_SENSOR_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
			break;
		case 2:
			newOrientation = level9 ? ActivityInfo_SCREEN_ORIENTATION_REVERSE_PORTRAIT : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
			break;
		case 3:
			newOrientation = level9 ? ActivityInfo_SCREEN_ORIENTATION_REVERSE_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
			break;
		case 4:
			newOrientation = level9 ? ActivityInfo_SCREEN_ORIENTATION_FULL_SENSOR : ActivityInfo.SCREEN_ORIENTATION_SENSOR;
			break;
		}
		if (newOrientation != screenOrientation) {
			log.d(""setScreenOrientation("" + angle + "")"");
			screenOrientation = newOrientation;
			setRequestedOrientation(screenOrientation);
			applyScreenOrientation(getWindow());
		}
	}

	private Runnable backlightTimerTask = null;
	private static long lastUserActivityTime;
	public static final int DEF_SCREEN_BACKLIGHT_TIMER_INTERVAL = 3 * 60 * 1000;
	private int screenBacklightDuration = DEF_SCREEN_BACKLIGHT_TIMER_INTERVAL;

	private class ScreenBacklightControl {
		PowerManager.WakeLock wl = null;

		public ScreenBacklightControl() {
		}


		public void onUserActivity() {
			lastUserActivityTime = Utils.timeStamp();
			if (!isWakeLockEnabled())
				return;
			if (wl == null) {
				PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
				wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK
				/* | PowerManager.ON_AFTER_RELEASE */, ""cr3"");
				log.d(""ScreenBacklightControl: WakeLock created"");
			}
			if (!isStarted()) {
				log.d(""ScreenBacklightControl: user activity while not started"");
				release();
				return;
			}

			if (!isHeld()) {
				log.d(""ScreenBacklightControl: acquiring WakeLock"");
				wl.acquire();
			}

			if (backlightTimerTask == null) {
				log.v(""ScreenBacklightControl: timer task started"");
				backlightTimerTask = new BacklightTimerTask();
				BackgroundThread.instance().postGUI(backlightTimerTask,
						screenBacklightDuration / 10);
			}
		}

		public boolean isHeld() {
			return wl != null && wl.isHeld();
		}

		public void release() {
			if (wl != null && wl.isHeld()) {
				log.d(""ScreenBacklightControl: wl.release()"");
				wl.release();
			}
			backlightTimerTask = null;
		}

		private class BacklightTimerTask implements Runnable {

			@Override
			public void run() {
				if (backlightTimerTask == null)
					return;
				long interval = Utils.timeInterval(lastUserActivityTime);
				log.v(""ScreenBacklightControl: timer task, lastActivityMillis = ""
						+ interval);
				int nextTimerInterval = screenBacklightDuration / 20;
				boolean dim = false;
				if (interval > screenBacklightDuration * 8 / 10) {
					nextTimerInterval = nextTimerInterval / 8;
					dim = true;
				}
				if (interval > screenBacklightDuration) {
					log.v(""ScreenBacklightControl: interval is expired"");
					release();
				} else {
					BackgroundThread.instance().postGUI(backlightTimerTask, nextTimerInterval);
					if (dim) {
						updateBacklightBrightness(-0.9f); // reduce by 9%
					}
				}
			}

		};

	}

	ScreenBacklightControl backlightControl = new ScreenBacklightControl();
	
	public int getPalmTipPixels()
	{
		return densityDpi / 3; // 1/3""
	}
	
	public int getDensityDpi()
	{
		return densityDpi;
	}
	
	private int densityDpi = 120;
	int initialBatteryState = -1;
	String fileToLoadOnStart = null;
	BroadcastReceiver intentReceiver;
	
	private String mVersion = ""3.0"";
	
	public String getVersion() {
		return mVersion;
	}
	
	TTS tts;
	boolean ttsInitialized;
	boolean ttsError;
	
	public boolean initTTS(final OnTTSCreatedListener listener) {
		if ( ttsError || !TTS.isFound() ) {
			if ( !ttsError ) {
				ttsError = true;
				showToast(""TTS is not available"");
			}
			return false;
		}
		if ( ttsInitialized && tts!=null ) {
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					listener.onCreated(tts);
				}
			});
			return true;
		}
		if ( ttsInitialized && tts!=null ) {
			showToast(""TTS initialization is already called"");
			return false;
		}
		showToast(""Initializing TTS"");
    	tts = new TTS(this, new TTS.OnInitListener() {
			@Override
			public void onInit(int status) {
				//tts.shutdown();
				L.i(""TTS init status: "" + status);
				if ( status==TTS.SUCCESS ) {
					ttsInitialized = true;
					BackgroundThread.instance().executeGUI(new Runnable() {
						@Override
						public void run() {
							listener.onCreated(tts);
						}
					});
				} else {
					ttsError = true;
					BackgroundThread.instance().executeGUI(new Runnable() {
						@Override
						public void run() {
							showToast(""Cannot initialize TTS"");
						}
					});
				}
			}
		});
		return true;
	}
	
	private AudioManager am;
	private int maxVolume;
	public AudioManager getAudioManager() {
		if ( am==null ) {
			am = (AudioManager)getSystemService(AUDIO_SERVICE);
			maxVolume = am.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
		}
		return am;
	}
	
	public int getVolume() {
		AudioManager am = getAudioManager();
		if (am!=null) {
			return am.getStreamVolume(AudioManager.STREAM_MUSIC) * 100 / maxVolume;
		}
		return 0;
	}
	
	public void setVolume( int volume ) {
		AudioManager am = getAudioManager();
		if (am!=null) {
			am.setStreamVolume(AudioManager.STREAM_MUSIC, volume * maxVolume / 100, 0);
		}
	}
	
	private boolean isFirstStart = true;
	
	/** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
		log.i(""CoolReader.onCreate() entered"");
		super.onCreate(savedInstanceState);

    	isFirstStart = true;
		
		setVolumeControlStream(AudioManager.STREAM_MUSIC);
		
		try {
			PackageInfo pi = getPackageManager().getPackageInfo(getPackageName(), 0);
			mVersion = pi.versionName;
		} catch ( NameNotFoundException e ) {
			// ignore
		}
		log.i(""CoolReader version : "" + getVersion());
		
		Display d = getWindowManager().getDefaultDisplay();
		DisplayMetrics m = new DisplayMetrics(); 
		d.getMetrics(m);
		try {
			Field fld = d.getClass().getField(""densityDpi"");
			if ( fld!=null ) {
				Object v = fld.get(m);
				if ( v!=null && v instanceof Integer ) {
					densityDpi = ((Integer)v).intValue();
					log.i(""Screen density detected: "" + densityDpi + ""DPI"");
				}
			}
		} catch ( Exception e ) {
			log.e(""Cannot find field densityDpi, using default value"");
		}
		
		intentReceiver = new BroadcastReceiver() {

			@Override
			public void onReceive(Context context, Intent intent) {
				int level = intent.getIntExtra(""level"", 0);
				if ( mReaderView!=null )
					mReaderView.setBatteryState(level);
				else
					initialBatteryState = level;
			}
			
		};
		registerReceiver(intentReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));


		log.i(""CoolReader.window="" + getWindow());
		WindowManager.LayoutParams lp = new WindowManager.LayoutParams();
		lp.alpha = 1.0f;
		lp.dimAmount = 0.0f;
		lp.format = PixelFormat.RGB_565;
		lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL;
		lp.horizontalMargin = 0;
		lp.verticalMargin = 0;
		lp.windowAnimations = 0;
		lp.layoutAnimationParameters = null;
		lp.memoryType = WindowManager.LayoutParams.MEMORY_TYPE_NORMAL;
		getWindow().setAttributes(lp);
		
		// testing background thread
    	mBackgroundThread = BackgroundThread.instance();
    	
		mEngine = new Engine(this, mBackgroundThread);
		
		// load settings
		Properties props = loadSettings();
		String theme = props.getProperty(ReaderView.PROP_APP_THEME, DeviceInfo.FORCE_LIGHT_THEME ? ""WHITE"" : ""LIGHT"");
		setCurrentTheme(theme);
    	
		mFrame = new FrameLayout(this);
		mBackgroundThread.setGUI(mFrame);

		requestWindowFeature(Window.FEATURE_NO_TITLE);

		setFullscreen( props.getBool(ReaderView.PROP_APP_FULLSCREEN, (DeviceInfo.EINK_SCREEN?true:false)));
		int orientation = props.getInt(ReaderView.PROP_APP_SCREEN_ORIENTATION, 0); //(DeviceInfo.EINK_SCREEN?0:4)
		if ( orientation < 0 || orientation > 4 )
			orientation = 0;
		setScreenOrientation(orientation);
		int backlight = props.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, -1);
		if ( backlight<-1 || backlight>100 )
			backlight = -1;
		setScreenBacklightLevel(backlight);

        mEngine.showProgress( 0, R.string.progress_starting_cool_reader );

        // wait until all background tasks are executed
        mBackgroundThread.syncWithBackground();
        
		mEngine.setHyphenationDictionary(HyphDict.byCode(props.getProperty(ReaderView.PROP_HYPHENATION_DICT, Engine.HyphDict.RUSSIAN.toString())));
		
		//this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, 
        //       WindowManager.LayoutParams.FLAG_FULLSCREEN );
//		startupView = new View(this) {
//		};
//		startupView.setBackgroundColor(Color.BLACK);
		setScreenBacklightDuration(props.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK, 3));

		// open DB
		final String SQLITE_DB_NAME = ""cr3db.sqlite"";
		File dbdir = getDir(""db"", Context.MODE_PRIVATE);
		dbdir.mkdirs();
		File dbfile = new File(dbdir, SQLITE_DB_NAME);
		File externalDir = Engine.getExternalSettingsDir();
		if ( externalDir!=null ) {
			dbfile = Engine.checkOrMoveFile(externalDir, dbdir, SQLITE_DB_NAME);
		}
		mDB = new CRDB(dbfile);

       	mScanner = new Scanner(this, mDB, mEngine);
       	mScanner.initRoots(mEngine.getMountedRootsMap());
		
       	mHistory = new History(this, mDB);
		mHistory.setCoverPagesEnabled(props.getBool(ReaderView.PROP_APP_SHOW_COVERPAGES, true));

//		if ( DeviceInfo.FORCE_LIGHT_THEME ) {
//			setTheme(android.R.style.Theme_Light);
//			getWindow().setBackgroundDrawableResource(drawable.editbox_background);
//		}
//		if ( DeviceInfo.FORCE_LIGHT_THEME ) {
//			mFrame.setBackgroundColor( Color.WHITE );
//			setTheme(R.style.Dialog_Fullscreen_Day);
//		}
		
		mReaderView = new ReaderView(this, mEngine, mBackgroundThread, props);

		mScanner.setDirScanEnabled(props.getBool(ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED, true));
		
		mBrowser = new FileBrowser(this, mEngine, mScanner, mHistory);

		
		mFrame.addView(mReaderView);
		mFrame.addView(mBrowser);
//		mFrame.addView(startupView);
		setContentView( mFrame );
        log.i(""initializing browser"");
        mBrowser.init();
		showView(mBrowser, false);
        log.i(""initializing reader"");
        mBrowser.setSortOrder( props.getProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER));
		mBrowser.setSimpleViewMode(props.getBool(ReaderView.PROP_APP_FILE_BROWSER_SIMPLE_MODE, false));
        mBrowser.showDirectory(mScanner.getRoot(), null);
        
        fileToLoadOnStart = null;
		Intent intent = getIntent();
		if ( intent!=null && Intent.ACTION_VIEW.equals(intent.getAction()) ) {
			Uri uri = intent.getData();
			if ( uri!=null ) {
				fileToLoadOnStart = extractFileName(uri);
			}
			intent.setData(null);
		}
		if ( initialBatteryState>=0 )
			mReaderView.setBatteryState(initialBatteryState);
        
        log.i(""CoolReader.onCreate() exiting"");
    }
    
    public ClipboardManager getClipboardmanager() {
    	return (ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
    }
    
    public void setScreenBacklightLevel( int percent )
    {
    	if ( percent<-1 )
    		percent = -1;
    	else if ( percent>100 )
    		percent = -1;
    	screenBacklightBrightness = percent;
    	onUserActivity();
    }
    
    private int screenBacklightBrightness = -1; // use default
    //private boolean brightnessHackError = false;
    private boolean brightnessHackError = false;
    	    
    private void updateBacklightBrightness(float b) {
        Window wnd = getWindow();
        if (wnd != null) {
	    	LayoutParams attrs =  wnd.getAttributes();
	    	boolean changed = false;
	    	if (b < 0) {
	    		log.d(""dimming screen by "" + (int)((1 + b)*100) + ""%"");
	    		b = -b * attrs.screenBrightness;
	    		if (b < 0.15)
	    			return;
	    	}
	    	float delta = attrs.screenBrightness - b;
	    	if (delta < 0)
	    		delta = -delta;
	    	if (delta > 0.01) {
	    		attrs.screenBrightness = b;
	    		changed = true;
	    	}
	    	// hack to set buttonBrightness field
	    	if ( !brightnessHackError )
	    	try {
	        	Field bb = attrs.getClass().getField(""buttonBrightness"");
	        	if ( bb!=null ) {
	        		//Float oldValue = (Float)bb.get(attrs);
	        		//if ( oldValue==null || oldValue.floatValue()!=0 ) {
	        			bb.set(attrs, Float.valueOf(0.0f));
		        		changed = true;
	        		//}
	        	}
	    	} catch ( Exception e ) {
	    		log.e(""WindowManager.LayoutParams.buttonBrightness field is not found, cannot turn buttons backlight off"");
	    		brightnessHackError = true;
	    	}
	    	//attrs.buttonBrightness = 0;
	    	if ( changed ) {
	    		log.d(""Window attribute changed: "" + attrs);
	    		wnd.setAttributes(attrs);
	    	}
        }
    }
    
    public void onUserActivity()
    {
    	if ( backlightControl==null )
    		return;
    	backlightControl.onUserActivity();
    	// Hack
    	//if ( backlightControl.isHeld() )
    	BackgroundThread.guiExecutor.execute(new Runnable() {
			@Override
			public void run() {
				try {
		        	float b;
		        	int dimmingAlpha = 255;
		        	if ( screenBacklightBrightness>=0 ) {
	        			float minb = 1/16f; 
		        		if ( screenBacklightBrightness >= 10 ) {
		        			b = (screenBacklightBrightness - 10) / 90.0f;
		        			b = minb + b * (1-minb);
				        	if (b < 0.0f ) // BRIGHTNESS_OVERRIDE_OFF
				        		b = 0.0f;
				        	else if ( b>1.0f )
				        		b = 1.0f; //BRIGHTNESS_OVERRIDE_FULL
		        		} else {
			        		b = minb;
			        		dimmingAlpha = 255 - (11-screenBacklightBrightness) * 180 / 10; 
		        		}
		        	} else
		        		b = -1.0f; //BRIGHTNESS_OVERRIDE_NONE
		        	mReaderView.setDimmingAlpha(dimmingAlpha);
			    	log.d(""Brightness: "" + b + "", dim: "" + dimmingAlpha);
			    	updateBacklightBrightness(b);
				} catch ( Exception e ) {
					// ignore
				}
			}
    	});
    }
    
    boolean mDestroyed = false;
	@Override
	protected void onDestroy() {

		log.i(""CoolReader.onDestroy() entered"");
		mDestroyed = true;
		if ( !CLOSE_BOOK_ON_STOP )
			mReaderView.close();
		
		//if ( mReaderView!=null )
		//	mReaderView.close();
		
		//if ( mHistory!=null && mDB!=null ) {
			//history.saveToDB();
		//}
		if ( intentReceiver!=null ) {
			unregisterReceiver(intentReceiver);
			intentReceiver = null;
		}

		if ( mReaderView!=null ) {
			mReaderView.destroy();
		}
		
		if ( tts!=null ) {
			tts.shutdown();
			tts = null;
			ttsInitialized = false;
			ttsError = false;
		}
		
		if ( mEngine!=null ) {
			//mEngine.uninit();
		}

		if ( mDB!=null ) {
			final CRDB db = mDB;
			mBackgroundThread.executeBackground(new Runnable() {
				public void run() {
					db.close();
				}
			});
		}
//		if ( mBackgroundThread!=null ) {
//			mBackgroundThread.quit();
//		}
			
		mDB = null;
		mReaderView = null;
		//mEngine = null;
		mBackgroundThread = null;
		log.i(""CoolReader.onDestroy() exiting"");
		super.onDestroy();
	}

	private String extractFileName( Uri uri )
	{
		if ( uri!=null ) {
			if ( uri.equals(Uri.parse(""file:///"")) )
				return null;
			else
				return uri.getPath();
		}
		return null;
	}

	public void showHomeScreen() {
		Intent intent = new Intent(Intent.ACTION_MAIN);
		intent.addCategory(Intent.CATEGORY_HOME);
		startActivity(intent);
	}
	
	@Override
	protected void onNewIntent(Intent intent) {
		log.i(""onNewIntent : "" + intent);
		if ( mDestroyed ) {
			log.e(""engine is already destroyed"");
			return;
		}
		String fileToOpen = null;
		if ( Intent.ACTION_VIEW.equals(intent.getAction()) ) {
			Uri uri = intent.getData();
			if ( uri!=null ) {
				fileToOpen = extractFileName(uri);
			}
			intent.setData(null);
		}
		log.v(""onNewIntent, fileToOpen="" + fileToOpen);
		if ( fileToOpen!=null ) {
			// load document
			final String fn = fileToOpen;
			mReaderView.loadDocument(fileToOpen, new Runnable() {
				public void run() {
					log.v(""onNewIntent, loadDocument error handler called"");
					showToast(""Error occured while loading "" + fn);
					mEngine.hideProgress();
				}
			});
		}
	}

	private boolean mPaused = false; 
	public boolean isPaused() {
		return mPaused;
	}
	
	@Override
	protected void onPause() {
		log.i(""CoolReader.onPause() : saving reader state"");
		mIsStarted = false;
		mPaused = true;
//		setScreenUpdateMode(-1, mReaderView);
		releaseBacklightControl();
		mReaderView.saveCurrentPositionBookmarkSync(true);
		super.onPause();
	}
	
	public void releaseBacklightControl()
	{
		backlightControl.release();
	}

	@Override
	protected void onPostCreate(Bundle savedInstanceState) {
		log.i(""CoolReader.onPostCreate()"");
		super.onPostCreate(savedInstanceState);
	}

	@Override
	protected void onPostResume() {
		log.i(""CoolReader.onPostResume()"");
		super.onPostResume();
	}

//	private boolean restarted = false;
	@Override
	protected void onRestart() {
		log.i(""CoolReader.onRestart()"");
		//restarted = true;
		super.onRestart();
	}

	@Override
	protected void onRestoreInstanceState(Bundle savedInstanceState) {
		log.i(""CoolReader.onRestoreInstanceState()"");
		super.onRestoreInstanceState(savedInstanceState);
	}

	@Override
	protected void onResume() {
		log.i(""CoolReader.onResume()"");
		mPaused = false;
		mIsStarted = true;
		Properties props = mReaderView.getSettings();
		
		if (DeviceInfo.EINK_SCREEN) {
			setScreenUpdateMode(props.getInt(ReaderView.PROP_APP_SCREEN_UPDATE_MODE, 0), mReaderView);
		}
		
		backlightControl.onUserActivity();
		super.onResume();
	}

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		log.i(""CoolReader.onSaveInstanceState()"");
		super.onSaveInstanceState(outState);
	}

	static final boolean LOAD_LAST_DOCUMENT_ON_START = true; 
	
	private boolean mIsStarted = false;
	
	public boolean isStarted() { return mIsStarted; }
	
	@Override
	protected void onStart() {
		log.i(""CoolReader.onStart() fileToLoadOnStart="" + fileToLoadOnStart);
		super.onStart();
		
		mPaused = false;
		
		backlightControl.onUserActivity();
		
		if (!isFirstStart)
			return;
		isFirstStart = false;
		
		if ( fileToLoadOnStart==null ) {
			if ( mReaderView!=null && currentView==mReaderView && mReaderView.isBookLoaded() ) {
				log.v(""Book is already opened, showing ReaderView"");
				showReader();
				return;
			}
			
			//!stopped && 
//			if ( restarted && mReaderView!=null && mReaderView.isBookLoaded() ) {
//				log.v(""Book is already opened, showing ReaderView"");
//		        restarted = false;
//		        return;
//			}
		}
		if ( !stopped ) {
			mEngine.showProgress( 500, R.string.progress_starting_cool_reader );
		}
        //log.i(""waiting for engine tasks completion"");
        //engine.waitTasksCompletion();
//		restarted = false;
		stopped = false;
		final String fileName = fileToLoadOnStart;
		mBackgroundThread.postGUI(new Runnable() {
			public void run() {
		        log.i(""onStart, scheduled runnable: submitting task"");
		        mEngine.execute(new LoadLastDocumentTask(fileName));
			}
		});
		log.i(""CoolReader.onStart() exiting"");
	}
	
	class LoadLastDocumentTask implements Engine.EngineTask {

		final String fileName;
		public LoadLastDocumentTask( String fileName ) {
			super();
			this.fileName = fileName;
		}
		
		public void done() {
	        log.i(""onStart, scheduled task: trying to load "" + fileToLoadOnStart);
			if ( fileName!=null || LOAD_LAST_DOCUMENT_ON_START ) {
				//currentView=mReaderView;
				if ( fileName!=null ) {
					log.v(""onStart() : loading "" + fileName);
					mReaderView.loadDocument(fileName, new Runnable() {
						public void run() {
							// cannot open recent book: load another one
							log.e(""Cannot open document "" + fileToLoadOnStart + "" starting file browser"");
							showBrowser(null);
						}
					});
				} else {
					log.v(""onStart() : loading last document"");
					mReaderView.loadLastDocument(new Runnable() {
						public void run() {
							// cannot open recent book: load another one
							log.e(""Cannot open last document, starting file browser"");
							showBrowser(null);
						}
					});
				}
			} else {
				showBrowser(null);
			}
			fileToLoadOnStart = null;
		}

		public void fail(Exception e) {
	        log.e(""onStart, scheduled task failed"", e);
		}

		public void work() throws Exception {
	        log.v(""onStart, scheduled task work()"");
		}
    }
 

	public final static boolean CLOSE_BOOK_ON_STOP = false;
	private boolean stopped = false;
	@Override
	protected void onStop() {
		log.i(""CoolReader.onStop() entering"");
		stopped = true;
		mPaused = false;
		// will close book at onDestroy()
		if ( CLOSE_BOOK_ON_STOP )
			mReaderView.close();
		super.onStop();
		log.i(""CoolReader.onStop() exiting"");
	}

	private View currentView;
	public void showView( View view )
	{
		showView( view, true );
	}
	public void showView( View view, boolean hideProgress )
	{
		if ( mBackgroundThread==null )
			return;
		if ( hideProgress )
		mBackgroundThread.postGUI(new Runnable() {
			public void run() {
				mEngine.hideProgress();
			}
		});
		if ( currentView==view ) {
			log.v(""showView : view "" + view.getClass().getSimpleName() + "" is already shown"");
			return;
		}
		log.v(""showView : showing view "" + view.getClass().getSimpleName());
		mFrame.bringChildToFront(view);
		for ( int i=0; i<mFrame.getChildCount(); i++ ) {
			View v = mFrame.getChildAt(i);
			v.setVisibility(view==v?View.VISIBLE:View.INVISIBLE);
		}
		currentView = view;
	}
	
	public void showReader()
	{
		log.v(""showReader() is called"");
		showView(mReaderView);
	}
	
	public boolean isBookOpened()
	{
		return mReaderView.isBookLoaded();
	}
	
	public void loadDocument( FileInfo item )
	{
		//showView(readerView);
		//setContentView(readerView);
		mReaderView.loadDocument(item);
	}
	
	public void showBrowser( final FileInfo fileToShow )
	{
		log.v(""showBrowser() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
		        if (fileToShow==null || mBrowser.isBookShownInRecentList(fileToShow))
		        	mBrowser.showLastDirectory();
		        else
		        	mBrowser.showDirectory(fileToShow, fileToShow);
			}
		});
	}

	public void showBrowserRecentBooks()
	{
		log.v(""showBrowserRecentBooks() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
	        	mBrowser.showRecentBooks();
			}
		});
	}

	public void showBrowserRoot()
	{
		log.v(""showBrowserRoot() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
	        	mBrowser.showRootDirectory();
			}
		});
	}

	private void fillMenu(Menu menu) {
		menu.clear();
	    MenuInflater inflater = getMenuInflater();
	    if ( currentView==mReaderView ) {
	    	inflater.inflate(R.menu.cr3_reader_menu, menu);
	    	MenuItem item = menu.findItem(R.id.cr3_mi_toggle_document_styles);
	    	if ( item!=null )
	    		item.setTitle(mReaderView.getDocumentStylesEnabled() ? R.string.mi_book_styles_disable : R.string.mi_book_styles_enable);
	    	item = menu.findItem(R.id.cr3_mi_toggle_day_night);
	    	if ( item!=null )
	    		item.setTitle(mReaderView.isNightMode() ? R.string.mi_night_mode_disable : R.string.mi_night_mode_enable);
	    } else {
	    	inflater.inflate(R.menu.cr3_browser_menu, menu);
	    	if ( !isBookOpened() ) {
	    		MenuItem item = menu.findItem(R.id.book_back_to_reading);
	    		if ( item!=null )
	    			item.setEnabled(false);
	    	}
    		MenuItem item = menu.findItem(R.id.book_toggle_simple_mode);
    		if ( item!=null )
    			item.setTitle(mBrowser.isSimpleViewMode() ? R.string.mi_book_browser_normal_mode : R.string.mi_book_browser_simple_mode );
	    }
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		fillMenu(menu);
	    return true;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		fillMenu(menu);
	    return true;
	}

	public void showToast( int stringResourceId )
	{
		String s = getString(stringResourceId);
		if ( s!=null )
			showToast(s);
	}

	public void showToast( String msg )
	{
        log.v(""showing toast: "" + msg);
        // TODO: enable custom toast
//        if (DeviceInfo.EINK_NOOK) {
//            ToastView.showToast(mReaderView, msg, Toast.LENGTH_LONG);
//        } else {
            //classic Toast
            Toast toast = Toast.makeText(this, msg, Toast.LENGTH_LONG);
            toast.show();
//        }
	}

	public interface InputHandler {
		boolean validate( String s ) throws Exception;
		void onOk( String s ) throws Exception;
		void onCancel();
	};
	
	public static class InputDialog extends BaseDialog {
		private InputHandler handler;
		private EditText input;
		public InputDialog( CoolReader activity, final String title, boolean isNumberEdit, final InputHandler handler )
		{
			super(activity, title, true, true);
			this.handler = handler;
	        LayoutInflater mInflater = LayoutInflater.from(getContext());
	        ViewGroup layout = (ViewGroup)mInflater.inflate(R.layout.line_edit_dlg, null);
	        input = (EditText)layout.findViewById(R.id.input_field);
	        //input = new EditText(getContext());
	        if ( isNumberEdit )
	        	input.setKeyListener(DigitsKeyListener.getInstance(""0123456789.""));
//		        input.getText().setFilters(new InputFilter[] {
//		        	new DigitsKeyListener()        
//		        });
	        setView(layout);
		}
		@Override
		protected void onNegativeButtonClick() {
            cancel();
            handler.onCancel();
		}
		@Override
		protected void onPositiveButtonClick() {
            String value = input.getText().toString().trim();
            try {
            	if ( handler.validate(value) )
            		handler.onOk(value);
            	else
            		handler.onCancel();
            } catch ( Exception e ) {
            	handler.onCancel();
            }
            cancel();
		}
	}
	
	public void showInputDialog( final String title, boolean isNumberEdit, final InputHandler handler )
	{
        final InputDialog dlg = new InputDialog(this, title, isNumberEdit, handler);
        dlg.show();
	}

	private int orientationFromSensor = 0;
	public int getOrientationFromSensor()
	{
		return orientationFromSensor;
	}
	
	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		// pass
		orientationFromSensor = newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE ? 1 : 0;
		//final int orientation = newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
//		if ( orientation!=screenOrientation ) {
//			log.d(""Screen orientation has been changed: ask for change"");
//			AlertDialog.Builder dlg = new AlertDialog.Builder(this);
//			dlg.setTitle(R.string.win_title_screen_orientation_change_apply);//R.string.win_title_options_apply);
//			dlg.setPositiveButton(R.string.dlg_button_ok, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					//onPositiveButtonClick();
//					Properties oldSettings = mReaderView.getSettings();
//					Properties newSettings = new Properties(oldSettings);
//					newSettings.setInt(ReaderView.PROP_APP_SCREEN_ORIENTATION, orientation==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE ? 1 : 0);
//					mReaderView.setSettings(newSettings, oldSettings);
//				}
//			});
//			dlg.setNegativeButton(R.string.dlg_button_cancel, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					//onNegativeButtonClick();
//				}
//			});
//		}
		super.onConfigurationChanged(newConfig);
	}

	String[] mFontFaces;

	public void showOptionsDialog()
	{
		final CoolReader _this = this;
		mBackgroundThread.executeBackground(new Runnable() {
			public void run() {
				mFontFaces = mEngine.getFontFaceList();
				mBackgroundThread.executeGUI(new Runnable() {
					public void run() {
						OptionsDialog dlg = new OptionsDialog(_this, mReaderView, mFontFaces);
						dlg.show();
					}
				});
			}
		});
	}
	
	public void saveSetting( String name, String value ) {
		mReaderView.saveSetting(name, value);
	}
	public String getSetting( String name ) {
		return mReaderView.getSetting(name);
	}
	
	public void showBookmarksDialog()
	{
		BackgroundThread.instance().executeGUI(new Runnable() {
			@Override
			public void run() {
				BookmarksDlg dlg = new BookmarksDlg(CoolReader.this, mReaderView);
				dlg.show();
			}
		});
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		int itemId = item.getItemId();
		if ( mReaderView.onMenuItem(itemId))
			return true; // processed by ReaderView
		// other commands
		switch ( itemId ) {
		case R.id.book_toggle_simple_mode:
			mBrowser.setSimpleViewMode(!mBrowser.isSimpleViewMode());
			mReaderView.saveSetting(ReaderView.PROP_APP_FILE_BROWSER_SIMPLE_MODE, mBrowser.isSimpleViewMode()?""1"":""0"");
			return true;
		case R.id.book_sort_order:
			mBrowser.showSortOrderMenu();
			return true;
		case R.id.book_root:
			mBrowser.showRootDirectory();
			return true;
		case R.id.book_opds_root:
			mBrowser.showOPDSRootDirectory();
			return true;
		case R.id.book_recent_books:
			mBrowser.showRecentBooks();
			return true;
		case R.id.book_find:
			mBrowser.showFindBookDialog();
			return true;
		case R.id.book_scan_recursive:
			mBrowser.scanCurrentDirectoryRecursive();
			return true;
		case R.id.book_back_to_reading:
			if ( isBookOpened() )
				showReader();
			else
				showToast(""No book opened"");
			return true;
		default:
			return false;
			//return super.onOptionsItemSelected(item);
		}
	}
	
	public void showGoToPageDialog() {
		showInputDialog(""Enter page number"", true, new InputHandler() {
			int pageNumber = 0;
			public boolean validate(String s) {
				pageNumber = Integer.valueOf(s); 
				return pageNumber>0;
			}
			public void onOk(String s) {
				mReaderView.goToPage(pageNumber);
			}
			public void onCancel() {
			}
		});
	}
	public void showGoToPercentDialog() {
		showInputDialog(""Enter position %"", true, new InputHandler() {
			int percent = 0;
			public boolean validate(String s) {
				percent = Integer.valueOf(s); 
				return percent>=0 && percent<=100;
			}
			public void onOk(String s) {
				mReaderView.goToPercent(percent);
			}
			public void onCancel() {
			}
		});
	}

	private static class DefKeyAction {
		public int keyCode;
		public int type;
		public ReaderAction action;
		public DefKeyAction(int keyCode, int type, ReaderAction action) {
			this.keyCode = keyCode;
			this.type = type;
			this.action = action;
		}
		public String getProp() {
			return ReaderView.PROP_APP_KEY_ACTIONS_PRESS + ReaderAction.getTypeString(type) + keyCode;			
		}
	}
	private static class DefTapAction {
		public int zone;
		public boolean longPress;
		public ReaderAction action;
		public DefTapAction(int zone, boolean longPress, ReaderAction action) {
			this.zone = zone;
			this.longPress = longPress;
			this.action = action;
		}
	}
	private static DefKeyAction[] DEF_KEY_ACTIONS = {
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.NORMAL, ReaderAction.FILE_BROWSER),
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.LONG, ReaderAction.EXIT),
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.DOUBLE, ReaderAction.EXIT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_CENTER, ReaderAction.NORMAL, ReaderAction.RECENT_BOOKS),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_CENTER, ReaderAction.LONG, ReaderAction.BOOKMARKS),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_UP, ReaderAction.LONG, (DeviceInfo.EINK_SONY? ReaderAction.PAGE_UP_10 : ReaderAction.REPEAT)),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_DOWN, ReaderAction.LONG, (DeviceInfo.EINK_SONY? ReaderAction.PAGE_DOWN_10 : ReaderAction.REPEAT)),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_UP_10),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN_10),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_LEFT, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_RIGHT, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_UP, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_DOWN, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_MENU, ReaderAction.NORMAL, ReaderAction.READER_MENU),
		new DefKeyAction(KeyEvent.KEYCODE_MENU, ReaderAction.LONG, ReaderAction.OPTIONS),
		new DefKeyAction(KeyEvent.KEYCODE_CAMERA, ReaderAction.NORMAL, ReaderAction.NONE),
		new DefKeyAction(KeyEvent.KEYCODE_CAMERA, ReaderAction.LONG, ReaderAction.NONE),
		new DefKeyAction(KeyEvent.KEYCODE_SEARCH, ReaderAction.NORMAL, ReaderAction.SEARCH),
		new DefKeyAction(KeyEvent.KEYCODE_SEARCH, ReaderAction.LONG, ReaderAction.TOGGLE_SELECTION_MODE),
		
		new DefKeyAction(ReaderView.NOOK_KEY_NEXT_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_SHIFT_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_PREV_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.NOOK_KEY_PREV_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.NOOK_KEY_SHIFT_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),

		new DefKeyAction(ReaderView.NOOK_12_KEY_NEXT_LEFT, ReaderAction.NORMAL, (DeviceInfo.EINK_NOOK ? ReaderAction.PAGE_UP : ReaderAction.PAGE_DOWN)),
		new DefKeyAction(ReaderView.NOOK_12_KEY_NEXT_LEFT, ReaderAction.LONG, (DeviceInfo.EINK_NOOK ? ReaderAction.PAGE_UP_10 : ReaderAction.PAGE_DOWN_10)),
		
		new DefKeyAction(ReaderView.KEYCODE_PAGE_BOTTOMLEFT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
//		new DefKeyAction(ReaderView.KEYCODE_PAGE_BOTTOMRIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.KEYCODE_PAGE_TOPLEFT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.KEYCODE_PAGE_TOPRIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.KEYCODE_PAGE_BOTTOMLEFT, ReaderAction.LONG, ReaderAction.PAGE_UP_10),
//		new DefKeyAction(ReaderView.KEYCODE_PAGE_BOTTOMRIGHT, ReaderAction.LONG, ReaderAction.PAGE_UP_10),
		new DefKeyAction(ReaderView.KEYCODE_PAGE_TOPLEFT, ReaderAction.LONG, ReaderAction.PAGE_DOWN_10),
		new DefKeyAction(ReaderView.KEYCODE_PAGE_TOPRIGHT, ReaderAction.LONG, ReaderAction.PAGE_DOWN_10),
		
		new DefKeyAction(ReaderView.SONY_DPAD_DOWN_SCANCODE, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.SONY_DPAD_UP_SCANCODE, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.SONY_DPAD_DOWN_SCANCODE, ReaderAction.LONG, ReaderAction.PAGE_DOWN_10),
		new DefKeyAction(ReaderView.SONY_DPAD_UP_SCANCODE, ReaderAction.LONG, ReaderAction.PAGE_UP_10),

//	    public static final int KEYCODE_PAGE_BOTTOMLEFT = 0x5d; // fwd
//	    public static final int KEYCODE_PAGE_BOTTOMRIGHT = 0x5f; // fwd
//	    public static final int KEYCODE_PAGE_TOPLEFT = 0x5c; // back
//	    public static final int KEYCODE_PAGE_TOPRIGHT = 0x5e; // back
		
	};
	private static DefTapAction[] DEF_TAP_ACTIONS = {
		new DefTapAction(1, false, ReaderAction.PAGE_UP),
		new DefTapAction(2, false, ReaderAction.PAGE_UP),
		new DefTapAction(4, false, ReaderAction.PAGE_UP),
		new DefTapAction(1, true, ReaderAction.GO_BACK), // back by link
		new DefTapAction(2, true, ReaderAction.TOGGLE_DAY_NIGHT),
		new DefTapAction(4, true, ReaderAction.PAGE_UP_10),
		new DefTapAction(3, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(6, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(7, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(8, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(9, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(3, true, ReaderAction.TOGGLE_AUTOSCROLL),
		new DefTapAction(6, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(7, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(8, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(9, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(5, false, ReaderAction.READER_MENU),
		new DefTapAction(5, true, ReaderAction.OPTIONS),
	};
	
	public Properties loadSettings(File file) {
        Properties props = new Properties();

        if ( file.exists() && !DEBUG_RESET_OPTIONS ) {
        	try {
        		FileInputStream is = new FileInputStream(file);
        		props.load(is);
        		log.v("""" + props.size() + "" settings items loaded from file "" + propsFile.getAbsolutePath() );
        	} catch ( Exception e ) {
        		log.e(""error while reading settings"");
        	}
        }
        
        // default key actions
        for ( DefKeyAction ka : DEF_KEY_ACTIONS ) {
        		props.applyDefault(ka.getProp(), ka.action.id);
        }
        // default tap zone actions
        for ( DefTapAction ka : DEF_TAP_ACTIONS ) {
        	if ( ka.longPress )
        		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + "".long."" + ka.zone, ka.action.id);
        	else
        		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + ""."" + ka.zone, ka.action.id);
        }
        
        if ( DeviceInfo.EINK_SCREEN ) {
    		props.applyDefault(ReaderView.PROP_PAGE_ANIMATION, ReaderView.PAGE_ANIMATION_NONE);
        } else {
    		props.applyDefault(ReaderView.PROP_PAGE_ANIMATION, ReaderView.PAGE_ANIMATION_SLIDE2);
        }
        
        props.applyDefault(ReaderView.PROP_APP_THEME, DeviceInfo.FORCE_LIGHT_THEME ? ""WHITE"" : ""LIGHT"");
        props.applyDefault(ReaderView.PROP_APP_THEME_DAY, DeviceInfo.FORCE_LIGHT_THEME ? ""WHITE"" : ""LIGHT"");
        props.applyDefault(ReaderView.PROP_APP_THEME_NIGHT, DeviceInfo.FORCE_LIGHT_THEME ? ""BLACK"" : ""DARK"");
        props.applyDefault(ReaderView.PROP_APP_SELECTION_PERSIST, ""0"");
        props.applyDefault(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK, ""3"");
        if (""1"".equals(props.getProperty(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK)))
            props.setProperty(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK, ""3"");
        props.applyDefault(ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED, ""1"");
        // autodetect best initial font size based on display resolution
        int screenWidth = getWindowManager().getDefaultDisplay().getWidth();
        int fontSize = 20;
        if ( screenWidth>=400 )
        	fontSize = 24;
        else if ( screenWidth>=600 )
        	fontSize = 28;
        props.applyDefault(ReaderView.PROP_FONT_SIZE, String.valueOf(fontSize));
        props.applyDefault(ReaderView.PROP_FONT_FACE, ""Droid Sans"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_FACE, ""Droid Sans"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_SIZE, DeviceInfo.EINK_NOOK ? ""15"" : ""16"");
        props.applyDefault(ReaderView.PROP_FONT_COLOR, ""#000000"");
        props.applyDefault(ReaderView.PROP_FONT_COLOR_DAY, ""#000000"");
        props.applyDefault(ReaderView.PROP_FONT_COLOR_NIGHT, ""#808080"");
        props.applyDefault(ReaderView.PROP_BACKGROUND_COLOR, ""#FFFFFF"");
        props.applyDefault(ReaderView.PROP_BACKGROUND_COLOR_DAY, ""#FFFFFF"");
        props.applyDefault(ReaderView.PROP_BACKGROUND_COLOR_NIGHT, ""#101010"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR, ""#FF000000""); // don't use separate color
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR_DAY, ""#FF000000""); // don't use separate color
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR_NIGHT, ""#80000000""); // don't use separate color
        props.setProperty(ReaderView.PROP_ROTATE_ANGLE, ""0""); // crengine's rotation will not be user anymore
        props.setProperty(ReaderView.PROP_DISPLAY_INVERSE, ""0"");
        props.applyDefault(ReaderView.PROP_APP_FULLSCREEN, ""0"");
        props.applyDefault(ReaderView.PROP_APP_VIEW_AUTOSCROLL_SPEED, ""1500"");
        props.applyDefault(ReaderView.PROP_APP_SCREEN_BACKLIGHT, ""-1"");
		props.applyDefault(ReaderView.PROP_SHOW_BATTERY, ""1""); 
		props.applyDefault(ReaderView.PROP_SHOW_POS_PERCENT, ""0""); 
		props.applyDefault(ReaderView.PROP_SHOW_PAGE_COUNT, ""1""); 
		props.applyDefault(ReaderView.PROP_SHOW_TIME, ""1"");
		props.applyDefault(ReaderView.PROP_FONT_ANTIALIASING, ""2"");
		props.applyDefault(ReaderView.PROP_APP_SHOW_COVERPAGES, ""1"");
		props.applyDefault(ReaderView.PROP_APP_SCREEN_ORIENTATION, ""0""); // DeviceInfo.EINK_SCREEN ? ""0"" : ""4""
		props.applyDefault(ReaderView.PROP_CONTROLS_ENABLE_VOLUME_KEYS, ""1"");
		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_HILIGHT, ""0"");
		props.applyDefault(ReaderView.PROP_APP_BOOK_SORT_ORDER, FileInfo.DEF_SORT_ORDER.name());
		props.applyDefault(ReaderView.PROP_APP_DICTIONARY, dicts[0].id);
		props.applyDefault(ReaderView.PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS, ""0"");
		props.applyDefault(ReaderView.PROP_APP_SELECTION_ACTION, ""0"");
		//props.applyDefault(ReaderView.PROP_FALLBACK_FONT_FACE, ""Droid Fallback"");
		props.put(ReaderView.PROP_FALLBACK_FONT_FACE, ""Droid Sans Fallback"");

		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMOUT_BLOCK_MODE, ""1"");
		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMIN_BLOCK_MODE, ""1"");
		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMOUT_INLINE_MODE, ""1"");
		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMIN_INLINE_MODE, ""1"");
		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMOUT_BLOCK_SCALE, ""0"");
		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMIN_BLOCK_SCALE, ""0"");
		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMOUT_INLINE_SCALE, ""0"");
		props.applyDefault(ReaderView.PROP_IMG_SCALING_ZOOMIN_INLINE_SCALE, ""0"");
		
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_LEFT, densityDpi > 160 ? ""10"" : DeviceInfo.EINK_NOOK ? ""20"" : ""4"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_RIGHT, densityDpi > 160 ? ""10"" : DeviceInfo.EINK_NOOK ? ""20"" : ""4"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_TOP, densityDpi > 160 ? ""8"" : ""2"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_BOTTOM, densityDpi > 160 ? ""8"" : ""2"");
		
        props.applyDefault(ReaderView.PROP_APP_SCREEN_UPDATE_MODE, ""0"");
        props.applyDefault(ReaderView.PROP_APP_SCREEN_UPDATE_INTERVAL, ""10"");
        
        props.applyDefault(ReaderView.PROP_NIGHT_MODE, ""0"");
        if (DeviceInfo.EINK_SCREEN) {
        	props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.NO_TEXTURE.id);
        } else {
        	if ( props.getBool(ReaderView.PROP_NIGHT_MODE, false) )
        		props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.DEF_NIGHT_BACKGROUND_TEXTURE);
        	else
        		props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.DEF_DAY_BACKGROUND_TEXTURE);
        }
        props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_DAY, Engine.DEF_DAY_BACKGROUND_TEXTURE);
        props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_NIGHT, Engine.DEF_NIGHT_BACKGROUND_TEXTURE);
        
        props.applyDefault(ReaderView.PROP_FONT_GAMMA, DeviceInfo.EINK_SCREEN ? ""1.5"" : ""1.0"");
		
		props.setProperty(ReaderView.PROP_MIN_FILE_SIZE_TO_CACHE, ""100000"");
		props.setProperty(ReaderView.PROP_FORCED_MIN_FILE_SIZE_TO_CACHE, ""32768"");
		props.applyDefault(ReaderView.PROP_HYPHENATION_DICT, Engine.HyphDict.RUSSIAN.toString());
		props.applyDefault(ReaderView.PROP_APP_FILE_BROWSER_SIMPLE_MODE, ""0"");
		
		props.applyDefault(ReaderView.PROP_APP_HIGHLIGHT_BOOKMARKS, ""1"");
        
        return props;
	}
	
	public File getSettingsFile(int profile) {
		if (profile == 0)
			return propsFile;
		return new File(propsFile.getAbsolutePath() + "".profile"" + profile);
	}
	
	File propsFile;
	private static final String SETTINGS_FILE_NAME = ""cr3.ini"";
	private static boolean DEBUG_RESET_OPTIONS = false;
	private Properties loadSettings()
	{
		File[] dataDirs = mEngine.getDataDirectories(null, false, true);
		File existingFile = null;
		for ( File dir : dataDirs ) {
			File f = new File(dir, SETTINGS_FILE_NAME);
			if ( f.exists() && f.isFile() ) {
				existingFile = f;
				break;
			}
		}
        if ( existingFile!=null )
        	propsFile = existingFile;
        else {
	        File propsDir = getDir(""settings"", Context.MODE_PRIVATE);
			propsFile = new File( propsDir, SETTINGS_FILE_NAME);
			File dataDir = Engine.getExternalSettingsDir();
			if ( dataDir!=null ) {
				log.d(""external settings dir: "" + dataDir);
				propsFile = Engine.checkOrMoveFile(dataDir, propsDir, SETTINGS_FILE_NAME);
			} else {
				propsDir.mkdirs();
			}
        }
        
        Properties props = loadSettings(propsFile);
        
        
		
		return props;
	}

	public static class DictInfo {
		public final String id; 
		public final String name;
		public final String packageName;
		public final String className;
		public final String action;
		public final Integer internal;
		public DictInfo ( String id, String name, String packageName, String className, String action, Integer internal ) {
			this.id = id;
			this.name = name;
			this.packageName = packageName;
			this.className = className;
			this.action = action;
			this.internal = internal;
		}
	}
	private static final DictInfo dicts[] = {
		new DictInfo(""Fora"", ""Fora Dictionary"", ""com.ngc.fora"", ""com.ngc.fora.ForaDictionary"", Intent.ACTION_SEARCH, 0),
		new DictInfo(""ColorDict"", ""ColorDict"", ""com.socialnmobile.colordict"", ""com.socialnmobile.colordict.activity.Main"", Intent.ACTION_SEARCH, 0),
		new DictInfo(""ColorDictApi"", ""ColorDict new / GoldenDict"", ""com.socialnmobile.colordict"", ""com.socialnmobile.colordict.activity.Main"", Intent.ACTION_SEARCH, 1),
		new DictInfo(""AardDict"", ""Aard Dictionary"", ""aarddict.android"", ""aarddict.android.Article"", Intent.ACTION_SEARCH, 0),
		new DictInfo(""AardDictLookup"", ""Aard Dictionary Lookup"", ""aarddict.android"", ""aarddict.android.Lookup"", Intent.ACTION_SEARCH, 0),
	};

	public DictInfo[] getDictList() {
		return dicts;
	}
	
	private DictInfo currentDict = dicts[0];
	
	public void setDict( String id ) {
		for ( DictInfo d : dicts ) {
			if ( d.id.equals(id) ) {
				currentDict = d;
				return;
			}
		}
	}

	private void findInDictionaryInternal(String s) {
		switch (currentDict.internal) {
		case 0:
			Intent intent0 = new Intent(currentDict.action).setComponent(new ComponentName(
				currentDict.packageName, currentDict.className
				)).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			if (s!=null)
				intent0.putExtra(SearchManager.QUERY, s);
			try {
				startActivity( intent0 );
			} catch ( ActivityNotFoundException e ) {
				showToast(""Dictionary \"""" + currentDict.name + ""\"" is not installed"");
			}
			break;
		case 1:
			final String SEARCH_ACTION  = ""colordict.intent.action.SEARCH"";
			final String EXTRA_QUERY   = ""EXTRA_QUERY"";
			final String EXTRA_FULLSCREEN = ""EXTRA_FULLSCREEN"";
			final String EXTRA_HEIGHT  = ""EXTRA_HEIGHT"";
			final String EXTRA_WIDTH   = ""EXTRA_WIDTH"";
			final String EXTRA_GRAVITY  = ""EXTRA_GRAVITY"";
			final String EXTRA_MARGIN_LEFT = ""EXTRA_MARGIN_LEFT"";
			final String EXTRA_MARGIN_TOP  = ""EXTRA_MARGIN_TOP"";
			final String EXTRA_MARGIN_BOTTOM = ""EXTRA_MARGIN_BOTTOM"";
			final String EXTRA_MARGIN_RIGHT = ""EXTRA_MARGIN_RIGHT"";

			Intent intent1 = new Intent(SEARCH_ACTION);
			if (s!=null)
				intent1.putExtra(EXTRA_QUERY, s); //Search Query
			intent1.putExtra(EXTRA_FULLSCREEN, true); //
			try
			{
				startActivity(intent1);
			} catch ( ActivityNotFoundException e ) {
				showToast(""Dictionary \"""" + currentDict.name + ""\"" is not installed"");
			}
			break;
		}
	}

	public void showDictionary() {
		findInDictionaryInternal(null);
	}
	
	public void findInDictionary( String s ) {
		if ( s!=null && s.length()!=0 ) {
			s = s.trim();
			for ( ;s.length()>0; ) {
				char ch = s.charAt(s.length()-1);
				if ( ch>=128 )
					break;
				if ( ch>='0' && ch<='9' || ch>='A' && ch<='Z' || ch>='a' && ch<='z' )
					break;
				s = s.substring(0, s.length()-1);
			}
			if ( s.length()>0 ) {
				//
				final String pattern = s;
				BackgroundThread.instance().executeBackground(new Runnable() {
					@Override
					public void run() {
						BackgroundThread.instance().postGUI(new Runnable() {
							@Override
							public void run() {
								findInDictionaryInternal(pattern);
							}
						}, 100);
					}
				});
			}
		}
	}
	
	public Properties loadSettings(int profile) {
		File f = getSettingsFile(profile);
		if (!f.exists() && profile != 0)
			f = getSettingsFile(0);
		Properties res = loadSettings(f);
		if (profile != 0)
			res.setInt(Settings.PROP_PROFILE_NUMBER, profile);
		return res;
	}
	
	public void saveSettings(int profile, Properties settings) {
		File f = getSettingsFile(profile);
		if (profile != 0)
			settings.setInt(Settings.PROP_PROFILE_NUMBER, profile);
		saveSettings(f, settings);
	}
	
	public void saveSettings(File f, Properties settings)
	{
		try {
			log.v(""saveSettings() "" + settings);
    		FileOutputStream os = new FileOutputStream(f);
    		settings.store(os, ""Cool Reader 3 settings"");
			log.i(""Settings successfully saved to file "" + f.getAbsolutePath());
		} catch ( Exception e ) {
			log.e(""exception while saving settings"", e);
		}
	}

	public void saveSettings(Properties settings)
	{
		saveSettings(propsFile, settings);
	}

	private static Debug.MemoryInfo info = new Debug.MemoryInfo();
	private static Field[] infoFields = Debug.MemoryInfo.class.getFields();
	private static String dumpFields( Field[] fields, Object obj) {
		StringBuilder buf = new StringBuilder();
		try {
			for ( Field f : fields ) {
				if ( buf.length()>0 )
					buf.append("", "");
				buf.append(f.getName());
				buf.append(""="");
				buf.append(f.get(obj));
			}
		} catch ( Exception e ) {
			
		}
		return buf.toString();
	}
	public static void dumpHeapAllocation() {
		Debug.getMemoryInfo(info);
		log.d(""nativeHeapAlloc="" + Debug.getNativeHeapAllocatedSize() + "", nativeHeapSize="" + Debug.getNativeHeapSize() + "", info: "" + dumpFields(infoFields, info));
	}
	
	public void showAboutDialog() {
		AboutDialog dlg = new AboutDialog(this);
		dlg.show();
	}
	
	public void openURL(String url) {
		try {
			Intent i = new Intent(Intent.ACTION_VIEW);  
			i.setData(Uri.parse(url));  
			startActivity(i);
		} catch (Exception e) {
			log.e(""Exception "" + e + "" while trying to open URL "" + url);
			showToast(""Cannot open URL "" + url);
		}
	}
	
	public void sendBookFragment(BookInfo bookInfo, String text) {
        final Intent emailIntent = new Intent(android.content.Intent.ACTION_SEND);
        emailIntent.setType(""text/plain"");
    	emailIntent.putExtra(android.content.Intent.EXTRA_SUBJECT, bookInfo.getFileInfo().getAuthors() + "" "" + bookInfo.getFileInfo().getTitle());
        emailIntent.putExtra(android.content.Intent.EXTRA_TEXT, text);
		startActivity(Intent.createChooser(emailIntent, null));	
	}
}
",True,23,49,0,0,2,24,22,24,L0
1,org.coolreader.crengine.ImageInfo.java,"package org.coolreader.crengine;

public class ImageInfo {
	int width;
	int height;
	int scaledWidth;
	int scaledHeight;
	int x;
	int y;
	int bufWidth;
	int bufHeight;
	int bufDpi;
	int rotation;

	public ImageInfo() {
		
	}
	
	public ImageInfo(ImageInfo v) {
		width = v.width;
		height = v.height;
		scaledWidth = v.scaledWidth;
		scaledHeight = v.scaledHeight;
		x = v.x;
		y = v.y;
		bufWidth = v.bufWidth;
		bufHeight = v.bufHeight;
		rotation = v.rotation;
		bufDpi = v.bufDpi;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + bufHeight;
		result = prime * result + bufWidth;
		result = prime * result + height;
		result = prime * result + scaledHeight;
		result = prime * result + scaledWidth;
		result = prime * result + width;
		result = prime * result + x;
		result = prime * result + y;
		result = prime * result + rotation;
		result = prime * result + bufDpi;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		ImageInfo other = (ImageInfo) obj;
		if (bufHeight != other.bufHeight)
			return false;
		if (bufWidth != other.bufWidth)
			return false;
		if (height != other.height)
			return false;
		if (scaledHeight != other.scaledHeight)
			return false;
		if (scaledWidth != other.scaledWidth)
			return false;
		if (width != other.width)
			return false;
		if (x != other.x)
			return false;
		if (y != other.y)
			return false;
		if (bufDpi != other.bufDpi)
			return false;
		if (rotation != other.rotation)
			return false;
		return true;
	}
	
	
}
",False,7,30,4,13,0,0,2,0,L0
2,org.coolreader.crengine.Selection.java,"package org.coolreader.crengine;

public class Selection {
	// IN
	public int startX;
	public int startY;
	public int endX;
	public int endY;
	// OUT
	public String startPos; 
	public String endPos;
	public String text;
	public String chapter;
	public int percent;
	
	boolean isEmpty() { return startPos==null || endPos==null; }
}
",False,41,30,4,12,0,0,4,0,L0
3,org.coolreader.crengine.BookSearchDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;
import android.widget.TextView;

public class BookSearchDialog extends BaseDialog {
	
	private final CoolReader mCoolReader;
	private final LayoutInflater mInflater;
	final EditText authorEdit;
	final EditText titleEdit;
	final EditText seriesEdit;
	final EditText filenameEdit;
	final TextView statusText;
	final SearchCallback callback;
	
	private int searchTaskId = 0;
	private boolean searchActive = false;
	private boolean closing = false;
	
	public BookSearchDialog( CoolReader activity, SearchCallback callback )
	{
		super(activity, activity.getString( R.string.dlg_book_search), true, false);
		mCoolReader = activity;
		this.callback = callback;
		setTitle(mCoolReader.getString( R.string.dlg_book_search));
		mInflater = LayoutInflater.from(getContext());
		View view = mInflater.inflate(R.layout.book_search_dialog, null);
		authorEdit = (EditText)view.findViewById(R.id.search_text_author);
		titleEdit = (EditText)view.findViewById(R.id.search_text_title);
		seriesEdit = (EditText)view.findViewById(R.id.search_text_series);
		filenameEdit = (EditText)view.findViewById(R.id.search_text_filename);
		statusText = (TextView)view.findViewById(R.id.search_status);
		TextWatcher watcher = new TextWatcher() {

			@Override
			public void afterTextChanged(Editable s) {
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count,
					int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before,
					int count) {
				postSearchTask();
			}
			
		}; 
		authorEdit.addTextChangedListener(watcher);
		seriesEdit.addTextChangedListener(watcher);
		titleEdit.addTextChangedListener(watcher);
		filenameEdit.addTextChangedListener(watcher);
		setView( view );
	}

	private void postSearchTask() {
		if ( closing )
			return;
		final int mySearchTaskId = ++searchTaskId;
		BackgroundThread.instance().postGUI(new Runnable() {
			@Override
			public void run() {
				if ( searchTaskId == mySearchTaskId ) {
					if ( searchActive )
						return;
					searchActive = true;
					find( new SearchCallback() {
						@Override
						public void done(FileInfo[] results) {
							searchActive = false;
							statusText.setText(mCoolReader.getString(R.string.dlg_book_search_found) + "" "" + results.length);
							if ( searchTaskId != mySearchTaskId ) {
								postSearchTask();
							}
						}
					});
				}
			}
		}, 3000);
	}
	
	public interface SearchCallback {
		public void done( FileInfo[] results );
	}

	private static String addWildcard( String s, boolean before, boolean after ) {
		if ( s==null || s.length()==0 )
			return s;
		if ( before )
			s = ""%"" + s;
		if ( after )
			s = s + ""%"";
		return s;
	}
	
	private final static int MAX_RESULTS = 50; 
	protected void find( final SearchCallback cb ) {
		final String author = addWildcard(authorEdit.getText().toString().trim(), false, true);
		final String series = addWildcard(seriesEdit.getText().toString().trim(), false, true);
		final String title = addWildcard(titleEdit.getText().toString().trim(), true, true);
		final String filename = addWildcard(filenameEdit.getText().toString().trim(), true, true);
		BackgroundThread.instance().executeBackground( new Runnable() {
			@Override
			public void run() {
				if (mCoolReader == null || mCoolReader.getDB() == null)
					return;
				final FileInfo[] results = mCoolReader.getDB().findByPatterns(MAX_RESULTS, author, title, series, filename);
				BackgroundThread.instance().executeGUI( new Runnable() {
					@Override
					public void run() {
						cb.done(results);
					}
				});
			}
		});
	}
	
	@Override
	protected void onPositiveButtonClick() {
		searchTaskId++;
		closing = true;
		super.onPositiveButtonClick();
		find( callback );
	}

	@Override
	protected void onNegativeButtonClick() {
		searchTaskId++;
		closing = true;
		super.onNegativeButtonClick();
		callback.done(null);
	}
}
",False,42,49,0,0,3,22,1,5,L0
4,org.coolreader.crengine.SelectionToolbarDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.ReaderView.ReaderCommand;

import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;

public class SelectionToolbarDlg {
	PopupWindow mWindow;
	View mAnchor;
	CoolReader mCoolReader;
	ReaderView mReaderView;
	View mPanel;
	Selection selection;
	static public void showDialog( CoolReader coolReader, ReaderView readerView, final Selection selection )
	{
		SelectionToolbarDlg dlg = new SelectionToolbarDlg(coolReader, readerView, selection);
		//dlg.mWindow.update(dlg.mAnchor, width, height)
		Log.d(""cr3"", ""popup: "" + dlg.mWindow.getWidth() + ""x"" + dlg.mWindow.getHeight());
		//dlg.update();
		//dlg.showAtLocation(readerView, Gravity.LEFT|Gravity.TOP, readerView.getLeft()+50, readerView.getTop()+50);
		//dlg.showAsDropDown(readerView);
		//dlg.update();
	}

	private boolean changedPageMode;
	private void setReaderMode()
	{
		String oldViewSetting = mReaderView.getSetting( ReaderView.PROP_PAGE_VIEW_MODE );
		if ( ""1"".equals(oldViewSetting) ) {
			changedPageMode = true;
			mReaderView.setSetting(ReaderView.PROP_PAGE_VIEW_MODE, ""0"");
		}
	}
	
	private void restoreReaderMode()
	{
		if ( changedPageMode ) {
			mReaderView.setSetting(ReaderView.PROP_PAGE_VIEW_MODE, ""1"");
		}
	}
	
	private void changeSelectionBound(boolean start, int delta) {
		L.d(""changeSelectionBound("" + (start?""start"":""end"") + "", "" + delta + "")"");
		ReaderCommand cmd = start ? ReaderCommand.DCMD_SELECT_MOVE_LEFT_BOUND_BY_WORDS : ReaderCommand.DCMD_SELECT_MOVE_RIGHT_BOUND_BY_WORDS; 
		mReaderView.moveSelection(cmd, delta, new ReaderView.MoveSelectionCallback() {
			
			@Override
			public void onNewSelection(Selection selection) {
				Log.d(""cr3"", ""onNewSelection: "" + selection.text);
				SelectionToolbarDlg.this.selection = selection;
			}
			
			@Override
			public void onFail() {
				Log.d(""cr3"", ""fail()"");
				//currentSelection = null;
			}
		});
	}
	
	private final static int SELECTION_CONTROL_STEP = 10; 
	private class BoundControlListener implements OnSeekBarChangeListener {

		public BoundControlListener(SeekBar sb, boolean start) {
			this.start = start;
			this.sb = sb;
			sb.setOnSeekBarChangeListener(this);
		}
		final boolean start;
		final SeekBar sb;
		int lastProgress = 50;
		
		@Override
		public void onStopTrackingTouch(SeekBar seekBar) {
			sb.setProgress(50);
			lastProgress = 50;
		}
		
		@Override
		public void onStartTrackingTouch(SeekBar seekBar) {
			sb.setProgress(50);
		}
		
		@Override
		public void onProgressChanged(SeekBar seekBar, int progress,
				boolean fromUser) {
			if (!fromUser)
				return;
			int diff = (progress - lastProgress) / SELECTION_CONTROL_STEP * SELECTION_CONTROL_STEP;
			if (diff!=0) {
				lastProgress += diff;
				changeSelectionBound(start, diff/SELECTION_CONTROL_STEP);
			}
		}
	};
	
	private void closeDialog(boolean clearSelection) {
		if (clearSelection)
			mReaderView.clearSelection();
		restoreReaderMode();
		mWindow.dismiss();
	}
	
	public SelectionToolbarDlg( CoolReader coolReader, ReaderView readerView, Selection sel )
	{
		this.selection = sel;
		mCoolReader = coolReader;
		mReaderView = readerView;
		mAnchor = readerView;

		View panel = (LayoutInflater.from(coolReader.getApplicationContext()).inflate(R.layout.selection_toolbar, null));
		panel.measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		
		//mReaderView.getS
		setReaderMode();
		
		mWindow = new PopupWindow( mAnchor.getContext() );
		mWindow.setTouchInterceptor(new OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
					closeDialog(true);
					return true;
				}
				return false;
			}
		});
		//super(panel);
		mPanel = panel;
		mPanel.findViewById(R.id.selection_copy).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.copyToClipboard(selection.text);
				closeDialog(true);
			}
		});
		mPanel.findViewById(R.id.selection_dict).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mCoolReader.findInDictionary( selection.text );
				closeDialog(!mReaderView.getSettings().getBool(ReaderView.PROP_APP_SELECTION_PERSIST, false));
			}
		});
		mPanel.findViewById(R.id.selection_bookmark).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.showNewBookmarkDialog(selection);
				closeDialog(true);
			}
		});
		mPanel.findViewById(R.id.selection_email).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.sendQuotationInEmail(selection);
				closeDialog(true);
			}
		});
		mPanel.findViewById(R.id.selection_cancel).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				closeDialog(true);
			}
		});
		new BoundControlListener((SeekBar)mPanel.findViewById(R.id.selection_left_bound_control), true);
		new BoundControlListener((SeekBar)mPanel.findViewById(R.id.selection_right_bound_control), false);
		mPanel.setFocusable(true);
		mPanel.setOnKeyListener( new OnKeyListener() {

			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ( event.getAction()==KeyEvent.ACTION_UP ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_BACK:
						closeDialog(true);
						return true;
//					case KeyEvent.KEYCODE_DPAD_LEFT:
//					case KeyEvent.KEYCODE_DPAD_UP:
//						//mReaderView.findNext(pattern, true, caseInsensitive);
//						return true;
//					case KeyEvent.KEYCODE_DPAD_RIGHT:
//					case KeyEvent.KEYCODE_DPAD_DOWN:
//						//mReaderView.findNext(pattern, false, caseInsensitive);
//						return true;
					}
				} else if ( event.getAction()==KeyEvent.ACTION_DOWN ) {
						switch ( keyCode ) {
//						case KeyEvent.KEYCODE_BACK:
//						case KeyEvent.KEYCODE_DPAD_LEFT:
//						case KeyEvent.KEYCODE_DPAD_UP:
//						case KeyEvent.KEYCODE_DPAD_RIGHT:
//						case KeyEvent.KEYCODE_DPAD_DOWN:
//							return true;
						}
					}
				if ( keyCode == KeyEvent.KEYCODE_BACK) {
					return true;
				}
				return false;
			}
			
		});

		mWindow.setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss() {
				restoreReaderMode();
				mReaderView.clearSelection();
			}
		});
		
		mWindow.setBackgroundDrawable(new BitmapDrawable());
		//mWindow.setAnimationStyle(android.R.style.Animation_Toast);
		mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
		mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
//		setWidth(panel.getWidth());
//		setHeight(panel.getHeight());
		
		mWindow.setFocusable(true);
		mWindow.setTouchable(true);
		mWindow.setOutsideTouchable(true);
		mWindow.setContentView(panel);
		
		
		int [] location = new int[2];
		mAnchor.getLocationOnScreen(location);
		//mWindow.update(location[0], location[1], mPanel.getWidth(), mPanel.getHeight() );
		//mWindow.setWidth(mPanel.getWidth());
		//mWindow.setHeight(mPanel.getHeight());

		mWindow.showAtLocation(mAnchor, Gravity.TOP | Gravity.CENTER_HORIZONTAL, location[0], location[1] + mAnchor.getHeight() - mPanel.getHeight());
//		if ( mWindow.isShowing() )
//			mWindow.update(mAnchor, 50, 50);
		//dlg.mWindow.showAsDropDown(dlg.mAnchor);
	
	}
	
}
",True,30,49,0,0,3,34,1,6,L0
5,org.coolreader.crengine.OPDSCatalogEditDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;

public class OPDSCatalogEditDialog extends BaseDialog {

	private final CoolReader mCoolReader;
	private final LayoutInflater mInflater;
	private final FileInfo mItem;
	private final EditText nameEdit;
	private final EditText urlEdit;
	private final Runnable mOnUpdate;

	public OPDSCatalogEditDialog(CoolReader activity, FileInfo item, Runnable onUpdate) {
		super(activity, activity.getString((item.id == null) ? R.string.dlg_catalog_add_title
				: R.string.dlg_catalog_edit_title), true,
				false);
		mCoolReader = activity;
		mItem = item;
		mOnUpdate = onUpdate;
		mInflater = LayoutInflater.from(getContext());
		View view = mInflater.inflate(R.layout.catalog_edit_dialog, null);
		nameEdit = (EditText) view.findViewById(R.id.catalog_name);
		urlEdit = (EditText) view.findViewById(R.id.catalog_url);
		nameEdit.setText(mItem.filename);
		urlEdit.setText(mItem.getOPDSUrl());
		setView(view);
	}

	@Override
	protected void onPositiveButtonClick() {
		mCoolReader.getDB().saveOPDSCatalog(mItem.id,
				urlEdit.getText().toString(), nameEdit.getText().toString());
		mOnUpdate.run();
		super.onPositiveButtonClick();
	}

	@Override
	protected void onNegativeButtonClick() {
		super.onNegativeButtonClick();
	}

}
",True,37,49,0,0,3,23,1,4,L0
6,org.coolreader.crengine.Settings.java,"package org.coolreader.crengine;

public interface Settings {
    public static final String PROP_PAGE_BACKGROUND_IMAGE       =""background.image"";
    public static final String PROP_PAGE_BACKGROUND_IMAGE_DAY   =""background.image.day"";
    public static final String PROP_PAGE_BACKGROUND_IMAGE_NIGHT =""background.image.night"";
    public static final String PROP_NIGHT_MODE              =""crengine.night.mode"";
    public static final String PROP_FONT_COLOR_DAY          =""font.color.day"";
    public static final String PROP_BACKGROUND_COLOR_DAY    =""background.color.day"";
    public static final String PROP_FONT_COLOR_NIGHT        =""font.color.night"";
    public static final String PROP_BACKGROUND_COLOR_NIGHT  =""background.color.night"";
    public static final String PROP_FONT_COLOR              =""font.color.default"";
    public static final String PROP_BACKGROUND_COLOR        =""background.color.default"";
    public static final String PROP_FONT_ANTIALIASING       =""font.antialiasing.mode"";
    public static final String PROP_FONT_FACE               =""font.face.default"";
    public static final String PROP_FONT_GAMMA              =""font.gamma"";
    public static final String PROP_FONT_GAMMA_DAY          =""font.gamma.day"";
    public static final String PROP_FONT_GAMMA_NIGHT        =""font.gamma.night"";
    public static final String PROP_FONT_WEIGHT_EMBOLDEN    =""font.face.weight.embolden"";
    public static final String PROP_TXT_OPTION_PREFORMATTED =""crengine.file.txt.preformatted"";
    public static final String PROP_LOG_FILENAME            =""crengine.log.filename"";
    public static final String PROP_LOG_LEVEL               =""crengine.log.level"";
    public static final String PROP_LOG_AUTOFLUSH           =""crengine.log.autoflush"";
    public static final String PROP_FONT_SIZE               =""crengine.font.size"";
    public static final String PROP_FALLBACK_FONT_FACE      =""crengine.font.fallback.face"";
    public static final String PROP_STATUS_FONT_COLOR       =""crengine.page.header.font.color"";
    public static final String PROP_STATUS_FONT_COLOR_DAY   =""crengine.page.header.font.color.day"";
    public static final String PROP_STATUS_FONT_COLOR_NIGHT =""crengine.page.header.font.color.night"";
    public static final String PROP_STATUS_FONT_FACE        =""crengine.page.header.font.face"";
    public static final String PROP_STATUS_FONT_SIZE        =""crengine.page.header.font.size"";
    public static final String PROP_STATUS_CHAPTER_MARKS    =""crengine.page.header.chapter.marks"";
    public static final String PROP_PAGE_MARGIN_TOP         =""crengine.page.margin.top"";
    public static final String PROP_PAGE_MARGIN_BOTTOM      =""crengine.page.margin.bottom"";
    public static final String PROP_PAGE_MARGIN_LEFT        =""crengine.page.margin.left"";
    public static final String PROP_PAGE_MARGIN_RIGHT       =""crengine.page.margin.right"";
    public static final String PROP_PAGE_VIEW_MODE          =""crengine.page.view.mode""; // pages/scroll
    public static final String PROP_PAGE_ANIMATION          =""crengine.page.animation"";
    public static final String PROP_INTERLINE_SPACE         =""crengine.interline.space"";
    public static final String PROP_ROTATE_ANGLE            =""window.rotate.angle"";
    public static final String PROP_EMBEDDED_STYLES         =""crengine.doc.embedded.styles.enabled"";
    public static final String PROP_DISPLAY_INVERSE         =""crengine.display.inverse"";
//    public static final String PROP_DISPLAY_FULL_UPDATE_INTERVAL =""crengine.display.full.update.interval"";
//    public static final String PROP_DISPLAY_TURBO_UPDATE_MODE =""crengine.display.turbo.update"";
    public static final String PROP_STATUS_LINE             =""window.status.line"";
    public static final String PROP_BOOKMARK_ICONS          =""crengine.bookmarks.icons"";
    public static final String PROP_FOOTNOTES               =""crengine.footnotes"";
    public static final String PROP_SHOW_TIME               =""window.status.clock"";
    public static final String PROP_SHOW_TITLE              =""window.status.title"";
    public static final String PROP_SHOW_BATTERY            =""window.status.battery"";
    public static final String PROP_SHOW_BATTERY_PERCENT    =""window.status.battery.percent"";
    public static final String PROP_SHOW_POS_PERCENT        =""window.status.pos.percent"";
    public static final String PROP_SHOW_PAGE_COUNT         =""window.status.pos.page.count"";
    public static final String PROP_SHOW_PAGE_NUMBER        =""window.status.pos.page.number"";
    public static final String PROP_FONT_KERNING_ENABLED    =""font.kerning.enabled"";
    public static final String PROP_FLOATING_PUNCTUATION    =""crengine.style.floating.punctuation.enabled"";
    public static final String PROP_LANDSCAPE_PAGES         =""window.landscape.pages"";
    public static final String PROP_HYPHENATION_DICT        =""crengine.hyphenation.dictionary.code""; // non-crengine
    public static final String PROP_AUTOSAVE_BOOKMARKS      =""crengine.autosave.bookmarks"";

    public static final String PROP_PROFILE_NUMBER          =""crengine.profile.number""; // current settings profile number
    public static final String PROP_APP_SETTINGS_SHOW_ICONS =""app.settings.show.icons"";

    
	 // image scaling settings
	 // mode: 0=disabled, 1=integer scaling factors, 2=free scaling
	 // scale: 0=auto based on font size, 1=no zoom, 2=scale up to *2, 3=scale up to *3
    public static final String PROP_IMG_SCALING_ZOOMIN_INLINE_MODE = ""crengine.image.scaling.zoomin.inline.mode"";
    public static final String PROP_IMG_SCALING_ZOOMIN_INLINE_SCALE = ""crengine.image.scaling.zoomin.inline.scale"";
    public static final String PROP_IMG_SCALING_ZOOMOUT_INLINE_MODE = ""crengine.image.scaling.zoomout.inline.mode"";
    public static final String PROP_IMG_SCALING_ZOOMOUT_INLINE_SCALE = ""crengine.image.scaling.zoomout.inline.scale"";
    public static final String PROP_IMG_SCALING_ZOOMIN_BLOCK_MODE = ""crengine.image.scaling.zoomin.block.mode"";
    public static final String PROP_IMG_SCALING_ZOOMIN_BLOCK_SCALE = ""crengine.image.scaling.zoomin.block.scale"";
    public static final String PROP_IMG_SCALING_ZOOMOUT_BLOCK_MODE = ""crengine.image.scaling.zoomout.block.mode"";
    public static final String PROP_IMG_SCALING_ZOOMOUT_BLOCK_SCALE = ""crengine.image.scaling.zoomout.block.scale"";
    
    public static final String PROP_FORMAT_MIN_SPACE_CONDENSING_PERCENT = ""crengine.style.space.condensing.percent"";
    
    public static final String PROP_MIN_FILE_SIZE_TO_CACHE  =""crengine.cache.filesize.min"";
    public static final String PROP_FORCED_MIN_FILE_SIZE_TO_CACHE  =""crengine.cache.forced.filesize.min"";
    public static final String PROP_PROGRESS_SHOW_FIRST_PAGE=""crengine.progress.show.first.page"";

    public static final String PROP_CONTROLS_ENABLE_VOLUME_KEYS =""app.controls.volume.keys.enabled"";
    
    public static final String PROP_APP_FULLSCREEN          =""app.fullscreen"";
    public static final String PROP_APP_BOOK_PROPERTY_SCAN_ENABLED =""app.browser.fileprops.scan.enabled"";
    public static final String PROP_APP_SHOW_COVERPAGES     =""app.browser.coverpages"";
    public static final String PROP_APP_SCREEN_ORIENTATION  =""app.screen.orientation"";
    public static final String PROP_APP_SCREEN_BACKLIGHT    =""app.screen.backlight"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_DAY   =""app.screen.backlight.day"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_NIGHT =""app.screen.backlight.night"";
    public static final String PROP_APP_DOUBLE_TAP_SELECTION     =""app.controls.doubletap.selection"";
    public static final String PROP_APP_TAP_ZONE_ACTIONS_TAP     =""app.tapzone.action.tap"";
    public static final String PROP_APP_KEY_ACTIONS_PRESS     =""app.key.action.press"";
    public static final String PROP_APP_TRACKBALL_DISABLED    =""app.trackball.disabled"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_LOCK    =""app.screen.backlight.lock.enabled"";
    public static final String PROP_APP_TAP_ZONE_HILIGHT     =""app.tapzone.hilight"";
    public static final String PROP_APP_FLICK_BACKLIGHT_CONTROL = ""app.screen.backlight.control.flick"";
    public static final String PROP_APP_BOOK_SORT_ORDER = ""app.browser.sort.order"";
    public static final String PROP_APP_DICTIONARY = ""app.dictionary.current"";
    public static final String PROP_APP_SELECTION_ACTION = ""app.selection.action"";
    public static final String PROP_APP_SELECTION_PERSIST = ""app.selection.persist"";
    public static final String PROP_APP_HIGHLIGHT_BOOKMARKS = ""crengine.highlight.bookmarks"";
    public static final String PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS = ""app.browser.hide.empty.folders"";
    public static final String PROP_APP_FILE_BROWSER_SIMPLE_MODE = ""app.browser.simple.mode"";

    public static final String PROP_APP_SCREEN_UPDATE_MODE  =""app.screen.update.mode"";
    public static final String PROP_APP_SCREEN_UPDATE_INTERVAL  =""app.screen.update.interval"";
    public static final String PROP_APP_SECONDARY_TAP_ACTION_TYPE  =""app.touch.secondary.action.type"";

    public static final String PROP_APP_VIEW_AUTOSCROLL_SPEED  =""app.view.autoscroll.speed"";
    public static final String PROP_APP_VIEW_AUTOSCROLL_TYPE  =""app.view.autoscroll.type"";

    public static final String PROP_APP_THEME  =""app.ui.theme"";
    public static final String PROP_APP_THEME_DAY  =""app.ui.theme.day"";
    public static final String PROP_APP_THEME_NIGHT  =""app.ui.theme.night"";
    
    // available options for PROP_APP_SELECTION_ACTION setting
    public static final int SELECTION_ACTION_TOOLBAR = 0;
    public static final int SELECTION_ACTION_COPY = 1;
    public static final int SELECTION_ACTION_DICTIONARY = 2;
    public static final int SELECTION_ACTION_BOOKMARK = 3;
    
    // available options for PROP_APP_SECONDARY_TAP_ACTION_TYPE setting
    public static final int TAP_ACTION_TYPE_LONGPRESS = 0;
    public static final int TAP_ACTION_TYPE_DOUBLE = 1;
    public static final int TAP_ACTION_TYPE_SHORT = 2;

    // available options for PROP_APP_FLICK_BACKLIGHT_CONTROL setting
    public static final int BACKLIGHT_CONTROL_FLICK_NONE = 0;
    public static final int BACKLIGHT_CONTROL_FLICK_LEFT = 1;
    public static final int BACKLIGHT_CONTROL_FLICK_RIGHT = 2;

	public final static int MAX_PROFILES = 6;

}
",False,33,30,4,17,0,0,8,0,L0
7,org.coolreader.crengine.DeviceInfo.java,"package org.coolreader.crengine;

import android.os.Build;
import android.util.Log;

public class DeviceInfo {

	public final static String MANUFACTURER;
	public final static String MODEL;
	public final static String DEVICE;
	public final static boolean SAMSUNG_BUTTONS_HIGHLIGHT_PATCH;
	public final static boolean EINK_SCREEN;
	public final static boolean EINK_SCREEN_UPDATE_MODES_SUPPORTED;
	public final static boolean NOOK_NAVIGATION_KEYS;
	public final static boolean EINK_NOOK;
	public final static boolean FORCE_LIGHT_THEME;
	public final static boolean EINK_SONY;
	public final static boolean SONY_NAVIGATION_KEYS;
	
	static {
		MANUFACTURER = getBuildField(""MANUFACTURER"");
		MODEL = getBuildField(""MODEL"");
		DEVICE = getBuildField(""DEVICE"");
		SAMSUNG_BUTTONS_HIGHLIGHT_PATCH = MANUFACTURER.toLowerCase().contentEquals(""samsung"") &&
		               (MODEL.contentEquals(""GT-S5830"") || MODEL.contentEquals(""GT-S5660"")); // More models?
		EINK_NOOK = MANUFACTURER.toLowerCase().contentEquals(""barnesandnoble"") && MODEL.contentEquals(""NOOK"") &&
				DEVICE.toLowerCase().contentEquals(""zoom2"");
		EINK_SONY = MANUFACTURER.toLowerCase().contentEquals(""sony"") && MODEL.contentEquals(""PRS-T1"");
		EINK_SCREEN = EINK_SONY || EINK_NOOK; // TODO: set to true for eink devices like Nook Touch
		
		NOOK_NAVIGATION_KEYS = EINK_NOOK; // TODO: add autodetect
		SONY_NAVIGATION_KEYS = EINK_SONY;
		EINK_SCREEN_UPDATE_MODES_SUPPORTED = EINK_SCREEN && EINK_NOOK; // TODO: add autodetect
		FORCE_LIGHT_THEME = EINK_SCREEN;
	}
	
	private static String getBuildField(String fieldName) {
		
		try {
			return (String)Build.class.getField(fieldName).get(null);
		} catch (Exception e) {
			Log.d(""cr3"", ""Exception while trying to check Build."" + fieldName);
			return """";
		}
	}
}
",True,17,32,4,21,0,0,7,0,L0
8,org.coolreader.crengine.BookInfo.java,"package org.coolreader.crengine;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import android.util.Log;

public class BookInfo {
	private FileInfo fileInfo;
	private Bookmark lastPosition;
	private ArrayList<Bookmark> bookmarks = new ArrayList<Bookmark>();

	synchronized public void setShortcutBookmark(int shortcut, Bookmark bookmark)
	{
		bookmark.setShortcut(shortcut);
		bookmark.setModified(true);
		for ( int i=0; i<bookmarks.size(); i++ ) {
			Bookmark bm = bookmarks.get(i);
			if ( bm.getType()==Bookmark.TYPE_POSITION && bm.getShortcut()==shortcut ) {
				bookmark.setId(bm.getId());
				bookmarks.set(i, bookmark);
				return;
			}
		}
		bookmarks.add(bookmark);
	}
	
	synchronized public Bookmark findShortcutBookmark( int shortcut )
	{
		for ( Bookmark bm : bookmarks )
			if ( bm.getType()==Bookmark.TYPE_POSITION && bm.getShortcut()==shortcut )
				return bm;
		return null;
	}
	
	public void updateAccess()
	{
		// TODO:
	}
	
	public BookInfo( FileInfo fileInfo )
	{
		this.fileInfo = fileInfo; //new FileInfo(fileInfo);
	}
	
	public Bookmark getLastPosition()
	{
		return lastPosition;
	}
	
	public void setLastPosition( Bookmark position )
	{
		synchronized (this) {
			if ( lastPosition!=null )
				position.setId(lastPosition.getId());
			lastPosition = position;
			lastPosition.setModified(true);
			fileInfo.lastAccessTime = lastPosition.getTimeStamp();
			fileInfo.setModified(true);
		}
	}
	
	public FileInfo getFileInfo()
	{
		return fileInfo;
	}
	
	synchronized public void addBookmark( Bookmark bm )
	{
		bookmarks.add(bm);
	}

	synchronized public int getBookmarkCount()
	{
		return bookmarks.size();
	}

	synchronized public Bookmark getBookmark( int index )
	{
		return bookmarks.get(index);
	}

	synchronized public Bookmark findBookmark(Bookmark bm)
	{
		if ( bm==null )
			return null;
		int index = findBookmarkIndex(bm);
		if (index < 0)
			return null;
		return bookmarks.get(index);
	}

	private int findBookmarkIndex(Bookmark bm)
	{
		if ( bm==null )
			return -1;
		int index = -1;
		for ( int i=0; i<bookmarks.size(); i++ ) {
			Bookmark item = bookmarks.get(i);
			if ( bm.getShortcut()>0 && item.getShortcut()==bm.getShortcut() ) {
				index = i;
				break;
			}
			if ( bm.getStartPos()!=null && bm.getStartPos().equals(item.getStartPos())) {
				if (bm.getType() == Bookmark.TYPE_POSITION) {
					index = i;
					break;
				}
				if (bm.getEndPos()!=null && bm.getEndPos().equals(item.getEndPos())) {
					if (item.getId() != null && bm.getId() != null && !bm.getId().equals(item.getId()))
						continue; // another bookmark with same pos
					index = i;
					break;
				}
			}
		}
		return index;
	}

	synchronized public Bookmark updateBookmark(Bookmark bm)
	{
		if ( bm==null )
			return null;
		int index = findBookmarkIndex(bm);
		if ( index<0 ) {
			Log.e(""cr3"", ""cannot find bookmark "" + bm);
			return null;
		}
		Bookmark item = bookmarks.get(index);
		item.setTimeStamp(bm.getTimeStamp());
		item.setPosText(bm.getPosText());
		item.setCommentText(bm.getCommentText());
		if (!item.isModified())
			return null;
		return item;
	}
	synchronized public Bookmark removeBookmark(Bookmark bm)
	{
		if ( bm==null )
			return null;
		int index = findBookmarkIndex(bm);
		if ( index<0 ) {
			Log.e(""cr3"", ""cannot find bookmark "" + bm);
			return null;
		}
		return bookmarks.remove(index);
	}

	synchronized public void sortBookmarks() {
		Collections.sort(bookmarks, new Comparator<Bookmark>() {
			@Override
			public int compare(Bookmark bm1, Bookmark bm2) {
				if ( bm1.getPercent() < bm2.getPercent() )
					return -1;
				if ( bm1.getPercent() > bm2.getPercent() )
					return 1;
				return 0;
			}
		});
	}
	
	synchronized public String getBookmarksExportText() {
		StringBuilder buf = new StringBuilder();
		File pathname = new File(fileInfo.getPathName());
		buf.append(""# file name: "" + pathname.getName() + ""\n"");
		buf.append(""# file path: "" + pathname.getParent() + ""\n"");
		buf.append(""# book title: "" + fileInfo.title + ""\n"");
		buf.append(""# author: "" + fileInfo.authors + ""\n"");
		buf.append(""\n"");
		for ( Bookmark bm : bookmarks ) {
			if ( bm.getType()!=Bookmark.TYPE_COMMENT && bm.getType()!=Bookmark.TYPE_CORRECTION )
				continue;
			int percent = bm.getPercent();
			String ps = String.valueOf(percent%100);
			if ( ps.length()<2 )
				ps = ""0"" + ps;
			ps = String.valueOf(percent/100) + ""."" + ps  + ""%"";
			buf.append(""## "" + ps + "" - "" + (bm.getType()!=Bookmark.TYPE_COMMENT ? ""comment"" : ""correction"")  + ""\n"");
			if ( bm.getTitleText()!=null )
				buf.append(""## "" + bm.getTitleText() + ""\n"");
			if ( bm.getPosText()!=null )
				buf.append(""<< "" + bm.getPosText() + ""\n"");
			if ( bm.getCommentText()!=null )
				buf.append("">> "" + bm.getCommentText() + ""\n"");
			buf.append(""\n"");
		}
		return buf.toString();
	}

	synchronized public boolean exportBookmarks( String fileName ) {
		Log.i(""cr3"", ""Exporting bookmarks to file "" + fileName);
		try { 
			FileOutputStream stream = new FileOutputStream(new File(fileName));
			OutputStreamWriter writer = new OutputStreamWriter(stream, ""UTF-8""); 
			writer.write(0xfeff);
			writer.write(""# Cool Reader 3 - exported bookmarks\r\n"");
			File pathname = new File(fileInfo.getPathName());
			writer.write(""# file name: "" + pathname.getName() + ""\r\n"");
			writer.write(""# file path: "" + pathname.getParent() + ""\r\n"");
			writer.write(""# book title: "" + fileInfo.title + ""\r\n"");
			writer.write(""# author: "" + fileInfo.authors + ""\r\n"");
			writer.write(""# series: "" + fileInfo.series + ""\r\n"");
			writer.write(""\r\n"");
			for ( Bookmark bm : bookmarks ) {
				if ( bm.getType()!=Bookmark.TYPE_COMMENT && bm.getType()!=Bookmark.TYPE_CORRECTION )
					continue;
				int percent = bm.getPercent();
				String ps = String.valueOf(percent%100);
				if ( ps.length()<2 )
					ps = ""0"" + ps;
				ps = String.valueOf(percent/100) + ""."" + ps  + ""%"";
				writer.write(""## "" + ps + "" - "" + (bm.getType()!=Bookmark.TYPE_COMMENT ? ""comment"" : ""correction"")  + ""\r\n"");
				if ( bm.getTitleText()!=null )
					writer.write(""## "" + bm.getTitleText() + ""\r\n"");
				if ( bm.getPosText()!=null )
					writer.write(""<< "" + bm.getPosText() + ""\r\n"");
				if ( bm.getCommentText()!=null )
					writer.write("">> "" + bm.getCommentText() + ""\r\n"");
				writer.write(""\r\n"");
			}
			writer.close();
			return true;
		} catch ( IOException e ) {
			Log.e(""cr3"", ""Cannot write bookmark file "" + fileName);
			return false;
		}
	}
	
	
	synchronized public Bookmark removeBookmark( int index )
	{
		return bookmarks.remove(index);
	}
	
	synchronized void setBookmarks(ArrayList<Bookmark> list)
	{
		if ( list.size()>0 ) {
			if ( list.get(0).getType()==0 ) {
				lastPosition = list.remove(0); 
			}
		}
		if ( list.size()>0 ) {
			bookmarks = list;
		}
	}

	@Override
	public String toString() {
		return ""BookInfo [fileInfo="" + fileInfo + "", lastPosition=""
				+ lastPosition + ""]"";
	}

	
	
}
",True,20,33,4,21,2,2,6,2,L0
9,org.coolreader.crengine.ProgressDialog.java,"package org.coolreader.crengine;

import android.R.drawable;
import android.app.AlertDialog;
import android.content.Context;
import android.graphics.Color;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import org.coolreader.R;

/**
 * Progress dialog, based on source code of android.app.ProgressDialog
 */
public class ProgressDialog extends AlertDialog {
    
    /** Creates a ProgressDialog with a ciruclar, spinning progress
     * bar. This is the default.
     */
    public static final int STYLE_SPINNER = 0;
    
    /** Creates a ProgressDialog with a horizontal progress bar.
     */
    public static final int STYLE_HORIZONTAL = 1;
    
    private ProgressBar mProgress;
    private TextView mMessageView;
    
    private int mProgressStyle = STYLE_SPINNER;
    
    private int mMax;
    private int mProgressVal;
    private int mSecondaryProgressVal;
    private int mIncrementBy;
    private int mIncrementSecondaryBy;
    private Drawable mProgressDrawable;
    private Drawable mIndeterminateDrawable;
    private CharSequence mMessage;
    private boolean mIndeterminate;
    
    private boolean mHasStarted;
    private Handler mViewUpdateHandler;
    private Context mContext;
    
    public ProgressDialog(Context context) {
        super(context);
        //super(context, android.R.style.Theme_Light);
        mContext = context;
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message) {
        return show(context, title, message, false);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate) {
        return show(context, title, message, indeterminate, false, null);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate, boolean cancelable) {
        return show(context, title, message, indeterminate, cancelable, null);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate,
            boolean cancelable, OnCancelListener cancelListener) {
        ProgressDialog dialog = new ProgressDialog(context);
        dialog.setTitle(title);
        dialog.setMessage(message);
        dialog.setIndeterminate(indeterminate);
        dialog.setCancelable(cancelable);
        dialog.setOnCancelListener(cancelListener);
        dialog.show();
        return dialog;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        LayoutInflater inflater = LayoutInflater.from(mContext);
        if (mProgressStyle == STYLE_HORIZONTAL) {
            
            /* Use a separate handler to update the text views as they
             * must be updated on the same thread that created them.
             */
            mViewUpdateHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                }
            };
            View view = inflater.inflate(R.layout.alert_dialog_progress, null);
            mProgress = (ProgressBar) view.findViewById(R.id.progress);
            //view.setBackgroundColor(Color.WHITE);
            setView(view);
//    		if ( DeviceInfo.FORCE_LIGHT_THEME ) {
//    			//getWindow() setTheme(android.R.style.Theme_Light);
//    			getWindow().setBackgroundDrawableResource(drawable.editbox_background);
//    		}
       } else {
            View view = inflater.inflate(R.layout.progress_dialog, null);
            mProgress = (ProgressBar) view.findViewById(R.id.progress);
            mMessageView = (TextView) view.findViewById(R.id.message);
            setView(view);
        }
        if (mMax > 0) {
            setMax(mMax);
        }
        if (mProgressVal > 0) {
            setProgress(mProgressVal);
        }
        if (mSecondaryProgressVal > 0) {
            setSecondaryProgress(mSecondaryProgressVal);
        }
        if (mIncrementBy > 0) {
            incrementProgressBy(mIncrementBy);
        }
        if (mIncrementSecondaryBy > 0) {
            incrementSecondaryProgressBy(mIncrementSecondaryBy);
        }
        if (mProgressDrawable != null) {
            setProgressDrawable(mProgressDrawable);
        }
        if (mIndeterminateDrawable != null) {
            setIndeterminateDrawable(mIndeterminateDrawable);
        }
        if (mMessage != null) {
            setMessage(mMessage);
        }
        setIndeterminate(mIndeterminate);
        onProgressChanged();
        super.onCreate(savedInstanceState);
    }
    
    @Override
    public void onStart() {
        super.onStart();
        mHasStarted = true;
    }
    
    @Override
    protected void onStop() {
        super.onStop();
        mHasStarted = false;
    }

    public void setProgress(int value) {
        if (mHasStarted && mProgress!=null) {
            mProgress.setProgress(value);
            onProgressChanged();
        } else {
            mProgressVal = value;
        }
    }

    public void setSecondaryProgress(int secondaryProgress) {
        if (mProgress != null) {
            mProgress.setSecondaryProgress(secondaryProgress);
            onProgressChanged();
        } else {
            mSecondaryProgressVal = secondaryProgress;
        }
    }

    public int getProgress() {
        if (mProgress != null) {
            return mProgress.getProgress();
        }
        return mProgressVal;
    }

    public int getSecondaryProgress() {
        if (mProgress != null) {
            return mProgress.getSecondaryProgress();
        }
        return mSecondaryProgressVal;
    }

    public int getMax() {
        if (mProgress != null) {
            return mProgress.getMax();
        }
        return mMax;
    }

    public void setMax(int max) {
        if (mProgress != null) {
            mProgress.setMax(max);
            onProgressChanged();
        } else {
            mMax = max;
        }
    }

    public void incrementProgressBy(int diff) {
        if (mProgress != null) {
            mProgress.incrementProgressBy(diff);
            onProgressChanged();
        } else {
            mIncrementBy += diff;
        }
    }

    public void incrementSecondaryProgressBy(int diff) {
        if (mProgress != null) {
            mProgress.incrementSecondaryProgressBy(diff);
            onProgressChanged();
        } else {
            mIncrementSecondaryBy += diff;
        }
    }

    public void setProgressDrawable(Drawable d) {
        if (mProgress != null) {
            mProgress.setProgressDrawable(d);
        } else {
            mProgressDrawable = d;
        }
    }

    public void setIndeterminateDrawable(Drawable d) {
        if (mProgress != null) {
            mProgress.setIndeterminateDrawable(d);
        } else {
            mIndeterminateDrawable = d;
        }
    }

    public void setIndeterminate(boolean indeterminate) {
        if (mProgress != null) {
            mProgress.setIndeterminate(indeterminate);
        } else {
            mIndeterminate = indeterminate;
        }
    }

    public boolean isIndeterminate() {
        if (mProgress != null) {
            return mProgress.isIndeterminate();
        }
        return mIndeterminate;
    }
    
    @Override
    public void setMessage(CharSequence message) {
        if (mProgress != null) {
            if (mProgressStyle == STYLE_HORIZONTAL) {
                super.setMessage(message);
            } else {
                mMessageView.setText(message);
            }
        } else {
            mMessage = message;
        }
    }
    
    public void setProgressStyle(int style) {
        mProgressStyle = style;
    }

    private void onProgressChanged() {
        if (mProgressStyle == STYLE_HORIZONTAL) {
            mViewUpdateHandler.sendEmptyMessage(0);
        }
    }
}
",True,3,30,4,17,0,0,2,0,L0
10,org.coolreader.crengine.SearchDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;

public class SearchDlg  extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	private LayoutInflater mInflater;
	View mDialogView;
	EditText mEditView;
	CheckBox mCaseSensitive;
	CheckBox mReverse;
	
	@Override
	protected void onPositiveButtonClick()
	{
		// override it
    	String pattern = mEditView.getText().toString();
    	if ( pattern==null || pattern.length()==0 ) 
    		mCoolReader.showToast(""No pattern specified"");
    	else
    		mReaderView.findText( mEditView.getText().toString(), mReverse.isChecked(), !mCaseSensitive.isChecked() );
        cancel();
	}
	
	@Override
	protected void onNegativeButtonClick()
	{
		// override it
        cancel();
	}

	
	public SearchDlg( CoolReader coolReader, ReaderView readerView )
	{
		super(coolReader, coolReader.getResources().getString(R.string.win_title_search), true, false);
        setCancelable(true);
		this.mCoolReader = coolReader;
		this.mReaderView = readerView;
		setPositiveButtonImage(R.drawable.cr3_button_find);
        mInflater = LayoutInflater.from(getContext());
        mDialogView = mInflater.inflate(R.layout.search_dialog, null);
    	mEditView = (EditText)mDialogView.findViewById(R.id.search_text);
    	mCaseSensitive = (CheckBox)mDialogView.findViewById(R.id.search_case_sensitive);
    	mReverse = (CheckBox)mDialogView.findViewById(R.id.search_reverse);
		// setup buttons
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setView(mDialogView);
	}
}
",False,11,49,0,0,3,37,1,3,L0
11,org.coolreader.crengine.Utils.java,"package org.coolreader.crengine;

public class Utils {
	public static long timeStamp() {
		return android.os.SystemClock.uptimeMillis();
	}
	
	public static long timeInterval(long startTime) {
		return android.os.SystemClock.uptimeMillis() - startTime;
	}
	
}
",False,49,30,4,23,0,0,2,0,L0
12,org.coolreader.crengine.OptionsDialog.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.ColorPickerDialog.OnColorChangedListener;

import android.content.Context;
import android.content.DialogInterface;
import android.database.DataSetObserver;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.TabHost;
import android.widget.TabHost.TabContentFactory;
import android.widget.TabWidget;
import android.widget.TextView;

public class OptionsDialog extends BaseDialog implements TabContentFactory, OptionOwner, Settings {

	ReaderView mReaderView;
	CoolReader mActivity;
	String[] mFontFaces;
	int[] mFontSizes = new int[] {
		12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 64, 68, 72
	};
	int[] mStatusFontSizes = new int[] {
			10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 22, 24, 26, 28, 30,
			32
		};
	public static int findBacklightSettingIndex( int value ) {
		int bestIndex = 0;
		int bestDiff = -1;
		for ( int i=0; i<mBacklightLevels.length; i++ ) {
			int diff = mBacklightLevels[i] - value;
			if (diff<0)
				diff = -diff;
			if ( bestDiff==-1 || diff < bestDiff ) {
				bestDiff = diff;
				bestIndex = i;
			}
		}
		return bestIndex;
	}
	public static final int[] mBacklightLevels = new int[] {
		-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100
	};
	public static final String[] mBacklightLevelsTitles = new String[] {
			""Default"", ""1%"", ""2%"", ""3%"", ""4%"", ""5%"", ""6%"", ""7%"", ""8%"", ""9%"", 
			""10%"", ""12%"", ""15%"", ""20%"", ""25%"", ""30%"", ""35%"", ""40%"", ""45%"", ""50%"", ""55%"", ""60%"", ""65%"", ""70%"", ""75%"", ""80%"", ""85%"", ""90%"", ""95%"", ""100%"",
	};
	int[] mInterlineSpaces = new int[] {
			80, 85, 90, 95, 100, 105, 110, 115, 120, 130, 140, 150, 160, 180, 200
		};
	int[] mMinSpaceWidths = new int[] {
			50, 60, 70, 80, 90, 100
		};
	int[] mMargins = new int[] {
			0, 1, 2, 3, 4, 5, 8, 10, 12, 15, 20, 25, 30, 40, 50, 60, 80, 100
		};
	double[] mGammas = new double[] {
			0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.5, 1.9
		};
	int[] mScreenFullUpdateInterval = new int[] {
			0, 2, 3, 4, 5, 7, 10, 15, 20
		};
	int[] mScreenUpdateModes = new int[] {
			0, 1, 2//, 2, 3
		};
	int[] mScreenUpdateModesTitles = new int[] {
			R.string.options_screen_update_mode_quality, R.string.options_screen_update_mode_fast, R.string.options_screen_update_mode_fast2
		};
	int[] mOrientations = new int[] {
			0, 1, 4
		};
	int[] mOrientationsTitles = new int[] {
			R.string.options_page_orientation_0, R.string.options_page_orientation_90, 
			R.string.options_page_orientation_sensor
		};
	int[] mOrientations_API9 = new int[] {
			0, 1, 2, 3, 4
		};
	int[] mOrientationsTitles_API9 = new int[] {
			R.string.options_page_orientation_0, R.string.options_page_orientation_90, R.string.options_page_orientation_180, R.string.options_page_orientation_270
			,R.string.options_page_orientation_sensor
		};
	int[] mImageScalingModes = new int[] {
			0, 1, 2
		};
	int[] mImageScalingModesTitles = new int[] {
			R.string.options_format_image_scaling_mode_disabled, R.string.options_format_image_scaling_mode_integer_factor, R.string.options_format_image_scaling_mode_arbitrary
		};
	int[] mImageScalingFactors = new int[] {
			0, 1, 2, 3
		};
	int[] mImageScalingFactorsTitles = new int[] {
			R.string.options_format_image_scaling_scale_auto, R.string.options_format_image_scaling_scale_1, R.string.options_format_image_scaling_scale_2, R.string.options_format_image_scaling_scale_3
		};
	int[] mFlickBrightness = new int[] {
			0, 1, 2
		};
	int[] mFlickBrightnessTitles = new int[] {
			R.string.options_controls_flick_brightness_none, R.string.options_controls_flick_brightness_left, R.string.options_controls_flick_brightness_right
		};
	int[] mBacklightTimeout = new int[] {
			0, 2, 3, 4, 5, 6
		};
	int[] mBacklightTimeoutTitles = new int[] {
			R.string.options_app_backlight_timeout_0, R.string.options_app_backlight_timeout_2, R.string.options_app_backlight_timeout_3, R.string.options_app_backlight_timeout_4, R.string.options_app_backlight_timeout_5, R.string.options_app_backlight_timeout_6
		};
	int[] mTapSecondaryActionType = new int[] {
			TAP_ACTION_TYPE_LONGPRESS, TAP_ACTION_TYPE_DOUBLE
		};
	int[] mTapSecondaryActionTypeTitles = new int[] {
			R.string.options_controls_tap_type_long, R.string.options_controls_tap_type_double
		};
	int[] mAnimation = new int[] {
			ReaderView.PAGE_ANIMATION_NONE, ReaderView.PAGE_ANIMATION_SLIDE, ReaderView.PAGE_ANIMATION_SLIDE2, 
			ReaderView.PAGE_ANIMATION_PAPER
		};
	int[] mAnimationTitles = new int[] {
			R.string.options_page_animation_none, R.string.options_page_animation_slide, R.string.options_page_animation_slide_2_pages,
			R.string.options_page_animation_paperbook
		};
	int[] mSelectionAction = new int[] {
			ReaderView.SELECTION_ACTION_TOOLBAR, ReaderView.SELECTION_ACTION_COPY, 
			ReaderView.SELECTION_ACTION_DICTIONARY,
			ReaderView.SELECTION_ACTION_BOOKMARK
		};
	int[] mSelectionActionTitles = new int[] {
			R.string.options_selection_action_toolbar, 
			R.string.options_selection_action_copy, 
			R.string.options_selection_action_dictionary, 
			R.string.options_selection_action_bookmark, 
		};
	int[] mAntialias = new int[] {
			0, 1, 2
		};
	int[] mAntialiasTitles = new int[] {
			R.string.options_font_antialias_off, R.string.options_font_antialias_on_for_big, R.string.options_font_antialias_on_for_all
		};
	int[] mLandscapePages = new int[] {
			1, 2
		};
	int[] mLandscapePagesTitles = new int[] {
			R.string.options_page_landscape_pages_one, R.string.options_page_landscape_pages_two
		};
	int[] mViewModes = new int[] {
			1, 0
		};
	int[] mViewModeTitles = new int[] {
			R.string.options_view_mode_pages, R.string.options_view_mode_scroll
		};
	TabHost mTabs;
	LayoutInflater mInflater;
	Properties mProperties;
	Properties mOldProperties;
	OptionsListView mOptionsStyles;
	OptionsListView mOptionsCSS;
	OptionsListView mOptionsPage;
	OptionsListView mOptionsApplication;
	OptionsListView mOptionsControls;

	public final static int OPTION_VIEW_TYPE_NORMAL = 0;
	public final static int OPTION_VIEW_TYPE_BOOLEAN = 1;
	public final static int OPTION_VIEW_TYPE_COLOR = 2;
	public final static int OPTION_VIEW_TYPE_SUBMENU = 3;
	//public final static int OPTION_VIEW_TYPE_COUNT = 3;

	public CoolReader getActivity() { return mActivity; }
	public Properties getProperties() { return mProperties; }
	public LayoutInflater getInflater() { return mInflater; }
	
	public static class OptionBase {
		protected View myView;
		Properties mProperties;
		CoolReader mActivity;
		OptionOwner mOwner;
		LayoutInflater mInflater;
		public String label;
		public String property;
		public String defaultValue;
		public int iconId = R.drawable.cr3_option_other;
		public OptionsListView optionsListView;
		protected Runnable onChangeHandler;
		public OptionBase( OptionOwner owner, String label, String property ) {
			this.mOwner = owner;
			this.mActivity = owner.getActivity();
			this.mInflater = owner.getInflater();
			this.mProperties = owner.getProperties();
			this.label = label;
			this.property = property;
		}
		public OptionBase setIconId(int id) {
			this.iconId = id;
			return this;
		}
		public OptionBase noIcon() {
			this.iconId = 0;
			return this;
		}
		public OptionBase setDefaultValue(String value) {
			this.defaultValue = value;
			if ( mProperties.getProperty(property)==null )
				mProperties.setProperty(property, value);
			return this;
		}
		public void setOnChangeHandler( Runnable handler ) {
			onChangeHandler = handler;
		}

		public int getItemViewType() {
			return OPTION_VIEW_TYPE_NORMAL;
		}

		protected void refreshItem()
		{
			getView(null, null).invalidate();
			//if ( optionsListView!=null )
			//	optionsListView.refresh();
		}

		protected void refreshList()
		{
			getView(null, null).invalidate();
			if ( optionsListView!=null )
				optionsListView.refresh();
		}

		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			TextView valueView = (TextView)view.findViewById(R.id.option_value);
			labelView.setText(label);
			if (valueView != null) {
				String valueLabel = getValueLabel();
				if (valueLabel != null && valueLabel.length() > 0) {
					valueView.setText(valueLabel);
					valueView.setVisibility(View.VISIBLE);
				} else {
					valueView.setText("""");
					valueView.setVisibility(View.INVISIBLE);
				}
			}
			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
			if (icon != null) {
				if (iconId != 0 && showIcons) {
					icon.setVisibility(View.VISIBLE);
					icon.setImageResource(iconId);
				} else {
					icon.setImageResource(0);
					icon.setVisibility(View.INVISIBLE);
				}
			}
			return view;
		}

		public String getValueLabel() { return mProperties.getProperty(property); }
		public void onSelect() { refreshList(); }
	}
	
	class ColorOption extends OptionBase {
		final int defColor;
		public ColorOption( OptionOwner owner, String label, String property, int defColor ) {
			super(owner, label, property);
			this.defColor = defColor;
		}
		public String getValueLabel() { return mProperties.getProperty(property); }
		public void onSelect()
		{ 
			ColorPickerDialog dlg = new ColorPickerDialog(mActivity, new OnColorChangedListener() {
				public void colorChanged(int color) {
					mProperties.setColor(property, color);
					if ( property.equals(PROP_BACKGROUND_COLOR) ) {
						String texture = mProperties.getProperty(PROP_PAGE_BACKGROUND_IMAGE, Engine.NO_TEXTURE.id);
						if ( texture!=null && !texture.equals(Engine.NO_TEXTURE.id) ) {
							// reset background image
							mProperties.setProperty(PROP_PAGE_BACKGROUND_IMAGE, Engine.NO_TEXTURE.id);
							// TODO: show notification?
						}
					}
					refreshList();
				}
			}, mProperties.getColor(property, defColor), label);
			dlg.show();
		}
		public int getItemViewType() {
			return OPTION_VIEW_TYPE_COLOR;
		}
		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item_color, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			ImageView valueView = (ImageView)view.findViewById(R.id.option_value_color);
			labelView.setText(label);
			int cl = mProperties.getColor(property, defColor);
			valueView.setBackgroundColor(cl);
			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
			if (icon != null) {
				if (iconId != 0 && showIcons) {
					icon.setVisibility(View.VISIBLE);
					icon.setImageResource(iconId);
				} else {
					icon.setImageResource(0);
					icon.setVisibility(View.INVISIBLE);
				}
			}
			return view;
		}
	}
	
	private static boolean showIcons = true;
	
	class IconsBoolOption extends BoolOption {
		public IconsBoolOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		public void onSelect() {
			mProperties.setProperty(property, ""1"".equals(mProperties.getProperty(property)) ? ""0"" : ""1"");
			showIcons = mProperties.getBool(property, true);
			mOptionsStyles.refresh();
			mOptionsCSS.refresh();
			mOptionsPage.refresh();
			mOptionsApplication.refresh();
			mOptionsControls.refresh();
		}
	}
	class BoolOption extends OptionBase {
		private boolean inverse = false;
		public BoolOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		private boolean getValueBoolean() { return ""1"".equals(mProperties.getProperty(property)) ^ inverse; }
		public String getValueLabel() { return getValueBoolean()  ? getString(R.string.options_value_on) : getString(R.string.options_value_off); }
		public void onSelect() { 
			mProperties.setProperty(property, ""1"".equals(mProperties.getProperty(property)) ? ""0"" : ""1"");
			refreshList();
		}
		public BoolOption setInverse() { inverse = true; return this; }
		public int getItemViewType() {
			return OPTION_VIEW_TYPE_BOOLEAN;
		}
		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item_boolean, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			CheckBox valueView = (CheckBox)view.findViewById(R.id.option_value_cb);
//			valueView.setFocusable(false);
//			valueView.setClickable(false);
			labelView.setText(label);
			valueView.setChecked(getValueBoolean());
			valueView.setOnCheckedChangeListener(new OnCheckedChangeListener() {
					@Override
					public void onCheckedChanged(CompoundButton arg0,
							boolean checked) {
//						mProperties.setBool(property, checked);
//						refreshList();
					}
				});
			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
			if (icon != null) {
				if (iconId != 0 && showIcons) {
					icon.setVisibility(View.VISIBLE);
					icon.setImageResource(iconId);
				} else {
					icon.setImageResource(0);
					icon.setVisibility(View.INVISIBLE);
				}
			}
//			view.setClickable(true);
//			view.setFocusable(true);
			return view;
		}
	}

	static public void saveColor( Properties mProperties, boolean night )
	{
		if ( night ) {
			mProperties.setProperty(PROP_PAGE_BACKGROUND_IMAGE_NIGHT, mProperties.getProperty(PROP_PAGE_BACKGROUND_IMAGE, ""(NONE)""));
			mProperties.setColor(PROP_BACKGROUND_COLOR_NIGHT, mProperties.getColor(PROP_BACKGROUND_COLOR, 0x000000));
			mProperties.setColor(PROP_FONT_COLOR_NIGHT, mProperties.getColor(PROP_FONT_COLOR, 0xFFFFFF));
			mProperties.setColor(PROP_STATUS_FONT_COLOR_NIGHT, mProperties.getColor(PROP_STATUS_FONT_COLOR, 0xFFFFFF));
			mProperties.setInt(PROP_APP_SCREEN_BACKLIGHT_NIGHT, mProperties.getInt(PROP_APP_SCREEN_BACKLIGHT, -1));
			mProperties.setProperty(PROP_FONT_GAMMA_NIGHT, mProperties.getProperty(PROP_FONT_GAMMA, ""1.0""));
			mProperties.setProperty(PROP_APP_THEME_NIGHT, mProperties.getProperty(PROP_APP_THEME, ""BLACK""));
		} else {
			mProperties.setProperty(PROP_PAGE_BACKGROUND_IMAGE_DAY, mProperties.getProperty(PROP_PAGE_BACKGROUND_IMAGE, ""(NONE)""));
			mProperties.setColor(PROP_BACKGROUND_COLOR_DAY, mProperties.getColor(PROP_BACKGROUND_COLOR, 0xFFFFFF));
			mProperties.setColor(PROP_FONT_COLOR_DAY, mProperties.getColor(PROP_FONT_COLOR, 0x000000));
			mProperties.setColor(PROP_STATUS_FONT_COLOR_DAY, mProperties.getColor(PROP_STATUS_FONT_COLOR, 0x000000));
			mProperties.setInt(PROP_APP_SCREEN_BACKLIGHT_DAY, mProperties.getInt(PROP_APP_SCREEN_BACKLIGHT, -1));
			mProperties.setProperty(PROP_FONT_GAMMA_DAY, mProperties.getProperty(PROP_FONT_GAMMA, ""1.0""));
			mProperties.setProperty(PROP_APP_THEME_DAY, mProperties.getProperty(PROP_APP_THEME, ""WHITE""));
		}
		for (String code : styleCodes) {
			String styleName = ""styles."" + code + "".color"";
			String v = mProperties.getProperty(styleName); 
			if (v != null) {
				if ( night )
					mProperties.setProperty(styleName + "".night"", v);
				else
					mProperties.setProperty(styleName + "".day"", v);
			}
		}
	}

	static public void restoreColor( Properties mProperties,  boolean night )
	{
		if ( night ) {
			mProperties.setProperty(PROP_PAGE_BACKGROUND_IMAGE, mProperties.getProperty(PROP_PAGE_BACKGROUND_IMAGE_NIGHT, ""(NONE)""));
			mProperties.setColor(PROP_BACKGROUND_COLOR, mProperties.getColor(PROP_BACKGROUND_COLOR_NIGHT, 0x000000));
			mProperties.setColor(PROP_FONT_COLOR, mProperties.getColor(PROP_FONT_COLOR_NIGHT, 0xFFFFFF));
			mProperties.setColor(PROP_STATUS_FONT_COLOR, mProperties.getColor(PROP_STATUS_FONT_COLOR_NIGHT, 0xFFFFFF));
			mProperties.setInt(PROP_APP_SCREEN_BACKLIGHT, mProperties.getInt(PROP_APP_SCREEN_BACKLIGHT_NIGHT, 70));
			mProperties.setProperty(PROP_FONT_GAMMA, mProperties.getProperty(PROP_FONT_GAMMA_NIGHT, ""1.0""));
			mProperties.setProperty(PROP_APP_THEME, mProperties.getProperty(PROP_APP_THEME_NIGHT, ""BLACK""));
		} else {
			mProperties.setProperty(PROP_PAGE_BACKGROUND_IMAGE, mProperties.getProperty(PROP_PAGE_BACKGROUND_IMAGE_DAY, ""(NONE)""));
			mProperties.setColor(PROP_BACKGROUND_COLOR, mProperties.getColor(PROP_BACKGROUND_COLOR_DAY, 0xFFFFFF));
			mProperties.setColor(PROP_FONT_COLOR, mProperties.getColor(PROP_FONT_COLOR_DAY, 0x000000));
			mProperties.setColor(PROP_STATUS_FONT_COLOR, mProperties.getColor(PROP_STATUS_FONT_COLOR_DAY, 0x000000));
			mProperties.setInt(PROP_APP_SCREEN_BACKLIGHT, mProperties.getInt(PROP_APP_SCREEN_BACKLIGHT_DAY, 80));
			mProperties.setProperty(PROP_FONT_GAMMA, mProperties.getProperty(PROP_FONT_GAMMA_DAY, ""1.0""));
			mProperties.setProperty(PROP_APP_THEME, mProperties.getProperty(PROP_APP_THEME_DAY, ""WHITE""));
		}
		for (String code : styleCodes) {
			String styleName = ""styles."" + code + "".color"";
			String pname = night ? styleName + "".night"" : styleName + "".day"";
			String v = mProperties.getProperty(pname);
			if (v != null)
				mProperties.setProperty(styleName, mProperties.getProperty(pname));
		}
	}

	static public void toggleDayNightMode( Properties mProperties ) {
		boolean oldMode = mProperties.getBool(PROP_NIGHT_MODE, false);
		saveColor(mProperties, oldMode);
		boolean newMode = !oldMode;
		restoreColor(mProperties, newMode);
		mProperties.setBool(PROP_NIGHT_MODE, newMode);
	}

	class NightModeOption extends BoolOption {
		public NightModeOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		public void onSelect() { 
			toggleDayNightMode(mProperties);
			refreshList();
		}
	}
	
	class ActionOption extends ListOption {
		public ActionOption( OptionOwner owner, String label, String property, boolean isTap, boolean allowRepeat ) {
			super(owner, label, property);
			ReaderAction[] actions = ReaderAction.AVAILABLE_ACTIONS;
			for ( ReaderAction a : actions )
				if ( !isTap || a.mayAssignOnTap() )
					add(a.id, getString(a.nameId));
			if ( allowRepeat )
				add(ReaderAction.REPEAT.id, getString(ReaderAction.REPEAT.nameId));
			if ( mProperties.getProperty(property)==null )
				mProperties.setProperty(property, ReaderAction.NONE.id);
		}
	}

	class KeyMapOption extends SubmenuOption {
		public KeyMapOption( OptionOwner owner, String label ) {
			super(owner, label, PROP_APP_KEY_ACTIONS_PRESS);
		}
		private void addKey( OptionsListView list, int keyCode, String keyName ) {
			final String propName = ReaderAction.getKeyProp(keyCode, ReaderAction.NORMAL);
			final String longPropName = ReaderAction.getKeyProp(keyCode, ReaderAction.LONG);
			final String dblPropName = ReaderAction.getKeyProp(keyCode, ReaderAction.DOUBLE);
			list.add(new ActionOption(mOwner, keyName, propName, false, false));
			list.add(new ActionOption(mOwner, keyName + "" "" + getContext().getString(R.string.options_app_key_long_press), longPropName, false, true));
			list.add(new ActionOption(mOwner, keyName + "" "" + getContext().getString(R.string.options_app_key_double_press), dblPropName, false, false));
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, label, false, false);
			OptionsListView listView = new OptionsListView(getContext());
			if ( DeviceInfo.NOOK_NAVIGATION_KEYS ) {
				addKey(listView, ReaderView.KEYCODE_PAGE_TOPLEFT, ""Top left navigation button"");
				addKey(listView, ReaderView.KEYCODE_PAGE_BOTTOMLEFT, ""Bottom left navigation button"");
				addKey(listView, ReaderView.KEYCODE_PAGE_TOPRIGHT, ""Top right navigation button"");
				addKey(listView, ReaderView.NOOK_12_KEY_NEXT_LEFT, ""Bottom right navigation button"");
//				addKey(listView, ReaderView.KEYCODE_PAGE_BOTTOMRIGHT, ""Bottom right navigation button"");
			} else if ( DeviceInfo.SONY_NAVIGATION_KEYS ) {
//				addKey(listView, KeyEvent.KEYCODE_DPAD_UP, ""Prev button"");
//				addKey(listView, KeyEvent.KEYCODE_DPAD_DOWN, ""Next button"");
				addKey(listView, ReaderView.SONY_DPAD_UP_SCANCODE, ""Prev button"");
				addKey(listView, ReaderView.SONY_DPAD_DOWN_SCANCODE, ""Next button"");
			} else {
				addKey(listView, KeyEvent.KEYCODE_MENU, ""Menu"");
				addKey(listView, KeyEvent.KEYCODE_DPAD_LEFT, ""Left"");
				addKey(listView, KeyEvent.KEYCODE_DPAD_RIGHT, ""Right"");
				addKey(listView, KeyEvent.KEYCODE_DPAD_UP, ""Up"");
				addKey(listView, KeyEvent.KEYCODE_DPAD_DOWN, ""Down"");
				addKey(listView, KeyEvent.KEYCODE_DPAD_CENTER, ""Center"");
				addKey(listView, KeyEvent.KEYCODE_BACK, ""Back"");
				addKey(listView, KeyEvent.KEYCODE_SEARCH, ""Search"");
				addKey(listView, KeyEvent.KEYCODE_VOLUME_UP, ""Volume Up"");
				addKey(listView, KeyEvent.KEYCODE_VOLUME_DOWN, ""Volume Down"");
				addKey(listView, KeyEvent.KEYCODE_CAMERA, ""Camera"");
				addKey(listView, KeyEvent.KEYCODE_HEADSETHOOK, ""Headset Hook"");
			}

			dlg.setView(listView);
			dlg.show();
		}

		public String getValueLabel() { return "">""; }
	}
	
	class StatusBarOption extends SubmenuOption {
		public StatusBarOption( OptionOwner owner, String label ) {
			super(owner, label, PROP_SHOW_TITLE);
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, label, false, false);
			OptionsListView listView = new OptionsListView(getContext());
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar), PROP_STATUS_LINE).setInverse().setDefaultValue(""0""));
			listView.add(new ListOption(mOwner, getString(R.string.options_page_titlebar_font_face), PROP_STATUS_FONT_FACE).add(mFontFaces).setDefaultValue(mFontFaces[0]).setIconId(R.drawable.cr3_option_font_face));
			listView.add(new ListOption(mOwner, getString(R.string.options_page_titlebar_font_size), PROP_STATUS_FONT_SIZE).add(mStatusFontSizes).setDefaultValue(""18"").setIconId(R.drawable.cr3_option_font_size));
			listView.add(new ColorOption(mOwner, getString(R.string.options_page_titlebar_font_color), PROP_STATUS_FONT_COLOR, 0x000000));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_title), PROP_SHOW_TITLE).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_page_number), PROP_SHOW_PAGE_NUMBER).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_page_count), PROP_SHOW_PAGE_COUNT).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_percent), PROP_SHOW_POS_PERCENT).setDefaultValue(""0""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_chapter_marks), PROP_STATUS_CHAPTER_MARKS).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_battery_percent), PROP_SHOW_BATTERY_PERCENT).setDefaultValue(""1""));
			dlg.setView(listView);
			dlg.show();
		}

		public String getValueLabel() { return "">""; }
	}
	
	class ImageScalingOption extends SubmenuOption {
		public ImageScalingOption( OptionOwner owner, String label ) {
			super(owner, label, PROP_IMG_SCALING_ZOOMIN_BLOCK_MODE);
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, label, false, false);
			OptionsListView listView = new OptionsListView(getContext());
			listView.add(new ListOption(mOwner, getString(R.string.options_format_image_scaling_block_mode), PROP_IMG_SCALING_ZOOMIN_BLOCK_MODE).add(mImageScalingModes, mImageScalingModesTitles).setDefaultValue(""2""));
			listView.add(new ListOption(mOwner, getString(R.string.options_format_image_scaling_block_scale), PROP_IMG_SCALING_ZOOMIN_BLOCK_SCALE).add(mImageScalingFactors, mImageScalingFactorsTitles).setDefaultValue(""2""));
			listView.add(new ListOption(mOwner, getString(R.string.options_format_image_scaling_inline_mode), PROP_IMG_SCALING_ZOOMIN_INLINE_MODE).add(mImageScalingModes, mImageScalingModesTitles).setDefaultValue(""2""));
			listView.add(new ListOption(mOwner, getString(R.string.options_format_image_scaling_inline_scale), PROP_IMG_SCALING_ZOOMIN_INLINE_SCALE).add(mImageScalingFactors, mImageScalingFactorsTitles).setDefaultValue(""2""));
			dlg.setView(listView);
			dlg.show();
		}

		private void copyProperty( String to, String from ) {
			mProperties.put(to, mProperties.get(from));
		}

		protected void closed() {
			copyProperty(PROP_IMG_SCALING_ZOOMOUT_BLOCK_MODE, PROP_IMG_SCALING_ZOOMIN_BLOCK_MODE);
			copyProperty(PROP_IMG_SCALING_ZOOMOUT_INLINE_MODE, PROP_IMG_SCALING_ZOOMIN_INLINE_MODE);
			copyProperty(PROP_IMG_SCALING_ZOOMOUT_BLOCK_SCALE, PROP_IMG_SCALING_ZOOMIN_BLOCK_SCALE);
			copyProperty(PROP_IMG_SCALING_ZOOMOUT_INLINE_SCALE, PROP_IMG_SCALING_ZOOMIN_INLINE_SCALE);
		}
		
		public String getValueLabel() { return "">""; }
	}
	
	class TapZoneOption extends SubmenuOption {
		public TapZoneOption( OptionOwner owner, String label, String property ) {
			super( owner, label, property);
		}
		View grid;
		private void initTapZone( View view, final int tapZoneId )
		{
			if ( view==null )
				return;
			final TextView text = (TextView)view.findViewById(R.id.tap_zone_action_text_short);
			final TextView longtext = (TextView)view.findViewById(R.id.tap_zone_action_text_long);
			final String propName = property + ""."" + tapZoneId;
			final String longPropName = property + "".long."" + tapZoneId;
			ReaderAction action = ReaderAction.findById( mProperties.getProperty(propName) );
			ReaderAction longAction = ReaderAction.findById( mProperties.getProperty(longPropName) );
			text.setText(getString(action.nameId));
			longtext.setText(getString(longAction.nameId));
			view.setLongClickable(true);
			view.setOnClickListener(new View.OnClickListener () {
				@Override
				public void onClick(View v) {
					// TODO: i18n
					ActionOption option = new ActionOption(mOwner, getString(R.string.options_app_tap_action_short), propName, true, false);
					option.setOnChangeHandler(new Runnable() {
						public void run() {
							ReaderAction action = ReaderAction.findById( mProperties.getProperty(propName) );
							text.setText(getString(action.nameId));
						}
					});
					option.onSelect();
				}
			});
			view.setOnLongClickListener(new View.OnLongClickListener () {
				@Override
				public boolean onLongClick(View v) {
					// TODO: i18n
					ActionOption option = new ActionOption(mOwner, getString(R.string.options_app_tap_action_long), longPropName, true, true);
					option.setOnChangeHandler(new Runnable() {
						public void run() {
							ReaderAction longAction = ReaderAction.findById( mProperties.getProperty(longPropName) );
							longtext.setText(getString(longAction.nameId));
						}
					});
					option.onSelect();
					return true;
				}
			});
		}

		public String getValueLabel() { return "">""; }
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, label, false, false);
			grid = (View)mInflater.inflate(R.layout.options_tap_zone_grid, null);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell1), 1);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell2), 2);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell3), 3);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell4), 4);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell5), 5);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell6), 6);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell7), 7);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell8), 8);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell9), 9);
			dlg.setView(grid);
			dlg.show();
		}
	}
	
	public static class Pair {
		public String value;
		public String label;
		public Pair(String value, String label) {
			this.value = value;
			this.label = label;
		}
	}

	public static class SubmenuOption extends ListOption {
		public SubmenuOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		public int getItemViewType() {
			return OPTION_VIEW_TYPE_SUBMENU; 
		}
		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item_submenu, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			labelView.setText(label);
			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
			if (icon != null) {
				if (iconId != 0 && showIcons) {
					icon.setVisibility(View.VISIBLE);
					icon.setImageResource(iconId);
				} else {
					icon.setImageResource(0);
					icon.setVisibility(View.INVISIBLE);
				}
			}
			return view;
		}
	}
	
	public static class ListOption extends OptionBase {
		private ArrayList<Pair> list = new ArrayList<Pair>();
		public ListOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		public void add(String value, String label) {
			list.add( new Pair(value, label) );
		}
		public ListOption add(String[]values) {
			for ( String item : values ) {
				add(item, item);
			}
			return this;
		}
		public ListOption add(double[]values) {
			for ( double item : values ) {
				String s = String.valueOf(item); 
				add(s, s);
			}
			return this;
		}
		public ListOption add(int[]values) {
			for ( int item : values ) {
				String s = String.valueOf(item); 
				add(s, s);
			}
			return this;
		}
		public ListOption add(int[]values, int[]labelIDs) {
			for ( int i=0; i<values.length; i++ ) {
				String value = String.valueOf(values[i]); 
				String label = mActivity.getString(labelIDs[i]); 
				add(value, label);
			}
			return this;
		}
		public ListOption add(String[]values, int[]labelIDs) {
			for ( int i=0; i<values.length; i++ ) {
				String value = values[i]; 
				String label = mActivity.getString(labelIDs[i]); 
				add(value, label);
			}
			return this;
		}
		public ListOption add(String[]values, String[]labels) {
			for ( int i=0; i<values.length; i++ ) {
				String value = values[i]; 
				String label = labels[i]; 
				add(value, label);
			}
			return this;
		}
		public ListOption add(int[]values, String[]labels) {
			for ( int i=0; i<values.length; i++ ) {
				String value = String.valueOf(values[i]); 
				String label = labels[i]; 
				add(value, label);
			}
			return this;
		}
		public ListOption addPercents(int[]values) {
			for ( int item : values ) {
				String s = String.valueOf(item); 
				add(s, s + ""%"");
			}
			return this;
		}
		public String findValueLabel( String value ) {
			for ( Pair pair : list ) {
				if ( value!=null && pair.value.equals(value) )
					return pair.label;
			}
			return null;
		}
		public int findValue( String value ) {
			if ( value==null )
				return -1;
			for ( int i=0; i<list.size(); i++ ) {
				if ( value.equals(list.get(i).value) )
					return i;
			}
			return -1;
		}
		
		public int getSelectedItemIndex() {
			return findValue(mProperties.getProperty(property));
		}

		protected void closed() {
			
		}
		
		protected int getItemLayoutId() {
			return R.layout.option_value; 
		}
		
		protected void updateItemContents( final View layout, final Pair item, final ListView listView, final int position ) {
			TextView view;
			RadioButton cb;
			view = (TextView)layout.findViewById(R.id.option_value_text);
			cb = (RadioButton)layout.findViewById(R.id.option_value_check);
			view.setText(item.label);
			String currValue = mProperties.getProperty(property);
			boolean isSelected = item.value!=null && currValue!=null && item.value.equals(currValue) ;//getSelectedItemIndex()==position;
			cb.setChecked(isSelected);
			cb.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					listView.getOnItemClickListener().onItemClick(listView, listView, position, 0);
//					mProperties.setProperty(property, item.value);
//					dismiss();
//					optionsListView.refresh();
				}
			});
		}
		
		public String getValueLabel() { return findValueLabel(mProperties.getProperty(property)); }
		
		public void onSelect() {
			final BaseDialog dlg = new BaseDialog(mActivity, label, false, false);

			final ListView listView = new ListView(mActivity);
			
			
			ListAdapter listAdapter = new ListAdapter() {

				public boolean areAllItemsEnabled() {
					return true;
				}

				public boolean isEnabled(int position) {
					return true;
				}

				public int getCount() {
					return list.size();
				}

				public Object getItem(int position) {
					return list.get(position);
				}

				public long getItemId(int position) {
					return position;
				}

				public int getItemViewType(int position) {
					return 0;
				}

				public View getView(final int position, View convertView,
						ViewGroup parent) {
					ViewGroup layout;
					if ( convertView==null ) {
						layout = (ViewGroup)mInflater.inflate(getItemLayoutId(), null);
						//view = new TextView(getContext());
					} else {
						layout = (ViewGroup)convertView;
					}
					final Pair item = list.get(position);
					updateItemContents( layout, item, listView, position );
					//cb.setClickable(false);
//					cb.setOnClickListener(new View.OnClickListener() {
//						@Override
//						public void onClick(View v) {
//							
//						}
//					});
					return layout;
				}

				public int getViewTypeCount() {
					return 1;
				}

				public boolean hasStableIds() {
					return true;
				}

				public boolean isEmpty() {
					return list.size()==0;
				}

				private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
				
				public void registerDataSetObserver(DataSetObserver observer) {
					observers.add(observer);
				}

				public void unregisterDataSetObserver(DataSetObserver observer) {
					observers.remove(observer);
				}
				
			};
			int selItem = getSelectedItemIndex();
			if ( selItem<0 )
				selItem = 0;
			listView.setAdapter(listAdapter);
			listView.setSelection(selItem);
			dlg.setView(listView);
			//final AlertDialog d = dlg.create();
			listView.setOnItemClickListener(new OnItemClickListener() {

				public void onItemClick(AdapterView<?> adapter, View listview,
						int position, long id) {
					Pair item = list.get(position);
					onClick(item);
					dlg.dismiss();
					closed();
				}
			});
			dlg.show();
		}
		
		public void onClick( Pair item ) {
			mProperties.setProperty(property, item.value);
			refreshList();
			if ( onChangeHandler!=null )
				onChangeHandler.run();
			if ( optionsListView!=null )
				optionsListView.refresh();
		}
	}
	
	class DictOptions extends ListOption
	{
		public DictOptions( OptionOwner owner, String label )
		{
			super( owner, label, PROP_APP_DICTIONARY );
			CoolReader.DictInfo[] dicts = mActivity.getDictList();
			setDefaultValue(dicts[0].id);
			for ( CoolReader.DictInfo dict : dicts )
				add( dict.id, dict.name );
		}
	} 
	
	class HyphenationOptions extends ListOption
	{
		public HyphenationOptions( OptionOwner owner, String label )
		{
			super( owner, label, PROP_HYPHENATION_DICT );
			setDefaultValue(""RUSSIAN"");
			Engine.HyphDict[] dicts = Engine.HyphDict.values();
			for ( Engine.HyphDict dict : dicts )
				add( dict.toString(), dict.name );
		}
	}
	
	class ThemeOptions extends ListOption
	{
		public ThemeOptions( OptionOwner owner, String label )
		{
			super( owner, label, PROP_APP_THEME );
			setDefaultValue(DeviceInfo.EINK_SCREEN ? ""WHITE"" : ""LIGHT"");
			for (InterfaceTheme theme : InterfaceTheme.allThemes)
				add(theme.getCode(), getString(theme.getDisplayNameResourceId()));
		}
	}
	
	class ThumbnailCache {
		final int maxcount;
		final int dx;
		final int dy;
		class Item {
			Drawable drawable;
			Bitmap bmp;
			String path;
			int id;
			public void clear() {
				if ( bmp!=null ) {
					//bmp.recycle();
					bmp = null;
				}
				if ( drawable!=null )
					drawable = null;
			}
		}
		ArrayList<Item> list = new ArrayList<Item>(); 
		public ThumbnailCache( int dx, int dy, int maxcount ) {
			this.dx = dx;
			this.dy = dy;
			this.maxcount = maxcount;
		}
		private void remove( int maxsize ) {
			while ( list.size()>maxsize ) {
				Item item = list.remove(0);
				item.clear();
			}
		}
		private Drawable createDrawable( String path ) {
			File f = new File(path);
			if ( !f.isFile() || !f.exists() )
				return null;
			try { 
				BitmapDrawable drawable = (BitmapDrawable)BitmapDrawable.createFromPath(path);
				if ( drawable==null )
					return null;
				Bitmap src = drawable.getBitmap();
				Bitmap bmp = Bitmap.createScaledBitmap(src, dx, dy, true);
				//Canvas canvas = new Canvas(bmp);
				BitmapDrawable res = new BitmapDrawable(bmp);
				//src.recycle();
				Item item = new Item();
				item.path = path;
				item.drawable = res; //drawable;
				item.bmp = bmp;
				list.add(item);
				remove(maxcount);
				return drawable;
			} catch ( Exception e ) {
				return null;
			}
		}
		private Drawable createDrawable( int resourceId ) {
			try { 
				//Drawable drawable = mReaderView.getActivity().getResources().getDrawable(resourceId);
				InputStream is = getContext().getResources().openRawResource(resourceId);
				if ( is==null )
					return null;
				BitmapDrawable src = new BitmapDrawable(is);
				Item item = new Item();
				item.id = resourceId;
				Bitmap bmp = Bitmap.createScaledBitmap(src.getBitmap(), dx, dy, true);
				BitmapDrawable res = new BitmapDrawable(bmp);
				item.drawable = res;
				item.bmp = bmp;
				list.add(item);
				remove(maxcount);
				return res;
			} catch ( Exception e ) {
				return null;
			}
		}
		public Drawable getImage( String path ) {
			if ( path==null || !path.startsWith(""/""))
				return null;
			// find existing
			for ( int i=0; i<list.size(); i++ ) {
				if ( list.get(i).path!=null && path.equals(list.get(i).path) ) {
					Item item = list.remove(i);
					list.add(item);
					return item.drawable;
				}
			}
			return createDrawable( path ); 
		}
		public Drawable getImage( int resourceId ) {
			if ( resourceId==0 )
				return null;
			// find existing
			for ( int i=0; i<list.size(); i++ ) {
				if ( list.get(i).id == resourceId ) {
					Item item = list.remove(i);
					list.add(item);
					return item.drawable;
				}
			}
			return createDrawable( resourceId ); 
		}
		public void clear() {
			remove(0);
		}
	}
	
	ThumbnailCache textureSampleCache = new ThumbnailCache(64, 64, 100);
	
	class TextureOptions extends ListOption
	{
		public TextureOptions( OptionOwner owner, String label )
		{
			super( owner, label, PROP_PAGE_BACKGROUND_IMAGE );
			setDefaultValue(""(NONE)"");
			BackgroundTextureInfo[] textures = mReaderView.getEngine().getAvailableTextures();
			for ( BackgroundTextureInfo item : textures )
				add( item.id, item.name );
		}

		protected void closed() {
			textureSampleCache.clear();
		}

		protected int getItemLayoutId() {
			return R.layout.option_value_image; 
		}
		
		protected void updateItemContents( final View layout, final Pair item, final ListView listView, final int position ) {
			super.updateItemContents(layout, item, listView, position);
			ImageView img = (ImageView)layout.findViewById(R.id.option_value_image);
			int cl = mProperties.getColor(PROP_BACKGROUND_COLOR, Color.WHITE);
			BackgroundTextureInfo texture = mReaderView.getEngine().getTextureInfoById(item.value);
			img.setBackgroundColor(cl);
			if ( texture.resourceId!=0 ) {
//				img.setImageDrawable(null);
//				img.setImageResource(texture.resourceId);
//				img.setBackgroundColor(Color.TRANSPARENT);
				Drawable drawable = textureSampleCache.getImage(texture.resourceId);
				if ( drawable!=null ) {
					img.setImageResource(0);
					img.setImageDrawable(drawable);
					img.setBackgroundColor(Color.TRANSPARENT);
				} else {
					img.setBackgroundColor(cl);
					img.setImageResource(0);
					img.setImageDrawable(null);
				}
			} else {
				// load image from file
				Drawable drawable = textureSampleCache.getImage(texture.id);
				if ( drawable!=null ) {
					img.setImageResource(0);
					img.setImageDrawable(drawable);
					img.setBackgroundColor(Color.TRANSPARENT);
				} else {
					img.setBackgroundColor(cl);
					img.setImageResource(0);
					img.setImageDrawable(null);
				}
			}
		}
	}
	
	//byte[] fakeLongArrayForDebug;
	
	public OptionsDialog( CoolReader activity, ReaderView readerView, String[] fontFaces )
	{
		super(activity, null, false, false);
		
		mActivity = activity;
		mReaderView = readerView;
		mFontFaces = fontFaces;
		mProperties = readerView.getSettings();
		showIcons = mProperties.getBool(PROP_APP_SETTINGS_SHOW_ICONS, true);

		//fakeLongArrayForDebug = new byte[2000000]; // 2M
		//CoolReader.dumpHeapAllocation();
	}
	
	class OptionsListView extends ListView {
		private ArrayList<OptionBase> mOptions = new ArrayList<OptionBase>();
		private ListAdapter mAdapter;
		public void refresh()
		{
			//setAdapter(mAdapter);
			for ( OptionBase item : mOptions ) {
				item.refreshItem();
			}
			invalidate();
		}
		public OptionsListView add( OptionBase option ) {
			mOptions.add(option);
			option.optionsListView = this;
			return this;
		}
		public OptionsListView( Context context )
		{
			super(context);
			setFocusable(true);
			setFocusableInTouchMode(true);
			mAdapter = new ListAdapter() {
				public boolean areAllItemsEnabled() {
					return false;
				}

				public boolean isEnabled(int position) {
					boolean isPageMode = mProperties.getBool(PROP_PAGE_VIEW_MODE, true);
					OptionBase option = mOptions.get(position);
					String prop = option.property;
					if ( prop.equals(PROP_STATUS_LINE) || prop.equals(PROP_FOOTNOTES) )
						return isPageMode;
					return true;
				}

				public int getCount() {
					return mOptions.size();
				}

				public Object getItem(int position) {
					return mOptions.get(position);
				}

				public long getItemId(int position) {
					return position;
				}

				public int getItemViewType(int position) {
//					OptionBase item = mOptions.get(position);
//					return item.getItemViewType();
					return position;
				}

				
				public View getView(int position, View convertView, ViewGroup parent) {
					OptionBase item = mOptions.get(position);
					return item.getView(convertView, parent);
				}

				public int getViewTypeCount() {
					//return OPTION_VIEW_TYPE_COUNT;
					return mOptions.size() > 0 ? mOptions.size() : 1;
				}

				public boolean hasStableIds() {
					return true;
				}

				public boolean isEmpty() {
					return mOptions.size()==0;
				}

				private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
				
				public void registerDataSetObserver(DataSetObserver observer) {
					observers.add(observer);
				}

				public void unregisterDataSetObserver(DataSetObserver observer) {
					observers.remove(observer);
				}
			};
			setAdapter(mAdapter);
		}
		@Override
		public boolean performItemClick(View view, int position, long id) {
			mOptions.get(position).onSelect();
			return true;
		}
		
	}
	
	public View createTabContent(String tag) {
		if ( ""App"".equals(tag) )
			return mOptionsApplication;
		else if ( ""Styles"".equals(tag) )
			return mOptionsStyles;
		else if ( ""CSS"".equals(tag) )
			return mOptionsCSS;
		else if ( ""Controls"".equals(tag) )
			return mOptionsControls;
		else if ( ""Page"".equals(tag))
			return mOptionsPage;
		return null;
	}

	private String getString( int resourceId )
	{
		return getContext().getResources().getString(resourceId); 
	}

	class StyleEditorOption extends SubmenuOption {
		
		private final String prefix;
		
		public StyleEditorOption( OptionOwner owner, String label, String prefix ) {
			super(owner, label, ""dummy.prop"");
			this.prefix = prefix;
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, label, false, false);
			OptionsListView listView = new OptionsListView(getContext());
			String[] firstLineOptions = {"""", ""text-align: justify"", ""text-align: left"", ""text-align: center"", ""text-align: right"", };
			int[] firstLineOptionNames = {
					R.string.options_css_inherited,
					R.string.options_css_text_align_justify,
					R.string.options_css_text_align_left,
					R.string.options_css_text_align_center,
					R.string.options_css_text_align_right,
			};
			listView.add(new ListOption(mOwner, getString(R.string.options_css_text_align), prefix + "".align"").add(firstLineOptions, firstLineOptionNames).setIconId(R.drawable.cr3_option_text_align));
			
			String[] identOptions = {"""", // inherited
			        ""text-indent: 0em"",
			        ""text-indent: 1.2em"",
			        ""text-indent: 2em"",
			        ""text-indent: -1.2em"",
			        ""text-indent: -2em""};
			int[] identOptionNames = {
					R.string.options_css_inherited,
					R.string.options_css_text_indent_no_indent,
					R.string.options_css_text_indent_small_indent,
					R.string.options_css_text_indent_big_indent,
					R.string.options_css_text_indent_small_outdent,
					R.string.options_css_text_indent_big_outdent};
			listView.add(new ListOption(mOwner, getString(R.string.options_css_text_indent), prefix + "".text-indent"").add(identOptions, identOptionNames).setIconId(R.drawable.cr3_option_text_indent));

			ArrayList<String> faces = new ArrayList<String>(); 
			ArrayList<String> faceValues = new ArrayList<String>(); 
		    faces.add(""-"");
		    faceValues.add("""");
		    faces.add(getString(R.string.options_css_font_face_sans_serif));
		    faceValues.add(""font-family: sans-serif"");
		    faces.add(getString(R.string.options_css_font_face_serif));
		    faceValues.add(""font-family: serif"");
		    faces.add(getString(R.string.options_css_font_face_monospace));
		    faceValues.add(""font-family: \""Courier New\"", \""Courier\"", monospace"");
		    for (String face : mFontFaces) {
			    faces.add(face);
			    faceValues.add(""font-family: "" + face);
		    }
			listView.add(new ListOption(mOwner, getString(R.string.options_css_font_face), prefix + "".font-face"").add(faceValues.toArray(new String[]{}), faces.toArray(new String[]{})).setIconId(R.drawable.cr3_option_font_face));
			
		    String[] fontSizeStyles = {
		        """", // inherited
		        ""font-size: 110%"",
		        ""font-size: 120%"",
		        ""font-size: 150%"",
		        ""font-size: 90%"",
		        ""font-size: 80%"",
		        ""font-size: 70%"",
		        ""font-size: 60%"",
		    };
		    int[] fontSizeStyleNames = {
			    R.string.options_css_inherited,
			    R.string.options_css_font_size_110p,
			    R.string.options_css_font_size_120p,
			    R.string.options_css_font_size_150p,
			    R.string.options_css_font_size_90p,
			    R.string.options_css_font_size_80p,
			    R.string.options_css_font_size_70p,
			    R.string.options_css_font_size_60p,
		    };
			listView.add(new ListOption(mOwner, getString(R.string.options_css_font_size), prefix + "".font-size"").add(fontSizeStyles, fontSizeStyleNames).setIconId(R.drawable.cr3_option_font_size));

		    String[] fontWeightStyles = {
		        """", // inherited
		        ""font-weight: normal"",
		        ""font-weight: bold"",
		        ""font-weight: bolder"",
		        ""font-weight: lighter"",
		    };
		    int[] fontWeightStyleNames = {
		        R.string.options_css_inherited,
		        R.string.options_css_font_weight_normal,
		        R.string.options_css_font_weight_bold,
		        R.string.options_css_font_weight_bolder,
		        R.string.options_css_font_weight_lighter,
		    };
			listView.add(new ListOption(mOwner, getString(R.string.options_css_font_weight), prefix + "".font-weight"").add(fontWeightStyles, fontWeightStyleNames).setIconId(R.drawable.cr3_option_text_bold));

		    String[] fontStyleStyles = {
		        """", // inherited
		        ""font-style: normal"",
		        ""font-style: italic"",
		    };
		    int[] fontStyleStyleNames = {
		    	R.string.options_css_inherited,
		    	R.string.options_css_font_style_normal,
		    	R.string.options_css_font_style_italic,
		    };
			listView.add(new ListOption(mOwner, getString(R.string.options_css_font_style), prefix + "".font-style"").add(fontStyleStyles, fontStyleStyleNames).setIconId(R.drawable.cr3_option_text_italic));

		    String[] lineHeightStyles = {
			        """", // inherited
			        ""line-height: 75%"",
			        ""line-height: 80%"",
			        ""line-height: 85%"",
			        ""line-height: 90%"",
			        ""line-height: 95%"",
			        ""line-height: 100%"",
			        ""line-height: 110%"",
			        ""line-height: 120%"",
			        ""line-height: 130%"",
			        ""line-height: 140%"",
			        ""line-height: 150%"",
			    };
		    String[] lineHeightStyleNames = {
			        ""-"",
			        ""75%"",
			        ""80%"",
			        ""85%"",
			        ""90%"",
			        ""95%"",
			        ""100%"",
			        ""110%"",
			        ""120%"",
			        ""130%"",
			        ""140%"",
			        ""150%"",
			    };
			listView.add(new ListOption(mOwner, getString(R.string.options_css_interline_space), prefix + "".line-height"").add(lineHeightStyles, lineHeightStyleNames).setIconId(R.drawable.cr3_option_line_spacing));

		    String[] textDecorationStyles = {
		    		"""", // inherited
		            ""text-decoration: none"",
		            ""text-decoration: underline"",
		            ""text-decoration: line-through"",
		            ""text-decoration: overline"",
			    };
		    int[] textDecorationStyleNames = {
			    	R.string.options_css_inherited,
			    	R.string.options_css_text_decoration_none,
			    	R.string.options_css_text_decoration_underline,
			    	R.string.options_css_text_decoration_line_through,
			    	R.string.options_css_text_decoration_overlineline,
			    };
			listView.add(new ListOption(mOwner, getString(R.string.options_css_font_decoration), prefix + "".text-decoration"").add(textDecorationStyles, textDecorationStyleNames).setIconId(R.drawable.cr3_option_text_underline));

		    String[] verticalAlignStyles = {
		    		"""", // inherited
		            ""vertical-align: baseline"",
		            ""vertical-align: sub"",
		            ""vertical-align: super"",
			    };
		    int[] verticalAlignStyleNames = {
			    	R.string.options_css_inherited,
			    	R.string.options_css_text_valign_baseline,
			    	R.string.options_css_text_valign_subscript,
			    	R.string.options_css_text_valign_superscript,
			    };
			listView.add(new ListOption(mOwner, getString(R.string.options_css_text_valign), prefix + "".vertical-align"").add(verticalAlignStyles, verticalAlignStyleNames).setIconId(R.drawable.cr3_option_text_superscript));

		    String[] fontColorStyles = {
		        """", // inherited
		        ""color: black"",
		        ""color: green"",
		        ""color: silver"",
		        ""color: lime"",
		        ""color: gray"",
		        ""color: olive"",
		        ""color: white"",
		        ""color: yellow"",
		        ""color: maroon"",
		        ""color: navy"",
		        ""color: red"",
		        ""color: blue"",
		        ""color: purple"",
		        ""color: teal"",
		        ""color: fuchsia"",
		        ""color: aqua"",
		    };
		    String[] fontColorStyleNames = {
		        ""-"",
		        ""Black"",
		        ""Green"",
		        ""Silver"",
		        ""Lime"",
		        ""Gray"",
		        ""Olive"",
		        ""White"",
		        ""Yellow"",
		        ""Maroon"",
		        ""Navy"",
		        ""Red"",
		        ""Blue"",
		        ""Purple"",
		        ""Teal"",
		        ""Fuchsia"",
		        ""Aqua"",
		    };
			listView.add(new ListOption(mOwner, getString(R.string.options_css_text_color), prefix + "".color"").add(fontColorStyles, fontColorStyleNames).setIconId(R.drawable.cr3_option_font_color));
			
			String[] marginTopOptions = {"""", // inherited
			        ""margin-top: 0em"",
			        ""margin-top: 0.2em"",
			        ""margin-top: 0.3em"",
			        ""margin-top: 0.5em"",
			        ""margin-top: 1em"",
			        ""margin-top: 2em""};
			String[] marginBottomOptions = {"""", // inherited
			        ""margin-bottom: 0em"",
			        ""margin-bottom: 0.2em"",
			        ""margin-bottom: 0.3em"",
			        ""margin-bottom: 0.5em"",
			        ""margin-bottom: 1em"",
			        ""margin-bottom: 2em""};
			int[] marginTopBottomOptionNames = {
			    	R.string.options_css_inherited,
			    	R.string.options_css_margin_0,
			    	R.string.options_css_margin_02em,
			    	R.string.options_css_margin_03em,
			    	R.string.options_css_margin_05em,
			    	R.string.options_css_margin_1em,
			    	R.string.options_css_margin_15em,
			        };
			String[] marginLeftOptions = {
					"""", // inherited
			        ""margin-left: 0em"",
			        ""margin-left: 0.5em"",
			        ""margin-left: 1em"",
			        ""margin-left: 1.5em"",
			        ""margin-left: 2em"",
			        ""margin-left: 4em"",
			        ""margin-left: 5%"",
			        ""margin-left: 10%"",
			        ""margin-left: 15%"",
			        ""margin-left: 20%"",
			        ""margin-left: 30%""};
			String[] marginRightOptions = {
					"""", // inherited
			        ""margin-right: 0em"",
			        ""margin-right: 0.5em"",
			        ""margin-right: 1em"",
			        ""margin-right: 1.5em"",
			        ""margin-right: 2em"",
			        ""margin-right: 4em"",
			        ""margin-right: 5%"",
			        ""margin-right: 10%"",
			        ""margin-right: 15%"",
			        ""margin-right: 20%"",
			        ""margin-right: 30%""};
			int[] marginLeftRightOptionNames = {
			    	R.string.options_css_inherited,
			    	R.string.options_css_margin_0,
			    	R.string.options_css_margin_05em,
			    	R.string.options_css_margin_1em,
			    	R.string.options_css_margin_15em,
			    	R.string.options_css_margin_2em,
			    	R.string.options_css_margin_4em,
			    	R.string.options_css_margin_5p,
			    	R.string.options_css_margin_10p,
			    	R.string.options_css_margin_15p,
			    	R.string.options_css_margin_20p,
			    	R.string.options_css_margin_30p,
			};
			listView.add(new ListOption(mOwner, getString(R.string.options_css_margin_top), prefix + "".margin-top"").add(marginTopOptions, marginTopBottomOptionNames).setIconId(R.drawable.cr3_option_text_margin_top));
			listView.add(new ListOption(mOwner, getString(R.string.options_css_margin_bottom), prefix + "".margin-bottom"").add(marginBottomOptions, marginTopBottomOptionNames).setIconId(R.drawable.cr3_option_text_margin_bottom));
			listView.add(new ListOption(mOwner, getString(R.string.options_css_margin_left), prefix + "".margin-left"").add(marginLeftOptions, marginLeftRightOptionNames).setIconId(R.drawable.cr3_option_text_margin_left));
			listView.add(new ListOption(mOwner, getString(R.string.options_css_margin_right), prefix + "".margin-right"").add(marginRightOptions, marginLeftRightOptionNames).setIconId(R.drawable.cr3_option_text_margin_right));
			

			dlg.setTitle(label);
			dlg.setView(listView);
			dlg.show();
		}

		public String getValueLabel() { return "">""; }
	}
	
	
	private ListOption createStyleEditor(String styleCode, int titleId) {
		ListOption res = new StyleEditorOption(this, getString(titleId), ""styles."" + styleCode);
		res.noIcon();
		return res;
	}

	final static private String[] styleCodes = {
		""def"",
		""title"",
		""subtitle"",
		""pre"",
		""link"",
		""cite"",
		""epigraph"",
		""poem"",
		""text-author"",
		""footnote"",
		""footnote-link"",
		""footnote-title"",
		""annotation"",
	};
	
	final static private int[] styleTitles = {
		R.string.options_css_def,
		R.string.options_css_title,
		R.string.options_css_subtitle,
		R.string.options_css_pre,
		R.string.options_css_link,
		R.string.options_css_cite,
		R.string.options_css_epigraph,
		R.string.options_css_poem,
		R.string.options_css_textauthor,
		R.string.options_css_footnote,
		R.string.options_css_footnotelink,
		R.string.options_css_footnotetitle,
		R.string.options_css_annotation,
	};
	
	private void fillStyleEditorOptions() {
		mOptionsCSS = new OptionsListView(getContext());
		for (int i=0; i<styleCodes.length; i++)
			mOptionsCSS.add(createStyleEditor(styleCodes[i], styleTitles[i]));
	}
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		L.v(""creating OptionsDialog"");
		CoolReader.dumpHeapAllocation();
		L.v(""calling gc"");
		System.gc();
		CoolReader.dumpHeapAllocation();
		L.v(""creating options dialog"");
        setCancelable(true);
        setCanceledOnTouchOutside(true);
        mInflater = LayoutInflater.from(getContext());
        mTabs = (TabHost)mInflater.inflate(R.layout.options, null);
		// setup tabs
		//setView(R.layout.options);
		//setContentView(R.layout.options);
		//mTabs = (TabHost)findViewById(android.R.id.tabhost); 
		mTabs.setup();
		
		TabWidget tabWidget = (TabWidget)mTabs.findViewById(android.R.id.tabs);
		//tabWidget.
		//new TabHost(getContext());
		
		mOptionsStyles = new OptionsListView(getContext());
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_font_face), PROP_FONT_FACE).add(mFontFaces).setDefaultValue(mFontFaces[0]).setIconId(R.drawable.cr3_option_font_face));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_font_size), PROP_FONT_SIZE).add(mFontSizes).setDefaultValue(""24"").setIconId(R.drawable.cr3_option_font_size));
		mOptionsStyles.add(new BoolOption(this, getString(R.string.options_font_embolden), PROP_FONT_WEIGHT_EMBOLDEN).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_text_bold));
		//mOptionsStyles.add(new BoolOption(getString(R.string.options_font_antialias), PROP_FONT_ANTIALIASING).setInverse().setDefaultValue(""0""));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_font_antialias), PROP_FONT_ANTIALIASING).add(mAntialias, mAntialiasTitles).setDefaultValue(""2"").setIconId(R.drawable.cr3_option_text_antialias));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_interline_space), PROP_INTERLINE_SPACE).addPercents(mInterlineSpaces).setDefaultValue(""100"").setIconId(R.drawable.cr3_option_line_spacing));
		//
		mOptionsStyles.add(new HyphenationOptions(this, getString(R.string.options_hyphenation_dictionary)).setIconId(R.drawable.cr3_option_text_hyphenation));
		mOptionsStyles.add(new BoolOption(this, getString(R.string.options_style_floating_punctuation), PROP_FLOATING_PUNCTUATION).setDefaultValue(""1"").setIconId(R.drawable.cr3_option_text_other));
		mOptionsStyles.add(new BoolOption(this, getString(R.string.options_font_kerning), PROP_FONT_KERNING_ENABLED).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_text_kerning));
		mOptionsStyles.add(new ImageScalingOption(this, getString(R.string.options_format_image_scaling)).setIconId(R.drawable.cr3_option_images));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_render_font_gamma), PROP_FONT_GAMMA).add(mGammas).setDefaultValue(""1.0"").setIconId(R.drawable.cr3_option_font_gamma));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_format_min_space_width_percent), PROP_FORMAT_MIN_SPACE_CONDENSING_PERCENT).addPercents(mMinSpaceWidths).setDefaultValue(""50"").setIconId(R.drawable.cr3_option_text_width));
		
		//
		mOptionsPage = new OptionsListView(getContext());
		mOptionsPage.add(new BoolOption(this, getString(R.string.options_app_fullscreen), PROP_APP_FULLSCREEN).setIconId(R.drawable.cr3_option_fullscreen));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_view_mode), PROP_PAGE_VIEW_MODE).add(mViewModes, mViewModeTitles).setDefaultValue(""1"").setIconId(R.drawable.cr3_option_view_mode_scroll));
		//mOptionsPage.add(new ListOption(getString(R.string.options_page_orientation), PROP_ROTATE_ANGLE).add(mOrientations, mOrientationsTitles).setDefaultValue(""0""));
		if (mActivity.getSDKLevel() >= 9)
			mOptionsPage.add(new ListOption(this, getString(R.string.options_page_orientation), PROP_APP_SCREEN_ORIENTATION).add(mOrientations_API9, mOrientationsTitles_API9).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_page_orientation_landscape));
		else
			mOptionsPage.add(new ListOption(this, getString(R.string.options_page_orientation), PROP_APP_SCREEN_ORIENTATION).add(mOrientations, mOrientationsTitles).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_page_orientation_landscape));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_landscape_pages), PROP_LANDSCAPE_PAGES).add(mLandscapePages, mLandscapePagesTitles).setDefaultValue(""1"").setIconId(R.drawable.cr3_option_pages_two));
		mOptionsPage.add(new NightModeOption(this, getString(R.string.options_inverse_view), PROP_NIGHT_MODE).setIconId(R.drawable.cr3_option_night));
		mOptionsPage.add(new ColorOption(this, getString(R.string.options_color_text), PROP_FONT_COLOR, 0x000000).setIconId(R.drawable.cr3_option_font_color));
		mOptionsPage.add(new ColorOption(this, getString(R.string.options_color_background), PROP_BACKGROUND_COLOR, 0xFFFFFF).setIconId(R.drawable.cr3_option_background_color));
		if ( !DeviceInfo.EINK_SCREEN )
			mOptionsPage.add(new TextureOptions(this, getString(R.string.options_background_texture)).setIconId(R.drawable.cr3_option_background_image));
		if ( DeviceInfo.EINK_SCREEN_UPDATE_MODES_SUPPORTED ) {
			mOptionsPage.add(new ListOption(this, getString(R.string.options_screen_update_mode), PROP_APP_SCREEN_UPDATE_MODE).add(mScreenUpdateModes, mScreenUpdateModesTitles).setDefaultValue(""0""));
			mOptionsPage.add(new ListOption(this, getString(R.string.options_screen_update_interval), PROP_APP_SCREEN_UPDATE_INTERVAL).add(mScreenFullUpdateInterval).setDefaultValue(""10""));
		}

		mOptionsPage.add(new StatusBarOption(this, getString(R.string.options_page_titlebar)));
		mOptionsPage.add(new BoolOption(this, getString(R.string.options_page_footnotes), PROP_FOOTNOTES).setDefaultValue(""1""));
		if ( !DeviceInfo.EINK_SCREEN )
			mOptionsPage.add(new ListOption(this, getString(R.string.options_page_animation), PROP_PAGE_ANIMATION).add(mAnimation, mAnimationTitles).setDefaultValue(""1""));
		mOptionsPage.add(new BoolOption(this, getString(R.string.options_view_bookmarks_highlight), PROP_APP_HIGHLIGHT_BOOKMARKS).setDefaultValue(""1""));

		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_left), PROP_PAGE_MARGIN_LEFT).add(mMargins).setDefaultValue(""5"").setIconId(R.drawable.cr3_option_text_margin_left));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_right), PROP_PAGE_MARGIN_RIGHT).add(mMargins).setDefaultValue(""5"").setIconId(R.drawable.cr3_option_text_margin_right));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_top), PROP_PAGE_MARGIN_TOP).add(mMargins).setDefaultValue(""5"").setIconId(R.drawable.cr3_option_text_margin_top));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_bottom), PROP_PAGE_MARGIN_BOTTOM).add(mMargins).setDefaultValue(""5"").setIconId(R.drawable.cr3_option_text_margin_bottom));
		
		mOptionsControls = new OptionsListView(getContext());
		mOptionsControls.add(new KeyMapOption(this, getString(R.string.options_app_key_actions)).setIconId(R.drawable.cr3_option_controls_keys));
		mOptionsControls.add(new TapZoneOption(this, getString(R.string.options_app_tapzones_normal), PROP_APP_TAP_ZONE_ACTIONS_TAP).setIconId(R.drawable.cr3_option_controls_tapzones));
		mOptionsControls.add(new ListOption(this, getString(R.string.options_controls_tap_secondary_action_type), PROP_APP_SECONDARY_TAP_ACTION_TYPE).add(mTapSecondaryActionType, mTapSecondaryActionTypeTitles).setDefaultValue(String.valueOf(TAP_ACTION_TYPE_LONGPRESS)));
		mOptionsControls.add(new BoolOption(this, getString(R.string.options_app_double_tap_selection), PROP_APP_DOUBLE_TAP_SELECTION).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_touch));
		if ( !DeviceInfo.EINK_SCREEN )
			mOptionsControls.add(new BoolOption(this, getString(R.string.options_controls_enable_volume_keys), PROP_CONTROLS_ENABLE_VOLUME_KEYS).setDefaultValue(""1""));
		mOptionsControls.add(new BoolOption(this, getString(R.string.options_app_tapzone_hilite), PROP_APP_TAP_ZONE_HILIGHT).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_touch));
		if ( !DeviceInfo.EINK_SCREEN )
			mOptionsControls.add(new BoolOption(this, getString(R.string.options_app_trackball_disable), PROP_APP_TRACKBALL_DISABLED).setDefaultValue(""0""));
		if ( !DeviceInfo.EINK_SCREEN )
			mOptionsControls.add(new ListOption(this, getString(R.string.options_controls_flick_brightness), PROP_APP_FLICK_BACKLIGHT_CONTROL).add(mFlickBrightness, mFlickBrightnessTitles).setDefaultValue(""1""));
		mOptionsControls.add(new ListOption(this, getString(R.string.options_selection_action), PROP_APP_SELECTION_ACTION).add(mSelectionAction, mSelectionActionTitles).setDefaultValue(""0""));
		mOptionsControls.add(new BoolOption(this, getString(R.string.options_selection_keep_selection_after_dictionary), PROP_APP_SELECTION_PERSIST).setDefaultValue(""0""));
		
		mOptionsApplication = new OptionsListView(getContext());
		if ( !DeviceInfo.FORCE_LIGHT_THEME ) {
			mOptionsApplication.add(new ThemeOptions(this, getString(R.string.options_app_ui_theme)).noIcon());
		}
		if ( !DeviceInfo.EINK_SCREEN ) {
			mOptionsApplication.add(new ListOption(this, getString(R.string.options_app_backlight_timeout), PROP_APP_SCREEN_BACKLIGHT_LOCK).add(mBacklightTimeout, mBacklightTimeoutTitles).setDefaultValue(""3"").noIcon());
			mBacklightLevelsTitles[0] = getString(R.string.options_app_backlight_screen_default);
			mOptionsApplication.add(new ListOption(this, getString(R.string.options_app_backlight_screen), PROP_APP_SCREEN_BACKLIGHT).add(mBacklightLevels, mBacklightLevelsTitles).setDefaultValue(""-1"").noIcon());
		}
		mOptionsApplication.add(new IconsBoolOption(this, getString(R.string.options_app_settings_icons), PROP_APP_SETTINGS_SHOW_ICONS).setDefaultValue(""1"").noIcon());
		mOptionsApplication.add(new DictOptions(this, getString(R.string.options_app_dictionary)).noIcon());
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_show_cover_pages), PROP_APP_SHOW_COVERPAGES).noIcon());
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_scan_book_props), PROP_APP_BOOK_PROPERTY_SCAN_ENABLED).setDefaultValue(""1"").noIcon());
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_browser_hide_empty_dirs), PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS).setDefaultValue(""0"").noIcon());
		
		fillStyleEditorOptions();
		
		mOptionsStyles.refresh();
		mOptionsCSS.refresh();
		mOptionsPage.refresh();
		mOptionsApplication.refresh();
		
		
		TabHost.TabSpec tsStyles = mTabs.newTabSpec(""Styles"");
		tsStyles.setIndicator("""", //getContext().getResources().getString(R.string.tab_options_styles) 
				getContext().getResources().getDrawable(R.drawable.cr3_tab_style)); //R.drawable.cr3_option_style
		tsStyles.setContent(this);
		mTabs.addTab(tsStyles);

		TabHost.TabSpec tsCSS = mTabs.newTabSpec(""CSS"");
		tsCSS.setIndicator("""", getContext().getResources().getDrawable(R.drawable.cr3_tab_css)); //R.drawable.cr3_option_style
		tsCSS.setContent(this);
		mTabs.addTab(tsCSS);

		TabHost.TabSpec tsPage = mTabs.newTabSpec(""Page"");
		tsPage.setIndicator("""", getContext().getResources().getDrawable(R.drawable.cr3_tab_page)); //R.drawable.cr3_option_page
		tsPage.setContent(this);
		mTabs.addTab(tsPage);

		TabHost.TabSpec tsControls = mTabs.newTabSpec(""Controls"");
		tsControls.setIndicator("""", getContext().getResources().getDrawable(R.drawable.cr3_tab_controls));
		tsControls.setContent(this);
		mTabs.addTab(tsControls);


		TabHost.TabSpec tsApp = mTabs.newTabSpec(""App"");
		tsApp.setIndicator("""", getContext().getResources().getDrawable(R.drawable.cr3_tab_application));
		tsApp.setContent(this);
		mTabs.addTab(tsApp);
		
		setView(mTabs);
		
		mOldProperties = new Properties(mProperties);
		
		setOnCancelListener(new OnCancelListener() {

			public void onCancel(DialogInterface dialog) {
				onPositiveButtonClick();
			}
		});

		ImageButton positiveButton = (ImageButton)mTabs.findViewById(R.id.options_btn_back);
		positiveButton.setOnClickListener(new View.OnClickListener() {
			public void onClick(View v) {
				onPositiveButtonClick();
			}
		});
		
//		ImageButton negativeButton = (ImageButton)mTabs.findViewById(R.id.options_btn_cancel);
//		negativeButton.setOnClickListener(new View.OnClickListener() {
//			public void onClick(View v) {
//				onNegativeButtonClick();
//			}
//		});
		
		super.onCreate(savedInstanceState);
		L.v(""OptionsDialog is created"");
	}

//	private void askApply()
//	{
//		Properties diff = mProperties.diff(mOldProperties);
//		if ( diff.size()>0 ) {
//			L.d(""Some properties were changed, ask user whether to apply"");
//			AlertDialog.Builder dlg = new AlertDialog.Builder(getContext());
//			dlg.setTitle(R.string.win_title_options_apply);
//			dlg.setPositiveButton(R.string.dlg_button_ok, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					onPositiveButtonClick();
//				}
//			});
//			dlg.setNegativeButton(R.string.dlg_button_cancel, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					onNegativeButtonClick();
//				}
//			});
//			dlg.show();
//		}
//	}
	
	@Override
	protected void onPositiveButtonClick() {
        mReaderView.setSettings(mProperties, mOldProperties);
        dismiss();
	}

	@Override
	protected void onNegativeButtonClick() {
		onPositiveButtonClick();
	}

	@Override
	protected void onStop() {
		L.d(""OptionsDialog.onStop() : calling gc()"");
		System.gc();
		super.onStop();
	}

	
}
",True,47,49,0,0,3,30,3,13,L0
13,org.coolreader.crengine.TOCDlg.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.database.DataSetObserver;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

public class TOCDlg extends BaseDialog {
	//CoolReader mCoolReader;
	ReaderView mReaderView;
	TOCItem mTOC;
	ListView mListView;
	int mCurrentPage;
	TOCItem mCurrentPageItem;
	ArrayList<TOCItem> mItems = new ArrayList<TOCItem>(); 
	private LayoutInflater mInflater;
	
	private void initItems( TOCItem toc, boolean expanded )
	{
		for ( int i=0; i<toc.getChildCount(); i++ ) {
			TOCItem child = toc.getChild(i);
			if ( child.getPage()<=mCurrentPage )
				mCurrentPageItem = child;
			if ( expanded ) {
				child.setGlobalIndex(mItems.size());
				mItems.add(child);
			} else {
				child.setGlobalIndex(-1); // invisible
			}
			initItems(child, expanded && child.getExpanded());
		}
	}
	private void initItems()
	{
		mCurrentPageItem = null;
		mItems.clear();
		initItems(mTOC, true);
	}
	
	private void expand( TOCItem item )
	{
		if ( item==null )
			return;
		item.setExpanded(true);
		// expand all parents
		for ( TOCItem p = item.getParent(); p!=null; p = p.getParent() )
			p.setExpanded(true);
		initItems();
		refreshList();
		if ( mItems.size()>0 ) {
			if ( item.getGlobalIndex()>=0 ) {
				mListView.setSelection(item.getGlobalIndex());
				mListView.setSelectionFromTop(item.getGlobalIndex(), mListView.getHeight()/2);
			} else
				mListView.setSelection(0);
		}
	}
	
	private void collapse( TOCItem item )
	{
		item.setExpanded(false);
		initItems();
		refreshList();
	}
	
	private void refreshList()
	{
		mListView.setAdapter(new ListAdapter() {
			public boolean areAllItemsEnabled() {
				return true;
			}

			public boolean isEnabled(int arg0) {
				return true;
			}

			public int getCount() {
				return mItems.size();
			}

			public Object getItem(int position) {
				return mItems.get(position);
			}

			public long getItemId(int position) {
				return position;
			}

			public int getItemViewType(int position) {
				TOCItem item = mItems.get(position);
				boolean isCurrentItem = item==mCurrentPageItem;
				return isCurrentItem ? 0 : 1;
			}

			
			public View getView(int position, View convertView, ViewGroup parent) {
				View view;
				TOCItem item = mItems.get(position);
				boolean isCurrentItem = item==mCurrentPageItem;
				if ( convertView==null ) {
					//view = new TextView(getContext());
					view = mInflater.inflate(isCurrentItem ? R.layout.toc_item_current : R.layout.toc_item, null);
				} else {
					view = (View)convertView;
				}
				TextView pageTextView = (TextView)view.findViewById(R.id.toc_page);
				TextView titleTextView = (TextView)view.findViewById(R.id.toc_title);
				TextView marginTextView = (TextView)view.findViewById(R.id.toc_level_margin);
				ImageView expandImageView = (ImageView)view.findViewById(R.id.toc_expand_icon);
				StringBuilder buf = new StringBuilder(item.getLevel()*2);
				for ( int i=1; i<item.getLevel(); i++ )
					buf.append(""  "");
				if ( item.getChildCount()>0 ) {
					if ( item.getExpanded() ) {
						expandImageView.setImageResource(R.drawable.cr3_toc_item_expanded);
					} else {
						expandImageView.setImageResource(R.drawable.cr3_toc_item_collapsed);
					}
				} else {
					expandImageView.setImageResource(R.drawable.cr3_toc_item_normal);
				}
				marginTextView.setText(buf.toString());
				titleTextView.setText(item.getName());
				pageTextView.setText(String.valueOf(item.getPage()+1));
				return view;
			}

			public int getViewTypeCount() {
				return 2;
			}

			public boolean hasStableIds() {
				return true;
			}

			public boolean isEmpty() {
				return false;
			}

			private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
			
			public void registerDataSetObserver(DataSetObserver observer) {
				observers.add(observer);
			}

			public void unregisterDataSetObserver(DataSetObserver observer) {
				observers.remove(observer);
			}
		});
	}

	public TOCDlg( CoolReader coolReader, ReaderView readerView, TOCItem toc, int currentPage )
	{
		super(coolReader, coolReader.getResources().getString(R.string.win_title_toc), false, false);
        setCancelable(true);
//		this.mCoolReader = coolReader;
		this.mReaderView = readerView;
		this.mTOC = toc;
		this.mCurrentPage = currentPage;
		this.mListView = new ListView(getContext());
		mListView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> listview, View view,
					int position, long id) {
				TOCItem item = mItems.get(position);
				if ( item.getChildCount()==0 || item.getExpanded() ) {
					mReaderView.goToPage(item.getPage()+1);
					dismiss();
				} else {
					expand(item);
				}
			}
		});
		mListView.setOnItemLongClickListener(new OnItemLongClickListener() {

			@Override
			public boolean onItemLongClick(AdapterView<?> listview, View view,
					int position, long id) {
				TOCItem item = mItems.get(position);
				if ( item.getChildCount()==0 ) {
					mReaderView.goToPage(item.getPage()+1);
					dismiss();
				} else {
					if ( item.getExpanded() )
						collapse(item);
					else
						expand(item);
				}
				return true;
			}
		});
		mListView.setLongClickable(true);
		mListView.setClickable(true);
		mListView.setFocusable(true);
		mListView.setFocusableInTouchMode(true);
		mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		setView(mListView);
		setFlingHandlers(mListView, new Runnable() {
			@Override
			public void run() {
				// cancel
				TOCDlg.this.dismiss();
			}
		}, new Runnable() {
			@Override
			public void run() {
				// 
				TOCDlg.this.dismiss();
			}
		});
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
        mInflater = LayoutInflater.from(getContext());
		super.onCreate(savedInstanceState);
		expand( mTOC );
		expand( mCurrentPageItem );
	}
	
	

}
",False,24,49,0,0,3,36,1,4,L0
14,org.coolreader.crengine.BookmarksDlg.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.Context;
import android.database.DataSetObserver;
import android.graphics.Paint;
import android.os.Bundle;
import android.util.Log;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnMenuItemClickListener;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

public class BookmarksDlg  extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	private LayoutInflater mInflater;
	BookInfo mBookInfo;
	BookmarkList mList;
	BookmarksDlg mThis;

	public final static int ITEM_POSITION=0;
	public final static int ITEM_COMMENT=1;
	public final static int ITEM_CORRECTION=2;
	public final static int ITEM_SHORTCUT=3;
	
	class BookmarkListAdapter implements ListAdapter {
		public boolean areAllItemsEnabled() {
			return true;
		}

		public boolean isEnabled(int arg0) {
			return true;
		}

		public int getCount() {
			return mBookInfo.getBookmarkCount();
		}

		public Object getItem(int position) {
			if ( position<0 || position>=mBookInfo.getBookmarkCount() )
				return null;
			return mBookInfo.getBookmark(position);
		}

		public long getItemId(int position) {
			return position;
		}

		
		
		public int getItemViewType(int position) {
			Bookmark bm = (Bookmark)getItem(position);
			if ( bm==null )
				return ITEM_POSITION;
			switch ( bm.getType() ) {
			case Bookmark.TYPE_COMMENT:
				return ITEM_COMMENT;
			case Bookmark.TYPE_CORRECTION:
				return ITEM_CORRECTION;
			default:
				if ( bm.getShortcut()>0 )
					return ITEM_SHORTCUT;
				return ITEM_POSITION;
			}
		}

		public int getViewTypeCount() {
			return 4;
		}

		
		public View getView(int position, View convertView, ViewGroup parent) {
			View view;
			int type = getItemViewType(position);
			if ( convertView==null ) {
				//view = new TextView(getContext());
				int res = R.layout.bookmark_position_item;
				switch ( type ) {
				case ITEM_COMMENT:
					res = R.layout.bookmark_comment_item;
					break;
				case ITEM_CORRECTION:
					res = R.layout.bookmark_correction_item;
					break;
				case ITEM_SHORTCUT:
					res = R.layout.bookmark_shortcut_item;
					break;
				}
				view = mInflater.inflate(res, null);
			} else {
				view = (View)convertView;
			}
			TextView labelView = (TextView)view.findViewById(R.id.bookmark_item_shortcut);
			TextView posTextView = (TextView)view.findViewById(R.id.bookmark_item_pos_text);
			TextView titleTextView = (TextView)view.findViewById(R.id.bookmark_item_title);
			TextView commentTextView = (TextView)view.findViewById(R.id.bookmark_item_comment_text);
			if ( type==ITEM_CORRECTION && posTextView!=null )
				posTextView.setPaintFlags(posTextView.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG );
				
			Bookmark b = (Bookmark)getItem(position);
			if ( labelView!=null ) {
				if ( b!=null && b.getShortcut()>0 )
					labelView.setText(String.valueOf(b.getShortcut()));
				else
					labelView.setText(String.valueOf(position+1));
			}
			if ( b!=null ) {
				String percentString = FileBrowser.formatPercent(b.getPercent());
				String s1 = b.getTitleText();
				String s2 = b.getPosText();
				String s3 = b.getCommentText();
				if ( s1!=null && s2!=null ) {
					s1 = percentString + ""   "" + s1;
				} else if ( s1!=null ) {
					s2 = s1;
					s1 = percentString;  
				} else if ( s2!=null ) {
					s1 = percentString;
				} else {
					s1 = s2 = """";
				}
				if ( titleTextView!=null )
					titleTextView.setText(s1);
				if ( posTextView!=null )
					posTextView.setText(s2);
				if ( commentTextView!=null )
					commentTextView.setText(s3);
			} else {
				if ( commentTextView!=null )
					commentTextView.setText("""");
				if ( titleTextView!=null )
					titleTextView.setText("""");
				if ( posTextView!=null )
					posTextView.setText("""");
			}
			return view;
		}

		public boolean hasStableIds() {
			return true;
		}

		public boolean isEmpty() {
			return mBookInfo.getBookmarkCount()==0;
		}

		private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
		
		public void registerDataSetObserver(DataSetObserver observer) {
			observers.add(observer);
		}

		public void unregisterDataSetObserver(DataSetObserver observer) {
			observers.remove(observer);
		}
	}
	
	class ShortcutBookmarkListAdapter extends BookmarkListAdapter {
		public int getCount() {
			return SHORTCUT_COUNT;
		}

		public Object getItem(int position) {
			return mBookInfo.findShortcutBookmark(position+1);
		}

		public int getItemViewType(int position) {
			return ITEM_SHORTCUT;
		}
	}
	
	class BookmarkList extends ListView {
		private ListAdapter mAdapter;
		private boolean mShortcutMode = false;
		
		public boolean isShortcutMode() {
			return mShortcutMode;
		}
		public void setShortcutMode( boolean shortcutMode ) {
			if ( !shortcutMode )
				mBookInfo.sortBookmarks();
			updateAdapter( shortcutMode ? new ShortcutBookmarkListAdapter() : new BookmarkListAdapter() );
		}
		public void updateAdapter( BookmarkListAdapter adapter ) {
			mAdapter = adapter;
			setAdapter(mAdapter);
		}
		public BookmarkList( Context context, boolean shortcutMode ) {
			super(context);
			setChoiceMode(ListView.CHOICE_MODE_SINGLE);
			setShortcutMode(shortcutMode);
			setLongClickable(true);
			setOnItemLongClickListener(new OnItemLongClickListener() {
				@Override
				public boolean onItemLongClick(AdapterView<?> arg0, View arg1,
						int position, long arg3) {
					selectedItem = position;
					openContextMenu(BookmarkList.this);
					return true;
				}
			});
		}

		public Bookmark getSelectedBookmark() {
			return (Bookmark)mAdapter.getItem(selectedItem);
		}
		
		@Override
		public boolean performItemClick(View view, int position, long id) {
			if ( mShortcutMode ) {
				Bookmark b = mBookInfo.findShortcutBookmark(position+1);
				if ( b==null ) {
					mReaderView.addBookmark(position+1);
					mThis.dismiss();
					return true;
				}
				selectedItem = position;
				openContextMenu(this);
			} else {
				Bookmark bm = (Bookmark)mAdapter.getItem(position);
				if ( bm!=null ) {
					mReaderView.goToBookmark(bm);
					dismiss();
				}
			}
			return true;
		}
		
		
	}
	
	final static int SHORTCUT_COUNT = 10;
	
	public BookmarksDlg( CoolReader activity, ReaderView readerView )
	{
		super(activity, activity.getResources().getString(R.string.win_title_bookmarks), true, false);
		mThis = this; // for inner classes
        mInflater = LayoutInflater.from(getContext());
		mCoolReader = activity;
		mReaderView = readerView;
		mBookInfo = mReaderView.getBookInfo();
		setPositiveButtonImage(R.drawable.cr3_button_add);
		View frame = mInflater.inflate(R.layout.bookmark_list_dialog, null);
		ViewGroup body = (ViewGroup)frame.findViewById(R.id.bookmark_list);
		mList = new BookmarkList(activity, false);
		body.addView(mList);
		setView(frame);
		setFlingHandlers(mList, null, null);
	}

	@Override
	protected void onPositiveButtonClick() {
		// add bookmark
		mReaderView.addBookmark(0);
		BookmarksDlg.this.dismiss();
	}

	@Override
	protected void onNegativeButtonClick() {
		BookmarksDlg.this.dismiss();
	}



	@Override
	protected void onCreate(Bundle savedInstanceState) {
		Log.v(""cr3"", ""creating BookmarksDlg"");
		//setTitle(mCoolReader.getResources().getString(R.string.win_title_bookmarks));
        setCancelable(true);
		super.onCreate(savedInstanceState);
		registerForContextMenu(mList);
	}
	
	private void listUpdated() {
		mList.setShortcutMode(mList.isShortcutMode());
	}
	
	@Override
	public boolean onContextItemSelected(MenuItem item) {
		
		int shortcut = selectedItem; //mList.getSelectedItemPosition();
		Bookmark bm = mList.getSelectedBookmark();
		if ( mList.isShortcutMode() ) {
			if ( shortcut>=0 && shortcut<SHORTCUT_COUNT ) {
				switch (item.getItemId()) {
				case R.id.bookmark_shortcut_add:
					mReaderView.addBookmark(shortcut+1);
					listUpdated();
					dismiss();
					return true;
				case R.id.bookmark_delete:
					if (mReaderView.removeBookmark(bm) != null)
						listUpdated();
					return true;
				case R.id.bookmark_shortcut_goto:
					mReaderView.goToBookmark(shortcut+1);
					dismiss();
					return true;
				}
			}
			return super.onContextItemSelected(item);
		}
		switch (item.getItemId()) {
		case R.id.bookmark_add:
			mReaderView.addBookmark(0);
			listUpdated();
			dismiss();
			return true;
		case R.id.bookmark_delete:
			if (mReaderView.removeBookmark(bm) != null)
				listUpdated();
			return true;
		case R.id.bookmark_goto:
			if ( bm!=null )
				mReaderView.goToBookmark(bm);
			dismiss();
			return true;
		case R.id.bookmark_edit:
			if ( bm!=null && (bm.getType()==Bookmark.TYPE_COMMENT || bm.getType()==Bookmark.TYPE_CORRECTION)) {
				BookmarkEditDialog dlg = new BookmarkEditDialog(mCoolReader, mReaderView, bm, false);
				dlg.show();
			}
			dismiss();
			return true;
		case R.id.bookmark_export:
			if ( mBookInfo.getBookmarkCount()>0 ) {
				FileInfo fi = mBookInfo.getFileInfo();
				String s = fi.getPathName();
				s = s.replace(FileInfo.ARC_SEPARATOR, ""_"");
				s = s + "".bmk.txt"";
				if ( mBookInfo.exportBookmarks(s) )
					mCoolReader.showToast( getContext().getString(R.string.toast_bookmark_export_ok) + "" "" + s);
				else
					mCoolReader.showToast(getContext().getString(R.string.toast_bookmark_export_failed) + "" "" + s);
			}
			dismiss();
			return true;
		case R.id.bookmark_send:
			if ( mBookInfo.getBookmarkCount()>0 ) {
				String s = mBookInfo.getBookmarksExportText();
				mCoolReader.sendBookFragment(mBookInfo, s);
			}
			dismiss();
			return true;
		}
		return super.onContextItemSelected(item);
	}
	
	private int selectedItem;
	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
	    MenuInflater inflater = mCoolReader.getMenuInflater();
	    menu.clear();
	    inflater.inflate(mList.isShortcutMode() ? R.menu.cr3_bookmark_shortcut_context_menu : R.menu.cr3_bookmark_context_menu, menu);
	    AdapterContextMenuInfo mi = (AdapterContextMenuInfo)menuInfo;
	    if ( mi!=null )
	    	selectedItem = mi.position;
		Bookmark bm = mList.getSelectedBookmark();
	    menu.setHeaderTitle(getContext().getString(R.string.context_menu_title_bookmark));
	    for ( int i=0; i<menu.size(); i++ ) {
	    	MenuItem menuItem = menu.getItem(i);
	    	if ( menuItem.getItemId()==R.id.bookmark_shortcut_goto || menuItem.getItemId()==R.id.bookmark_edit ||
	    			menuItem.getItemId()==R.id.bookmark_delete )
	    		menuItem.setEnabled(bm!=null);
	    	if ( menuItem.getItemId()==R.id.bookmark_edit )
	    		menuItem.setEnabled(bm!=null && (bm.getType()==Bookmark.TYPE_COMMENT || bm.getType()==Bookmark.TYPE_CORRECTION));
	    	menuItem.setOnMenuItemClickListener(new OnMenuItemClickListener() {
				public boolean onMenuItemClick(MenuItem item) {
					onContextItemSelected(item);
					return true;
				}
			});
	    }
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if ( keyCode==KeyEvent.KEYCODE_MENU ) {
			openContextMenu(mList);
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}
	
	

}
",False,9,49,0,0,3,38,1,8,L0
15,org.coolreader.crengine.N2EpdController.java,"package org.coolreader.crengine;

import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import android.view.View;
//import java.lang.reflect.InvocationTargetException;

/**
 * Nook Touch EPD controller interface wrapper.
 * This class is created by DairyKnight for Nook Touch screen support in FBReaderJ.
 * @author DairyKnight <dairyknight@gmail.com>
 * http://forum.xda-developers.com/showthread.php?t=1183173
 */

public class N2EpdController {
	public static final int REGION_APP_1 = 0;
	public static final int REGION_APP_2 = 1;
	public static final int REGION_APP_3 = 2;
	public static final int REGION_APP_4 = 3;
	
	public static final int WAVE_GC = 0;
	public static final int WAVE_GU = 1;
	public static final int WAVE_DU = 2;
	public static final int WAVE_A2 = 3;
	public static final int WAVE_GL16 = 4;
	public static final int WAVE_AUTO = 5;
	
	public static final int MODE_BLINK = 0;
	public static final int MODE_ACTIVE = 1;
	public static final int MODE_ONESHOT = 2;
	public static final int MODE_CLEAR = 3;
	public static final int MODE_ACTIVE_ALL = 4;
	public static final int MODE_ONESHOT_ALL = 5;
	public static final int MODE_CLEAR_ALL = 6;
	
	public static String strN2EpdInit = "" N2EpdInit: "";
	
	private static Method mtSetRegion = null;
	private static Constructor RegionParamsConstructor= null;

	private static Object[] enumsWave 	= null;
	private static Object[] enumsRegion	= null;
	private static Object[] enumsMode	= null;

	static {
		if (DeviceInfo.EINK_NOOK) {
			try {
				Class clEpdController     	= Class.forName(""android.hardware.EpdController"");
				Class clEpdControllerWave 	= Class.forName(""android.hardware.EpdController$Wave"");
				Class clEpdControllerMode 	= Class.forName(""android.hardware.EpdController$Mode"");
				Class clEpdControllerRegion = Class.forName(""android.hardware.EpdController$Region"");

				Class clEpdControllerRegionParams = Class.forName(""android.hardware.EpdController$RegionParams"");
				
				enumsWave = clEpdControllerWave.getEnumConstants();

				enumsMode = clEpdControllerMode.getEnumConstants();

				enumsRegion = clEpdControllerRegion.getEnumConstants();

//				mtSetRegion = clEpdController.getMethod(""setRegion"", String.class, clEpdControllerRegion, View.class,
//								clEpdControllerWave, clEpdControllerMode);
				RegionParamsConstructor = clEpdControllerRegionParams.getConstructor(
						new Class[] { Integer.TYPE, Integer.TYPE, Integer.TYPE, Integer.TYPE, clEpdControllerWave});
				mtSetRegion = clEpdController.getMethod(""setRegion"", String.class, clEpdControllerRegion, 
						clEpdControllerRegionParams, clEpdControllerMode);
				
				strN2EpdInit += ""Ok!"";
			} catch (Exception e) {
				System.err.println(""Failed to init refresh EPD"");
				System.err.println(e.toString());
				strN2EpdInit += ""Failed: "" + e.toString();
				e.printStackTrace();
			}
		}
	}

//	public static void setMode(int region, int wave, int mode, View view) {
	public static void setMode(int region, int wave, int mode) {
		if (mtSetRegion != null) {
			try {
				Object regionParams =  RegionParamsConstructor.newInstance(new Object[] { 0, 0, 600, 800, enumsWave[wave]});
//				mtSetRegion.invoke(null, ""CoolReader"", enumsRegion[region], view, enumsWave[wave], enumsMode[mode]);
				mtSetRegion.invoke(null, ""CoolReader"", enumsRegion[region], regionParams, enumsMode[mode]);
			} catch (Exception e) {
				System.err.println(""Failed: SetMode"");
				System.err.println(e.toString());
				strN2EpdInit += ""Failed: setMode: "" + e.toString();
				e.printStackTrace();
			}
		}
	}
}
",True,16,32,5,23,1,1,1,1,L0
16,org.coolreader.crengine.BaseListAdapter.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import android.database.DataSetObserver;
import android.widget.ListAdapter;

public abstract class BaseListAdapter implements ListAdapter {
	private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
	
	public void registerDataSetObserver(DataSetObserver observer) {
		observers.add(observer);
	}

	public void unregisterDataSetObserver(DataSetObserver observer) {
		observers.remove(observer);
	}
	
	public void notifyDataSetChanged() {
		for (DataSetObserver observer : observers) {
			observer.onChanged();
		}
	}

	public void notifyInvalidated() {
		for (DataSetObserver observer : observers) {
			observer.onInvalidated();
		}
	}
}
",False,25,30,5,20,0,0,2,0,L0
17,org.coolreader.crengine.BaseDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.app.Dialog;
import android.content.DialogInterface;
import android.graphics.PixelFormat;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.ImageButton;
import android.widget.TextView;

public class BaseDialog extends Dialog {

	View layoutView;
	ViewGroup buttonsLayout;
	ViewGroup contentsLayout;
	CoolReader activity;
	String title;
	boolean needCancelButton;
	int positiveButtonImage;
	int negativeButtonImage;
	public void setPositiveButtonImage(int id) {
		positiveButtonImage = id;
	}
	public void setNegativeButtonImage(int id) {
		negativeButtonImage = id;
	}
	
	public static final boolean DARK_THEME = !DeviceInfo.FORCE_LIGHT_THEME;
	public BaseDialog( CoolReader activity )
	{
		this( activity, """", false, false );
	}
	public BaseDialog( CoolReader activity, String title, boolean showNegativeButton, boolean windowed )
	{
		this( activity, title, showNegativeButton, activity.isFullscreen(), activity.isNightMode(), windowed );
	}
	public BaseDialog( CoolReader activity, String title, boolean showNegativeButton, boolean fullscreen, boolean dark, boolean windowed )
	{
		//super(activity, fullscreen ? R.style.Dialog_Fullscreen : R.style.Dialog_Normal);
		//super(activity, fullscreen ? R.style.Dialog_Fullscreen : android.R.style.Theme_Dialog); //android.R.style.Theme_Light_NoTitleBar_Fullscreen : android.R.style.Theme_Light
		super(activity,
				windowed ? activity.getCurrentTheme().getDialogThemeId() :
				(fullscreen
				? activity.getCurrentTheme().getFullscreenDialogThemeId()
				: activity.getCurrentTheme().getDialogThemeId()
				));
		setOwnerActivity(activity);
		this.activity = activity;
		this.title = title;
		this.needCancelButton = showNegativeButton;
		getWindow().requestFeature(Window.FEATURE_NO_TITLE);
//		requestWindowFeature(Window.FEATURE_OPTIONS_PANEL);
		WindowManager.LayoutParams lp = new WindowManager.LayoutParams();
		lp.alpha = 1.0f;
		lp.dimAmount = 0.0f;
		lp.format = PixelFormat.RGB_565;
		lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL;
		lp.horizontalMargin = 0;
		lp.verticalMargin = 0;
		lp.windowAnimations = 0;
		lp.layoutAnimationParameters = null;
		//lp.memoryType = WindowManager.LayoutParams.MEMORY_TYPE_PUSH_BUFFERS;
		getWindow().setAttributes(lp);
		Log.i(""cr3"", ""BaseDialog.window="" + getWindow());
        setCancelable(true);
        setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss(DialogInterface dialog) {
				onClose();
			}
        });
        onCreate();
	}

	public void setView( View view )
	{
		this.view = view;
		if ( layoutView==null ) {
			layoutView = createLayout(view);
			setContentView(layoutView);
		}
		contentsLayout.removeAllViews();
		contentsLayout.addView(view);
	}
	
	protected void onPositiveButtonClick()
	{
		// override it
		dismiss();
	}
	
	protected void onNegativeButtonClick()
	{
		// override it
		dismiss();
	}

	protected void createButtonsPane( ViewGroup parent, ViewGroup layout )
	{
		//getWindow().getDecorView().getWidth()
		ImageButton positiveButton = (ImageButton)layout.findViewById(R.id.base_dlg_btn_positive);
		ImageButton negativeButton = (ImageButton)layout.findViewById(R.id.base_dlg_btn_negative);
		ImageButton backButton = (ImageButton)layout.findViewById(R.id.base_dlg_btn_back);
		if (positiveButtonImage != 0) {
			positiveButton.setImageResource(positiveButtonImage);
			//backButton.setImageResource(positiveButtonImage);
		}
		if (negativeButtonImage != 0) {
			negativeButton.setImageResource(negativeButtonImage);
			backButton.setImageResource(negativeButtonImage);
		}
		if (needCancelButton) {
			//layout.removeView(backButton);
			layout.removeView(negativeButton);
			positiveButton.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					onPositiveButtonClick();
				}
			});
			//negativeButton.setOnClickListener(new View.OnClickListener() {
			backButton.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					onNegativeButtonClick();
				}
			});
		} else {
			layout.removeView(positiveButton);
			layout.removeView(negativeButton);
			if (title != null) {
				backButton.setOnClickListener(new View.OnClickListener() {
					public void onClick(View v) {
						onPositiveButtonClick();
					}
				});
			} else {
				parent.removeView(layout);
                buttonsLayout = null;
			}
		}
		if (title != null)
			setTitle(title);
		if (buttonsLayout != null) {
			buttonsLayout.setOnTouchListener(new OnTouchListener() {
				@Override
				public boolean onTouch(View v, MotionEvent event) {
					if (event.getAction() == MotionEvent.ACTION_DOWN) {
						int x = (int)event.getX();
						int dx = v.getWidth();
						if (x < dx / 2) {
							if (needCancelButton)
								onNegativeButtonClick();
							else
								onPositiveButtonClick();
						} else {
							onPositiveButtonClick();
						}
						return true;
					}
					return false;
				}
			});
		}
	}

	@Override
	public void setTitle(CharSequence title) {
		this.title = String.valueOf(title);
		if (buttonsLayout != null) {
	        TextView lbl = (TextView)buttonsLayout.findViewById(R.id.base_dlg_title);
	        if (lbl != null)
	        	lbl.setText(title != null ? title : """");
		}
	}

	protected View createLayout( View view )
	{
        LayoutInflater mInflater = LayoutInflater.from(getContext());
        ViewGroup layout = (ViewGroup)mInflater.inflate(R.layout.base_dialog, null);
        buttonsLayout = (ViewGroup)layout.findViewById(R.id.base_dlg_button_panel);
        if (buttonsLayout != null) {
            if ( needCancelButton || title != null) {
            	createButtonsPane(layout, buttonsLayout);
            } else {
            	layout.removeView(buttonsLayout);
                buttonsLayout = null;
            }
        }
        contentsLayout =  (ViewGroup)layout.findViewById(R.id.base_dialog_content_view);
        contentsLayout.addView(view);
        setTitle(title);
		return layout;
	}
	
	protected void onCreate() {
		// when dialog is created
	}
	
	protected void onClose() {
		// when dialog is closed
	}
	
	/**
	 * Set View's gesture handlers for LTR and RTL horizontal fling
	 * @param view
	 * @param ltrHandler, pass null to call onNegativeButtonClick
	 * @param rtlHandler, pass null to call onPositiveButtonClick
	 */
	public void setFlingHandlers(View view, Runnable ltrHandler, Runnable rtlHandler) {
		if (ltrHandler == null)
			ltrHandler = new Runnable() {
				@Override
				public void run() {
					// cancel
					onNegativeButtonClick();
				}
			};
		if (rtlHandler == null)
			rtlHandler = new Runnable() {
				@Override
				public void run() {
					// ok
					onPositiveButtonClick();
				}
			};
		final GestureDetector detector = new GestureDetector(new MyGestureListener(ltrHandler, rtlHandler));
		view.setOnTouchListener(new OnTouchListener() {
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				return detector.onTouchEvent(event);
			}
		});
	}

	private class MyGestureListener extends SimpleOnGestureListener {
		Runnable ltrHandler;
		Runnable rtlHandler;
		
		public MyGestureListener(Runnable ltrHandler, Runnable rtlHandler) {
			this.ltrHandler = ltrHandler;
			this.rtlHandler = rtlHandler;
		}

		@Override
		public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
				float velocityY) {
			if (e1 == null || e2 == null)
				return false;
			int thresholdDistance = activity.getPalmTipPixels() * 2;
			int thresholdVelocity = activity.getPalmTipPixels();
			int x1 = (int)e1.getX();
			int x2 = (int)e2.getX();
			int y1 = (int)e1.getY();
			int y2 = (int)e2.getY();
			int dist = x2 - x1;
			int adist = dist > 0 ? dist : -dist;
			int ydist = y2 - y1;
			int aydist = ydist > 0 ? ydist : -ydist;
			int vel = (int)velocityX;
			if (vel<0)
				vel = -vel;
			if (vel > thresholdVelocity && adist > thresholdDistance && adist > aydist * 2) {
				if (dist > 0) {
					Log.d(""cr3"", ""LTR fling detected"");
					if (ltrHandler != null) {
						ltrHandler.run();
						return true;
					}
				} else {
					Log.d(""cr3"", ""RTL fling detected"");
					if (rtlHandler != null) {
						rtlHandler.run();
						return true;
					}
				}
			}
			return false;
		}
		
	}
	
	protected View view;
}
",True,6,49,0,0,3,24,12,3,L0
18,org.coolreader.crengine.InterfaceTheme.java,"package org.coolreader.crengine;

import org.coolreader.R;

public class InterfaceTheme {

	public final static InterfaceTheme BLACK = new InterfaceTheme(""BLACK"", R.style.Theme_Black, R.style.Theme_Black_Dialog_Normal, R.style.Theme_Black_Dialog_Fullscreen, R.string.options_app_ui_theme_black);
	
	public final static InterfaceTheme WHITE = new InterfaceTheme(""WHITE"", R.style.Theme_White, R.style.Theme_White_Dialog_Normal, R.style.Theme_White_Dialog_Fullscreen, R.string.options_app_ui_theme_white);

	public final static InterfaceTheme LIGHT = new InterfaceTheme(""LIGHT"", R.style.Theme_Light, R.style.Theme_Light_Dialog_Normal, R.style.Theme_Light_Dialog_Fullscreen, R.string.options_app_ui_theme_light);
	
	public final static InterfaceTheme DARK = new InterfaceTheme(""DARK"", R.style.Theme_Dark, R.style.Theme_Dark_Dialog_Normal, R.style.Theme_Dark_Dialog_Fullscreen, R.string.options_app_ui_theme_dark);
	
	public String getCode() {
		return code;
	}
	public int getThemeId() {
		return themeId;
	}
	public int getDialogThemeId() {
		return dialogThemeId;
	}
	public int getFullscreenDialogThemeId() {
		return fsDialogThemeId;
	}
	public int getDisplayNameResourceId() {
		return displayNameResourceId;
	}
	
	
	public final static InterfaceTheme[] allThemes = {
		BLACK, WHITE, DARK, LIGHT,
	};
	
	public static InterfaceTheme findByCode(String code) {
		if (code == null)
			return null;
		for (InterfaceTheme t : allThemes)
			if (t.getCode().equals(code))
				return t;
		return null;
	}
	
	private final String code;
	private final int themeId;
	private final int dialogThemeId;
	private final int fsDialogThemeId;
	private final int displayNameResourceId;
	private InterfaceTheme(String code, int themeId, int dialogThemeId, int fsDialogThemeId, int displayNameResourceId) {
		this.code = code;
		this.themeId = themeId;
		this.dialogThemeId = dialogThemeId;
		this.fsDialogThemeId = fsDialogThemeId;
		this.displayNameResourceId = displayNameResourceId;
	}
}
",False,19,30,5,20,0,0,3,0,L0
19,org.coolreader.crengine.DocView.java,"package org.coolreader.crengine;

import android.graphics.Bitmap;

public class DocView {

	public static final Logger log = L.create(""dv"");

	public static final int SWAP_DONE = 0;
	public static final int SWAP_TIMEOUT = 1;
	public static final int SWAP_ERROR = 2;

	/**
	 * Create native object.
	 */
	public void create() {
		createInternal();
	}

	/**
	 * Destroy native object.
	 */
	public void destroy() {
		destroyInternal();
	}

	/**
	 * Set document callback.
	 * @param readerCallback is callback to set
	 */
	public void setReaderCallback(ReaderCallback readerCallback) {
		this.readerCallback = readerCallback;
	}

	/**
	 * If document uses cache file, swap all unsaved data to it.
	 * @return either SWAP_DONE, SWAP_TIMEOUT, SWAP_ERROR
	 */
	public int swapToCache() {
		return swapToCacheInternal();
	}

	/**
	 * Follow link.
	 * @param link
	 * @return
	 */
	public int goLink(String link) {
		return goLinkInternal(link);
	}
	
	/**
	 * Find a link near to specified window coordinates.
	 * @param x
	 * @param y
	 * @param delta
	 * @return
	 */
	public String checkLink(int x, int y, int delta) {
		return checkLinkInternal(x, y, delta);
	}
	
	/**
	 * Set selection range.
	 * @param sel
	 */
	public void updateSelection(Selection sel) {
		updateSelectionInternal(sel);
	}

	/**
	 * Move selection.
	 * @param sel
	 * @param moveCmd
	 * @param params
	 * @return
	 */
	public boolean moveSelection(Selection sel,
			int moveCmd, int params) {
		return moveSelectionInternal(sel, moveCmd, params);
	}

	/**
	 * Send battery state to native object.
	 * @param state
	 */
	public void setBatteryState(int state) {
		setBatteryStateInternal(state);
	}

	/**
	 * Get current book coverpage data bytes.
	 * @return
	 */
	public byte[] getCoverPageData() {
		return getCoverPageDataInternal();
	}

	/**
	 * Set texture for page background.
	 * @param imageBytes
	 * @param tileFlags
	 */
	public void setPageBackgroundTexture(
			byte[] imageBytes, int tileFlags) {
		setPageBackgroundTextureInternal(imageBytes, tileFlags);
	}

	/**
	 * Load document from file.
	 * @param fileName
	 * @return
	 */
	public boolean loadDocument(String fileName) {
		return loadDocumentInternal(fileName);
	}

	/**
	 * Get settings from native object.
	 * @return
	 */
	public java.util.Properties getSettings() {
		return getSettingsInternal();
	}

	/**
	 * Apply settings.
	 * @param settings
	 * @return
	 */
	public boolean applySettings(java.util.Properties settings) {
		return applySettingsInternal(settings);
	}

	/**
	 * Set stylesheet for document.
	 * @param stylesheet
	 */
	public void setStylesheet(String stylesheet) {
		setStylesheetInternal(stylesheet);
	}

	/**
	 * Change window size.
	 * @param dx
	 * @param dy
	 */
	public void resize(int dx, int dy) {
		resizeInternal(dx, dy);
	}

	/**
	 * Execute command by native object.
	 * @param command
	 * @param param
	 * @return
	 */
	public boolean doCommand(int command, int param) {
		return doCommandInternal(command, param);
	}

	/**
	 * Get current page bookmark info.
	 * @return
	 */
	public Bookmark getCurrentPageBookmark() {
		return getCurrentPageBookmarkInternal();
	}

	/**
	 * Move reading position to specified xPath.
	 * @param xPath
	 * @return
	 */
	public boolean goToPosition(String xPath) {
		return goToPositionInternal(xPath);
	}

	/**
	 * Get position properties by xPath.
	 * @param xPath
	 * @return
	 */
	public PositionProperties getPositionProps(String xPath) {
		return getPositionPropsInternal(xPath);
	}

	/**
	 * Fill book info fields using metadata from current book. 
	 * @param info
	 */
	public void updateBookInfo(BookInfo info) {
		updateBookInfoInternal(info);
	}

	/**
	 * Get TOC tree from current book.
	 * @return
	 */
	public TOCItem getTOC() {
		return getTOCInternal();
	}

	/**
	 * Clear selection.
	 */
	public void clearSelection() {
		clearSelectionInternal();
	}

	/**
	 * Find text in book.
	 * @param pattern
	 * @param origin
	 * @param reverse
	 * @param caseInsensitive
	 * @return
	 */
	public boolean findText(String pattern, int origin,
			int reverse, int caseInsensitive) {
		return findTextInternal(pattern, origin, reverse, caseInsensitive);
	}

	/**
	 * Get current page image.
	 * @param bitmap is buffer to put data to.
	 */
	public void getPageImage(Bitmap bitmap) {
		getPageImageInternal(bitmap, DeviceInfo.EINK_SCREEN ? 4 : 32);
	}

	/**
	 * Check whether point of current document contains image.
	 * If image is found, image becomes current image to be drawn by drawImage(), dstImage fields are set to image dimension.
	 *  
	 * @param x is X coordinate in document window
	 * @param y is Y coordinate in document window
	 * @param dstImage is to place found image dimensions to
	 * @return true if point belongs to image
	 */
	public boolean checkImage(int x, int y, ImageInfo dstImage) {
		return checkImageInternal(x, y, dstImage);
	}

	/**
	 * Check whether point of current document belongs to bookmark.
	 *  
	 * @param x is X coordinate in document window
	 * @param y is Y coordinate in document window
	 * @return bookmark if point belongs to bookmark, null otherwise
	 */
	public Bookmark checkBookmark(int x, int y) {
		Bookmark dstBookmark = new Bookmark();
		if (checkBookmarkInternal(x, y, dstBookmark)) {
			return dstBookmark;
		}
		return null;
	}
	
	
	/**
	 * Draws currently opened image to bitmap.
	 * @param bitmap is destination bitmap
	 * @param imageInfo contains image position and scaling parameters.
	 * @return true if current image is drawn successfully.
	 */
	public boolean drawImage(Bitmap bitmap, ImageInfo imageInfo) {
		return drawImageInternal(bitmap, DeviceInfo.EINK_SCREEN ? 4 : 32, imageInfo);
	}

	/**
	 * Close currently opened image, free resources.
	 * @return true if there was opened current image, and it's now closed 
	 */
	public boolean closeImage() {
		return closeImageInternal();
	}
	
	/**
	 * Highlight bookmarks.
	 * Remove highlight using clearSelection().
	 * @params bookmarks is array of bookmarks to highlight 
	 */
	public void hilightBookmarks(Bookmark[] bookmarks) {
		hilightBookmarksInternal(bookmarks);
	}
	
	//========================================================================================
	// Native functions
	/* implementend by libcr3engine.so */
	//========================================================================================
	private native void getPageImageInternal(Bitmap bitmap, int bpp);

	private native void createInternal();

	private native void destroyInternal();

	private native boolean loadDocumentInternal(String fileName);

	private native java.util.Properties getSettingsInternal();

	private native boolean applySettingsInternal(
			java.util.Properties settings);

	private native void setStylesheetInternal(String stylesheet);

	private native void resizeInternal(int dx, int dy);

	private native boolean doCommandInternal(int command, int param);

	private native Bookmark getCurrentPageBookmarkInternal();

	private native boolean goToPositionInternal(String xPath);

	private native PositionProperties getPositionPropsInternal(String xPath);
	
	private native void updateBookInfoInternal(BookInfo info);

	private native TOCItem getTOCInternal();

	private native void clearSelectionInternal();

	private native boolean findTextInternal(String pattern, int origin,
			int reverse, int caseInsensitive);

	private native void setBatteryStateInternal(int state);

	private native byte[] getCoverPageDataInternal();

	private native void setPageBackgroundTextureInternal(
			byte[] imageBytes, int tileFlags);

	private native void updateSelectionInternal(Selection sel);

	private native boolean moveSelectionInternal(Selection sel,
			int moveCmd, int params);

	private native String checkLinkInternal(int x, int y, int delta);

	private native boolean checkImageInternal(int x, int y, ImageInfo dstImage);

	private native boolean checkBookmarkInternal(int x, int y, Bookmark dstBookmark);

	private native boolean drawImageInternal(Bitmap bitmap, int bpp, ImageInfo dstImage);

	private native boolean closeImageInternal();

	private native int goLinkInternal(String link);

	private native void hilightBookmarksInternal(Bookmark[] bookmarks);

	// / returns either SWAP_DONE, SWAP_TIMEOUT or SWAP_ERROR
	private native int swapToCacheInternal();

	private int mNativeObject; // used from JNI

	private ReaderCallback readerCallback;

}
",True,10,49,0,0,5,22,1,10,L0
20,org.coolreader.crengine.TTSToolbarDlg.java,"package org.coolreader.crengine;

import java.util.HashMap;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.ReaderView.ReaderCommand;

import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.ImageButton;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;

public class TTSToolbarDlg implements TTS.OnUtteranceCompletedListener {
	PopupWindow mWindow;
	View mAnchor;
	CoolReader mCoolReader;
	ReaderView mReaderView;
	View mPanel;
	TTS mTTS;
	ImageButton playPauseButton; 
	SeekBar sbSpeed;
	SeekBar sbVolume;
	
	static public void showDialog( CoolReader coolReader, ReaderView readerView, TTS tts)
	{
		TTSToolbarDlg dlg = new TTSToolbarDlg(coolReader, readerView, tts);
		//dlg.mWindow.update(dlg.mAnchor, width, height)
		Log.d(""cr3"", ""popup: "" + dlg.mWindow.getWidth() + ""x"" + dlg.mWindow.getHeight());
		//dlg.update();
		//dlg.showAtLocation(readerView, Gravity.LEFT|Gravity.TOP, readerView.getLeft()+50, readerView.getTop()+50);
		//dlg.showAsDropDown(readerView);
		//dlg.update();
	}

	private boolean closed; 
	public void stopAndClose() {
		if (closed)
			return;
		isSpeaking = false;
		closed = true;
		BackgroundThread.instance().executeGUI(new Runnable() {
			@Override
			public void run() {
				stop();
				restoreReaderMode();
				mReaderView.clearSelection();
				if ( mWindow.isShowing() )
					mWindow.dismiss();
			}
		});
	}
	
	private boolean changedPageMode;
	private void setReaderMode()
	{
		String oldViewSetting = mReaderView.getSetting( ReaderView.PROP_PAGE_VIEW_MODE );
		if ( ""1"".equals(oldViewSetting) ) {
			changedPageMode = true;
			mReaderView.setSetting(ReaderView.PROP_PAGE_VIEW_MODE, ""0"");
		}
		moveSelection( ReaderCommand.DCMD_SELECT_FIRST_SENTENCE );
	}
	
	private void restoreReaderMode()
	{
		if ( changedPageMode ) {
			mReaderView.setSetting(ReaderView.PROP_PAGE_VIEW_MODE, ""1"");
		}
	}
	
	private Selection currentSelection;
	
	private void moveSelection( ReaderCommand cmd )
	{
		mReaderView.moveSelection(cmd, 0, new ReaderView.MoveSelectionCallback() {
			
			@Override
			public void onNewSelection(Selection selection) {
				Log.d(""cr3"", ""onNewSelection: "" + selection.text);
				currentSelection = selection;
				if ( isSpeaking )
					say( currentSelection );
			}
			
			@Override
			public void onFail() {
				Log.d(""cr3"", ""fail()"");
				stop();
				//currentSelection = null;
			}
		});
	}
	
	private void say( Selection selection ) {
		HashMap<String, String> params = new HashMap<String, String>();
		params.put(TTS.KEY_PARAM_UTTERANCE_ID, ""cr3UtteranceId"");
		mTTS.speak(selection.text, TTS.QUEUE_ADD, params);
	}
	
	private void start() {
		if ( currentSelection==null )
			return;
		isSpeaking = true;
		say( currentSelection );
	}
	
	private boolean isSpeaking; 
	private void stop() {
		isSpeaking = false;
		if ( mTTS.isSpeaking() ) {
			mTTS.stop();
		}
	}
	
	private void toggleStartStop() {
		if ( isSpeaking ) {
			playPauseButton.setImageResource(R.drawable.ic_media_play);
			stop();
		} else {
			playPauseButton.setImageResource(R.drawable.ic_media_pause);
			start();
		}
	}
	
	@Override
	public void onUtteranceCompleted(String utteranceId) {
		Log.d(""cr3"", ""onUtteranceCompleted "" + utteranceId);
		if ( isSpeaking )
			moveSelection( ReaderCommand.DCMD_SELECT_NEXT_SENTENCE );
	}

	public TTSToolbarDlg( CoolReader coolReader, ReaderView readerView, TTS tts )
	{
		mCoolReader = coolReader;
		mReaderView = readerView;
		mAnchor = readerView;
		mTTS = tts;
		mTTS.setOnUtteranceCompletedListener(this);

		View panel = (LayoutInflater.from(coolReader.getApplicationContext()).inflate(R.layout.tts_toolbar, null));
		playPauseButton = (ImageButton)panel.findViewById(R.id.tts_play_pause);
		playPauseButton.setImageResource(R.drawable.ic_media_play);
		//panel.measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		panel.measure(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		
		//mReaderView.getS
		
		mWindow = new PopupWindow( mAnchor.getContext() );
//		mWindow.setFocusable(true);
//		mWindow.setTouchable(true);
//		mWindow.setOutsideTouchable(true);
		mWindow.setBackgroundDrawable(new BitmapDrawable());
//		mWindow.setTouchInterceptor(new OnTouchListener() {
//			@Override
//			public boolean onTouch(View v, MotionEvent event) {
////				if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
////					stopAndClose();
////					return true;
////				}
//				return true;
//			}
//		});
		//super(panel);
		mPanel = panel;
		mPanel.findViewById(R.id.tts_play_pause).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				toggleStartStop();
			}
		});
		mPanel.findViewById(R.id.tts_back).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				if ( isSpeaking ) {
					isSpeaking = false;
					mTTS.stop();
					isSpeaking = true;
				}
				moveSelection( ReaderCommand.DCMD_SELECT_PREV_SENTENCE );
			}
		});
		mPanel.findViewById(R.id.tts_forward).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				if ( isSpeaking ) {
					isSpeaking = false;
					mTTS.stop();
					isSpeaking = true;
				}
				moveSelection( ReaderCommand.DCMD_SELECT_NEXT_SENTENCE );
			}
		});
		mPanel.findViewById(R.id.tts_stop).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				stopAndClose();
			}
		});
		mPanel.setFocusable(true);
		mPanel.setEnabled(true);
		mPanel.setOnKeyListener( new OnKeyListener() {

			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ( event.getAction()==KeyEvent.ACTION_UP ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_VOLUME_DOWN:
					case KeyEvent.KEYCODE_VOLUME_UP:
						return true;
					case KeyEvent.KEYCODE_BACK:
						stopAndClose();
						return true;
//					case KeyEvent.KEYCODE_DPAD_LEFT:
//					case KeyEvent.KEYCODE_DPAD_UP:
//						//mReaderView.findNext(pattern, true, caseInsensitive);
//						return true;
//					case KeyEvent.KEYCODE_DPAD_RIGHT:
//					case KeyEvent.KEYCODE_DPAD_DOWN:
//						//mReaderView.findNext(pattern, false, caseInsensitive);
//						return true;
					}
				} else if ( event.getAction()==KeyEvent.ACTION_DOWN ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_VOLUME_DOWN: {
						int p = sbVolume.getProgress() - 5;
						if ( p<0 )
							p = 0;
						sbVolume.setProgress(p);
						return true;
					}
					case KeyEvent.KEYCODE_VOLUME_UP:
						int p = sbVolume.getProgress() + 5;
						if ( p>100 )
							p = 100;
						sbVolume.setProgress(p);
						return true;
					}
					if ( keyCode == KeyEvent.KEYCODE_BACK) {
						return true;
					}
				}
				return false;
			}
			
		});

		mWindow.setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss() {
				if ( !closed )
					stopAndClose();
			}
		});
		
		mWindow.setBackgroundDrawable(new BitmapDrawable());
		//mWindow.setAnimationStyle(android.R.style.Animation_Toast);
		//mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
		mWindow.setWidth(WindowManager.LayoutParams.FILL_PARENT);
		mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
//		setWidth(panel.getWidth());
//		setHeight(panel.getHeight());
		
		mWindow.setFocusable(true);
		mWindow.setTouchable(true);
		mWindow.setOutsideTouchable(true);
		mWindow.setContentView(panel);
		
		
		int [] location = new int[2];
		mAnchor.getLocationOnScreen(location);
		//mWindow.update(location[0], location[1], mPanel.getWidth(), mPanel.getHeight() );
		//mWindow.setWidth(mPanel.getWidth());
		//mWindow.setHeight(mPanel.getHeight());

		mWindow.showAtLocation(mAnchor, Gravity.TOP | Gravity.CENTER_HORIZONTAL, location[0], location[1] + mAnchor.getHeight() - mPanel.getHeight());
//		if ( mWindow.isShowing() )
//			mWindow.update(mAnchor, 50, 50);
		//dlg.mWindow.showAsDropDown(dlg.mAnchor);
		
		setReaderMode();

		// setup speed && volume seek bars
		sbSpeed = (SeekBar)mPanel.findViewById(R.id.tts_sb_speed);
		sbVolume = (SeekBar)mPanel.findViewById(R.id.tts_sb_volume);
		
		sbSpeed.setMax(100);
		sbSpeed.setProgress(50);
		sbVolume.setMax(100);
		sbVolume.setProgress(mCoolReader.getVolume());
		sbSpeed.setOnSeekBarChangeListener( new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				float rate = 1.0f;
				if ( progress<50 )
					rate = 0.3f + 0.7f * progress / 50f;
				else
					rate = 1.0f + 1.5f * (progress-50) / 50f;
				mTTS.setSpeechRate(rate);
			}

			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
			}
		});

		sbVolume.setOnSeekBarChangeListener( new OnSeekBarChangeListener() {
			@Override
			public void onProgressChanged(SeekBar seekBar, int progress,
					boolean fromUser) {
				mCoolReader.setVolume(progress);
			}

			@Override
			public void onStartTrackingTouch(SeekBar seekBar) {
			}

			@Override
			public void onStopTrackingTouch(SeekBar seekBar) {
			}
		});
		
		mPanel.requestFocus();
	}
	
}
",True,14,49,0,0,3,34,1,6,L0
21,org.coolreader.crengine.Logger.java,"package org.coolreader.crengine;

public interface Logger {
	public void i(String msg); 
	public void i(String msg, Exception e); 
	public void w(String msg); 
	public void w(String msg, Exception e); 
	public void e(String msg); 
	public void e(String msg, Exception e); 
	public void d(String msg); 
	public void d(String msg, Exception e); 
	public void v(String msg); 
	public void v(String msg, Exception e);
	public void setLevel( int level );
}
",False,13,30,2,22,0,0,7,0,L0
22,org.coolreader.crengine.OptionOwner.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;

import android.view.LayoutInflater;

public interface OptionOwner {
	public CoolReader getActivity();
	public Properties getProperties();
	public LayoutInflater getInflater();
}
",False,46,49,0,0,3,23,2,2,L0
23,org.coolreader.crengine.OPDSUtil.java,"package org.coolreader.crengine;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URL;
import java.net.URLConnection;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Stack;
import java.util.concurrent.Callable;

import javax.net.ssl.HttpsURLConnection;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.coolreader.CoolReader;
import org.coolreader.crengine.Engine.DelayedProgress;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import android.util.Log;

public class OPDSUtil {

    public static final int CONNECT_TIMEOUT = 60000;
    public static final int READ_TIMEOUT = 60000;
	/*
<?xml version=""1.0"" encoding=""utf-8""?>
<feed xmlns:opensearch=""http://a9.com/-/spec/opensearch/1.1/"" xmlns:relevance=""http://a9.com/-/opensearch/extensions/relevance/1.0/"" 
xmlns=""http://www.w3.org/2005/Atom"" 
xml:base=""http://lib.ololo.cc/opds/"">
<id>http://lib.ololo.cc/opds/</id>
<updated>2011-05-31T10:28:22+04:00</updated>
<title>OPDS: lib.ololo.cc</title>
<subtitle>Librusec mirror.</subtitle>
<author>
  <name>ololo team</name>
  <uri>http://lib.ololo.cc</uri><email>libololo@gmail.com</email>
</author>
<icon>http://lib.ololo.cc/book.png</icon>
<link rel=""self"" title=""This Page"" type=""application/atom+xml"" href=""/opds/""/>
<link rel=""alternate"" type=""text/html"" title=""HTML Page"" href=""/""/>
<entry>
   <updated>2011-05-31T10:28:22+04:00</updated>
   <id>http://lib.ololo.cc/opds/asearch/</id>
   <title>Авторы</title>
   <content type=""text"">Поиск по авторам</content>
   <link type=""application/atom+xml"" href=""http://lib.ololo.cc/opds/asearch/""/>
</entry>
</feed>
	 */
	/**
	 * Callback interface for OPDS.
	 */
	public interface DownloadCallback {
		/**
		 * Some entries are downloaded.
		 * @param doc is document
		 * @param entries is list of entries to add
		 */
		public void onEntries( DocInfo doc, Collection<EntryInfo> entries );
		/**
		 * All entries are downloaded.
		 * @param doc is document
		 * @param entries is list of entries to add
		 */
		public void onFinish( DocInfo doc, Collection<EntryInfo> entries );
		/**
		 * Before download: request filename to save as.
		 */
		public File onDownloadStart( String type, String url );
		/**
		 * Download progress
		 */
		public void onDownloadProgress( String type, String url, int percent );
		/**
		 * Book is downloaded.
		 */
		public void onDownloadEnd( String type, String url, File file );
		/**
		 * Error occured
		 */
		public void onError( String message );
	}
	
	public static class DocInfo {
		public String id;
		public long updated;
		public String title;
		public String subtitle;
		public String icon;
		public LinkInfo selfLink;
		public LinkInfo alternateLink;
		public LinkInfo nextLink;
	}
	
	public static String dirPath(String filePath) {
		int pos = filePath.lastIndexOf(""/"");
		if (pos < 0)
			return filePath;
		return filePath.substring(0, pos+1);
	}
	
	public static class LinkInfo {
		public String href;
		public String rel;
		public String title;
		public String type;
		public LinkInfo( URL baseURL, Attributes attributes ) {
			rel = attributes.getValue(""rel"");
			type = attributes.getValue(""type"");
			title = attributes.getValue(""title"");
			href = convertHref( baseURL, attributes.getValue(""href"") );
		}
		public static String convertHref( URL baseURL, String href ) {
			if ( href==null )
				return href;
			if ( href.startsWith(""/"") )
				return baseURL.getProtocol() + ""://"" + baseURL.getHost() + href;
			if ( !href.startsWith(""http://"") ) {
				return baseURL.getProtocol() + ""://"" + baseURL.getHost() + dirPath(baseURL.getPath()) + ""/"" + href;
			}
			return href;
		}
		public boolean isValid() {
			return href!=null && href.length()!=0;
		}
		public int getPriority() {
			if ( type==null )
				return 0;
			DocumentFormat df = DocumentFormat.byMimeType(type);
			if ( rel!=null && rel.indexOf(""acquisition"")<0 && df!=DocumentFormat.FB2 && df!=DocumentFormat.EPUB 
					&& df!=DocumentFormat.RTF && df!=DocumentFormat.DOC)
				return 0;
			return df!=null ? df.getPriority() : 0;
		}
		@Override
		public String toString() {
			return ""[ rel="" + rel + "", type="" + type
					+ "", title="" + title + "", href="" + href + ""]"";
		}
		
	}
	
	public static class AuthorInfo {
		public String name;
		public String uri;
	}
	
	public static class EntryInfo {
		public String id;
		public long updated;
		public String title="""";
		public String content="""";
		public String summary="""";
		public LinkInfo link;
		public ArrayList<LinkInfo> links = new ArrayList<LinkInfo>();
		public String icon;
		public ArrayList<String> categories = new ArrayList<String>(); 
		public ArrayList<AuthorInfo> authors = new ArrayList<AuthorInfo>(); 
		public LinkInfo getBestAcquisitionLink() {
			LinkInfo best = null;
			int bestPriority = 0; 
			for ( LinkInfo link : links ) {
				//boolean isAcquisition = link.rel!=null && link.rel.indexOf(""acquisition"")>=0;
				int priority = link.getPriority();
				if (priority>0 && priority>bestPriority) {
					if ( link.getPriority()>0 && (best==null || best.getPriority()<link.getPriority()) ) {
						best = link;
						bestPriority = priority;
					}
				}
			}
			return best;
		}
		public String getAuthors() {
			if ( authors.size()==0 )
				return null;
			StringBuilder buf = new StringBuilder(100);
			for ( AuthorInfo a : authors ) {
				if ( buf.length()>0 )
					buf.append("", "");
				buf.append(a.name);
			}
			return buf.toString();
		}
	}
	
	public static class OPDSHandler extends DefaultHandler {
		private URL url;
		private DocInfo docInfo = new DocInfo(); 
		private EntryInfo entryInfo = new EntryInfo(); 
		private ArrayList<EntryInfo> entries = new ArrayList<EntryInfo>(); 
		private Stack<String> elements = new Stack<String>();
		//private Attributes currentAttributes;
		private AuthorInfo authorInfo;
		private boolean insideFeed;
		private boolean insideEntry;
		//private boolean singleEntry;
		private int level = 0;
		//2011-05-31T10:28:22+04:00
		private static SimpleDateFormat tsFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ""); 
		private static SimpleDateFormat tsFormat2 = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"");
		public OPDSHandler( URL url ) {
			this.url = url;
		}
		public void setUrl(URL url) {
			this.url = url;
		}
		private long parseTimestamp( String ts ) {
			if ( ts==null )
				return 0;
			ts = ts.trim();
			try {
				if ( ts.length()==""2010-01-10T10:01:10Z"".length() )
					return tsFormat2.parse(ts).getTime();
				if ( ts.length()==""2011-11-11T11:11:11+67:87"".length()&& ts.lastIndexOf("":"")==ts.length()-3 ) {
					ts = ts.substring(0, ts.length()-3) + ts.substring(0, ts.length()-2);
					return tsFormat.parse(ts).getTime();
				}
				if ( ts.length()==""2011-11-11T11:11:11+6787"".length()) {
					return tsFormat.parse(ts).getTime();
				}
			} catch (ParseException e) {
			}
			L.e(""cannot parse timestamp "" + ts);
			return 0;
		}
		
		@Override
		public void characters(char[] ch, int start, int length)
				throws SAXException {
			super.characters(ch, start, length);
			
			String s = new String( ch, start, length);
			s = s.trim();
			if (s.length()==0 || (s.length()==1 && s.charAt(0) == '\n') )
				return; // ignore empty line
			L.d(tab() + ""  {"" + s + ""}"");
			String currentElement = elements.peek();
			if ( currentElement==null )
				return;
			if ( insideFeed ) {
				if ( ""id"".equals(currentElement) ) {
					if ( insideEntry )
						entryInfo.id = s;
					else
						docInfo.id = s;
				} else if ( ""updated"".equals(currentElement) ) {
					long ts = parseTimestamp(s);
					if ( insideEntry )
						entryInfo.updated = ts;
					else
						docInfo.updated = ts;
				} else if ( ""title"".equals(currentElement) ) {
					if ( !insideEntry )
						docInfo.title = s;
					else
						entryInfo.title = entryInfo.title + s;
				} else if ( ""summary"".equals(currentElement) ) {
					if ( insideEntry )
						entryInfo.summary = entryInfo.summary + s;
				} else if ( ""name"".equals(currentElement) ) {
					if ( authorInfo!=null )
						authorInfo.name = s;
				} else if ( ""uri"".equals(currentElement) ) {
					if ( authorInfo!=null )
						authorInfo.uri = s;
				} else if ( ""icon"".equals(currentElement) ) {
					if ( !insideEntry )
						docInfo.icon = s;
					else
						entryInfo.icon = s;
				} else if ( ""link"".equals(currentElement) ) {
					// rel, type, title, href
					if ( !insideEntry )
						docInfo.icon = s;
					else
						entryInfo.icon = s;
				} else if ( ""content"".equals(currentElement) ) {
					if ( insideEntry )
						entryInfo.content = entryInfo.content + s;
				} else if ( ""subtitle"".equals(currentElement) ) {
					if ( !insideEntry )
						docInfo.subtitle = s;
				}
			}
		}

		@Override
		public void endDocument() throws SAXException {
			super.endDocument();
			L.d(""endDocument: "" + entries.size() + "" entries parsed"");
			for ( EntryInfo entry : entries ) {
				L.d(""   "" + entry.title + "" : "" + entry.link.toString());
			}
		}

		private String tab() {
			if ( level<=1 )
				return """";
			StringBuffer buf = new StringBuffer(level*2);
			for ( int i=1; i<level; i++ )
				buf.append(""  "");
			return buf.toString();
		}
		
		@Override
		public void startElement(String uri, String localName,
				String qName, Attributes attributes)
				throws SAXException {
			super.startElement(uri, localName, qName, attributes);
			if ( qName!=null && qName.length()>0 )
				localName = qName;
			level++;
			L.d(tab() + ""<"" + localName + "">"");
			//currentAttributes = attributes;
			elements.push(localName);
			//String currentElement = elements.peek();
			if ( !insideFeed && ""feed"".equals(localName) ) {
				insideFeed = true;
			} else if ( ""entry"".equals(localName) ) {
				if ( !insideFeed ) {
					insideFeed = true;
					//singleEntry = true;
				}
				insideEntry = true;
				entryInfo = new EntryInfo();
			} else if ( ""category"".equals(localName) ) {
				if ( insideEntry ) {
					String category = attributes.getValue(""label"");
					if ( category!=null )
						entryInfo.categories.add(category);
				}
			} else if ( ""id"".equals(localName) ) {
				
			} else if ( ""updated"".equals(localName) ) {
				
			} else if ( ""title"".equals(localName) ) {
				
			} else if ( ""link"".equals(localName) ) {
				LinkInfo link = new LinkInfo(url, attributes);
				if ( link.isValid() && insideFeed ) {
					L.d(tab()+link.toString());
					if ( insideEntry ) {
						if ( link.type!=null ) {
							entryInfo.links.add(link);
							int priority = link.getPriority();
							if ( link.type.startsWith(""application/atom+xml"") ) {
								entryInfo.link = link;
							} else if (priority>0 && (entryInfo.link==null || entryInfo.link.getPriority()<priority)) {
								entryInfo.link = link;
							}
						}
					} else {
						if ( ""self"".equals(link.rel) )
							docInfo.selfLink = link;
						else if ( ""alternate"".equals(link.rel) )
							docInfo.alternateLink = link;
						else if ( ""next"".equals(link.rel) )
							docInfo.nextLink = link;
					}
				}
			} else if ( ""author"".equals(localName) ) {
				authorInfo = new AuthorInfo();
			}
		}
		
		@Override
		public void endElement(String uri, String localName,
				String qName) throws SAXException {
			super.endElement(uri, localName, qName);
			if ( qName!=null && qName.length()>0 )
				localName = qName;
			L.d(tab() + ""</"" + localName + "">"");
			//String currentElement = elements.peek();
			if ( insideFeed && ""feed"".equals(localName) ) {
				insideFeed = false;
			} else if ( ""entry"".equals(localName) ) {
				if ( !insideFeed || !insideEntry )
					throw new SAXException(""unexpected element "" + localName);
				if ( entryInfo.link!=null || entryInfo.getBestAcquisitionLink()!=null ) {
					entries.add(entryInfo);
				}
				insideEntry = false;
				entryInfo = null;
			} else if ( ""author"".equals(localName) ) {
				if ( authorInfo!=null && authorInfo.name!=null )
					entryInfo.authors.add(authorInfo);
				authorInfo = null;
			} 
			//currentAttributes = null;
			if ( level>0 )
				level--;
		}

		@Override
		public void startDocument() throws SAXException {
			// TODO Auto-generated method stub
			super.startDocument();
		}

	}
	
	public static class DownloadTask {
		final private CoolReader coolReader; 
		private URL url;
		final private String expectedType;
		final private String referer;
		final private String defaultFileName;
		final private DownloadCallback callback;
		private String progressMessage = ""Dowloading..."";
		private HttpURLConnection connection;
		private DelayedProgress delayedProgress;
		OPDSHandler handler;
		public DownloadTask( CoolReader coolReader, URL url, String defaultFileName, String expectedType, String referer, DownloadCallback callback ) {
			this.url = url;
			this.coolReader = coolReader;
			this.callback = callback; 
			this.referer = referer;
			this.expectedType = expectedType;
			this.defaultFileName = defaultFileName;
			Log.d(""cr3"", ""Created DownloadTask for "" + url);
		}
		private void setProgressMessage( String url, int totalSize ) {
			progressMessage = coolReader.getString(org.coolreader.R.string.progress_downloading) + "" "" + url;
			if ( totalSize>0 )
				progressMessage = progressMessage + "" ("" + totalSize + "")"";
		}
		private void onError(final String msg) {
			BackgroundThread.guiExecutor.execute(new Runnable() {
				@Override
				public void run() {
					if ( delayedProgress!=null ) {
						delayedProgress.cancel();
						delayedProgress.hide();
					}
					if (coolReader.getEngine() != null)
						coolReader.getEngine().hideProgress();
					callback.onError(msg);
				}
			});
		}
		private void parseFeed( InputStream is ) throws Exception {
			try {
				if (handler==null)
					handler = new OPDSHandler(url);
				else
					handler.setUrl(url); // download next part
				String[] namespaces = new String[] { 
                        ""access"", ""http://www.bloglines.com/about/specs/fac-1.0"",
                        ""admin"", ""http://webns.net/mvcb/"",
                        ""ag"", ""http://purl.org/rss/1.0/modules/aggregation/"",
                        ""annotate"", ""http://purl.org/rss/1.0/modules/annotate/"",
                        ""app"", ""http://www.w3.org/2007/app"",
                        ""atom"", ""http://www.w3.org/2005/Atom"",
                        ""audio"", ""http://media.tangent.org/rss/1.0/"",
                        ""blogChannel"", ""http://backend.userland.com/blogChannelModule"",
                        ""cc"", ""http://web.resource.org/cc/"",
                        ""cf"", ""http://www.microsoft.com/schemas/rss/core/2005"",
                        ""company"", ""http://purl.org/rss/1.0/modules/company"",
                        ""content"", ""http://purl.org/rss/1.0/modules/content/"",
                        ""conversationsNetwork"", ""http://conversationsnetwork.org/rssNamespace-1.0/"",
                        ""cp"", ""http://my.theinfo.org/changed/1.0/rss/"",
                        ""creativeCommons"", ""http://backend.userland.com/creativeCommonsRssModule"",
                        ""dc"", ""http://purl.org/dc/elements/1.1/"",
                        ""dcterms"", ""http://purl.org/dc/terms/"",
                        ""email"", ""http://purl.org/rss/1.0/modules/email/"",
                        ""ev"", ""http://purl.org/rss/1.0/modules/event/"",
                        ""feedburner"", ""http://rssnamespace.org/feedburner/ext/1.0"",
                        ""fh"", ""http://purl.org/syndication/history/1.0"",
                        ""foaf"", ""http://xmlns.com/foaf/0.1/"",
                        ""foaf"", ""http://xmlns.com/foaf/0.1"",
                        ""geo"", ""http://www.w3.org/2003/01/geo/wgs84_pos#"",
                        ""georss"", ""http://www.georss.org/georss"",
                        ""geourl"", ""http://geourl.org/rss/module/"",
                        ""g"", ""http://base.google.com/ns/1.0"",
                        ""gml"", ""http://www.opengis.net/gml"",
                        ""icbm"", ""http://postneo.com/icbm"",
                        ""image"", ""http://purl.org/rss/1.0/modules/image/"",
                        ""indexing"", ""urn:atom-extension:indexing"",
                        ""itunes"", ""http://www.itunes.com/dtds/podcast-1.0.dtd"",
                        ""kml20"", ""http://earth.google.com/kml/2.0"",
                        ""kml21"", ""http://earth.google.com/kml/2.1"",
                        ""kml22"", ""http://www.opengis.net/kml/2.2"",
                        ""l"", ""http://purl.org/rss/1.0/modules/link/"",
                        ""mathml"", ""http://www.w3.org/1998/Math/MathML"",
                        ""media"", ""http://search.yahoo.com/mrss/"",
                        ""openid"", ""http://openid.net/xmlns/1.0"",
                        ""opensearch10"", ""http://a9.com/-/spec/opensearchrss/1.0/"",
                        ""opensearch"", ""http://a9.com/-/spec/opensearch/1.1/"",
                        ""opml"", ""http://www.opml.org/spec2"",
                        ""rdf"", ""http://www.w3.org/1999/02/22-rdf-syntax-ns#"",
                        ""rdfs"", ""http://www.w3.org/2000/01/rdf-schema#"",
                        ""ref"", ""http://purl.org/rss/1.0/modules/reference/"",
                        ""reqv"", ""http://purl.org/rss/1.0/modules/richequiv/"",
                        ""rss090"", ""http://my.netscape.com/rdf/simple/0.9/"",
                        ""rss091"", ""http://purl.org/rss/1.0/modules/rss091#"",
                        ""rss1"", ""http://purl.org/rss/1.0/"",
                        ""rss11"", ""http://purl.org/net/rss1.1#"",
                        ""search"", ""http://purl.org/rss/1.0/modules/search/"",
                        ""slash"", ""http://purl.org/rss/1.0/modules/slash/"",
                        ""ss"", ""http://purl.org/rss/1.0/modules/servicestatus/"",
                        ""str"", ""http://hacks.benhammersley.com/rss/streaming/"",
                        ""sub"", ""http://purl.org/rss/1.0/modules/subscription/"",
                        ""svg"", ""http://www.w3.org/2000/svg"",
                        ""sx"", ""http://feedsync.org/2007/feedsync"",
                        ""sy"", ""http://purl.org/rss/1.0/modules/syndication/"",
                        ""taxo"", ""http://purl.org/rss/1.0/modules/taxonomy/"",
                        ""thr"", ""http://purl.org/rss/1.0/modules/threading/"",
                        ""thr"", ""http://purl.org/syndication/thread/1.0"",
                        ""trackback"", ""http://madskills.com/public/xml/rss/module/trackback/"",
                        ""wfw"", ""http://wellformedweb.org/CommentAPI/"",
                        ""wiki"", ""http://purl.org/rss/1.0/modules/wiki/"",
                        ""xhtml"", ""http://www.w3.org/1999/xhtml"",
                        ""xlink"", ""http://www.w3.org/1999/xlink"",
                        ""xrd"", ""xri://$xrd*($v*2.0)"",
                        ""xrds"", ""xri://$xrds""
				};
				for ( int i=0; i<namespaces.length-1; i+=2 )
					handler.startPrefixMapping(namespaces[i], namespaces[i+1]);
				SAXParserFactory spf = SAXParserFactory.newInstance();
				spf.setValidating(false);
//				spf.setNamespaceAware(true);
//				spf.setFeature(""http://xml.org/sax/features/namespaces"", false);
				SAXParser sp = spf.newSAXParser();
				//XMLReader xr = sp.getXMLReader();				
				sp.parse(is, handler);
			} catch (SAXException se) {
				L.e(""sax error"", se);
				throw se;
			} catch (IOException ioe) {
				L.e(""sax parse io error"", ioe);
				throw ioe;
			}
		}
		
		private File generateFileName( File outDir, String fileName, String type, boolean isZip ) {
			DocumentFormat fmt = type!=null ? DocumentFormat.byMimeType(type) : null;
			//DocumentFormat fmtext = fileName!=null ? DocumentFormat.byExtension(fileName) : null;
			if ( fileName==null )
				fileName = ""noname"";
			String ext = null;
			if ( fileName.lastIndexOf(""."")>0 ) {
				ext = fileName.substring(fileName.lastIndexOf(""."")+1);
				fileName = fileName.substring(0, fileName.lastIndexOf("".""));
			}
			fileName = transcribeFileName( fileName );
			if ( fmt!=null ) {
				if ( fmt==DocumentFormat.FB2 && isZip )
					ext = "".fb2.zip"";
				else
					ext = fmt.getExtensions()[0].substring(1);
			}
			for (int i=0; i<1000; i++ ) {
				String fn = fileName + (i==0 ? """" : ""("" + i + "")"") + ""."" + ext; 
				File f = new File(outDir, fn);
				if ( !f.exists() && !f.isDirectory() )
					return f;
			}
			return null;
		}
		private void downloadBook( final String type, final String url, InputStream is, int contentLength, final String fileName, final boolean isZip ) throws Exception {
			L.d(""Download requested: "" + type + "" "" + url + "" "" + contentLength);
			DocumentFormat fmt = DocumentFormat.byMimeType(type);
			if ( fmt==null ) {
				L.d(""Download: unknown type "" + type);
				throw new Exception(""Unknown file type "" + type);
			}
			final File outDir = BackgroundThread.instance().callGUI(new Callable<File>() {
				@Override
				public File call() throws Exception {
					return callback.onDownloadStart(type, url);
				}
			});
			if ( outDir==null ) {
				L.d(""Cannot find writable location for downloaded file "" + url);
				throw new Exception(""Cannot save file "" + url);
			}
			final File outFile = generateFileName( outDir, fileName, type, isZip );
			if ( outFile==null ) {
				L.d(""Cannot generate file name"");
				throw new Exception(""Cannot generate file name"");
			}
			L.d(""Creating file: "" + outFile.getAbsolutePath());
			if ( outFile.exists() || !outFile.createNewFile() ) {
				L.d(""Cannot create file "" + outFile.getAbsolutePath());
				throw new Exception(""Cannot create file"");
			}
			
			L.d(""Download started: "" + outFile.getAbsolutePath());
//			long lastTs = System.currentTimeMillis(); 
//			int lastPercent = -1;
			FileOutputStream os = null;
			boolean success = false;
			try {
				os = new FileOutputStream(outFile);
				byte[] buf = new byte[16384];
				int totalWritten = 0;
				while (totalWritten<contentLength || contentLength==-1) {
					int bytesRead = is.read(buf);
					if ( bytesRead<=0 )
						break;
					os.write(buf, 0, bytesRead);
					totalWritten += bytesRead;
//					final int percent = totalWritten * 100 / contentLength;
//					long ts = System.currentTimeMillis(); 
//					if ( percent!=lastPercent && ts - lastTs > 1500 ) {
//						L.d(""Download progress: "" + percent + ""%"");
//						BackgroundThread.instance().postGUI(new Runnable() {
//							@Override
//							public void run() {
//								callback.onDownloadProgress(type, url, percent);
//							}
//						});
//					}
				}
				success = true;
			} finally {
				if ( os!=null )
					os.close();
				if ( !success ) {
					if ( outFile.exists() && outFile.isFile() ) {
						L.w(""deleting unsuccessully downloaded file "" + outFile);
						outFile.delete();
					}
				}
			}
			L.d(""Download finished"");
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					callback.onDownloadEnd(type, url, outFile);
				}
			});
		}
		public static int findSubstring( byte[]buf, String str ) {
			for ( int i=0; i<buf.length-str.length(); i++ ) {
				boolean found = true;
				for ( int j=0; j<str.length(); j++ )
					if ( str.charAt(j)!=buf[i+j] ) {
						found = false;
						break;
					}
				if ( found )
					return i;
			}
			return -1; // not found
		}
		public void runInternal() {
			connection = null;
			
			boolean itemsLoadedPartially = false;
			boolean loadNext = false;
			HashSet<String> visited = new HashSet<String>();

			do {
			try {
				setProgressMessage( url.toString(), -1 );
				visited.add(url.toString());
				long startTimeStamp = System.currentTimeMillis();
				delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS); 
				URLConnection conn = url.openConnection();
				if ( conn instanceof HttpsURLConnection ) {
					onError(""HTTPs is not supported yet"");
					return;
				}
				if ( !(conn instanceof HttpURLConnection) ) {
					onError(""Only HTTP supported"");
					return;
				}
				connection = (HttpURLConnection)conn;
	            connection.setRequestProperty(""User-Agent"", ""CoolReader/3(Android)"");
	            if ( referer!=null )
	            	connection.setRequestProperty(""Referer"", referer);
	            connection.setInstanceFollowRedirects(true);
	            connection.setAllowUserInteraction(false);
	            connection.setConnectTimeout(CONNECT_TIMEOUT);
	            connection.setReadTimeout(READ_TIMEOUT);
	            connection.setDoInput(true);
	            String fileName = null;
	            String disp = connection.getHeaderField(""Content-Disposition"");
	            if ( disp!=null ) {
	            	int p = disp.indexOf(""filename="");
	            	if ( p>0 ) {
	            		fileName = disp.substring(p + 9);
	            	}
	            }
	            //connection.setDoOutput(true);
	            //connection.set
	            
	            int response = -1;
				
				response = connection.getResponseCode();
				L.d(""Response: "" + response);
				if ( response!=200 ) {
					onError(""Error "" + response);
					return;
				}
				String contentType = connection.getContentType();
				String contentEncoding = connection.getContentEncoding();
				int contentLen = connection.getContentLength();
				//connection.getC
				L.d(""Entity content length: "" + contentLen);
				L.d(""Entity content type: "" + contentType);
				L.d(""Entity content encoding: "" + contentEncoding);
				setProgressMessage( url.toString(), contentLen );
				InputStream is = connection.getInputStream();
				delayedProgress.cancel();
				is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);
				final int MAX_CONTENT_LEN_TO_BUFFER = 256*1024;
				boolean isZip = contentType!=null && contentType.equals(""application/zip"");
				if ( expectedType!=null )
					contentType = expectedType;
				else if ( contentLen>0 && contentLen<MAX_CONTENT_LEN_TO_BUFFER) { // autodetect type
					byte[] buf = new byte[contentLen];
					if ( is.read(buf)!=contentLen ) {
						onError(""Wrong content length"");
						return;
					}
					is.close();
					is = null;
					is = new ByteArrayInputStream(buf);
					if ( findSubstring(buf, ""<?xml version="")>=0 && findSubstring(buf, ""<feed"")>=0  )
						contentType = ""application/atom+xml""; // override type
				}
				if ( contentType.startsWith(""application/atom+xml"") ) {
					L.d(""Parsing feed"");
					parseFeed( is );
					itemsLoadedPartially = true;
					if (handler.docInfo.nextLink!=null && handler.docInfo.nextLink.type.startsWith(""application/atom+xml;profile=opds-catalog"")) {
						url = new URL(handler.docInfo.nextLink.href);
						loadNext = !visited.contains(url.toString());
						L.d(""continue with next part: "" + url);
					} else {
						loadNext = false;
					}
						
				} else {
					if ( fileName==null )
						fileName = defaultFileName;
					L.d(""Downloading book: "" + contentEncoding);
					downloadBook( contentType, url.toString(), is, contentLen, fileName, isZip );
					if ( progressShown )
						coolReader.getEngine().hideProgress();
					loadNext = false;
					itemsLoadedPartially = false;
				}
			} catch (Exception e) {
				L.e(""Exception while trying to open URI "" + url.toString(), e);
				if ( progressShown )
					coolReader.getEngine().hideProgress();
				onError(""Error occured while reading OPDS catalog"");
			} finally {
				if ( connection!=null )
					try {
						connection.disconnect();
					} catch ( Exception e ) {
						// ignore
					}
			}
			} while (loadNext);
			if ( progressShown )
				coolReader.getEngine().hideProgress();
			if (itemsLoadedPartially)
				BackgroundThread.guiExecutor.execute(new Runnable() {
					@Override
					public void run() {
						L.d(""Parsing is finished successfully. "" + handler.entries.size() + "" entries found"");
						callback.onFinish(handler.docInfo, handler.entries);
					}
				});
		}

		public void run() {
			BackgroundThread.backgroundExecutor.execute(new Runnable() {
				@Override
				public void run() {
					try {
						runInternal();
					} catch ( Exception e ) {
						L.e(""exception while opening OPDS"", e);
					}
				}
			});
		}

		public void cancel() {
		}

		private boolean progressShown = false;
	
		public class ProgressInputStream extends InputStream {

			private static final int TIMEOUT = 1500;  
			
			private final InputStream sourceStream;
			private final int totalSize;
			private final String progressMessage;
			private long lastUpdate;
			private int lastPercent;
			private int maxPercentToStartShowingProgress;
			private int bytesRead;
			
			public ProgressInputStream( InputStream sourceStream, long startTimeStamp, String progressMessage, int totalSize, int maxPercentToStartShowingProgress ) {
				this.sourceStream = sourceStream;
				this.totalSize = totalSize;
				this.maxPercentToStartShowingProgress = maxPercentToStartShowingProgress * 100;
				this.progressMessage = progressMessage;
				this.lastUpdate = startTimeStamp;
				this.bytesRead = 0;
			}

			private void updateProgress() {
				long ts = System.currentTimeMillis();
				long delay = ts - lastUpdate;
				if ( delay > TIMEOUT ) {
					lastUpdate = ts;
					int percent = 0;
					if ( totalSize>0 ) {
						percent = bytesRead * 100 / totalSize * 100;
					}
					if ( (!progressShown || percent!=lastPercent) && (progressShown || percent<maxPercentToStartShowingProgress || delay > TIMEOUT*2 ) ) {
						coolReader.getEngine().showProgress(percent, progressMessage);
						lastPercent = percent;
						progressShown = true;
					}
				}
					
			}
			
			@Override
			public int read() throws IOException {
				bytesRead++;
				updateProgress();
				return sourceStream.read();
			}

			@Override
			public void close() throws IOException {
				super.close();
			}
		}
		
	}
	private static DownloadTask currentTask;
	public static DownloadTask create( CoolReader coolReader, URL uri, String defaultFileName, String expectedType, String referer, DownloadCallback callback ) {
		final DownloadTask task = new DownloadTask(coolReader, uri, defaultFileName, expectedType, referer, callback);
		currentTask = task;
		return task;
	}

	private static class SubstTable {
		private final int startChar;
		private final String[] replacements;
		public SubstTable( int startChar, String[] replacements ) {
			this.startChar = startChar;
			this.replacements = replacements;
		}
		boolean isInRange( char ch ) {
			return ch>=startChar && ch<startChar + replacements.length;
		}
		String get( char ch ) {
			return (ch>=startChar && ch<startChar + replacements.length) ? replacements[ch - startChar] : """";
		}
	}
	
	private final static SubstTable[] substTables = { 
		new SubstTable(0x430, new String[]{""a"", ""b"", ""v"", ""g"", ""d"", ""e"", ""zh"", ""z"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""r"", ""s"", ""t"", ""u"", ""f"", ""h"", ""c"", ""ch"", ""sh"", ""sch"", ""'"", ""y"", ""i"", ""e"", ""yu"", ""ya""}),
		new SubstTable(0x410, new String[]{""A"", ""B"", ""V"", ""G"", ""D"", ""E"", ""Zh"", ""Z"", ""I"", ""J"", ""K"", ""L"", ""M"", ""N"", ""O"", ""P"", ""R"", ""S"", ""T"", ""U"", ""F"", ""H"", ""C"", ""Ch"", ""Sh"", ""Sch"", ""'"", ""Y"", ""I"", ""E"", ""Yu"", ""Ya""}),
	};
	
	public static String transcribeFileName( String fileName ) {
		StringBuilder buf = new StringBuilder(fileName.length());
		for ( char ch : fileName.toCharArray() ) {
			boolean found = false;
			if ( ((ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9') || ch=='-' || ch=='_' || ch=='(' || ch==')')) {
				buf.append(ch);
				continue;
			}
			for ( SubstTable t : substTables ) {
				if ( t.isInRange(ch) ) {
					buf.append(t.get(ch));
					found = true;
				}
			}
			if ( found )
				continue;
			buf.append(""_"");
		}
		return buf.toString();
	}
	
	public static final int PROGRESS_DELAY_MILLIS = 2000; 
}
",True,45,49,0,0,3,22,1,5,L0
24,org.coolreader.crengine.Bookmark.java,"package org.coolreader.crengine;


public class Bookmark {

	public Bookmark()
	{
	}
	
	public Bookmark( Bookmark v )
	{
		id=v.id;
		type=v.type;
		percent=v.percent;
		shortcut=v.shortcut;
		startPos=v.startPos;
		endPos=v.endPos;
		titleText=v.titleText;
		posText=v.posText;
		commentText=v.commentText;
		timeStamp=v.timeStamp;
		modified=v.modified;
	}
	
	
	public int getType() {
		return type;
	}
	public boolean setType(int type) {
		if (this.type == type)
			return false;
		this.type = type;
		modified = true;
		return true;
	}
	public int getPercent() {
		return percent;
	}
	public void setPercent(int percent) {
		this.percent = percent;
		modified = true;
	}
	public String getStartPos() {
		return startPos;
	}
	public void setStartPos(String startPos) {
		this.startPos = startPos;
		modified = true;
	}
	public String getEndPos() {
		return endPos;
	}
	public void setEndPos(String endPos) {
		this.endPos = endPos;
		modified = true;
	}
	public String getCommentText() {
		return commentText;
	}
	private boolean changed( String v1, String v2 ) {
		if ( v1==null && v2==null )
			return false;
		if ( v1==null || v2==null )
			return true;
		return !v1.equals(v2);
	}
	public boolean setCommentText(String commentText) {
		if ( !changed(this.commentText, commentText) )
			return false;
		this.commentText = commentText;
		modified = true;
		return true;
	}
	public String getTitleText() {
		return titleText;
	}
	public String getPosText() {
		return posText;
	}
	
	public void setTitleText(String titleText) {
		this.titleText = titleText;
		modified = true;
	}
	public void setPosText(String posText) {
		this.posText = posText;
		modified = true;
	}
	public int getShortcut() {
		return shortcut;
	}
	public void setShortcut(int shortcut) {
		modified = true;
		this.shortcut = shortcut;
	}
	public long getTimeStamp() {
		return timeStamp;
	}
	public void setTimeStamp(long timeStamp) {
		if ( this.timeStamp == timeStamp )
			return;
		this.timeStamp = timeStamp;
		modified = true;
	}
	
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}

	public boolean isModified() {
		return modified || id==null;
	}
	public void setModified(boolean modified) {
		this.modified = modified;
	}

	public static final int TYPE_LAST_POSITION = 0;
	public static final int TYPE_POSITION = 1;
	public static final int TYPE_COMMENT = 2;
	public static final int TYPE_CORRECTION = 3;
	private Long id;
	private int type;
	private int percent;
	private int shortcut;
	private String startPos;
	private String endPos;
	private String titleText;
	private String posText;
	private String commentText;
	private long timeStamp = System.currentTimeMillis(); // UTC timestamp
	private boolean modified;
	
}
",False,22,31,4,13,0,0,8,0,L0
25,org.coolreader.crengine.DocumentFormat.java,"package org.coolreader.crengine;

import org.coolreader.R;

public enum DocumentFormat {
	/// lvtinydom.h: source document formats
	//typedef enum {
	NONE(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book, false, 0, 
			new String[] {},
			new String[] {}),// doc_format_none,
	FB2(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book_fb2, true, 10, 
			new String[] {"".fb2"", "".fb2.zip""},
			new String[] {""application/fb2+zip""}), // doc_format_fb2,
	TXT(""txt.css"", R.raw.txt, R.drawable.cr3_browser_book_txt, false, 3, 
			new String[] {"".txt"", "".tcr"", "".pml""},
			new String[] {""text/plain""}), // doc_format_txt,
	RTF(""rtf.css"", R.raw.rtf, R.drawable.cr3_browser_book_rtf, false, 7, 
			new String[] {"".rtf""},
			new String[] {}), // doc_format_rtf,
	EPUB(""epub.css"", R.raw.epub, R.drawable.cr3_browser_book_epub, true, 9, 
			new String[] {"".epub""},
			new String[] {""application/epub+zip""}),// doc_format_epub,
	HTML(""htm.css"", R.raw.htm, R.drawable.cr3_browser_book_html, false, 8, 
			new String[] {"".htm"", "".html"", "".shtml"", "".xhtml""},
			new String[] {""text/html""}),// doc_format_html,
	TXT_BOOKMARK(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book_fb2, false, 0, 
			new String[] {"".txt.bmk""},
			new String[] {}), // doc_format_txt_bookmark, // coolreader TXT format bookmark
	CHM(""chm.css"", R.raw.chm, R.drawable.cr3_browser_book_chm, false, 6, 
			new String[] {"".chm""},
			new String[] {}), //  doc_format_chm,
	DOC(""doc.css"", R.raw.doc, R.drawable.cr3_browser_book_doc, false, 5, 
			new String[] {"".doc""},
			new String[] {}), // doc_format_doc,
	PDB(""htm.css"", R.raw.htm, R.drawable.cr3_browser_book_pdb, false, 4, 
			new String[] {"".pdb"", "".prc"", "".mobi"", "".azw""},
			new String[] {}); // doc_format_txt/html/...,
    // don't forget update getDocFormatName() when changing this enum
	//} doc_format_t;
	
	public String getCssName()
	{
		return cssFileName;
	}
	
	public int getPriority()
	{
		return priority;
	}
	
	public String[] getExtensions()
	{
		return extensions;
	}
	
	public int getCSSResourceId()
	{
		return cssResourceId;
	}
	
	public int getIconResourceId()
	{
		return iconResourceId;
	}
	
	public String[] getMimeFormats()
	{
		return mimeFormats;
	}
	
	public String getMimeFormat()
	{
		return mimeFormats.length>0 ? mimeFormats[0] : null;
	}
	
	public boolean canParseProperties()
	{
		return canParseProperties;
	}
	
	public static DocumentFormat byId( int i )
	{
		if ( i>=0 && i<DocumentFormat.values().length )
			return values()[i];
		return null;
	}
	
	public boolean matchExtension( String filename )
	{
		for ( String ext : extensions )
			if ( filename.endsWith(ext) )
				return true;
		return false;
	}
	
	public boolean matchMimeType( String type )
	{
		for ( String s : mimeFormats ) {
			if ( type.equals(s) || type.startsWith(s+"";""))
				return true;
		}
		return false;
	}
	
	public static DocumentFormat byExtension( String filename )
	{
		String s = filename.toLowerCase();
		for ( int i=0; i<DocumentFormat.values().length; i++ )
			if ( values()[i].matchExtension(s))
				return values()[i];
		return null;
	}
	
	public static DocumentFormat byMimeType( String format )
	{
		if ( format==null )
			return null;
		String s = format.toLowerCase();
		for ( int i=0; i<DocumentFormat.values().length; i++ )
			if ( values()[i].matchMimeType(s))
				return values()[i];
		return null;
	}
	
	private DocumentFormat( String cssFileName, int cssResourceId, int iconResourceId, boolean canParseProperties, int priority, String extensions[], String mimeFormats[] )
	{
		this.cssFileName = cssFileName;
		this.cssResourceId = cssResourceId;
		this.iconResourceId = iconResourceId;
		this.extensions = extensions;
		this.canParseProperties = canParseProperties;
		this.mimeFormats = mimeFormats;
		this.priority = priority;
	}
	final private String cssFileName;
	final private int cssResourceId;
	final private int iconResourceId;
	final private String[] extensions;
	final boolean canParseProperties;
	final private String[] mimeFormats;
	final private int priority;
}
",False,44,33,4,18,0,0,7,0,L0
26,org.coolreader.crengine.FileInfo.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.coolreader.R;

import android.util.Log;

public class FileInfo {

	public final static String RECENT_DIR_TAG = ""@recent"";
	public final static String SEARCH_RESULT_DIR_TAG = ""@searchResults"";
	public final static String ROOT_DIR_TAG = ""@root"";
	public final static String OPDS_LIST_TAG = ""@opds"";
	public final static String OPDS_DIR_PREFIX = ""@opds:"";
	public final static String AUTHORS_TAG = ""@authors"";
	public final static String AUTHOR_GROUP_PREFIX = ""@authorGroup:"";
	public final static String AUTHOR_PREFIX = ""@author:"";
	public final static String SEARCH_SHORTCUT_TAG = ""@search"";
	
	
	
	Long id; // db id
	String title; // book title
	String authors; // authors, delimited with '|'
	String series; // series name w/o number
	int seriesNumber; // number of book inside series
	String path; // path to directory where file or archive is located
	String filename; // file name w/o path for normal file, with optional path for file inside archive 
	String pathname; // full path+arcname+filename
	String arcname; // archive file name w/o path
	DocumentFormat format;
	int size;
	int arcsize;
	long createTime;
	long lastAccessTime;
	int flags;
	boolean isArchive;
	boolean isDirectory;
	boolean isModified;
	boolean isListed;
	boolean isScanned;
	private ArrayList<FileInfo> files;// files
	private ArrayList<FileInfo> dirs; // directories
	FileInfo parent; // parent item
	
	Object tag; // some additional information
	
	public static final int DONT_USE_DOCUMENT_STYLES_FLAG = 1;
	public static final int DONT_REFLOW_TXT_FILES_FLAG = 2;

	/**
	 * To separate archive name from file name inside archive.
	 */
	public static final String ARC_SEPARATOR = ""@/"";
	
	
	public void setFlag( int flag, boolean value ) {
		flags = flags & (~flag) | (value? flag : 0);
	}
	
	public boolean getFlag( int flag ) {
		return (flags & flag)!=0;
	}
	
	/**
	 * Split archive + file path name by ARC_SEPARATOR
	 * @param pathName is pathname like /arc_file_path@/filepath_inside_arc or /file_path 
	 * @return item[0] is pathname, item[1] is archive name (null if no archive)
	 */
	public static String[] splitArcName( String pathName )
	{
		String[] res = new String[2];
		int arcSeparatorPos = pathName.indexOf(ARC_SEPARATOR);
		if ( arcSeparatorPos>=0 ) {
			// from archive
			res[1] = pathName.substring(0, arcSeparatorPos);
			res[0] = pathName.substring(arcSeparatorPos + ARC_SEPARATOR.length());
		} else {
			res[0] = pathName;
		}
		return res;
	}
	
	public FileInfo( String pathName )
	{
		String[] parts = splitArcName( pathName );
		if ( parts[1]!=null ) {
			// from archive
			isArchive = true;
			arcname = parts[1];
			pathname = parts[0];
			File f = new File(pathname);
			filename = f.getName();
			path = f.getPath();
			File arc = new File(arcname);
			if ( arc.isFile() && arc.exists() ) {
				arcsize = (int)arc.length();
				try {
					ZipFile zip = new ZipFile(new File(arcname));
					for ( Enumeration<?> e = zip.entries(); e.hasMoreElements(); ) {
						ZipEntry entry = (ZipEntry)e.nextElement();
						
						String name = entry.getName();
						if ( !entry.isDirectory() && !pathname.equals(name) ) {
							format = DocumentFormat.byExtension(name);
							size = (int)entry.getSize();
							createTime = entry.getTime();
							break;
						}
					}
				} catch ( Exception e ) {
					Log.e(""cr3"", ""error while reading contents of "" + arcname);
				}
			}
		} else {
			fromFile(new File(pathName));
		}
	}
	
	public String getFileNameToDisplay() {
		boolean isSingleFileArchive = (isArchive && parent!=null && !parent.isArchive && arcname!=null);
		return isSingleFileArchive
			? new File(arcname).getName() : filename;
	}
	
	private void fromFile( File f )
	{
		if ( !f.isDirectory() ) {
			DocumentFormat fmt = DocumentFormat.byExtension(f.getName());
			filename = f.getName();
			path = f.getParent();
			pathname = f.getAbsolutePath();
			format = fmt;
			createTime = f.lastModified();
			size = (int)f.length();
		} else {
			filename = f.getName();
			path = f.getParent();
			pathname = f.getAbsolutePath();
			isDirectory = true;
		}
	}
	
	public FileInfo( File f )
	{
		fromFile(f);
	}
	
	public FileInfo()
	{
	}

	/// doesn't copy parent and children
	public FileInfo(FileInfo v)
	{
		title = v.title;
		authors = v.authors;
		series = v.series;
		seriesNumber = v.seriesNumber;
		path = v.path;
		filename = v.filename;
		pathname = v.pathname;
		arcname = v.arcname;
		format = v.format;
		size = v.size;
		arcsize = v.arcsize;
		isArchive = v.isArchive;
		isDirectory = v.isDirectory;
		createTime = v.createTime;
		lastAccessTime = v.lastAccessTime;
	}
	
	/**
	 * @return archive file path and name, null if this object is neither archive nor a file inside archive
	 */
	public String getArchiveName()
	{
		return arcname;
	}
	
	/**
	 * @return file name inside archive, null if this object is not a file inside archive
	 */
	public String getArchiveItemName()
	{
		if ( isArchive && !isDirectory && pathname!=null )
			return pathname;
		return null;
	}
	
	public boolean isRecentDir()
	{
		return RECENT_DIR_TAG.equals(pathname);
	}
	
	public boolean isSearchDir()
	{
		return SEARCH_RESULT_DIR_TAG.equals(pathname);
	}
	
	public boolean isRootDir()
	{
		return ROOT_DIR_TAG.equals(pathname);
	}
	
	public boolean isSpecialDir()
	{
		return pathname!=null && pathname.startsWith(""@"");
	}
	
	public boolean isOPDSDir()
	{
		return pathname!=null && pathname.startsWith(OPDS_DIR_PREFIX);
	}
	
	public boolean isOPDSRoot()
	{
		return OPDS_LIST_TAG.equals(pathname);
	}
	
	public boolean isSearchShortcut()
	{
		return SEARCH_SHORTCUT_TAG.equals(pathname);
	}
	
	public boolean isBooksByAuthorRoot()
	{
		return AUTHORS_TAG.equals(pathname);
	}
	
	public boolean isBooksByAuthorDir()
	{
		return pathname!=null && pathname.startsWith(AUTHOR_PREFIX);
	}
	
	public long getAuthorId()
	{
		if (!isBooksByAuthorDir())
			return 0;
		try {
			return Long.parseLong(pathname.substring(AUTHOR_PREFIX.length()));
		} catch (NumberFormatException e) {
			return 0;
		}
	}
	
	public boolean isHidden()
	{
		return pathname.startsWith(""."");
	}
	
	public String getOPDSUrl()
	{
		if ( !pathname.startsWith(OPDS_DIR_PREFIX) )
			return null;
		return pathname.substring(OPDS_DIR_PREFIX.length());
	}
	
	/**
	 * Get absolute path to file.
	 * For plain files, returns /abs_path_to_file/filename.ext
	 * For archives, returns /abs_path_to_archive/arc_file_name.zip@/filename_inside_archive.ext
	 * @return full path + filename
	 */
	public String getPathName()
	{
		if ( arcname!=null )
			return arcname + ARC_SEPARATOR + pathname;
		return pathname;
	}

	public String getBasePath()
	{
		if ( arcname!=null )
			return arcname;
		return pathname;
	}

	public int dirCount()
	{
		return dirs!=null ? dirs.size() : 0;
	}

	public int fileCount()
	{
		return files!=null ? files.size() : 0;
	}

	public int itemCount()
	{
		return dirCount() + fileCount();
	}

	public void addDir( FileInfo dir )
	{
		if ( dirs==null )
			dirs = new ArrayList<FileInfo>();
		dirs.add(dir);
	}
	public void addFile( FileInfo file )
	{
		if ( files==null )
			files = new ArrayList<FileInfo>();
		files.add(file);
	}
	public void addItems( Collection<FileInfo> items )
	{
		for ( FileInfo item : items ) {
			if ( item.isDirectory )
				addDir(item);
			else
				addFile(item);
			item.parent = this;
		}
	}
	public void replaceItems( Collection<FileInfo> items )
	{
		files = null;
		dirs = null;
		addItems( items );
	}
	public boolean isEmpty()
	{
		return fileCount()==0 && dirCount()==0;
	}
	public FileInfo getItem( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<dirCount())
			return dirs.get(index);
		index -= dirCount();
		if ( index<fileCount())
			return files.get(index);
		Log.e(""cr3"", ""Index out of bounds "" + index + "" at FileInfo.getItem() : returning 0"");
		//throw new IndexOutOfBoundsException();
		return null;
	}
	public FileInfo findItemByPathName( String pathName )
	{
		if ( dirs!=null )
			for ( FileInfo dir : dirs )
				if ( pathName.equals(dir.getPathName() ))
					return dir;
		if ( files!=null )
			for ( FileInfo file : files ) {
				if ( pathName.equals(file.getPathName() ))
					return file;
				if ( file.getPathName().startsWith(pathName+""@/"" ))
					return file;
			}
		return null;
	}
	public int getItemIndex( FileInfo item )
	{
		if ( item==null )
			return -1;
		for ( int i=0; i<dirCount(); i++ ) {
			if ( item.getPathName().equals(getDir(i).getPathName()) )
				return i;
		}
		for ( int i=0; i<fileCount(); i++ ) {
			if ( item.getPathName().equals(getFile(i).getPathName()) )
				return i + dirCount();
		}
		return -1;
	}

	public FileInfo getDir( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<dirCount())
			return dirs.get(index);
		throw new IndexOutOfBoundsException();
	}
	public FileInfo getFile( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<fileCount())
			return files.get(index);
		throw new IndexOutOfBoundsException();
	}

	public void removeEmptyDirs()
	{
		if ( parent==null || pathname.startsWith(""@"") )
			return;
		for ( int i=dirCount()-1; i>=0; i-- )
			if ( getDir(i).dirCount()==0 && getDir(i).fileCount()==0 )
				dirs.remove(i);
	}
	
	public void removeChild( FileInfo item )
	{
		if ( item.isSpecialDir() )
			return;
		if ( files!=null ) {
			int n = files.indexOf(item);
			if ( n>=0 && n<files.size() ) {
				files.remove(n);
				return;
			}
		}
		if ( dirs!=null ) {
			int n = dirs.indexOf(item);
			if ( n>=0 && n<dirs.size() ) {
				dirs.remove(n);
			}
		}
	}
	
	public boolean deleteFile()
	{
		if ( isArchive ) {
			if ( isDirectory )
				return false;
			File f = new File(arcname);
			if ( f.exists() && !f.isDirectory() ) {
				if ( !f.delete() )
					return false;
				if ( parent!=null ) {
					if ( parent.isArchive ) {
						// remove all files belonging to this archive
					} else {
						parent.removeChild(this);
					}
				}
				return true;
			}
		}
		if ( isDirectory )
			return false;
		if ( !fileExists() )
			return false;
		File f = new File(pathname);
		if ( f.delete() ) {
			if ( parent!=null ) {
				parent.removeChild(this);
			}
			return true;
		}
		return false;
	}
	
	public boolean fileExists()
	{
		if (isDirectory)
			return false;
		if ( isArchive ) {
			if ( arcname!=null )
				return new File(arcname).exists();
			return false;
		}
		return new File(pathname).exists();
	}
	
	/**
	 * @return true if item (file, directory, or archive) exists
	 */
	public boolean exists()
	{
		if ( isArchive ) {
			if ( arcname==null )
				return false;
			File f = new File(arcname);
			return f.exists();
		}
		File f = new File(pathname);
		return f.exists();
	}
	
	public boolean isModified() {
		return isModified || id==null;
	}

	public void setModified(boolean isModified) {
		this.isModified = isModified;
	}

	public String getAuthors() {
		return authors;
	}
	
	public String getTitle() {
		return title;
	}

	public void clear()
	{
		dirs = null;
		files = null;
	}
	
	public static enum SortOrder {
		FILENAME(R.string.mi_book_sort_order_filename, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return cmp(f1.getFileNameToDisplay(), f2.getFileNameToDisplay());
			}
		}),
		FILENAME_DESC(R.string.mi_book_sort_order_filename_desc, FILENAME),
		TIMESTAMP(R.string.mi_book_sort_order_timestamp, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz( cmp(f1.createTime, f2.createTime), cmp(f1.filename, f2.filename) );
			}
		}),
		TIMESTAMP_DESC(R.string.mi_book_sort_order_timestamp_desc, TIMESTAMP),
		AUTHOR_TITLE(R.string.mi_book_sort_order_author, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz(
						cmpNotNullFirst(f1.authors, f2.authors)
						,cmpNotNullFirst(f1.series, f2.series)
						,cmp(f1.seriesNumber, f2.seriesNumber)
						,cmpNotNullFirst(f1.title, f2.title)
						,cmp(f1.filename, f2.filename) 
						);
			}
		}),
		AUTHOR_TITLE_DESC(R.string.mi_book_sort_order_author_desc, AUTHOR_TITLE),
		TITLE_AUTHOR(R.string.mi_book_sort_order_title, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz(
						cmpNotNullFirst(f1.series, f2.series)
						,cmp(f1.seriesNumber, f2.seriesNumber)
						,cmpNotNullFirst(f1.title, f2.title)
						,cmpNotNullFirst(f1.authors, f2.authors)
						,cmp(f1.filename, f2.filename) 
						);
			}
		}),
		TITLE_AUTHOR_DESC(R.string.mi_book_sort_order_title_desc, TITLE_AUTHOR);
		//================================================
		private final Comparator<FileInfo> comparator;
		public final int resourceId;
		private SortOrder( int resourceId, Comparator<FileInfo> comparator )
		{
			this.resourceId = resourceId;
			this.comparator = comparator;
		}
		private SortOrder( int resourceId, final SortOrder base )
		{
			this.resourceId = resourceId;
			this.comparator = new Comparator<FileInfo>() {
				public int compare( FileInfo f1, FileInfo f2 )
				{
					return -base.comparator.compare(f1, f2);
				}
			};
		}
		
		public final Comparator<FileInfo> getComparator()
		{
			return comparator;
		}
		
		/**
		 * Compares two strings - with numbers sorted by value.
		 * @param str1
		 * @param str2
		 * @return
		 */
		private static int cmp( String str1, String str2 )
		{
			if ( str1==null && str2==null )
				return 0;
			if ( str1==null )
				return -1;
			if ( str2==null )
				return 1;
			
			int p1 = 0;
			int p2 = 0;
			for ( ;; ) {
				if ( p1>=str1.length() ) {
					if ( p2>=str2.length() )
						return 0;
					return 1;
				}
				if ( p2>=str2.length() )
					return -1;
				char ch1 = str1.charAt(p1);
				char ch2 = str2.charAt(p2);
				if ( ch1>='0' && ch1<='9' && ch2>='0' && ch2<='9' ) {
					int n1 = 0;
					int n2 = 0;
					while ( ch1>='0' && ch1<='9' ) {
						p1++;
						n1 = n1 * 10 + (ch1-'0');
						if ( p1>=str1.length() )
							break;
						ch1 = str1.charAt(p1);
					}
					while ( ch2>='0' && ch2<='9' ) {
						p2++;
						n2 = n2 * 10 + (ch2-'0');
						if ( p2>=str2.length() )
							break;
						ch2 = str2.charAt(p2);
					}
					int c = cmp(n1, n2);
					if ( c!=0 )
						return c;
				} else {
					if ( ch1<ch2 )
						return -1;
					if ( ch1>ch2 )
						return 1;
					p1++;
					p2++;
				}
			}
		}
		
		/**
		 * Same as cmp, but not-null comes first
		 * @param str1
		 * @param str2
		 * @return
		 */
		private static int cmpNotNullFirst( String str1, String str2 )
		{
			if ( str1==null && str2==null )
				return 0;
			if ( str1==null )
				return 1;
			if ( str2==null )
				return -1;
			return cmp(str1, str2);
		}
		
		private static int cmp( long n1, long n2 )
		{
			if ( n1<n2 )
				return -1;
			if ( n1>n2 )
				return 1;
			return 0;
		}
		
		private static int firstNz( int... v)
		{
			for ( int i=0; i<v.length; i++ ) {
				if ( v[i]!=0 )
					return v[i];
			}
			return 0;
		}
		public static SortOrder fromName( String name ) {
			if ( name!=null )
				for ( SortOrder order : values() )
					if ( order.name().equals(name) )
						return order;
			return DEF_SORT_ORDER;
		}
	}
	public final static SortOrder DEF_SORT_ORDER = SortOrder.AUTHOR_TITLE;
		
	public void sort( SortOrder SortOrder )
	{
		if ( dirs!=null ) {
			ArrayList<FileInfo> newDirs = new ArrayList<FileInfo>(dirs);
			Collections.sort( newDirs, SortOrder.getComparator() );
			dirs = newDirs;
		}
		if ( files!=null ) {
			ArrayList<FileInfo> newFiles = new ArrayList<FileInfo>(files);
			Collections.sort( newFiles, SortOrder.getComparator() );
			files = newFiles;
		}
	}
	
	@Override
	public String toString()
	{
		return pathname;
	}
	
	public boolean allowSorting() {
		return isDirectory && !isRootDir() && !isRecentDir() && !isOPDSDir();
	}
}
",True,48,32,4,17,1,1,11,1,L0
27,org.coolreader.crengine.BackgroundTextureInfo.java,"package org.coolreader.crengine;

import java.io.File;

public class BackgroundTextureInfo {
	public String id; // filepath for external image or unique symbolic name for resource
	public String name;
	public int resourceId;
	public boolean tiled;
	public BackgroundTextureInfo(String id, String name, int resourceId) {
		this.id = id;
		this.name = name;
		this.resourceId = resourceId;
		this.tiled = id.startsWith(""tx_"") || id.indexOf(""/textures/"")>0;
	}

	public static BackgroundTextureInfo fromFile( String filename ) {
		if ( filename==null )
			return null;
		File f = new File(filename);
		if ( !f.isFile() || !f.exists() )
			return null;
		String nm = new File(filename).getName();
		String fnlc = nm.toLowerCase();
		if ( fnlc.endsWith("".png"") || fnlc.endsWith("".jpg"") || fnlc.endsWith("".jpeg"") || fnlc.endsWith("".gif"") ) {
			return new BackgroundTextureInfo(filename, nm.substring(0, nm.lastIndexOf('.')), 0);
		}
		return null;
	}

	public static final String NO_TEXTURE_ID = ""(NONE)"";
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + resourceId;
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		BackgroundTextureInfo other = (BackgroundTextureInfo) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (resourceId != other.resourceId)
			return false;
		return true;
	}
	@Override
	public String toString() {
		return ""BackgroundTextureInfo [id="" + id + "", name="" + name + ""]"";
	}
	public boolean isNone() {
		return id==null || id.equals(NO_TEXTURE_ID);
	}
}
",False,5,30,4,21,0,0,4,0,L0
28,org.coolreader.crengine.History.java,"package org.coolreader.crengine;

import java.io.ByteArrayInputStream;
import java.lang.reflect.Method;
import java.util.ArrayList;

import org.coolreader.CoolReader;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.util.Log;

public class History {
	private ArrayList<BookInfo> mBooks = new ArrayList<BookInfo>();
	private final CRDB mDB;
	private final CoolReader mCoolReader;
	private FileInfo mRecentBooksFolder;
	
	public History(CoolReader cr, CRDB db)
	{
		this.mCoolReader = cr;
		this.mDB = db;
	}
	
	public BookInfo getLastBook()
	{
		if ( mBooks.size()==0 )
			return null;
		return mBooks.get(0);
	}

	public BookInfo getPreviousBook()
	{
		if ( mBooks.size()<2 )
			return null;
		return mBooks.get(1);
	}

	public BookInfo getOrCreateBookInfo( FileInfo file )
	{
		BookInfo res = getBookInfo(file);
		if ( res==null ) {
			res = new BookInfo( file );
			mBooks.add(0, res);
		}
		return res;
	}
	
	public BookInfo getBookInfo( FileInfo file )
	{
		int index = findBookInfo( file );
		if ( index>=0 )
			return mBooks.get(index);
		return null;
	}

	public BookInfo getBookInfo( String pathname )
	{
		int index = findBookInfo( pathname );
		if ( index>=0 )
			return mBooks.get(index);
		return null;
	}
	
	public void removeBookInfo( FileInfo fileInfo, boolean removeRecentAccessFromDB, boolean removeBookFromDB )
	{
		int index = findBookInfo(fileInfo);
		if ( index>=0 )
			mBooks.remove(index);
		if ( mDB.findByPathname(fileInfo) ) {
			if ( removeBookFromDB )
				mDB.deleteBook(fileInfo);
			else if ( removeRecentAccessFromDB )
				mDB.deleteRecentPosition(fileInfo);
		}
	}
	
	public void updateBookAccess( BookInfo bookInfo )
	{
		Log.v(""cr3"", ""History.updateBookAccess() for "" + bookInfo.getFileInfo().getPathName());
		int index = findBookInfo(bookInfo.getFileInfo());
		if ( index>=0 ) {
			BookInfo info = mBooks.get(index);
			if ( index>0 ) {
				mBooks.remove(index);
				mBooks.add(0, info);
			}
			info.updateAccess();
			updateRecentDir();
		}
	}

	public int findBookInfo( String pathname )
	{
		for ( int i=0; i<mBooks.size(); i++ )
			if ( pathname.equals(mBooks.get(i).getFileInfo().getPathName()) )
				return i;
		return -1;
	}
	
	public int findBookInfo( FileInfo file )
	{
		return findBookInfo( file.getPathName() );
	}
	
	public Bookmark getLastPos( FileInfo file )
	{
		int index = findBookInfo(file);
		if ( index<0 )
			return null;
		return mBooks.get(index).getLastPosition();
	}
	protected void updateRecentDir()
	{
		Log.v(""cr3"", ""History.updateRecentDir()"");
		if ( mRecentBooksFolder!=null ) { 
			mRecentBooksFolder.clear();
			for ( BookInfo book : mBooks )
				mRecentBooksFolder.addFile(book.getFileInfo());
		} else {
			Log.v(""cr3"", ""History.updateRecentDir() : mRecentBooksFolder is null"");
		}
	}
	static class ImageData {
		long bookId;
		byte[] data;
		BitmapDrawable drawable = null;
	}
	class ImageDataCache {
		private final int maxSize;
		private int dataSize = 0;
		private int maxCount = 15;
		private ArrayList<ImageData> list = new ArrayList<ImageData>();
		public ImageDataCache( int maxSize, int maxCount ) {
			this.maxSize = maxSize;
			this.maxCount = maxCount;
		}
		synchronized public void clear() {
			list.clear();
		}
		synchronized public byte[] get( long bookId ) {
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId )
					return list.get(i).data;
			return null;
		}
		synchronized public void put( long bookId, byte[] data ) {
			boolean found = false;
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId ) {
					dataSize -= list.get(i).data.length;  
					dataSize += data.length;  
					list.get(i).data = data;
					if ( i>0 ) {
						ImageData item = list.remove(i);
						list.add(0, item);
					}
					found = true;
					break;
				}
			if ( !found ) {
				ImageData item = new ImageData();
				item.bookId = bookId;
				item.data = data;
				list.add(0, item);
				dataSize += data.length;
			}
			for ( int i=list.size()-1; i>0; i-- ) {
				if ( dataSize>maxSize || list.size()>maxCount ) {
					ImageData item = list.remove(i);
					dataSize -= item.data.length;
				} else
					break;
			}
		}
		synchronized public BitmapDrawable getImage( long bookId )
		{
			ImageData item = null;
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId ) {
					item = list.get(i);
					break;
				}
			if ( item==null )
				return null;
			byte[] data = get(bookId);
			if ( data==null || data.length==0 )
				return null;
			if ( item.drawable!=null )
				return item.drawable;
			// decode & resize
			BitmapDrawable res = decodeCoverPage( data );
			if ( res!=null ) {
	    		item.drawable = res;
			} else {
	    		item.data = new byte[] {};
			}
			return res;
		}
		synchronized void invalidateImages()
		{
			for ( int i=0; i<list.size(); i++ )
				list.get(i).drawable = null;
		}
	}
	
	private static Method bitmapSetDensityMethod;
	private static Method canvasSetDensityMethod;
	private static boolean isNewApiChecked;
	public BitmapDrawable decodeCoverPage( byte[] data )
	{
		try {
			ByteArrayInputStream is = new ByteArrayInputStream(data);
			Bitmap srcbmp = BitmapFactory.decodeStream(is);
			//BitmapDrawable drawable = new BitmapDrawable(mCoolReader.getResources(), is);
			//BitmapDrawable drawable = new BitmapDrawable(null, is);
			
			if ( !isNewApiChecked ) {
				isNewApiChecked = true;
				try {
					bitmapSetDensityMethod = Bitmap.class.getMethod(""setDensity"", new Class[] {int.class});
					canvasSetDensityMethod = Canvas.class.getMethod(""setDensity"", new Class[] {int.class});
				} catch ( Exception e ) {
					L.w(""No Bitmap.setDensity() method found"");
				}
			}
			
			Bitmap bmp = Bitmap.createBitmap(coverPageWidth, coverPageHeight, Bitmap.Config.ARGB_8888);
			if ( bitmapSetDensityMethod!=null )
				bitmapSetDensityMethod.invoke(bmp, Bitmap.DENSITY_NONE);
			//bmp.setDensity(Bitmap.DENSITY_NONE); // mCoolReader.getResources().getDisplayMetrics().densityDpi
			Canvas canvas = new Canvas(bmp);
			if ( canvasSetDensityMethod!=null )
				canvasSetDensityMethod.invoke(canvas, Bitmap.DENSITY_NONE);
			//canvas.setDensity(Bitmap.DENSITY_NONE); // mCoolReader.getResources().getDisplayMetrics().densityDpi
			canvas.drawBitmap(srcbmp, new Rect(0, 0, srcbmp.getWidth(), srcbmp.getHeight()),
					new Rect(0, 0, coverPageWidth, coverPageHeight), null);
    		Log.d(""cr3"", ""cover page format: "" + srcbmp.getWidth() + ""x"" + srcbmp.getHeight());
    		BitmapDrawable res = new BitmapDrawable(bmp);

    		
//			BitmapDrawable drawable = new BitmapDrawable(mCoolReader.getResources(), is);
//			//BitmapDrawable drawable = new BitmapDrawable(null, is);
//			Bitmap bmp = Bitmap.createBitmap(coverPageWidth, coverPageHeight, Bitmap.Config.ARGB_8888);
//			bmp.setDensity(mCoolReader.getResources().getDisplayMetrics().densityDpi); //Bitmap.DENSITY_NONE
//			Canvas canvas = new Canvas(bmp);
//			canvas.setDensity(mCoolReader.getResources().getDisplayMetrics().densityDpi); //Bitmap.DENSITY_NONE
//			canvas.drawBitmap(drawable.getBitmap(), new Rect(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()),
//					new Rect(0, 0, coverPageWidth, coverPageHeight), null);
//    		Log.d(""cr3"", ""cover page format: "" + drawable.getIntrinsicWidth() + ""x"" + drawable.getIntrinsicHeight());
//    		BitmapDrawable res = new BitmapDrawable(bmp);
    		
    		
    		return res;
		} catch ( Exception e ) {
    		Log.e(""cr3"", ""exception while decoding coverpage "" + e.getMessage());
    		return null;
		}
	}
	
	private boolean coverPagesEnabled = true;
	public boolean getCoverPagesEnabled()
	{
		return coverPagesEnabled;
	}
	
	public void setCoverPagesEnabled(boolean coverPagesEnabled)
	{
		this.coverPagesEnabled = coverPagesEnabled;
		if ( !coverPagesEnabled ) {
			coverPageCache.clear();
		}
	}
	
	public final static int COVERPAGE_IMAGE_CACHE_DATA_SIZE = 500000;
	public final static int COVERPAGE_IMAGE_CACHE_MAX_COUNT = 20;
	private ImageDataCache coverPageCache = new ImageDataCache(COVERPAGE_IMAGE_CACHE_DATA_SIZE, COVERPAGE_IMAGE_CACHE_MAX_COUNT);
	private int coverPageWidth = 60;
	private int coverPageHeight = 80;
	public void setBookCoverpageData(long bookId, byte[] coverpageData )
	{
		if ( bookId==0 )
			return;
		byte[] oldData = coverPageCache.get(bookId);
		if ( coverpageData==null )
			coverpageData = new byte[] {};
		if ( oldData==null || oldData.length!=coverpageData.length ) { 
			coverPageCache.put(bookId, coverpageData);
			mDB.saveBookCoverpage(bookId, coverpageData);
		}
	}
	public void updateCoverPageSize( int screenDX, int screenDY )
	{
		int min = screenDX<screenDY ? screenDX : screenDY;
		coverPageHeight = min / 4;
		coverPageWidth = coverPageHeight * 3 / 4;
		coverPageCache.invalidateImages();
	}
	public byte[] getBookCoverpageData(long bookId)
	{
		if ( bookId==0 )
			return null;
		byte[] data = coverPageCache.get(bookId);
		if ( data==null ) {
			data = mDB.loadBookCoverpage(bookId);
			if ( data==null )
				data = new byte[] {};
			coverPageCache.put(bookId, data);
		}
		return data.length>0 ? data : null;
	}
	public BitmapDrawable getBookCoverpageImage(Resources resources, long bookId)
	{
		byte[] data = getBookCoverpageData(bookId);
		if ( data==null )
			return null;
		return coverPageCache.getImage( bookId );
	}
	public boolean loadFromDB( Scanner scanner, int maxItems )
	{
		Log.v(""cr3"", ""History.loadFromDB()"");
		mBooks = mDB.loadRecentBooks(scanner.mFileList, maxItems);
		mRecentBooksFolder = scanner.mRoot.getDir(0);
		if ( mRecentBooksFolder==null )
			Log.v(""cr3"", ""History.loadFromDB() : mRecentBooksFolder is null"");
		updateRecentDir();
		return true;
	}

	public boolean saveToDB( )
	{
		Log.v(""cr3"", ""History.saveToDB()"");
		try {
			for ( BookInfo book : mBooks )
				mDB.save(book);
			return true;
		} catch ( Exception e ) {
			Log.e(""cr3"", ""error while saving file history "" + e.getMessage(), e);
			return false;
		}
	}

}
",True,31,49,0,0,3,22,3,7,L0
29,org.coolreader.crengine.PositionProperties.java,"package org.coolreader.crengine;

public class PositionProperties {
	public int x;
	public int y;
	public int fullHeight;
	public int pageHeight;
	public int pageWidth;
	public int pageNumber;
	public int pageCount;
	public int pageMode; // 1, 2 for page mode, 0 for scroll mode
	public int charCount;
	public int imageCount;
	
	public boolean canMoveToNextPage() {
		if (pageMode == 0) {
			return fullHeight > pageHeight && y < fullHeight - pageHeight;
		}
		return pageNumber < pageCount - pageMode;
	}
	
	@Override
	public String toString() {
		return ""PositionProperties [pageMode="" + pageMode + "", pageNumber=""
				+ pageNumber + "", pageCount="" + pageCount + "", x="" + x + "", y=""
				+ y + "", pageHeight="" + pageHeight + "", pageWidth="" + pageWidth
				+ "", fullHeight="" + fullHeight + ""]"";
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + fullHeight;
		result = prime * result + pageCount;
		result = prime * result + pageHeight;
		result = prime * result + pageMode;
		result = prime * result + pageNumber;
		result = prime * result + pageWidth;
		result = prime * result + x;
		result = prime * result + y;
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PositionProperties other = (PositionProperties) obj;
		if (fullHeight != other.fullHeight)
			return false;
		if (pageCount != other.pageCount)
			return false;
		if (pageHeight != other.pageHeight)
			return false;
		if (pageMode != other.pageMode)
			return false;
		if (pageNumber != other.pageNumber)
			return false;
		if (pageWidth != other.pageWidth)
			return false;
		if (x != other.x)
			return false;
		if (y != other.y)
			return false;
		return true;
	}
	
	
}
",False,35,30,4,13,0,0,2,0,L0
30,org.coolreader.crengine.Scanner.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.zip.ZipEntry;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.Engine.EngineTask;

import android.os.Environment;
import android.util.Log;

public class Scanner {
	
	HashMap<String, FileInfo> mFileList = new HashMap<String, FileInfo>();
//	ArrayList<FileInfo> mFilesForParsing = new ArrayList<FileInfo>();
	FileInfo mRoot;
	
	boolean mHideEmptyDirs = true;
	
	void setHideEmptyDirs( boolean flgHide ) {
		mHideEmptyDirs = flgHide;
	}

//	private boolean scanDirectories( FileInfo baseDir )
//	{
//		try {
//			File dir = new File(baseDir.pathname);
//			File[] items = dir.listFiles();
//			// process normal files
//			for ( File f : items ) {
//				if ( !f.isDirectory() ) {
//					FileInfo item = new FileInfo( f );
//					if ( item.format!=null ) {
//						item.parent = baseDir;
//						baseDir.addFile(item);
//						mFileList.add(item);
//					}
//				}
//			}
//			// process directories 
//			for ( File f : items ) {
//				if ( f.isDirectory() ) {
//					FileInfo item = new FileInfo( f );
//					item.parent = baseDir;
//					scanDirectories(item);
//					if ( !item.isEmpty() ) {
//						baseDir.addDir(item);					
//					}
//				}
//			}
//			return !baseDir.isEmpty();
//		} catch ( Exception e ) {
//			L.e(""Exception while scanning directory "" + baseDir.pathname, e);
//			return false;
//		}
//	}
	
	private boolean dirScanEnabled = true;
	public boolean getDirScanEnabled()
	{
		return dirScanEnabled;
	}
	
	public void setDirScanEnabled(boolean dirScanEnabled)
	{
		this.dirScanEnabled = dirScanEnabled;
	}
	
	private FileInfo scanZip( FileInfo zip )
	{
		try {
			File zf = new File(zip.pathname);
			//ZipFile file = new ZipFile(zf);
			ArrayList<ZipEntry> entries = engine.getArchiveItems(zip.pathname);
			ArrayList<FileInfo> items = new ArrayList<FileInfo>();
			//for ( Enumeration<?> e = file.entries(); e.hasMoreElements(); ) {
			for ( ZipEntry entry : entries ) {
				if ( entry.isDirectory() )
					continue;
				String name = entry.getName();
				FileInfo item = new FileInfo();
				item.format = DocumentFormat.byExtension(name);
				if ( item.format==null )
					continue;
				File f = new File(name);
				item.filename = f.getName();
				item.path = f.getPath();
				item.pathname = entry.getName();
				item.size = (int)entry.getSize();
				//item.createTime = entry.getTime();
				item.createTime = zf.lastModified();
				item.arcname = zip.pathname;
				item.arcsize = (int)entry.getSize(); //getCompressedSize();
				item.isArchive = true;
				items.add(item);
			}
			if ( items.size()==0 ) {
				L.i(""Supported files not found in "" + zip.pathname);
				return null;
			} else if ( items.size()==1 ) {
				// single supported file in archive
				FileInfo item = items.get(0);
				item.isArchive = true;
				item.isDirectory = false;
				return item;
			} else {
				zip.isArchive = true;
				zip.isDirectory = true;
				zip.isListed = true;
				for ( FileInfo item : items ) {
					item.parent = zip;
					zip.addFile(item);
				}
				return zip;
			}
		} catch ( Exception e ) {
			L.e(""IOException while opening "" + zip.pathname + "" "" + e.getMessage());
		}
		return null;
	}
	
	/**
	 * Adds dir and file children to directory FileInfo item.
	 * @param baseDir is directory to list files and dirs for
	 * @return true if successful.
	 */
	public boolean listDirectory( FileInfo baseDir )
	{
		Set<String> knownItems = null;
		if ( baseDir.isListed ) {
			knownItems = new HashSet<String>();
			for ( int i=baseDir.itemCount()-1; i>=0; i-- ) {
				FileInfo item = baseDir.getItem(i);
				if ( !item.exists() ) {
					// remove item from list
					baseDir.removeChild(item);
				} else {
					knownItems.add(item.getBasePath());
				}
			}
		}
		try {
			File dir = new File(baseDir.pathname);
			File[] items = dir.listFiles();
			// process normal files
			if ( items!=null ) {
				for ( File f : items ) {
					if ( !f.isDirectory() ) {
						if ( f.getName().startsWith(""."") )
							continue; // treat files beginning with '.' as hidden
						String pathName = f.getAbsolutePath();
						if ( knownItems!=null && knownItems.contains(pathName) )
							continue;
						boolean isZip = pathName.toLowerCase().endsWith("".zip"");
						FileInfo item = mFileList.get(pathName);
						boolean isNew = false;
						if ( item==null ) {
							item = new FileInfo( f );
							if ( isZip ) {
								item = scanZip( item );
								if ( item==null )
									continue;
								if ( item.isDirectory ) {
									// many supported files in ZIP
									item.parent = baseDir;
									baseDir.addDir(item);
									for ( int i=0; i<item.fileCount(); i++ ) {
										FileInfo file = item.getFile(i);
										mFileList.put(file.getPathName(), file);
									}
								} else {
									item.parent = baseDir;
									baseDir.addFile(item);
									mFileList.put(pathName, item);
								}
								continue;
							}
							isNew = true;
						}
						if ( item.format!=null ) {
							item.parent = baseDir;
							baseDir.addFile(item);
							if ( isNew )
								mFileList.put(pathName, item);
						}
					}
				}
				// process directories 
				for ( File f : items ) {
					if ( f.isDirectory() ) {
						if ( f.getName().startsWith(""."") )
							continue; // treat dirs beginning with '.' as hidden
						FileInfo item = new FileInfo( f );
						if ( knownItems!=null && knownItems.contains(item.getPathName()) )
							continue;
						item.parent = baseDir;
						baseDir.addDir(item);					
					}
				}
			}
			baseDir.isListed = true;
			return !baseDir.isEmpty();
		} catch ( Exception e ) {
			L.e(""Exception while listing directory "" + baseDir.pathname, e);
			baseDir.isListed = true;
			return false;
		}
	}
	
	public static class ScanControl {
		volatile private boolean stopped = false;
		public boolean isStopped() {
			return stopped;
		}
		public void stop() {
			stopped = true;
		}
	}
	
	/**
	 * Scan single directory for dir and file properties in background thread.
	 * @param baseDir is directory to scan
	 * @param readyCallback is called on completion
	 */
	public void scanDirectory( final FileInfo baseDir, final Runnable readyCallback, final boolean recursiveScan, final ScanControl scanControl )
	{
		final long startTime = System.currentTimeMillis();
		listDirectory(baseDir);
		listSubtree( baseDir, 2, android.os.SystemClock.uptimeMillis() + 700 );
		if ( (!getDirScanEnabled() || baseDir.isScanned) && !recursiveScan ) {
			readyCallback.run();
			return;
		}
		engine.execute(new EngineTask() {
			long nextProgressTime = startTime + 2000;
			boolean progressShown = false;
			void progress( int percent )
			{
				if ( recursiveScan )
					return; // no progress dialog for recursive scan
				long ts = System.currentTimeMillis();
				if ( ts>=nextProgressTime ) {
					engine.showProgress(percent, R.string.progress_scanning);
					nextProgressTime = ts + 1500;
					progressShown = true;
				}
			}
			
			public void done() {
				baseDir.isScanned = true;
				if ( progressShown )
					engine.hideProgress();
				readyCallback.run();
			}

			public void fail(Exception e) {
				L.e(""Exception while scanning directory "" + baseDir.pathname, e);
				baseDir.isScanned = true;
				if ( progressShown )
					engine.hideProgress();
				readyCallback.run();
			}

			public void scan( FileInfo baseDir ) {
				if ( baseDir.isRecentDir() )
					return;
				//listDirectory(baseDir);
				progress(1000);
				if ( scanControl.isStopped() )
					return;
				for ( int i=baseDir.dirCount()-1; i>=0; i-- ) {
					if ( scanControl.isStopped() )
						return;
					listDirectory(baseDir.getDir(i));
				}
				progress(2000);
				if ( mHideEmptyDirs )
					baseDir.removeEmptyDirs();
				if ( scanControl.isStopped() )
					return;
				ArrayList<FileInfo> filesForParsing = new ArrayList<FileInfo>();
				int count = baseDir.fileCount();
				for ( int i=0; i<count; i++ ) {
					FileInfo item = baseDir.getFile(i);
					boolean found = db.findByPathname(item);
					if ( found )
						Log.v(""cr3db"", ""File "" + item.pathname + "" is found in DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");

					boolean saveToDB = true;
					if ( !found && item.format.canParseProperties() ) {
						filesForParsing.add(item);
						saveToDB = false;
					}

					if ( !found && saveToDB ) {
						db.save(item);
						Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
					}
					progress( 2000 + 3000 * i / count );
				}
				// db lookup files
				count = filesForParsing.size();
				for ( int i=0; i<count; i++ ) {
					if ( scanControl.isStopped() )
						return;
					FileInfo item = filesForParsing.get(i);
					engine.scanBookProperties(item);
					db.save(item);
					Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
					progress( 5000 + 5000 * i / count );
				}
				if ( recursiveScan ) {
					if ( scanControl.isStopped() )
						return;
					for ( int i=baseDir.dirCount()-1; i>=0; i-- )
						scan(baseDir.getDir(i));
				}
			}
			
			public void work() throws Exception {
				// scan (list) directories
				nextProgressTime = startTime + 1500;
				scan( baseDir );
			}
		});
	}

//	private int lastPercent = 0;
//	private long lastProgressUpdate = 0;
//	private final int PROGRESS_UPDATE_INTERVAL = 2000; // 2 seconds
//	private void updateProgress( int percent )
//	{
//		long ts = System.currentTimeMillis();
//		if ( percent!=lastPercent && ts>lastProgressUpdate+PROGRESS_UPDATE_INTERVAL ) {
//			engine.showProgress(percent, ""Scanning directories..."");
//			lastPercent = percent;
//			lastProgressUpdate = ts;
//		}
//	}
	
//	private void lookupDB()
//	{
//		int count = mFileList.size();
//		for ( int i=0; i<count; i++ ) {
//			FileInfo item = mFileList.get(i);
//			boolean found = db.findByPathname(item);
//			if ( found )
//				Log.v(""cr3db"", ""File "" + item.pathname + "" is found in DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//
//			boolean saveToDB = true;
//			if ( !found && item.format==DocumentFormat.FB2 ) {
//				mFilesForParsing.add(item);
//				saveToDB = false;
//			}
//
//			if ( !found && saveToDB ) {
//				db.save(item);
//				Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//			}
//			updateProgress( 1000 + 4000 * i / count );
//		}
//	}
//	
//	private void parseBookProperties()
//	{
//		int count = mFilesForParsing.size();
//		for ( int i=0; i<count; i++ ) {
//			FileInfo item = mFilesForParsing.get(i);
//			engine.scanBookProperties(item);
//			db.save(item);
//			Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//			updateProgress( 5000 + 5000 * i / count );
//		}
//	}
	
	private boolean addRoot( String pathname, int resourceId, boolean listIt)
	{
		return addRoot( pathname, coolReader.getResources().getString(resourceId), listIt);
	}
	private boolean addRoot( String pathname, String filename, boolean listIt)
	{
		FileInfo dir = new FileInfo();
		dir.isDirectory = true;
		dir.pathname = pathname;
		dir.filename = filename;
		if ( mRoot.findItemByPathName(pathname)!=null )
			return false; // exclude duplicates
		if ( listIt && !listDirectory(dir) )
			return false;
		mRoot.addDir(dir);
		dir.parent = mRoot;
		if ( !listIt ) {
			dir.isListed = true;
			dir.isScanned = true;
		}
		return true;
	}
	
	private void addOPDSRoot() {
		FileInfo dir = new FileInfo();
		dir.isDirectory = true;
		dir.pathname = FileInfo.OPDS_LIST_TAG;
		dir.filename = coolReader.getString(R.string.mi_book_opds_root);
		dir.isListed = true;
		dir.isScanned = true;
		dir.parent = mRoot;
		mRoot.addDir(dir);
		db.loadOPDSCatalogs(dir);
	}
	
	private void addSearchRoot() {
		FileInfo dir = new FileInfo();
		dir.isDirectory = true;
		dir.pathname = FileInfo.SEARCH_SHORTCUT_TAG;
		dir.filename = coolReader.getString(R.string.mi_book_search);
		dir.isListed = true;
		dir.isScanned = true;
		dir.parent = mRoot;
		mRoot.addDir(dir);
	}
	
	private void addAuthorsRoot() {
		FileInfo dir = new FileInfo();
		dir.isDirectory = true;
		dir.pathname = FileInfo.AUTHORS_TAG;
		dir.filename = coolReader.getString(R.string.folder_name_books_by_author);
		dir.isListed = true;
		dir.isScanned = true;
		dir.parent = mRoot;
		mRoot.addDir(dir);
	}
	
	/**
	 * Lists all directories from root to directory of specified file, returns found directory.
	 * @param file
	 * @param root
	 * @return
	 */
	private FileInfo findParentInternal( FileInfo file, FileInfo root )
	{
		if ( root==null || file==null || root.isRecentDir() )
			return null;
		if ( !root.isRootDir() && !file.getPathName().startsWith( root.getPathName() ) )
			return null;
		// to list all directories starting root dir
		if ( root.isDirectory && !root.isSpecialDir() )
				listDirectory(root);
		for ( int i=0; i<root.dirCount(); i++ ) {
			FileInfo found = findParentInternal( file, root.getDir(i));
			if ( found!=null )
				return found;
		}
		for ( int i=0; i<root.fileCount(); i++ ) {
			if ( root.getFile(i).getPathName().equals(file.getPathName()) )
				return root;
			if ( root.getFile(i).getPathName().startsWith(file.getPathName() + ""@/"") )
				return root;
		}
		return null;
	}
	
	public final static int MAX_DIR_LIST_TIME = 500; // 0.5 seconds
	
	/**
	 * Lists all directories from root to directory of specified file, returns found directory.
	 * @param file
	 * @param root
	 * @return
	 */
	public FileInfo findParent( FileInfo file, FileInfo root )
	{
		FileInfo parent = findParentInternal(file, root);
		if ( parent==null ) {
			autoAddRootForFile(new File(file.pathname) );
			parent = findParentInternal(file, root);
			if ( parent==null ) {
				L.e(""Cannot find root directory for file "" + file.pathname);
				return null;
			}
		}
		long maxTs = android.os.SystemClock.uptimeMillis() + MAX_DIR_LIST_TIME;
		listSubtrees(root, mHideEmptyDirs ? 5 : 1, maxTs);
		return parent;
	}
	
	/**
	 * List directories in subtree, limited by runtime and depth; remove empty branches (w/o books).  
	 * @param root is directory to start with
	 * @param maxDepth is maximum depth
	 * @param limitTs is limit for android.os.SystemClock.uptimeMillis()
	 * @return true if completed, false if stopped by limit. 
	 */
	private boolean listSubtree( FileInfo root, int maxDepth, long limitTs )
	{
		long ts = android.os.SystemClock.uptimeMillis();
		if ( ts>limitTs || maxDepth<=0 )
			return false;
		listDirectory(root);
		for ( int i=root.dirCount()-1; i>=-0; i-- ) {
			boolean res = listSubtree(root.getDir(i), maxDepth-1, limitTs);
			if ( !res )
				return false;
		}
		if ( mHideEmptyDirs )
			root.removeEmptyDirs();
		return true;
	}
	
	/**
	 * List directories in subtree, limited by runtime and depth; remove empty branches (w/o books).  
	 * @param root is directory to start with
	 * @param maxDepth is maximum depth
	 * @param limitTs is limit for android.os.SystemClock.uptimeMillis()
	 * @return true if completed, false if stopped by limit. 
	 */
	public boolean listSubtrees( FileInfo root, int maxDepth, long limitTs )
	{
		for ( int depth = 1; depth<=maxDepth; depth++ ) {
			boolean res = listSubtree( root, depth, limitTs );
			if ( res )
				return true;
			long ts = android.os.SystemClock.uptimeMillis();
			if ( ts>limitTs )
				return false; // limited by time
			// iterate deeper
		}
		return false; // limited by depth
	}
	
	public FileInfo setSearchResults( FileInfo[] results ) {
		FileInfo existingResults = null;
		for ( int i=0; i<mRoot.dirCount(); i++ ) {
			FileInfo dir = mRoot.getDir(i);
			if ( dir.isSearchDir() ) {
				existingResults = dir;
				dir.clear();
				break;
			}
		}
		if ( existingResults==null ) {
			FileInfo dir = new FileInfo();
			dir.isDirectory = true;
			dir.pathname = FileInfo.SEARCH_RESULT_DIR_TAG;
			dir.filename = coolReader.getResources().getString(R.string.dir_search_results);
			dir.parent = mRoot;
			dir.isListed = true;
			dir.isScanned = true;
			mRoot.addDir(dir);
			existingResults = dir;
		}
		for ( FileInfo item : results )
			existingResults.addFile(item);
		return existingResults;
	}

	private void autoAddRoots( String rootPath, String[] pathsToExclude )
	{
		try {
			File root = new File(rootPath);
			File[] files = root.listFiles();
			if ( files!=null ) {
				for ( File f : files ) {
					if ( !f.isDirectory() )
						continue;
					String fullPath = f.getAbsolutePath();
					if ( engine.isLink(fullPath) ) {
						L.d(""skipping symlink "" + fullPath);
						continue;
					}
					boolean skip = false;
					for ( String path : pathsToExclude ) {
						if ( fullPath.startsWith(path) ) {
							skip = true;
							break;
						}
					}
					if ( skip )
						continue;
					if ( !f.canWrite() )
						continue;
					L.i(""Found possible mount point "" + f.getAbsolutePath());
					addRoot(f.getAbsolutePath(), f.getAbsolutePath(), true);
				}
			}
		} catch ( Exception e ) {
			L.w(""Exception while trying to auto add roots"");
		}
	}
	
	public static final String[] SD_MOUNT_POINTS = {
		""/system/media/sdcard"",
		""/media"",
		""/nand"",
		""/PocketBook701"",
		""/mnt/extsd"",
		""/mnt/ext.sd"",
		""/mnt/external1"",
		""/ext.sd"",
		""/sdcard2"",
	};
	
	public void initRoots(Map<String, String> fsRoots)
	{
		mRoot.clear();
		// create recent books dir
		addRoot( FileInfo.RECENT_DIR_TAG, R.string.dir_recent_books, false);

		// create system dirs
		for (Map.Entry<String, String> entry : fsRoots.entrySet())
			addRoot( entry.getKey(), entry.getValue(), true);

		// create OPDS dir
		addOPDSRoot();
		
		// create search dir
		addSearchRoot();
		
		// create books by author root
		addAuthorsRoot();
	}
	
	public boolean autoAddRootForFile( File f ) {
		File p = f.getParentFile();
		while ( p!=null ) {
			if ( p.getParentFile()==null || p.getParentFile().getParentFile()==null )
				break;
			p = p.getParentFile();
		}
		if ( p!=null ) {
			L.i(""Found possible mount point "" + p.getAbsolutePath());
			return addRoot(p.getAbsolutePath(), p.getAbsolutePath(), true);
		}
		return false;
	}
	
//	public boolean scan()
//	{
//		L.i(""Started scanning"");
//		long start = System.currentTimeMillis();
//		mFileList.clear();
//		mFilesForParsing.clear();
//		mRoot.clear();
//		// create recent books dir
//		FileInfo recentDir = new FileInfo();
//		recentDir.isDirectory = true;
//		recentDir.pathname = ""@recent"";
//		recentDir.filename = ""Recent Books"";
//		mRoot.addDir(recentDir);
//		recentDir.parent = mRoot;
//		// scan directories
//		lastPercent = -1;
//		lastProgressUpdate = System.currentTimeMillis() - 500;
//		boolean res = scanDirectories( mRoot );
//		// process found files
//		lookupDB();
//		parseBookProperties();
//		updateProgress(9999);
//		L.i(""Finished scanning ("" + (System.currentTimeMillis()-start)+ "" ms)"");
//		return res;
//	}
	
	
	public FileInfo getDownloadDirectory() {
		for ( int i=0; i<mRoot.dirCount(); i++ ) {
			FileInfo item = mRoot.getDir(i);
			if ( !item.isSpecialDir() && !item.isArchive ) {
				FileInfo books = item.findItemByPathName(item.pathname + ""/Books"");
				if (books == null)
					books = item.findItemByPathName(item.pathname + ""/books"");
				if (books != null && books.exists())
					return books;
				File dir = new File(item.getPathName());
				if (dir.isDirectory()) {
					if (!dir.canWrite())
						Log.w(""cr3"", ""Directory "" + dir + "" is readonly"");
					File f = new File( dir, ""Books"" );
					if ( f.mkdirs() ) {
						books = new FileInfo(f);
						books.parent = item;
						item.addDir(books);
						books.isScanned = true;
						books.isListed = true;
						return books;
					}
				}
			}
		}
		return null;
	}
	
	public FileInfo getRoot() 
	{
		return mRoot;
	}

	public FileInfo getOPDSRoot() 
	{
		for ( int i=0; i<mRoot.dirCount(); i++ ) {
			if ( mRoot.getDir(i).isOPDSRoot() )
				return mRoot.getDir(i);
		}
		L.w(""OPDS root directory not found!"");
		return null;
	}
	
	public Scanner( CoolReader coolReader, CRDB db, Engine engine )
	{
		this.engine = engine;
		this.db = db;
		this.coolReader = coolReader;
		mRoot = new FileInfo();
		mRoot.path = FileInfo.ROOT_DIR_TAG;	
		mRoot.filename = ""File Manager"";
		mRoot.pathname = FileInfo.ROOT_DIR_TAG;
		mRoot.isListed = true;
		mRoot.isScanned = true;
		mRoot.isDirectory = true;
	}

	private final Engine engine;
	private final CRDB db;
	private final CoolReader coolReader;
}
",True,34,49,0,0,3,21,5,6,L0
31,org.coolreader.crengine.SwitchProfileDialog.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.database.DataSetObserver;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.TextView;

public class SwitchProfileDialog extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	ListView mListView;
	int currentProfile;
	public SwitchProfileDialog(CoolReader coolReader, ReaderView readerView)
	{
		super(coolReader, coolReader.getResources().getString(R.string.action_switch_settings_profile), false, false);
        setCancelable(true);
		this.mCoolReader = coolReader;
		this.mReaderView = readerView;
		this.mListView = new ListView(getContext());
		currentProfile = mReaderView.getCurrentProfile(); // TODO: get from settings
		mListView.setOnItemClickListener(new OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> listview, View view,
					int position, long id) {
				mReaderView.setCurrentProfile(position + 1);
				dismiss();
			}
		});
		mListView.setOnItemLongClickListener(new OnItemLongClickListener() {
			@Override
			public boolean onItemLongClick(AdapterView<?> listview, View view,
					int position, long id) {
				// TODO: rename?
				dismiss();
				return true;
			}
		});
		mListView.setLongClickable(true);
		mListView.setClickable(true);
		mListView.setFocusable(true);
		mListView.setFocusableInTouchMode(true);
		mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		setView(mListView);
		setFlingHandlers(mListView, new Runnable() {
			@Override
			public void run() {
				// cancel
				SwitchProfileDialog.this.dismiss();
			}
		}, new Runnable() {
			@Override
			public void run() {
				// 
				SwitchProfileDialog.this.dismiss();
			}
		});
		mListView.setAdapter(new ProfileListAdapter());
	}

	
	private String[] profileNames = {
		""Profile 1"",
		""Profile 2"",
		""Profile 3"",
		""Profile 4"",
		""Profile 5"",
		""Profile 6"",
		""Profile 7"",
	};

	class ProfileListAdapter extends BaseListAdapter {
		public boolean areAllItemsEnabled() {
			return true;
		}

		public boolean isEnabled(int arg0) {
			return true;
		}

		public int getCount() {
			return Settings.MAX_PROFILES;
		}

		public Object getItem(int position) {
			return profileNames[position];
		}

		public long getItemId(int position) {
			return position;
		}

		public int getItemViewType(int position) {
			return 0;
		}

		
		public View getView(int position, View convertView, ViewGroup parent) {
			View view;
			boolean isCurrentItem = position == currentProfile - 1;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				LayoutInflater inflater = LayoutInflater.from(getContext());
				view = inflater.inflate(R.layout.profile_item, null);
			} else {
				view = (View)convertView;
			}
			RadioButton cb = (RadioButton)view.findViewById(R.id.option_value_check);
			TextView title = (TextView)view.findViewById(R.id.option_value_text);
			cb.setChecked(isCurrentItem);
			title.setText(profileNames[position]);
			return view;
		}

		public int getViewTypeCount() {
			return 1;
		}

		public boolean hasStableIds() {
			return true;
		}

		public boolean isEmpty() {
			return false;
		}
	}

}

",False,39,49,0,0,3,36,1,5,L0
32,org.coolreader.crengine.ReaderCallback.java,"package org.coolreader.crengine;

public interface ReaderCallback {
    /// on starting file loading
    void OnLoadFileStart( String filename );
    /// format detection finished
    String OnLoadFileFormatDetected( DocumentFormat fileFormat );
    /// file loading is finished successfully - drawCoveTo() may be called there
    void OnLoadFileEnd();
    /// first page is loaded from file an can be formatted for preview
    void OnLoadFileFirstPagesReady();
    /// file progress indicator, called with values 0..100
    boolean OnLoadFileProgress( int percent );
    /// document formatting started
    void OnFormatStart();
    /// document formatting finished
    void OnFormatEnd();
    /// format progress, called with values 0..100
    boolean OnFormatProgress( int percent );
    /// format progress, called with values 0..100
    boolean OnExportProgress( int percent );
    /// file load finiished with error
    void OnLoadFileError( String message );
    /// Override to handle external links
    void OnExternalLink( String url, String nodeXPath );
    /// Override to handle external links
    void OnImageCacheClear();
}
",False,36,31,4,13,1,1,2,1,L0
33,org.coolreader.crengine.ColorPickerDialog.java,"package org.coolreader.crengine;

// based on color picker from 
// http://www.anddev.org/announce_color_picker_dialog-t10771.html

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.res.Resources;
import android.content.res.Resources.NotFoundException;
import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.BitmapFactory;
import android.graphics.BlurMaskFilter;
import android.graphics.BlurMaskFilter.Blur;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.PixelFormat;
import android.graphics.PorterDuff.Mode;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.LayerDrawable;
import android.os.SystemClock;
import android.util.StateSet;
import android.view.LayoutInflater;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Transformation;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;
import android.widget.TextView;

public class ColorPickerDialog extends BaseDialog implements OnSeekBarChangeListener {

    public interface OnColorChangedListener {
        public void colorChanged(int color);
    }

	private SeekBar mR;
	private SeekBar mG;
	private SeekBar mB;
	private SeekBar mHue;
	private SeekBar mSaturation;
	private SeekBar mValue;
	private TextView mLabel;
	private OnColorChangedListener mListener;
	private int mColor;
	private GradientDrawable mPreviewDrawable;

	public ColorPickerDialog(CoolReader activity, OnColorChangedListener listener, int color, String title) {
		super(activity, title, true, true);
		mListener = listener;

		Resources res = activity.getResources();
		setTitle(title);
		View root = LayoutInflater.from(activity).inflate(R.layout.color_picker, null);
		setView(root);
		
		View preview = root.findViewById(R.id.preview);
		mPreviewDrawable = new GradientDrawable();
		// 2 pix more than color_picker_frame's radius
		mPreviewDrawable.setCornerRadius(7);
		Drawable[] layers;
		layers = new Drawable[] {
				mPreviewDrawable,
				res.getDrawable(R.drawable.color_picker_frame),
		};
		preview.setBackgroundDrawable(new LayerDrawable(layers));
		
		mR = (SeekBar) root.findViewById(R.id.r);
		mG = (SeekBar) root.findViewById(R.id.g);
		mB = (SeekBar) root.findViewById(R.id.b);
		mHue = (SeekBar) root.findViewById(R.id.hue);
		mSaturation = (SeekBar) root.findViewById(R.id.saturation);
		mValue = (SeekBar) root.findViewById(R.id.value);
		mLabel = (TextView) root.findViewById(R.id.value_label);
		
		mColor = color;
		int r = Color.red(mColor);
		int g = Color.green(mColor);
		int b = Color.blue(mColor);
		float[] hsv = new float[3];
		Color.colorToHSV(color, hsv);
		int h = (int) (hsv[0] * mHue.getMax() / 360);
		int s = (int) (hsv[1] * mSaturation.getMax());
		int v = (int) (hsv[2] * mValue.getMax());
		setupSeekBar(mR, R.string.options_color_r, r, res);
		setupSeekBar(mG, R.string.options_color_g, g, res);
		setupSeekBar(mB, R.string.options_color_b, b, res);
		setupSeekBar(mHue, R.string.options_color_hue, h, res);
		setupSeekBar(mSaturation, R.string.options_color_saturation, s, res);
		setupSeekBar(mValue, R.string.options_color_brightness, v, res);
		
		updatePreview(color);
	}
	
	private void setupSeekBar(SeekBar seekBar, int id, int value, Resources res) {
		seekBar.setProgressDrawable(new TextSeekBarDrawable(res, id, value < seekBar.getMax() / 2));
		seekBar.setProgress(value);
		seekBar.setOnSeekBarChangeListener(this);
	}

	private void updateHSV() {
		float[] hsv = {
			360 * mHue.getProgress() / (float) mHue.getMax(),
			mSaturation.getProgress() / (float) mSaturation.getMax(),
			mValue.getProgress() / (float) mValue.getMax(),
		};
		mColor = Color.HSVToColor(hsv);
		mR.setProgress(Color.red(mColor));
		mG.setProgress(Color.green(mColor));
		mB.setProgress(Color.blue(mColor));
		updatePreview(mColor);
	}
	
	private void updateRGB() {
		mColor = Color.rgb(mR.getProgress(), mG.getProgress(), mB.getProgress());
		float[] hsv = new float[3];
		Color.colorToHSV(mColor, hsv);
		int h = (int) (hsv[0] * mHue.getMax() / 360);
		int s = (int) (hsv[1] * mSaturation.getMax());
		int v = (int) (hsv[2] * mValue.getMax());
		mHue.setProgress(h);
		mSaturation.setProgress(s);
		mValue.setProgress(v);
		updatePreview(mColor);
	}
	
	private static String byteToHex(int n) {
		String s = Integer.toHexString(n & 255);
		if (s.length()<2)
			s = ""0"" + s;
		return s;
	}
	private static String colorToHex(int n) {
		return (""#"" + byteToHex(Color.red(n))
			 + byteToHex(Color.green(n))
			 + byteToHex(Color.blue(n))).toUpperCase();
	}
	private void updatePreview(int color) {
		mPreviewDrawable.setColor(color);
		mPreviewDrawable.invalidateSelf();
		mLabel.setText(colorToHex(mColor));
	}

	public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
		if ( fromUser ) {
			if ( seekBar==mR || seekBar==mG || seekBar==mB )
				updateRGB();
			else
				updateHSV();
		}
	}

	public void onStartTrackingTouch(SeekBar seekBar) {
	}

	public void onStopTrackingTouch(SeekBar seekBar) {
	}

	@Override
	protected void onPositiveButtonClick() {
		mListener.colorChanged(mColor);
		super.onPositiveButtonClick();
	}

	static class IconPreviewDrawable extends Drawable {
		private Bitmap mBitmap;
		private Bitmap mTmpBitmap;
		private Canvas mTmpCanvas;
		private int mTintColor;
		

		public IconPreviewDrawable(Resources res, int id) {
			Bitmap b;
			try {
				b = BitmapFactory.decodeResource(res, id);
				if (b == null) {
					b = BitmapFactory.decodeResource(res, R.drawable.color_picker_icon);
				}
			} catch (NotFoundException e) {
				b = BitmapFactory.decodeResource(res, R.drawable.color_picker_icon);
			}
			mBitmap = b;
			mTmpBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Config.ARGB_8888);
			mTmpCanvas = new Canvas(mTmpBitmap);
		}
		
		@Override
		public void draw(Canvas canvas) {
			Rect b = getBounds();
			float x = (b.width() - mBitmap.getWidth()) / 2.0f;
			float y = 0.75f * b.height() - mBitmap.getHeight() / 2.0f;
			
			mTmpCanvas.drawColor(0, Mode.CLEAR);
			mTmpCanvas.drawBitmap(mBitmap, 0, 0, null);
			mTmpCanvas.drawColor(mTintColor, Mode.SRC_ATOP);
			canvas.drawBitmap(mTmpBitmap, x, y, null);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}
		
		@Override
		public void setColorFilter(int color, Mode mode) {
			mTintColor = color;
		}
	}
	
	static final int[] STATE_FOCUSED = {android.R.attr.state_focused};
	static final int[] STATE_PRESSED = {android.R.attr.state_pressed};
	
	static class TextSeekBarDrawable extends Drawable implements Runnable {
		
		private static final String TAG = ""TextSeekBarDrawable"";
		private static final long DELAY = 50;
		private String mText;
		private Drawable mProgress;
		private Paint mPaint;
		private Paint mOutlinePaint;
		private float mTextWidth;
		private boolean mActive;
		private float mTextXScale;
		private int mDelta;
		private ScrollAnimation mAnimation;

		public TextSeekBarDrawable(Resources res, int id, boolean labelOnRight) {
			mText = res.getString(id);
			mProgress = res.getDrawable(android.R.drawable.progress_horizontal);
			mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
			mPaint.setTypeface(Typeface.DEFAULT_BOLD);
			mPaint.setTextSize(16);
			mPaint.setColor(0xff000000);
			mOutlinePaint = new Paint(mPaint);
			mOutlinePaint.setStyle(Style.STROKE);
			mOutlinePaint.setStrokeWidth(3);
			mOutlinePaint.setColor(0xbbffc300);
			mOutlinePaint.setMaskFilter(new BlurMaskFilter(1, Blur.NORMAL));
			mTextWidth = mOutlinePaint.measureText(mText);
			mTextXScale = labelOnRight? 1 : 0;
			mAnimation = new ScrollAnimation();
		}

		@Override
		protected void onBoundsChange(Rect bounds) {
			mProgress.setBounds(bounds);
		}
		
		@Override
		protected boolean onStateChange(int[] state) {
			mActive = StateSet.stateSetMatches(STATE_FOCUSED, state) | StateSet.stateSetMatches(STATE_PRESSED, state);
			invalidateSelf();
			return false;
		}
		
		@Override
		public boolean isStateful() {
			return true;
		}
		
		@Override
		protected boolean onLevelChange(int level) {
//			Log.d(TAG, ""onLevelChange "" + level);
			if (level < 4000 && mDelta <= 0) {
//				Log.d(TAG, ""onLevelChange scheduleSelf ++"");
				mDelta = 1;
				mAnimation.startScrolling(mTextXScale, 1);
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			} else
			if (level > 6000 && mDelta >= 0) {
//				Log.d(TAG, ""onLevelChange scheduleSelf --"");
				mDelta = -1;
				mAnimation.startScrolling(mTextXScale, 0);
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			}
			return mProgress.setLevel(level);
		}
		
		@Override
		public void draw(Canvas canvas) {
			mProgress.draw(canvas);

			if (mAnimation.hasStarted() && !mAnimation.hasEnded()) {
				// pending animation
				mAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), null);
				mTextXScale = mAnimation.getCurrent();
//				Log.d(TAG, ""draw "" + mTextX + "" "" + SystemClock.uptimeMillis());
			}
			
			Rect bounds = getBounds();
			float x = 6 + mTextXScale * (bounds.width() - mTextWidth - 6 - 6);
			float y = (bounds.height() + mPaint.getTextSize()) / 2;
			mOutlinePaint.setAlpha(mActive? 255 : 255 / 2);
			mPaint.setAlpha(mActive? 255 : 255 / 2);
			canvas.drawText(mText, x, y, mOutlinePaint);
			canvas.drawText(mText, x, y, mPaint);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}

		public void run() {
			mAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), null);
			// close interpolation of mTextX
			mTextXScale = mAnimation.getCurrent();
			if (!mAnimation.hasEnded()) {
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			}
			invalidateSelf();
//			Log.d(TAG, ""run "" + mTextX + "" "" + SystemClock.uptimeMillis());
		}
	}
	
	static class ScrollAnimation extends Animation {
		private static final String TAG = ""ScrollAnimation"";
		private static final long DURATION = 750;
		private float mFrom;
		private float mTo;
		private float mCurrent;
		
		public ScrollAnimation() {
			setDuration(DURATION);
			setInterpolator(new DecelerateInterpolator());
		}
		
		public void startScrolling(float from, float to) {
			mFrom = from;
			mTo = to;
			startNow();
		}
		
		@Override
		protected void applyTransformation(float interpolatedTime, Transformation t) {
			mCurrent = mFrom + (mTo - mFrom) * interpolatedTime;
//			Log.d(TAG, ""applyTransformation "" + mCurrent);
		}
		
		public float getCurrent() {
			return mCurrent;
		}
	}
}
",False,1,49,0,0,3,23,1,2,L0
34,org.coolreader.crengine.TTS.java,"package org.coolreader.crengine;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Locale;

import android.content.Context;

/**
 * Wrapper for android.speech.tts.TextToSpeech
 * 
 * For compatibility with Android 1.5
 */
public class TTS {
	
	public static final Logger log = L.create(""tts"");
	
	// constants from TextToSpeech
	public final static String	ACTION_TTS_QUEUE_PROCESSING_COMPLETED=""android.speech.tts.TTS_QUEUE_PROCESSING_COMPLETED"";	//Broadcast Action: The TextToSpeech synthesizer has completed processing of all the text in the speech queue.
	public final static int	ERROR=1;	//Denotes a generic operation failure.
	public final static int	LANG_AVAILABLE=0;	//Denotes the language is available for the language by the locale, but not the country and variant.
	public final static int	LANG_COUNTRY_AVAILABLE=1;	//Denotes the language is available for the language and country specified by the locale, but not the variant.
	public final static int	LANG_COUNTRY_VAR_AVAILABLE=2;	//Denotes the language is available exactly as specified by the locale.
	public final static int	LANG_MISSING_DATA=-1;	//Denotes the language data is missing.
	public final static int	LANG_NOT_SUPPORTED=-2;	//Denotes the language is not supported.
	public final static int	QUEUE_ADD=1;	//Queue mode where the new entry is added at the end of the playback queue.
	public final static int	QUEUE_FLUSH=0;	//Queue mode where all entries in the playback queue (media to be played and text to be synthesized) are dropped and replaced by the new entry.
	public final static int	SUCCESS=0;  //Denotes a successful operation.
	public final static String KEY_PARAM_UTTERANCE_ID = ""utteranceId"";
	
	private static Class<?> textToSpeechClass;
	private static Constructor<?> textToSpeech_constructor;
	private static Class<?> onInitListenerClass;
	//private static Method onInitListener_onInit; //	void onInit(int status)
	private static Class<?> onUtteranceCompletedListenerClass;
	//private static Method onUtteranceCompletedListener_onUtteranceCompleted;
	
	private static Method textToSpeech_addEarcon; //int addEarcon(String earcon, String filename); // Adds a mapping between a string of text and a sound file.
	private static Method textToSpeech_addEarcon2; //int 	addEarcon(String earcon, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
	private static Method textToSpeech_addSpeech; //int 	addSpeech(String text, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
	private static Method textToSpeech_addSpeech2; //int 	addSpeech(String text, String filename); //Adds a mapping between a string of text and a sound file.
	private static Method textToSpeech_areDefaultsEnforced; //boolean 	areDefaultsEnforced(); // Returns whether or not the user is forcing their defaults to override the Text-To-Speech settings set by applications.
	private static Method textToSpeech_getDefaultEngine; //String 	getDefaultEngine(); // Gets the packagename of the default speech synthesis engine.
	private static Method textToSpeech_getLanguage; //Locale 	getLanguage(); // Returns a Locale instance describing the language currently being used by the TextToSpeech engine.
	private static Method textToSpeech_isLanguageAvailable; //int 	isLanguageAvailable(Locale loc); // Checks if the specified language as represented by the Locale is available and supported.
	private static Method textToSpeech_isSpeaking; //boolean isSpeaking(); // Returns whether or not the TextToSpeech engine is busy speaking.
	private static Method textToSpeech_playEarcon; //int 	playEarcon(String earcon, int queueMode, HashMap<String, String> params); // Plays the earcon using the specified queueing mode and parameters.
	private static Method textToSpeech_playSilence; //int 	playSilence(long durationInMs, int queueMode, HashMap<String, String> params); // Plays silence for the specified amount of time using the specified queue mode.
	private static Method textToSpeech_setEngineByPackageName; //int 	setEngineByPackageName(String enginePackageName); // Sets the speech synthesis engine to be used by its packagename.
	private static Method textToSpeech_setLanguage; //int 	setLanguage(Locale loc); // Sets the language for the TextToSpeech engine.
	private static Method textToSpeech_setOnUtteranceCompletedListener; //int 	setOnUtteranceCompletedListener(TextToSpeech.OnUtteranceCompletedListener listener); // Sets the OnUtteranceCompletedListener that will fire when an utterance completes.
	private static Method textToSpeech_setPitch; //int 	setPitch(float pitch); // Sets the speech pitch for the TextToSpeech engine.
	private static Method textToSpeech_setSpeechRate; //int 	setSpeechRate(float speechRate); // Sets the speech rate for the TextToSpeech engine.
	private static Method textToSpeech_shutdown; //void 	shutdown() ; // Releases the resources used by the TextToSpeech engine.
	private static Method textToSpeech_speak; //int 	speak(String text, int queueMode, HashMap<String, String> params); // Speaks the string using the specified queuing strategy and speech parameters.
	private static Method textToSpeech_stop; //int 	stop() ; // Interrupts the current utterance (whether played or rendered to file) and discards other utterances in the queue.
	private static Method textToSpeech_synthesizeToFile; //int 	synthesizeToFile(String text, HashMap<String, String> params, String filename); // Synthesizes the given text to a file using the specified parameters.

	private Object tts;
	private boolean initialized;
	
	/**
	 * @param listener is listener to call on init finished
	 * @return proxy
	 */
	private Object createOnInitProxy( final OnInitListener listener ) {
		InvocationHandler handler = new InvocationHandler() {

			@Override
			public Object invoke(Object proxy, Method method, Object[] args)
					throws Throwable {
                log.d(""invoking OnInit - "" + method.getName());
				if ( ""onInit"".equals(method.getName()) ) {
					int status = (Integer)(args[0]);
					log.i(""OnInitListener.onInit() is called: status="" + status);
					if ( status==SUCCESS )
						initialized = true;
					listener.onInit(status);
				}
				return null;
			}
			
		};
		return Proxy.newProxyInstance(
				onInitListenerClass.getClassLoader(),
		        new Class[] { onInitListenerClass },
		        handler);		
	}
	
	/**
	 * @param listener is listener to call on init finished
	 * @return proxy
	 */
	private Object createOnUtteranceCompletedListener( final OnUtteranceCompletedListener listener ) {
		InvocationHandler handler = new InvocationHandler() {

			@Override
			public Object invoke(Object proxy, Method method, Object[] args)
					throws Throwable {
				log.d(""invoking OnUtteranceCompletedListener - "" + method.getName());
                if ( ""onUtteranceCompleted"".equals(method.getName()) ) {
					String id = (String)(args[0]);
					log.d(""OnUtteranceCompletedListener.onUtteranceCompleted() is called: id="" + id);
					listener.onUtteranceCompleted(id);
				}
				return null;
			}
			
		};
		return Proxy.newProxyInstance(
				onUtteranceCompletedListenerClass.getClassLoader(),
		        new Class[] { onUtteranceCompletedListenerClass },
		        handler);		
	}
	
	private static boolean classesFound;
	static {
		try {
			onInitListenerClass = Class.forName(""android.speech.tts.TextToSpeech$OnInitListener"");
			//onInitListener_onInit = onInitListenerClass.getMethod(""onInit"", new Class[] {int.class});
			onUtteranceCompletedListenerClass = Class.forName(""android.speech.tts.TextToSpeech$OnUtteranceCompletedListener"");
			//onUtteranceCompletedListener_onUtteranceCompleted = onUtteranceCompletedListenerClass.getMethod(""onUtteranceCompleted"", new Class[] {String.class});
			textToSpeechClass = Class.forName(""android.speech.tts.TextToSpeech"");
			textToSpeech_constructor = textToSpeechClass.getConstructor(new Class[] {Context.class, onInitListenerClass}); 
			textToSpeech_addEarcon = textToSpeechClass.getMethod(""addEarcon"", new Class[] {String.class, String.class}); //int addEarcon(String earcon, String filename); // Adds a mapping between a string of text and a sound file.
			textToSpeech_addEarcon2 = textToSpeechClass.getMethod(""addEarcon"", new Class[] {String.class, String.class, int.class}); //int 	addEarcon(String earcon, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
			textToSpeech_addSpeech = textToSpeechClass.getMethod(""addSpeech"", new Class[] {String.class, String.class, int.class}); //int 	addSpeech(String text, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
			textToSpeech_addSpeech2 = textToSpeechClass.getMethod(""addSpeech"", new Class[] {String.class, String.class}); //int 	addSpeech(String text, String filename); //Adds a mapping between a string of text and a sound file.
			textToSpeech_areDefaultsEnforced = textToSpeechClass.getMethod(""areDefaultsEnforced"", new Class[] {}); //boolean 	areDefaultsEnforced(); // Returns whether or not the user is forcing their defaults to override the Text-To-Speech settings set by applications.
			textToSpeech_getDefaultEngine = textToSpeechClass.getMethod(""getDefaultEngine"", new Class[] {}); //String 	getDefaultEngine(); // Gets the packagename of the default speech synthesis engine.
			textToSpeech_getLanguage = textToSpeechClass.getMethod(""getLanguage"", new Class[] {}); //Locale 	getLanguage(); // Returns a Locale instance describing the language currently being used by the TextToSpeech engine.
			textToSpeech_isLanguageAvailable = textToSpeechClass.getMethod(""isLanguageAvailable"", new Class[] {Locale.class}); //int 	isLanguageAvailable(Locale loc); // Checks if the specified language as represented by the Locale is available and supported.
			textToSpeech_isSpeaking = textToSpeechClass.getMethod(""isSpeaking"", new Class[] {}); //boolean isSpeaking(); // Returns whether or not the TextToSpeech engine is busy speaking.
			textToSpeech_playEarcon = textToSpeechClass.getMethod(""playEarcon"", new Class[] {String.class, int.class, HashMap.class}); //int 	playEarcon(String earcon, int queueMode, HashMap<String, String> params); // Plays the earcon using the specified queueing mode and parameters.
			textToSpeech_playSilence = textToSpeechClass.getMethod(""playSilence"", new Class[] {long.class, int.class, HashMap.class}); //int 	playSilence(long durationInMs, int queueMode, HashMap<String, String> params); // Plays silence for the specified amount of time using the specified queue mode.
			textToSpeech_setEngineByPackageName = textToSpeechClass.getMethod(""setEngineByPackageName"", new Class[] {String.class}); //int 	setEngineByPackageName(String enginePackageName); // Sets the speech synthesis engine to be used by its packagename.
			textToSpeech_setLanguage = textToSpeechClass.getMethod(""setLanguage"", new Class[] {Locale.class}); //int 	setLanguage(Locale loc); // Sets the language for the TextToSpeech engine.
			textToSpeech_setOnUtteranceCompletedListener = textToSpeechClass.getMethod(""setOnUtteranceCompletedListener"", new Class[] {onUtteranceCompletedListenerClass}); //int 	setOnUtteranceCompletedListener(TextToSpeech.OnUtteranceCompletedListener listener); // Sets the OnUtteranceCompletedListener that will fire when an utterance completes.
			textToSpeech_setPitch = textToSpeechClass.getMethod(""setPitch"", new Class[] {float.class}); //int 	setPitch(float pitch); // Sets the speech pitch for the TextToSpeech engine.
			textToSpeech_setSpeechRate = textToSpeechClass.getMethod(""setSpeechRate"", new Class[] {float.class}); //int 	setSpeechRate(float speechRate); // Sets the speech rate for the TextToSpeech engine.
			textToSpeech_shutdown = textToSpeechClass.getMethod(""shutdown"", new Class[] {}); //void 	shutdown() ; // Releases the resources used by the TextToSpeech engine.
			textToSpeech_speak = textToSpeechClass.getMethod(""speak"", new Class[] {String.class, int.class, HashMap.class}); //int 	speak(String text, int queueMode, HashMap<String, String> params); // Speaks the string using the specified queuing strategy and speech parameters.
			textToSpeech_stop = textToSpeechClass.getMethod(""stop"", new Class[] {}); //int 	stop() ; // Interrupts the current utterance (whether played or rendered to file) and discards other utterances in the queue.
			textToSpeech_synthesizeToFile = textToSpeechClass.getMethod(""synthesizeToFile"", new Class[] {String.class, HashMap.class, String.class}); //int 	synthesizeToFile(String text, HashMap<String, String> params, String filename); // Synthesizes the given text to a file using the specified parameters.
			classesFound = true;
			L.i(""TTS classes initialized successfully"");
		} catch ( Exception e ) {
			L.e(""Exception while initializing TTS classes: tts will be disabled"", e);
			classesFound = false;
		}
	}
	
	public interface OnInitListener {
		void onInit(int status);
	}
	
	public interface OnUtteranceCompletedListener {
		/**
		 * Called to signal the completion of the synthesis of the utterance that was identified with the string parameter.
		 * @param utteranceId
		 */
		void 	onUtteranceCompleted(String utteranceId);
	}
	
	public interface OnTTSCreatedListener {
		void onCreated(TTS tts);
	}
	

	public TTS(Context context, OnInitListener listener ) {
		if ( !classesFound ) {
			L.e(""Cannot create TTS object : TTS classes not initialized"");
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		}
		try {
			tts = textToSpeech_constructor.newInstance(context, createOnInitProxy(listener));
			L.i(""TTS object created successfully"");
//	    	setOnUtteranceCompletedListener(new TTS.OnUtteranceCompletedListener() {
//				
//				@Override
//				public void onUtteranceCompleted(String utteranceId) {
//					L.i(""TTS utterance completed: "" + utteranceId);
//					// TODO
//				}
//			});
		} catch ( InvocationTargetException e ) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		} catch (IllegalArgumentException e) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		} catch (InstantiationException e) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		} catch (IllegalAccessException e) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		}
	}

	// Adds a mapping between a string of text and a sound file.
	public int addEarcon(String earcon, String filename) {
		try {
			return (Integer)textToSpeech_addEarcon.invoke(tts, earcon, filename);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	
	// Adds a mapping between a string of text and a sound resource in a package.
	public int 	addEarcon(String earcon, String packagename, int resourceId) {
		try {
			return (Integer)textToSpeech_addEarcon2.invoke(tts, packagename, resourceId);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	
	// Adds a mapping between a string of text and a sound resource in a package.
	public int 	addSpeech(String text, String packagename, int resourceId) {
		try {
			return (Integer)textToSpeech_addSpeech.invoke(tts, text, packagename, resourceId);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	//Adds a mapping between a string of text and a sound file.
	public int 	addSpeech(String text, String filename) {
		try {
			return (Integer)textToSpeech_addSpeech2.invoke(tts, text, filename);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Returns whether or not the user is forcing their defaults to override the Text-To-Speech settings set by applications.
	public boolean areDefaultsEnforced() {
		try {
			return (Boolean)textToSpeech_areDefaultsEnforced.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Gets the packagename of the default speech synthesis engine.
	public String 	getDefaultEngine() {
		try {
			return (String)textToSpeech_getDefaultEngine.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Returns a Locale instance describing the language currently being used by the TextToSpeech engine.
	public Locale 	getLanguage() {
		try {
			return (Locale)textToSpeech_getLanguage.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Checks if the specified language as represented by the Locale is available and supported.
	public int 	isLanguageAvailable(Locale loc) {
		try {
			return (Integer)textToSpeech_isLanguageAvailable.invoke(tts, loc);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Returns whether or not the TextToSpeech engine is busy speaking.
	public boolean isSpeaking() {
		try {
			return (Boolean)textToSpeech_isSpeaking.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Plays the earcon using the specified queueing mode and parameters.
	public int playEarcon(String earcon, int queueMode, HashMap<String, String> params) {
		try {
			return (Integer)textToSpeech_playEarcon.invoke(tts, earcon, queueMode, params);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Plays silence for the specified amount of time using the specified queue mode.
	public int 	playSilence(long durationInMs, int queueMode, HashMap<String, String> params) {
		try {
			return (Integer)textToSpeech_playSilence.invoke(tts, durationInMs, queueMode, params);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the speech synthesis engine to be used by its packagename.
	public int setEngineByPackageName(String enginePackageName) {
		try {
			return (Integer)textToSpeech_setEngineByPackageName.invoke(tts, enginePackageName);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the language for the TextToSpeech engine.
	public int setLanguage(Locale loc) {
		try {
			return (Integer)textToSpeech_setLanguage.invoke(tts, loc);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the OnUtteranceCompletedListener that will fire when an utterance completes.
	public int setOnUtteranceCompletedListener(OnUtteranceCompletedListener listener) {
		try {
			return (Integer)textToSpeech_setOnUtteranceCompletedListener.invoke(tts, createOnUtteranceCompletedListener(listener));
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the speech pitch for the TextToSpeech engine.
	public int 	setPitch(float pitch) {
		try {
			return (Integer)textToSpeech_setPitch.invoke(tts, pitch);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the speech rate for the TextToSpeech engine.
	public int 	setSpeechRate(float speechRate) {
		try {
			return (Integer)textToSpeech_setSpeechRate.invoke(tts, speechRate);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}

	// Releases the resources used by the TextToSpeech engine.
	public void shutdown() {
		if ( tts!=null && initialized )
		try {
			initialized = false;
			textToSpeech_shutdown.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}

	// Speaks the string using the specified queuing strategy and speech parameters.
	public int speak(String text, int queueMode, HashMap<String, String> params) {
        try {
            L.v(""speak("" + text + "")"");
            int res = (Integer) textToSpeech_speak.invoke(tts, text, queueMode,
                    params);
            L.v(""speak() returned "" + res);
            return res;
        } catch (Exception e) {
            L.e(""Exception while calling tts"", e);
            throw new IllegalStateException(e);
        }
	}
	// Interrupts the current utterance (whether played or rendered to file) and discards other utterances in the queue.
	public int 	stop() {
		try {
			return (Integer)textToSpeech_stop.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Synthesizes the given text to a file using the specified parameters.
	public int 	synthesizeToFile(String text, HashMap<String, String> params, String filename) {
		try {
			return (Integer)textToSpeech_synthesizeToFile.invoke(tts, text, params, filename);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	
	public boolean isInitialized() {
		return false;
	}
	
	public static boolean isFound() {
		return classesFound;
	}
}
",True,28,49,0,0,5,32,3,2,L0
35,org.coolreader.crengine.BookInfoDialog.java,"package org.coolreader.crengine;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TextView;

public class BookInfoDialog extends BaseDialog {
	private final CoolReader mCoolReader;
	private final LayoutInflater mInflater; 
	private Map<String, Integer> mLabelMap;
	private void fillMap() {
		mLabelMap = new HashMap<String, Integer>();
		mLabelMap.put(""section.system"", R.string.book_info_section_system);
		mLabelMap.put(""system.version"", R.string.book_info_system_version);
		mLabelMap.put(""system.battery"", R.string.book_info_system_battery);
		mLabelMap.put(""system.time"", R.string.book_info_system_time);
		mLabelMap.put(""section.file"", R.string.book_info_section_file_properties);
		mLabelMap.put(""file.name"", R.string.book_info_file_name);
		mLabelMap.put(""file.path"", R.string.book_info_file_path);
		mLabelMap.put(""file.arcname"", R.string.book_info_file_arcname);
		mLabelMap.put(""file.arcpath"", R.string.book_info_file_arcpath);
		mLabelMap.put(""file.arcsize"", R.string.book_info_file_arcsize);
		mLabelMap.put(""file.size"", R.string.book_info_file_size);
		mLabelMap.put(""file.format"", R.string.book_info_file_format);
		mLabelMap.put(""section.position"", R.string.book_info_section_current_position);
		mLabelMap.put(""position.percent"", R.string.book_info_position_percent);
		mLabelMap.put(""position.page"", R.string.book_info_position_page);
		mLabelMap.put(""position.chapter"", R.string.book_info_position_chapter);
		mLabelMap.put(""section.book"", R.string.book_info_section_book_properties);
		mLabelMap.put(""book.authors"", R.string.book_info_book_authors);
		mLabelMap.put(""book.title"", R.string.book_info_book_title);
		mLabelMap.put(""book.series"", R.string.book_info_book_series_name);
	}
	
	private void addItem(TableLayout table, String item) {
		int p = item.indexOf(""="");
		if ( p<0 )
			return;
		String name = item.substring(0, p).trim();
		String value = item.substring(p+1).trim();
		if ( name.length()==0 || value.length()==0 )
			return;
		boolean isSection = false;
		if ( ""section"".equals(name) ) {
			name = """";
			Integer id = mLabelMap.get(value);
			if ( id==null )
				return;
			String section = getContext().getString(id);
			if ( section!=null )
				value = section;
			isSection = true;
		} else {
			Integer id = mLabelMap.get(name);
			String title = id!=null ? getContext().getString(id) : name;
			if ( title!=null )
				name = title;
		}
		TableRow tableRow = (TableRow)mInflater.inflate(isSection ? R.layout.book_info_section : R.layout.book_info_item, null);
		TextView nameView = (TextView)tableRow.findViewById(R.id.name);
		TextView valueView = (TextView)tableRow.findViewById(R.id.value);
		nameView.setText(name);
		valueView.setText(value);
		table.addView(tableRow);
	}
	
	public BookInfoDialog( CoolReader activity, Collection<String> items)
	{
		super(activity);
		mCoolReader = activity;
		setTitle(mCoolReader.getString(R.string.dlg_book_info));
		fillMap();
		mInflater = LayoutInflater.from(getContext());
		View view = mInflater.inflate(R.layout.book_info_dialog, null);
		TableLayout table = (TableLayout)view.findViewById(R.id.table);
		for ( String item : items ) {
			addItem(table, item);
		}
		setView( view );
	}

}
",False,26,49,0,0,3,23,1,2,L0
36,org.coolreader.crengine.Engine.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.app.AlertDialog;
import android.content.Context;
import android.graphics.drawable.Drawable;
import android.os.Environment;
import android.util.Log;

/**
 * CoolReader Engine class.
 * 
 * Only one instance is allowed.
 */
public class Engine {

	public static final Logger log = L.create(""en"");
	
	private final CoolReader mActivity;
	private final BackgroundThread mBackgroundThread;
	private File[] mountedRootsList;
	private Map<String, String> mountedRootsMap;
	
	static final private String LIBRARY_NAME = ""cr3engine-45-15"";

	// private final View mMainView;
	// private final ExecutorService mExecutor =
	// Executors.newFixedThreadPool(1);

	/**
	 * Get storage root directories.
	 * 
	 * @return array of r/w storage roots
	 */
	public File[] getStorageDirectories(boolean writableOnly) {
		Collection<File> res = new HashSet<File>(2);
		for (File dir : mountedRootsList) {
			if (dir.isDirectory() && (!writableOnly || dir.canWrite()))
				res.add(dir);
		}
		return res.toArray(new File[res.size()]);
	}
	
	public Map<String, String> getMountedRootsMap() {
		return mountedRootsMap;
	}

	/**
	 * Get or create writable subdirectory for specified base directory
	 * 
	 * @param dir
	 *            is base directory
	 * @param subdir
	 *            is subdirectory name, null to use base directory
	 * @param createIfNotExists
	 *            is true to force directory creation
	 * @return writable directory, null if not exist or not writable
	 */
	public static File getSubdir(File dir, String subdir,
			boolean createIfNotExists, boolean writableOnly) {
		if (dir == null)
			return null;
		File dataDir = dir;
		if (subdir != null) {
			dataDir = new File(dataDir, subdir);
			if (!dataDir.isDirectory() && createIfNotExists)
				dataDir.mkdir();
		}
		if (dataDir.isDirectory() && (!writableOnly || dataDir.canWrite()))
			return dataDir;
		return null;
	}

	/**
	 * Returns array of writable data directories on external storage
	 * 
	 * @param subdir
	 * @param createIfNotExists
	 * @return
	 */
	public File[] getDataDirectories(String subdir,
			boolean createIfNotExists, boolean writableOnly) {
		File[] roots = getStorageDirectories(writableOnly);
		ArrayList<File> res = new ArrayList<File>(roots.length);
		for (File dir : roots) {
			File dataDir = getSubdir(dir, "".cr3"", createIfNotExists,
					writableOnly);
			if (subdir != null)
				dataDir = getSubdir(dataDir, subdir, createIfNotExists,
						writableOnly);
			if (dataDir != null)
				res.add(dataDir);
		}
		return res.toArray(new File[] {});
	}

	public interface EngineTask {
		public void work() throws Exception;

		public void done();

		public void fail(Exception e);
	}

	// public static class FatalError extends RuntimeException {
	// private Engine engine;
	// private String msg;
	// public FatalError( Engine engine, String msg )
	// {
	// this.engine = engine;
	// this.msg = msg;
	// }
	// public void handle()
	// {
	// engine.fatalError(msg);
	// }
	// }

	public final static boolean LOG_ENGINE_TASKS = false;

	private class TaskHandler implements Runnable {
		final EngineTask task;

		public TaskHandler(EngineTask task) {
			this.task = task;
		}

		public String toString() {
			return ""[handler for "" + this.task.toString() + ""]"";
		}

		public void run() {
			try {
				if (LOG_ENGINE_TASKS)
					log.i(""running task.work() ""
							+ task.getClass().getName());
				if (!initialized)
					throw new IllegalStateException(""Engine not initialized"");
				// run task
				task.work();
				if (LOG_ENGINE_TASKS)
					log.i(""exited task.work() ""
							+ task.getClass().getName());
				// post success callback
				mBackgroundThread.postGUI(new Runnable() {
					public void run() {
						if (LOG_ENGINE_TASKS)
							log.i(""running task.done() ""
									+ task.getClass().getName()
									+ "" in gui thread"");
						task.done();
					}
				});
				// } catch ( final FatalError e ) {
				// TODO:
				// Handler h = view.getHandler();
				//
				// if ( h==null ) {
				// View root = view.getRootView();
				// h = root.getHandler();
				// }
				// if ( h==null ) {
				// //
				// e.handle();
				// } else {
				// h.postAtFrontOfQueue(new Runnable() {
				// public void run() {
				// e.handle();
				// }
				// });
				// }
			} catch (final Exception e) {
				log.e(""exception while running task ""
						+ task.getClass().getName(), e);
				// post error callback
				mBackgroundThread.postGUI(new Runnable() {
					public void run() {
						log.e(""running task.fail("" + e.getMessage()
								+ "") "" + task.getClass().getSimpleName()
								+ "" in gui thread "");
						task.fail(e);
					}
				});
			}
		}
	}

	/**
	 * Execute task in Engine thread
	 * 
	 * @param task
	 *            is task to execute
	 */
	public void execute(final EngineTask task) {
		if (LOG_ENGINE_TASKS)
			log.d(""executing task "" + task.getClass().getSimpleName());
		TaskHandler taskHandler = new TaskHandler(task);
		mBackgroundThread.executeBackground(taskHandler);
	}

	/**
	 * Schedule task for execution in Engine thread
	 * 
	 * @param task
	 *            is task to execute
	 */
	public void post(final EngineTask task) {
		if (LOG_ENGINE_TASKS)
			log.d(""executing task "" + task.getClass().getSimpleName());
		TaskHandler taskHandler = new TaskHandler(task);
		mBackgroundThread.postBackground(taskHandler);
	}

	/**
	 * Schedule Runnable for execution in GUI thread after all current Engine
	 * queue tasks done.
	 * 
	 * @param task
	 */
	public void runInGUI(final Runnable task) {
		execute(new EngineTask() {

			public void done() {
				mBackgroundThread.postGUI(task);
			}

			public void fail(Exception e) {
				// do nothing
			}

			public void work() throws Exception {
				// do nothing
			}
		});
	}

	public void fatalError(String msg) {
		AlertDialog dlg = new AlertDialog.Builder(mActivity).setMessage(msg)
				.setTitle(""CoolReader fatal error"").show();
		try {
			Thread.sleep(10);
		} catch (InterruptedException e) {
			// do nothing
		}
		dlg.dismiss();
		mActivity.finish();
	}

	private ProgressDialog mProgress;
	private boolean enable_progress = true;
	private boolean progressShown = false;
	private static int PROGRESS_STYLE = ProgressDialog.STYLE_HORIZONTAL;
	private Drawable progressIcon = null;

	// public void setProgressDrawable( final BitmapDrawable drawable )
	// {
	// if ( enable_progress ) {
	// mBackgroundThread.executeGUI( new Runnable() {
	// public void run() {
	// // show progress
	// log.v(""showProgress() - in GUI thread"");
	// if ( mProgress!=null && progressShown ) {
	// hideProgress();
	// progressIcon = drawable;
	// showProgress(mProgressPos, mProgressMessage);
	// //mProgress.setIcon(drawable);
	// }
	// }
	// });
	// }
	// }
	public void showProgress(final int mainProgress, final int resourceId) {
		showProgress(mainProgress,
				mActivity.getResources().getString(resourceId));
	}

	private String mProgressMessage = null;
	private int mProgressPos = 0;

	private volatile int nextProgressId = 0;

	public class DelayedProgress {
		private volatile boolean cancelled;
		private volatile boolean shown;

		/**
		 * Cancel scheduled progress.
		 */
		public void cancel() {
			cancelled = true;
		}
		/**
		 * Cancel and hide scheduled progress.
		 */
		public void hide() {
			this.cancelled = true;
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					if ( shown )
						hideProgress();
					shown = false;
				}
				
			});
		}

		DelayedProgress( final int percent, final String msg, final int delayMillis ) {
			this.cancelled = false;
			BackgroundThread.instance().postGUI(new Runnable() {
				@Override
				public void run() {
					if ( !cancelled ) {
						showProgress( percent, msg );
						shown = true;
					}
				}
				
			}, delayMillis);
		}
	}
	
	/**
	 * Display progress dialog after delay.
	 * (thread-safe)
	 * @param mainProgress is percent*100
	 * @param msg is progress message text
	 * @param delayMillis is delay before display of progress
	 * @return DelayedProgress object which can be use to hide or cancel this schedule
	 */
	public DelayedProgress showProgressDelayed(final int mainProgress, final String msg, final int delayMillis ) {
		return new DelayedProgress(mainProgress, msg, delayMillis);
	}
	
	/**
	 * Show progress dialog.
	 * (thread-safe)
	 * @param mainProgress is percent*100
	 * @param msg is progress message
	 */
	public void showProgress(final int mainProgress, final String msg) {
		final int progressId = ++nextProgressId;
		mProgressMessage = msg;
		mProgressPos = mainProgress;
		if (mainProgress == 10000) {
			//log.v(""mainProgress==10000 : calling hideProgress"");
			hideProgress();
			return;
		}
		log.v(""showProgress("" + mainProgress + "", \"""" + msg
				+ ""\"") is called : "" + Thread.currentThread().getName());
		if (enable_progress) {
			mBackgroundThread.executeGUI(new Runnable() {
				public void run() {
					// show progress
					//log.v(""showProgress() - in GUI thread"");
					if (progressId != nextProgressId) {
						//Log.v(""cr3"",
						//		""showProgress() - skipping duplicate progress event"");
						return;
					}
					if (mProgress == null) {
						try {
							if (mActivity != null && mActivity.isStarted()) {
								mProgress = new ProgressDialog(mActivity);
								mProgress
										.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
								if (progressIcon != null)
									mProgress.setIcon(progressIcon);
								else
									mProgress.setIcon(R.drawable.cr3_logo);
								mProgress.setMax(10000);
								mProgress.setCancelable(false);
								mProgress.setProgress(mainProgress);
								mProgress
										.setTitle(mActivity
												.getResources()
												.getString(
														R.string.progress_please_wait));
								mProgress.setMessage(msg);
								mProgress.show();
								progressShown = true;
							}
						} catch (Exception e) {
							Log.e(""cr3"",
									""Exception while trying to show progress dialog"",
									e);
							progressShown = false;
							mProgress = null;
						}
					} else {
						mProgress.setProgress(mainProgress);
						mProgress.setMessage(msg);
						if (!mProgress.isShowing()) {
							mProgress.show();
							progressShown = true;
						}
					}
				}
			});
		}
	}

	/**
	 * Hide progress dialog (if shown).
	 * (thread-safe)
	 */
	public void hideProgress() {
		final int progressId = ++nextProgressId;
		log.v(""hideProgress() - is called : ""
				+ Thread.currentThread().getName());
		// log.v(""hideProgress() is called"");
		mBackgroundThread.executeGUI(new Runnable() {
			public void run() {
				// hide progress
//				log.v(""hideProgress() - in GUI thread"");
				if (progressId != nextProgressId) {
//					Log.v(""cr3"",
//							""hideProgress() - skipping duplicate progress event"");
					return;
				}
				if (mProgress != null) {
					// if ( mProgress.isShowing() )
					// mProgress.hide();
					progressShown = false;
					progressIcon = null;
					if (mProgress.isShowing())
						mProgress.dismiss();
					mProgress = null;
//					log.v(""hideProgress() - in GUI thread, finished"");
				}
			}
		});
	}

	public boolean isProgressShown() {
		return progressShown;
	}

	public String loadFileUtf8(File file) {
		try {
			InputStream is = new FileInputStream(file);
			return loadResourceUtf8(is);
		} catch (Exception e) {
			log.e(""cannot load resource from file "" + file);
			return null;
		}
	}

	public String loadResourceUtf8(int id) {
		try {
			InputStream is = this.mActivity.getResources().openRawResource(id);
			return loadResourceUtf8(is);
		} catch (Exception e) {
			log.e(""cannot load resource "" + id);
			return null;
		}
	}

	public String loadResourceUtf8(InputStream is) {
		try {
			int available = is.available();
			if (available <= 0)
				return null;
			byte buf[] = new byte[available];
			if (is.read(buf) != available)
				throw new IOException(""Resource not read fully"");
			is.close();
			String utf8 = new String(buf, 0, available, ""UTF8"");
			return utf8;
		} catch (Exception e) {
			log.e(""cannot load resource"");
			return null;
		}
	}

	public byte[] loadResourceBytes(int id) {
		try {
			InputStream is = this.mActivity.getResources().openRawResource(id);
			return loadResourceBytes(is);
		} catch (Exception e) {
			log.e(""cannot load resource"");
			return null;
		}
	}

	public static byte[] loadResourceBytes(File f) {
		if (f == null || !f.isFile() || !f.exists())
			return null;
		FileInputStream is = null;
		try {
			is = new FileInputStream(f);
			byte[] res = loadResourceBytes(is);
			return res;
		} catch (IOException e) {
			log.e(""Cannot open file "" + f);
		}
		return null;
	}

	public static byte[] loadResourceBytes(InputStream is) {
		try {
			int available = is.available();
			if (available <= 0)
				return null;
			byte buf[] = new byte[available];
			if (is.read(buf) != available)
				throw new IOException(""Resource not read fully"");
			is.close();
			return buf;
		} catch (Exception e) {
			log.e(""cannot load resource"");
			return null;
		}
	}

	/**
	 * Initialize CoolReader Engine
	 * 
	 * @param fontList
	 *            is array of .ttf font pathnames to load
	 */
	public Engine(CoolReader activity, BackgroundThread backgroundThread) {
		this.mActivity = activity;
		this.mBackgroundThread = backgroundThread;
		installLibrary();
		initMountRoots();
		// this.mMainView = mainView;
		//
//		log.i(""Engine() : initializing Engine in UI thread"");
//		if (!initialized) {
//			installLibrary();
//		}
		initializeStarted = true;
		log.i(""Engine() : scheduling init task"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			public void run() {
				try {
					log.i(""Engine() : running init() in engine thread"");
					init();
					// android.view.ViewRoot.getRunQueue().post(new Runnable() {
					// public void run() {
					//
					// }
					// });
				} catch (final Exception e) {
					log.e(""Exception while initializing Engine"", e);
					// handler.post(new Runnable() {
					// public void run() {
					// // TODO: fatal error
					// }
					// });
				}
			}
		});
	}

	private native boolean initInternal(String[] fontList);

	private native void uninitInternal();

	private native String[] getFontFaceListInternal();

	private native String[] getArchiveItemsInternal(String arcName); // pairs:
																		// pathname,
																		// size

	private native boolean setCacheDirectoryInternal(String dir, int size);

	private native boolean scanBookPropertiesInternal(FileInfo info);

    private static native void suspendLongOperationInternal(); // cancel current long operation in engine thread (swapping to cache file) -- call it from GUI thread
    
    public static void suspendLongOperation() {
    	if (isInitialized()) {
    		suspendLongOperationInternal();
    	}
    }
	
	/**
	 * Checks whether specified directlry or file is symbolic link.
	 * (thread-safe)
	 * @param pathName is path to check
	 * @return true if specified directory or file is link (symlink)
	 */
	public native boolean isLink(String pathName);
	
	private static final int HYPH_NONE = 0;
	private static final int HYPH_ALGO = 1;
	private static final int HYPH_DICT = 2;

	private native boolean setHyphenationMethod(int type, byte[] dictData);

	public ArrayList<ZipEntry> getArchiveItems(String zipFileName) {
		final int itemsPerEntry = 2;
		String[] in = getArchiveItemsInternal(zipFileName);
		ArrayList<ZipEntry> list = new ArrayList<ZipEntry>();
		for (int i = 0; i <= in.length - itemsPerEntry; i += itemsPerEntry) {
			ZipEntry e = new ZipEntry(in[i]);
			e.setSize(Integer.valueOf(in[i + 1]));
			e.setCompressedSize(Integer.valueOf(in[i + 1]));
			list.add(e);
		}
		return list;
	}

	public static class HyphDict {
		private static HyphDict[] values = new HyphDict[] {};
		public final static HyphDict NONE = new HyphDict(""NONE"", HYPH_NONE, 0, ""[None]"");
		public final static HyphDict ALGORITHM = new HyphDict(""ALGORITHM"", HYPH_ALGO, 0, ""[Algorythmic]""); 
		public final static HyphDict RUSSIAN = new HyphDict(""RUSSIAN"", HYPH_DICT, R.raw.russian_enus_hyphen, ""Russian""); 
		public final static HyphDict ENGLISH = new HyphDict(""ENGLISH"", HYPH_DICT, R.raw.english_us_hyphen, ""English US""); 
		public final static HyphDict GERMAN = new HyphDict(""GERMAN"", HYPH_DICT, R.raw.german_hyphen, ""German""); 
		public final static HyphDict UKRAINIAN = new HyphDict(""UKRAINIAN"", HYPH_DICT,R.raw.ukrain_hyphen, ""Ukrainian""); 
		public final static HyphDict SPANISH = new HyphDict(""SPANISH"", HYPH_DICT,R.raw.spanish_hyphen, ""Spanish""); 
		public final static HyphDict FRENCH = new HyphDict(""FRENCH"", HYPH_DICT,R.raw.french_hyphen, ""French""); 
		public final static HyphDict BULGARIAN = new HyphDict(""BULGARIAN"", HYPH_DICT, R.raw.bulgarian_hyphen, ""Bulgarian""); 
		public final static HyphDict SWEDISH = new HyphDict(""SWEDISH"", HYPH_DICT, R.raw.swedish_hyphen, ""Swedish""); 
		public final static HyphDict POLISH = new HyphDict(""POLISH"", HYPH_DICT, R.raw.polish_hyphen, ""Polish"");
		public final static HyphDict HUNGARIAN = new HyphDict(""HUNGARIAN"", HYPH_DICT, R.raw.hungarian_hyphen, ""Hungarian"");
		
		public final String code;
		public final int type;
		public final int resource;
		public final String name;
		public final File file;

		
		public static HyphDict[] values() {
			return values;
		}

		private static void add(HyphDict dict) {
			// Arrays.copyOf(values, values.length+1); -- absent until API level 9
			HyphDict[] list = new HyphDict[values.length+1];
			for (int i=0; i<values.length; i++)
				list[i] = values[i];
			list[list.length-1] = dict;
			values = list;
		}
		
		private HyphDict(String code, int type, int resource, String name) {
			this.type = type;
			this.resource = resource;
			this.name = name;
			this.file = null;
			this.code = code;
			// register in list
			add(this);
		}

		private HyphDict(File file) {
			this.type = HYPH_DICT;
			this.resource = 0;
			this.name = file.getName();
			this.file = file;
			this.code = this.name;
			// register in list
			add(this);
		}

		public static HyphDict byCode(String code) {
			for (HyphDict dict : values)
				if (dict.toString().equals(code))
					return dict;
			return NONE;
		}

		public static HyphDict byFileName(String fileName) {
			for (HyphDict dict : values)
				if (dict.file!=null && dict.file.getName().equals(fileName))
					return dict;
			return NONE;
		}

		@Override
		public String toString() {
			return code;
		}
		
		public static boolean fromFile(File file) {
			if (file==null || !file.exists() || !file.isFile() || !file.canRead())
				return false;
			String fn = file.getName();
			if (!fn.toLowerCase().endsWith("".pdb"") && !fn.toLowerCase().endsWith("".pattern""))
				return false; // wrong file name
			if (byFileName(file.getName())!=NONE)
				return false; // already registered
			new HyphDict(file);
			return true;
		}
	};

	private HyphDict currentHyphDict = null;

	public boolean setHyphenationDictionary(final HyphDict dict) {
		log.i(""setHyphenationDictionary( "" + dict + "" ) is called"");
		if (currentHyphDict == dict)
			return false;
		currentHyphDict = dict;
		// byte[] image = loadResourceBytes(R.drawable.tx_old_book);
		mBackgroundThread.postBackground(new Runnable() {
			public void run() {
				if (!initialized)
					throw new IllegalStateException(""CREngine is not initialized"");
				byte[] data = null;
				if (dict.type == HYPH_DICT) {
					if (dict.resource!=0) {
						data = loadResourceBytes(dict.resource);
					} else if (dict.file!=null) {
						data = loadResourceBytes(dict.file);
					}
				}
				log.i(""Setting engine's hyphenation dictionary to ""
						+ dict);
				setHyphenationMethod(dict.type, data);
			}
		});
		return true;
	}

	public boolean scanBookProperties(FileInfo info) {
		if (!initialized)
			throw new IllegalStateException(""CREngine is not initialized"");
		return scanBookPropertiesInternal(info);
	}

	public String[] getFontFaceList() {
		if (!initialized)
			throw new IllegalStateException(""CREngine is not initialized"");
		return getFontFaceListInternal();
	}

	final static int CACHE_DIR_SIZE = 32000000;

	private String createCacheDir(File baseDir, String subDir) {
		String cacheDirName = null;
		if (baseDir.isDirectory()) {
			if (baseDir.canWrite()) {
				if (subDir != null) {
					baseDir = new File(baseDir, subDir);
					baseDir.mkdir();
				}
				if (baseDir.exists() && baseDir.canWrite()) {
					File cacheDir = new File(baseDir, ""cache"");
					if (cacheDir.exists() || cacheDir.mkdirs()) {
						if (cacheDir.canWrite()) {
							cacheDirName = cacheDir.getAbsolutePath();
							CR3_SETTINGS_DIR_NAME = baseDir.getAbsolutePath(); 
						}
					}
				}
			} else {
				log.i(baseDir.toString() + "" is read only"");
			}
		} else {
			log.i(baseDir.toString() + "" is not found"");
		}
		return cacheDirName;
	}
	
	public static String getExternalSettingsDirName() {
		return CR3_SETTINGS_DIR_NAME;
	}
	
	public static File getExternalSettingsDir() {
		return CR3_SETTINGS_DIR_NAME!=null ? new File(CR3_SETTINGS_DIR_NAME) : null;
	}
	
	public static boolean moveFile( File oldPlace, File newPlace ) {
		boolean removeNewFile = true;
		log.i(""Moving file "" + oldPlace.getAbsolutePath() + "" to "" + newPlace.getAbsolutePath());
		if ( !oldPlace.exists() ) {
			log.e(""File "" + oldPlace.getAbsolutePath() + "" does not exist!"");
			return false;
		}
		FileOutputStream os = null;
		FileInputStream is = null;
		try {
			if ( !newPlace.createNewFile() )
				return false; // cannot create file
			os = new FileOutputStream(newPlace);
			is = new FileInputStream(oldPlace);
			byte[] buf = new byte[0x10000];
			for (;;) {
				int bytesRead = is.read(buf);
				if ( bytesRead<=0 )
					break;
				os.write(buf, 0, bytesRead);
			}
			removeNewFile = false;
			oldPlace.delete();
			return true;
		} catch ( IOException e ) {
			return false;
		} finally {
			try {
				if (os != null)
					os.close();
			} catch (IOException ee) {
				// ignore
			}
			try {
				if (is != null)
					is.close();
			} catch (IOException ee) {
				// ignore
			}
			if ( removeNewFile )
				newPlace.delete();
		}
	}
	
	/**
	 * Checks whether file under old path exists, and moves it to better place when necessary.
	 * Can be slow if big file is being moved. 
	 * @param bestPlace is desired directory for file (e.g. new place after migration)
	 * @param oldPlace is old (obsolete) directory for file (e.g. location from older releases)
	 * @param filename is name of file
	 * @return file to use (from old or new place)
	 */
	public static File checkOrMoveFile( File bestPlace, File oldPlace, String filename ) {
		if ( !bestPlace.exists() ) {
			bestPlace.mkdirs();
		}
		File oldFile = new File(oldPlace, filename);
		if ( bestPlace.isDirectory() && bestPlace.canWrite() ) {
			File bestFile = new File(bestPlace, filename);
			if (bestFile.exists())
				return bestFile; // already exists
			if (oldFile.exists() && oldFile.isFile()) {
				// move file
				if (moveFile(oldFile, bestFile))
					return bestFile;
				return oldFile;
			}
			return bestFile;
		}
		return oldFile;
	}

	private static String CR3_SETTINGS_DIR_NAME;
	
	public final static String CACHE_BASE_DIR_NAME = "".cr3""; // ""Books""
	private void initCacheDirectory() {
		String cacheDirName = null;
		// SD card
		cacheDirName = createCacheDir(
				Environment.getExternalStorageDirectory(), CACHE_BASE_DIR_NAME);
		// non-standard SD mount points
		if (cacheDirName == null) {
			for ( String dirname : Scanner.SD_MOUNT_POINTS ) {
				cacheDirName = createCacheDir(new File(dirname),
						CACHE_BASE_DIR_NAME);
				if ( cacheDirName!=null )
					break;
			}
		}
		// internal flash
		if (cacheDirName == null) {
			File cacheDir = mActivity.getCacheDir();
			if (!cacheDir.isDirectory())
				cacheDir.mkdir();
			cacheDirName = createCacheDir(cacheDir, null);
			// File cacheDir = mActivity.getDir(""cache"", Context.MODE_PRIVATE);
//			if (cacheDir.isDirectory() && cacheDir.canWrite())
//				cacheDirName = cacheDir.getAbsolutePath();
		}
		// set cache directory for engine
		if (cacheDirName != null) {
			log.i(cacheDirName
					+ "" will be used for cache, maxCacheSize="" + CACHE_DIR_SIZE);
			setCacheDirectoryInternal(cacheDirName, CACHE_DIR_SIZE);
		}
	}

	private boolean addMountRoot(Map<String, String> list, String pathname, int resourceId)
	{
		return addMountRoot(list, pathname, mActivity.getResources().getString(resourceId));
	}
	
	private boolean addMountRoot(Map<String, String> list, String path, String name) {
		if (list.containsKey(path))
			return false;
		try {
			File dir = new File(path);
			if (dir.exists() && dir.isDirectory()) {
				String[] d = dir.list();
				if (d!=null && d.length>0) {
					log.i(""Adding FS root: "" + path + "" "" + name);
					list.put(path, name);
					return true;
				}
			}
		} catch (Exception e) {
			// ignore
		}
		return false;
	}
	
	private static final String[] SYSTEM_ROOT_PATHS = {""/system"", ""/data"", ""/mnt""};
	private void autoAddRoots(Map<String, String> list, String rootPath, String[] pathsToExclude)
	{
		try {
			File root = new File(rootPath);
			File[] files = root.listFiles();
			if ( files!=null ) {
				for ( File f : files ) {
					if ( !f.isDirectory() )
						continue;
					String fullPath = f.getAbsolutePath();
					if ( isLink(fullPath) ) {
						L.d(""skipping symlink "" + fullPath);
						continue;
					}
					boolean skip = false;
					for ( String path : pathsToExclude ) {
						if ( fullPath.startsWith(path) ) {
							skip = true;
							break;
						}
					}
					if ( skip )
						continue;
					if ( !f.canWrite() ) {
						L.i(""Path is readonly: "" + f.getAbsolutePath());
						continue;
					}
					L.i(""Found possible mount point "" + f.getAbsolutePath());
					addMountRoot(list, f.getAbsolutePath(), f.getAbsolutePath());
				}
			}
		} catch ( Exception e ) {
			L.w(""Exception while trying to auto add roots"");
		}
	}
	
	private void initMountRoots() {
		Map<String, String> map = new LinkedHashMap<String, String>();
		String sdpath = Environment.getExternalStorageDirectory().getAbsolutePath();
		if ( ""/nand"".equals(sdpath) && new File(""/sdcard"").isDirectory() )
			sdpath = ""/sdcard"";
		addMountRoot(map, sdpath, R.string.dir_sd_card);
		// internal SD card on Nook
		addMountRoot(map, ""/system/media/sdcard"", R.string.dir_internal_sd_card);
		// internal memory
		addMountRoot(map, ""/media"", R.string.dir_internal_memory);
		addMountRoot(map, ""/nand"", R.string.dir_internal_memory);
		// internal SD card on PocketBook 701 IQ
		addMountRoot(map, ""/PocketBook701"", R.string.dir_internal_sd_card);
		// external SD
		addMountRoot(map, ""/mnt/extsd"", ""External SD /mnt/extsd"");
		// external SD
		addMountRoot(map, ""/mnt/external1"", ""External SD /mnt/external1"");
		// external SD / Galaxy S
		addMountRoot(map, ""/mnt/ext.sd"", ""External SD /mnt/ext.sd"");
		addMountRoot(map, ""/ext.sd"", ""External SD /ext.sd"");
		// Asus EEE PAD Transformer
		addMountRoot(map, ""/Removable/MicroSD"", ""MicroSD"");
		// external SD card Huawei S7
		addMountRoot(map, ""/sdcard2"", R.string.dir_sd_card_2);
		
		// auto detection
		autoAddRoots(map, ""/"", SYSTEM_ROOT_PATHS);
		autoAddRoots(map, ""/mnt"", new String[] {});
		
		mountedRootsMap = map;
		Collection<File> list = new ArrayList<File>();
		for (String f : map.keySet()) {
			list.add(new File(f));
		}
		mountedRootsList = list.toArray(new File[] {});
	}
	
	private void init() throws IOException {
		if (initialized)
			throw new IllegalStateException(""Already initialized"");
		String[] fonts = findFonts();
		findExternalHyphDictionaries();
		if (!initInternal(fonts))
			throw new IOException(""Cannot initialize CREngine JNI"");
		// Initialization of cache directory
		initCacheDirectory();
		initialized = true;
	}

	// public void waitTasksCompletion()
	// {
	// log.i(""waiting for engine tasks completion"");
	// try {
	// mExecutor.awaitTermination(0, TimeUnit.SECONDS);
	// } catch (InterruptedException e) {
	// // ignore
	// }
	// }

	/**
	 * Uninitialize engine.
	 */
	public void uninit() {
		log.i(""Engine.uninit() is called"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			public void run() {
				log.i(""Engine.uninit() : in background thread"");
				if (initialized) {
					uninitInternal();
					initialized = false;
				}
			}
		});
	}

	protected void finalize() throws Throwable {
		log.i(""Engine.finalize() is called"");
		// if ( initialized ) {
		// //uninitInternal();
		// initialized = false;
		// }
	}

	public static boolean isInitialized() {
		return initialized;
	}
	
	static private boolean initialized = false;
	static private boolean initializeStarted = false;

	private String[] findFonts() {
		ArrayList<File> dirs = new ArrayList<File>();
		File[] dataDirs = getDataDirectories(""fonts"", false, false);
		for (File dir : dataDirs)
			dirs.add(dir);
		File[] rootDirs = getStorageDirectories(false);
		for (File dir : rootDirs)
			dirs.add(new File(dir, ""fonts""));
		dirs.add(new File(Environment.getRootDirectory(), ""fonts""));
		ArrayList<String> fontPaths = new ArrayList<String>();
		for (File fontDir : dirs) {
			if (fontDir.isDirectory()) {
				log.v(""Scanning directory "" + fontDir.getAbsolutePath()
						+ "" for font files"");
				// get font names
				String[] fileList = fontDir.list(new FilenameFilter() {
					public boolean accept(File dir, String filename) {
						String lc = filename.toLowerCase();
						return (lc.endsWith("".ttf"") || lc.endsWith("".otf"")
								|| lc.endsWith("".pfb"") || lc.endsWith("".pfa""))
//								&& !filename.endsWith(""Fallback.ttf"")
								;
					}
				});
				// append path
				for (int i = 0; i < fileList.length; i++) {
					String pathName = new File(fontDir, fileList[i])
							.getAbsolutePath();
					fontPaths.add(pathName);
					log.v(""found font: "" + pathName);
				}
			}
		}
		return fontPaths.toArray(new String[] {});
	}

	private String SO_NAME = ""lib"" + LIBRARY_NAME + "".so"";
	private boolean force_install_library = false;

	private void installLibrary() {
		try {
			if (force_install_library)
				throw new Exception(""forcing install"");
			// try loading library w/o manual installation
			log.i(""trying to load library "" + LIBRARY_NAME
					+ "" w/o installation"");
			System.loadLibrary(LIBRARY_NAME);
			// try invoke native method
			//log.i(""trying execute native method "");
			//setHyphenationMethod(HYPH_NONE, new byte[] {});
			log.i(LIBRARY_NAME + "" loaded successfully"");
		} catch (Exception ee) {
			log.i(SO_NAME + "" not found using standard paths, will install manually"");
			File sopath = mActivity.getDir(""libs"", Context.MODE_PRIVATE);
			File soname = new File(sopath, SO_NAME);
			try {
				sopath.mkdirs();
				File zip = new File(mActivity.getPackageCodePath());
				ZipFile zipfile = new ZipFile(zip);
				ZipEntry zipentry = zipfile.getEntry(""lib/armeabi/"" + SO_NAME);
				if (!soname.exists() || zipentry.getSize() != soname.length()) {
					InputStream is = zipfile.getInputStream(zipentry);
					OutputStream os = new FileOutputStream(soname);
					Log.i(""cr3"",
							""Installing JNI library ""
									+ soname.getAbsolutePath());
					final int BUF_SIZE = 0x10000;
					byte[] buf = new byte[BUF_SIZE];
					int n;
					while ((n = is.read(buf)) > 0)
						os.write(buf, 0, n);
					is.close();
					os.close();
				} else {
					log.i(""JNI library "" + soname.getAbsolutePath()
							+ "" is up to date"");
				}
				System.load(soname.getAbsolutePath());
				//setHyphenationMethod(HYPH_NONE, new byte[] {});
			} catch (Exception e) {
				log.e(""cannot install "" + LIBRARY_NAME + "" library"", e);
			}
		}
	}

	public static final BackgroundTextureInfo NO_TEXTURE = new BackgroundTextureInfo(
			BackgroundTextureInfo.NO_TEXTURE_ID, ""(SOLID COLOR)"", 0);
	private static final BackgroundTextureInfo[] internalTextures = {
			NO_TEXTURE,
			new BackgroundTextureInfo(""bg_paper1"", ""Paper 1"",
					R.drawable.bg_paper1),
			new BackgroundTextureInfo(""bg_paper1_dark"", ""Paper 1 (dark)"",
					R.drawable.bg_paper1_dark),
			new BackgroundTextureInfo(""tx_wood_dark"", ""Wood (dark)"",
					R.drawable.tx_wood_dark),
			new BackgroundTextureInfo(""tx_wood"", ""Wood"", R.drawable.tx_wood),
			new BackgroundTextureInfo(""tx_wood_dark"", ""Wood (dark)"",
					R.drawable.tx_wood_dark),
			new BackgroundTextureInfo(""tx_fabric"", ""Fabric"",
					R.drawable.tx_fabric),
			new BackgroundTextureInfo(""tx_fabric_dark"", ""Fabric (dark)"",
					R.drawable.tx_fabric_dark),
			new BackgroundTextureInfo(""tx_fabric_indigo_fibre"", ""Fabric fibre"",
					R.drawable.tx_fabric_indigo_fibre),
			new BackgroundTextureInfo(""tx_fabric_indigo_fibre_dark"",
					""Fabric fibre (dark)"",
					R.drawable.tx_fabric_indigo_fibre_dark),
			new BackgroundTextureInfo(""tx_gray_sand"", ""Gray sand"",
					R.drawable.tx_gray_sand),
			new BackgroundTextureInfo(""tx_gray_sand_dark"", ""Gray sand (dark)"",
					R.drawable.tx_gray_sand_dark),
			new BackgroundTextureInfo(""tx_green_wall"", ""Green wall"",
					R.drawable.tx_green_wall),
			new BackgroundTextureInfo(""tx_green_wall_dark"",
					""Green wall (dark)"", R.drawable.tx_green_wall_dark),
			new BackgroundTextureInfo(""tx_metal_red_light"", ""Metall red"",
					R.drawable.tx_metal_red_light),
			new BackgroundTextureInfo(""tx_metal_red_dark"", ""Metall red (dark)"",
					R.drawable.tx_metal_red_dark),
			new BackgroundTextureInfo(""tx_metall_copper"", ""Metall copper"",
					R.drawable.tx_metall_copper),
			new BackgroundTextureInfo(""tx_metall_copper_dark"",
					""Metall copper (dark)"", R.drawable.tx_metall_copper_dark),
			new BackgroundTextureInfo(""tx_metall_old_blue"", ""Metall blue"",
					R.drawable.tx_metall_old_blue),
			new BackgroundTextureInfo(""tx_metall_old_blue_dark"",
					""Metall blue (dark)"", R.drawable.tx_metall_old_blue_dark),
			new BackgroundTextureInfo(""tx_old_book"", ""Old book"",
					R.drawable.tx_old_book),
			new BackgroundTextureInfo(""tx_old_book_dark"", ""Old book (dark)"",
					R.drawable.tx_old_book_dark),
			new BackgroundTextureInfo(""tx_old_paper"", ""Old paper"",
					R.drawable.tx_old_paper),
			new BackgroundTextureInfo(""tx_old_paper_dark"", ""Old paper (dark)"",
					R.drawable.tx_old_paper_dark),
			new BackgroundTextureInfo(""tx_paper"", ""Paper"", R.drawable.tx_paper),
			new BackgroundTextureInfo(""tx_paper_dark"", ""Paper (dark)"",
					R.drawable.tx_paper_dark),
			new BackgroundTextureInfo(""tx_rust"", ""Rust"", R.drawable.tx_rust),
			new BackgroundTextureInfo(""tx_rust_dark"", ""Rust (dark)"",
					R.drawable.tx_rust_dark),
			new BackgroundTextureInfo(""tx_sand"", ""Sand"", R.drawable.tx_sand),
			new BackgroundTextureInfo(""tx_sand_dark"", ""Sand (dark)"",
					R.drawable.tx_sand_dark),
			new BackgroundTextureInfo(""tx_stones"", ""Stones"",
					R.drawable.tx_stones),
			new BackgroundTextureInfo(""tx_stones_dark"", ""Stones (dark)"",
					R.drawable.tx_stones_dark), };
	public static final String DEF_DAY_BACKGROUND_TEXTURE = ""bg_paper1"";
	public static final String DEF_NIGHT_BACKGROUND_TEXTURE = ""bg_paper1_dark"";

	public BackgroundTextureInfo[] getAvailableTextures() {
		ArrayList<BackgroundTextureInfo> list = new ArrayList<BackgroundTextureInfo>(
				internalTextures.length);
		list.add(NO_TEXTURE);
		findExternalTextures(list);
		for (int i = 1; i < internalTextures.length; i++)
			list.add(internalTextures[i]);
		return list.toArray(new BackgroundTextureInfo[] {});
	}

	public void findHyphDictionariesFromDirectory(File dir) {
		for (File f : dir.listFiles()) {
			if (!f.isDirectory()) {
				if (HyphDict.fromFile(f))
					log.i(""Registered external hyphenation dict "" + f.getAbsolutePath());
			}
		}
	}

	public void findExternalHyphDictionaries() {
		for (File d : getStorageDirectories(false)) {
			File base = new File(d, "".cr3"");
			if (!base.isDirectory())
				base = new File(d, ""cr3"");
			if (!base.isDirectory())
				continue;
			File subdir = new File(base, ""hyph"");
			if (subdir.isDirectory())
				findHyphDictionariesFromDirectory(subdir);
		}
	}

	public void findTexturesFromDirectory(File dir,
			Collection<BackgroundTextureInfo> listToAppend) {
		for (File f : dir.listFiles()) {
			if (!f.isDirectory()) {
				BackgroundTextureInfo item = BackgroundTextureInfo.fromFile(f
						.getAbsolutePath());
				if (item != null)
					listToAppend.add(item);
			}
		}
	}

	public void findExternalTextures(
			Collection<BackgroundTextureInfo> listToAppend) {
		for (File d : getStorageDirectories(false)) {
			File base = new File(d, "".cr3"");
			if (!base.isDirectory())
				base = new File(d, ""cr3"");
			if (!base.isDirectory())
				continue;
			File subdirTextures = new File(base, ""textures"");
			File subdirBackgrounds = new File(base, ""backgrounds"");
			if (subdirTextures.isDirectory())
				findTexturesFromDirectory(subdirTextures, listToAppend);
			if (subdirBackgrounds.isDirectory())
				findTexturesFromDirectory(subdirBackgrounds, listToAppend);
		}
	}

	public byte[] getImageData(BackgroundTextureInfo texture) {
		if (texture.isNone())
			return null;
		if (texture.resourceId != 0) {
			byte[] data = loadResourceBytes(texture.resourceId);
			return data;
		} else if (texture.id != null && texture.id.startsWith(""/"")) {
			File f = new File(texture.id);
			byte[] data = loadResourceBytes(f);
			return data;
		}
		return null;
	}

	public BackgroundTextureInfo getTextureInfoById(String id) {
		if (id == null)
			return NO_TEXTURE;
		if (id.startsWith(""/"")) {
			BackgroundTextureInfo item = BackgroundTextureInfo.fromFile(id);
			if (item != null)
				return item;
		} else {
			for (BackgroundTextureInfo item : internalTextures)
				if (item.id.equals(id))
					return item;
		}
		return NO_TEXTURE;
	}

}
",True,29,49,0,0,3,22,7,8,L0
37,org.coolreader.crengine.L.java,"package org.coolreader.crengine;

import android.util.Log;

public class L {
	public static String getThreadLabel() {
		return BackgroundThread.instance().isGUIThread() ? ""G|"" : ""B|"";
	}
	public static void i(String msg) {
		Log.i(""cr3"", getThreadLabel() + msg);
	}
	public static void i(String msg, Exception e) {
		Log.i(""cr3"", getThreadLabel() + msg, e);
	}
	public static void w(String msg) {
		Log.w(""cr3"", getThreadLabel() + msg);
	}
	public static void w(String msg, Exception e) {
		Log.w(""cr3"", getThreadLabel() + msg, e);
	}
	public static void e(String msg) {
		Log.e(""cr3"", getThreadLabel() + msg);
	}
	public static void e(String msg, Exception e) {
		Log.e(""cr3"", getThreadLabel() + msg, e);
	}
	public static void d(String msg) {
		Log.d(""cr3"", getThreadLabel() + msg);
	}
	public static void d(String msg, Exception e) {
		Log.d(""cr3"", getThreadLabel() + msg, e);
	}
	public static void v(String msg) {
		Log.v(""cr3"", getThreadLabel() + msg);
	}
	public static void v(String msg, Exception e) {
		Log.v(""cr3"", getThreadLabel() + msg, e);
	}
	public static Logger create(String name) {
		return new LoggerImpl(name, Log.VERBOSE);
	}
	public static Logger create(String name, int level) {
		return new LoggerImpl(name, level);
	}
}

class LoggerImpl implements Logger {
	private final String name;
	private int level;
	public LoggerImpl( String name, int level ) {
		this.name = name;
		this.level = level;
	}
	public void setLevel( int level ) {
		this.level = level;
	}
	private String addName( String msg ) {
		return name + ""| "" + msg;
	}
	@Override
	public void i(String msg) {
		if ( level>=Log.INFO )
			L.i(addName(msg));
	}
	@Override
	public void i(String msg, Exception e) {
		if ( level>=Log.INFO )
			L.i(addName(msg), e);
	}
	@Override
	public void w(String msg) {
		if ( level>=Log.WARN )
			L.w(addName(msg));
	}
	@Override
	public void w(String msg, Exception e) {
		if ( level>=Log.WARN )
			L.w(addName(msg), e);
	}
	@Override
	public void e(String msg) {
		if ( level>=Log.ERROR )
			L.e(addName(msg));
	}
	@Override
	public void e(String msg, Exception e) {
		if ( level>=Log.ERROR )
			L.e(addName(msg), e);
	}
	@Override
	public void d(String msg) {
		if ( level>=Log.DEBUG )
			L.d(addName(msg));
	}
	@Override
	public void d(String msg, Exception e) {
		if ( level>=Log.DEBUG )
			L.d(addName(msg), e);
	}
	@Override
	public void v(String msg) {
		if ( level>=Log.VERBOSE )
			L.v(addName(msg));
	}
	@Override
	public void v(String msg, Exception e) {
		if ( level>=Log.VERBOSE )
			L.v(addName(msg), e);
	}
}
",True,8,49,0,0,4,33,13,2,L0
38,org.coolreader.crengine.AboutDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.net.Uri;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.TabHost;
import android.widget.TabHost.TabContentFactory;
import android.widget.TextView;

public class AboutDialog extends BaseDialog implements TabContentFactory {
	final CoolReader mCoolReader;
	
	private View mAppTab;
	private View mLicenseTab;
	private View mDonationTab;
	
	private boolean isPackageInstalled( String packageName ) {
		try {
			mCoolReader.getPackageManager().getApplicationInfo(packageName, 0);
			return true;
		} catch ( Exception e ) {
			return false;
		}
	}

	private void installPackage( String packageName ) {
		Log.i(""cr3"", ""installPackageL "" + packageName);
		try {
			mCoolReader.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(""market://details?id="" + packageName)));
		} catch ( ActivityNotFoundException e ) {
			mCoolReader.showToast(""Cannot run Android Market application"");
		}
	}
	
	private void setupDonationButton( final Button btn, final String packageName ) {
		if ( isPackageInstalled(packageName)) {
			btn.setEnabled(false);
			btn.setText(R.string.dlg_about_donation_installed);
		} else {
			btn.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					installPackage(packageName);
				}
			});
		}
	}
	
	public AboutDialog( CoolReader activity)
	{
		super(activity);
		mCoolReader = activity;
		LayoutInflater inflater = LayoutInflater.from(getContext());
		TabHost tabs = (TabHost)inflater.inflate(R.layout.about_dialog, null);
		mAppTab = (View)inflater.inflate(R.layout.about_dialog_app, null);
		((TextView)mAppTab.findViewById(R.id.version)).setText(""Cool Reader "" + mCoolReader.getVersion());
		mLicenseTab = (View)inflater.inflate(R.layout.about_dialog_license, null);
		String license = mCoolReader.getEngine().loadResourceUtf8(R.raw.license);
		((TextView)mLicenseTab.findViewById(R.id.license)).setText(license);
		mDonationTab = (View)inflater.inflate(R.layout.about_dialog_donation, null);

		setupDonationButton( (Button)mDonationTab.findViewById(R.id.btn_about_donation_install_gold), ""org.coolreader.donation.gold"");
		setupDonationButton( (Button)mDonationTab.findViewById(R.id.btn_about_donation_install_silver), ""org.coolreader.donation.silver"");
		setupDonationButton( (Button)mDonationTab.findViewById(R.id.btn_about_donation_install_bronze), ""org.coolreader.donation.bronze"");
		
		tabs.setup();
		TabHost.TabSpec tsApp = tabs.newTabSpec(""App"");
		tsApp.setIndicator("""", 
				getContext().getResources().getDrawable(R.drawable.cr3_menu_link));
		tsApp.setContent(this);
		tabs.addTab(tsApp);

		TabHost.TabSpec tsLicense = tabs.newTabSpec(""License"");
		tsLicense.setIndicator("""", 
				getContext().getResources().getDrawable(R.drawable.ic_menu_star));
		tsLicense.setContent(this);
		tabs.addTab(tsLicense);
		
		TabHost.TabSpec tsDonation = tabs.newTabSpec(""Donation"");
		tsDonation.setIndicator("""", 
				getContext().getResources().getDrawable(R.drawable.ic_menu_emoticons));
		tsDonation.setContent(this);
		tabs.addTab(tsDonation);
		
		setView( tabs );
	}

	@Override
	public View createTabContent(String tag) {
		if ( ""App"".equals(tag) )
			return mAppTab;
		else if ( ""License"".equals(tag) )
			return mLicenseTab;
		else if ( ""Donation"".equals(tag) )
			return mDonationTab;
		return null;
	}
	
}
",True,12,49,0,0,3,24,1,2,L0
39,org.coolreader.crengine.FindNextDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.view.View.OnTouchListener;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;

public class FindNextDlg {
	PopupWindow mWindow;
	View mAnchor;
	//CoolReader mCoolReader;
	ReaderView mReaderView;
	View mPanel;
	final String pattern;
	final boolean caseInsensitive;
	static public void showDialog( CoolReader coolReader, ReaderView readerView, final String pattern, final boolean caseInsensitive )
	{
		FindNextDlg dlg = new FindNextDlg(coolReader, readerView, pattern, caseInsensitive);
		//dlg.mWindow.update(dlg.mAnchor, width, height)
		Log.d(""cr3"", ""popup: "" + dlg.mWindow.getWidth() + ""x"" + dlg.mWindow.getHeight());
		//dlg.update();
		//dlg.showAtLocation(readerView, Gravity.LEFT|Gravity.TOP, readerView.getLeft()+50, readerView.getTop()+50);
		//dlg.showAsDropDown(readerView);
		//dlg.update();
	}
	public FindNextDlg( CoolReader coolReader, ReaderView readerView, final String pattern, final boolean caseInsensitive )
	{
		this.pattern = pattern;
		this.caseInsensitive = caseInsensitive;
		//mCoolReader = coolReader;
		mReaderView = readerView;
		mAnchor = readerView;

		View panel = (LayoutInflater.from(coolReader.getApplicationContext()).inflate(R.layout.search_popup, null));
		panel.measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		
		//mReaderView.getS
		
		mWindow = new PopupWindow( mAnchor.getContext() );
		mWindow.setTouchInterceptor(new OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
					mReaderView.clearSelection();
					mWindow.dismiss();
					return true;
				}
				return false;
			}
		});
		//super(panel);
		mPanel = panel;
		mPanel.findViewById(R.id.search_btn_prev).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.findNext(pattern, true, caseInsensitive);
			}
		});
		mPanel.findViewById(R.id.search_btn_next).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.findNext(pattern, false, caseInsensitive);
			}
		});
		mPanel.findViewById(R.id.search_btn_close).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.setFocusable(true);
		mPanel.setOnKeyListener( new OnKeyListener() {

			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ( event.getAction()==KeyEvent.ACTION_UP ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_BACK:
						mReaderView.clearSelection();
						mWindow.dismiss();
						return true;
					case KeyEvent.KEYCODE_DPAD_LEFT:
					case KeyEvent.KEYCODE_DPAD_UP:
						mReaderView.findNext(pattern, true, caseInsensitive);
						return true;
					case KeyEvent.KEYCODE_DPAD_RIGHT:
					case KeyEvent.KEYCODE_DPAD_DOWN:
						mReaderView.findNext(pattern, false, caseInsensitive);
						return true;
					}
				} else if ( event.getAction()==KeyEvent.ACTION_DOWN ) {
						switch ( keyCode ) {
						case KeyEvent.KEYCODE_BACK:
						case KeyEvent.KEYCODE_DPAD_LEFT:
						case KeyEvent.KEYCODE_DPAD_UP:
						case KeyEvent.KEYCODE_DPAD_RIGHT:
						case KeyEvent.KEYCODE_DPAD_DOWN:
							return true;
						}
					}
				if ( keyCode == KeyEvent.KEYCODE_BACK) {
					return true;
				}
				return false;
			}
			
		});

		mWindow.setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss() {
				mReaderView.clearSelection();
			}
		});
		
		mWindow.setBackgroundDrawable(new BitmapDrawable());
		//mWindow.setAnimationStyle(android.R.style.Animation_Toast);
		mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
		mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
//		setWidth(panel.getWidth());
//		setHeight(panel.getHeight());
		
		mWindow.setFocusable(true);
		mWindow.setTouchable(true);
		mWindow.setOutsideTouchable(true);
		mWindow.setContentView(panel);
		
		
		int [] location = new int[2];
		mAnchor.getLocationOnScreen(location);
		//mWindow.update(location[0], location[1], mPanel.getWidth(), mPanel.getHeight() );
		//mWindow.setWidth(mPanel.getWidth());
		//mWindow.setHeight(mPanel.getHeight());

		mWindow.showAtLocation(mAnchor, Gravity.TOP | Gravity.CENTER_HORIZONTAL, location[0], location[1] + mAnchor.getHeight() - mPanel.getHeight());
//		if ( mWindow.isShowing() )
//			mWindow.update(mAnchor, 50, 50);
		//dlg.mWindow.showAsDropDown(dlg.mAnchor);
	
	}
	
}
",False,2,49,0,0,3,38,1,2,L0
40,org.coolreader.crengine.TOCItem.java,"package org.coolreader.crengine;

import java.util.ArrayList;

public class TOCItem {
	private TOCItem mParent;
	private int mLevel;
	private int mIndex;
	private int mGlobalIndex=-1;
	private int mPage;
	private int mPercent;
	private boolean mExpanded;
	private String mName;
	private String mPath;
	private ArrayList<TOCItem> mChildren;
	// create root item
	public TOCItem() {
	}
	// create child item
	public TOCItem addChild() {
		if ( mChildren==null )
			mChildren = new ArrayList<TOCItem>();
		TOCItem item = new TOCItem();
		item.mParent = this;
		item.mIndex = mChildren.size();
		mChildren.add(item);
		return item;
	}
	public int getChildCount(){
		return mChildren!=null ? mChildren.size() : 0;
	}
	public TOCItem getChild( int index)	{
		return mChildren.get(index);
	}
	public TOCItem getParent() {
		return mParent;
	}
	public int getLevel() {
		return mLevel;
	}
	public int getIndex() {
		return mIndex;
	}
	public int getGlobalIndex() {
		return mGlobalIndex;
	}
	public void setGlobalIndex( int index ) {
		mGlobalIndex = index;
	}
	public boolean getExpanded() {
		return mExpanded;
	}
	public void setExpanded( boolean expanded ) {
		mExpanded = expanded;
	}
	public int getPage() {
		return mPage;
	}
	public int getPercent() {
		return mPercent;
	}
	public String getName() {
		return mName;
	}
	public String getPath() {
		return mPath;
	}
	
}
",False,32,30,4,12,0,0,3,0,L0
41,org.coolreader.crengine.FileBrowser.java,"package org.coolreader.crengine;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Locale;
import java.util.TimeZone;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.OPDSUtil.DocInfo;
import org.coolreader.crengine.OPDSUtil.DownloadCallback;
import org.coolreader.crengine.OPDSUtil.EntryInfo;

import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.graphics.drawable.Drawable;
import android.view.ContextMenu;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnMenuItemClickListener;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Adapter;
import android.widget.AdapterView;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

public class FileBrowser extends LinearLayout {

	public static final Logger log = L.create(""fb"");
	
	Engine mEngine;
	Scanner mScanner;
	CoolReader mActivity;
	LayoutInflater mInflater;
	History mHistory;
	ListView mListView;

	public static final int MAX_SUBDIR_LEN = 32;
	
	private class FileBrowserListView extends ListView {

		public FileBrowserListView(Context context) {
			super(context);
	        setFocusable(true);
	        setFocusableInTouchMode(true);
	        setLongClickable(true);
	        //registerForContextMenu(this);
	        //final FileBrowser _this = this;
	        setOnItemLongClickListener(new OnItemLongClickListener() {

				@Override
				public boolean onItemLongClick(AdapterView<?> arg0, View arg1,
						int position, long id) {
					log.d(""onItemLongClick(""+position+"")"");
					//return super.performItemClick(view, position, id);
					if (position == 0 && currDirectory.parent != null) {
						showParentDirectory();
						return true;
					}
					FileInfo item = (FileInfo) getAdapter().getItem(position);
					if ( item==null )
						return false;
					if (item.isDirectory && !item.isOPDSDir()) {
						showDirectory(item, null);
						return true;
					}
					//openContextMenu(_this);
					//mActivity.loadDocument(item);
					selectedItem = item;
					showContextMenu();
					return true;
				}
			});
			setChoiceMode(CHOICE_MODE_SINGLE);
		}
		
		@Override
		public void createContextMenu(ContextMenu menu) {
			log.d(""createContextMenu()"");
			menu.clear();
		    MenuInflater inflater = mActivity.getMenuInflater();
		    if ( isRecentDir() ) {
			    inflater.inflate(R.menu.cr3_file_browser_recent_context_menu, menu);
			    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_recent_book));
		    } else if (selectedItem!=null && selectedItem.isOPDSDir()) {
			    inflater.inflate(R.menu.cr3_file_browser_opds_context_menu, menu);
			    menu.setHeaderTitle(mActivity.getString(R.string.menu_title_catalog));
		    } else if (selectedItem!=null && selectedItem.isDirectory) {
			    inflater.inflate(R.menu.cr3_file_browser_folder_context_menu, menu);
			    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_book));
		    } else {
			    inflater.inflate(R.menu.cr3_file_browser_context_menu, menu);
			    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_book));
		    }
		    for ( int i=0; i<menu.size(); i++ ) {
		    	menu.getItem(i).setOnMenuItemClickListener(new OnMenuItemClickListener() {
					public boolean onMenuItemClick(MenuItem item) {
						onContextItemSelected(item);
						return true;
					}
				});
		    }
		    return;
		}



		@Override
		public boolean performItemClick(View view, int position, long id) {
			log.d(""performItemClick(""+position+"")"");
			//return super.performItemClick(view, position, id);
			if (position == 0 && currDirectory.parent != null) {
				showParentDirectory();
				return true;
			}
			FileInfo item = (FileInfo) getAdapter().getItem(position);
			if ( item==null )
				return false;
			if ( item.isDirectory ) {
				showDirectory(item, null);
				return true;
			}
			if ( item.isOPDSDir() )
				showOPDSDir(item, null);
			else
				mActivity.loadDocument(item);
			return true;
		}

		@Override
		public boolean onKeyDown(int keyCode, KeyEvent event) {
			if ( keyCode==KeyEvent.KEYCODE_BACK && mActivity.isBookOpened() ) {
				if ( isRootDir() ) {
					if ( mActivity.isBookOpened() ) {
						mActivity.showReader();
						return true;
					} else
						return super.onKeyDown(keyCode, event);
				}
				showParentDirectory();
				return true;
			}
			if (keyCode==KeyEvent.KEYCODE_SEARCH) {
				showFindBookDialog();
				return true;
			}
			return super.onKeyDown(keyCode, event);
		}

		@Override
		public void setSelection(int position) {
			super.setSelection(position);
		}
		
	}
	
	public FileBrowser(CoolReader activity, Engine engine, Scanner scanner, History history) {
		super(activity);
		this.mActivity = activity;
		this.mEngine = engine;
		this.mScanner = scanner;
		this.mInflater = LayoutInflater.from(activity);// activity.getLayoutInflater();
		this.mHistory = history;
		setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
		createListView(true);
		showDirectory( null, null );
	}
	
	private void createListView(boolean recreateAdapter) {
		mListView = new FileBrowserListView(mActivity);
		final GestureDetector detector = new GestureDetector(new MyGestureListener());
		mListView.setOnTouchListener(new ListView.OnTouchListener() {
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				return detector.onTouchEvent(event);
			}
		});
		if (currentListAdapter == null || recreateAdapter) {
			currentListAdapter = new FileListAdapter();
			mListView.setAdapter(currentListAdapter);
		} else {
			currentListAdapter.notifyDataSetChanged();
		}
		mListView.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
		removeAllViews();
		addView(mListView);
		mListView.setVisibility(VISIBLE);
	}
	
	public void onThemeChanged() {
		createListView(true);
		currentListAdapter.notifyDataSetChanged();
	}
	
	FileInfo selectedItem = null;
	
	public boolean onContextItemSelected(MenuItem item) {
		
		if ( selectedItem==null || (selectedItem.isDirectory && !selectedItem.isOPDSDir()) )
			return false;
			
		switch (item.getItemId()) {
		case R.id.book_open:
			log.d(""book_open menu item selected"");
			if ( selectedItem.isOPDSDir() )
				showOPDSDir(selectedItem, null);
			else
				mActivity.loadDocument(selectedItem);
			return true;
		case R.id.book_sort_order:
			mActivity.showToast(""Sorry, sort order selection is not yet implemented"");
			return true;
		case R.id.book_recent_books:
			showRecentBooks();
			return true;
		case R.id.book_opds_root:
			showOPDSRootDirectory();
			return true;
		case R.id.book_root:
			showRootDirectory();
			return true;
		case R.id.book_back_to_reading:
			if ( mActivity.isBookOpened() )
				mActivity.showReader();
			else
				mActivity.showToast(""No book opened"");
			return true;
		case R.id.book_delete:
			log.d(""book_delete menu item selected"");
			mActivity.getReaderView().closeIfOpened(selectedItem);
			if ( selectedItem.deleteFile() ) {
				mHistory.removeBookInfo(selectedItem, true, true);
			}
			showDirectory(currDirectory, null);
			return true;
		case R.id.book_recent_goto:
			log.d(""book_recent_goto menu item selected"");
			showDirectory(selectedItem, selectedItem);
			return true;
		case R.id.book_recent_remove:
			log.d(""book_recent_remove menu item selected"");
			mActivity.getHistory().removeBookInfo(selectedItem, true, false);
			showRecentBooks();
			return true;
		case R.id.catalog_add:
			log.d(""catalog_add menu item selected"");
			editOPDSCatalog(null);
			return true;
		case R.id.catalog_delete:
			log.d(""catalog_delete menu item selected"");
			if (selectedItem!=null && selectedItem.isOPDSDir()) {
				mActivity.getDB().removeOPDSCatalog(selectedItem.id);
				refreshOPDSRootDirectory();
			}
			return true;
		case R.id.catalog_edit:
			log.d(""catalog_edit menu item selected"");
			editOPDSCatalog(selectedItem);
			return true;
		case R.id.catalog_open:
			log.d(""catalog_open menu item selected"");
			showOPDSDir(selectedItem, null);
			return true;
		}
		return false;
	}
	
	private void editOPDSCatalog(FileInfo opds) {
		if (opds==null) {
			opds = new FileInfo();
			opds.isDirectory = true;
			opds.pathname = FileInfo.OPDS_DIR_PREFIX + ""http://"";
			opds.filename = ""New Catalog"";
			opds.isListed = true;
			opds.isScanned = true;
			opds.parent = mScanner.getOPDSRoot();
		}
		OPDSCatalogEditDialog dlg = new OPDSCatalogEditDialog(mActivity, opds, new Runnable() {
			@Override
			public void run() {
				refreshOPDSRootDirectory();
			}
		});
		dlg.show();
	}
	
	private void refreshOPDSRootDirectory() {
		FileInfo opdsRoot = mScanner.getOPDSRoot();
		if ( opdsRoot!=null ) {
			mActivity.getDB().loadOPDSCatalogs(opdsRoot);
			showDirectory(opdsRoot, null);
		}
	}
	

	protected void showParentDirectory()
	{
		if (currDirectory != null && currDirectory.parent != null) {
			showDirectory(currDirectory.parent, currDirectory);
		}
	}
	
	boolean mInitStarted = false;
//	boolean mInitialized = false;
	public void init()
	{
		if ( mInitStarted )
			return;
		log.e(""FileBrowser.init() called"");
		mInitStarted = true;
		//mEngine.showProgress(1000, R.string.progress_scanning);
		execute( new Task() {
			public void work() {
				mHistory.loadFromDB(mScanner, 100);
			}
			public void done() {
				log.e(""Directory scan is finished. "" + mScanner.mFileList.size() + "" files found"" + "", root item count is "" + mScanner.mRoot.itemCount());
				//mInitialized = true;
				//mEngine.hideProgress();
				//mEngine.hideProgress();
				showDirectory( mScanner.mRoot, null );
				mListView.setSelection(0);
			}
			public void fail(Exception e )
			{
				//mEngine.showProgress(9000, ""Scan is failed"");
				//mEngine.hideProgress();
				mActivity.showToast(""Scan is failed"");
				log.e(""Exception while scanning directories"", e);
			}
		});
	}
	
	public static String formatAuthors( String authors ) {
		if ( authors==null || authors.length()==0 )
			return null;
		String[] list = authors.split(""\\|"");
		StringBuilder buf = new StringBuilder(authors.length());
		for ( String a : list ) {
			if ( buf.length()>0 )
				buf.append("", "");
			String[] items = a.split("" "");
			if ( items.length==3 && items[1]!=null && items[1].length()>=1 )
				buf.append(items[0] + "" "" + items[1].charAt(0) + "". "" + items[2]);
			else
				buf.append(a);
		}
		return buf.toString();
	}
	
	public static String formatSize( int size )
	{
		if ( size==0 )
			return """";
		if ( size<10000 )
			return String.valueOf(size);
		else if ( size<1000000 )
			return String.valueOf(size/1000) + ""K"";
		else if ( size<10000000 )
			return String.valueOf(size/1000000) + ""."" + String.valueOf(size%1000000/100000) + ""M"";
		else
			return String.valueOf(size/1000000) + ""M"";
	}

	public static String formatSeries( String name, int number )
	{
		if ( name==null || name.length()==0 )
			return null;
		if ( number>0 )
			return ""#"" + number + "" "" + name;
		else
			return name;
	}
	
	static private ThreadLocal<SimpleDateFormat> dateFormatThreadLocal = new ThreadLocal<SimpleDateFormat>(); 
	static private ThreadLocal<SimpleDateFormat> timeFormatThreadLocal = new ThreadLocal<SimpleDateFormat>();
	static private SimpleDateFormat dateFormat() {
		if (dateFormatThreadLocal.get() == null)
			dateFormatThreadLocal.set(new SimpleDateFormat(""dd.MM.yy"", Locale.getDefault()));
		return dateFormatThreadLocal.get();
	}
	
	static private SimpleDateFormat timeFormat() {
		if (timeFormatThreadLocal.get() == null)
			timeFormatThreadLocal.set(new SimpleDateFormat(""HH:mm"", Locale.getDefault()));
		return timeFormatThreadLocal.get();
	}
	
	public static String formatDate( long timeStamp )
	{
		if ( timeStamp<5000*60*60*24*1000 )
			return """";
		TimeZone tz = java.util.TimeZone.getDefault();
		Calendar now = Calendar.getInstance(tz);
		Calendar c = Calendar.getInstance(tz);
		c.setTimeInMillis(timeStamp);
		if ( c.get(Calendar.YEAR)<1980 )
			return """";
		if ( c.get(Calendar.YEAR)==now.get(Calendar.YEAR)
				&& c.get(Calendar.MONTH)==now.get(Calendar.MONTH)
				&& c.get(Calendar.DAY_OF_MONTH)==now.get(Calendar.DAY_OF_MONTH)) {
			timeFormat().setTimeZone(tz);
			return timeFormat().format(c.getTime());
		} else {
			dateFormat().setTimeZone(tz);
			return dateFormat().format(c.getTime());
		}
	}

	public static String formatPercent( int percent )
	{
		if ( percent<=0 )
			return null;
		return String.valueOf(percent/100) + ""."" + String.valueOf(percent/10%10) + ""%"";
	}

	private FileInfo currDirectory;

	public boolean isRootDir()
	{
		return currDirectory == mScanner.getRoot();
	}

	public boolean isRecentDir()
	{
		return currDirectory!=null && currDirectory.isRecentDir();
	}

	public void showRecentBooks()
	{
		showDirectory(null, null);
	}

	public boolean isBookShownInRecentList(FileInfo book) {
		if (currDirectory==null || !currDirectory.isRecentDir())
			return false;
		return currDirectory.findItemByPathName(book.getPathName())!=null;
	}
	
	public void showLastDirectory()
	{
		if ( currDirectory==null || currDirectory==mScanner.getRoot() )
			showRecentBooks();
		else
			showDirectory(currDirectory, null);
	}

	public void showSearchResult( FileInfo[] books ) {
		FileInfo dir = mScanner.setSearchResults( books );
		showDirectory(dir, null);
	}
	
	public void showFindBookDialog()
	{
		BookSearchDialog dlg = new BookSearchDialog( mActivity, new BookSearchDialog.SearchCallback() {
			@Override
			public void done(FileInfo[] results) {
				if ( results!=null ) {
					if ( results.length==0 ) {
						mActivity.showToast(R.string.dlg_book_search_not_found);
					} else {
						showSearchResult( results );
					}
				}
			}
		});
		dlg.show();
	}

	public void showRootDirectory()
	{
		log.v(""showRootDirectory()"");
		showDirectory(mScanner.getRoot(), null);
	}

	public void showOPDSRootDirectory()
	{
		log.v(""showOPDSRootDirectory()"");
		FileInfo opdsRoot = mScanner.getOPDSRoot();
		if ( opdsRoot!=null )
			showDirectory(opdsRoot, null);
	}

	private FileInfo.SortOrder mSortOrder = FileInfo.DEF_SORT_ORDER; 
	public void setSortOrder(FileInfo.SortOrder order) {
		if ( mSortOrder == order )
			return;
		mSortOrder = order!=null ? order : FileInfo.DEF_SORT_ORDER;
		if ( currDirectory!=null && currDirectory.allowSorting() ) {
			currDirectory.sort(mSortOrder);
			showDirectory(currDirectory, null);
			mActivity.saveSetting(ReaderView.PROP_APP_BOOK_SORT_ORDER, mSortOrder.name());
		}
	}
	public void setSortOrder(String orderName) {
		setSortOrder(FileInfo.SortOrder.fromName(orderName));
	}
	public void showSortOrderMenu() {
		final Properties properties = new Properties();
		properties.setProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER, mActivity.getSetting(ReaderView.PROP_APP_BOOK_SORT_ORDER));
		final String oldValue = properties.getProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER);
		int[] optionLabels = {
			FileInfo.SortOrder.FILENAME.resourceId,	
			FileInfo.SortOrder.FILENAME_DESC.resourceId,	
			FileInfo.SortOrder.AUTHOR_TITLE.resourceId,	
			FileInfo.SortOrder.AUTHOR_TITLE_DESC.resourceId,	
			FileInfo.SortOrder.TITLE_AUTHOR.resourceId,	
			FileInfo.SortOrder.TITLE_AUTHOR_DESC.resourceId,	
			FileInfo.SortOrder.TIMESTAMP.resourceId,	
			FileInfo.SortOrder.TIMESTAMP_DESC.resourceId,	
		};
		String[] optionValues = {
			FileInfo.SortOrder.FILENAME.name(),	
			FileInfo.SortOrder.FILENAME_DESC.name(),	
			FileInfo.SortOrder.AUTHOR_TITLE.name(),	
			FileInfo.SortOrder.AUTHOR_TITLE_DESC.name(),	
			FileInfo.SortOrder.TITLE_AUTHOR.name(),	
			FileInfo.SortOrder.TITLE_AUTHOR_DESC.name(),	
			FileInfo.SortOrder.TIMESTAMP.name(),	
			FileInfo.SortOrder.TIMESTAMP_DESC.name(),	
		};
		OptionsDialog.ListOption dlg = new OptionsDialog.ListOption(
			new OptionOwner() {
				public CoolReader getActivity() { return mActivity; }
				public Properties getProperties() { return properties; }
				public LayoutInflater getInflater() { return mInflater; }
			}, 
			mActivity.getString(R.string.mi_book_sort_order), 
			ReaderView.PROP_APP_BOOK_SORT_ORDER).add(optionValues, optionLabels); 
		dlg.setOnChangeHandler(new Runnable() {
			public void run() {
				final String newValue = properties.getProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER);
				if ( newValue!=null && oldValue!=null && !newValue.equals(oldValue) ) {
					log.d(""New sort order: "" + newValue);
					setSortOrder(newValue);
				}
			}
		});
		dlg.onSelect();
	}
	
	private void showOPDSDir( final FileInfo fileOrDir, final FileInfo itemToSelect ) {
		
		if ( fileOrDir.fileCount()>0 || fileOrDir.dirCount()>0 ) {
			// already downloaded
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					showDirectoryInternal(fileOrDir, itemToSelect);					
				}
			});
			return;
		}
		
		String url = fileOrDir.getOPDSUrl();
		final FileInfo myCurrDirectory = currDirectory;
		if ( url!=null ) {
			try {
				final URL uri = new URL(url);
				DownloadCallback callback = new DownloadCallback() {

					@Override
					public void onEntries(DocInfo doc,
							Collection<EntryInfo> entries) {
						// TODO Auto-generated method stub
					}

					@Override
					public void onFinish(DocInfo doc,
							Collection<EntryInfo> entries) {
						if ( myCurrDirectory != currDirectory ) {
							log.w(""current directory has been changed: ignore downloaded items"");
							return;
						}
						ArrayList<FileInfo> items = new ArrayList<FileInfo>();
						for ( EntryInfo entry : entries ) {
							OPDSUtil.LinkInfo acquisition = entry.getBestAcquisitionLink();
							if ( acquisition!=null ) {
								FileInfo file = new FileInfo();
								file.isDirectory = false;
								file.pathname = FileInfo.OPDS_DIR_PREFIX + acquisition.href;
								file.filename = entry.content;
								file.title = entry.title;
								file.format = DocumentFormat.byMimeType(acquisition.type);
								file.authors = entry.getAuthors();
								file.isListed = true;
								file.isScanned = true;
								file.parent = fileOrDir;
								file.tag = entry;
								items.add(file);
							} else if ( entry.link.type!=null && entry.link.type.startsWith(""application/atom+xml"") ) {
								FileInfo file = new FileInfo();
								file.isDirectory = true;
								file.pathname = FileInfo.OPDS_DIR_PREFIX + entry.link.href;
								file.filename = entry.title;
								file.isListed = true;
								file.isScanned = true;
								file.tag = entry;
								file.parent = fileOrDir;
								items.add(file);
							}
						}
						if ( items.size()>0 ) {
							fileOrDir.replaceItems(items);
							showDirectoryInternal(fileOrDir, null);
						} else {
							mActivity.showToast(""No OPDS entries found"");
						}
					}

					@Override
					public void onError(String message) {
						mEngine.hideProgress();
						mActivity.showToast(message);
					}

					FileInfo downloadDir;
					@Override
					public File onDownloadStart(String type, String url) {
						//mEngine.showProgress(0, ""Downloading "" + url);
						//mActivity.showToast(""Starting download of "" + type + "" from "" + url);
						log.d(""onDownloadStart: called for "" + type + "" "" + url );
						downloadDir = mActivity.getScanner().getDownloadDirectory();
						log.d(""onDownloadStart: after getDownloadDirectory()"" );
						String subdir = null;
						if ( fileOrDir.authors!=null ) {
							subdir = OPDSUtil.transcribeFileName(fileOrDir.authors);
							if ( subdir.length()>MAX_SUBDIR_LEN )
								subdir = subdir.substring(0, MAX_SUBDIR_LEN);
						} else {
							subdir = ""NoAuthor"";
						}
						if ( downloadDir==null )
							return null;
						File result = new File(downloadDir.getPathName());
						result = new File(result, subdir);
						result.mkdirs();
						downloadDir.findItemByPathName(result.getAbsolutePath());
						log.d(""onDownloadStart: returning "" + result.getAbsolutePath() );
						return result;
					}

					@Override
					public void onDownloadEnd(String type, String url, File file) {
						mEngine.hideProgress();
						//mActivity.showToast(""Download is finished"");
						FileInfo fi = new FileInfo(file);
						FileInfo dir = mScanner.findParent(fi, downloadDir);
						if ( dir==null )
							dir = downloadDir;
						mScanner.listDirectory(dir);
						FileInfo item = dir.findItemByPathName(file.getAbsolutePath());
						if ( item!=null )
							mActivity.loadDocument(item);
						else
							mActivity.loadDocument(fi);
					}

					@Override
					public void onDownloadProgress(String type, String url,
							int percent) {
						mEngine.showProgress(percent * 100, ""Downloading"");
					}
					
				};
				String fileMimeType = fileOrDir.format!=null ? fileOrDir.format.getMimeFormat() : null;
				String defFileName = OPDSUtil.transcribeFileName( fileOrDir.title!=null ? fileOrDir.title : fileOrDir.filename );
				if ( fileOrDir.format!=null )
					defFileName = defFileName + fileOrDir.format.getExtensions()[0];
				final OPDSUtil.DownloadTask downloadTask = OPDSUtil.create(mActivity, uri, defFileName, fileOrDir.isDirectory?""application/atom+xml"":fileMimeType, 
						myCurrDirectory.getOPDSUrl(), callback);
				downloadTask.run();
			} catch (MalformedURLException e) {
				log.e(""MalformedURLException: "" + url);
				mActivity.showToast(""Wrong URI: "" + url);
			}
		}
	}
	
	public void showDirectory( FileInfo fileOrDir, FileInfo itemToSelect )
	{
		BackgroundThread.ensureGUI();
		if ( fileOrDir!=null && fileOrDir.isOPDSDir() ) {
			showOPDSDir(fileOrDir, itemToSelect);
			return;
		}
		if (fileOrDir!=null && fileOrDir.isSearchShortcut()) {
			showFindBookDialog();
			return;
		}
		if (fileOrDir!=null && fileOrDir.isBooksByAuthorRoot()) {
			// refresh authors list
			log.d(""Updating authors list"");
			mActivity.getDB().loadAuthorsList(fileOrDir);
		}
		if (fileOrDir!=null && fileOrDir.isBooksByAuthorDir()) {
			log.d(""Updating author book list"");
			mActivity.getDB().loadAuthorBooks(fileOrDir);
		}
		
		if ( fileOrDir==null && mScanner.getRoot()!=null && mScanner.getRoot().dirCount()>0 ) {
			if ( mScanner.getRoot().getDir(0).fileCount()>0 ) {
				fileOrDir = mScanner.getRoot().getDir(0);
				itemToSelect = mScanner.getRoot().getDir(0).getFile(0);
			} else {
				fileOrDir = mScanner.getRoot();
				itemToSelect = mScanner.getRoot().dirCount()>1 ? mScanner.getRoot().getDir(1) : null;
			}
		}
		final FileInfo file = fileOrDir==null || fileOrDir.isDirectory ? itemToSelect : fileOrDir;
		final FileInfo dir = fileOrDir!=null && !fileOrDir.isDirectory ? mScanner.findParent(file, mScanner.getRoot()) : fileOrDir;
		if ( dir!=null ) {
			mScanner.scanDirectory(dir, new Runnable() {
				public void run() {
					if ( dir.allowSorting() )
						dir.sort(mSortOrder);
					showDirectoryInternal(dir, file);
				}
			}, false, new Scanner.ScanControl() );
		} else
			showDirectoryInternal(null, file);
	}
	
	public void scanCurrentDirectoryRecursive() {
		if ( currDirectory==null )
			return;
		log.i(""scanCurrentDirectoryRecursive started"");
		final Scanner.ScanControl control = new Scanner.ScanControl(); 
		final ProgressDialog dlg = ProgressDialog.show(mActivity, 
				mActivity.getString(R.string.dlg_scan_title), 
				mActivity.getString(R.string.dlg_scan_message),
				true, true, new OnCancelListener() {
					@Override
					public void onCancel(DialogInterface dialog) {
						log.i(""scanCurrentDirectoryRecursive : stop handler"");
						control.stop();
					}
		});
		mScanner.scanDirectory(currDirectory, new Runnable() {
			@Override
			public void run() {
				log.i(""scanCurrentDirectoryRecursive : finish handler"");
				if ( dlg.isShowing() )
					dlg.dismiss();
			}
		}, true, control); 
	}


	public boolean isSimpleViewMode() {
		return isSimpleViewMode;
	}

	public void setSimpleViewMode( boolean isSimple ) {
		if ( isSimpleViewMode!=isSimple ) {
			isSimpleViewMode = isSimple;
			mSortOrder = FileInfo.SortOrder.FILENAME;
			mActivity.saveSetting(ReaderView.PROP_APP_BOOK_SORT_ORDER, mSortOrder.name());
			if ( isShown() && currDirectory!=null ) {
				showDirectory(currDirectory, null);
			}
		}
	}
	private boolean isSimpleViewMode = true;

	private FileListAdapter currentListAdapter;
	
	private class FileListAdapter extends BaseListAdapter {
		public boolean areAllItemsEnabled() {
			return true;
		}

		public boolean isEnabled(int arg0) {
			return true;
		}

		public int getCount() {
			if (currDirectory == null)
				return 0;
			return currDirectory.fileCount() + currDirectory.dirCount() + (currDirectory.parent!=null ? 1 : 0);
		}

		public Object getItem(int position) {
			if (currDirectory == null)
				return null;
			if ( position<0 )
				return null;
			int start = (currDirectory.parent!=null ? 1 : 0);
			if ( position<start )
				return currDirectory.parent;
			return currDirectory.getItem(position-start);
		}

		public long getItemId(int position) {
			if (currDirectory == null)
				return 0;
			return position;
		}

		public final int VIEW_TYPE_LEVEL_UP = 0;
		public final int VIEW_TYPE_DIRECTORY = 1;
		public final int VIEW_TYPE_FILE = 2;
		public final int VIEW_TYPE_FILE_SIMPLE = 3;
		public final int VIEW_TYPE_COUNT = 4;
		public int getItemViewType(int position) {
			if (currDirectory == null)
				return 0;
			if (position < 0)
				return Adapter.IGNORE_ITEM_VIEW_TYPE;
			int start = (currDirectory.parent!=null ? 1 : 0);
			if (position<start)
				return VIEW_TYPE_LEVEL_UP;
			if (position<start + currDirectory.dirCount())
				return VIEW_TYPE_DIRECTORY;
			start += currDirectory.dirCount();
			position -= start;
			if (position < currDirectory.fileCount())
				return isSimpleViewMode ? VIEW_TYPE_FILE_SIMPLE : VIEW_TYPE_FILE;
			return Adapter.IGNORE_ITEM_VIEW_TYPE;
		}

		class ViewHolder {
			int viewType;
			ImageView image;
			TextView name;
			TextView author;
			TextView series;
			TextView filename;
			TextView field1;
			TextView field2;
			//TextView field3;
			void setText( TextView view, String text )
			{
				if ( view==null )
					return;
				if ( text!=null && text.length()>0 ) {
					view.setText(text);
					view.setVisibility(ViewGroup.VISIBLE);
				} else {
					view.setText(null);
					view.setVisibility(ViewGroup.INVISIBLE);
				}
			}
			void setItem(FileInfo item, FileInfo parentItem)
			{
				if ( item==null ) {
					image.setImageResource(R.drawable.cr3_browser_back);
					String thisDir = """";
					if ( parentItem!=null ) {
						if ( parentItem.pathname.startsWith(""@"") )
							thisDir = ""/"" + parentItem.filename;
//						else if ( parentItem.isArchive )
//							thisDir = parentItem.arcname;
						else
							thisDir = parentItem.pathname;
						//parentDir = parentItem.path;
					}
					name.setText(thisDir);
					return;
				}
				if ( item.isDirectory ) {
					if (item.isBooksByAuthorRoot())
						image.setImageResource(R.drawable.cr3_browser_folder_authors);
					else if (item.isOPDSRoot() || item.isOPDSDir())
						image.setImageResource(R.drawable.cr3_browser_folder_opds);
					else if (item.isSearchShortcut())
						image.setImageResource(R.drawable.cr3_browser_find);
					else if ( item.isRecentDir() )
						image.setImageResource(R.drawable.cr3_browser_folder_recent);
					else if ( item.isArchive )
						image.setImageResource(R.drawable.cr3_browser_folder_zip);
					else
						image.setImageResource(R.drawable.cr3_browser_folder);
					setText(name, item.filename);

					if ( item.isBooksByAuthorDir() ) {
						int bookCount = 0;
						if (item.fileCount() > 0)
							bookCount = item.fileCount();
						else if (item.tag != null && item.tag instanceof Integer)
							bookCount = (Integer)item.tag;
						setText(field1, ""books: "" + String.valueOf(bookCount));
						setText(field2, ""folders: 0"");
					} else  if ( !item.isOPDSDir() && !item.isSearchShortcut() && (!item.isBooksByAuthorRoot() || item.dirCount()>0)) {
						setText(field1, ""books: "" + String.valueOf(item.fileCount()));
						setText(field2, ""folders: "" + String.valueOf(item.dirCount()));
					} else {
						setText(field1, """");
						setText(field2, """");
					}
				} else {
					boolean isSimple = (viewType == VIEW_TYPE_FILE_SIMPLE);
					if ( image!=null ) {
						if ( isSimple ) {
							image.setImageResource(item.format.getIconResourceId());
						} else {
							Drawable drawable = null;
							if ( item.id!=null )
								drawable = mHistory.getBookCoverpageImage(null, item.id);
							if ( drawable!=null ) {
								image.setImageDrawable(drawable);
							} else {
								int resId = item.format!=null ? item.format.getIconResourceId() : 0;
								if ( resId!=0 )
									image.setImageResource(item.format.getIconResourceId());
							}
						}
					}
					if ( isSimple ) {
						String fn = item.getFileNameToDisplay();
						setText( filename, fn );
					} else {
						setText( author, formatAuthors(item.authors) );
						String seriesName = formatSeries(item.series, item.seriesNumber);
						String title = item.title;
						String filename1 = item.filename;
						String filename2 = item.isArchive /*&& !item.isDirectory */
								? new File(item.arcname).getName() : null;
						if ( title==null || title.length()==0 ) {
							title = filename1;
							if (seriesName==null) 
								seriesName = filename2;
						} else if (seriesName==null) 
							seriesName = filename1;
						setText( name, title );
						setText( series, seriesName );

//						field1.setVisibility(VISIBLE);
//						field2.setVisibility(VISIBLE);
//						field3.setVisibility(VISIBLE);
						if (field1 != null)
							field1.setText(formatSize(item.size) + "" "" + (item.format!=null ? item.format.name().toLowerCase() : """") + "" "" + formatDate(item.createTime) + ""  "");
						//field2.setText(formatDate(pos!=null ? pos.getTimeStamp() : item.createTime));
						if (field2 != null) {
							Bookmark pos = mHistory.getLastPos(item);
							if ( pos!=null ) {
								field2.setText(formatPercent(pos.getPercent()) + "" "" + formatDate(pos.getTimeStamp())) ;
							} else {
								field2.setText("""");
							}
						}
						//field3.setText(pos!=null ? formatPercent(pos.getPercent()) : null);
					} 
					
				}
			}
		}
		
		public View getView(int position, View convertView, ViewGroup parent) {
			if (currDirectory == null)
				return null;
			View view;
			ViewHolder holder;
			int vt = getItemViewType(position);
			if (convertView == null) {
				if ( vt==VIEW_TYPE_LEVEL_UP )
					view = mInflater.inflate(R.layout.browser_item_parent_dir, null);
				else if ( vt==VIEW_TYPE_DIRECTORY )
					view = mInflater.inflate(R.layout.browser_item_folder, null);
				else if ( vt==VIEW_TYPE_FILE_SIMPLE )
					view = mInflater.inflate(R.layout.browser_item_book_simple, null);
				else
					view = mInflater.inflate(R.layout.browser_item_book, null);
				holder = new ViewHolder();
				holder.image = (ImageView)view.findViewById(R.id.book_icon);
				holder.name = (TextView)view.findViewById(R.id.book_name);
				holder.author = (TextView)view.findViewById(R.id.book_author);
				holder.series = (TextView)view.findViewById(R.id.book_series);
				holder.filename = (TextView)view.findViewById(R.id.book_filename);
				holder.field1 = (TextView)view.findViewById(R.id.browser_item_field1);
				holder.field2 = (TextView)view.findViewById(R.id.browser_item_field2);
				//holder.field3 = (TextView)view.findViewById(R.id.browser_item_field3);
				view.setTag(holder);
			} else {
				view = convertView;
				holder = (ViewHolder)view.getTag();
			}
			holder.viewType = vt;
			FileInfo item = (FileInfo)getItem(position);
			FileInfo parentItem = null;//item!=null ? item.parent : null;
			if ( vt == VIEW_TYPE_LEVEL_UP ) {
				item = null;
				parentItem = currDirectory;
			}
			holder.setItem(item, parentItem);
//			if ( DeviceInfo.FORCE_LIGHT_THEME ) {
//				view.setBackgroundColor(Color.WHITE);
//			}
			return view;
		}

		public int getViewTypeCount() {
			if (currDirectory == null)
				return 1;
			return VIEW_TYPE_COUNT;
		}

		public boolean hasStableIds() {
			return true;
		}

		public boolean isEmpty() {
			if (currDirectory == null)
				return true;
			return mScanner.mFileList.size()==0;
		}

	}
	
	private void showDirectoryInternal( final FileInfo dir, final FileInfo file )
	{
		BackgroundThread.ensureGUI();
		currDirectory = dir;
		if ( dir!=null )
			log.i(""Showing directory "" + dir + "" "" + Thread.currentThread().getName());
		if ( !BackgroundThread.instance().isGUIThread() )
			throw new IllegalStateException(""showDirectoryInternal should be called from GUI thread!"");
		int index = dir!=null ? dir.getItemIndex(file) : -1;
		if ( dir!=null && !dir.isRootDir() )
			index++;
		mListView.setAdapter(currentListAdapter);
		currentListAdapter.notifyDataSetChanged();
		mListView.setSelection(index);
		mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		mListView.invalidate();
	}

	private class MyGestureListener extends SimpleOnGestureListener {

		@Override
		public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
				float velocityY) {
			if (e1 == null || e2 == null)
				return false;
			int thresholdDistance = mActivity.getPalmTipPixels() * 2;
			int thresholdVelocity = mActivity.getPalmTipPixels();
			int x1 = (int)e1.getX();
			int x2 = (int)e2.getX();
			int y1 = (int)e1.getY();
			int y2 = (int)e2.getY();
			int dist = x2 - x1;
			int adist = dist > 0 ? dist : -dist;
			int ydist = y2 - y1;
			int aydist = ydist > 0 ? ydist : -ydist;
			int vel = (int)velocityX;
			if (vel<0)
				vel = -vel;
			if (vel > thresholdVelocity && adist > thresholdDistance && adist > aydist * 2) {
				if (dist > 0) {
					log.d(""LTR fling detected: moving to parent"");
					showParentDirectory();
					return true;
				} else {
					log.d(""RTL fling detected: show menu"");
					mActivity.openOptionsMenu();
					return true;
				}
			}
			return false;
		}
		
	}
	
	private void execute( Engine.EngineTask task )
    {
    	mEngine.execute(task);
    }

    private abstract class Task implements Engine.EngineTask {
    	
		public void done() {
			// override to do something useful
		}

		public void fail(Exception e) {
			// do nothing, just log exception
			// override to do custom action
			log.e(""Task "" + this.getClass().getSimpleName() + "" is failed with exception "" + e.getMessage(), e);
		}
    }
    
}
",True,21,49,0,0,3,26,3,21,L0
42,org.coolreader.crengine.CRDB.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;

import android.database.Cursor;
import android.database.DatabaseUtils;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteDiskIOException;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

public class CRDB {
	static final boolean DROP_TABLES = false; // for debug purposes
	SQLiteDatabase mDB;
	File mDBFile;
	SQLiteDatabase mCoverpageDB;
	//File mCoverpageDBFile;

	private boolean moveToBackup(File f) {
		Log.e(""cr3"", ""Moving corrupted DB file to backup."");
		File f2 = null;
		for (int i=2; i<100; i++) {
			f2 = new File(f.getAbsoluteFile() + "".bak."" + i);
			if (!f2.exists())
				break;
		}
		if (!f.renameTo(f2)) {
			Log.e(""cr3"", ""Cannot rename DB file "" + f + "" to "" + f2);
			if (!f.delete()) {
				Log.e(""cr3"", ""Cannot remove DB file "" + f);
				return false;
			}
		}
		return true;
	}

	private void openCoverpageDB(File coverFile) {
		try {
			this.mCoverpageDB = SQLiteDatabase.openOrCreateDatabase(coverFile, null);
		} catch (SQLiteDiskIOException e) {
			moveToBackup(coverFile);
			this.mCoverpageDB = SQLiteDatabase.openOrCreateDatabase(coverFile, null);
			try {
				this.mCoverpageDB = SQLiteDatabase.openOrCreateDatabase(coverFile, null);
			} catch (SQLiteDiskIOException e2) {
				throw new SQLiteDiskIOException(""can't open DB "" + coverFile + "": "" + e2.getMessage());
			}
		}
	}
	
	synchronized protected boolean open( File dbfile )
	{
		File coverFile = new File(dbfile.getAbsolutePath().replace("".sqlite"", ""_cover.sqlite""));
		L.i(""Opening database from "" + dbfile.getAbsolutePath());
		try {
			this.mDB = SQLiteDatabase.openOrCreateDatabase(dbfile, null);
			openCoverpageDB(coverFile);
			try {
				updateSchema();
			} catch (SQLiteDiskIOException e) {
				throw (SQLiteDiskIOException)new SQLiteDiskIOException(""error updating schema "" + mDBFile + "": "" + e.getMessage()).initCause(e);
			}
		} catch (SQLiteDiskIOException e) {
			moveToBackup(dbfile);
			moveToBackup(coverFile);
			try {
				this.mDB = SQLiteDatabase.openOrCreateDatabase(dbfile, null);
				openCoverpageDB(coverFile);
			} catch (SQLiteDiskIOException e2) {
				throw (SQLiteDiskIOException)new SQLiteDiskIOException(""can't open DB "" + dbfile + "": "" + e2.getMessage()).initCause(e2);
			}
			try {
				updateSchema();
			} catch (SQLiteDiskIOException e2) {
				throw (SQLiteDiskIOException)new SQLiteDiskIOException(""error updating schema "" + mDBFile + "": "" + e2.getMessage()).initCause(e2);
			}
		}
		this.mDBFile = dbfile;
		return true;
	}

	protected void dropTables()
	{
		String[] tableNames = new String[] {
			""book_author"", ""bookmark"", ""book"", ""series"", ""author"", ""folder"", ""coverpage""	
		};
		for ( String name : tableNames )
			mDB.execSQL(""DROP TABLE IF EXISTS "" + name);
		mCoverpageDB.execSQL(""DROP TABLE IF EXISTS coverpage"");
	}
	
	private void execSQLIgnoreErrors( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""query failed, ignoring: "" + sql);
			}
		}
	}

	private void execSQLCoverpageIgnoreErrors( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mCoverpageDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""cp query failed, ignoring: "" + sql);
			}
		}
	}

	private void execSQL( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""query failed: "" + sql);
				throw e;
			}
		}
	}

	private void execCoverpageSQL( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mCoverpageDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""cp query failed: "" + sql);
				throw e;
			}
		}
	}

	private final static String[] COVERPAGE_SCHEMA = new String[] {
		""CREATE TABLE IF NOT EXISTS coverpage ("" +
		""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
		""imagedata BLOB NULL"" +
		"")""
	};
	
	public final int DB_VERSION = 7;
	protected boolean updateSchema()
	{
		if (DROP_TABLES)
			dropTables();
		execSQL(""CREATE TABLE IF NOT EXISTS author ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL COLLATE NOCASE"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
                ""author_name_index ON author (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS series ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL COLLATE NOCASE"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
		        ""series_name_index ON series (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS folder ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""folder_name_index ON folder (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS book ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""pathname VARCHAR NOT NULL,"" +
				""folder_fk INTEGER REFERENCES folder (id),"" +
				""filename VARCHAR NOT NULL,"" +
				""arcname VARCHAR,"" +
				""title VARCHAR COLLATE NOCASE,"" +
				""series_fk INTEGER REFERENCES series (id),"" +
				""series_number INTEGER,"" +
				""format INTEGER,"" +
				""filesize INTEGER,"" +
				""arcsize INTEGER,"" +
				""create_time INTEGER,"" +
				""last_access_time INTEGER, "" +
				""flags INTEGER DEFAULT 0"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_folder_index ON book (folder_fk) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_pathname_index ON book (pathname) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_filename_index ON book (filename) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_title_index ON book (title) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_last_access_time_index ON book (last_access_time) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_title_index ON book (title) "");
		execSQL(""CREATE TABLE IF NOT EXISTS book_author ("" +
				""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
				""author_fk INTEGER NOT NULL REFERENCES author (id),"" +
				""PRIMARY KEY (book_fk, author_fk)"" +
				"")"");
		execSQL(""CREATE UNIQUE INDEX IF NOT EXISTS "" +
				""author_book_index ON book_author (author_fk, book_fk) "");
		execSQL(""CREATE TABLE IF NOT EXISTS bookmark ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
				""type INTEGER NOT NULL DEFAULT 0,"" +
				""percent INTEGER DEFAULT 0,"" +
				""shortcut INTEGER DEFAULT 0,"" +
				""time_stamp INTEGER DEFAULT 0,"" +
				""start_pos VARCHAR NOT NULL,"" +
				""end_pos VARCHAR,"" +
				""title_text VARCHAR,"" +
				""pos_text VARCHAR,"" +
				""comment_text VARCHAR"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
		""bookmark_book_index ON bookmark (book_fk) "");
		execCoverpageSQL(COVERPAGE_SCHEMA);
		int currentVersion = mDB.getVersion();
		// version 1 updates ====================================================================
		if ( currentVersion<1 )
			execSQLIgnoreErrors(""ALTER TABLE bookmark ADD COLUMN shortcut INTEGER DEFAULT 0"");
		if ( currentVersion<3 )
			execSQLIgnoreErrors(COVERPAGE_SCHEMA);
		if ( currentVersion<4 )
			execSQLIgnoreErrors(""ALTER TABLE book ADD COLUMN flags INTEGER DEFAULT 0"");
		if ( currentVersion>0 && currentVersion<5 )
			migrateCoverpages();
		if ( currentVersion<6 )
			execSQL(""CREATE TABLE IF NOT EXISTS opds_catalog ("" +
					""id INTEGER PRIMARY KEY AUTOINCREMENT, "" +
					""name VARCHAR NOT NULL COLLATE NOCASE, "" +
					""url VARCHAR NOT NULL COLLATE NOCASE"" +
					"")"");
		if ( currentVersion<7 )
			addOPDSCatalogs(DEF_OPDS_URLS1);
		// TODO: add more updates here
			
		// set current version
		if ( currentVersion<DB_VERSION )
			mDB.setVersion(DB_VERSION);
		return true;
	}
	
	private final static String[] DEF_OPDS_URLS1 = {
			""http://www.feedbooks.com/catalog.atom"", ""Feedbooks"",
			""http://bookserver.archive.org/catalog/"", ""Internet Archive"",
			""http://m.gutenberg.org/"", ""Project Gutenberg"", 
//			""http://ebooksearch.webfactional.com/catalog.atom"", ""eBookSearch"", 
			""http://bookserver.revues.org/"", ""Revues.org"", 
			""http://www.legimi.com/opds/root.atom"", ""Legimi"",
			""http://www.ebooksgratuits.com/opds/"", ""Ebooks libres et gratuits"",
			""http://flibusta.net/opds/"", ""Flibusta"", 
	};

	private void addOPDSCatalogs(String[] catalogs) {
		for (int i=0; i<catalogs.length-1; i+=2) {
			String url = catalogs[i];
			String name = catalogs[i+1];
			saveOPDSCatalog(null, url, name);
		}
	}

	public boolean loadAuthorBooks(FileInfo parent) {
		Log.i(""cr3"", ""loadAuthorBooks()"");
		parent.clear();
		boolean found = false;
		if (!parent.isBooksByAuthorDir())
			return false;
		long id = parent.getAuthorId();
		if (id == 0)
			return false;
		ArrayList<FileInfo> list = new ArrayList<FileInfo>();
		if (findAuthorBooks(list, id)) {
			for (FileInfo file : list) {
				file.parent = parent;
				parent.addFile(file);
			}
		}
		return found;
	}

	public boolean loadAuthorsList(FileInfo parent) {
		Log.i(""cr3"", ""loadAuthorsList()"");
		parent.clear();
		boolean found = false;
		Cursor rs = null;
		FileInfo letterDir = null;
		String lastAuthorFirstLetter = null;
		try {
			String sql = ""SELECT author.id, author.name, count(*) as book_count FROM author INNER JOIN book_author ON book_author.author_fk = author.id GROUP BY author.id, author.name ORDER BY author.name"";
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				// remove existing entries
				parent.clear();
				// read DB
				do {
					long id = rs.getLong(0);
					String name = rs.getString(1);
					Integer bookCount = rs.getInt(2);
					String firstLetter = (name!=null && name.length()>0) ? name.substring(0, 1).toUpperCase() : ""_"";
					if (letterDir == null || !firstLetter.equals(lastAuthorFirstLetter)) {
						letterDir = new FileInfo();
						letterDir.isDirectory = true;
						letterDir.pathname = FileInfo.AUTHOR_GROUP_PREFIX + firstLetter;
						letterDir.filename = firstLetter + ""..."";
						letterDir.isListed = true;
						letterDir.isScanned = true;
						letterDir.parent = parent;
						letterDir.id = id;
						lastAuthorFirstLetter = firstLetter;
						parent.addDir(letterDir);
						found = true;
					}
					FileInfo author = new FileInfo();
					author.isDirectory = true;
					author.pathname = FileInfo.AUTHOR_PREFIX + id;
					author.filename = name;
					author.isListed = true;
					author.isScanned = true;
					author.parent = parent;
					author.id = id;
					author.tag = bookCount;
					letterDir.addDir(author);
					found = true;
				} while (rs.moveToNext());
			}
		} catch (Exception e) {
			Log.e(""cr3"", ""exception while loading list of authors"", e);
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}
	
	private static String quoteSqlString(String src) {
		if (src==null)
			return ""null"";
		String s = src.replaceAll(""\\'"", ""\\\\'"");
		return ""'"" + s + ""'"";
	}
	
	public boolean saveOPDSCatalog(Long id, String url, String name) {
		if (url==null || name==null)
			return false;
		url = url.trim();
		name = name.trim();
		if (url.length()==0 || name.length()==0)
			return false;
		try {
			Long existingIdByUrl = longQuery(""SELECT id FROM opds_catalog WHERE url="" + quoteSqlString(url));
			Long existingIdByName = longQuery(""SELECT id FROM opds_catalog WHERE name="" + quoteSqlString(name));
			if (existingIdByUrl!=null && existingIdByName!=null && !existingIdByName.equals(existingIdByUrl))
				return false; // duplicates detected
			if (id==null) {
				id = existingIdByUrl;
				if (id==null)
					id = existingIdByName;
			}
			if (id==null) {
				// insert new
				execSQL(""INSERT INTO opds_catalog (name, url) VALUES (""+quoteSqlString(name)+"", ""+quoteSqlString(url)+"")"");
			} else {
				// update existing
				execSQL(""UPDATE opds_catalog SET name=""+quoteSqlString(name)+"", url=""+quoteSqlString(url)+"" WHERE id="" + id);
			}
				
		} catch (Exception e) {
			Log.e(""cr3"", ""exception while saving OPDS catalog item"", e);
			return false;
		}
		return true;
	}

	synchronized public boolean loadOPDSCatalogs(FileInfo parent) {
		Log.i(""cr3"", ""loadOPDSCatalogs()"");
		boolean found = false;
		Cursor rs = null;
		try {
			String sql = ""SELECT id, name, url FROM opds_catalog"";
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				// remove existing entries
				parent.clear();
				// read DB
				do {
					Long id = rs.getLong(0);
					String name = rs.getString(1);
					String url = rs.getString(2);
					FileInfo opds = new FileInfo();
					opds.isDirectory = true;
					opds.pathname = FileInfo.OPDS_DIR_PREFIX + url;
					opds.filename = name;
					opds.isListed = true;
					opds.isScanned = true;
					opds.parent = parent;
					opds.id = id;
					parent.addDir(opds);
					found = true;
				} while (rs.moveToNext());
			}
		} catch (Exception e) {
			Log.e(""cr3"", ""exception while loading list of OPDS catalogs"", e);
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}
	
	public void removeOPDSCatalog(Long id) {
		Log.i(""cr3"", ""removeOPDSCatalog("" + id + "")"");
		execSQLIgnoreErrors(""DELETE FROM opds_catalog WHERE id = "" + id);
	}

	private void migrateCoverpages() {
		Thread migrationThread = new Thread() {
			@Override
			public void run() {
				Log.i(""cr3"", ""Migration thread is started"");
				try {
					String sql = ""SELECT book_fk, imagedata FROM coverpage"";
					Cursor rs = null;
					try {
						rs = mDB.rawQuery(sql, null);
						if ( rs.moveToFirst() ) {
							do {
								long id = rs.getLong(0);
								byte[] data = rs.getBlob(1);
								if (data!=null && data.length>0) {
									Log.i(""cr3"", ""Moving coverpage for bookId="" + id + "" ("" + data.length + "" bytes)"");
									saveBookCoverpage(id, data);
								}
							} while (rs.moveToNext());
							execSQLIgnoreErrors(""DROP TABLE IF EXISTS coverpage"");
						}
					} finally {
						if (rs!=null)
							rs.close();
					}
				} catch (Exception e) {
					Log.e(""cr3"", ""Exception while moving cover pages"", e);
				}
				Log.i(""cr3"", ""Migration thread is finished"");
			}
			
		};
		migrationThread.start();
	}
	
	public CRDB( File dbfile )
	{
		open(dbfile);

		dumpStatistics();
	}
	
	public boolean findByPathname( FileInfo fileInfo )
	{
		return findBy( fileInfo, ""pathname"", fileInfo.getPathName());
	}

	public boolean findById( FileInfo fileInfo )
	{
		return findBy( fileInfo, ""b.id"", fileInfo.id);
	}

	private static final String READ_BOOKMARK_SQL = 
		""SELECT "" +
		""id, type, percent, shortcut, time_stamp, "" + 
		""start_pos, end_pos, title_text, pos_text, comment_text "" +
		""FROM bookmark b "";
	private void readBookmarkFromCursor( Bookmark v, Cursor rs )
	{
		int i=0;
		v.setId( rs.getLong(i++) );
		v.setType( (int)rs.getLong(i++) );
		v.setPercent( (int)rs.getLong(i++) );
		v.setShortcut( (int)rs.getLong(i++) );
		v.setTimeStamp( rs.getLong(i++) );
		v.setStartPos( rs.getString(i++) );
		v.setEndPos( rs.getString(i++) );
		v.setTitleText( rs.getString(i++) );
		v.setPosText( rs.getString(i++) );
		v.setCommentText( rs.getString(i++) );
		v.setModified(false);
	}
	synchronized public boolean findBy( Bookmark v, String condition )
	{
		boolean found = false;
		Cursor rs = null;
		try {
			condition = "" WHERE "" + condition;
			rs = mDB.rawQuery(READ_BOOKMARK_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				readBookmarkFromCursor( v, rs );
				found = true;
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	synchronized public boolean load( ArrayList<Bookmark> list, String condition )
	{
		boolean found = false;
		Cursor rs = null;
		try {
			condition = "" WHERE "" + condition;
			rs = mDB.rawQuery(READ_BOOKMARK_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				do {
					Bookmark v = new Bookmark();
					readBookmarkFromCursor( v, rs );
					list.add(v);
					found = true;
				} while ( rs.moveToNext() );
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	private static final String READ_FILEINFO_FIELDS = 
		""b.id AS id, pathname,"" +
		""f.name as path, "" +
		""filename, arcname, title, "" +
		""(SELECT GROUP_CONCAT(a.name,'|') FROM author a JOIN book_author ba ON a.id=ba.author_fk WHERE ba.book_fk=b.id) as authors, "" +
		""s.name as series_name, "" +
		""series_number, "" +
		""format, filesize, arcsize, "" +
		""create_time, last_access_time, flags "";
	
	private static final String READ_FILEINFO_SQL = 
		""SELECT "" +
		READ_FILEINFO_FIELDS +
		""FROM book b "" +
		""LEFT JOIN series s ON s.id=b.series_fk "" +
		""LEFT JOIN folder f ON f.id=b.folder_fk "";
	private void readFileInfoFromCursor( FileInfo fileInfo, Cursor rs )
	{
		int i=0;
		fileInfo.id = rs.getLong(i++);
		String pathName = rs.getString(i++);
		String[] parts = FileInfo.splitArcName(pathName);
		fileInfo.pathname = parts[0];
		fileInfo.path = rs.getString(i++);
		fileInfo.filename = rs.getString(i++);
		fileInfo.arcname = rs.getString(i++);
		fileInfo.title = rs.getString(i++);
		fileInfo.authors = rs.getString(i++);
		fileInfo.series = rs.getString(i++);
		fileInfo.seriesNumber = rs.getInt(i++);
		fileInfo.format = DocumentFormat.byId(rs.getInt(i++));
		fileInfo.size = rs.getInt(i++);
		fileInfo.arcsize = rs.getInt(i++);
		fileInfo.createTime = rs.getInt(i++);
		fileInfo.lastAccessTime = rs.getInt(i++);
		fileInfo.flags = rs.getInt(i++);
		fileInfo.isArchive = fileInfo.arcname!=null; 
	}
	
	
	synchronized public boolean findBy( FileInfo fileInfo, String fieldName, Object fieldValue )
	{
		String condition;
		StringBuilder buf = new StringBuilder("" WHERE "");
		buf.append(fieldName);
		if ( fieldValue==null ) {
			buf.append("" IS NULL "");
		} else {
			buf.append(""="");
			DatabaseUtils.appendValueToSql(buf, fieldValue);
			buf.append("" "");
		}
		condition = buf.toString();
		boolean found = false;
		Cursor rs = null;
		try { 
			rs = mDB.rawQuery(READ_FILEINFO_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				readFileInfoFromCursor( fileInfo, rs );
				found = true;
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	synchronized public FileInfo[] findByPatterns( int maxCount, String author, String title, String series, String filename )
	{
		ArrayList<FileInfo> list = new ArrayList<FileInfo>();
		
		StringBuilder buf = new StringBuilder();
		if ( author!=null && author.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.id IN (SELECT ba.book_fk FROM author a JOIN book_author ba ON a.id=ba.author_fk WHERE a.name LIKE "");
			DatabaseUtils.appendValueToSql(buf, author);
			buf.append("") "");
		}
		if ( series!=null && series.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.series_fk IN (SELECT s.name FROM series s WHERE s.name LIKE "");
			DatabaseUtils.appendValueToSql(buf, series);
			buf.append("") "");
		}
		if ( title!=null && title.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.title LIKE "");
			DatabaseUtils.appendValueToSql(buf, title);
			buf.append("" "");
		}
		if ( filename!=null && filename.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.filename LIKE "");
			DatabaseUtils.appendValueToSql(buf, filename);
			buf.append("" "");
		}
		if ( buf.length()==0 )
			return new FileInfo[0];
		
		String condition = "" WHERE "" + buf.toString();
		String sql = READ_FILEINFO_SQL + condition;
		Log.d(""cr3"", ""sql: "" + sql );
		if ( condition.length()==0 )
			return new FileInfo[] { };
		Cursor rs = null;
		try { 
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				int count = 0;
				do {
					FileInfo fi = new FileInfo(); 
					readFileInfoFromCursor( fi, rs );
					list.add(fi);
					count++;
				} while ( count<maxCount && rs.moveToNext() );
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return list.toArray(new FileInfo[list.size()]);
	}
	
	synchronized public boolean findRecentBooks( ArrayList<FileInfo> list, int maxCount, int limit )
	{
		String sql = READ_FILEINFO_SQL + "" WHERE last_access_time>0 ORDER BY last_access_time DESC LIMIT "" + limit;
		Cursor rs = null;
		boolean found = false;
		try {
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				do {
					FileInfo fileInfo = new FileInfo();
					readFileInfoFromCursor( fileInfo, rs );
					if ( !fileInfo.fileExists() )
						continue;
					list.add(fileInfo);
					found = true;
					if ( list.size()>maxCount )
						break;
				} while (rs.moveToNext());
			}
		} finally {
			rs.close();
		}
		return found;
	}
	
	synchronized public boolean findAuthorBooks(ArrayList<FileInfo> list, long authorId)
	{
		String sql = READ_FILEINFO_SQL + "" LEFT JOIN book_author ON book_author.book_fk = b.id WHERE book_author.author_fk = "" + authorId + "" ORDER BY b.title"";
		Cursor rs = null;
		boolean found = false;
		try {
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				do {
					FileInfo fileInfo = new FileInfo();
					readFileInfoFromCursor( fileInfo, rs );
					if ( !fileInfo.fileExists() )
						continue;
					list.add(fileInfo);
					found = true;
				} while (rs.moveToNext());
			}
		} finally {
			if (rs != null)
				rs.close();
		}
		return found;
	}
	
	private Long longQuery( String sql )
	{
		SQLiteStatement stmt = null;
		try {
			stmt = mDB.compileStatement(sql);
			return stmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found or error
			return null;
		} finally {
			if (stmt != null)
				stmt.close();
		}
	}
	
	private Long longCoverpageQuery( String sql )
	{
		SQLiteStatement stmt = null;
		try {
			stmt = mCoverpageDB.compileStatement(sql);
			return stmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found or error
			return null;
		} finally {
			if (stmt != null)
				stmt.close();
		}
	}
	
	synchronized public void saveBookCoverpage( long bookId, byte[] data )
	{
		if ( data==null )
			return;
		SQLiteStatement stmt = null;
		try { 
			Long existing = longCoverpageQuery(""SELECT book_fk FROM coverpage WHERE book_fk="" + bookId);
			if ( existing==null ) {
				stmt = mCoverpageDB.compileStatement(""INSERT INTO coverpage (book_fk, imagedata) VALUES (""+bookId+"", ?)"");
				stmt.bindBlob(1, data);
				stmt.execute();
				Log.v(""cr3"", ""db: saved "" + data.length + "" bytes of cover page for book "" + bookId);
			}
		} catch ( Exception e ) {
			Log.e(""cr3"", ""Exception while trying to save cover page to DB: "" + e.getMessage() );
		} finally {
			if ( stmt!=null )
				stmt.close();
		}
	}
	synchronized public byte[] loadBookCoverpage( long bookId )
	{
		Cursor rs = null;
		try {
			rs = mCoverpageDB.rawQuery(""SELECT imagedata FROM coverpage WHERE book_fk="" + bookId, null);
			if ( rs.moveToFirst() ) {
				return rs.getBlob(0);
			}
			return null;
		} catch ( Exception e ) {
			Log.e(""cr3"", ""error while reading coverpage for book "" + bookId + "": "" + e.getMessage());
			return null;
		} finally {
			if ( rs!=null )
				rs.close();
		}
	}
	
	synchronized public void dumpStatistics()
	{
		Log.i(""cr3db"", ""DB: "" + longQuery(""SELECT count(*) FROM author"") + "" authors, ""
				 + longQuery(""SELECT count(*) FROM series"") + "" series, ""
				 + longQuery(""SELECT count(*) FROM book"") + "" books, ""
				 + longQuery(""SELECT count(*) FROM bookmark"") + "" bookmarks""
				 + longQuery(""SELECT count(*) FROM folder"") + "" folders""
				 + longCoverpageQuery(""SELECT count(*) FROM coverpage"") + "" coverpages""
				 );
	}

	private SQLiteStatement seriesStmt;
	private SQLiteStatement seriesSelectStmt;
	private HashMap<String,Long> seriesCache = new HashMap<String,Long>();
	synchronized public Long getSeriesId( String seriesName )
	{
		if ( seriesName==null || seriesName.trim().length()==0 )
			return null;
		Long id = seriesCache.get(seriesName); 
		if ( id!=null )
			return id;
		if ( seriesSelectStmt==null )
			seriesSelectStmt = mDB.compileStatement(""SELECT id FROM series WHERE name=?"");
		try {
			seriesSelectStmt.bindString(1, seriesName);
			return seriesSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( seriesStmt==null )
			seriesStmt = mDB.compileStatement(""INSERT INTO series (id, name) VALUES (NULL,?)"");
		seriesStmt.bindString(1, seriesName);
		id = seriesStmt.executeInsert();
		seriesCache.put( seriesName, id );
		return id;
	}
	
	private SQLiteStatement folderStmt;
	private SQLiteStatement folderSelectStmt;
	private HashMap<String,Long> folderCache = new HashMap<String,Long>();
	synchronized public Long getFolderId( String folderName )
	{
		if ( folderName==null || folderName.trim().length()==0 )
			return null;
		Long id = folderCache.get(folderName); 
		if ( id!=null )
			return id;
		if ( folderSelectStmt==null )
			folderSelectStmt = mDB.compileStatement(""SELECT id FROM folder WHERE name=?"");
		try {
			folderSelectStmt.bindString(1, folderName);
			return folderSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( folderStmt==null )
			folderStmt = mDB.compileStatement(""INSERT INTO folder (id, name) VALUES (NULL,?)"");
		folderStmt.bindString(1, folderName);
		id = folderStmt.executeInsert();
		folderCache.put( folderName, id );
		return id;
	}
	
	private SQLiteStatement authorStmt;
	private SQLiteStatement authorSelectStmt;
	private HashMap<String,Long> authorCache = new HashMap<String,Long>();
	synchronized public Long getAuthorId( String authorName )
	{
		if ( authorName==null || authorName.trim().length()==0 )
			return null;
		Long id = authorCache.get(authorName); 
		if ( id!=null )
			return id;
		if ( authorSelectStmt==null )
			authorSelectStmt = mDB.compileStatement(""SELECT id FROM author WHERE name=?"");
		try {
			authorSelectStmt.bindString(1, authorName);
			return authorSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( authorStmt==null )
			authorStmt = mDB.compileStatement(""INSERT INTO author (id, name) VALUES (NULL,?)"");
		authorStmt.bindString(1, authorName);
		id = authorStmt.executeInsert();
		authorCache.put( authorName, id );
		return id;
	}
	synchronized public Long[] getAuthorIds( String authorNames )
	{
		if ( authorNames==null || authorNames.trim().length()==0 )
			return null;
		String[] names = authorNames.split(""\\|"");
		if ( names==null || names.length==0 )
			return null;
		ArrayList<Long> ids = new ArrayList<Long>(names.length);
		for ( String name : names ) {
			Long id = getAuthorId(name);
			if ( id!=null )
				ids.add(id);
		}
		if ( ids.size()>0 )
			return ids.toArray(new Long[ids.size()]);
		return null;
	}
	
	synchronized public void saveBookAuthors( Long bookId, Long[] authors)
	{
		if ( authors==null || authors.length==0 )
			return;
		String insertQuery = ""INSERT OR IGNORE INTO book_author (book_fk,author_fk) VALUES "";
		for ( Long id : authors ) {
			String sql = insertQuery + ""("" + bookId + "","" + id + "")""; 
			//Log.v(""cr3"", ""executing: "" + sql);
			mDB.execSQL(sql);
		}
	}

	public static boolean eq(String s1, String s2)
	{
		if ( s1!=null )
			return s1.equals(s2);
		return s2==null;
	}
	
	public class QueryHelper {
		String tableName;
		QueryHelper(String tableName)
		{
			this.tableName = tableName;
		}
		ArrayList<String> fields = new ArrayList<String>(); 
		ArrayList<Object> values = new ArrayList<Object>();
		QueryHelper add(String fieldName, int value, int oldValue )
		{
			if ( value!=oldValue ) {
				fields.add(fieldName);
				values.add(Long.valueOf(value));
			}
			return this;
		}
		QueryHelper add(String fieldName, Long value, Long oldValue )
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		QueryHelper add(String fieldName, String value, String oldValue)
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		QueryHelper add(String fieldName, Double value, Double oldValue)
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		Long insert()
		{
			if ( fields.size()==0 )
				return null;
			StringBuilder valueBuf = new StringBuilder();
			try {
				String ignoreOption = """"; //""OR IGNORE "";
				StringBuilder buf = new StringBuilder(""INSERT "" + ignoreOption + "" INTO "");
				buf.append(tableName);
				buf.append("" (id"");
				for ( String field : fields ) {
					buf.append("","");
					buf.append(field);
				}
				buf.append("") VALUES (NULL"");
				for ( String field : fields ) {
					buf.append("","");
					buf.append(""?"");
				}
				buf.append("")"");
				String sql = buf.toString();
				Log.d(""cr3db"", ""going to execute "" + sql);
				SQLiteStatement stmt = null;
				Long id = null;
				try {
					stmt = mDB.compileStatement(sql);
					for ( int i=1; i<=values.size(); i++ ) {
						Object v = values.get(i-1);
						valueBuf.append(v!=null ? v.toString() : ""null"");
						valueBuf.append("","");
						if ( v==null )
							stmt.bindNull(i);
						else if (v instanceof String)
							stmt.bindString(i, (String)v);
						else if (v instanceof Long)
							stmt.bindLong(i, (Long)v);
						else if (v instanceof Double)
							stmt.bindDouble(i, (Double)v);
					}
					id = stmt.executeInsert();
					Log.d(""cr3db"", ""added book, id="" + id + "", query="" + sql);
				} finally {
					if ( stmt!=null )
						stmt.close();
				}
				return id;
			} catch ( Exception e ) {
				Log.e(""cr3db"", ""insert failed: "" + e.getMessage());
				Log.e(""cr3db"", ""values: "" + valueBuf.toString());
				return null;
			}
		}
		boolean update( Long id )
		{
			if ( fields.size()==0 )
				return false;
			StringBuilder buf = new StringBuilder(""UPDATE "");
			buf.append(tableName);
			buf.append("" SET "");
			boolean first = true;
			for ( String field : fields ) {
				if ( !first )
					buf.append("","");
				buf.append(field);
				buf.append(""=?"");
				first = false;
			}
			buf.append("" WHERE id="" + id );
			mDB.execSQL(buf.toString(), values.toArray());
			return true;
		}
		Long fromFormat( DocumentFormat f )
		{
			if ( f==null )
				return null;
			return (long)f.ordinal();
		}
		QueryHelper( FileInfo newValue, FileInfo oldValue )
		{
			this(""book"");
			add(""pathname"", newValue.getPathName(), oldValue.getPathName());
			add(""folder_fk"", getFolderId(newValue.path), getFolderId(oldValue.path));
			add(""filename"", newValue.filename, oldValue.filename);
			add(""arcname"", newValue.arcname, oldValue.arcname);
			add(""title"", newValue.title, oldValue.title);
			add(""series_fk"", getSeriesId(newValue.series), getSeriesId(oldValue.series));
			add(""series_number"", (long)newValue.seriesNumber, (long)oldValue.seriesNumber);
			add(""format"", fromFormat(newValue.format), fromFormat(oldValue.format));
			add(""filesize"", (long)newValue.size, (long)oldValue.size);
			add(""arcsize"", (long)newValue.arcsize, (long)oldValue.arcsize);
			add(""last_access_time"", (long)newValue.lastAccessTime, (long)oldValue.lastAccessTime);
			add(""create_time"", (long)newValue.createTime, (long)oldValue.createTime);
			add(""flags"", (long)newValue.flags, (long)oldValue.flags);
		}
		QueryHelper( Bookmark newValue, Bookmark oldValue, long bookId )
		{
			this(""bookmark"");
			add(""book_fk"", bookId, oldValue.getId()!=null ? bookId : null);
			add(""type"", newValue.getType(), oldValue.getType());
			add(""percent"", newValue.getPercent(), oldValue.getPercent());
			add(""shortcut"", newValue.getShortcut(), oldValue.getShortcut());
			add(""start_pos"", newValue.getStartPos(), oldValue.getStartPos());
			add(""end_pos"", newValue.getEndPos(), oldValue.getEndPos());
			add(""title_text"", newValue.getTitleText(), oldValue.getTitleText());
			add(""pos_text"", newValue.getPosText(), oldValue.getPosText());
			add(""comment_text"", newValue.getCommentText(), oldValue.getCommentText());
			add(""time_stamp"", newValue.getTimeStamp(), oldValue.getTimeStamp());
		}
	}

	/**
	 * @param fileList
	 * @param maxCount
	 * @return
	 */
	public ArrayList<BookInfo> loadRecentBooks( HashMap<String, FileInfo> fileList, int maxCount )
	{
		ArrayList<FileInfo> list = new ArrayList<FileInfo>();
		findRecentBooks( list, maxCount, maxCount*10 );
		ArrayList<BookInfo> res = new ArrayList<BookInfo>(list.size());
		for ( FileInfo file : list ) {
			fileList.put(file.getPathName(), file);
			BookInfo item = new BookInfo( file );
			ArrayList<Bookmark> bookmarks = new ArrayList<Bookmark>(); 
			if ( load( bookmarks, ""book_fk="" + file.id + "" ORDER BY type"" ) ) {
				item.setBookmarks(bookmarks);
			}
			res.add(item);
		}
		return res;
	}

	synchronized public boolean save( BookInfo bookInfo )
	{
		if ( mDB==null ) {
			Log.e(""cr3db"", ""cannot save book info : DB is closed"");
			return false;
		}
		if (bookInfo==null || bookInfo.getFileInfo()==null)
			return false;
		boolean res = true;
		if (bookInfo.getFileInfo().isModified || bookInfo.getFileInfo().id==null) {
			res = save(bookInfo.getFileInfo()) && res;
			Log.d(""cr3db"", ""saving Book info id="" + bookInfo.getFileInfo().id);
		}
		for ( int i=0; i<bookInfo.getBookmarkCount(); i++ ) {
			 Bookmark bmk  = bookInfo.getBookmark(i);
			 if (bmk.isModified())
			 	res = save(bmk, bookInfo.getFileInfo().id) || res;
		}
		if ( bookInfo.getLastPosition()!=null && bookInfo.getLastPosition().isModified() )
			res = save(bookInfo.getLastPosition(), bookInfo.getFileInfo().id) || res;
		return res;
	}

	private boolean save( Bookmark v, long bookId )
	{
		if ( !v.isModified() )
			return false;
		Log.d(""cr3db"", ""saving bookmark id="" + v.getId() + "", bookId="" + bookId + "", pos="" + v.getStartPos());
		if ( v.getId()!=null ) {
			// update
			Bookmark oldValue = new Bookmark();
			oldValue.setId(v.getId());
			if ( findBy(oldValue, ""book_fk="" + bookId + "" AND id="" + v.getId()) ) {
				// found, updating
				QueryHelper h = new QueryHelper(v, oldValue, bookId);
				h.update(v.getId());
			} else {
				oldValue = new Bookmark();
				QueryHelper h = new QueryHelper(v, oldValue, bookId);
				v.setId( h.insert() );
			}
		} else {
			Bookmark oldValue = new Bookmark();
			QueryHelper h = new QueryHelper(v, oldValue, bookId);
			v.setId( h.insert() );
		}
		v.setModified(false);
		return true;
	}

	synchronized public void deleteRecentPosition( FileInfo fileInfo )
	{
		if ( fileInfo==null || fileInfo.id==0 )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE book_fk="" + fileInfo.id + "" AND type=0"");
		execSQLIgnoreErrors(""UPDATE book SET last_access_time=0 WHERE id="" + fileInfo.id);
	}
	
	synchronized public void deleteBookmark( Bookmark bm )
	{
		if ( bm.getId()==null )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE id="" + bm.getId());
	}
	
	synchronized public void deleteBook( FileInfo fileInfo )
	{
		if ( fileInfo==null || fileInfo.id==0 )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE book_fk="" + fileInfo.id);
		execSQLIgnoreErrors(""DELETE FROM coverpage WHERE book_fk="" + fileInfo.id);
		execSQLIgnoreErrors(""DELETE FROM book WHERE id="" + fileInfo.id);
	}
	
	synchronized public boolean save( FileInfo fileInfo )
	{
		boolean authorsChanged = true;
		try {
			if ( fileInfo.id!=null ) {
				// update
				FileInfo oldValue = new FileInfo();
				oldValue.id = fileInfo.id;
				if ( findById(oldValue) ) {
					// found, updating
					QueryHelper h = new QueryHelper(fileInfo, oldValue);
					h.update(fileInfo.id);
					authorsChanged = !eq(fileInfo.authors, oldValue.authors);
				} else {
					oldValue = new FileInfo();
					QueryHelper h = new QueryHelper(fileInfo, oldValue);
					fileInfo.id = h.insert();
				}
			} else {
				FileInfo oldValue = new FileInfo();
				QueryHelper h = new QueryHelper(fileInfo, oldValue);
				fileInfo.id = h.insert();
			}
			fileInfo.setModified(false);
			if ( fileInfo.id!=null ) {
				if ( authorsChanged ) {
					Long[] authorIds = getAuthorIds(fileInfo.authors);
					saveBookAuthors(fileInfo.id, authorIds);
				}
				return true;
			}
			return false;
		} catch (SQLiteDiskIOException e) {
			throw new SQLiteDiskIOException(""error while writing to DB "" + mDBFile + "": "" + e.getMessage());
		}
	}

	synchronized public void flush()
    {
        Log.i(""cr3db"", ""Flushing DB"");
        if ( seriesStmt!=null) {
            seriesStmt.close();
            seriesStmt = null;
        }
        if ( authorStmt!=null) {
            authorStmt.close();
            authorStmt = null;
        }
        if ( seriesSelectStmt!=null) {
            seriesSelectStmt.close();
            seriesSelectStmt = null;
        }
        if ( authorSelectStmt!=null) {
            authorSelectStmt.close();
            authorSelectStmt = null;
        }
        SQLiteDatabase.releaseMemory();
    }
    
	synchronized public void close()
	{
	    flush();
		Log.i(""cr3db"", ""Closing DB"");
		if ( mDB!=null && mDB.isOpen() ) {
			mDB.close();
			mDB = null;
		}
		if ( mCoverpageDB!=null && mCoverpageDB.isOpen() ) {
			mCoverpageDB.close();
			mCoverpageDB = null;
		}
	}
}
",True,15,49,0,0,5,28,7,5,L0
43,org.coolreader.crengine.Properties.java,"package org.coolreader.crengine;

import java.util.Map;

public class Properties extends java.util.Properties {
	public Properties()
	{
		super();
	}
	public void setAll(java.util.Properties props)
	{
        for ( Map.Entry<Object, Object> entry : props.entrySet() ) {
    		setProperty((String)entry.getKey(), (String)entry.getValue());
        }
	}
	public Properties(java.util.Properties props)
	{
		setAll(props);
	}
	private static int revBytes( int color )
	{
		return color & 0xFFFFFF;
		//return ((color & 0xFF)<<16)|((color & 0xFF00)<<0)|((color & 0xFF0000)>>16);
	}
	public void setColor( String key, int color )
	{
		color &= 0xFFFFFF;
		color = revBytes(color);
		String value = Integer.toHexString(color);
		while ( value.length()<6 )
			value = ""0"" + value;
		value = ""0x"" + value;
		setProperty(key, value);
	}
	public int getColor( String key, int defColor )
	{
		defColor = revBytes(defColor);
		String value = getProperty(key);
		try {
			if ( value!=null && value.length()>2 && value.startsWith(""0x"") ) {
				int cl = Integer.parseInt(value.substring(2), 16);
				cl = revBytes(cl);
				return cl | 0xFF000000;
			}
		} catch ( Exception e ) {
		}
		return revBytes(defColor) | 0xFF000000;
	}
	public void setInt( String key, int v )
	{
		String value = String.valueOf(v);
		setProperty(key, value);
	}
	public int getInt( String key, int def )
	{
		String value = getProperty(key);
		int res = def;
		try {
			if ( value!=null )
				res = Integer.valueOf(value);
		} catch ( Exception e ) {
		}
		return res;
	}
	public void setBool( String key, boolean value )
	{
		setProperty( key, value ? ""1"" : ""0"" );
	}
	public boolean getBool( String key, boolean defaultValue )
	{
		String value = getProperty(key);
		if ( value==null )
			return defaultValue;
		if ( value.equals(""1"") || value.equals(""true"") || value.equals(""yes"") )
			return true;
		if ( value.equals(""0"") || value.equals(""false"") || value.equals(""no"") )
			return false;
		return defaultValue;
	}

	public void applyDefault( String prop, String defValue )
	{
		if ( getProperty(prop)==null )
			setProperty(prop, defValue);
	}
	
	public void applyDefault( String prop, int defValue )
	{
		if ( getProperty(prop)==null )
			setInt(prop, defValue);
	}
	
	public static boolean eq(Object obj1, Object obj2)
	{
		if ( obj1==null && obj2==null )
			return true;
		if ( obj1==null || obj2==null )
			return false;
		return obj1.equals(obj2);
	}

	public Properties diff( Properties oldValue )
	{
		Properties res = new Properties();
        for ( Map.Entry<Object, Object> entry : entrySet() ) {
        	if ( !oldValue.containsKey(entry.getKey()) || !eq(entry.getValue(), oldValue.get(entry.getKey()))) {
        		res.setProperty( (String)entry.getKey(), (String)entry.getValue() );
        	}
        }
        return res;
	}
}
",True,38,30,4,18,0,0,7,0,L0
44,org.coolreader.crengine.EinkScreen.java,"package org.coolreader.crengine;

import org.coolreader.crengine.N2EpdController;
import android.view.View;

public class EinkScreen {
	
	/// variables
	public static int UpdateMode = -1; 
	// 0 - CLEAR_ALL, set only for old_mode == 2 
	// 1 - ONESHOT, always set in prepare 
	// 2 - ACTIVE, set in prepare
	public static int UpdateModeInterval;
	public static int RefreshNumber = -1;
	public static boolean IsSleep = false;
	// constants
	public final static int cmodeClear = 0;
	public final static int cmodeOneshot = 1;
	public final static int cmodeActive = 2;

	public static void PrepareController(View view, boolean isPartially) {
		if (DeviceInfo.EINK_NOOK) {
			//System.err.println(""Sleep = "" + isPartially);
			if (isPartially || IsSleep != isPartially) {
				SleepController(isPartially, view);
//				if (isPartially) 
					return;
			} 
			if (RefreshNumber == -1) {
				switch (UpdateMode) {
					case cmodeClear:
						SetMode(view, cmodeClear);
						break;
					case cmodeActive:
						if (UpdateModeInterval == 0) {
							SetMode(view, cmodeActive);
						}
						break;
				}
				RefreshNumber = 0;
				return;
			}
			if (UpdateMode == cmodeClear) {
				SetMode(view, cmodeClear);
				return;
			}
			if (UpdateMode > 0 && (UpdateModeInterval > 0 || UpdateMode == 1)) {
				if (RefreshNumber == 0 || (UpdateMode == cmodeOneshot && RefreshNumber < UpdateModeInterval)) {
					switch (UpdateMode) {
						case cmodeActive:
							SetMode(view, cmodeActive);
							break;
						case cmodeOneshot:
							SetMode(view, cmodeOneshot);
							break;
					}
				} else if (UpdateModeInterval <= RefreshNumber) {
					SetMode(view, cmodeClear);
					RefreshNumber = -1;
				}
				if (UpdateModeInterval > 0) {
					RefreshNumber++;
				}
			}
			
			return;
			/*
			if (UpdateMode == 1 && UpdateModeInterval != 0) {
				if (RefreshNumber == 0) {
					// быстрый режим, один раз устанавливается
					N2EpdController.setMode(N2EpdController.REGION_APP_3,
											N2EpdController.WAVE_GL16,
											N2EpdController.MODE_ACTIVE, view); // why not MODE_ACTIVE_ALL?
				} else if (UpdateModeInterval == RefreshNumber) {
					// одно качественное обновление для быстрого режима
					N2EpdController.setMode(N2EpdController.REGION_APP_3,
											N2EpdController.WAVE_GU,
											N2EpdController.MODE_CLEAR_ALL, view);
					RefreshNumber = -1;
				}
				RefreshNumber ++;
			}
			*/
		}
	}

	public static void ResetController(int mode, View view) {
		if (!DeviceInfo.EINK_NOOK) { return; }
		System.err.println(""+++ResetController "" + mode);
		switch (mode) {
			case cmodeClear:
				if (UpdateMode == cmodeActive) {
					RefreshNumber = -1;
				} else {
					RefreshNumber = 0;
				}
				break;
			case cmodeOneshot:
				RefreshNumber = 0;
				break;
			default:
				RefreshNumber = -1;
		}
		
		UpdateMode = mode;
	}
	public static void ResetController(View view) {
		if (!DeviceInfo.EINK_NOOK || UpdateMode == cmodeClear) { return; }
		System.err.println(""+++Soft reset Controller "");
		SetMode(view, cmodeClear);
		RefreshNumber = -1;
	}

	public static void SleepController(boolean toSleep, View view) {
		if (!DeviceInfo.EINK_NOOK || toSleep == IsSleep) {
			return;
		}
		System.err.println(""+++SleepController "" + toSleep);
		IsSleep = toSleep;
		if (IsSleep) {
			switch (UpdateMode) {
			case cmodeClear:
				break;
			case cmodeOneshot:
				break;
			case cmodeActive:
				SetMode(view, cmodeClear);
				RefreshNumber = -1;
			}
		} else {
			ResetController(UpdateMode, view);
		}
		return;
	}
	
	private static void SetMode(View view, int mode) {
		switch (mode) {
		case cmodeClear:	
			N2EpdController.setMode(N2EpdController.REGION_APP_3,
				N2EpdController.WAVE_GC,
				N2EpdController.MODE_ONESHOT_ALL);
//				N2EpdController.MODE_CLEAR, view);
			break;
		case cmodeOneshot:	
			N2EpdController.setMode(N2EpdController.REGION_APP_3,
					N2EpdController.WAVE_GU,
					N2EpdController.MODE_ONESHOT_ALL);
//			N2EpdController.MODE_ONESHOT_ALL, view);
			break;
		case cmodeActive:	
			N2EpdController.setMode(N2EpdController.REGION_APP_3,
				N2EpdController.WAVE_GL16,
				N2EpdController.MODE_ACTIVE_ALL);
//			N2EpdController.MODE_ACTIVE_ALL, view);
			break;
		}  
	}	
}
",True,40,32,4,23,1,2,2,2,L0
45,org.coolreader.crengine.BackgroundThread.java,"package org.coolreader.crengine;

import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.Executor;

import org.coolreader.crengine.ReaderView.Sync;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.view.View;

/**
 * Allows running tasks either in background thread or in GUI thread.
 */
public class BackgroundThread extends Thread {
	
	private final static Object LOCK = new Object(); 

	private static BackgroundThread instance;
	
	// singleton
	public static BackgroundThread instance()
	{
		if ( instance==null ) {
			synchronized( LOCK ) {
				if ( instance==null ) {
					instance = new BackgroundThread();
					instance.start();
				}
			}
		}
		return instance;
	}

	public final static Executor backgroundExecutor = new Executor() {
		public void execute(Runnable task) {
			instance().postBackground(task);
		}
	};
	
	public final static Executor guiExecutor = new Executor() {
		public void execute(Runnable task) {
			instance().postGUI(task);
		}
	};
	
	public final static boolean CHECK_THREAD_CONTEXT = true; 

	/**
	 * Throws exception if not in background thread.
	 */
	public final static void ensureBackground()
	{
		if ( CHECK_THREAD_CONTEXT && !instance().isBackgroundThread() ) {
			L.e(""not in background thread"", new Exception(""ensureInBackgroundThread() is failed""));
			throw new RuntimeException(""ensureInBackgroundThread() is failed"");
		}
	}
	
	/**
	 * Throws exception if not in GUI thread.
	 */
	public final static void ensureGUI()
	{
		if ( CHECK_THREAD_CONTEXT && instance().isBackgroundThread() ) {
			L.e(""not in GUI thread"", new Exception(""ensureGUI() is failed""));
			throw new RuntimeException(""ensureGUI() is failed"");
		}
	}
	
	// 
	private Handler handler;
	private ArrayList<Runnable> posted = new ArrayList<Runnable>();
	private View guiTarget;
	private ArrayList<Runnable> postedGUI = new ArrayList<Runnable>();

	/**
	 * Set view to post GUI tasks to.
	 * @param guiTarget is view to post GUI tasks to.
	 */
	public void setGUI( View guiTarget ) {
		this.guiTarget = guiTarget;
		if ( guiTarget!=null ) {
			// forward already posted events
			synchronized(postedGUI) {
				L.d(""Engine.setGUI: "" + postedGUI.size() + "" posted tasks to copy"");
				for ( Runnable task : postedGUI )
					guiTarget.post( task );
			}
		}
	}

	/**
	 * Create background thread executor.
	 */
	private BackgroundThread() {
		super();
		setName(""BackgroundThread"" + Integer.toHexString(hashCode()));
	}

	@Override
	public void run() {
		L.i(""Entering background thread"");
		Looper.prepare();
		handler = new Handler() {
			public void handleMessage( Message message )
			{
				L.d(""message: "" + message);
			}
		};
		L.i(""Background thread handler is created"");
		synchronized(posted) {
			for ( Runnable task : posted ) {
				L.i(""Copying posted bg task to handler : "" + task);
				handler.post(task);
			}
			posted.clear();
		}
		Looper.loop();
		handler = null;
		L.i(""Exiting background thread"");
	}

	private final static boolean USE_LOCK = false;
	private Runnable guard( final Runnable r )
	{
		if ( !USE_LOCK )
			return r;
		return new Runnable() {
			public void run() {
				synchronized (LOCK) {
					r.run();
				}
			}
		};
	}

	/**
	 * Post runnable to be executed in background thread.
	 * @param task is runnable to execute in background thread.
	 */
	public void postBackground( Runnable task )
	{
		Engine.suspendLongOperation();
		if ( mStopped ) {
			L.i(""Posting task "" + task + "" to GUI queue since background thread is stopped"");
			postGUI( task );
			return;
		}
		task = guard(task);
		if ( handler==null ) {
			synchronized(posted) {
				L.i(""Adding task "" + task + "" to posted list since handler is not yet created"");
				posted.add(task);
			}
		} else {
			handler.post(task);
		}
	}

	/**
	 * Post runnable to be executed in GUI thread
	 * @param task is runnable to execute in GUI thread
	 */
	public void postGUI( Runnable task )
	{
		postGUI(task, 0);
	}

	/**
	 * Post runnable to be executed in GUI thread
	 * @param task is runnable to execute in GUI thread
	 * @param delay is delay before running task, in millis
	 */
	public void postGUI( Runnable task, long delay )
	{
		if ( guiTarget==null ) {
			synchronized( postedGUI ) {
				postedGUI.add(task);
			}
		} else {
			if ( delay>0 )
				guiTarget.postDelayed(task, delay);
			else
				guiTarget.post(task);
		}
	}

	/**
	 * Run task instantly if called from the same thread, or post it through message queue otherwise.
	 * @param task is task to execute
	 */
	public void executeBackground( Runnable task )
	{
		Engine.suspendLongOperation();
		task = guard(task);
		if ( isBackgroundThread() || mStopped )
			task.run(); // run in this thread
		else 
			postBackground(task); // post
	}

	// assume there are only two threads: main GUI and background
	public boolean isGUIThread()
	{
		return !isBackgroundThread();
	}

	public boolean isBackgroundThread()
	{
		return ( Thread.currentThread()==this );
	}

	public void executeGUI( Runnable task )
	{
		//Handler guiHandler = guiTarget.getHandler();
		//if ( guiHandler!=null && guiHandler.getLooper().getThread()==Thread.currentThread() )
		if ( isGUIThread() )
			task.run(); // run in this thread
		else
			postGUI(task);
	}

    public <T> Callable<T> guard( final Callable<T> task )
    {
    	return new Callable<T>() {
    		public T call() throws Exception {
    			return task.call();
    		}
    	};
    }
    
    
    /**
     * Waits until all pending background tasks are executed.
     */
    public void syncWithBackground() {
    	callBackground( new Callable<Integer>() {
			@Override
			public Integer call() throws Exception {
				return null;
			}
    	});
    }
	
    public <T> T callBackground( final Callable<T> srcTask )
    {
    	final Callable<T> task = srcTask; //guard(srcTask);
    	if ( isBackgroundThread() ) {
    		try {
    			return task.call();
    		} catch ( Exception e ) {
    			return null;
    		}
    	}
    	//L.d(""executeSync called"");
    	if(DBG) L.d(""callBackground : posting Background task "" + Thread.currentThread().getName());
    	final Sync<T> sync = new Sync<T>();
    	postBackground( new Runnable() {
    		public void run() {
    			if(DBG) L.d(""callBackground : inside background thread "" + Thread.currentThread().getName());
    			try {
    				sync.set( task.call() );
    			} catch ( Exception e ) {
    				sync.set( null );
    			}
    		}
    	});
    	if(DBG) L.d(""callBackground : calling get "" + Thread.currentThread().getName());
    	T res = sync.get();
    	if(DBG) L.d(""callBackground : returned from get "" + Thread.currentThread().getName());
    	//L.d(""executeSync done"");
    	return res;
    }
	
    private final static boolean DBG = false; 
    
    public <T> T callGUI( final Callable<T> task )
    {
    	if ( isGUIThread() ) {
    		try {
    			return task.call();
    		} catch ( Exception e ) {
    			return null;
    		}
    	}
    	if(DBG) L.d(""callGUI : posting GUI task "" + Thread.currentThread().getName());
    	final Sync<T> sync = new Sync<T>();
    	postGUI( new Runnable() {
    		public void run() {
    			if(DBG) L.d(""callGUI : inside GUI thread "" + Thread.currentThread().getName());
    	    	T result = null;
    			try {
        	    	L.d(""callGUI : calling source callable "" + Thread.currentThread().getName());
    				result = task.call();
    			} catch ( Exception e ) {
    				if(DBG) L.e(""exception in postGUI"", e);
    				throw new RuntimeException(e);
    			}
    			try {
    				if(DBG) L.d(""callGUI : calling sync.set "" + Thread.currentThread().getName());
    				sync.set( result );
    				if(DBG) L.d(""callGUI : returned from sync.set "" + Thread.currentThread().getName());
    			} catch ( Exception e ) {
    				if(DBG) L.e(""exception in postGUI"", e);
    				throw new RuntimeException(e);
    			}
    		}
    	});
    	if(DBG) L.d(""callGUI : calling get "" + Thread.currentThread().getName());
    	T res = sync.get();
    	if(DBG) L.d(""callGUI : returned from get "" + Thread.currentThread().getName());
    	return res;
    }
	
	private boolean mStopped = false;
	
	public void waitForBackgroundCompletion()
	{
		Engine.suspendLongOperation();
		callBackground(new Callable<Object>() {
			public Object call() {
				return null;
			}
		});
	}
	
//	public void quit()
//	{
//		callBackground(new Callable<Object>() {
//			public Object call() {
//				mStopped = true;
//				Looper.myLooper().quit();
//				return null;
//			}
//		});
//	}
}
",True,4,49,0,0,3,34,8,3,L0
46,org.coolreader.crengine.BookmarkEditDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.TextView;

public class BookmarkEditDialog extends BaseDialog {
	
	private final CoolReader mCoolReader;
	private final LayoutInflater mInflater;
	private final ReaderView mReaderView;
	private final Bookmark mOriginalBookmark;
	private final Bookmark mBookmark;
	private final boolean mIsNew;
	final EditText commentEdit;
	
	public BookmarkEditDialog( CoolReader activity, ReaderView readerView, Bookmark bookmark, boolean isNew)
	{
		super(activity, """", true, false);
		mCoolReader = activity;
		mReaderView = readerView;
		mIsNew = isNew;
		mOriginalBookmark = bookmark;
		if ( !isNew )
			mBookmark = new Bookmark(bookmark);
		else
			mBookmark = bookmark;
		boolean isComment = bookmark.getType()==Bookmark.TYPE_COMMENT;
		setTitle(mCoolReader.getString( mIsNew ? R.string.dlg_bookmark_create : R.string.dlg_bookmark_edit));
		mInflater = LayoutInflater.from(getContext());
		View view = mInflater.inflate(R.layout.bookmark_edit_dialog, null);
		final RadioButton btnComment = (RadioButton)view.findViewById(R.id.rb_comment);
		final RadioButton btnCorrection = (RadioButton)view.findViewById(R.id.rb_correction);
		final TextView posLabel = (TextView)view.findViewById(R.id.lbl_position); 
		final TextView commentLabel = (TextView)view.findViewById(R.id.lbl_comment_text); 
		final EditText posEdit = (EditText)view.findViewById(R.id.position_text); 
		commentEdit = (EditText)view.findViewById(R.id.comment_edit);
		String postext = mBookmark.getPercent()/100 + ""%"";
		if ( mBookmark.getTitleText()!=null )
			postext = postext + ""  "" + mBookmark.getTitleText();
		posLabel.setText(postext);
		commentLabel.setText(isComment ? R.string.dlg_bookmark_edit_comment : R.string.dlg_bookmark_edit_correction);
		posEdit.setText(mBookmark.getPosText());
		commentEdit.setText(bookmark.getCommentText());
		if ( isNew ) {
			btnComment.setChecked(isComment);
			btnCorrection.setChecked(!isComment);
			btnComment.setOnCheckedChangeListener(new OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					if ( isChecked ) {
						mBookmark.setType(Bookmark.TYPE_COMMENT); 
						commentLabel.setText(R.string.dlg_bookmark_edit_comment); // : R.string.dlg_bookmark_edit_correction
					}
				}
			});
			btnCorrection.setOnCheckedChangeListener(new OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					if ( isChecked ) {
						mBookmark.setType(Bookmark.TYPE_CORRECTION); 
						commentLabel.setText(R.string.dlg_bookmark_edit_correction);
						String oldText = commentEdit.getText().toString();
						if ( oldText==null || oldText.length()==0 )
							commentEdit.setText(mBookmark.getPosText());
					}
				}
			});
		} else {
			btnComment.setClickable(false);
			btnCorrection.setClickable(false);
		}
		setView( view );
	}

	@Override
	protected void onPositiveButtonClick() {
		if ( mIsNew ) {
			mBookmark.setCommentText( commentEdit.getText().toString() );
			mReaderView.addBookmark(mBookmark);
		} else {
			if ( mOriginalBookmark.setCommentText(mBookmark.getCommentText()) ) {
				mOriginalBookmark.setTimeStamp(System.currentTimeMillis());
				mReaderView.updateBookmark(mBookmark);
			}
		}
		super.onPositiveButtonClick();
	}

	@Override
	protected void onNegativeButtonClick() {
		super.onNegativeButtonClick();
	}

	
}
",True,18,49,0,0,3,36,2,4,L0
47,org.coolreader.crengine.ReaderView.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.Engine.HyphDict;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.text.ClipboardManager;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

public class ReaderView extends SurfaceView implements android.view.SurfaceHolder.Callback, Settings {

	public static final Logger log = L.create(""rv"");

	private DocView doc;
	
    // additional key codes for Nook
    public static final int NOOK_KEY_PREV_LEFT = 96;
    public static final int NOOK_KEY_PREV_RIGHT = 98;
    public static final int NOOK_KEY_NEXT_RIGHT = 97;    
    public static final int NOOK_KEY_SHIFT_UP = 101;
    public static final int NOOK_KEY_SHIFT_DOWN = 100;

    // nook 1 & 2
    public static final int NOOK_12_KEY_NEXT_LEFT = 95;
   
    // Nook touch buttons
    public static final int KEYCODE_PAGE_BOTTOMLEFT = 0x5d; // fwd = 93 (
    //    public static final int KEYCODE_PAGE_BOTTOMRIGHT = 158; // 0x5f; // fwd = 95
    public static final int KEYCODE_PAGE_TOPLEFT = 0x5c; // back = 92
    public static final int KEYCODE_PAGE_TOPRIGHT = 0x5e; // back = 94
    
    public static final int SONY_DPAD_UP_SCANCODE = 105;
    public static final int SONY_DPAD_DOWN_SCANCODE = 106;
    
    
    public static final int PAGE_ANIMATION_NONE = 0;
    public static final int PAGE_ANIMATION_PAPER = 1;
    public static final int PAGE_ANIMATION_SLIDE = 2;
    public static final int PAGE_ANIMATION_SLIDE2 = 3;
    public static final int PAGE_ANIMATION_MAX = 3;
    
    public static final int SEL_CMD_SELECT_FIRST_SENTENCE_ON_PAGE = 1;
    public static final int SEL_CMD_NEXT_SENTENCE = 2;
    public static final int SEL_CMD_PREV_SENTENCE = 3;
    
    
    public enum ViewMode
    {
    	PAGES,
    	SCROLL
    }
    
    private ViewMode viewMode = ViewMode.PAGES;
    
    public enum ReaderCommand
    {
    	DCMD_NONE(0),
    	DCMD_REPEAT(1), // repeat last action
    	
    	//definitions from crengine/include/lvdocview.h
    	DCMD_BEGIN(100),
    	DCMD_LINEUP(101),
    	DCMD_PAGEUP(102),
    	DCMD_PAGEDOWN(103),
    	DCMD_LINEDOWN(104),
    	DCMD_LINK_FORWARD(105),
    	DCMD_LINK_BACK(106),
    	DCMD_LINK_NEXT(107),
    	DCMD_LINK_PREV(108),
    	DCMD_LINK_GO(109),
    	DCMD_END(110),
    	DCMD_GO_POS(111),
    	DCMD_GO_PAGE(112),
    	DCMD_ZOOM_IN(113),
    	DCMD_ZOOM_OUT(114),
    	DCMD_TOGGLE_TEXT_FORMAT(115),
    	DCMD_BOOKMARK_SAVE_N(116),
    	DCMD_BOOKMARK_GO_N(117),
    	DCMD_MOVE_BY_CHAPTER(118),
    	DCMD_GO_SCROLL_POS(119),
    	DCMD_TOGGLE_PAGE_SCROLL_VIEW(120),
    	DCMD_LINK_FIRST(121),
    	DCMD_ROTATE_BY(122),
    	DCMD_ROTATE_SET(123),
    	DCMD_SAVE_HISTORY(124),
    	DCMD_SAVE_TO_CACHE(125),
    	DCMD_TOGGLE_BOLD(126),
    	DCMD_SCROLL_BY(127),
    	DCMD_REQUEST_RENDER(128),
    	DCMD_GO_PAGE_DONT_SAVE_HISTORY(129),
    	DCMD_SET_INTERNAL_STYLES(130),
    	
        DCMD_SELECT_FIRST_SENTENCE(131), // select first sentence on page
        DCMD_SELECT_NEXT_SENTENCE(132), // move selection to next sentence
        DCMD_SELECT_PREV_SENTENCE(133), // move selection to next sentence
        DCMD_SELECT_MOVE_LEFT_BOUND_BY_WORDS(134), // move selection start by words 
        DCMD_SELECT_MOVE_RIGHT_BOUND_BY_WORDS(135), // move selection end by words 
    	
    	// definitions from android/jni/readerview.h
    	DCMD_OPEN_RECENT_BOOK(2000),
    	DCMD_CLOSE_BOOK(2001),
    	DCMD_RESTORE_POSITION(2002),

    	// application actions
    	DCMD_RECENT_BOOKS_LIST(2003),
    	DCMD_SEARCH(2004),
    	DCMD_EXIT(2005),
    	DCMD_BOOKMARKS(2005),
    	DCMD_GO_PERCENT_DIALOG(2006),
    	DCMD_GO_PAGE_DIALOG(2007),
    	DCMD_TOC_DIALOG(2008),
    	DCMD_FILE_BROWSER(2009),
    	DCMD_OPTIONS_DIALOG(2010),
    	DCMD_TOGGLE_DAY_NIGHT_MODE(2011),
    	DCMD_READER_MENU(2012),
    	DCMD_TOGGLE_TOUCH_SCREEN_LOCK(2013),
    	DCMD_TOGGLE_SELECTION_MODE(2014),
    	DCMD_TOGGLE_ORIENTATION(2015),
    	DCMD_TOGGLE_FULLSCREEN(2016),
    	DCMD_SHOW_HOME_SCREEN(2017), // home screen activity
    	DCMD_TOGGLE_DOCUMENT_STYLES(2018),
    	DCMD_ABOUT(2019),
    	DCMD_BOOK_INFO(2020),
    	DCMD_TTS_PLAY(2021),
    	DCMD_TOGGLE_TITLEBAR(2022),
    	DCMD_SHOW_POSITION_INFO_POPUP(2023),
    	DCMD_SHOW_DICTIONARY(2024),
    	DCMD_OPEN_PREVIOUS_BOOK(2025),
    	DCMD_TOGGLE_AUTOSCROLL(2026),
    	DCMD_AUTOSCROLL_SPEED_INCREASE(2027),
    	DCMD_AUTOSCROLL_SPEED_DECREASE(2028),
    	DCMD_START_SELECTION(2029),
    	DCMD_SWITCH_PROFILE(2030),
    	;
    	
    	private final int nativeId;
    	private ReaderCommand( int nativeId )
    	{
    		this.nativeId = nativeId;
    	}
    }
    
    private void execute( Engine.EngineTask task )
    {
    	mEngine.execute(task);
    }
    
    private void post( Engine.EngineTask task )
    {
    	mEngine.post(task);
    }
    
    private abstract class Task implements Engine.EngineTask {
    	
		public void done() {
			// override to do something useful
		}

		public void fail(Exception e) {
			// do nothing, just log exception
			// override to do custom action
			log.e(""Task "" + this.getClass().getSimpleName() + "" is failed with exception "" + e.getMessage(), e);
		}
    }
    
	static class Sync<T> extends Object {
		private volatile T result = null;
		private volatile boolean completed = false;
		public void set( T res )
		{
			log.d(""sync.set() called from "" + Thread.currentThread().getName());
			result = res;
			completed = true;
			synchronized(this) {
				notify();
			}
			log.d(""sync.set() returned from notify "" + Thread.currentThread().getName());
		}
		public T get()
		{
			log.d(""sync.get() called from "" + Thread.currentThread().getName());
			while ( !completed ) {
    			try {
    				log.d(""sync.get() before wait "" + Thread.currentThread().getName());
    				synchronized(this) {
    					if ( !completed )
    						wait();
    				}
    				log.d(""sync.get() after wait wait "" + Thread.currentThread().getName());
    			} catch (InterruptedException e) {
    				log.d(""sync.get() exception"", e);
    				// ignore
    			} catch (Exception e) {
    				log.d(""sync.get() exception"", e);
    				// ignore
    			}
			}
			log.d(""sync.get() returning "" + Thread.currentThread().getName());
			return result;
		}
	}

    private <T> T executeSync( final Callable<T> task )
    {
    	//log.d(""executeSync called"");
    	
    	
    	final Sync<T> sync = new Sync<T>();
    	post( new Runnable() {
    		public void run() {
    			log.d(""executeSync "" + Thread.currentThread().getName());
    			try {
    				sync.set( task.call() );
    			} catch ( Exception e ) {
    			}
    		}
    	});
    	T res = sync.get();
    	//log.d(""executeSync done"");
    	return res;
    }
    
	private final CoolReader mActivity;
    private final Engine mEngine;
    private final BackgroundThread mBackThread;
    
    private BookInfo mBookInfo;
    
    private Properties mSettings = new Properties();

    public Engine getEngine()
    {
    	return mEngine;
    }
    
    public CoolReader getActivity()
    {
    	return mActivity;
    }
    
	private int lastResizeTaskId = 0;
	@Override
	protected void onSizeChanged(final int w, final int h, int oldw, int oldh) {
		log.i(""onSizeChanged(""+w + "", "" + h +"")"");
		super.onSizeChanged(w, h, oldw, oldh);
		final int thisId = ++lastResizeTaskId;
	    if ( w<h && mActivity.isLandscape() ) {
	    	log.i(""ignoring size change to portrait since landscape is set"");
	    	return;
	    }
//		if ( mActivity.isPaused() ) {
//			log.i(""ignoring size change since activity is paused"");
//			return;
//		}
		// update size with delay: chance to avoid extra unnecessary resizing
		
	    Runnable task = new Runnable() {
	    	public void run() {
	    		if ( thisId != lastResizeTaskId ) {
					log.d(""skipping duplicate resize request in GUI thread"");
	    			return;
	    		}
	    		mActivity.getHistory().updateCoverPageSize(w, h);
	    		post(new Task() {
	    			public void work() {
	    				BackgroundThread.ensureBackground();
	    				if ( thisId != lastResizeTaskId ) {
	    					log.d(""skipping duplicate resize request"");
	    					return;
	    				}
	    		        internalDX = w;
	    		        internalDY = h;
	    				log.d(""ResizeTask: resizeInternal(""+w+"",""+h+"")"");
	    		        doc.resize(w, h);
//	    		        if ( mOpened ) {
//	    					log.d(""ResizeTask: done, drawing page"");
//	    			        drawPage();
//	    		        }
	    			}
	    			public void done() {
	    				clearImageCache();
	    				invalidate();
	    			}
	    		});
	    	}
	    };
	    if ( mOpened ) {
	    	log.d(""scheduling delayed resize task id=""+thisId);
	    	BackgroundThread.instance().postGUI( task, 1500);
	    } else {
	    	log.d(""executing resize without delay"");
	    	task.run();
	    }
	    
	}
	
	public boolean isBookLoaded()
	{
		BackgroundThread.ensureGUI();
		return mOpened;
	}
	
	public int getOrientation()
	{
		int angle = mSettings.getInt(PROP_APP_SCREEN_ORIENTATION, 0);
		if ( angle==4 )
			angle = mActivity.getOrientationFromSensor();
		return angle;
	}

	private int overrideKey( int keyCode )
	{
		return keyCode;
	}
	
	public int getTapZone( int x, int y, int dx, int dy )
	{
		int x1 = dx / 3;
		int x2 = dx * 2 / 3;
		int y1 = dy / 3;
		int y2 = dy * 2 / 3;
		int zone = 0;
		if ( y<y1 ) {
			if ( x<x1 )
				zone = 1;
			else if ( x<x2 )
				zone = 2;
			else
				zone = 3;
		} else if ( y<y2 ) {
			if ( x<x1 )
				zone = 4;
			else if ( x<x2 )
				zone = 5;
			else
				zone = 6;
		} else {
			if ( x<x1 )
				zone = 7;
			else if ( x<x2 )
				zone = 8;
			else
				zone = 9;
		}
		return zone;
	}
	
	public ReaderAction findTapZoneAction(int zone, int tapActionType) {
		ReaderAction action = ReaderAction.NONE;
		boolean isSecondaryAction = (secondaryTapActionType == tapActionType);
		if (tapActionType == TAP_ACTION_TYPE_SHORT) {
			action = ReaderAction.findForTap(zone, mSettings);
		} else {
			if (isSecondaryAction)
				action = ReaderAction.findForLongTap(zone, mSettings);
			else if (doubleTapSelectionEnabled || tapActionType == TAP_ACTION_TYPE_LONGPRESS)
				action = ReaderAction.START_SELECTION;
		}
		return action;
	}
	
	public FileInfo getOpenedFileInfo()
	{
		if ( isBookLoaded() && mBookInfo!=null )
			return mBookInfo.getFileInfo();
		return null;
	}
	
	public final int LONG_KEYPRESS_TIME = 900;
	public final int AUTOREPEAT_KEYPRESS_TIME = 700;
	public final int DOUBLE_CLICK_INTERVAL = 400;
	private ReaderAction currentDoubleClickAction = null;
	private ReaderAction currentSingleClickAction = null;
	private long currentDoubleClickActionStart = 0;
	private int currentDoubleClickActionKeyCode = 0;
	@Override
	public boolean onKeyUp(int keyCode, final KeyEvent event) {
		if (currentImageViewer != null)
			return currentImageViewer.onKeyUp(keyCode, event);
		if (keyCode == 0)
			keyCode = event.getScanCode();
		if ( keyCode==KeyEvent.KEYCODE_VOLUME_DOWN || keyCode==KeyEvent.KEYCODE_VOLUME_UP ) {
    		if (isAutoScrollActive())
    			return true;
			if ( !enableVolumeKeys )
				return super.onKeyUp(keyCode, event);
		}
		if (isAutoScrollActive()) {
			stopAutoScroll();
			return true;
		}
		if ( keyCode==KeyEvent.KEYCODE_POWER || keyCode==KeyEvent.KEYCODE_ENDCALL ) {
			mActivity.releaseBacklightControl();
			return false;
		}
		boolean tracked = isTracked(event);
//		if ( keyCode!=KeyEvent.KEYCODE_BACK )
//			backKeyDownHere = false;
		mActivity.onUserActivity();

		if ( keyCode==KeyEvent.KEYCODE_BACK && !tracked )
			return true;
		//backKeyDownHere = false;
		
		// apply orientation
		keyCode = overrideKey( keyCode );
		boolean isLongPress = false;
		Long keyDownTs = keyDownTimestampMap.get(keyCode);
		if ( keyDownTs!=null && System.currentTimeMillis()-keyDownTs>=LONG_KEYPRESS_TIME )
			isLongPress = true;
		ReaderAction action = ReaderAction.findForKey( keyCode, mSettings );
		ReaderAction longAction = ReaderAction.findForLongKey( keyCode, mSettings );
		ReaderAction dblAction = ReaderAction.findForDoubleKey( keyCode, mSettings );
		stopTracking();

		if ( keyCode>=KeyEvent.KEYCODE_0 && keyCode<=KeyEvent.KEYCODE_9 && tracked ) {
			// goto/set shortcut bookmark
			int shortcut = keyCode - KeyEvent.KEYCODE_0;
			if ( shortcut==0 )
				shortcut = 10;
			if ( isLongPress )
				addBookmark(shortcut);
			else
				goToBookmark(shortcut);
			return true;
		}
		if ( action.isNone() || !tracked ) {
			return super.onKeyUp(keyCode, event);
		}
		if ( !action.isNone() && action.canRepeat() && longAction.isRepeat() ) {
			// already processed by onKeyDown()
			return true;
		}
		
		if ( isLongPress ) {
			action = longAction;
		} else {
			if ( !dblAction.isNone() ) {
				// wait for possible double click
				currentDoubleClickActionStart = android.os.SystemClock.uptimeMillis();
				currentDoubleClickAction = dblAction;
				currentSingleClickAction = action;
				currentDoubleClickActionKeyCode = keyCode;
				final int myKeyCode = keyCode;
				BackgroundThread.instance().postGUI(new Runnable() {
					public void run() {
						if ( currentSingleClickAction!=null && currentDoubleClickActionKeyCode==myKeyCode ) {
							log.d(""onKeyUp: single click action "" + currentSingleClickAction.id + "" found for key "" + myKeyCode + "" single click"");
							onAction( currentSingleClickAction );
						}
						currentDoubleClickActionStart = 0;
						currentDoubleClickActionKeyCode = 0;
						currentDoubleClickAction = null;
						currentSingleClickAction = null;
					}
				}, DOUBLE_CLICK_INTERVAL);
				// posted
				return true;
			}
		}
		if ( !action.isNone() ) {
			log.d(""onKeyUp: action "" + action.id + "" found for key "" + keyCode + (isLongPress?"" (long)"" : """") );
			onAction( action );
			return true;
		}
		

		// not processed
		return super.onKeyUp(keyCode, event);
	}

//	boolean VOLUME_KEYS_ZOOM = false;
	
	//private boolean backKeyDownHere = false;
	
	@Override
	protected void onFocusChanged(boolean gainFocus, int direction,
			Rect previouslyFocusedRect) {
		stopTracking();
		if (currentAutoScrollAnimation != null)
			stopAutoScroll();
		super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
	}
	
	private boolean startTrackingKey( KeyEvent event ) {
		if ( event.getRepeatCount()==0 ) {
			stopTracking();
			trackedKeyEvent = event;
			return true;
		}
		return false;
	}
	
	private void stopTracking() {
		trackedKeyEvent = null;
		actionToRepeat = null;
		repeatActionActive = false;
		if (currentTapHandler != null)
			currentTapHandler.cancel();
	}

	private boolean isTracked( KeyEvent event ) {
        if ( trackedKeyEvent!=null) {
            int tkeKc = trackedKeyEvent.getKeyCode();
            int eKc = event.getKeyCode();
            // check if tracked key and current key are the same
            if (tkeKc == eKc) {
                long tkeDt = trackedKeyEvent.getDownTime();
                long eDt = event.getDownTime();
                // empirical value (could be changed or moved to constant)
                long delta = 300l;
                // time difference between tracked and current event
                long diff = eDt - tkeDt;
                // needed for correct function on HTC Desire for CENTER_KEY
                if (delta > diff)
                    return true;
            }
            else {
                log.v(""isTracked( trackedKeyEvent="" + trackedKeyEvent + "", event="" + event + "" )"");
            }
        }
		stopTracking();
		return false;
	}

	@Override
	public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) {
		log.v(""onKeyMultiple( keyCode="" + keyCode + "", repeatCount="" + repeatCount + "", event="" + event);
		return super.onKeyMultiple(keyCode, repeatCount, event);
	}


	private KeyEvent trackedKeyEvent = null; 
	private ReaderAction actionToRepeat = null;
	private boolean repeatActionActive = false;
	private Map<Integer, Long> keyDownTimestampMap = new HashMap<Integer, Long>();
	
	@Override
	public boolean onKeyDown(int keyCode, final KeyEvent event) {
		
		if (currentImageViewer != null)
			return currentImageViewer.onKeyDown(keyCode, event);

		if (keyCode == 0)
			keyCode = event.getScanCode();
//		backKeyDownHere = false;
		if ( event.getRepeatCount()==0 ) {
			log.v(""onKeyDown(""+keyCode + "", "" + event +"")"");
			keyDownTimestampMap.put(keyCode, System.currentTimeMillis());
		}
		if ( keyCode==KeyEvent.KEYCODE_POWER || keyCode==KeyEvent.KEYCODE_ENDCALL ) {
			mActivity.releaseBacklightControl();
			boolean res = super.onKeyDown(keyCode, event);
			mActivity.onUserActivity();
			return res;
		}

    	if ( keyCode==KeyEvent.KEYCODE_VOLUME_UP || keyCode==KeyEvent.KEYCODE_VOLUME_DOWN ) {
    		if (isAutoScrollActive()) {
    			if (keyCode==KeyEvent.KEYCODE_VOLUME_UP)
    				changeAutoScrollSpeed(1);
    			else
    				changeAutoScrollSpeed(-1);
    			return true;
    		}
    		if (!enableVolumeKeys) {
    			boolean res = super.onKeyDown(keyCode, event);
    			mActivity.onUserActivity();
    			return res;
    		}
    	}
    	
		if (isAutoScrollActive())
			return true; // autoscroll will be stopped in onKeyUp
    	
		mActivity.onUserActivity();
		keyCode = overrideKey( keyCode );
		ReaderAction action = ReaderAction.findForKey( keyCode, mSettings );
		ReaderAction longAction = ReaderAction.findForLongKey( keyCode, mSettings );
		//ReaderAction dblAction = ReaderAction.findForDoubleKey( keyCode, mSettings );

		if ( event.getRepeatCount()==0 ) {
			if ( keyCode==currentDoubleClickActionKeyCode && currentDoubleClickActionStart + DOUBLE_CLICK_INTERVAL > android.os.SystemClock.uptimeMillis() ) {
				if ( currentDoubleClickAction!=null ) {
					log.d(""executing doubleclick action "" + currentDoubleClickAction);
					onAction(currentDoubleClickAction);
				}
				currentDoubleClickActionStart = 0;
				currentDoubleClickActionKeyCode = 0;
				currentDoubleClickAction = null;
				currentSingleClickAction = null;
				return true;
			} else {
				if ( currentSingleClickAction!=null ) {
					onAction(currentSingleClickAction);
				}
				currentDoubleClickActionStart = 0;
				currentDoubleClickActionKeyCode = 0;
				currentDoubleClickAction = null;
				currentSingleClickAction = null;
			}
			
		}
		
		
    	if ( event.getRepeatCount()>0 ) {
    		if ( !isTracked(event) )
    			return true; // ignore
    		// repeating key down
    		boolean isLongPress = (event.getEventTime()-event.getDownTime())>=AUTOREPEAT_KEYPRESS_TIME;
    		if ( isLongPress ) {
	    		if ( actionToRepeat!=null ) {
	    			if ( !repeatActionActive ) {
		    			log.v(""autorepeating action : "" + actionToRepeat );
		    			repeatActionActive = true;
		    			onAction(actionToRepeat, new Runnable() {
		    				public void run() {
		    					if ( trackedKeyEvent!=null && trackedKeyEvent.getDownTime()==event.getDownTime() ) {
		    						log.v(""action is completed : "" + actionToRepeat );
		    						repeatActionActive = false;
		    					}
		    				}
		    			});
	    			}
	    		} else {
	    			stopTracking();
	    			log.v(""executing action on long press : "" + longAction );
	    			onAction(longAction);
	    		}
    		}
    		return true;
    	}
		
		if ( !action.isNone() && action.canRepeat() && longAction.isRepeat() ) {
			// start tracking repeat
			startTrackingKey(event);
			actionToRepeat = action;
			log.v(""running action with scheduled autorepeat : "" + actionToRepeat );
			repeatActionActive = true;
			onAction(actionToRepeat, new Runnable() {
				public void run() {
					if ( trackedKeyEvent==event ) {
						log.v(""action is completed : "" + actionToRepeat );
						repeatActionActive = false;
					}
				}
			});
			return true;
		} else {
			actionToRepeat = null;
		}
		
		if ( keyCode>=KeyEvent.KEYCODE_0 && keyCode<=KeyEvent.KEYCODE_9 ) {
			// will process in keyup handler
			startTrackingKey(event);
			return true;
		}
		if ( action.isNone() && longAction.isNone() )
			return super.onKeyDown(keyCode, event);
		startTrackingKey(event);
		return true;
	}
	
	private int nextUpdateId = 0;
	private void updateSelection(int startX, int startY, int endX, int endY, final boolean isUpdateEnd ) {
		final Selection sel = new Selection();
		final int myId = ++nextUpdateId;
		sel.startX = startX;
		sel.startY = startY;
		sel.endX = endX;
		sel.endY = endY;
		mEngine.execute(new Task() {
			@Override
			public void work() throws Exception {
				if ( myId != nextUpdateId && !isUpdateEnd )
					return;
				doc.updateSelection(sel);
				if ( !sel.isEmpty() ) {
					invalidImages = true;
					BitmapInfo bi = preparePageImage(0);
					if ( bi!=null ) {
						draw(true);
					}
				}
			}

			@Override
			public void done() {
				if ( isUpdateEnd ) {
					String text = sel.text;
					if ( text!=null && text.length()>0 ) {
						onSelectionComplete( sel );
					} else {
						clearSelection();
					}
				}
			}
		});
	}

	private int mSelectionAction = SELECTION_ACTION_TOOLBAR;
	private void onSelectionComplete( Selection sel ) {
		switch ( mSelectionAction ) {
		case SELECTION_ACTION_TOOLBAR:
			SelectionToolbarDlg.showDialog(mActivity, ReaderView.this, sel);
			break;
		case SELECTION_ACTION_COPY:
			copyToClipboard(sel.text);
			clearSelection();
			break;
		case SELECTION_ACTION_DICTIONARY:
			mActivity.findInDictionary( sel.text );
			if (!getSettings().getBool(PROP_APP_SELECTION_PERSIST, false))
				clearSelection();
			break;
		case SELECTION_ACTION_BOOKMARK:
			clearSelection();
			showNewBookmarkDialog( sel );
			break;
		default:
			clearSelection();
			break;
		}
		
	}
	
	public void showNewBookmarkDialog( Selection sel ) {
		if ( mBookInfo==null )
			return;
		Bookmark bmk = new Bookmark();
		bmk.setType(Bookmark.TYPE_COMMENT);
		bmk.setPosText(sel.text);
		bmk.setStartPos(sel.startPos);
		bmk.setEndPos(sel.endPos);
		bmk.setPercent(sel.percent);
		bmk.setTitleText(sel.chapter);
		BookmarkEditDialog dlg = new BookmarkEditDialog(mActivity, this, bmk, true);
		dlg.show();
	}
	
	public void sendQuotationInEmail( Selection sel ) {
        StringBuilder buf = new StringBuilder();
        if (mBookInfo.getFileInfo().authors!=null)
        	buf.append(""|"" + mBookInfo.getFileInfo().authors + ""\n"");
        if (mBookInfo.getFileInfo().title!=null)
        	buf.append(""|"" + mBookInfo.getFileInfo().title + ""\n"");
        if (sel.chapter!=null && sel.chapter.length()>0)
        	buf.append(""|"" + sel.chapter + ""\n"");
    	buf.append(sel.text + ""\n"");
    	mActivity.sendBookFragment(mBookInfo, buf.toString());
	}
	
	public void copyToClipboard( String text ) {
		if ( text!=null && text.length()>0 ) {
			ClipboardManager cm = mActivity.getClipboardmanager();
			cm.setText(text);
			log.i(""Setting clipboard text: "" + text);
			mActivity.showToast(""Selection text copied to clipboard"");
		}
	}
	
//	private void cancelSelection() {
//		//
//		selectionInProgress = false;
//		clearSelection();
//	}

	private int isBacklightControlFlick = 1;
	private boolean isTouchScreenEnabled = true;
//	private boolean isManualScrollActive = false;
//	private boolean isBrightnessControlActive = false;
//	private int manualScrollStartPosX = -1;
//	private int manualScrollStartPosY = -1;
//	volatile private boolean touchEventIgnoreNextUp = false;
//	volatile private int longTouchId = 0;
//	volatile private long currentDoubleTapActionStart = 0;
//	private boolean selectionInProgress = false;
//	private int selectionStartX = 0;
//	private int selectionStartY = 0;
//	private int selectionEndX = 0;
//	private int selectionEndY = 0;
	private boolean doubleTapSelectionEnabled = false;
	private int secondaryTapActionType = TAP_ACTION_TYPE_LONGPRESS;
	private boolean selectionModeActive = false;
	
	public void toggleSelectionMode() {
		selectionModeActive = !selectionModeActive;
		mActivity.showToast( selectionModeActive ? R.string.action_toggle_selection_mode_on : R.string.action_toggle_selection_mode_off);
	}

	private ImageViewer currentImageViewer;
	private class ImageViewer extends SimpleOnGestureListener {
		private ImageInfo currentImage;
		final GestureDetector detector;
		int oldOrientation;
		public ImageViewer(ImageInfo image) {
			lockOrientation();
			detector = new GestureDetector(this);
			if (image.bufHeight / image.height >= 2 && image.bufWidth / image.width >= 2) {
				image.scaledHeight *= 2;
				image.scaledWidth *= 2;
			}
			centerIfLessThanScreen(image);
			currentImage = image;
		}
		
		private void lockOrientation() {
			oldOrientation = mActivity.getScreenOrientation();
			if (oldOrientation == 4)
				mActivity.setScreenOrientation(mActivity.getOrientationFromSensor());
		}

		private void unlockOrientation() {
			if (oldOrientation == 4)
				mActivity.setScreenOrientation(oldOrientation);
		}

		private void centerIfLessThanScreen(ImageInfo image) {
			if (image.scaledHeight < image.bufHeight)
				image.y = (image.bufHeight - image.scaledHeight) / 2;
			if (image.scaledWidth < image.bufWidth)
				image.x = (image.bufWidth - image.scaledWidth) / 2;
		}
		
		private void fixScreenBounds(ImageInfo image) {
			if (image.scaledHeight > image.bufHeight) {
				if (image.y < image.bufHeight - image.scaledHeight)
					image.y = image.bufHeight - image.scaledHeight;
				if (image.y > 0)
					image.y = 0;
			}
			if (image.scaledWidth > image.bufWidth) {
				if (image.x < image.bufWidth - image.scaledWidth)
					image.x = image.bufWidth - image.scaledWidth;
				if (image.x > 0)
					image.x = 0;
			}
		}
		
		private void updateImage(ImageInfo image) {
			centerIfLessThanScreen(image);
			fixScreenBounds(image);
			if (!currentImage.equals(image)) {
				currentImage = image;
				drawPage();
			}
		}
		
		public void zoomIn() {
			ImageInfo image = new ImageInfo(currentImage);
			if (image.scaledHeight >= image.height) {
				int scale = image.scaledHeight / image.height;
				if (scale < 4)
					scale++;
				image.scaledHeight = image.height * scale;
				image.scaledWidth = image.width * scale;
			} else {
				int scale = image.height / image.scaledHeight;
				if (scale > 1)
					scale--;
				image.scaledHeight = image.height / scale;
				image.scaledWidth = image.width / scale;
			}
			updateImage(image);
		}
		
		public void zoomOut() {
			ImageInfo image = new ImageInfo(currentImage);
			if (image.scaledHeight > image.height) {
				int scale = image.scaledHeight / image.height;
				if (scale > 1)
					scale--;
				image.scaledHeight = image.height * scale;
				image.scaledWidth = image.width * scale;
			} else {
				int scale = image.height / image.scaledHeight;
				if (image.scaledHeight > image.bufHeight || image.scaledWidth > image.bufWidth)
					scale++;
				image.scaledHeight = image.height / scale;
				image.scaledWidth = image.width / scale;
			}
			updateImage(image);
		}
		
		public int getStep() {
			ImageInfo image = currentImage;
			int max = image.bufHeight;
			if (max < image.bufWidth)
				max = image.bufWidth;
			return max / 10;
		}
		
		public void moveBy(int dx, int dy) {
			ImageInfo image = new ImageInfo(currentImage);
			image.x += dx;
			image.y += dy;
			updateImage(image);
		}
		
		public boolean onKeyDown(int keyCode, final KeyEvent event) {
			if (keyCode == 0)
				keyCode = event.getScanCode();
			switch (keyCode) {
			case KeyEvent.KEYCODE_VOLUME_UP:
				zoomIn();
				return true;
			case KeyEvent.KEYCODE_VOLUME_DOWN:
				zoomOut();
				return true;
			case KeyEvent.KEYCODE_DPAD_CENTER:
			case KeyEvent.KEYCODE_BACK:
			case KeyEvent.KEYCODE_ENDCALL:
				close();
				return true;
			case KeyEvent.KEYCODE_DPAD_LEFT:
				moveBy(getStep(), 0);
				return true;
			case KeyEvent.KEYCODE_DPAD_RIGHT:
				moveBy(-getStep(), 0);
				return true;
			case KeyEvent.KEYCODE_DPAD_UP:
				moveBy(0, getStep());
				return true;
			case KeyEvent.KEYCODE_DPAD_DOWN:
				moveBy(0, -getStep());
				return true;
			}
			return false;
		}

		public boolean onKeyUp(int keyCode, final KeyEvent event) {
			if (keyCode == 0)
				keyCode = event.getScanCode();
			switch (keyCode) {
			case KeyEvent.KEYCODE_BACK:
			case KeyEvent.KEYCODE_ENDCALL:
				close();
				return true;
			}
			return false;
		}

		public boolean onTouchEvent(MotionEvent event) {
//			int aindex = event.getActionIndex();
//			if (event.getAction() == MotionEvent.ACTION_POINTER_DOWN) {
//				log.v(""ACTION_POINTER_DOWN"");
//			}
			return detector.onTouchEvent(event);
		}
		
		
		
		@Override
		public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,
				float velocityY) {
			log.v(""onFling()"");
			return true;
		}

		@Override
		public boolean onScroll(MotionEvent e1, MotionEvent e2,
				float distanceX, float distanceY) {
			log.v(""onScroll() "" + distanceX + "", "" + distanceY);
			int dx = (int)distanceX;
			int dy = (int)distanceY;
			moveBy(-dx, -dy);
			return true;
		}

		@Override
		public boolean onSingleTapConfirmed(MotionEvent e) {
			log.v(""onSingleTapConfirmed()"");
			ImageInfo image = new ImageInfo(currentImage);
			
			int x = (int)e.getX();
			int y = (int)e.getY();

			int zone = 0;
			int zw = mActivity.getDensityDpi() / 2;
			int w = image.bufWidth;
			int h = image.bufHeight;
			if (image.rotation == 0) {
				if (x < zw && y > h - zw)
					zone = 1;
				if (x > w - zw && y > h - zw)
					zone = 2;
			} else {
				if (x < zw && y < zw)
					zone = 1;
				if (x < zw && y > h - zw)
					zone = 2;
			}
			if (zone != 0) {
				if (zone == 1)
					zoomIn();
				else
					zoomOut();
				return true;
			}
			
			close();
			return super.onSingleTapConfirmed(e);
		}
		
		@Override
		public boolean onDown(MotionEvent e) {
			return true;
		}

		public void close() {
			if (currentImageViewer == null)
				return;
			currentImageViewer = null;
			unlockOrientation();
			BackgroundThread.instance().executeBackground(new Runnable() {
				@Override
				public void run() {
					doc.closeImage();
				}
			});
			drawPage();
		}
		
		public BitmapInfo prepareImage() {
			// called from background thread
			ImageInfo img = currentImage;
			img.bufWidth = internalDX;
			img.bufHeight = internalDY;
			if (mCurrentPageInfo != null) {
				if (img.equals(mCurrentPageInfo.imageInfo))
					return mCurrentPageInfo;
				mCurrentPageInfo.recycle();
				mCurrentPageInfo = null;
			}
			PositionProperties currpos = doc.getPositionProps(null);
			BitmapInfo bi = new BitmapInfo();
	        bi.imageInfo = new ImageInfo(img);
			bi.bitmap = factory.get(internalDX, internalDY);
			bi.position = currpos;
			doc.drawImage(bi.bitmap, bi.imageInfo);
	        mCurrentPageInfo = bi;
	        return mCurrentPageInfo;
		}
		
	}

	private void startImageViewer(ImageInfo image) {
		currentImageViewer = new ImageViewer(image);
		drawPage();
	}

	private boolean isImageViewMode() {
		return currentImageViewer != null;
	}

	private void stopImageViewer() {
		if (currentImageViewer != null)
			currentImageViewer.close();
	}

	private TapHandler currentTapHandler = null;
	public class TapHandler {

		private final static int STATE_INITIAL = 0; // no events yet
		private final static int STATE_DOWN_1 = 1; // down first time
		private final static int STATE_SELECTION = 3; // selection is started
		private final static int STATE_FLIPPING = 4; // flipping is in progress
		private final static int STATE_WAIT_FOR_DOUBLE_CLICK = 5; // flipping is in progress
		private final static int STATE_DONE = 6; // done: no more tracking
		private final static int STATE_BRIGHTNESS = 7; // brightness change in progress
		
		private final static int EXPIRATION_TIME_MS = 180000;
		
		int state = STATE_INITIAL;
		
		int start_x = 0;
		int start_y = 0;
		int width = 0;
		int height = 0;
		ReaderAction shortTapAction = ReaderAction.NONE;
		ReaderAction longTapAction = ReaderAction.NONE;
		ReaderAction doubleTapAction = ReaderAction.NONE;
		long firstDown;
		
		/// handle unexpected event for state: stop tracking
		private boolean unexpectedEvent() {
			cancel();
			return true; // ignore
		}
		
		public boolean isInitialState() {
			return state == STATE_INITIAL;
		}
		public void checkExpiration() {
			if (state != STATE_INITIAL && Utils.timeInterval(firstDown) > EXPIRATION_TIME_MS)
				cancel();
		}
		
		/// cancel current action and reset touch tracking state
		private boolean cancel() {
			if (state == STATE_INITIAL)
				return true;
			switch (state) {
			case STATE_DOWN_1:
			case STATE_SELECTION:
				clearSelection();
				break;
			case STATE_FLIPPING:
				stopAnimation(-1, -1);
				break;
			case STATE_WAIT_FOR_DOUBLE_CLICK:
			case STATE_DONE:
			case STATE_BRIGHTNESS:
				stopBrightnessControl(-1, -1);
				break;
			}
			state = STATE_DONE;
			unhiliteTapZone(); 
			currentTapHandler = new TapHandler();
			return true;
		}

		/// perform action and reset touch tracking state
		private boolean performAction(final ReaderAction action, boolean checkForLinks) {
			log.d(""performAction on touch: "" + action);
			state = STATE_DONE;

			currentTapHandler = new TapHandler();

			if (!checkForLinks) {
				onAction(action);
				return true;
			}
			
			// check link before executing action
			mEngine.execute(new Task() {
				String link;
				ImageInfo image;
				Bookmark bookmark;
				public void work() {
					image = new ImageInfo();
					image.bufWidth = internalDX;
					image.bufHeight = internalDY;
					image.bufDpi = mActivity.getDensityDpi();
					if (doc.checkImage(start_x, start_y, image)) {
						return;
					}
					image = null;
					link = doc.checkLink(start_x, start_y, mActivity.getPalmTipPixels() / 2 );
					if ( link!=null ) {
						if ( link.startsWith(""#"") ) {
							log.d(""go to "" + link);
							doc.goLink(link);
							drawPage();
						}
						return;
					} 
					bookmark = doc.checkBookmark(start_x, start_y);
					if (bookmark != null && bookmark.getType() == Bookmark.TYPE_POSITION)
						bookmark = null;
				}
				public void done() {
					if (bookmark != null)
						bookmark = mBookInfo.findBookmark(bookmark);
					if (link == null && image == null && bookmark == null) {
						onAction(action);
					} else if (image != null) {
						startImageViewer(image);
					} else if (bookmark != null) {
						BookmarkEditDialog dlg = new BookmarkEditDialog(mActivity, ReaderView.this, bookmark, false);
						dlg.show();
					} else if (!link.startsWith(""#"")) {
						log.d(""external link "" + link);
						if (link.startsWith(""http://"")||link.startsWith(""https://"")) {
							mActivity.openURL(link);
						} else {
							// absolute path to file
							FileInfo fi = new FileInfo(link);
							if (fi.exists()) {
								mActivity.loadDocument(fi);
								return;
							}
							File baseDir = null;
							if (mBookInfo!=null && mBookInfo.getFileInfo()!=null) {
								if (!mBookInfo.getFileInfo().isArchive) {
									// relatively to base directory
									File f = new File(mBookInfo.getFileInfo().getBasePath());
									baseDir = f.getParentFile();
									String url = link;
									while (baseDir!=null && url!=null && url.startsWith(""../"")) {
										baseDir = baseDir.getParentFile();
										url = url.substring(3);
									}
									if (baseDir!=null && url!=null && url.length()>0) {
										fi = new FileInfo(baseDir.getAbsolutePath()+""/""+url);
										if (fi.exists()) {
											mActivity.loadDocument(fi);
											return;
										}
									}
								} else {
									// from archive
									fi = new FileInfo(mBookInfo.getFileInfo().getArchiveName() + FileInfo.ARC_SEPARATOR + link);
									if (fi.exists()) {
										mActivity.loadDocument(fi);
										return;
									}
								}
							}
							mActivity.showToast(""Cannot open link "" + link);
						}
					}
				}
			});
			return true;
		}
		
		private boolean startSelection() {
			state = STATE_SELECTION;
			// check link before executing action
			mEngine.execute(new Task() {
				ImageInfo image;
				Bookmark bookmark;
				public void work() {
					image = new ImageInfo();
					image.bufWidth = internalDX;
					image.bufHeight = internalDY;
					image.bufDpi = mActivity.getDensityDpi();
					if (!doc.checkImage(start_x, start_y, image))
						image = null;
					bookmark = doc.checkBookmark(start_x, start_y);
					if (bookmark != null && bookmark.getType() == Bookmark.TYPE_POSITION)
						bookmark = null;
				}
				public void done() {
					if (bookmark != null)
						bookmark = mBookInfo.findBookmark(bookmark);
					if (image != null) {
						cancel();
						startImageViewer(image);
					} else if (bookmark != null) {
						cancel();
						BookmarkEditDialog dlg = new BookmarkEditDialog(mActivity, ReaderView.this, bookmark, false);
						dlg.show();
					} else {
						updateSelection( start_x, start_y, start_x, start_y, false );
					}
				}
			});
			return true;
		}
		
		private boolean trackDoubleTap() {
			state = STATE_WAIT_FOR_DOUBLE_CLICK;
			BackgroundThread.instance().postGUI(new Runnable() {
				@Override
				public void run() {
					if (currentTapHandler == TapHandler.this && state == STATE_WAIT_FOR_DOUBLE_CLICK)
						performAction(shortTapAction, false);
				}
			}, DOUBLE_CLICK_INTERVAL);
			return true;
		}
		
		private boolean trackLongTap() {
			BackgroundThread.instance().postGUI(new Runnable() {
				@Override
				public void run() {
					if (currentTapHandler == TapHandler.this && state == STATE_DOWN_1) {
						if (longTapAction == ReaderAction.START_SELECTION)
							startSelection();
						else
							performAction(longTapAction, true);
					}
				}
			}, LONG_KEYPRESS_TIME);
			return true;
		}
		
		public boolean onTouchEvent(MotionEvent event) {
			int x = (int)event.getX();
			int y = (int)event.getY();
			

			if (state == STATE_INITIAL && event.getAction() != MotionEvent.ACTION_DOWN)
				return unexpectedEvent(); // ignore unexpected event
			
			if (event.getAction() == MotionEvent.ACTION_UP) {
				long duration = Utils.timeInterval(firstDown);
				switch (state) {
				case STATE_DOWN_1:
					if ( hiliteTapZoneOnTap ) {
						hiliteTapZone( true, x, y, width, height );
						scheduleUnhilite( LONG_KEYPRESS_TIME );
					}
					if (duration > LONG_KEYPRESS_TIME) {
						if (longTapAction == ReaderAction.START_SELECTION)
							return startSelection();
						return performAction(longTapAction, true);
					}
					if (doubleTapAction.isNone())
						return performAction(shortTapAction, false);
					// start possible double tap tracking
					return trackDoubleTap();
				case STATE_FLIPPING:
					stopAnimation(x, y);
					state = STATE_DONE;
					return cancel();
				case STATE_BRIGHTNESS:
					stopBrightnessControl(x, y);
					state = STATE_DONE;
					return cancel();
				case STATE_SELECTION:
					updateSelection( start_x, start_y, x, y, true );
					selectionModeActive = false;
					state = STATE_DONE;
					return cancel();
				}
			} else if (event.getAction() == MotionEvent.ACTION_DOWN) {
				switch (state) {
				case STATE_INITIAL:
					start_x = x;
					start_y = y;
					width = getWidth();
					height = getHeight();
					int zone = getTapZone(x, y, width, height);
					shortTapAction = findTapZoneAction(zone, TAP_ACTION_TYPE_SHORT);
					longTapAction = findTapZoneAction(zone, TAP_ACTION_TYPE_LONGPRESS);
					doubleTapAction = findTapZoneAction(zone, TAP_ACTION_TYPE_DOUBLE);
					firstDown = Utils.timeStamp();
					if (selectionModeActive) {
						startSelection();
					} else {
						state = STATE_DOWN_1;
						trackLongTap();
					}
					return true;
				case STATE_DOWN_1:
				case STATE_BRIGHTNESS:
				case STATE_FLIPPING:
				case STATE_SELECTION:
					return unexpectedEvent();
				case STATE_WAIT_FOR_DOUBLE_CLICK:
					if (doubleTapAction == ReaderAction.START_SELECTION)
						return startSelection();
					return performAction(doubleTapAction, true);
				}
			} else if (event.getAction() == MotionEvent.ACTION_MOVE) {
				int dx = x - start_x;
				int dy = y - start_y;
				int adx = dx > 0 ? dx : -dx;
				int ady = dy > 0 ? dy : -dy;
				int distance = adx + ady;
				int dragThreshold = mActivity.getPalmTipPixels();
				switch (state) {
				case STATE_DOWN_1:
					if (distance < dragThreshold)
						return true;
					if (!DeviceInfo.EINK_SCREEN && isBacklightControlFlick != BACKLIGHT_CONTROL_FLICK_NONE && ady > adx) {
						// backlight control enabled
						if (start_x < dragThreshold * 170 / 100 && isBacklightControlFlick == 1
								|| start_x > width - dragThreshold * 170 / 100 && isBacklightControlFlick == 2) {
							// brightness
							state = STATE_BRIGHTNESS;
							startBrightnessControl(start_x, start_y);
							return true;
						}
					}
					boolean isPageMode = mSettings.getInt(PROP_PAGE_VIEW_MODE, 1) == 1;
					int dir = isPageMode ? x - start_x : y - start_y;
					if (pageFlipAnimationSpeedMs == 0 || DeviceInfo.EINK_SCREEN) {
						// no animation
						return performAction(dir < 0 ? ReaderAction.PAGE_DOWN : ReaderAction.PAGE_UP, false);
					}
					startAnimation(start_x, start_y, width, height);
					updateAnimation(x, y);
					state = STATE_FLIPPING;
					return true;
				case STATE_FLIPPING:
					updateAnimation(x, y);
					return true;
				case STATE_BRIGHTNESS:
					updateBrightnessControl(x, y);
					return true;
				case STATE_WAIT_FOR_DOUBLE_CLICK:
					return true;
				case STATE_SELECTION:
					updateSelection( start_x, start_y, x, y, false );
					break;
				}
				
			} else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) {
				return unexpectedEvent();
			}
			return true;
		}
	}
	
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		
		if ( !isTouchScreenEnabled ) {
			return true;
		}
		mActivity.onUserActivity();
		
		if (currentImageViewer != null)
			return currentImageViewer.onTouchEvent(event);
		
		if (isAutoScrollActive()) {
			//if (currentTapHandler != null && currentTapHandler.isInitialState()) {
			if (event.getAction() == MotionEvent.ACTION_DOWN) {
				int x = (int)event.getX();
				int y = (int)event.getY();
				int z = getTapZone(x, y, getWidth(), getHeight());
				if (z == 7)
					changeAutoScrollSpeed(-1);
				else if (z == 9)
					changeAutoScrollSpeed(1);
				else
					stopAutoScroll();
			}
			return true;
		}
		
		if (currentTapHandler == null)
			currentTapHandler = new TapHandler();
		currentTapHandler.checkExpiration();
		return currentTapHandler.onTouchEvent(event);
	}

	@Override
	public boolean onTrackballEvent(MotionEvent event) {
		log.d(""onTrackballEvent("" + event + "")"");
		if ( mSettings.getBool(PROP_APP_TRACKBALL_DISABLED, false) ) {
			log.d(""trackball is disabled in settings"");
			return true;
		}
		mActivity.onUserActivity();
		return super.onTrackballEvent(event);
	}
	
	public void showTOC()
	{
		BackgroundThread.ensureGUI();
		final ReaderView view = this; 
		mEngine.post(new Task() {
			TOCItem toc;
			PositionProperties pos;
			public void work() {
				BackgroundThread.ensureBackground();
				toc = doc.getTOC();
				pos = doc.getPositionProps(null);
			}
			public void done() {
				BackgroundThread.ensureGUI();
				if ( toc!=null && pos!=null ) {
					TOCDlg dlg = new TOCDlg(mActivity, view, toc, pos.pageNumber);
					dlg.show();
				} else {
					mActivity.showToast(""No Table of Contents found"");
				}
			}
		});
	}
	
	public void showSearchDialog()
	{
		BackgroundThread.ensureGUI();
		SearchDlg dlg = new SearchDlg( mActivity, this );
		dlg.show();
	}

    public void findText( final String pattern, final boolean reverse, final boolean caseInsensitive )
    {
		BackgroundThread.ensureGUI();
		final ReaderView view = this; 
		mEngine.execute(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				boolean res = doc.findText( pattern, 1, reverse?1:0, caseInsensitive?1:0);
				if ( !res )
					res = doc.findText( pattern, -1, reverse?1:0, caseInsensitive?1:0);
				if ( !res ) {
					doc.clearSelection();
					throw new Exception(""pattern not found"");
				}
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
				FindNextDlg.showDialog( mActivity, view, pattern, caseInsensitive );
			}
			public void fail(Exception e) {
				BackgroundThread.ensureGUI();
				mActivity.showToast(""Pattern not found"");
			}
			
		});
    }
    
    public void findNext( final String pattern, final boolean reverse, final boolean caseInsensitive )
    {
		BackgroundThread.ensureGUI();
		mEngine.execute(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				boolean res = doc.findText( pattern, 1, reverse?1:0, caseInsensitive?1:0);
				if ( !res )
					res = doc.findText( pattern, -1, reverse?1:0, caseInsensitive?1:0);
				if ( !res ) {
					doc.clearSelection();
					throw new Exception(""pattern not found"");
				}
			}
			public void done() {
				BackgroundThread.ensureGUI();
//				drawPage();
				drawPage(true);
			}
		});
    }
    
    private boolean flgHighlightBookmarks = false;
    public void clearSelection()
    {
		BackgroundThread.ensureGUI();
    	if (mBookInfo == null || !isBookLoaded())
    		return;
		mEngine.post(new Task() {
			public void work() throws Exception {
				doc.clearSelection();
				invalidImages = true;
			}
			public void done() {
				if (isShown())
					drawPage(true);
			}
		});
    }
    
    public void highlightBookmarks() {
		BackgroundThread.ensureGUI();
    	if (mBookInfo == null || !isBookLoaded())
    		return;
    	int count = mBookInfo.getBookmarkCount();
    	final Bookmark[] list = (count > 0 && flgHighlightBookmarks) ? new Bookmark[count] : null; 
    	for (int i=0; i<count && flgHighlightBookmarks; i++)
    		list[i] = mBookInfo.getBookmark(i);
		mEngine.post(new Task() {
			public void work() throws Exception {
		    	doc.hilightBookmarks(list);
				invalidImages = true;
			}
			public void done() {
				if (isShown())
					drawPage(true);
			}
		});
    }

    public void goToBookmark( Bookmark bm )
	{
		BackgroundThread.ensureGUI();
		final String pos = bm.getStartPos();
		mEngine.execute(new Task() {
			public void work() {
				BackgroundThread.ensureBackground();
				doc.goToPosition(pos);
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
			}
		});
	}
	
	public boolean goToBookmark( final int shortcut )
	{
		BackgroundThread.ensureGUI();
		if ( mBookInfo!=null ) {
			Bookmark bm = mBookInfo.findShortcutBookmark(shortcut);
			if ( bm==null ) {
				addBookmark(shortcut);
				return true;
			} else {
				// go to bookmark
				goToBookmark( bm );
				return false;
			}
		}
		return false;
	}
	
	public Bookmark removeBookmark(final Bookmark bookmark) {
		Bookmark removed = mBookInfo.removeBookmark(bookmark);
		if (removed != null) {
			if ( removed.getId()!=null ) {
				mActivity.getDB().deleteBookmark(removed);
			}
			highlightBookmarks();
		}
		return removed;
	}

	public Bookmark updateBookmark(final Bookmark bookmark) {
		Bookmark bm = mBookInfo.updateBookmark(bookmark);
		if (bm != null) {
			if (mBookInfo.getFileInfo().id != null)
				mActivity.getDB().save(mBookInfo);
	        highlightBookmarks();
		}
		return bm;
	}
	
	public void addBookmark(final Bookmark bookmark) {
		mBookInfo.addBookmark(bookmark);
        highlightBookmarks();
	}
	
	public void addBookmark( final int shortcut )
	{
		BackgroundThread.ensureGUI();
		// set bookmark instead
		mEngine.execute(new Task() {
			Bookmark bm;
			public void work() {
				BackgroundThread.ensureBackground();
				if ( mBookInfo!=null ) {
					bm = doc.getCurrentPageBookmark();
					bm.setShortcut(shortcut);
				}
			}
			public void done() {
				if ( mBookInfo!=null && bm!=null ) {
					if ( shortcut==0 )
						mBookInfo.addBookmark(bm);
					else
						mBookInfo.setShortcutBookmark(shortcut, bm);
					mActivity.getDB().save(mBookInfo);
					String s;
					if ( shortcut==0 )
						s = mActivity.getString(R.string.toast_position_bookmark_is_set);
					else {
						s = mActivity.getString(R.string.toast_shortcut_bookmark_is_set);
						s.replace(""$1"", String.valueOf(shortcut));
					}
			        highlightBookmarks();
					mActivity.showToast(s);
				}
			}
		});
	}
	
	public boolean onMenuItem( final int itemId )
	{
		BackgroundThread.ensureGUI();
		ReaderAction action = ReaderAction.findByMenuId(itemId);
		if ( action.isNone() )
			return false;
		onAction(action);
		return true;
	}
	
	public void onAction( final ReaderAction action )
	{
		onAction(action, null);
	}
	public void onAction( final ReaderAction action, final Runnable onFinishHandler )
	{
		BackgroundThread.ensureGUI();
		if ( action.cmd!=ReaderCommand.DCMD_NONE )
			onCommand( action.cmd, action.param, onFinishHandler );
	}
	
	public void toggleDayNightMode()
	{
		Properties settings = getSettings();
		OptionsDialog.toggleDayNightMode(settings);
		setSettings(settings, null);
		invalidImages = true;
	}
	
	public boolean isNightMode() {
		return mSettings.getBool(PROP_NIGHT_MODE, false);
	}

	public String getSetting( String name ) {
		return mSettings.getProperty(name);
	}

	private int lastSaveSettingsRequestId = 0;
	
	public void scheduleSaveSettings(int delayMillis) {
		final int mySaveSettingsRequestId = ++lastSaveSettingsRequestId;
		BackgroundThread.instance().postGUI(new Runnable() {
			@Override
			public void run() {
				if (mySaveSettingsRequestId == lastSaveSettingsRequestId)
					mActivity.saveSettings(mSettings);
			}
		});
	}
	
	public void setSetting(String name, String value, boolean invalidateImages, boolean save, boolean apply) {
		Properties settings = new Properties(); //getSettings();
		settings.put(name, value);
		setSettings(settings, null, false, apply);
		if (invalidateImages)
			invalidImages = true;
		if (save) {
			scheduleSaveSettings(3000);
		}
	}
	
	public void setSetting( String name, String value ) {
		setSetting(name, value, true, false, true);
	}
	
	public void saveSetting( String name, String value ) {
		setSetting(name, value, true, true, true);
	}
	
	public void toggleScreenOrientation()
	{
		int orientation = mActivity.getScreenOrientation();
		orientation = ( orientation==0 )? 1 : 0;
		saveSetting(PROP_APP_SCREEN_ORIENTATION, String.valueOf(orientation));
		mActivity.setScreenOrientation(orientation);
	}
	
	public void toggleFullscreen()
	{
		boolean newBool = !mActivity.isFullscreen();
		String newValue = newBool ? ""1"" : ""0"";
		saveSetting(PROP_APP_FULLSCREEN, newValue);
		mActivity.setFullscreen(newBool);
	}
	
	public void showReadingPositionPopup()
	{
		if (mBookInfo==null)
			return;
		final StringBuilder buf = new StringBuilder();
//		if (mActivity.isFullscreen()) {
		SimpleDateFormat fmt = new SimpleDateFormat(""HH:mm"");
		final String time = fmt.format(new Date());
		buf.append(time + "" "");
		if (mBatteryState>=0)
 			buf.append("" ["" + mBatteryState + ""%]\n"");
//		}
		execute( new Task() {
			Bookmark bm;
			@Override
			public void work() {
				bm = doc.getCurrentPageBookmark();
				if ( bm!=null ) {
					PositionProperties prop = doc.getPositionProps(bm.getStartPos());
					if ( prop.pageMode!=0 ) {
						buf.append("""" + (prop.pageNumber+1) + "" / "" + prop.pageCount + ""   "");
					}
					int percent = (int)(10000 * (long)prop.y / prop.fullHeight);
					buf.append("""" + (percent/100) + ""."" + (percent%100) + ""%"" );
					String chapter = bm.getTitleText();
					if (chapter!=null && chapter.length()>100)
						chapter = chapter.substring(0, 100) + ""..."";
					if (chapter!=null)
			 			buf.append(""\n"" + chapter);
				}
			}
			public void done() {
				mActivity.showToast(buf.toString());
			}
		});
	}

	public void toggleTitlebar()
	{
		boolean newBool = ""1"".equals(getSetting(PROP_STATUS_LINE));
		String newValue = !newBool ? ""1"" : ""0"";
		Properties settings = new Properties();
		settings.setProperty(PROP_STATUS_LINE, newValue);
		setSettings(settings, null, true, true);
	}
	
	public void toggleDocumentStyles()
	{
		if ( mOpened && mBookInfo!=null ) {
			log.d(""toggleDocumentStyles()"");
			int internalStyles = mBookInfo.getFileInfo().getFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG) ? 0 : 1;
			int txtReflow = mBookInfo.getFileInfo().getFlag(FileInfo.DONT_REFLOW_TXT_FILES_FLAG) ? 0 : 2;
			internalStyles ^= 1;
			mBookInfo.getFileInfo().setFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG, internalStyles == 0);
            doEngineCommand( ReaderCommand.DCMD_SET_INTERNAL_STYLES, internalStyles | txtReflow);
            doEngineCommand( ReaderCommand.DCMD_REQUEST_RENDER, 1);
		}
	}
	
	public void toggleTextReflow()
	{
		if ( mOpened && mBookInfo!=null ) {
			log.d(""toggleTextReflow()"");
			if (mBookInfo.getFileInfo().format != DocumentFormat.TXT && mBookInfo.getFileInfo().format != DocumentFormat.HTML)
				return;
			int internalStyles = mBookInfo.getFileInfo().getFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG) ? 0 : 1;
			int txtReflow = mBookInfo.getFileInfo().getFlag(FileInfo.DONT_REFLOW_TXT_FILES_FLAG) ? 0 : 2;
			txtReflow ^= 2;
			mBookInfo.getFileInfo().setFlag(FileInfo.DONT_REFLOW_TXT_FILES_FLAG, txtReflow == 0);
            doEngineCommand( ReaderCommand.DCMD_SET_INTERNAL_STYLES, internalStyles | txtReflow);
            doEngineCommand( ReaderCommand.DCMD_REQUEST_RENDER, 1);
		}
	}
	
	public boolean getDocumentStylesEnabled() {
		if ( mOpened && mBookInfo!=null ) {
			boolean flg = !mBookInfo.getFileInfo().getFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG);
			return flg;
		}
		return true;
	}
	
	static private SimpleDateFormat timeFormat = new SimpleDateFormat(""HH:mm"", Locale.getDefault());
	public void showBookInfo() {
		final ArrayList<String> items = new ArrayList<String>();
		items.add(""section=section.system"");
		items.add(""system.version=Cool Reader "" + mActivity.getVersion());
		items.add(""system.battery="" + mBatteryState + ""%"");
		items.add(""system.time="" + timeFormat.format(new Date()));
		final BookInfo bi = mBookInfo;
		if ( bi!=null ) {
			FileInfo fi = bi.getFileInfo();
			items.add(""section=section.file"");
			String fname = new File(fi.pathname).getName();
			items.add(""file.name="" + fname);
			if ( new File(fi.pathname).getParent()!=null )
				items.add(""file.path="" + new File(fi.pathname).getParent());
			items.add(""file.size="" + fi.size);
			if ( fi.arcname!=null ) {
				items.add(""file.arcname="" + new File(fi.arcname).getName());
				if ( new File(fi.arcname).getParent()!=null )
					items.add(""file.arcpath="" + new File(fi.arcname).getParent());
				items.add(""file.arcsize="" + fi.arcsize);
			}
			items.add(""file.format="" + fi.format.name());
		}
		execute( new Task() {
			Bookmark bm;
			@Override
			public void work() {
				bm = doc.getCurrentPageBookmark();
				if ( bm!=null ) {
					PositionProperties prop = doc.getPositionProps(bm.getStartPos());
					items.add(""section=section.position"");
					if ( prop.pageMode!=0 ) {
						items.add(""position.page="" + (prop.pageNumber+1) + "" / "" + prop.pageCount);
					}
					int percent = (int)(10000 * (long)prop.y / prop.fullHeight);
					items.add(""position.percent="" + (percent/100) + ""."" + (percent%100) + ""%"" );
					String chapter = bm.getTitleText();
					if ( chapter!=null && chapter.length()>100 )
						chapter = chapter.substring(0, 100) + ""..."";
					items.add(""position.chapter="" + chapter);
				}
			}
			public void done() {
				FileInfo fi = bi.getFileInfo();
				items.add(""section=section.book"");
				if ( fi.authors!=null || fi.title!=null || fi.series!=null) { 
					items.add(""book.authors="" + fi.authors);
					items.add(""book.title="" + fi.title);
					if ( fi.series!=null ) {
						String s = fi.series;
						if ( fi.seriesNumber>0 )
							s = s + "" #"" + fi.seriesNumber; 
						items.add(""book.series="" + s);
					}
				}
				BookInfoDialog dlg = new BookInfoDialog(mActivity, items);
				dlg.show();
			}
		});
	}

	private int autoScrollSpeed = 1500; // chars / minute
	private int autoScrollNotificationId = 0;
	private AutoScrollAnimation currentAutoScrollAnimation = null;
	
	private boolean isAutoScrollActive() {
		return currentAutoScrollAnimation != null;
	}
	
	private void stopAutoScroll() {
		if (!isAutoScrollActive())
			return;
		log.d(""stopAutoScroll()"");
		//notifyAutoscroll(""Autoscroll is stopped"");
		currentAutoScrollAnimation.stop();
	}
	
	public static final int AUTOSCROLL_START_ANIMATION_PERCENT = 5; 
	
	private void startAutoScroll() {
		if (isAutoScrollActive())
			return;
		log.d(""startAutoScroll()"");
		currentAutoScrollAnimation = new AutoScrollAnimation(AUTOSCROLL_START_ANIMATION_PERCENT * 100);
		nextHiliteId++;
		hiliteRect = null;
	}
	
	private void toggleAutoScroll() {
		if (isAutoScrollActive())
			stopAutoScroll();
		else
			startAutoScroll();
	}
	
	private final static boolean AUTOSCROLL_SPEED_NOTIFICATION_ENABLED = false;
	private void notifyAutoscroll(final String msg) {
		if (DeviceInfo.EINK_SCREEN)
			return; // disable toast for eink
		if (AUTOSCROLL_SPEED_NOTIFICATION_ENABLED) {
			final int myId = ++autoScrollNotificationId;
			BackgroundThread.instance().postGUI(new Runnable() {
				@Override
				public void run() {
					if (myId == autoScrollNotificationId)
						mActivity.showToast(msg);
				}}, 1000);
		}
	}
	
	private void notifyAutoscrollSpeed() {
		final String msg = mActivity.getString(R.string.lbl_autoscroll_speed).replace(""$1"", String.valueOf(autoScrollSpeed));
		notifyAutoscroll(msg);
	}
	
	private void changeAutoScrollSpeed(int delta) {
		if (autoScrollSpeed<300)
			delta *= 10;
		else if (autoScrollSpeed<500)
			delta *= 20;
		else if (autoScrollSpeed<1000)
			delta *= 40;
		else if (autoScrollSpeed<2000)
			delta *= 80;
		else if (autoScrollSpeed<5000)
			delta *= 200;
		else
			delta *= 300;
		autoScrollSpeed += delta;
		if (autoScrollSpeed < 200)
			autoScrollSpeed = 200;
		if (autoScrollSpeed > 10000)
			autoScrollSpeed = 10000;
		setSetting(PROP_APP_VIEW_AUTOSCROLL_SPEED, String.valueOf(autoScrollSpeed), false, true, false);
		notifyAutoscrollSpeed();
	}
	
	class AutoScrollAnimation {

		boolean isScrollView;
		BitmapInfo image1;
		BitmapInfo image2;
		PositionProperties currPos;
		int progress;
		int pageCount;
		int charCount;
		int timerInterval;
		long pageTurnStart;
		int nextPos;
		
		Paint[] shadePaints;
		Paint[] hilitePaints;
		
		final int startAnimationProgress;
		
		public static final int MAX_PROGRESS = 10000;
		public final static int ANIMATION_INTERVAL_NORMAL = 30;
		public final static int ANIMATION_INTERVAL_EINK = 5000;
		
		public AutoScrollAnimation(final int startProgress) {
			progress = startProgress;
			startAnimationProgress = AUTOSCROLL_START_ANIMATION_PERCENT * 100;
			currentAutoScrollAnimation = this;

			final int numPaints = 32;
			shadePaints = new Paint[numPaints];
			hilitePaints = new Paint[numPaints];
			for ( int i=0; i<numPaints; i++ ) {
				shadePaints[i] = new Paint();
				hilitePaints[i] = new Paint();
				hilitePaints[i].setStyle(Paint.Style.FILL);
				shadePaints[i].setStyle(Paint.Style.FILL);
				if ( mActivity.isNightMode() ) {
					shadePaints[i].setColor(Color.argb((i+1)*128 / numPaints, 0, 0, 0));
					hilitePaints[i].setColor(Color.argb((i+1)*128 / numPaints, 128, 128, 128));
				} else {
					shadePaints[i].setColor(Color.argb((i+1)*128 / numPaints, 0, 0, 0));
					hilitePaints[i].setColor(Color.argb((i+1)*128 / numPaints, 255, 255, 255));
				}
			}
			
			BackgroundThread.instance().postBackground(new Runnable() {
				@Override
				public void run() {
					if (initPageTurn(startProgress)) {
						log.d(""AutoScrollAnimation: starting autoscroll timer"");
						timerInterval = DeviceInfo.EINK_SCREEN ? ANIMATION_INTERVAL_EINK : ANIMATION_INTERVAL_NORMAL;
						startTimer(timerInterval);
					} else {
						currentAutoScrollAnimation = null;
					}
				}
			});
		}
		
		private int calcProgressPercent() {
			long duration = Utils.timeInterval(pageTurnStart);
			long estimatedFullDuration = 60000 * charCount / autoScrollSpeed; 
			int percent = (int)(10000 * duration / estimatedFullDuration);
//			if (duration > estimatedFullDuration - timerInterval / 3)
//				percent = 10000;
			if (percent > 10000)
				percent = 10000;
			if (percent < 0)
				percent = 0;
			return percent;
		}
		
		private boolean onTimer() {
			int newProgress = calcProgressPercent();
			if (DEBUG_ANIMATION) log.v(""onTimer(progress = "" + newProgress + "")"");
			mActivity.onUserActivity();
			progress = newProgress;
			if (progress == 0 || progress >= startAnimationProgress) {
				if (image1 != null && image2 != null) {
					if (image1.isReleased() || image2.isReleased()) {
						log.d(""Images lost! Recreating images..."");
						initPageTurn(progress);
					}
					draw();
				}
			}
			if (progress >= 10000) {
				if (!donePageTurn(true)) {
					stop();
					return false;
				}
				initPageTurn(0);
			}
			return true;
		}
		
		class AutoscrollTimerTask implements Runnable {
			final long interval;
			public AutoscrollTimerTask(long interval) {
				this.interval = interval;
				mActivity.onUserActivity();
				BackgroundThread.instance().postGUI(this, interval);
			}
			@Override
			public void run() {
				if (currentAutoScrollAnimation != AutoScrollAnimation.this) {
					log.v(""timer is cancelled - GUI"");
					return;
				}
				BackgroundThread.instance().postBackground(new Runnable() {
					@Override
					public void run() {
						if (currentAutoScrollAnimation != AutoScrollAnimation.this) {
							log.v(""timer is cancelled - BackgroundThread"");
							return;
						}
						if (onTimer())
							BackgroundThread.instance().postGUI(AutoscrollTimerTask.this, interval);
						else
							log.v(""timer is cancelled - onTimer returned false"");
					}
				});
			}
		}
		
		private void startTimer(final int interval) {
			new AutoscrollTimerTask(interval);
		}
		
		private boolean initPageTurn(int startProgress) {
			cancelGc();
			log.v(""initPageTurn(startProgress = "" + startProgress + "")"");
			pageTurnStart = Utils.timeStamp();
			progress = startProgress;
			currPos = doc.getPositionProps(null);
			charCount = currPos.charCount;
			pageCount = currPos.pageMode;
			if (charCount < 150)
				charCount = 150;
			isScrollView = currPos.pageMode == 0;
			log.v(""initPageTurn(charCount = "" + charCount + "")"");
			if (isScrollView) {
				image1 = preparePageImage(0);
				if (image1 == null) {
					log.v(""ScrollViewAnimation -- not started: image is null"");
					return false;
				}
				int pos0 = image1.position.y;
				int pos1 = pos0 + image1.position.pageHeight * 9/10;
				if (pos1 > image1.position.fullHeight - image1.position.pageHeight)
					pos1 = image1.position.fullHeight - image1.position.pageHeight;
				if (pos1 < 0)
					pos1 = 0;
				nextPos = pos1; 
				image2 = preparePageImage(pos1 - pos0);
				if (image2 == null) {
					log.v(""ScrollViewAnimation -- not started: image is null"");
					return false;
				}
			} else {
				int page1 = currPos.pageNumber;
				int page2 = currPos.pageNumber + 1;
				if ( page2<0 || page2>=currPos.pageCount) {
					currentAnimation = null;
					return false;
				}
				image1 = preparePageImage(0);
				image2 = preparePageImage(1);
				if ( page1==page2 ) {
					log.v(""PageViewAnimation -- cannot start animation: not moved"");
					return false;
				}
				if ( image1==null || image2==null ) {
					log.v(""PageViewAnimation -- cannot start animation: page image is null"");
					return false;
				}
				
			}
			long duration = android.os.SystemClock.uptimeMillis() - pageTurnStart;
			log.v(""AutoScrollAnimation -- page turn initialized in "" + duration + "" millis"");
			currentAutoScrollAnimation = this;
			draw();
			return true;
		}
		
		
		private boolean donePageTurn(boolean turnPage) {
			log.v(""donePageTurn()"");
			if (turnPage) {
				if (isScrollView)
					doc.doCommand(ReaderCommand.DCMD_GO_POS.nativeId, nextPos);
				else
					doc.doCommand(ReaderCommand.DCMD_PAGEDOWN.nativeId, 1);
			}
			progress = 0;
			//draw();
			return currPos.canMoveToNextPage();
		}

		public void draw()
		{
			draw(true);
		}

		public void draw(boolean isPartially)
		{
			drawCallback( new DrawCanvasCallback() {
				@Override
				public void drawTo(Canvas c) {
				//	long startTs = android.os.SystemClock.uptimeMillis();
					draw(c);
				}
			}, null, isPartially);
		}
		
		public void stop() {
			currentAutoScrollAnimation = null;
			BackgroundThread.instance().executeBackground(new Runnable() {
				@Override
				public void run() {
					donePageTurn(wantPageTurn());
					redraw();
				}
			});
			scheduleGc();
		}
		
	    private boolean wantPageTurn() {
	    	return (progress > (startAnimationProgress + MAX_PROGRESS) / 2);
	    }
		
		private void drawGradient( Canvas canvas, Rect rc, Paint[] paints, int startIndex, int endIndex ) {
			//log.v(""drawShadow"");
			int n = (startIndex<endIndex) ? endIndex-startIndex+1 : startIndex-endIndex + 1;
			int dir = (startIndex<endIndex) ? 1 : -1;
			int dx = rc.bottom - rc.top;
			Rect rect = new Rect(rc);
			for ( int i=0; i<n; i++ ) {
				int index = startIndex + i*dir;
				int x1 = rc.top + dx*i/n;
				int x2 = rc.top + dx*(i+1)/n;
				if (x1 < 0)
					x1 = 0;
				if (x2 > canvas.getHeight())
					x2 = canvas.getHeight();
				rect.top = x1;
				rect.bottom = x2;
				if ( x2>x1 ) {
					//log.v(""drawShadow : "" + x1 + "", "" + x2 + "", "" + index);
					canvas.drawRect(rect, paints[index]);
				}
			}
		}
		
		private void drawShadow( Canvas canvas, Rect rc ) {
			drawGradient(canvas, rc, shadePaints, shadePaints.length * 3 / 4, 0);
		}
		
	    void drawPageProgress(Canvas canvas, int scrollPercent, Rect dst, Rect src) {
	    	int shadowHeight = 32;
			int h = dst.height();
			int div = (h + shadowHeight) * scrollPercent / 10000 - shadowHeight;
			//log.v(""drawPageProgress() div = "" + div + "", percent = "" + scrollPercent);
			int d = div >= 0 ? div : 0; 
			if (d > 0) {
	    		Rect src1 = new Rect(src.left, src.top, src.right, src.top + d);
	    		Rect dst1 = new Rect(dst.left, dst.top, dst.right, dst.top + d);
	    		drawDimmedBitmap(canvas, image2.bitmap, src1, dst1);
			}
			if (d < h) {
	    		Rect src2 = new Rect(src.left, src.top + d, src.right, src.bottom);
	    		Rect dst2 = new Rect(dst.left, dst.top + d, dst.right, dst.bottom);
	    		drawDimmedBitmap(canvas, image1.bitmap, src2, dst2);
			}
    		if (scrollPercent > 0 && scrollPercent < 10000) {
				Rect shadowRect = new Rect(src.left, src.top + div, src.right, src.top + div + shadowHeight);
				drawShadow(canvas, shadowRect);
    		}
	    }
	    
		public void draw(Canvas canvas) {
			if (currentAutoScrollAnimation != this)
				return;
			if (DEBUG_ANIMATION) log.v(""AutoScrollAnimation.draw("" + progress + "")"");
			if (progress!=0 && progress<startAnimationProgress)
				return; // don't draw page w/o started animation
			int scrollPercent = 10000 * (progress - startAnimationProgress) / (MAX_PROGRESS - startAnimationProgress);
			if (scrollPercent < 0)
				scrollPercent = 0;
			int w = image1.bitmap.getWidth(); 
			int h = image1.bitmap.getHeight();
			if (isScrollView) {
				// scroll
				drawPageProgress(canvas, scrollPercent, new Rect(0, 0, w, h), new Rect(0, 0, w, h));
			} else {
				if (image1.isReleased() || image2.isReleased())
					return;
				if (pageCount==2) {
					if (scrollPercent<5000) {
						// < 50%
						scrollPercent = scrollPercent * 2; 
						drawPageProgress(canvas, scrollPercent, new Rect(0, 0, w/2, h), new Rect(0, 0, w/2, h));
						drawPageProgress(canvas, 0, new Rect(w/2, 0, w, h), new Rect(w/2, 0, w, h));
					} else {
						// >=50%
						scrollPercent = (scrollPercent - 5000) * 2; 
						drawPageProgress(canvas, 10000, new Rect(0, 0, w/2, h), new Rect(0, 0, w/2, h));
						drawPageProgress(canvas, scrollPercent, new Rect(w/2, 0, w, h), new Rect(w/2, 0, w, h));
					}
				} else {
					drawPageProgress(canvas, scrollPercent, new Rect(0, 0, w, h), new Rect(0, 0, w, h));
				}
			}
			
		}
		
	}

	private void redraw() {
		BackgroundThread.instance().executeGUI(new Runnable() {
			@Override
			public void run() {
				invalidate();
				invalidImages = true;
				draw();
			}
		});
	}

	public void onCommand( final ReaderCommand cmd, final int param )
	{
		onCommand( cmd, param, null );
	}
	
	public void onCommand( final ReaderCommand cmd, final int param, final Runnable onFinishHandler )
	{
		BackgroundThread.ensureGUI();
		log.i(""On command "" + cmd + (param!=0?"" (""+param+"")"":"" ""));
		switch ( cmd ) {
		case DCMD_ABOUT:
			mActivity.showAboutDialog();
			break;
		case DCMD_SWITCH_PROFILE:
			showSwitchProfileDialog();
			break;
		case DCMD_TOGGLE_AUTOSCROLL:
			toggleAutoScroll();
			break;
		case DCMD_AUTOSCROLL_SPEED_INCREASE:
			changeAutoScrollSpeed(1);
			break;
		case DCMD_AUTOSCROLL_SPEED_DECREASE:
			changeAutoScrollSpeed(-1);
			break;
		case DCMD_SHOW_DICTIONARY:
			mActivity.showDictionary();
			break;
		case DCMD_OPEN_PREVIOUS_BOOK:
			loadPreviousDocument(new Runnable() {
				@Override
				public void run() {
					// do nothing
				}
			});
			break;
		case DCMD_BOOK_INFO:
			showBookInfo();
			break;
		case DCMD_TTS_PLAY:
			{
				log.i(""DCMD_TTS_PLAY: initializing TTS"");
				if ( !mActivity.initTTS(new TTS.OnTTSCreatedListener() {
					@Override
					public void onCreated(TTS tts) {
						log.i(""TTS created: opening TTS toolbar"");
						TTSToolbarDlg.showDialog(mActivity, ReaderView.this, tts);
					}
				}) ) {
					log.e(""Cannot initilize TTS"");
				}
			}
			break;
		case DCMD_TOGGLE_DOCUMENT_STYLES:
			toggleDocumentStyles();
			break;
		case DCMD_SHOW_HOME_SCREEN:
			mActivity.showHomeScreen();
			break;
		case DCMD_TOGGLE_ORIENTATION:
			toggleScreenOrientation();
			break;
		case DCMD_TOGGLE_FULLSCREEN:
			toggleFullscreen();
			break;
		case DCMD_TOGGLE_TITLEBAR:
			toggleTitlebar();
			break;
		case DCMD_SHOW_POSITION_INFO_POPUP:
			showReadingPositionPopup();
			break;
		case DCMD_TOGGLE_SELECTION_MODE:
			toggleSelectionMode();
			break;
		case DCMD_TOGGLE_TOUCH_SCREEN_LOCK:
			isTouchScreenEnabled = !isTouchScreenEnabled;
			if ( isTouchScreenEnabled )
				mActivity.showToast(R.string.action_touch_screen_enabled_toast);
			else
				mActivity.showToast(R.string.action_touch_screen_disabled_toast);
			break;
		case DCMD_LINK_BACK:
		case DCMD_LINK_FORWARD:
            doEngineCommand( cmd, 0);
            drawPage();
            break;
		case DCMD_ZOOM_OUT:
            doEngineCommand( ReaderCommand.DCMD_ZOOM_OUT, param);
            syncViewSettings(getSettings(), true);
            break;
		case DCMD_ZOOM_IN:
            doEngineCommand( ReaderCommand.DCMD_ZOOM_IN, param);
            syncViewSettings(getSettings(), true);
            break;
		case DCMD_PAGEDOWN:
			if ( param==1 )
				animatePageFlip(1, onFinishHandler);
			else
				doEngineCommand(cmd, param, onFinishHandler);
			break;
		case DCMD_PAGEUP:
			if ( param==1 )
				animatePageFlip(-1, onFinishHandler);
			else
				doEngineCommand(cmd, param, onFinishHandler);
			break;
		case DCMD_BEGIN:
		case DCMD_END:
			doEngineCommand(cmd, param);
			break;
		case DCMD_RECENT_BOOKS_LIST:
			mActivity.showBrowserRecentBooks();
			break;
		case DCMD_SEARCH:
			showSearchDialog();
			break;
		case DCMD_EXIT:
			mActivity.finish();
			break;
		case DCMD_BOOKMARKS:
			mActivity.showBookmarksDialog();
			break;
		case DCMD_GO_PERCENT_DIALOG:
			mActivity.showGoToPercentDialog();
			break;
		case DCMD_GO_PAGE_DIALOG:
			mActivity.showGoToPageDialog();
			break;
		case DCMD_TOC_DIALOG:
			showTOC();
			break;
		case DCMD_FILE_BROWSER:
			mActivity.showBrowser(getOpenedFileInfo());
			break;
		case DCMD_OPTIONS_DIALOG:
			mActivity.showOptionsDialog();
			break;
		case DCMD_READER_MENU:
			mActivity.openOptionsMenu();
			break;
		case DCMD_TOGGLE_DAY_NIGHT_MODE:
			toggleDayNightMode();
			break;
		}
	}
	
	public void doEngineCommand( final ReaderCommand cmd, final int param )
	{
		doEngineCommand( cmd, param, null );
	}
	public void doEngineCommand( final ReaderCommand cmd, final int param, final Runnable doneHandler )
	{
		BackgroundThread.ensureGUI();
		log.d(""doCommand(""+cmd + "", "" + param +"")"");
		post(new Task() {
			boolean res;
			public void work() {
				BackgroundThread.ensureBackground();
				res = doc.doCommand(cmd.nativeId, param);
			}
			public void done() {
				if ( res )
					drawPage( doneHandler, false );
			}
		});
	}
	
	public void doCommandFromBackgroundThread( final ReaderCommand cmd, final int param )
	{
		log.d(""doCommandFromBackgroundThread(""+cmd + "", "" + param +"")"");
		BackgroundThread.ensureBackground();
		boolean res = doc.doCommand(cmd.nativeId, param);
		if ( res ) {
			BackgroundThread.guiExecutor.execute(new Runnable() {
				public void run() {
					drawPage();
				}
			});
		}
	}
	
	volatile private boolean mInitialized = false;
	volatile private boolean mOpened = false;
	
	//private File historyFile;
	
	private void updateLoadedBookInfo()
	{
		BackgroundThread.ensureBackground();
		// get title, authors, etc.
		doc.updateBookInfo( mBookInfo );
	}
	
	private void applySettings( Properties props, boolean save )
	{
		BackgroundThread.ensureBackground();
		log.v(""applySettings() "" + props);
		boolean isFullScreen = props.getBool(PROP_APP_FULLSCREEN, false );
		props.setBool(PROP_SHOW_BATTERY, isFullScreen); 
		props.setBool(PROP_SHOW_TIME, isFullScreen);
		String backgroundImageId = props.getProperty(PROP_PAGE_BACKGROUND_IMAGE);
		if ( backgroundImageId!=null )
			setBackgroundTexture(backgroundImageId);
		props.remove(PROP_EMBEDDED_STYLES);
		doc.applySettings(props);
        syncViewSettings(props, save);
        drawPage();
	}
	
	public static boolean eq(Object obj1, Object obj2)
	{
		if ( obj1==null && obj2==null )
			return true;
		if ( obj1==null || obj2==null )
			return false;
		return obj1.equals(obj2);
	}

	public void saveSettings( Properties settings )
	{
		mActivity.saveSettings(settings);
	}
	
	/**
	 * Read JNI view settings, update and save if changed 
	 */
	private void syncViewSettings( final Properties currSettings, final boolean save )
	{
		post( new Task() {
			Properties props;
			public void work() {
				BackgroundThread.ensureBackground();
				java.util.Properties internalProps = doc.getSettings(); 
				props = new Properties(internalProps);
				props.remove(PROP_EMBEDDED_STYLES);
			}
			public void done() {
				Properties changedSettings = props.diff(currSettings);
		        for ( Map.Entry<Object, Object> entry : changedSettings.entrySet() ) {
	        		currSettings.setProperty((String)entry.getKey(), (String)entry.getValue());
		        }
	        	mSettings = currSettings;
	        	if ( save )
	        		saveSettings(currSettings);
			}
		});
	}
	
	public Properties getSettings()
	{
		return new Properties(mSettings);
	}
	
	static public int stringToInt( String value, int defValue ) {
		if ( value==null )
			return defValue;
		try {
			return Integer.valueOf(value);
		} catch ( NumberFormatException e ) {
			return defValue;
		}
	}

	private boolean hiliteTapZoneOnTap = false;
	private boolean enableVolumeKeys = true; 
	static private final int DEF_PAGE_FLIP_MS = 300; 
	public void applyAppSetting( String key, String value )
	{
		boolean flg = ""1"".equals(value);
        if ( key.equals(PROP_APP_FULLSCREEN) ) {
			this.mActivity.setFullscreen( ""1"".equals(value) );
        } else if ( key.equals(PROP_APP_SHOW_COVERPAGES) ) {
			mActivity.getHistory().setCoverPagesEnabled(flg);
        } else if ( key.equals(PROP_APP_BOOK_PROPERTY_SCAN_ENABLED) ) {
			mActivity.getScanner().setDirScanEnabled(flg);
        } else if ( key.equals(PROP_APP_SCREEN_BACKLIGHT_LOCK) ) {
        	int n = 0;
        	try {
        		n = Integer.parseInt(value);
        	} catch (NumberFormatException e) {
        		// ignore
        	}
			mActivity.setScreenBacklightDuration(n);
        } else if ( key.equals(PROP_APP_FILE_BROWSER_SIMPLE_MODE) ) {
        	if ( mActivity.getBrowser()!=null )
        		mActivity.getBrowser().setSimpleViewMode(flg);
        } else if ( key.equals(PROP_NIGHT_MODE) ) {
			mActivity.setNightMode(flg);
        } else if ( key.equals(PROP_APP_SCREEN_UPDATE_MODE) ) {
			mActivity.setScreenUpdateMode(stringToInt(value, 0), this);
        } else if ( key.equals(PROP_APP_SCREEN_UPDATE_INTERVAL) ) {
			mActivity.setScreenUpdateInterval(stringToInt(value, 10), this);
        } else if ( key.equals(PROP_APP_TAP_ZONE_HILIGHT) ) {
        	hiliteTapZoneOnTap = flg;
        } else if ( key.equals(PROP_APP_DICTIONARY) ) {
        	mActivity.setDict(value);
        } else if ( key.equals(PROP_APP_THEME) ) {
        	mActivity.setCurrentTheme(value);
        } else if ( key.equals(PROP_APP_DOUBLE_TAP_SELECTION) ) {
        	doubleTapSelectionEnabled = flg;
        } else if ( key.equals(PROP_APP_SECONDARY_TAP_ACTION_TYPE) ) {
        	secondaryTapActionType = flg ? TAP_ACTION_TYPE_DOUBLE : TAP_ACTION_TYPE_LONGPRESS;
        } else if ( key.equals(PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS) ) {
        	mActivity.getScanner().setHideEmptyDirs(flg);
        } else if ( key.equals(PROP_APP_FLICK_BACKLIGHT_CONTROL) ) {
        	isBacklightControlFlick = ""1"".equals(value) ? 1 : (""2"".equals(value) ? 2 : 0);
        } else if (PROP_APP_HIGHLIGHT_BOOKMARKS.equals(key)) {
        	flgHighlightBookmarks = flg;
        	clearSelection();
        } else if ( key.equals(PROP_APP_SCREEN_ORIENTATION) ) {
        	int orientation = 0;
        	try {
        		orientation = Integer.parseInt(value);
        	} catch (NumberFormatException e) {
        		// ignore
        	}
        	mActivity.setScreenOrientation(orientation);
        } else if (PROP_APP_VIEW_AUTOSCROLL_SPEED.equals(key)) {
        	int n = 1500;
        	try {
        		n = Integer.parseInt(value);
        	} catch (NumberFormatException e) {
        		// ignore
        	}
        	if (n < 200)
        		n = 200;
        	if (n > 10000)
        		n = 10000;
        	autoScrollSpeed = n;
        } else if ( PROP_PAGE_ANIMATION.equals(key) ) {
        	try {
        		int n = Integer.valueOf(value);
        		if ( n<0 || n>PAGE_ANIMATION_MAX )
        			n = PAGE_ANIMATION_SLIDE2;
        		pageFlipAnimationMode = n;
        	} catch ( Exception e ) {
        		// ignore
        	}
			pageFlipAnimationSpeedMs = pageFlipAnimationMode!=PAGE_ANIMATION_NONE ? DEF_PAGE_FLIP_MS : 0; 
        } else if ( PROP_CONTROLS_ENABLE_VOLUME_KEYS.equals(key) ) {
        	enableVolumeKeys = flg;
        } else if ( !DeviceInfo.EINK_SCREEN && PROP_APP_SCREEN_BACKLIGHT.equals(key) ) {
        	try {
        		final int n = Integer.valueOf(value);
        		// delay before setting brightness
        		mBackThread.postGUI(new Runnable() {
        			public void run() {
        				execute( new Task() {

							@Override
							public void work() throws Exception {
								// do nothing
							}

							@Override
							public void done() {
				        		mActivity.setScreenBacklightLevel(n);
								super.done();
							}
        					
        				});
        			}
        		}, 100);
        	} catch ( Exception e ) {
        		// ignore
        	}
        } else if ( PROP_APP_SELECTION_ACTION.equals(key) ) {
        	try {
        		int n = Integer.valueOf(value);
        		mSelectionAction = n;
        	} catch ( Exception e ) {
        		// ignore
        	}
        }
        //
	}
	
	public void setAppSettings( Properties newSettings, Properties oldSettings )
	{
		log.v(""setAppSettings() "" + newSettings.toString());
		BackgroundThread.ensureGUI();
		if ( oldSettings==null )
			oldSettings = mSettings;
		Properties changedSettings = newSettings.diff(oldSettings);
        for ( Map.Entry<Object, Object> entry : changedSettings.entrySet() ) {
    		String key = (String)entry.getKey();
    		String value = (String)entry.getValue();
    		applyAppSetting( key, value );
    		if ( PROP_APP_FULLSCREEN.equals(key) ) {
    			boolean flg = mSettings.getBool(PROP_APP_FULLSCREEN, false);
    			newSettings.setBool(PROP_SHOW_BATTERY, flg); 
    			newSettings.setBool(PROP_SHOW_TIME, flg); 
    		} else if ( PROP_PAGE_VIEW_MODE.equals(key) ) {
    			boolean flg = ""1"".equals(value);
    			viewMode = flg ? ViewMode.PAGES : ViewMode.SCROLL;
    		} else if ( PROP_APP_SCREEN_ORIENTATION.equals(key) || PROP_PAGE_ANIMATION.equals(key)
    				|| PROP_CONTROLS_ENABLE_VOLUME_KEYS.equals(key) || PROP_APP_SHOW_COVERPAGES.equals(key) 
    				|| PROP_APP_SCREEN_BACKLIGHT.equals(key) 
    				|| PROP_APP_BOOK_PROPERTY_SCAN_ENABLED.equals(key)
    				|| PROP_APP_SCREEN_BACKLIGHT_LOCK.equals(key)
    				|| PROP_APP_TAP_ZONE_HILIGHT.equals(key)
    				|| PROP_APP_DICTIONARY.equals(key)
    				|| PROP_APP_DOUBLE_TAP_SELECTION.equals(key)
    				|| PROP_APP_FLICK_BACKLIGHT_CONTROL.equals(key)
    				|| PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS.equals(key)
    				|| PROP_APP_SELECTION_ACTION.equals(key)
    				|| PROP_APP_FILE_BROWSER_SIMPLE_MODE.equals(key)
    				// TODO: redesign all this mess!
    				) {
    			newSettings.setProperty(key, value);
    		} else if ( PROP_HYPHENATION_DICT.equals(key) ) {
    			Engine.HyphDict dict = HyphDict.byCode(value);
    			//mEngine.setHyphenationDictionary();
    			if ( mEngine.setHyphenationDictionary(dict) ) {
    				if ( isBookLoaded() ) {
    					doEngineCommand( ReaderCommand.DCMD_REQUEST_RENDER, 0);
    					//drawPage();
    				}
    			}
    			newSettings.setProperty(key, value);
    		}
        }
	}
	
	public ViewMode getViewMode()
	{
		return viewMode;
	}
	
	/**
     * Change settings.
	 * @param newSettings are new settings
	 * @param oldSettings are old settings, null to use mSettings
	 */
	public void setSettings(Properties newSettings, Properties oldSettings)
	{
		setSettings(newSettings, oldSettings, true, true);
	}

	/**
     * Change settings.
	 * @param newSettings are new settings
	 * @param oldSettings are old settings, null to use mSettings
	 * @param save is true to save settings to file, false to skip saving
	 */
	public void setSettings(Properties newSettings, Properties oldSettings, final boolean save, final boolean apply)
	{
		log.v(""setSettings() "" + newSettings.toString());
		BackgroundThread.ensureGUI();
		if ( oldSettings==null )
			oldSettings = mSettings;
		final Properties currSettings = new Properties(oldSettings);
		setAppSettings( newSettings, currSettings );
		Properties changedSettings = newSettings.diff(currSettings);
		currSettings.setAll(changedSettings);
    	mBackThread.executeBackground(new Runnable() {
    		public void run() {
    			if (apply)
    				applySettings(currSettings, save);
    			else
    				mSettings = currSettings;
    		}
    	});
//        }
	}

	private void setBackgroundTexture( String textureId ) {
		BackgroundTextureInfo[] textures = mEngine.getAvailableTextures();
		for ( BackgroundTextureInfo item : textures ) {
			if ( item.id.equals(textureId) ) {
				setBackgroundTexture( item );
				return;
			}
		}
		setBackgroundTexture( Engine.NO_TEXTURE );
	}

	private void setBackgroundTexture( BackgroundTextureInfo texture ) {
		if ( !currentBackgroundTexture.equals(texture) ) {
		log.d(""setBackgroundTexture( "" + texture + "" )"");
			currentBackgroundTexture = texture;
			byte[] data = mEngine.getImageData(currentBackgroundTexture);
			doc.setPageBackgroundTexture(data, texture.tiled ? 1 : 0);
		}
	}
	
	BackgroundTextureInfo currentBackgroundTexture = Engine.NO_TEXTURE;
	class CreateViewTask extends Task
	{
        Properties props = new Properties();
        public CreateViewTask( Properties props ) {
       		this.props = props;
       		Properties oldSettings = new Properties(); // may be changed by setAppSettings 
   			setAppSettings(props, oldSettings);
   			props.setAll(oldSettings);
       		mSettings = props;
        }
		public void work() throws Exception {
			BackgroundThread.ensureBackground();
			log.d(""CreateViewTask - in background thread"");
//			BackgroundTextureInfo[] textures = mEngine.getAvailableTextures();
//			byte[] data = mEngine.getImageData(textures[3]);
			byte[] data = mEngine.getImageData(currentBackgroundTexture);
			doc.setPageBackgroundTexture(data, currentBackgroundTexture.tiled?1:0);
			
			//File historyDir = activity.getDir(""settings"", Context.MODE_PRIVATE);
			//File historyDir = new File(Environment.getExternalStorageDirectory(), "".cr3"");
			//historyDir.mkdirs();
			//File historyFile = new File(historyDir, ""cr3hist.ini"");
			
			//File historyFile = new File(activity.getDir(""settings"", Context.MODE_PRIVATE), ""cr3hist.ini"");
			//if ( historyFile.exists() ) {
			//log.d(""Reading history from file "" + historyFile.getAbsolutePath());
			//readHistoryInternal(historyFile.getAbsolutePath());
			//}
	        String css = mEngine.loadResourceUtf8(R.raw.fb2);
	        if ( css!=null && css.length()>0 )
	        	doc.setStylesheet(css);
   			applySettings(props, false);
   			mInitialized = true;
		}
		public void done() {
			log.d(""InitializationFinishedEvent"");
			BackgroundThread.ensureGUI();
	        //setSettings(props, new Properties());
		}
		public void fail( Exception e )
		{
			log.e(""CoolReader engine initialization failed. Exiting."", e);
			mEngine.fatalError(""Failed to init CoolReader engine"");
		}
	}

	public void closeIfOpened( final FileInfo fileInfo )
	{
		if ( this.mBookInfo!=null && this.mBookInfo.getFileInfo().pathname.equals(fileInfo.pathname) && mOpened ) {
			close();
		}
	}
	
	public void loadDocument( final FileInfo fileInfo )
	{
		if ( this.mBookInfo!=null && this.mBookInfo.getFileInfo().pathname.equals(fileInfo.pathname) && mOpened ) {
			log.d(""trying to load already opened document"");
			mActivity.showReader();
			drawPage();
			return;
		}
		post(new LoadDocumentTask(fileInfo, null));
	}

	public boolean loadLastDocument( final Runnable errorHandler )
	{
		BackgroundThread.ensureGUI();
		//BookInfo book = mActivity.getHistory().getLastBook();
		String lastBookName = mActivity.getLastSuccessfullyOpenedBook();
		log.i(""loadLastDocument() is called, lastBookName = "" + lastBookName);
		return loadDocument( lastBookName, errorHandler );
	}
	
	/**
	 * When current book is opened, switch to previous book.
	 * @param errorHandler
	 * @return
	 */
	public boolean loadPreviousDocument( final Runnable errorHandler )
	{
		BackgroundThread.ensureGUI();
		BookInfo bi = mActivity.getHistory().getPreviousBook();
		if (bi!=null && bi.getFileInfo()!=null) {
			save();
			log.i(""loadPreviousDocument() is called, prevBookName = "" + bi.getFileInfo().getPathName());
			return loadDocument( bi.getFileInfo().getPathName(), errorHandler );
		}
		errorHandler.run();
		return false;
	}
	
	public boolean loadDocument( String fileName, final Runnable errorHandler )
	{
		BackgroundThread.ensureGUI();
		log.i(""loadDocument("" + fileName + "")"");
		if ( fileName==null ) {
			log.v(""loadDocument() : no filename specified"");
			errorHandler.run();
			return false;
		}
		BookInfo book = mActivity.getHistory().getBookInfo(fileName);
		if ( book!=null )
			log.v(""loadDocument() : found book in history : "" + book);
		FileInfo fi = null;
		if ( book==null ) {
			log.v(""loadDocument() : book not found in history, looking for location directory"");
			FileInfo dir = mActivity.getScanner().findParent(new FileInfo(fileName), mActivity.getScanner().getRoot());
			if ( dir!=null ) {
				log.v(""loadDocument() : document location found : "" + dir);
				fi = dir.findItemByPathName(fileName);
				log.v(""loadDocument() : item inside location : "" + fi);
			}
			if ( fi==null ) {
				log.v(""loadDocument() : no file item "" + fileName + "" found inside "" + dir);
				errorHandler.run();
				return false;
			}
			if ( fi.isDirectory ) {
				log.v(""loadDocument() : is a directory, opening browser"");
				mActivity.showBrowser(fi);
				return true;
			}
		} else {
			fi = book.getFileInfo();
			log.v(""loadDocument() : item from history : "" + fi);
		}
		post( new LoadDocumentTask(fi, errorHandler) );
		log.v(""loadDocument: LoadDocumentTask("" + fi + "") is posted"");
		return true;
	}
	
	public BookInfo getBookInfo() {
		BackgroundThread.ensureGUI();
		return mBookInfo;
	}
	
	
	private int mBatteryState = 100;
	public void setBatteryState( int state ) {
		if ( state!=mBatteryState ) {
			log.i(""Battery state changed: "" + state);
			mBatteryState = state;
			if (!DeviceInfo.EINK_SCREEN) {
				drawPage();
			}
		}
	}
	
	public int getBatteryState() {
		return mBatteryState;
	}
	
	private static class BitmapFactory {
		public static final int MAX_FREE_LIST_SIZE=2;
		ArrayList<Bitmap> freeList = new ArrayList<Bitmap>(); 
		ArrayList<Bitmap> usedList = new ArrayList<Bitmap>(); 
		public synchronized Bitmap get( int dx, int dy ) {
			for ( int i=0; i<freeList.size(); i++ ) {
				Bitmap bmp = freeList.get(i);
				if ( bmp.getWidth()==dx && bmp.getHeight()==dy ) {
					// found bitmap of proper size
					freeList.remove(i);
					usedList.add(bmp);
					//log.d(""BitmapFactory: reused free bitmap, used list = "" + usedList.size() + "", free list="" + freeList.size());
					return bmp;
				}
			}
			for ( int i=freeList.size()-1; i>=0; i-- ) {
				Bitmap bmp = freeList.remove(i);
				//log.d(""Recycling free bitmap ""+bmp.getWidth()+""x""+bmp.getHeight());
				//bmp.recycle(); //20110109 
			}
			Bitmap bmp = Bitmap.createBitmap(dx, dy, Bitmap.Config.RGB_565);
			//bmp.setDensity(0);
			usedList.add(bmp);
			//log.d(""Created new bitmap ""+dx+""x""+dy+"". New bitmap list size = "" + usedList.size());
			return bmp;
		}
		public synchronized void compact() {
			while ( freeList.size()>0 ) {
				//freeList.get(0).recycle();//20110109
				freeList.remove(0);
			}
		}
		public synchronized void release( Bitmap bmp ) {
			for ( int i=0; i<usedList.size(); i++ ) {
				if ( usedList.get(i)==bmp ) {
					freeList.add(bmp);
					usedList.remove(i);
					while ( freeList.size()>MAX_FREE_LIST_SIZE ) {
						//freeList.get(0).recycle(); //20110109
						freeList.remove(0);
					}
					log.d(""BitmapFactory: bitmap released, used size = "" + usedList.size() + "", free size="" + freeList.size());
					return;
				}
			}
			// unknown bitmap, just recycle
			//bmp.recycle();//20110109
		}
	};
	BitmapFactory factory = new BitmapFactory(); 
	
	class BitmapInfo {
		Bitmap bitmap;
		PositionProperties position;
		ImageInfo imageInfo;
		void recycle()
		{
			factory.release(bitmap);
			bitmap = null;
			position = null;
			imageInfo = null;
		}
		boolean isReleased() {
			return bitmap == null;
		}
		@Override
		public String toString() {
			return ""BitmapInfo [position="" + position + ""]"";
		}
		
	}
	
    private BitmapInfo mCurrentPageInfo;
    private BitmapInfo mNextPageInfo;
	/**
	 * Prepare and cache page image.
	 * Cache is represented by two slots: mCurrentPageInfo and mNextPageInfo.  
	 * If page already exists in cache, returns it (if current page requested, 
	 *  ensures that it became stored as mCurrentPageInfo; if another page requested, 
	 *  no mCurrentPageInfo/mNextPageInfo reordering made).
	 * @param offset is kind of page: 0==current, -1=previous, 1=next page
	 * @return page image and properties, null if requested page is unavailable (e.g. requested next/prev page is out of document range)
	 */
	private BitmapInfo preparePageImage( int offset )
	{
		BackgroundThread.ensureBackground();
		log.v(""preparePageImage( ""+offset+"")"");
		//if (offset == 0) {
//			// DEBUG stack trace
//			try {
//				if (currentAutoScrollAnimation!=null)
//					log.v(""preparePageImage from autoscroll"");
//				throw new Exception(""stack trace"");
//			} catch (Exception e) {
//				Log.d(""cr3"", ""stack trace"", e);
//			}
		//}
		if ( invalidImages ) {
			if ( mCurrentPageInfo!=null )
				mCurrentPageInfo.recycle();
			mCurrentPageInfo = null;
			if ( mNextPageInfo!=null )
				mNextPageInfo.recycle();
			mNextPageInfo = null;
			invalidImages = false;
		}

		if ( internalDX==0 || internalDY==0 ) {
			internalDX=200;
			internalDY=300;
			doc.resize(internalDX, internalDY);
		}
		
		if (currentImageViewer != null)
			return currentImageViewer.prepareImage();

		PositionProperties currpos = doc.getPositionProps(null);
		
		boolean isPageView = currpos.pageMode!=0;
		
		BitmapInfo currposBitmap = null;
		if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(currpos) && mCurrentPageInfo.imageInfo == null)
			currposBitmap = mCurrentPageInfo;
		else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(currpos) && mNextPageInfo.imageInfo == null )
			currposBitmap = mNextPageInfo;
		if ( offset==0 ) {
			// Current page requested
			if ( currposBitmap!=null ) {
				if ( mNextPageInfo==currposBitmap ) {
					// reorder pages
					BitmapInfo tmp = mNextPageInfo;
					mNextPageInfo = mCurrentPageInfo;
					mCurrentPageInfo = tmp;
				}
				// found ready page image
				return mCurrentPageInfo;
			}
			if ( mCurrentPageInfo!=null ) {
				mCurrentPageInfo.recycle();
				mCurrentPageInfo = null;
			}
			BitmapInfo bi = new BitmapInfo();
	        bi.position = currpos;
			bi.bitmap = factory.get(internalDX, internalDY);
			doc.setBatteryState(mBatteryState);
			doc.getPageImage(bi.bitmap);
	        mCurrentPageInfo = bi;
	        //log.v(""Prepared new current page image "" + mCurrentPageInfo);
	        return mCurrentPageInfo;
		}
		if ( isPageView ) {
			// PAGES: one of next or prev pages requested, offset is specified as param 
			int cmd1 = offset > 0 ? ReaderCommand.DCMD_PAGEDOWN.nativeId : ReaderCommand.DCMD_PAGEUP.nativeId;
			int cmd2 = offset > 0 ? ReaderCommand.DCMD_PAGEUP.nativeId : ReaderCommand.DCMD_PAGEDOWN.nativeId;
			if ( offset<0 )
				offset = -offset;
			if ( doc.doCommand(cmd1, offset) ) {
				// can move to next page
				PositionProperties nextpos = doc.getPositionProps(null);
				BitmapInfo nextposBitmap = null;
				if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
					nextposBitmap = mCurrentPageInfo;
				else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
					nextposBitmap = mNextPageInfo;
				if ( nextposBitmap==null ) {
					// existing image not found in cache, overriding mNextPageInfo
					if ( mNextPageInfo!=null )
						mNextPageInfo.recycle();
					mNextPageInfo = null;
					BitmapInfo bi = new BitmapInfo();
			        bi.position = nextpos;
					bi.bitmap = factory.get(internalDX, internalDY);
					doc.setBatteryState(mBatteryState);
					doc.getPageImage(bi.bitmap);
			        mNextPageInfo = bi;
			        nextposBitmap = bi;
			        //log.v(""Prepared new current page image "" + mNextPageInfo);
				}
				// return back to previous page
				doc.doCommand(cmd2, offset);
				return nextposBitmap;
			} else {
				// cannot move to page: out of document range
				return null;
			}
		} else {
			// SCROLL next or prev page requested, with pixel offset specified
			int y = currpos.y + offset;
			if ( doc.doCommand(ReaderCommand.DCMD_GO_POS.nativeId, y) ) {
				PositionProperties nextpos = doc.getPositionProps(null);
				BitmapInfo nextposBitmap = null;
				if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
					nextposBitmap = mCurrentPageInfo;
				else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
					nextposBitmap = mNextPageInfo;
				if ( nextposBitmap==null ) {
					// existing image not found in cache, overriding mNextPageInfo
					if ( mNextPageInfo!=null )
						mNextPageInfo.recycle();
					mNextPageInfo = null;
					BitmapInfo bi = new BitmapInfo();
			        bi.position = nextpos;
					bi.bitmap = factory.get(internalDX, internalDY);
					doc.setBatteryState(mBatteryState);
					doc.getPageImage(bi.bitmap);
			        mNextPageInfo = bi;
			        nextposBitmap = bi;
				}
				// return back to prev position
				doc.doCommand(ReaderCommand.DCMD_GO_POS.nativeId, currpos.y);
				return nextposBitmap;
			} else {
				return null;
			}
		}
		
	}
	
	private int lastDrawTaskId = 0;
	private class DrawPageTask extends Task {
		final int id;
		BitmapInfo bi;
		Runnable doneHandler;
		boolean isPartially;
		DrawPageTask(Runnable doneHandler, boolean isPartially)
		{
//			// DEBUG stack trace
//			try {
//				throw new Exception(""DrawPageTask() stack trace"");
//			} catch (Exception e) {
//				Log.d(""cr3"", ""stack trace"", e);
//			}
			this.id = ++lastDrawTaskId;
			this.doneHandler = doneHandler;
			this.isPartially = isPartially;
			cancelGc();
		}
		public void work() {
			BackgroundThread.ensureBackground();
			if ( this.id!=lastDrawTaskId ) {
				log.d(""skipping duplicate drawPage request"");
				return;
			}
			nextHiliteId++;
			if ( currentAnimation!=null ) {
				log.d(""skipping drawPage request while scroll animation is in progress"");
				return;
			}
			log.e(""DrawPageTask.work(""+internalDX+"",""+internalDY+"")"");
			bi = preparePageImage(0);
			if ( bi!=null ) {
				draw(isPartially);
			}
		}
		@Override
		public void done()
		{
			BackgroundThread.ensureGUI();
//			log.d(""drawPage : bitmap is ready, invalidating view to draw new bitmap"");
//			if ( bi!=null ) {
//				setBitmap( bi.bitmap );
//				invalidate();
//			}
//    		if (mOpened)
   			mEngine.hideProgress();
   			if ( doneHandler!=null )
   				doneHandler.run();
   			scheduleGc();
		}
		@Override
		public void fail(Exception e) {
   			mEngine.hideProgress();
		}
	};
	
	static class ReaderSurfaceView extends SurfaceView {
		public ReaderSurfaceView( Context context )
		{
			super(context);
		}
	}
	
	// SurfaceView callbacks
	@Override
	public void surfaceChanged(SurfaceHolder holder, int format, int width,
			int height) {
		log.i(""surfaceChanged("" + width + "", "" + height + "")"");
		drawPage();
	}

	boolean mSurfaceCreated = false;
	@Override
	public void surfaceCreated(SurfaceHolder holder) {
		log.i(""surfaceCreated()"");
		mSurfaceCreated = true;
		drawPage();
	}

	@Override
	public void surfaceDestroyed(SurfaceHolder holder) {
		log.i(""surfaceDestroyed()"");
		mSurfaceCreated = false;
	}
	
	enum AnimationType {
		SCROLL, // for scroll mode
		PAGE_SHIFT, // for simple page shift
	}

	
	
	private ViewAnimationControl currentAnimation = null;

	private int pageFlipAnimationSpeedMs = DEF_PAGE_FLIP_MS; // if 0 : no animation
	private int pageFlipAnimationMode = PAGE_ANIMATION_SLIDE2; //PAGE_ANIMATION_PAPER; // if 0 : no animation
//	private void animatePageFlip( final int dir ) {
//		animatePageFlip(dir, null);
//	}
	private void animatePageFlip( final int dir, final Runnable onFinishHandler )
	{
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				BackgroundThread.ensureBackground();
				if ( currentAnimation==null ) {
					PositionProperties currPos = doc.getPositionProps(null);
					if ( currPos==null )
						return;
					int w = currPos.pageWidth;
					int h = currPos.pageHeight;
					int dir2 = dir;
//					if ( currPos.pageMode==2 )
//						if ( dir2==1 )
//							dir2 = 2;
//						else if ( dir2==-1 ) 
//							dir2 = -2;
					int speed = pageFlipAnimationSpeedMs;
					if ( onFinishHandler!=null )
						speed = pageFlipAnimationSpeedMs / 2;
					if ( currPos.pageMode!=0 ) {
						int fromX = dir2>0 ? w : 0;
						int toX = dir2>0 ? 0 : w;
						new PageViewAnimation(fromX, w, dir2);
						if (currentAnimation != null) {
							if (currentAnimation != null) {
								nextHiliteId++;
								hiliteRect = null;
								currentAnimation.update(toX, h/2);
								currentAnimation.move(speed, true);
								currentAnimation.stop(-1, -1);
							}
							if ( onFinishHandler!=null )
								BackgroundThread.guiExecutor.execute(onFinishHandler);
						}
					} else {
						//new ScrollViewAnimation(startY, maxY);
						int fromY = dir>0 ? h*7/8 : 0;
						int toY = dir>0 ? 0 : h*7/8;
						new ScrollViewAnimation(fromY, h);
						if (currentAnimation != null) {
							if (currentAnimation != null) {
								nextHiliteId++;
								hiliteRect = null;
								currentAnimation.update(w/2, toY);
								currentAnimation.move(speed, true);
								currentAnimation.stop(-1, -1);
							}
							if ( onFinishHandler!=null )
								BackgroundThread.guiExecutor.execute(onFinishHandler);
						}
					}
				}
			}
		});
	}
	
	static private Rect tapZoneBounds( int startX, int startY, int maxX, int maxY ) {
		if ( startX<0 )
			startX=0;
		if ( startY<0 )
			startY = 0;
		if ( startX>maxX )
			startX = maxX;
		if ( startY>maxY)
			startY = maxY;
		int dx = (maxX + 2) / 3;
		int dy = (maxY + 2) / 3;
		int x0 = startX / dx * dx; 
		int y0 = startY / dy * dy;
		return new Rect(x0, y0, x0+dx, y0+dy);
	}
	
	volatile private int nextHiliteId = 0;
	private final static int HILITE_RECT_ALPHA = 32;
	private Rect hiliteRect = null;
	private void unhiliteTapZone() {
		hiliteTapZone( false, 0, 0, getWidth(), getHeight() );
	}
	private void hiliteTapZone( final boolean hilite, final int startX, final int startY, final int maxX, final int maxY )
	{
		if (DEBUG_ANIMATION) log.d(""highliteTapZone(""+startX + "", "" + startY+"")"");
		final int myHiliteId = ++nextHiliteId;
		int txcolor = mSettings.getColor(PROP_FONT_COLOR, Color.BLACK);
		final int color = (txcolor & 0xFFFFFF) | (HILITE_RECT_ALPHA<<24);
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( myHiliteId != nextHiliteId || (!hilite && hiliteRect==null) )
					return;
				
				if (currentAutoScrollAnimation!=null) {
					hiliteRect = null;
					return;
				}
				
				BackgroundThread.ensureBackground();
				final BitmapInfo pageImage = preparePageImage(0);
				if ( pageImage!=null && pageImage.bitmap!=null && pageImage.position!=null ) {
					//PositionProperties currPos = pageImage.position;
					final Rect rc = hilite ? tapZoneBounds( startX, startY, maxX, maxY ) : hiliteRect;
					if ( hilite )
						hiliteRect = rc;
					else
						hiliteRect = null;
					if ( rc!=null )
					drawCallback( new DrawCanvasCallback() {
						@Override
						public void drawTo(Canvas canvas) {
				    		if ( mInitialized && mCurrentPageInfo!=null ) {
				        		log.d(""onDraw() -- drawing page image"");
				        		drawDimmedBitmap(canvas, mCurrentPageInfo.bitmap, rc, rc);
				    			if ( hilite ) {
					    			Paint p = new Paint();
					    			p.setColor(color);
					    			if ( true ) {
					    				canvas.drawRect(new Rect(rc.left, rc.top, rc.right-2, rc.top+2), p);
					    				canvas.drawRect(new Rect(rc.left, rc.top+2, rc.left+2, rc.bottom-2), p);
					    				canvas.drawRect(new Rect(rc.right-2-2, rc.top+2, rc.right-2, rc.bottom-2), p);
					    				canvas.drawRect(new Rect(rc.left+2, rc.bottom-2-2, rc.right-2-2, rc.bottom-2), p);
					    			} else {
					    				canvas.drawRect(rc, p);
					    			}
				    			}
				    		}
						}
						
					}, rc, false);
				}
			}
			
		});
	}
	private void scheduleUnhilite( int delay ) {
		final int myHiliteId = nextHiliteId;
		mBackThread.postGUI(new Runnable() {
			@Override
			public void run() {
				if ( myHiliteId == nextHiliteId && hiliteRect!=null )
					unhiliteTapZone(); 
			}
		}, delay);
	}
	
	int currentBrightnessValueIndex = -1;
	private void startBrightnessControl(final int startX, final int startY)
	{
		currentBrightnessValueIndex = -1;
		updateBrightnessControl(startX, startY);
	}
	private void updateBrightnessControl(final int x, final int y) {
		int n = OptionsDialog.mBacklightLevels.length;
		int index = n - 1 - y * n / getHeight();
		if ( index<0 )
			index = 0;
		else if ( index>=n )
			index = n-1;
		if ( index != currentBrightnessValueIndex ) {
			currentBrightnessValueIndex = index;
			int newValue = OptionsDialog.mBacklightLevels[currentBrightnessValueIndex]; 
			mActivity.setScreenBacklightLevel(newValue);
		}
		
	}
	private void stopBrightnessControl(final int x, final int y) {
		if ( currentBrightnessValueIndex>=0 ) {
			if ( x>=0 && y>=0 ) {
				updateBrightnessControl(x, y);
			}
			mSettings.setInt(PROP_APP_SCREEN_BACKLIGHT, OptionsDialog.mBacklightLevels[currentBrightnessValueIndex]);
			OptionsDialog.mBacklightLevelsTitles[0] = mActivity.getString(R.string.options_app_backlight_screen_default);
			if ( showBrightnessFlickToast ) {
				String s = OptionsDialog.mBacklightLevelsTitles[currentBrightnessValueIndex];
				mActivity.showToast(s);
			}
			mActivity.saveSettings(mSettings);
			currentBrightnessValueIndex = -1;
		}
	}
	private static final boolean showBrightnessFlickToast = false;


	private void startAnimation( final int startX, final int startY, final int maxX, final int maxY )
	{
		if (DEBUG_ANIMATION) log.d(""startAnimation(""+startX + "", "" + startY+"")"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				BackgroundThread.ensureBackground();
				PositionProperties currPos = doc.getPositionProps(null);
				if ( currPos!=null && currPos.pageMode!=0 ) {
					//int dir = startX > maxX/2 ? currPos.pageMode : -currPos.pageMode;
					int dir = startX > maxX/2 ? 1 : -1;
					int sx = startX;
					if ( dir<0 )
						sx = 0;
					new PageViewAnimation(sx, maxX, dir);
				} else {
					new ScrollViewAnimation(startY, maxY);
				}
				if ( currentAnimation!=null ) {
					nextHiliteId++;
					hiliteRect = null;
				}
			}
			
		});
	}

	private final static boolean DEBUG_ANIMATION = false;
	private volatile int updateSerialNumber = 0;
	private void updateAnimation( final int x, final int y )
	{
		if (DEBUG_ANIMATION) log.d(""updateAnimation(""+x + "", "" + y+"")"");
		final int serial = ++updateSerialNumber;
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( currentAnimation!=null ) {
					currentAnimation.update(x, y);
					if ( serial==updateSerialNumber ) //|| serial==updateSerialNumber-1 
						currentAnimation.animate();
				}
			}
		});
		try {
			// give a chance to background thread to process event faster
			Thread.sleep(0);
		} catch ( InterruptedException e ) {
			// ignore
		}
	}
	
	private void stopAnimation( final int x, final int y )
	{
		if (DEBUG_ANIMATION) log.d(""stopAnimation(""+x+"", ""+y+"")"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( currentAnimation!=null ) {
					currentAnimation.stop(x, y);
				}
			}
			
		});
	}

	private int animationSerialNumber = 0;
	private void scheduleAnimation()
	{
		final int serial = ++animationSerialNumber; 
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( serial!=animationSerialNumber )
					return;
				if ( currentAnimation!=null ) {
					currentAnimation.animate();
				}
			}
		});
	}
	
	interface ViewAnimationControl
	{
		public void update( int x, int y );
		public void stop( int x, int y );
		public void animate();
		public void move( int duration, boolean accelerated );
		public boolean isStarted();
		abstract void draw( Canvas canvas );
	}

//	private Object surfaceLock = new Object(); 

	private static final int[] accelerationShape = new int[] {
		0, 6, 24, 54, 95, 146, 206, 273, 345, 421, 500, 578, 654, 726, 793, 853, 904, 945, 975, 993, 1000  
	};
	static public int accelerate( int x0, int x1, int x )
	{
		if ( x<x0 )
			x = x0;
		if (x>x1)
			x = x1;
		int intervals = accelerationShape.length - 1;
		int pos = 100 * intervals * (x - x0) / (x1-x0);
		int interval = pos / 100;
		int part = pos % 100;
		if ( interval<0 )
			interval = 0;
		else if ( interval>intervals )
			interval = intervals;
		int y = interval==intervals ? 100000 : accelerationShape[interval]*100 + (accelerationShape[interval+1]-accelerationShape[interval]) * part;
		return x0 + (x1 - x0) * y / 100000;
	}

	private interface DrawCanvasCallback {
		public void drawTo( Canvas c );
	}
	private void drawCallback( DrawCanvasCallback callback, Rect rc, boolean isPartially )
	{
		if ( !mSurfaceCreated )
			return;
		//synchronized(surfaceLock) { }
		//log.v(""draw() - in thread "" + Thread.currentThread().getName());
		final SurfaceHolder holder = getHolder();
		//log.v(""before synchronized(surfaceLock)"");
		if ( holder!=null )
		//synchronized(surfaceLock) 
		{
			Canvas canvas = null;
			long startTs = android.os.SystemClock.uptimeMillis();
			try {
				canvas = holder.lockCanvas(rc);
				//log.v(""before draw(canvas)"");
				if ( canvas!=null ) {
					if (DeviceInfo.EINK_SCREEN){
						EinkScreen.PrepareController(this, isPartially);
					}
					callback.drawTo(canvas);
				}
			} finally {
				//log.v(""exiting finally"");
				if ( canvas!=null && getHolder()!=null ) {
					//log.v(""before unlockCanvasAndPost"");
					if ( canvas!=null && holder!=null ) {
						holder.unlockCanvasAndPost(canvas);
						//if ( rc==null ) {
							long endTs = android.os.SystemClock.uptimeMillis();
							updateAnimationDurationStats(endTs - startTs);
						//}
					}
					//log.v(""after unlockCanvasAndPost"");
				}
			}
		}
		//log.v(""exiting draw()"");
	}
	
	abstract class ViewAnimationBase implements ViewAnimationControl {
		//long startTimeStamp;
		boolean started;
		public boolean isStarted()
		{
			return started;
		}
		ViewAnimationBase()
		{
			//startTimeStamp = android.os.SystemClock.uptimeMillis();
			cancelGc();
		}
		public void close()
		{
			currentAnimation = null;
			scheduleGc();
		}

		

		public void draw()
		{
			draw(false);
		}

		public void draw(boolean isPartially)
		{
			drawCallback( new DrawCanvasCallback() {
				@Override
				public void drawTo(Canvas c) {
				//	long startTs = android.os.SystemClock.uptimeMillis();
					draw(c);
				}
			}, null, isPartially);
		}
	}
	
	//private static final int PAGE_ANIMATION_DURATION = 3000;
	class ScrollViewAnimation extends ViewAnimationBase {
		int startY;
		int maxY;
		int pointerStartPos;
		int pointerDestPos;
		int pointerCurrPos;
		BitmapInfo image1;
		BitmapInfo image2;
		ScrollViewAnimation( int startY, int maxY )
		{
			super();
			this.startY = startY;
			this.maxY = maxY;
			long start = android.os.SystemClock.uptimeMillis();
			log.v(""ScrollViewAnimation -- creating: drawing two pages to buffer"");
			PositionProperties currPos = doc.getPositionProps(null);
			int pos = currPos.y;
			int pos0 = pos - (maxY - startY);
			if ( pos0<0 )
				pos0 = 0;
			pointerStartPos = pos;
			pointerCurrPos = pos;
			pointerDestPos = startY;
			doc.doCommand(ReaderCommand.DCMD_GO_POS.nativeId, pos0);
			image1 = preparePageImage(0);
			if (image1 == null) {
				log.v(""ScrollViewAnimation -- not started: image is null"");
				return;
			}
			image2 = preparePageImage(image1.position.pageHeight);
			doc.doCommand(ReaderCommand.DCMD_GO_POS.nativeId, pos);
			if (image2 == null) {
				log.v(""ScrollViewAnimation -- not started: image is null"");
				return;
			}
			long duration = android.os.SystemClock.uptimeMillis() - start;
			log.v(""ScrollViewAnimation -- created in "" + duration + "" millis"");
			currentAnimation = this;
		}
		
		@Override
		public void stop(int x, int y) {
			//if ( started ) {
				if ( y!=-1 ) {
					int delta = startY - y;
					pointerCurrPos = pointerStartPos + delta;
				}
				pointerDestPos = pointerCurrPos;
				draw();
				doc.doCommand(ReaderCommand.DCMD_GO_POS.nativeId, pointerDestPos);
			//}
			close();
		}

		@Override
		public void move( int duration, boolean accelerated  ) {
			if ( duration>0  && pageFlipAnimationSpeedMs!=0 ) {
				int steps = (int)(duration / getAvgAnimationDrawDuration()) + 2;
				int x0 = pointerCurrPos;
				int x1 = pointerDestPos;
				if ( (x0-x1)<10 && (x0-x1)>-10 )
					steps = 2;
				for ( int i=1; i<steps; i++ ) {
					int x = x0 + (x1-x0) * i / steps;
					pointerCurrPos = accelerated ? accelerate( x0, x1, x ) : x; 
					draw();
				}
			}
			pointerCurrPos = pointerDestPos; 
			draw();
		}

		@Override
		public void update(int x, int y) {
			int delta = startY - y;
			pointerDestPos = pointerStartPos + delta;
		}

		public void animate()
		{
			//log.d(""animate() is called"");
			if ( pointerDestPos != pointerCurrPos ) {
				if ( !started )
					started = true;
				if ( pageFlipAnimationSpeedMs==0 )
					pointerCurrPos = pointerDestPos;
				else {
					int delta = pointerCurrPos-pointerDestPos;
					if ( delta<0 )
						delta = -delta;
					long avgDraw = getAvgAnimationDrawDuration();
					//int maxStep = (int)(maxY * PAGE_ANIMATION_DURATION / avgDraw);
					int maxStep = pageFlipAnimationSpeedMs > 0 ? (int)(maxY * 1000 / avgDraw / pageFlipAnimationSpeedMs) : maxY;
					int step;
					if ( delta > maxStep * 2 )
						step = maxStep;
					else
						step = (delta + 3) / 4;
					//int step = delta<3 ? 1 : (delta<5 ? 2 : (delta<10 ? 3 : (delta<15 ? 6 : (delta<25 ? 10 : (delta<50 ? 15 : 30))))); 
					if ( pointerCurrPos<pointerDestPos )
						pointerCurrPos+=step;
					else if ( pointerCurrPos>pointerDestPos )
						pointerCurrPos-=step;
					log.d(""animate(""+pointerCurrPos + "" => "" + pointerDestPos + ""  step="" + step + "")"");
				}
				//pointerCurrPos = pointerDestPos;
				draw();
				if ( pointerDestPos != pointerCurrPos )
					scheduleAnimation();
			}
		}

		public void draw(Canvas canvas)
		{
//			BitmapInfo image1 = mCurrentPageInfo;
//			BitmapInfo image2 = mNextPageInfo;
			if (image1 == null || image1.isReleased() || image2 == null || image2.isReleased())
				return;
			int h = image1.position.pageHeight;
			int rowsFromImg1 = image1.position.y + h - pointerCurrPos;
			int rowsFromImg2 = h - rowsFromImg1;
    		Rect src1 = new Rect(0, h-rowsFromImg1, mCurrentPageInfo.bitmap.getWidth(), h);
    		Rect dst1 = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), rowsFromImg1);
    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			if (image2 != null) {
	    		Rect src2 = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), rowsFromImg2);
	    		Rect dst2 = new Rect(0, rowsFromImg1, mCurrentPageInfo.bitmap.getWidth(), h);
	    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
			}
			//log.v(""anim.drawScroll( pos="" + pointerCurrPos + "", "" + src1 + ""=>"" + dst1 + "", "" + src2 + ""=>"" + dst2 + "" )"");
		}
	}

	private final static int SIN_TABLE_SIZE = 1024;
	private final static int SIN_TABLE_SCALE = 0x10000;
	private final static int PI_DIV_2 = (int)(Math.PI / 2 * SIN_TABLE_SCALE);
	/// sin table, for 0..PI/2
	private static int[] SIN_TABLE = new int[SIN_TABLE_SIZE+1];
	private static int[] ASIN_TABLE = new int[SIN_TABLE_SIZE+1];
	// mapping of 0..1 shift to angle
	private static int[] SRC_TABLE = new int[SIN_TABLE_SIZE+1];
	// mapping of 0..1 shift to sin(angle)
	private static int[] DST_TABLE = new int[SIN_TABLE_SIZE+1];
	// for dx=0..1 find such alpha (0..pi/2) that alpha - sin(alpha) = dx  
	private static double shiftfn( double dx ) {
		double a = 0;
		double b = Math.PI/2;
		double c = 0;
		for ( int i=0; i<15; i++ ) {
			c = (a + b) / 2;
			double cq = c - Math.sin(c);
			if ( cq < dx )
				a = c;
			else
				b = c;
		}
		return c;
	}
	static {
		for ( int i=0; i<=SIN_TABLE_SIZE; i++ ) {
			double angle = Math.PI / 2 * i / SIN_TABLE_SIZE;
			int s = (int)Math.round(Math.sin(angle) * SIN_TABLE_SCALE);
			SIN_TABLE[i] = s;
			double x = (double)i / SIN_TABLE_SIZE;
			s = (int)Math.round(Math.asin(x) * SIN_TABLE_SCALE);
			ASIN_TABLE[i] = s;
			
			double dx = i * (Math.PI/2 - 1.0) / SIN_TABLE_SIZE;
			angle = shiftfn( dx );
			SRC_TABLE[i] = (int)Math.round(angle * SIN_TABLE_SCALE);
			DST_TABLE[i] = (int)Math.round(Math.sin(angle) * SIN_TABLE_SCALE);
		}
	}
	
	class PageViewAnimation extends ViewAnimationBase {
		int startX;
		int maxX;
		int page1;
		int page2;
		int direction;
		int currShift;
		int destShift;
		int pageCount;
		Paint divPaint;
		Paint[] shadePaints;
		Paint[] hilitePaints;
		private final boolean naturalPageFlip; 
		private final boolean flipTwoPages; 

		BitmapInfo image1;
		BitmapInfo image2;
		
		PageViewAnimation( int startX, int maxX, int direction )
		{
			super();
			this.startX = startX;
			this.maxX = maxX;
			this.direction = direction;
			this.currShift = 0;
			this.destShift = 0;
			this.naturalPageFlip = (pageFlipAnimationMode==PAGE_ANIMATION_PAPER);
			this.flipTwoPages = (pageFlipAnimationMode==PAGE_ANIMATION_SLIDE2);
			
			long start = android.os.SystemClock.uptimeMillis();
			log.v(""PageViewAnimation -- creating: drawing two pages to buffer"");
			
			PositionProperties currPos = mCurrentPageInfo.position;
			if ( currPos==null )
				currPos = doc.getPositionProps(null);
			page1 = currPos.pageNumber;
			page2 = currPos.pageNumber + direction;
			if ( page2<0 || page2>=currPos.pageCount) {
				currentAnimation = null;
				return;
			}
			this.pageCount = currPos.pageMode;
			image1 = preparePageImage(0);
			image2 = preparePageImage(direction);
			if ( image1==null || image2==null ) {
				log.v(""PageViewAnimation -- cannot start animation: page image is null"");
				return;
			}
			if ( page1==page2 ) {
				log.v(""PageViewAnimation -- cannot start animation: not moved"");
				return;
			}
			page2 = image2.position.pageNumber;
			currentAnimation = this;
			divPaint = new Paint();
			divPaint.setStyle(Paint.Style.FILL);
			divPaint.setColor(Color.argb(128, 128, 128, 128));
			final int numPaints = 16;
			shadePaints = new Paint[numPaints];
			hilitePaints = new Paint[numPaints];
			for ( int i=0; i<numPaints; i++ ) {
				shadePaints[i] = new Paint();
				hilitePaints[i] = new Paint();
				hilitePaints[i].setStyle(Paint.Style.FILL);
				shadePaints[i].setStyle(Paint.Style.FILL);
				if ( mActivity.isNightMode() ) {
					shadePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 0, 0, 0));
					hilitePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 128, 128, 128));
				} else {
					shadePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 0, 0, 0));
					hilitePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 255, 255, 255));
				}
			}

			
			long duration = android.os.SystemClock.uptimeMillis() - start;
			log.d(""PageViewAnimation -- created in "" + duration + "" millis"");
		}
		
		private void drawGradient( Canvas canvas, Rect rc, Paint[] paints, int startIndex, int endIndex ) {
			int n = (startIndex<endIndex) ? endIndex-startIndex+1 : startIndex-endIndex + 1;
			int dir = (startIndex<endIndex) ? 1 : -1;
			int dx = rc.right - rc.left;
			Rect rect = new Rect(rc);
			for ( int i=0; i<n; i++ ) {
				int index = startIndex + i*dir;
				int x1 = rc.left + dx*i/n;
				int x2 = rc.left + dx*(i+1)/n;
				if ( x2>rc.right )
					x2 = rc.right;
				rect.left = x1;
				rect.right = x2;
				if ( x2>x1 ) {
					canvas.drawRect(rect, paints[index]);
				}
			}
		}
		
		private void drawShadow( Canvas canvas, Rect rc ) {
			drawGradient(canvas, rc, shadePaints, shadePaints.length/2, shadePaints.length/10);
		}
		
		private final static int DISTORT_PART_PERCENT = 30;
		private void drawDistorted( Canvas canvas, Bitmap bmp, Rect src, Rect dst, int dir) {
			int srcdx = src.width();
			int dstdx = dst.width();
			int dx = srcdx - dstdx;
			int maxdistortdx = srcdx * DISTORT_PART_PERCENT / 100;
			int maxdx = maxdistortdx * (PI_DIV_2 - SIN_TABLE_SCALE) / SIN_TABLE_SCALE;
			int maxdistortsrc = maxdistortdx * PI_DIV_2 / SIN_TABLE_SCALE;
			
			int distortdx = dx < maxdistortdx ? dx : maxdistortdx;
			int distortsrcstart = -1;
			int distortsrcend = -1;
			int distortdststart = -1;
			int distortdstend = -1;
			int distortanglestart = -1;
			int distortangleend = -1;
			int normalsrcstart = -1;
			int normalsrcend = -1;
			int normaldststart = -1;
			int normaldstend = -1;
			
			if ( dx < maxdx ) {
				// start
				int index = dx>=0 ? dx * SIN_TABLE_SIZE / maxdx : 0;
				if (index > DST_TABLE.length)
					index = DST_TABLE.length;
				int dstv = DST_TABLE[index] * maxdistortdx / SIN_TABLE_SCALE;
				distortdststart = distortsrcstart = dstdx - dstv;
				distortsrcend = srcdx;
				distortdstend = dstdx;
				normalsrcstart = normaldststart = 0;
				normalsrcend = distortsrcstart;
				normaldstend = distortdststart;
				distortanglestart = 0;
				distortangleend = SRC_TABLE[index];
				distortdx = maxdistortdx;
			} else if (dstdx>maxdistortdx) {
				// middle
				distortdststart = distortsrcstart = dstdx - maxdistortdx;
				distortsrcend = distortsrcstart + maxdistortsrc;
				distortdstend = dstdx;
				normalsrcstart = normaldststart = 0;
				normalsrcend = distortsrcstart;
				normaldstend = distortdststart;
				distortanglestart = 0;
				distortangleend = PI_DIV_2;
			} else {
				// end
				normalsrcstart = normaldststart = normalsrcend = normaldstend = -1;
				distortdx = dstdx;
				distortsrcstart = 0;
				int n = maxdistortdx >= dstdx ? maxdistortdx - dstdx : 0;
				distortsrcend = ASIN_TABLE[SIN_TABLE_SIZE * n/maxdistortdx ] * maxdistortsrc / SIN_TABLE_SCALE;
				distortdststart = 0;
				distortdstend = dstdx;
				distortangleend = PI_DIV_2; 
				n = maxdistortdx >= distortdx ? maxdistortdx - distortdx : 0;
				distortanglestart = ASIN_TABLE[SIN_TABLE_SIZE * (maxdistortdx - distortdx)/maxdistortdx ];
			}
			
			Rect srcrc = new Rect(src);
			Rect dstrc = new Rect(dst);
			if ( normalsrcstart<normalsrcend ) {
				if ( dir>0 ) {
					srcrc.left = src.left + normalsrcstart;
					srcrc.right = src.left + normalsrcend;
					dstrc.left = dst.left + normaldststart;
					dstrc.right = dst.left + normaldstend;
				} else {
					srcrc.right = src.right - normalsrcstart;
					srcrc.left = src.right - normalsrcend;
					dstrc.right = dst.right - normaldststart;
					dstrc.left = dst.right - normaldstend;
				}
				drawDimmedBitmap(canvas, bmp, srcrc, dstrc);
			}
			if ( distortdststart<distortdstend ) {
				int n = distortdx / 5 + 1;
				int dst0 = SIN_TABLE[distortanglestart * SIN_TABLE_SIZE / PI_DIV_2] * maxdistortdx / SIN_TABLE_SCALE; 
				int src0 = distortanglestart * maxdistortdx / SIN_TABLE_SCALE;
				for ( int i=0; i<n; i++ ) {
					int angledelta = distortangleend - distortanglestart;
					int startangle = distortanglestart + i * angledelta / n;
					int endangle = distortanglestart + (i+1) * angledelta / n;
					int src1 = startangle * maxdistortdx / SIN_TABLE_SCALE - src0;
					int src2 = endangle * maxdistortdx / SIN_TABLE_SCALE - src0;
					int dst1 = SIN_TABLE[startangle * SIN_TABLE_SIZE / PI_DIV_2] * maxdistortdx / SIN_TABLE_SCALE - dst0;
					int dst2 = SIN_TABLE[endangle * SIN_TABLE_SIZE / PI_DIV_2] * maxdistortdx / SIN_TABLE_SCALE - dst0;
					int hiliteIndex = startangle * hilitePaints.length / PI_DIV_2;
					Paint[] paints;
					if ( dir>0 ) {
						dstrc.left = dst.left + distortdststart + dst1; 
						dstrc.right = dst.left + distortdststart + dst2;
						srcrc.left = src.left + distortsrcstart + src1;
						srcrc.right = src.left + distortsrcstart + src2;
						paints = hilitePaints;
					} else {
						dstrc.right = dst.right - distortdststart - dst1; 
						dstrc.left = dst.right - distortdststart - dst2;
						srcrc.right = src.right - distortsrcstart - src1;
						srcrc.left = src.right - distortsrcstart - src2;
						paints = shadePaints;
					}
					drawDimmedBitmap(canvas, bmp, srcrc, dstrc);
					canvas.drawRect(dstrc, paints[hiliteIndex]);
				}
			}
		}
		
		@Override
		public void move( int duration, boolean accelerated ) {
			if ( duration > 0 && pageFlipAnimationSpeedMs!=0 ) {
				int steps = (int)(duration / getAvgAnimationDrawDuration()) + 2;
				int x0 = currShift;
				int x1 = destShift;
				if ( (x0-x1)<10 && (x0-x1)>-10 )
					steps = 2;
				for ( int i=1; i<steps; i++ ) {
					int x = x0 + (x1-x0) * i / steps;
					currShift = accelerated ? accelerate( x0, x1, x ) : x;
					draw();
				}
			}
			currShift = destShift;
			draw();
		}

		@Override
		public void stop(int x, int y) {
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.stop("" + x + "", "" + y + "")"");
			//if ( started ) {
				boolean moved = false;
				if ( x!=-1 ) {
					int threshold = mActivity.getPalmTipPixels() * 7/8;
					if ( direction>0 ) {
						// |  <=====  |
						int dx = startX - x; 
						if ( dx>threshold )
							moved = true;
					} else {
						// |  =====>  |
						int dx = x - startX; 
						if ( dx>threshold )
							moved = true;
					}
					int duration;
					if ( moved ) {
						destShift = maxX;
						duration = 300; // 500 ms forward
					} else {
						destShift = 0;
						duration = 200; // 200 ms cancel
					}
					move( duration, false );
				} else {
					moved = true;
				}
				doc.doCommand(ReaderCommand.DCMD_GO_PAGE_DONT_SAVE_HISTORY.nativeId, moved ? page2 : page1);
			//}
			close();
			// preparing images for next page flip
			preparePageImage(0);
			preparePageImage(direction);
			//if ( started )
			//	drawPage();
		}

		@Override
		public void update(int x, int y) {
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.update("" + x + "", "" + y + "")"");
			int delta = direction>0 ? startX - x : x - startX;
			if ( delta<=0 )
				destShift = 0;
			else if ( delta<maxX )
				destShift = delta;
			else
				destShift = maxX;
		}

		public void animate()
		{
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.animate(""+currShift + "" => "" + destShift + "") speed="" + pageFlipAnimationSpeedMs);
			//log.d(""animate() is called"");
			if ( currShift != destShift ) {
				started = true;
				if ( pageFlipAnimationSpeedMs==0 )
					currShift = destShift;
				else {
					int delta = currShift - destShift;
					if ( delta<0 )
						delta = -delta;
					long avgDraw = getAvgAnimationDrawDuration();
					int maxStep = pageFlipAnimationSpeedMs > 0 ? (int)(maxX * 1000 / avgDraw / pageFlipAnimationSpeedMs) : maxX;
					int step;
					if ( delta > maxStep * 2 )
						step = maxStep;
					else
						step = (delta + 3) / 4;
					//int step = delta<3 ? 1 : (delta<5 ? 2 : (delta<10 ? 3 : (delta<15 ? 6 : (delta<25 ? 10 : (delta<50 ? 15 : 30))))); 
					if ( currShift < destShift )
						currShift+=step;
					else if ( currShift > destShift )
						currShift-=step;
					if (DEBUG_ANIMATION) log.v(""PageViewAnimation.animate(""+currShift + "" => "" + destShift + ""  step="" + step + "")"");
				}
				//pointerCurrPos = pointerDestPos;
				draw();
				if ( currShift != destShift )
					scheduleAnimation();
			}
		}

		public void draw(Canvas canvas)
		{
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.draw(""+currShift + "")"");
//			BitmapInfo image1 = mCurrentPageInfo;
//			BitmapInfo image2 = mNextPageInfo;
			if (image1.isReleased() || image2.isReleased())
				return;
			int w = image1.bitmap.getWidth(); 
			int h = image1.bitmap.getHeight();
			int div;
			if ( direction > 0 ) {
				// FORWARD
				div = w-currShift;
				Rect shadowRect = new Rect(div, 0, div+w/10, h);
				if ( naturalPageFlip ) {
					if ( this.pageCount==2 ) {
						int w2 = w/2;
						if ( div<w2 ) {
							// left - part of old page
				    		Rect src1 = new Rect(0, 0, div, h);
				    		Rect dst1 = new Rect(0, 0, div, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
							// left, resized part of new page
				    		Rect src2 = new Rect(0, 0, w2, h);
				    		Rect dst2 = new Rect(div, 0, w2, h);
				    		//canvas.drawBitmap(image2.bitmap, src2, dst2, null);
							drawDistorted(canvas, image2.bitmap, src2, dst2, -1);
							// right, new page
				    		Rect src3 = new Rect(w2, 0, w, h);
				    		Rect dst3 = new Rect(w2, 0, w, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src3, dst3);

						} else {
							// left - old page
				    		Rect src1 = new Rect(0, 0, w2, h);
				    		Rect dst1 = new Rect(0, 0, w2, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
							// right, resized old page
				    		Rect src2 = new Rect(w2, 0, w, h);
				    		Rect dst2 = new Rect(w2, 0, div, h);
				    		//canvas.drawBitmap(image1.bitmap, src2, dst2, null);
							drawDistorted(canvas, image1.bitmap, src2, dst2, 1);
							// right, new page
				    		Rect src3 = new Rect(div, 0, w, h);
				    		Rect dst3 = new Rect(div, 0, w, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src3, dst3);

							if ( div>0 && div<w )
								drawShadow( canvas, shadowRect );
						}
					} else {
			    		Rect src1 = new Rect(0, 0, w, h);
			    		Rect dst1 = new Rect(0, 0, w-currShift, h);
			    		//log.v(""drawing "" + image1);
						//canvas.drawBitmap(image1.bitmap, src1, dst1, null);
						drawDistorted(canvas, image1.bitmap, src1, dst1, 1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(w-currShift, 0, w, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);

						if ( div>0 && div<w )
							drawShadow( canvas, shadowRect );
					}
				} else {
					if ( flipTwoPages ) {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(0, 0, w-currShift, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(0, 0, currShift, h);
			    		Rect dst2 = new Rect(w-currShift, 0, w, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					} else {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(0, 0, w-currShift, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(w-currShift, 0, w, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					}
				}
			} else {
				// BACK
				div = currShift;
				Rect shadowRect = new Rect(div, 0, div+10, h);
				if ( naturalPageFlip ) {
					if ( this.pageCount==2 ) {
						int w2 = w/2;
						if ( div<w2 ) {
							// left - part of old page
				    		Rect src1 = new Rect(0, 0, div, h);
				    		Rect dst1 = new Rect(0, 0, div, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src1, dst1);
							// left, resized part of new page
				    		Rect src2 = new Rect(0, 0, w2, h);
				    		Rect dst2 = new Rect(div, 0, w2, h);
				    		//canvas.drawBitmap(image1.bitmap, src2, dst2, null);
							drawDistorted(canvas, image1.bitmap, src2, dst2, -1);
							// right, new page
				    		Rect src3 = new Rect(w2, 0, w, h);
				    		Rect dst3 = new Rect(w2, 0, w, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src3, dst3);
						} else {
							// left - old page
				    		Rect src1 = new Rect(0, 0, w2, h);
				    		Rect dst1 = new Rect(0, 0, w2, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src1, dst1);
							// right, resized old page
				    		Rect src2 = new Rect(w2, 0, w, h);
				    		Rect dst2 = new Rect(w2, 0, div, h);
				    		//canvas.drawBitmap(image2.bitmap, src2, dst2, null);
							drawDistorted(canvas, image2.bitmap, src2, dst2, 1);
							// right, new page
				    		Rect src3 = new Rect(div, 0, w, h);
				    		Rect dst3 = new Rect(div, 0, w, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src3, dst3);

							if ( div>0 && div<w )
								drawShadow( canvas, shadowRect );
						}
					} else {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(currShift, 0, w, h);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(0, 0, w, h);
			    		Rect dst2 = new Rect(0, 0, currShift, h);
						//canvas.drawBitmap(image2.bitmap, src2, dst2, null);
						drawDistorted(canvas, image2.bitmap, src2, dst2, 1);

						if ( div>0 && div<w )
							drawShadow( canvas, shadowRect );
					}
				} else {
					if ( flipTwoPages ) {
			    		Rect src1 = new Rect(0, 0, w-currShift, h);
			    		Rect dst1 = new Rect(currShift, 0, w, h);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(0, 0, currShift, h);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					} else {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(currShift, 0, w, h);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(0, 0, currShift, h);
		        		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					}
				}
			}
			if ( div>0 && div<w ) {
				canvas.drawLine(div, 0, div, h, divPaint);
			}
		}
	}

	private int drawAnimationPos = 0;
	private Long[] drawAnimationStats = new Long[8];
	private long avgDrawAnimationDuration = 200;
	private long getAvgAnimationDrawDuration()
	{
		return avgDrawAnimationDuration; 
	}
	
	private void updateAnimationDurationStats( long duration )
	{
		if ( duration<=0 )
			duration = 1;
		else if ( duration>1000 )
			return;
		int pos = drawAnimationPos + 1;
		if (pos >= drawAnimationStats.length)
			pos = 0;
		drawAnimationStats[pos] = duration;
		drawAnimationPos = pos;
		long sum = 0;
		int count = 0;
		for (Long item : drawAnimationStats) {
			if (item != null) {
				sum += item;
				count++;
			}
		}
		avgDrawAnimationDuration = sum / count;
	}
	
	private void drawPage()
	{
		drawPage(null, false);
	}
	private void drawPage(boolean isPartially)
	{
		drawPage(null, isPartially);
	}
	private void drawPage( Runnable doneHandler, boolean isPartially )
	{
		if ( !mInitialized || !mOpened )
			return;
		log.v(""drawPage() : submitting DrawPageTask"");
		post( new DrawPageTask(doneHandler, isPartially) );
	}
	
	private int internalDX = 0;
	private int internalDY = 0;

	private byte[] coverPageBytes = null;
	private BitmapDrawable coverPageDrawable = null;
	private void findCoverPage()
	{
    	log.d(""document is loaded succesfull, checking coverpage data"");
    	if ( mActivity.getHistory().getCoverPagesEnabled() ) {
	    	byte[] coverpageBytes = doc.getCoverPageData();
	    	if ( coverpageBytes!=null ) {
	    		log.d(""Found cover page data: "" + coverpageBytes.length + "" bytes"");
	    		BitmapDrawable drawable = mActivity.getHistory().decodeCoverPage(coverpageBytes);
	    		if ( drawable!=null ) {
	    			coverPageBytes = coverpageBytes;
	    			coverPageDrawable = drawable;
	    		}
	    	}
    	}
	}
	
	private class LoadDocumentTask extends Task
	{
		String filename;
		Runnable errorHandler;
		String pos;
		LoadDocumentTask( FileInfo fileInfo, Runnable errorHandler )
		{
			log.v(""LoadDocumentTask for "" + fileInfo);
			BackgroundThread.ensureGUI();
			this.filename = fileInfo.getPathName();
			this.errorHandler = errorHandler;
			//FileInfo fileInfo = new FileInfo(filename);
			mBookInfo = mActivity.getHistory().getOrCreateBookInfo( fileInfo );
	    	if ( mBookInfo!=null && mBookInfo.getLastPosition()!=null )
	    		pos = mBookInfo.getLastPosition().getStartPos();
			log.v(""LoadDocumentTask : book info "" + mBookInfo);
			log.v(""LoadDocumentTask : last position = "" + pos);
    		//mBitmap = null;
	        mEngine.showProgress( 1000, R.string.progress_loading );
	        //init();
		}

		public void work() throws IOException {
			BackgroundThread.ensureBackground();
			coverPageBytes = null;
			coverPageDrawable = null;
			log.i(""Loading document "" + filename);
	        boolean success = doc.loadDocument(filename);
	        if ( success ) {
				log.v(""loadDocumentInternal completed successfully"");
	        	findCoverPage();
				log.v(""requesting page image, to render"");
	        	preparePageImage(0);
				log.v(""updating loaded book info"");
	        	updateLoadedBookInfo();
				log.i(""Document "" + filename + "" is loaded successfully"");
				if ( pos!=null ) {
					log.i(""Restoring position : "" + pos);
					restorePositionBackground(pos);
				}
				CoolReader.dumpHeapAllocation();
	        } else {
				log.e(""Error occured while trying to load document "" + filename);
				throw new IOException(""Cannot read document"");
	        }
		}
		public void done()
		{
			BackgroundThread.ensureGUI();
			log.d(""LoadDocumentTask, GUI thread is finished successfully"");
			if ( mActivity.getHistory()!=null ) {
	    		mActivity.getHistory().updateBookAccess(mBookInfo);
	    		mActivity.getHistory().saveToDB();
		        if (mBookInfo.getFileInfo().id!=null && coverPageBytes!=null && coverPageDrawable!=null && mBookInfo!=null && mBookInfo.getFileInfo()!=null) {
		        	mActivity.getHistory().setBookCoverpageData( mBookInfo.getFileInfo().id, coverPageBytes );
		        	if (DeviceInfo.EINK_NOOK)
		        		updateNookTouchCoverpage(mBookInfo.getFileInfo().getPathName(), coverPageBytes);
		        	//mEngine.setProgressDrawable(coverPageDrawable);
		        }
		        mOpened = true;
		        
		        highlightBookmarks();
		        
		        drawPage();
		        mBackThread.postGUI(new Runnable() {
		        	public void run() {
		    			mActivity.showReader();
		        	}
		        });
		        mActivity.setLastSuccessfullyOpenedBook(filename);
			}
		}
		public void fail( Exception e )
		{
			BackgroundThread.ensureGUI();
			log.e(""LoadDocumentTask failed for "" + mBookInfo);
			mActivity.getHistory().removeBookInfo( mBookInfo.getFileInfo(), true, false );
			mBookInfo = null;
			log.d(""LoadDocumentTask is finished with exception "" + e.getMessage());
	        mOpened = false;
			drawPage();
			mEngine.hideProgress();
			mActivity.showToast(""Error while loading document"");
			if ( errorHandler!=null ) {
				log.e(""LoadDocumentTask: Calling error handler"");
				errorHandler.run();
			}
		}
	}

	private final static boolean dontStretchWhileDrawing = true;
	private final static boolean centerPageInsteadOfResizing = true;
	
	private void dimRect( Canvas canvas, Rect dst ) {
		if (DeviceInfo.EINK_SCREEN)
			return; // no backlight
		int alpha = dimmingAlpha;
		if ( alpha!=255 ) {
			Paint p = new Paint();
			p.setColor((255-alpha)<<24);
			canvas.drawRect(dst, p);
		}
	}
	
	private void drawDimmedBitmap( Canvas canvas, Bitmap bmp, Rect src, Rect dst ) {
		canvas.drawBitmap(bmp, src, dst, null);
		dimRect( canvas, dst );
	}
	
	protected void doDraw(Canvas canvas)
	{
       	try {
    		log.d(""doDraw() called"");
    		if ( mInitialized && mCurrentPageInfo!=null ) {
        		log.d(""onDraw() -- drawing page image"");

        		if (currentAutoScrollAnimation != null) {
        			currentAutoScrollAnimation.draw(canvas);
        			return;
        		}
        		
        		if (currentAnimation != null) {
        			currentAnimation.draw(canvas);
        			return;
        		}

        		Rect dst = new Rect(0, 0, canvas.getWidth(), canvas.getHeight());
        		Rect src = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), mCurrentPageInfo.bitmap.getHeight());
        		if ( dontStretchWhileDrawing ) {
	        		if ( dst.right>src.right )
	        			dst.right = src.right;
	        		if ( dst.bottom>src.bottom )
	        			dst.bottom = src.bottom;
	        		if ( src.right>dst.right )
	        			src.right = dst.right;
	        		if ( src.bottom>dst.bottom )
	        			src.bottom = dst.bottom;
	        		if ( centerPageInsteadOfResizing ) {
		        		int ddx = (canvas.getWidth() - dst.width()) / 2;
		        		int ddy = (canvas.getHeight() - dst.height()) / 2;
		        		dst.left += ddx; 
		        		dst.right += ddx; 
		        		dst.top += ddy; 
		        		dst.bottom += ddy; 
	        		}
        		}
        		if ( dst.width()!=canvas.getWidth() || dst.height()!=canvas.getHeight() )
        			canvas.drawColor(Color.rgb(32, 32, 32));
        		drawDimmedBitmap(canvas, mCurrentPageInfo.bitmap, src, dst);
    		} else {
        		log.d(""onDraw() -- drawing empty screen"");
    			canvas.drawColor(Color.rgb(64, 64, 64));
    		}
    	} catch ( Exception e ) {
    		log.e(""exception while drawing"", e);
    	}
	}
	
	protected void draw()
	{
		drawCallback(new DrawCanvasCallback() {
			@Override
			public void drawTo(Canvas c) {
				doDraw(c);
			}
		}, null, false);
	}
	protected void draw(boolean isPartially)
	{
		drawCallback(new DrawCanvasCallback() {
			@Override
			public void drawTo(Canvas c) {
				doDraw(c);
			}
		}, null, isPartially);
	}
	
    @Override 
    protected void onDraw(Canvas canvas) {
    	try {
    		log.d(""onDraw() called"");
    		draw();
//    		if ( mInitialized && mBitmap!=null ) {
//        		log.d(""onDraw() -- drawing page image"");
//        		Rect rc = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());
//    			canvas.drawBitmap(mBitmap, rc, rc, null);
//    		} else {
//        		log.d(""onDraw() -- drawing empty screen"");
//    			canvas.drawColor(Color.rgb(192, 192, 192));
//    		}
    	} catch ( Exception e ) {
    		log.e(""exception while drawing"", e);
    	}
    }
    
    private int dimmingAlpha = 255; // no dimming
    public void setDimmingAlpha( int alpha ) {
    	if ( alpha>255 )
    		alpha = 255;
    	if ( alpha<32 )
    		alpha = 32;
    	if ( dimmingAlpha!=alpha ) {
    		dimmingAlpha = alpha;
    		mEngine.execute(new Task() {
				@Override
				public void work() throws Exception {
		    		draw();
				}
    			
    		});
    	}
    }

    private void restorePositionBackground( String pos )
    {
		BackgroundThread.ensureBackground();
    	if ( pos!=null ) {
			BackgroundThread.ensureBackground();
			doc.goToPosition( pos );
    		preparePageImage(0);
    	}
    }
    
//    private void restorePosition()
//    {
//		BackgroundThread.ensureGUI();
//    	if ( mBookInfo!=null ) {
//    		if ( mBookInfo.getLastPosition()!=null ) {
//	    		final String pos = mBookInfo.getLastPosition().getStartPos();
//	    		post( new Task() {
//	    			public void work() {
//	    				BackgroundThread.ensureBackground();
//	    	    		goToPositionInternal( pos );
//	    	    		preparePageImage(0);
//	    			}
//	    		});
//	    		mActivity.getHistory().updateBookAccess(mBookInfo);
//    		}
//    		mActivity.getHistory().saveToDB();
//    	}
//    }
    
//    private void savePosition()
//    {
//		BackgroundThread.ensureBackground();
//    	if ( !mOpened )
//    		return;
//    	Bookmark bmk = getCurrentPageBookmarkInternal();
//    	if ( bmk!=null )
//    		log.d(""saving position, bmk="" + bmk.getStartPos());
//    	else
//    		log.d(""saving position: no current page bookmark obtained"");
//    	if ( bmk!=null && mBookInfo!=null ) {
//        	bmk.setTimeStamp(System.currentTimeMillis());
//    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
//    		mBookInfo.setLastPosition(bmk);
//    		mActivity.getHistory().updateRecentDir();
//    		mActivity.getHistory().saveToDB();
//    		saveSettings();
//    	}
//    }
    
    public Bookmark saveCurrentPositionBookmarkSync( boolean saveToDB ) {
        Bookmark bmk = mBackThread.callBackground(new Callable<Bookmark>() {
            @Override
            public Bookmark call() throws Exception {
                if ( !mOpened )
                    return null;
                return doc.getCurrentPageBookmark();
            }
        });
        if ( bmk!=null ) {
            bmk.setTimeStamp(System.currentTimeMillis());
            bmk.setType(Bookmark.TYPE_LAST_POSITION);
            if ( mBookInfo!=null )
                mBookInfo.setLastPosition(bmk);
            if ( saveToDB ) {
                mActivity.getHistory().updateRecentDir();
                mActivity.getHistory().saveToDB();
                mActivity.getDB().flush();
            }
        }
        return bmk;
    }
    
    private class SavePositionTask extends Task {

    	Bookmark bmk;
    	
		@Override
		public void done() {
	    	if ( bmk!=null && mBookInfo!=null ) {
	        	bmk.setTimeStamp(System.currentTimeMillis());
	    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
	    		mBookInfo.setLastPosition(bmk);
	    		mActivity.getHistory().updateRecentDir();
	    		mActivity.getHistory().saveToDB();
                log.i(""SavePositionTask.done()"");
	    	}
		}

		public void work() throws Exception {
			BackgroundThread.ensureBackground();
	    	if ( !mOpened )
	    		return;
	    	bmk = doc.getCurrentPageBookmark();
	    	if ( bmk!=null )
	    		log.d(""saving position, bmk="" + bmk.getStartPos());
	    	else
	    		log.d(""saving position: no current page bookmark obtained"");
		}
    	
    }

    public void save()
    {
		BackgroundThread.ensureGUI();
    	post( new SavePositionTask() );
    }
    
    public void close()
    {
		BackgroundThread.ensureGUI();
    	log.i(""ReaderView.close() is called"");
    	if ( !mOpened )
    		return;
		cancelSwapTask();
		stopImageViewer();
		//save();
    	post( new Task() {
    		public void work() {
    			BackgroundThread.ensureBackground();
    			if ( mOpened ) {
	    			mOpened = false;
					log.i(""ReaderView().close() : closing current document"");
					doc.doCommand(ReaderCommand.DCMD_CLOSE_BOOK.nativeId, 0);
    			}
    		}
    		public void done() {
    			BackgroundThread.ensureGUI();
    			if ( currentAnimation==null ) {
	    			if (  mCurrentPageInfo!=null ) {
	    				mCurrentPageInfo.recycle();
	    				mCurrentPageInfo = null;
	    			}
	    			if (  mNextPageInfo!=null ) {
	    				mNextPageInfo.recycle();
	    				mNextPageInfo = null;
	    			}
    			} else
        	    	invalidImages = true;
    			factory.compact();
    			mCurrentPageInfo = null;
    		}
    	});
    }

    public void destroy()
    {
    	log.i(""ReaderView.destroy() is called"");
		BackgroundThread.ensureGUI();
    	if ( mInitialized ) {
        	//close();
        	BackgroundThread.backgroundExecutor.execute( new Runnable() {
        		public void run() {
        			BackgroundThread.ensureBackground();
        	    	if ( mInitialized ) {
        	        	log.i(""ReaderView.destroyInternal() calling"");
        	        	doc.destroy();
        	    		mInitialized = false;
        	    		currentBackgroundTexture = Engine.NO_TEXTURE;
        	    	}
        		}
        	});
    		//engine.waitTasksCompletion();
    	}
    }
    
    @Override
	protected void onDetachedFromWindow() {
		// TODO Auto-generated method stub
		super.onDetachedFromWindow();
		log.d(""View.onDetachedFromWindow() is called"");
	}

	private String getCSSForFormat( DocumentFormat fileFormat )
	{
		if ( fileFormat==null )
			fileFormat = DocumentFormat.FB2;
		File[] dataDirs = mEngine.getDataDirectories(null, false, false);
		String defaultCss = mEngine.loadResourceUtf8(fileFormat.getCSSResourceId());
		for ( File dir : dataDirs ) {
			File file = new File( dir, fileFormat.getCssName() );
			if ( file.exists() ) {
				String css = mEngine.loadFileUtf8(file);
				if ( css!=null ) {
					int p1 = css.indexOf(""@import"");
					if ( p1<0 )
						p1 = css.indexOf(""@include"");
					int p2 = css.indexOf(""\"";"");
					if (p1 >= 0 && p2 >= 0 && p1 < p2 ) {
						css = css.substring(0, p1) + ""\n"" + defaultCss + ""\n"" + css.substring(p2+2);
					}
					return css;
				}
			} 
		}
		return defaultCss;
	} 

	boolean enable_progress_callback = true;
    ReaderCallback readerCallback = new ReaderCallback() {
    
	    public boolean OnExportProgress(int percent) {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnExportProgress "" + percent);
			return true;
		}
		public void OnExternalLink(String url, String nodeXPath) {
			BackgroundThread.ensureBackground();
		}
		public void OnFormatEnd() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnFormatEnd"");
			//mEngine.hideProgress();
			drawPage();
			scheduleSwapTask();
		}
		public boolean OnFormatProgress(final int percent) {
			BackgroundThread.ensureBackground();
			if ( enable_progress_callback ) {
		    	log.d(""readerCallback.OnFormatProgress "" + percent);
		    	mEngine.showProgress( percent*4/10 + 5000, R.string.progress_formatting);
			}
//			executeSync( new Callable<Object>() {
//				public Object call() {
//					BackgroundThread.ensureGUI();
//			    	log.d(""readerCallback.OnFormatProgress "" + percent);
//			    	mEngine.showProgress( percent*4/10 + 5000, R.string.progress_formatting);
//			    	return null;
//				}
//			});
			return true;
		}
		public void OnFormatStart() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnFormatStart"");
		}
		public void OnLoadFileEnd() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileEnd"");
		}
		public void OnLoadFileError(String message) {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileError("" + message + "")"");
		}
		public void OnLoadFileFirstPagesReady() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileFirstPagesReady"");
		}
		public String OnLoadFileFormatDetected(final DocumentFormat fileFormat) {
			BackgroundThread.ensureBackground();
			String res = executeSync( new Callable<String>() {
				public String call() {
					BackgroundThread.ensureGUI();
					log.i(""readerCallback.OnLoadFileFormatDetected "" + fileFormat);
					if (fileFormat != null) {
						String s = getCSSForFormat(fileFormat);
						log.i(""setting .css for file format "" + fileFormat + "" from resource "" + fileFormat.getCssName());
						return s;
					}
			    	return null;
				}
			});
			int internalStyles = mBookInfo.getFileInfo().getFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG) ? 0 : 1;
			int txtReflow = mBookInfo.getFileInfo().getFlag(FileInfo.DONT_REFLOW_TXT_FILES_FLAG) ? 0 : 2;
			log.d(""internalStyles: "" + internalStyles);
			doc.doCommand(ReaderCommand.DCMD_SET_INTERNAL_STYLES.nativeId, internalStyles | txtReflow);
			return res;
		}
		public boolean OnLoadFileProgress(final int percent) {
			BackgroundThread.ensureBackground();
			if ( enable_progress_callback ) {
		    	log.d(""readerCallback.OnLoadFileProgress "" + percent);
		    	mEngine.showProgress( percent*4/10 + 1000, R.string.progress_loading);
			}
//			executeSync( new Callable<Object>() {
//				public Object call() {
//					BackgroundThread.ensureGUI();
//			    	log.d(""readerCallback.OnLoadFileProgress "" + percent);
//			    	mEngine.showProgress( percent*4/10 + 1000, R.string.progress_loading);
//			    	return null;
//				}
//			});
			return true;
		}
		public void OnLoadFileStart(String filename) {
			cancelSwapTask();
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileStart "" + filename);
		}
	    /// Override to handle external links
	    public void OnImageCacheClear() {
	    	//log.d(""readerCallback.OnImageCacheClear"");
	    	clearImageCache();
	    }
    };
    
    private volatile SwapToCacheTask currentSwapTask;
	private void scheduleSwapTask() {
		currentSwapTask = new SwapToCacheTask();
		currentSwapTask.reschedule();
	}
	private void cancelSwapTask() {
		currentSwapTask = null;
	}
    private class SwapToCacheTask extends Task {
    	boolean isTimeout;
    	long startTime;
    	public SwapToCacheTask() {
    		startTime = System.currentTimeMillis();
    	}
    	public void reschedule() {
    		if ( this!=currentSwapTask )
    			return;
			BackgroundThread.instance().postGUI( new Runnable() {
				@Override
				public void run() {
					post(SwapToCacheTask.this);
				}
			}, 2000);
    	}
		@Override
		public void work() throws Exception {
    		if ( this!=currentSwapTask )
    			return;
			int res = doc.swapToCache();
			isTimeout = res==DocView.SWAP_TIMEOUT;
			long duration = System.currentTimeMillis() - startTime;
			if ( !isTimeout ) {
				log.i(""swapToCacheInternal is finished with result "" + res + "" in "" + duration + "" ms"");
			} else {
				log.d(""swapToCacheInternal exited by TIMEOUT in "" + duration + "" ms: rescheduling"");
			}
		}
		@Override
		public void done() {
			if ( isTimeout )
				reschedule();
		}
		
    }
    
    private boolean invalidImages = true;
    private void clearImageCache()
    {
    	BackgroundThread.instance().postBackground( new Runnable() {
    		public void run() {
    	    	invalidImages = true;
    		}
    	});
    }

    public void setStyleSheet( final String css )
    {
		BackgroundThread.ensureGUI();
        if ( css!=null && css.length()>0 ) {
        	post(new Task() {
        		public void work() {
        			doc.setStylesheet(css);
        		}
        	});
        }
    }
    
    public void goToPosition( int position )
    {
		BackgroundThread.ensureGUI();
		doEngineCommand(ReaderView.ReaderCommand.DCMD_GO_POS, position);
    }
    
    public void moveBy( final int delta )
    {
		BackgroundThread.ensureGUI();
		log.d(""moveBy("" + delta + "")"");
		post(new Task() {
			public void work() {
				BackgroundThread.ensureBackground();
				doc.doCommand(ReaderCommand.DCMD_SCROLL_BY.nativeId, delta);
			}
			public void done() {
				drawPage();
			}
		});
    }
    
    public void goToPage( int pageNumber )
    {
		BackgroundThread.ensureGUI();
		doEngineCommand(ReaderView.ReaderCommand.DCMD_GO_PAGE, pageNumber-1);
    }
    
    public void goToPercent( final int percent )
    {
		BackgroundThread.ensureGUI();
    	if ( percent>=0 && percent<=100 )
	    	post( new Task() {
	    		public void work() {
	    			PositionProperties pos = doc.getPositionProps(null);
	    			if ( pos!=null && pos.pageCount>0) {
	    				int pageNumber = pos.pageCount * percent / 100; 
						doCommandFromBackgroundThread(ReaderView.ReaderCommand.DCMD_GO_PAGE, pageNumber);
	    			}
	    		}
	    	});
    }

    public interface MoveSelectionCallback {
    	// selection is changed
    	public void onNewSelection( Selection selection );
    	// cannot move selection
    	public void onFail();
    }
    
    public void moveSelection( final ReaderCommand command, final int param, final MoveSelectionCallback callback ) {
    	post( new Task() {
    		private boolean res;
    		private Selection selection = new Selection();
			@Override
			public void work() throws Exception {
				res = doc.moveSelection(selection, command.nativeId, param);
			}

			@Override
			public void done() {
				if ( callback!=null ) {
					clearImageCache();
					invalidate();
					drawPage();
					if ( res )
						callback.onNewSelection(selection);
					else
						callback.onFail();
				}
			}

			@Override
			public void fail(Exception e) {
				if ( callback!=null )
					callback.onFail();
			}
			
			
    		
    	});
    }

	private void showSwitchProfileDialog() {
		SwitchProfileDialog dlg = new SwitchProfileDialog(mActivity, this);
		dlg.show();
	}
	
	private int currentProfile = 0;
	public int getCurrentProfile() {
		if (currentProfile == 0) {
			currentProfile = mSettings.getInt(PROP_PROFILE_NUMBER, 1);
			if (currentProfile < 1 || currentProfile > MAX_PROFILES)
				currentProfile = 1;
		}
		return currentProfile;
	}

	public void setCurrentProfile(int profile) {
		if (profile == getCurrentProfile())
			return;
		log.i(""Switching from profile "" + currentProfile + "" to "" + profile);
		mActivity.saveSettings(currentProfile, mSettings);
		final Properties newSettings = mActivity.loadSettings(profile);
		mActivity.saveSettings(0, mSettings); // save to default
		currentProfile = profile;
		BackgroundThread.instance().executeBackground(new Runnable() {
			@Override
			public void run() {
				applySettings(newSettings, false);
				log.i(""Switching done"");
			}
		});
	}
    
    private final static String NOOK_TOUCH_COVERPAGE_DIR = ""/media/screensavers/currentbook"";
	private void updateNookTouchCoverpage(String bookFileName,
			byte[] coverpageBytes) {
		try {
			String imageFileName;
			int lastSlash = bookFileName.lastIndexOf(""/"");
			// exclude path and extension
			if (lastSlash >= 0 && lastSlash < bookFileName.length()) {
				imageFileName = bookFileName.substring(lastSlash);
			} else {
				imageFileName = bookFileName;
			}
			int lastDot = imageFileName.lastIndexOf(""."");
			if (lastDot > 0) {
				imageFileName = imageFileName.substring(0, lastDot);
			}
			// guess image type
			if (coverpageBytes.length > 8 // PNG signature length
					&& coverpageBytes[0] == (byte)0x89 // PNG signature start 4 bytes
					&& coverpageBytes[1] == 0x50
					&& coverpageBytes[2] == 0x4E
					&& coverpageBytes[3] == 0x47) {
				imageFileName += "".png"";
			} else if (coverpageBytes.length > 3 // Checking only the first 3
													// bytes of JPEG header
					&& coverpageBytes[0] == (byte)0xFF
					&& coverpageBytes[1] == (byte)0xD8
					&& coverpageBytes[2] == (byte)0xFF) {
				imageFileName += "".jpg"";
			} else if (coverpageBytes.length > 3 // Checking only the first 3
													// bytes of GIF header
					&& coverpageBytes[0] == 0x47
					&& coverpageBytes[1] == 0x49
					&& coverpageBytes[2] == 0x46) {
				imageFileName += "".gif"";
			} else if (coverpageBytes.length > 2 // Checking only the first 2
													// bytes of BMP signature
					&& coverpageBytes[0] == 0x42 && coverpageBytes[1] == 0x4D) {
				imageFileName += "".bmp"";
			} else {
				imageFileName += "".jpg""; // default image type
			}
			// create directory if it does not exist
			File d = new File(NOOK_TOUCH_COVERPAGE_DIR);
			if (!d.exists()) {
				d.mkdir();
			}
			// create file only if file with same name does not exist
			File f = new File(d, imageFileName);
			if (!f.exists()) {
				// delete other files in directory so that only current cover is
				// shown all the time
				File[] files = d.listFiles();
				for (File oldFile : files) {
					oldFile.delete();
				}
				// write the image file
				FileOutputStream fos = new FileOutputStream(f);
				fos.write(coverpageBytes);
				fos.close();
			}
		} catch (Exception ex) {
			log.e(""Error writing cover page: "", ex);
		}
	}
    
    private static volatile int gcCounter = 0;
    private static final int GC_INTERVAL = 5000; // 5 ms
    private static class GcScheduleTask implements Runnable {
    	public static void scheduleGc() {
    		BackgroundThread.instance().postGUI(new GcScheduleTask(), GC_INTERVAL);
    	}
    	private final int myCounter;
    	private GcScheduleTask() {
    		myCounter = ++gcCounter;
    	}
		@Override
		public void run() {
			if (myCounter == gcCounter) {
				log.v(""Initiating garbage collection"");
				System.gc();
				++gcCounter;
			}
		}
    }
    public static void scheduleGc() {
    	GcScheduleTask.scheduleGc();
    }
    public static void cancelGc() {
    	++gcCounter;
    }

	public ReaderView(CoolReader activity, Engine engine, BackgroundThread backThread, Properties props ) 
    {
        super(activity);
        doc = new DocView();
        doc.setReaderCallback(readerCallback);
        SurfaceHolder holder = getHolder();
        holder.addCallback(this);
        
		BackgroundThread.ensureGUI();
        this.mActivity = activity;
        this.mEngine = engine;
        this.mBackThread = backThread;
        setFocusable(true);
        setFocusableInTouchMode(true);
        
        mBackThread.postBackground(new Runnable() {

			@Override
			public void run() {
				log.d(""ReaderView - in background thread: calling createInternal()"");
				doc.create();
				mInitialized = true;
			}
        	
        });

        post(new CreateViewTask( props ));

    }

}
",True,43,49,0,0,2,36,13,36,L0
48,org.coolreader.crengine.ReaderAction.java,"package org.coolreader.crengine;

import org.coolreader.R;
import org.coolreader.crengine.ReaderView.ReaderCommand;

public class ReaderAction {
	final public String id;
	final public int nameId;
	final public int    iconId;
	final public ReaderView.ReaderCommand cmd;
	final public int param;
	final public int menuItemId;
	private boolean canRepeat = false;
	private boolean mayAssignOnKey = true;
	private boolean mayAssignOnTap = true;
	private ReaderAction setCanRepeat() { canRepeat=true; return this; }
	//private ReaderAction dontAssignOnKey() { mayAssignOnKey=false; return this; }
	private ReaderAction dontAssignOnTap() { mayAssignOnTap=false; return this; }
	public boolean canRepeat() { return canRepeat; }
	public boolean mayAssignOnKey() { return mayAssignOnKey; }
	public boolean mayAssignOnTap() { return mayAssignOnTap; }

	public ReaderAction(String id, int nameId, ReaderCommand cmd, int param) {
		super();
		this.id = id;
		this.nameId = nameId;
		this.cmd = cmd;
		this.param = param;
		this.menuItemId = 0;
		this.iconId = 0;
	}

	public ReaderAction(String id, int nameId, ReaderCommand cmd, int param, int menuItemId) {
		super();
		this.id = id;
		this.nameId = nameId;
		this.cmd = cmd;
		this.param = param;
		this.menuItemId = menuItemId;
		this.iconId = 0;
	}

	public String toString() {
		return id;
	}
	
	public final static ReaderAction NONE = new ReaderAction(""NONE"", R.string.action_none, ReaderCommand.DCMD_NONE, 0 );
	public final static ReaderAction REPEAT = new ReaderAction(""REPEAT"", R.string.action_repeat, ReaderCommand.DCMD_REPEAT, 0 );
	public final static ReaderAction PAGE_DOWN = new ReaderAction(""PAGE_DOWN"", R.string.action_pagedown, ReaderCommand.DCMD_PAGEDOWN, 1 ).setCanRepeat();
	public final static ReaderAction PAGE_DOWN_10 = new ReaderAction(""PAGE_DOWN_10"", R.string.action_pagedown_10, ReaderCommand.DCMD_PAGEDOWN, 10 ).setCanRepeat();
	public final static ReaderAction PAGE_UP = new ReaderAction(""PAGE_UP"", R.string.action_pageup, ReaderCommand.DCMD_PAGEUP, 1 ).setCanRepeat();
	public final static ReaderAction PAGE_UP_10 = new ReaderAction(""PAGE_UP_10"", R.string.action_pageup_10, ReaderCommand.DCMD_PAGEUP, 10 ).setCanRepeat();
	public final static ReaderAction ZOOM_IN = new ReaderAction(""ZOOM_IN"", R.string.action_zoom_in, ReaderCommand.DCMD_ZOOM_IN, 2 );
	public final static ReaderAction ZOOM_OUT = new ReaderAction(""ZOOM_OUT"", R.string.action_zoom_out, ReaderCommand.DCMD_ZOOM_OUT, 2 );
	public final static ReaderAction DOCUMENT_STYLES = new ReaderAction(""DOCUMENT_STYLES"", R.string.action_toggle_document_styles, ReaderCommand.DCMD_TOGGLE_DOCUMENT_STYLES, 0, R.id.cr3_mi_toggle_document_styles );
	public final static ReaderAction BOOKMARKS = new ReaderAction(""BOOKMARKS"", R.string.action_bookmarks, ReaderCommand.DCMD_BOOKMARKS, 0, R.id.cr3_mi_bookmarks );
	public final static ReaderAction ABOUT = new ReaderAction(""ABOUT"", R.string.dlg_about, ReaderCommand.DCMD_ABOUT, 0, R.id.cr3_mi_about );
	public final static ReaderAction BOOK_INFO = new ReaderAction(""BOOK_INFO"", R.string.dlg_book_info, ReaderCommand.DCMD_BOOK_INFO, 0, R.id.cr3_mi_book_info );
	public final static ReaderAction TOC = new ReaderAction(""TOC"", R.string.action_toc, ReaderCommand.DCMD_TOC_DIALOG, 0, R.id.cr3_go_toc );
	public final static ReaderAction SEARCH = new ReaderAction(""SEARCH"", R.string.action_search, ReaderCommand.DCMD_SEARCH, 0, R.id.cr3_mi_search );
	public final static ReaderAction GO_PAGE = new ReaderAction(""GO_PAGE"", R.string.action_go_page, ReaderCommand.DCMD_GO_PAGE_DIALOG, 0, R.id.cr3_mi_go_page );
	public final static ReaderAction GO_PERCENT = new ReaderAction(""GO_PERCENT"", R.string.action_go_percent, ReaderCommand.DCMD_GO_PERCENT_DIALOG, 0, R.id.cr3_mi_go_percent );
	public final static ReaderAction FIRST_PAGE = new ReaderAction(""FIRST_PAGE"", R.string.action_go_first_page, ReaderCommand.DCMD_BEGIN, 0 );
	public final static ReaderAction LAST_PAGE = new ReaderAction(""LAST_PAGE"", R.string.action_go_last_page, ReaderCommand.DCMD_END, 0 );
	public final static ReaderAction OPTIONS = new ReaderAction(""OPTIONS"", R.string.action_options, ReaderCommand.DCMD_OPTIONS_DIALOG, 0, R.id.cr3_mi_options );
	public final static ReaderAction READER_MENU = new ReaderAction(""READER_MENU"", R.string.action_reader_menu, ReaderCommand.DCMD_READER_MENU, 0 );
	public final static ReaderAction TOGGLE_DAY_NIGHT = new ReaderAction(""TOGGLE_DAY_NIGHT"", R.string.action_toggle_day_night, ReaderCommand.DCMD_TOGGLE_DAY_NIGHT_MODE, 0, R.id.cr3_mi_toggle_day_night );
	public final static ReaderAction RECENT_BOOKS = new ReaderAction(""RECENT_BOOKS"", R.string.action_recent_books_list, ReaderCommand.DCMD_RECENT_BOOKS_LIST, R.id.book_recent_books );
	public final static ReaderAction FILE_BROWSER = new ReaderAction(""FILE_BROWSER"", R.string.action_file_browser, ReaderCommand.DCMD_FILE_BROWSER, 0, R.id.cr3_mi_open_file );
	public final static ReaderAction TOGGLE_TOUCH_SCREEN_LOCK = new ReaderAction(""TOGGLE_TOUCH_SCREEN_LOCK"", R.string.action_touch_screen_toggle_lock, ReaderCommand.DCMD_TOGGLE_TOUCH_SCREEN_LOCK, 0 ).dontAssignOnTap();
	public final static ReaderAction TOGGLE_ORIENTATION = new ReaderAction(""TOGGLE_ORIENTATION"", R.string.action_toggle_screen_orientation, ReaderCommand.DCMD_TOGGLE_ORIENTATION, 0 );
	public final static ReaderAction TOGGLE_FULLSCREEN = new ReaderAction(""TOGGLE_FULLSCREEN"", R.string.action_toggle_fullscreen, ReaderCommand.DCMD_TOGGLE_FULLSCREEN, 0 );
	public final static ReaderAction TOGGLE_SELECTION_MODE = new ReaderAction(""TOGGLE_SELECTION_MODE"", R.string.action_toggle_selection_mode, ReaderCommand.DCMD_TOGGLE_SELECTION_MODE, 0, R.id.cr3_mi_select_text );
	public final static ReaderAction HOME_SCREEN = new ReaderAction(""HOME_SCREEN"", R.string.action_exit_home_screen, ReaderCommand.DCMD_SHOW_HOME_SCREEN, 0 );
	public final static ReaderAction GO_BACK = new ReaderAction(""GO_BACK"", R.string.action_go_back, ReaderCommand.DCMD_LINK_BACK, 0, R.id.cr3_go_back );
	public final static ReaderAction GO_FORWARD = new ReaderAction(""GO_FORWARD"", R.string.action_go_forward, ReaderCommand.DCMD_LINK_FORWARD, 0, R.id.cr3_go_forward );
	public final static ReaderAction TTS_PLAY = new ReaderAction(""TTS_PLAY"", R.string.mi_tts_play, ReaderCommand.DCMD_TTS_PLAY, 0, R.id.cr3_mi_tts_play );
	public final static ReaderAction TOGGLE_TITLEBAR = new ReaderAction(""TOGGLE_TITLEBAR"", R.string.action_toggle_titlebar, ReaderCommand.DCMD_TOGGLE_TITLEBAR, 0 );
	public final static ReaderAction SHOW_POSITION_INFO_POPUP = new ReaderAction(""SHOW_POSITION_INFO_POPUP"", R.string.action_show_position_info, ReaderCommand.DCMD_SHOW_POSITION_INFO_POPUP, 0 );
	public final static ReaderAction SHOW_DICTIONARY = new ReaderAction(""SHOW_DICTIONARY"", R.string.action_show_dictionary, ReaderCommand.DCMD_SHOW_DICTIONARY, 0);
	public final static ReaderAction OPEN_PREVIOUS_BOOK = new ReaderAction(""OPEN_PREVIOUS_BOOK"", R.string.action_open_last_book, ReaderCommand.DCMD_OPEN_PREVIOUS_BOOK, 0, R.id.cr3_go_previous_book);
	public final static ReaderAction TOGGLE_AUTOSCROLL = new ReaderAction(""TOGGLE_AUTOSCROLL"", R.string.action_toggle_autoscroll, ReaderCommand.DCMD_TOGGLE_AUTOSCROLL, 0, R.id.cr3_mi_toggle_autoscroll);
	public final static ReaderAction AUTOSCROLL_SPEED_INCREASE = new ReaderAction(""AUTOSCROLL_SPEED_INCREASE"", R.string.action_autoscroll_speed_increase, ReaderCommand.DCMD_AUTOSCROLL_SPEED_INCREASE, 0);
	public final static ReaderAction AUTOSCROLL_SPEED_DECREASE = new ReaderAction(""AUTOSCROLL_SPEED_DECREASE"", R.string.action_autoscroll_speed_decrease, ReaderCommand.DCMD_AUTOSCROLL_SPEED_DECREASE, 0);
	public final static ReaderAction START_SELECTION = new ReaderAction(""START_SELECTION"", R.string.action_toggle_selection_mode, ReaderCommand.DCMD_START_SELECTION, 0);
	public final static ReaderAction SWITCH_PROFILE = new ReaderAction(""SWITCH_PROFILE"", R.string.action_switch_settings_profile, ReaderCommand.DCMD_SWITCH_PROFILE, 0);
	public final static ReaderAction EXIT = new ReaderAction(""EXIT"", R.string.action_exit, ReaderCommand.DCMD_EXIT, 0, R.id.cr3_mi_exit );
	
	
	public final static ReaderAction[] AVAILABLE_ACTIONS = {
		NONE,
		PAGE_DOWN,
		PAGE_UP,
		PAGE_DOWN_10,
		PAGE_UP_10,
		FIRST_PAGE,
		LAST_PAGE,
		TOC,
		GO_PAGE,
		GO_PERCENT,
		BOOKMARKS,
		SEARCH,
		OPTIONS,
		EXIT,
		TOGGLE_DAY_NIGHT,
		RECENT_BOOKS,
		FILE_BROWSER,
		READER_MENU,
		TOGGLE_TOUCH_SCREEN_LOCK,
		TOGGLE_SELECTION_MODE,
		TOGGLE_ORIENTATION,
		TOGGLE_FULLSCREEN,
		GO_BACK,
		GO_FORWARD,
		HOME_SCREEN,
		ZOOM_IN,
		ZOOM_OUT,
		DOCUMENT_STYLES,
		ABOUT,
		BOOK_INFO,
		TTS_PLAY,
		TOGGLE_TITLEBAR,
		SHOW_POSITION_INFO_POPUP,
		SHOW_DICTIONARY,
		OPEN_PREVIOUS_BOOK,
		TOGGLE_AUTOSCROLL,
		SWITCH_PROFILE,
		AUTOSCROLL_SPEED_INCREASE,
		AUTOSCROLL_SPEED_DECREASE,
	};

	public boolean isNone() {
		return cmd == NONE.cmd;
	}
	
	public boolean isRepeat() {
		return cmd == REPEAT.cmd;
	}
	
	public static ReaderAction findById( String id ) {
		if ( id==null )
			return NONE;
		for ( ReaderAction a : AVAILABLE_ACTIONS ) {
			if ( id.equals(a.id) )
				return a;
		}
		if ( id.equals(REPEAT.id) )
			return REPEAT;
		return NONE;
	}
	public static ReaderAction findByMenuId( int id ) {
		if ( id==0 )
			return NONE;
		for ( ReaderAction a : AVAILABLE_ACTIONS ) {
			if ( id == a.menuItemId )
				return a;
		}
		return NONE;
	}
	public final static String NORMAL_PROP = ""."";
	public final static String LONG_PROP = "".long."";
	public final static String DOUBLECLICK_PROP = "".dbl."";
	
	public final static int NORMAL = 0;
	public final static int LONG = 1;
	public final static int DOUBLE = 2;
	public final static String[] TYPE_PROP_SUBPATH = new String[] {NORMAL_PROP, LONG_PROP, DOUBLECLICK_PROP};

	public static String getTypeString( int type ) {
		return TYPE_PROP_SUBPATH[type];
	}
	
	public static String getTapZoneProp( int tapZoneNumber, int type ) {
		return ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + getTypeString(type) + tapZoneNumber;
	}
	public static String getKeyProp( int keyCode, int type ) {
		return ReaderView.PROP_APP_KEY_ACTIONS_PRESS + getTypeString(type) + keyCode;
	}
	public static ReaderAction findForTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, NORMAL ) );
		return findById(id);
	}
	public static ReaderAction findForLongTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, LONG ) );
		return findById(id);
	}
	public static ReaderAction findForDoubleTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, DOUBLE ) );
		return findById(id);
	}
	public static ReaderAction findForKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, NORMAL ) );
		return findById(id);
	}
	public static ReaderAction findForLongKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, LONG ) );
		return findById(id);
	}
	public static ReaderAction findForDoubleKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, DOUBLE ) );
		return findById(id);
	}
}
",False,50,49,0,0,3,33,3,3,L0
49,org.coolreader.crengine.ToastView.java,"package org.coolreader.crengine;

import android.content.Context;
import android.os.Handler;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;
import android.widget.PopupWindow;
import android.widget.TextView;
import org.coolreader.R;

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * User: Victor Soskin
 * Date: 11/3/11
 * Time: 2:51 PM
 */
public class ToastView {
    private static class Toast {
        private View anchor;
        private String msg;
        private int duration;

        private Toast(View anchor, String msg, int duration) {
            this.anchor = anchor;
            this.msg = msg;
            this.duration = duration;
        }
    }


    private static LinkedBlockingQueue<Toast> queue = new LinkedBlockingQueue<Toast>();
    private static AtomicBoolean showing = new AtomicBoolean(false);
    private static Handler mHandler = new Handler();
    private static PopupWindow window = null;

    private static Runnable handleDismiss = new Runnable() {
        @Override
        public void run() {
            if (window != null) {
                window.dismiss();
                show();
            }
        }
    };

    public static void showToast(View anchor, String msg, int duration) {
        try {
            queue.put(new Toast(anchor, msg, duration));
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (showing.compareAndSet(false, true)) {
            show();
        }
    }

    private static void show() {
        if (queue.size() == 0) {
            showing.compareAndSet(true, false);
            return;
        }
        Toast t = queue.poll();
        window = new PopupWindow(t.anchor.getContext());
        window.setWidth(WindowManager.LayoutParams.FILL_PARENT);
        window.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
        window.setTouchable(false);
        window.setFocusable(false);
        window.setOutsideTouchable(true);
        window.setBackgroundDrawable(null);
        /* LinearLayout ll = new LinearLayout(t.anchor.getContext());
        ll.setLayoutParams(new LinearLayout.LayoutParams(LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT));

        TextView tv = new TextView(t.anchor.getContext());
        tv.setText(t.msg);
        ll.setGravity(Gravity.CENTER);
        ll.addView(tv);*/
        LayoutInflater inflater = (LayoutInflater) t.anchor.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        // TODO: uncomment this
//        window.setContentView(inflater.inflate(R.layout.custom_toast, null, true));
//        TextView tv = (TextView) window.getContentView().findViewById(R.id.toast);
//        tv.setText(t.msg);
        window.showAtLocation(t.anchor, Gravity.NO_GRAVITY, 0, 0);
        mHandler.postDelayed(handleDismiss, t.duration == 0 ? 2000 : 3000);
    }
}
",True,27,1,0,0,0,0,0,0,I0
