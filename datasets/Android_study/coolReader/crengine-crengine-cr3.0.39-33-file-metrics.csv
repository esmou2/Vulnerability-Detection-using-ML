,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.coolreader.CoolReader.java,"// Main Class
package org.coolreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.lang.reflect.Field;

import org.coolreader.crengine.BackgroundThread;
import org.coolreader.crengine.BaseDialog;
import org.coolreader.crengine.BookmarksDlg;
import org.coolreader.crengine.CRDB;
import org.coolreader.crengine.Engine;
import org.coolreader.crengine.Engine.HyphDict;
import org.coolreader.crengine.FileBrowser;
import org.coolreader.crengine.FileInfo;
import org.coolreader.crengine.History;
import org.coolreader.crengine.OptionsDialog;
import org.coolreader.crengine.Properties;
import org.coolreader.crengine.ReaderAction;
import org.coolreader.crengine.ReaderView;
import org.coolreader.crengine.Scanner;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.graphics.PixelFormat;
import android.net.Uri;
import android.os.Bundle;
import android.os.Debug;
import android.os.PowerManager;
import android.text.ClipboardManager;
import android.text.InputFilter;
import android.text.method.DigitsKeyListener;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.Toast;

public class CoolReader extends Activity
{
	Engine mEngine;
	ReaderView mReaderView;
	Scanner mScanner;
	FileBrowser mBrowser;
	FrameLayout mFrame;
	//View startupView;
	History mHistory;
	CRDB mDB;
	private BackgroundThread mBackgroundThread;
	
	public Scanner getScanner()
	{
		return mScanner;
	}
	
	public History getHistory() 
	{
		return mHistory;
	}
	
	public ReaderView getReaderView() 
	{
		return mReaderView;
	}
	
	public CRDB getDB()
	{
		return mDB;
	}
	
	private static String PREF_FILE = ""CR3LastBook"";
	private static String PREF_LAST_BOOK = ""LastBook"";
	public String getLastSuccessfullyOpenedBook()
	{
		SharedPreferences pref = getSharedPreferences(PREF_FILE, 0);
		String res = pref.getString(PREF_LAST_BOOK, null);
		pref.edit().putString(PREF_LAST_BOOK, null).commit();
		return res;
	}
	
	public void setLastSuccessfullyOpenedBook( String filename )
	{
		SharedPreferences pref = getSharedPreferences(PREF_FILE, 0);
		pref.edit().putString(PREF_LAST_BOOK, filename).commit();
	}
	
	private boolean mNightMode = false;
	public boolean isNightMode() {
		return mNightMode;
	}
	public void setNightMode( boolean nightMode ) {
		mNightMode = nightMode;
	}
	private boolean mFullscreen = false;
	public boolean isFullscreen() {
		return mFullscreen;
	}

	public void applyFullscreen( Window wnd )
	{
		if ( mFullscreen ) {
			//mActivity.getWindow().requestFeature(Window.)
			wnd.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, 
			        WindowManager.LayoutParams.FLAG_FULLSCREEN );
		} else {
			wnd.setFlags(0, 
			        WindowManager.LayoutParams.FLAG_FULLSCREEN );
		}
	}
	public void setFullscreen( boolean fullscreen )
	{
		if ( mFullscreen!=fullscreen ) {
			mFullscreen = fullscreen;
			applyFullscreen( getWindow() );
		}
	}
	
	private boolean mWakeLockEnabled = false;
	public boolean isWakeLockEnabled() {
		return mWakeLockEnabled;
	}

	public void setWakeLockEnabled( boolean wakeLockEnabled )
	{
		if ( mWakeLockEnabled != wakeLockEnabled ) {
			mWakeLockEnabled = wakeLockEnabled;
			if ( !mWakeLockEnabled )
				backlightControl.release();
			else
				backlightControl.onUserActivity();
		}
	}
	
	int screenOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR;
	public void applyScreenOrientation( Window wnd )
	{
		if ( wnd!=null ) {
			WindowManager.LayoutParams attrs = wnd.getAttributes();
			attrs.screenOrientation = screenOrientation;
			wnd.setAttributes(attrs);
		}
	}

	public void setScreenOrientation( int angle )
	{
		int newOrientation = screenOrientation;
		if ( angle==4 )
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR;
		else if ( (angle&1)!=0 )
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
		else
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
		if ( newOrientation!=screenOrientation ) {
			screenOrientation = newOrientation;
			setRequestedOrientation(screenOrientation);
			applyScreenOrientation(getWindow());
		}
	}

	private Runnable backlightTimerTask = null; 
	private class ScreenBacklightControl
	{
		PowerManager.WakeLock wl = null;
		public ScreenBacklightControl()
		{
		}
		public static final int SCREEN_BACKLIGHT_DURATION_STEPS = 3;
		public static final int SCREEN_BACKLIGHT_TIMER_STEP = 60*1000;
		int backlightCountDown = 0; 
		public void onUserActivity()
		{
			if ( !isWakeLockEnabled() )
				return;
			if ( wl==null ) {
				PowerManager pm = (PowerManager)getSystemService(
			            Context.POWER_SERVICE);
				wl = pm.newWakeLock(
			        PowerManager.SCREEN_BRIGHT_WAKE_LOCK
			        | PowerManager.ON_AFTER_RELEASE,
			        ""cr3"");
			}
			if ( !wl.isHeld() )
				wl.acquire();
			backlightCountDown = SCREEN_BACKLIGHT_DURATION_STEPS;
			if ( backlightTimerTask==null ) {
				backlightTimerTask = new Runnable() {
					public void run() {
						if ( backlightTimerTask!=this )
							return;
						if ( backlightCountDown<=0 )
							release();
						else {
							backlightCountDown--;
							BackgroundThread.instance().postGUI(backlightTimerTask, SCREEN_BACKLIGHT_TIMER_STEP);
						}
					}
				};
				BackgroundThread.instance().postGUI(backlightTimerTask, SCREEN_BACKLIGHT_TIMER_STEP);
			}
		}
		public boolean isHeld()
		{
			return wl!=null && wl.isHeld();
		}
		public void release()
		{
			if ( wl!=null && wl.isHeld() )
				wl.release();
			backlightTimerTask = null;
		}
	}
	ScreenBacklightControl backlightControl = new ScreenBacklightControl();
	
	public int getPalmTipPixels()
	{
		return densityDpi / 3; // 1/3""
	}
	
	private int densityDpi = 160;
	int initialBatteryState = -1;
	String fileToLoadOnStart = null;
	BroadcastReceiver intentReceiver;
	/** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
		Log.i(""cr3"", ""CoolReader.onCreate() entered"");
		super.onCreate(savedInstanceState);

		
		Display d = getWindowManager().getDefaultDisplay();
		DisplayMetrics m = new DisplayMetrics(); 
		d.getMetrics(m);
		try {
			Field fld = d.getClass().getField(""densityDpi"");
			if ( fld!=null ) {
				Object v = fld.get(m);
				if ( v!=null && v instanceof Integer ) {
					densityDpi = ((Integer)v).intValue();
					Log.i(""cr3"", ""Screen density detected: "" + densityDpi + ""DPI"");
				}
			}
		} catch ( Exception e ) {
			Log.e(""cr3"", ""Cannot find field densityDpi, using default value"");
		}
		
		// load settings
		Properties props = loadSettings();
		
		intentReceiver = new BroadcastReceiver() {

			@Override
			public void onReceive(Context context, Intent intent) {
				Log.i(""cr3"", ""Battery state changed. Intent="" + intent);
				int level = intent.getIntExtra(""level"", 0);
				if ( mReaderView!=null )
					mReaderView.setBatteryState(level);
				else
					initialBatteryState = level;
			}
			
		};
		registerReceiver(intentReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));


		Log.i(""cr3"", ""CoolReader.window="" + getWindow());
		WindowManager.LayoutParams lp = new WindowManager.LayoutParams();
		lp.alpha = 1.0f;
		lp.dimAmount = 0.0f;
		lp.format = PixelFormat.RGB_565;
		lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL;
		lp.horizontalMargin = 0;
		lp.verticalMargin = 0;
		lp.windowAnimations = 0;
		lp.layoutAnimationParameters = null;
		lp.memoryType = WindowManager.LayoutParams.MEMORY_TYPE_NORMAL;
		getWindow().setAttributes(lp);
		
		
		setFullscreen( props.getBool(ReaderView.PROP_APP_FULLSCREEN, false) );
		int orientation = props.getInt(ReaderView.PROP_APP_SCREEN_ORIENTATION, 4);
		if ( orientation!=1 && orientation!=4 )
			orientation = 0;
		setScreenOrientation(orientation);
		int backlight = props.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, -1);
		if ( backlight<-1 || backlight>100 )
			backlight = -1;
		setScreenBacklightLevel(backlight);
		

		
		// testing background thread
    	mBackgroundThread = BackgroundThread.instance();
		mFrame = new FrameLayout(this);
		mEngine = new Engine(this, mBackgroundThread);
		mBackgroundThread.setGUI(mFrame);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		
        mEngine.showProgress( 0, R.string.progress_starting_cool_reader );
		
		mEngine.setHyphenationDictionary(HyphDict.byCode(props.getProperty(ReaderView.PROP_HYPHENATION_DICT, Engine.HyphDict.RUSSIAN.toString())));
		
		//this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, 
        //       WindowManager.LayoutParams.FLAG_FULLSCREEN );
//		startupView = new View(this) {
//		};
//		startupView.setBackgroundColor(Color.BLACK);
		setWakeLockEnabled(props.getBool(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK, true));

		File dbdir = getDir(""db"", Context.MODE_PRIVATE);
		dbdir.mkdirs();
		File dbfile = new File(dbdir, ""cr3db.sqlite"");
		mDB = new CRDB(dbfile);
		
       	mScanner = new Scanner(this, mDB, mEngine); //, Environment.getExternalStorageDirectory(), ""SD""
       	mHistory = new History(mDB);
		mHistory.setCoverPagesEnabled(props.getBool(ReaderView.PROP_APP_SHOW_COVERPAGES, true));

		mReaderView = new ReaderView(this, mEngine, mBackgroundThread, props);
		
		mScanner.setDirScanEnabled(props.getBool(ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED, true));
		Log.i(""cr3"", ""initializing scanner"");
        mScanner.initRoots();

		mBrowser = new FileBrowser(this, mEngine, mScanner, mHistory);
		mFrame.addView(mReaderView);
		mFrame.addView(mBrowser);
//		mFrame.addView(startupView);
		setContentView( mFrame );
        Log.i(""cr3"", ""initializing browser"");
        mBrowser.init();
		showView(mBrowser, false);
        Log.i(""cr3"", ""initializing reader"");
        mBrowser.showDirectory(mScanner.getRoot(), null);
        
        fileToLoadOnStart = null;
		Intent intent = getIntent();
		if ( intent!=null && Intent.ACTION_VIEW.equals(intent.getAction()) ) {
			Uri uri = intent.getData();
			if ( uri!=null ) {
				fileToLoadOnStart = extractFileName(uri);
			}
			intent.setData(null);
		}
		if ( initialBatteryState>=0 )
			mReaderView.setBatteryState(initialBatteryState);
        
        Log.i(""cr3"", ""CoolReader.onCreate() exiting"");
    }
    
    public ClipboardManager getClipboardmanager() {
    	return (ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
    }
    
    public void setScreenBacklightLevel( int percent )
    {
    	if ( percent<-1 )
    		percent = -1;
    	else if ( percent>100 )
    		percent = -1;
    	screenBacklightBrightness = percent;
    	onUserActivity();
    }
    
    private int screenBacklightBrightness = -1; // use default
    private boolean brightnessHackError = false;
    public void onUserActivity()
    {
    	if ( backlightControl==null )
    		return;
    	backlightControl.onUserActivity();
    	// Hack
    	//if ( backlightControl.isHeld() )
    	BackgroundThread.guiExecutor.execute(new Runnable() {
			@Override
			public void run() {
				try {
			        Window wnd = getWindow();
			        if ( wnd!=null ) {
			        	LayoutParams attrs =  wnd.getAttributes();
			        	boolean changed = false;
			        	float b;
			        	if ( screenBacklightBrightness>=0 ) {
			        		b = screenBacklightBrightness / 100.0f;
				        	if ( b<0.0f ) // BRIGHTNESS_OVERRIDE_OFF
				        		b = 0.0f;
				        	else if ( b>1.0f )
				        		b = 1.0f; //BRIGHTNESS_OVERRIDE_FULL
			        	} else
			        		b = -1.0f; //BRIGHTNESS_OVERRIDE_NONE
			        	if ( attrs.screenBrightness != b ) {
			        		attrs.screenBrightness = b;
			        		changed = true;
			        	}
			        	// hack to set buttonBrightness field
			        	if ( !brightnessHackError )
			        	try {
				        	Field bb = attrs.getClass().getField(""buttonBrightness"");
				        	if ( bb!=null ) {
				        		Float oldValue = (Float)bb.get(attrs);
				        		//if ( oldValue==null || oldValue.floatValue()!=0 ) {
				        			bb.set(attrs, Float.valueOf(0.0f));
					        		changed = true;
				        		//}
				        	}
			        	} catch ( Exception e ) {
			        		Log.e(""cr3"", ""WindowManager.LayoutParams.buttonBrightness field is not found, cannot turn buttons backlight off"");
			        		brightnessHackError = true;
			        	}
			        	//attrs.buttonBrightness = 0;
			        	if ( changed ) {
			        		Log.d(""cr3"", ""Window attribute changed: "" + attrs);
			        		wnd.setAttributes(attrs);
			        	}
			        	//attrs.screenOrientation = LayoutParams.SCREEN_;
			        }
				} catch ( Exception e ) {
					// ignore
				}
			}
    	});
    }
    
    boolean mDestroyed = false;
	@Override
	protected void onDestroy() {

		Log.i(""cr3"", ""CoolReader.onDestroy() entered"");
		mDestroyed = true;
		if ( !CLOSE_BOOK_ON_STOP )
			mReaderView.close();
		
		//if ( mReaderView!=null )
		//	mReaderView.close();
		
		//if ( mHistory!=null && mDB!=null ) {
			//history.saveToDB();
		//}
		if ( intentReceiver!=null ) {
			unregisterReceiver(intentReceiver);
			intentReceiver = null;
		}

		if ( mReaderView!=null ) {
			mReaderView.destroy();
		}
		if ( mEngine!=null ) {
			mEngine.uninit();
		}
		if ( mDB!=null ) {
			final CRDB db = mDB;
			mBackgroundThread.executeBackground(new Runnable() {
				public void run() {
					db.close();
				}
			});
		}
//		if ( mBackgroundThread!=null ) {
//			mBackgroundThread.quit();
//		}
			
		mDB = null;
		mReaderView = null;
		mEngine = null;
		mBackgroundThread = null;
		Log.i(""cr3"", ""CoolReader.onDestroy() exiting"");
		super.onDestroy();
	}

	private String extractFileName( Uri uri )
	{
		if ( uri!=null ) {
			if ( uri.equals(Uri.parse(""file:///"")) )
				return null;
			else
				return uri.getPath();
		}
		return null;
	}
	
	@Override
	protected void onNewIntent(Intent intent) {
		Log.i(""cr3"", ""onNewIntent : "" + intent);
		if ( mDestroyed ) {
			Log.e(""cr3"", ""engine is already destroyed"");
			return;
		}
		String fileToOpen = null;
		if ( Intent.ACTION_VIEW.equals(intent.getAction()) ) {
			Uri uri = intent.getData();
			if ( uri!=null ) {
				fileToOpen = extractFileName(uri);
			}
			intent.setData(null);
		}
		Log.v(""cr3"", ""onNewIntent, fileToOpen="" + fileToOpen);
		if ( fileToOpen!=null ) {
			// load document
			final String fn = fileToOpen;
			mReaderView.loadDocument(fileToOpen, new Runnable() {
				public void run() {
					Log.v(""cr3"", ""onNewIntent, loadDocument error handler called"");
					showToast(""Error occured while loading "" + fn);
					mEngine.hideProgress();
				}
			});
		}
	}

	@Override
	protected void onPause() {
		Log.i(""cr3"", ""CoolReader.onPause() : saving reader state"");
		releaseBacklightControl();
		mReaderView.save();
		super.onPause();
	}
	
	public void releaseBacklightControl()
	{
		backlightControl.release();
	}

	@Override
	protected void onPostCreate(Bundle savedInstanceState) {
		Log.i(""cr3"", ""CoolReader.onPostCreate()"");
		super.onPostCreate(savedInstanceState);
	}

	@Override
	protected void onPostResume() {
		Log.i(""cr3"", ""CoolReader.onPostResume()"");
		super.onPostResume();
	}

	private boolean restarted = false;
	@Override
	protected void onRestart() {
		Log.i(""cr3"", ""CoolReader.onRestart()"");
		restarted = true;
		super.onRestart();
	}

	@Override
	protected void onRestoreInstanceState(Bundle savedInstanceState) {
		Log.i(""cr3"", ""CoolReader.onRestoreInstanceState()"");
		super.onRestoreInstanceState(savedInstanceState);
	}

	@Override
	protected void onResume() {
		Log.i(""cr3"", ""CoolReader.onResume()"");
		super.onResume();
	}

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		Log.i(""cr3"", ""CoolReader.onSaveInstanceState()"");
		super.onSaveInstanceState(outState);
	}

	static final boolean LOAD_LAST_DOCUMENT_ON_START = true; 
	
	@Override
	protected void onStart() {
		Log.i(""cr3"", ""CoolReader.onStart() fileToLoadOnStart="" + fileToLoadOnStart);
		super.onStart();
		
		backlightControl.onUserActivity();

		if ( fileToLoadOnStart==null ) {
			if ( mReaderView!=null && currentView==mReaderView && mReaderView.isBookLoaded() ) {
				Log.v(""cr3"", ""Book is already opened, showing ReaderView"");
				showReader();
				return;
			}
			
			//!stopped && 
//			if ( restarted && mReaderView!=null && mReaderView.isBookLoaded() ) {
//				Log.v(""cr3"", ""Book is already opened, showing ReaderView"");
//		        restarted = false;
//		        return;
//			}
		}
		if ( !stopped ) {
	        mEngine.showProgress( 500, R.string.progress_starting_cool_reader );
			//mEngine.setHyphenationDictionary( HyphDict.RUSSIAN );
		}
        //Log.i(""cr3"", ""waiting for engine tasks completion"");
        //engine.waitTasksCompletion();
		restarted = false;
		stopped = false;
		final String fileName = fileToLoadOnStart;
		mBackgroundThread.postGUI(new Runnable() {
			public void run() {
		        Log.i(""cr3"", ""onStart, scheduled runnable: submitting task"");
		        mEngine.execute(new LoadLastDocumentTask(fileName));
			}
		});
		Log.i(""cr3"", ""CoolReader.onStart() exiting"");
	}
	
	class LoadLastDocumentTask implements Engine.EngineTask {

		final String fileName;
		public LoadLastDocumentTask( String fileName ) {
			super();
			this.fileName = fileName;
		}
		
		public void done() {
	        Log.i(""cr3"", ""onStart, scheduled task: trying to load "" + fileToLoadOnStart);
			if ( fileName!=null || LOAD_LAST_DOCUMENT_ON_START ) {
				//currentView=mReaderView;
				if ( fileName!=null ) {
					Log.v(""cr3"", ""onStart() : loading "" + fileName);
					mReaderView.loadDocument(fileName, new Runnable() {
						public void run() {
							// cannot open recent book: load another one
							Log.e(""cr3"", ""Cannot open document "" + fileToLoadOnStart + "" starting file browser"");
							showBrowser(null);
						}
					});
				} else {
					Log.v(""cr3"", ""onStart() : loading last document"");
					mReaderView.loadLastDocument(new Runnable() {
						public void run() {
							// cannot open recent book: load another one
							Log.e(""cr3"", ""Cannot open last document, starting file browser"");
							showBrowser(null);
						}
					});
				}
			} else {
				showBrowser(null);
			}
			fileToLoadOnStart = null;
		}

		public void fail(Exception e) {
	        Log.e(""cr3"", ""onStart, scheduled task failed"", e);
		}

		public void work() throws Exception {
	        Log.v(""cr3"", ""onStart, scheduled task work()"");
		}
    }
 

	public final static boolean CLOSE_BOOK_ON_STOP = false;
	private boolean stopped = false;
	@Override
	protected void onStop() {
		Log.i(""cr3"", ""CoolReader.onStop() entering"");
		stopped = true;
		// will close book at onDestroy()
		if ( CLOSE_BOOK_ON_STOP )
			mReaderView.close();
		super.onStop();
		Log.i(""cr3"", ""CoolReader.onStop() exiting"");
	}

	private View currentView;
	public void showView( View view )
	{
		showView( view, true );
	}
	public void showView( View view, boolean hideProgress )
	{
		if ( hideProgress )
		mBackgroundThread.postGUI(new Runnable() {
			public void run() {
				mEngine.hideProgress();
			}
		});
		if ( currentView==view ) {
			Log.v(""cr3"", ""showView : view "" + view.getClass().getSimpleName() + "" is already shown"");
			return;
		}
		Log.v(""cr3"", ""showView : showing view "" + view.getClass().getSimpleName());
		mFrame.bringChildToFront(view);
		for ( int i=0; i<mFrame.getChildCount(); i++ ) {
			View v = mFrame.getChildAt(i);
			v.setVisibility(view==v?View.VISIBLE:View.INVISIBLE);
		}
		currentView = view;
	}
	
	public void showReader()
	{
		Log.v(""cr3"", ""showReader() is called"");
		showView(mReaderView);
	}
	
	public boolean isBookOpened()
	{
		return mReaderView.isBookLoaded();
	}
	
	public void loadDocument( FileInfo item )
	{
		//showView(readerView);
		//setContentView(readerView);
		mReaderView.loadDocument(item);
	}
	
	public void showBrowser( final FileInfo fileToShow )
	{
		Log.v(""cr3"", ""showBrowser() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
		        if ( fileToShow==null )
		        	mBrowser.showLastDirectory();
		        else
		        	mBrowser.showDirectory(fileToShow, fileToShow);
			}
		});
	}

	public void showBrowserRecentBooks()
	{
		Log.v(""cr3"", ""showBrowserRecentBooks() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
	        	mBrowser.showRecentBooks();
			}
		});
	}

	public void showBrowserRoot()
	{
		Log.v(""cr3"", ""showBrowserRoot() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
	        	mBrowser.showRootDirectory();
			}
		});
	}

	private void fillMenu(Menu menu) {
		menu.clear();
	    MenuInflater inflater = getMenuInflater();
	    if ( currentView==mReaderView )
	    	inflater.inflate(R.menu.cr3_reader_menu, menu);
	    else {
	    	inflater.inflate(R.menu.cr3_browser_menu, menu);
	    	if ( !isBookOpened() ) {
	    		MenuItem item = menu.findItem(R.id.book_back_to_reading);
	    		if ( item!=null )
	    			item.setEnabled(false);
	    	}
	    }
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		fillMenu(menu);
	    return true;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		fillMenu(menu);
	    return true;
	}

	public void showToast( int stringResourceId )
	{
		String s = getString(stringResourceId);
		if ( s!=null )
			showToast(s);
	}

	public void showToast( String msg )
	{
		Log.v(""cr3"", ""showing toast: "" + msg);
		Toast toast = Toast.makeText(this, msg, Toast.LENGTH_LONG);
		toast.show();
	}

	public interface InputHandler {
		boolean validate( String s ) throws Exception;
		void onOk( String s ) throws Exception;
		void onCancel();
	};
	
	public static class InputDialog extends BaseDialog {
		private InputHandler handler;
		private EditText input;
		public InputDialog( CoolReader activity, final String title, boolean isNumberEdit, final InputHandler handler )
		{
			super(activity, R.string.dlg_button_ok, R.string.dlg_button_cancel, true);
			this.handler = handler;
			setTitle(title);
	        input = new EditText(getContext());
	        if ( isNumberEdit )
		        input.getText().setFilters(new InputFilter[] {
		        	new DigitsKeyListener()        
		        });
	        setView(input);
		}
		@Override
		protected void onNegativeButtonClick() {
            cancel();
            handler.onCancel();
		}
		@Override
		protected void onPositiveButtonClick() {
            String value = input.getText().toString().trim();
            try {
            	if ( handler.validate(value) )
            		handler.onOk(value);
            	else
            		handler.onCancel();
            } catch ( Exception e ) {
            	handler.onCancel();
            }
            cancel();
		}
	}
	
	public void showInputDialog( final String title, boolean isNumberEdit, final InputHandler handler )
	{
        final InputDialog dlg = new InputDialog(this, title, isNumberEdit, handler);
        dlg.show();
	}

	private int orientationFromSensor = 0;
	public int getOrientationFromSensor()
	{
		return orientationFromSensor;
	}
	
	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		// pass
		orientationFromSensor = newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE ? 1 : 0;
		//final int orientation = newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
//		if ( orientation!=screenOrientation ) {
//			Log.d(""cr3"", ""Screen orientation has been changed: ask for change"");
//			AlertDialog.Builder dlg = new AlertDialog.Builder(this);
//			dlg.setTitle(R.string.win_title_screen_orientation_change_apply);//R.string.win_title_options_apply);
//			dlg.setPositiveButton(R.string.dlg_button_ok, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					//onPositiveButtonClick();
//					Properties oldSettings = mReaderView.getSettings();
//					Properties newSettings = new Properties(oldSettings);
//					newSettings.setInt(ReaderView.PROP_APP_SCREEN_ORIENTATION, orientation==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE ? 1 : 0);
//					mReaderView.setSettings(newSettings, oldSettings);
//				}
//			});
//			dlg.setNegativeButton(R.string.dlg_button_cancel, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					//onNegativeButtonClick();
//				}
//			});
//		}
		super.onConfigurationChanged(newConfig);
	}

	String[] mFontFaces;

	public void showOptionsDialog()
	{
		final CoolReader _this = this;
		mBackgroundThread.executeBackground(new Runnable() {
			public void run() {
				mFontFaces = mEngine.getFontFaceList();
				mBackgroundThread.executeGUI(new Runnable() {
					public void run() {
						OptionsDialog dlg = new OptionsDialog(_this, mReaderView, mFontFaces);
						dlg.show();
					}
				});
			}
		});
	}
	
	public void showBookmarksDialog()
	{
		BookmarksDlg dlg = new BookmarksDlg(this, mReaderView);
		dlg.show();
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		int itemId = item.getItemId();
		if ( mReaderView.onMenuItem(itemId))
			return true; // processed by ReaderView
		// other commands
		switch ( itemId ) {
		case R.id.book_sort_order:
			showToast(""Sorry, this option is not yet supported"");
			break;
		case R.id.book_root:
			mBrowser.showRootDirectory();
			return true;
		case R.id.book_recent_books:
			mBrowser.showRecentBooks();
			return true;
		case R.id.book_back_to_reading:
			if ( isBookOpened() )
				showReader();
			else
				showToast(""No book opened"");
			return true;
		default:
			return false;
			//return super.onOptionsItemSelected(item);
		}
		return true;
	}
	
	public void showGoToPageDialog() {
		showInputDialog(""Enter page number"", true, new InputHandler() {
			int pageNumber = 0;
			public boolean validate(String s) {
				pageNumber = Integer.valueOf(s); 
				return pageNumber>0;
			}
			public void onOk(String s) {
				mReaderView.goToPage(pageNumber);
			}
			public void onCancel() {
			}
		});
	}
	public void showGoToPercentDialog() {
		showInputDialog(""Enter position %"", true, new InputHandler() {
			int percent = 0;
			public boolean validate(String s) {
				percent = Integer.valueOf(s); 
				return percent>=0 && percent<=100;
			}
			public void onOk(String s) {
				mReaderView.goToPercent(percent);
			}
			public void onCancel() {
			}
		});
	}

	private static class DefKeyAction {
		public int keyCode;
		public int type;
		public ReaderAction action;
		public DefKeyAction(int keyCode, int type, ReaderAction action) {
			this.keyCode = keyCode;
			this.type = type;
			this.action = action;
		}
		public String getProp() {
			return ReaderView.PROP_APP_KEY_ACTIONS_PRESS + ReaderAction.getTypeString(type) + keyCode;			
		}
	}
	private static class DefTapAction {
		public int zone;
		public boolean longPress;
		public ReaderAction action;
		public DefTapAction(int zone, boolean longPress, ReaderAction action) {
			this.zone = zone;
			this.longPress = longPress;
			this.action = action;
		}
	}
	private static DefKeyAction[] DEF_KEY_ACTIONS = {
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.NORMAL, ReaderAction.FILE_BROWSER),
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.LONG, ReaderAction.EXIT),
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.DOUBLE, ReaderAction.EXIT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_CENTER, ReaderAction.NORMAL, ReaderAction.RECENT_BOOKS),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_CENTER, ReaderAction.LONG, ReaderAction.BOOKMARKS),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_UP, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_DOWN, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_UP_10),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN_10),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_LEFT, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_RIGHT, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_UP, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_DOWN, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_SEARCH, ReaderAction.LONG, ReaderAction.SEARCH),
		new DefKeyAction(KeyEvent.KEYCODE_MENU, ReaderAction.NORMAL, ReaderAction.READER_MENU),
		new DefKeyAction(KeyEvent.KEYCODE_MENU, ReaderAction.LONG, ReaderAction.OPTIONS),
		new DefKeyAction(KeyEvent.KEYCODE_CAMERA, ReaderAction.NORMAL, ReaderAction.NONE),
		new DefKeyAction(KeyEvent.KEYCODE_CAMERA, ReaderAction.LONG, ReaderAction.NONE),
		new DefKeyAction(ReaderView.NOOK_KEY_NEXT_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_NEXT_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_SHIFT_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_PREV_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.NOOK_KEY_PREV_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.NOOK_KEY_SHIFT_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
	};
	private static DefTapAction[] DEF_TAP_ACTIONS = {
		new DefTapAction(1, false, ReaderAction.PAGE_UP),
		new DefTapAction(2, false, ReaderAction.PAGE_UP),
		new DefTapAction(4, false, ReaderAction.PAGE_UP),
		new DefTapAction(1, true, ReaderAction.PAGE_UP_10),
		new DefTapAction(2, true, ReaderAction.PAGE_UP_10),
		new DefTapAction(4, true, ReaderAction.PAGE_UP_10),
		new DefTapAction(3, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(6, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(7, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(8, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(9, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(3, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(6, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(7, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(8, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(8, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(5, false, ReaderAction.READER_MENU),
		new DefTapAction(5, true, ReaderAction.OPTIONS),
	};
	File propsFile;
	private static final String SETTINGS_FILE_NAME = ""cr3.ini"";
	private static boolean DEBUG_RESET_OPTIONS = false;
	private Properties loadSettings()
	{
        Properties props = new Properties();

		File[] dataDirs = Engine.getDataDirectories(null, false, true);
		File existingFile = null;
		for ( File dir : dataDirs ) {
			File f = new File(dir, SETTINGS_FILE_NAME);
			if ( f.exists() && f.isFile() ) {
				existingFile = f;
				break;
			}
		}
        if ( existingFile!=null )
        	propsFile = existingFile;
        else {
	        File propsDir = getDir(""settings"", Context.MODE_PRIVATE);
			propsDir.mkdirs();
			propsFile = new File( propsDir, ""cr3.ini"");
        }
        if ( propsFile.exists() && !DEBUG_RESET_OPTIONS ) {
        	try {
        		FileInputStream is = new FileInputStream(propsFile);
        		props.load(is);
        		Log.v(""cr3"", """" + props.size() + "" settings items loaded from file "" + propsFile.getAbsolutePath() );
        	} catch ( Exception e ) {
        		Log.e(""cr3"", ""error while reading settings"");
        	}
        }
        
        // default key actions
        for ( DefKeyAction ka : DEF_KEY_ACTIONS ) {
        		props.applyDefault(ka.getProp(), ka.action.id);
        }
        // default tap zone actions
        for ( DefTapAction ka : DEF_TAP_ACTIONS ) {
        	if ( ka.longPress )
        		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + "".long."" + ka.zone, ka.action.id);
        	else
        		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + ""."" + ka.zone, ka.action.id);
        }
        
        props.applyDefault(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK, ""1"");
        props.applyDefault(ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED, ""1"");
        props.applyDefault(ReaderView.PROP_FONT_SIZE, ""20"");
        props.applyDefault(ReaderView.PROP_FONT_FACE, ""Droid Sans"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_FACE, ""Droid Sans"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_SIZE, ""16"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR, ""#FF000000""); // don't use separate color
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR_DAY, ""#FF000000""); // don't use separate color
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR_NIGHT, ""#FF000000""); // don't use separate color
        props.setProperty(ReaderView.PROP_ROTATE_ANGLE, ""0""); // crengine's rotation will not be user anymore
        props.setProperty(ReaderView.PROP_DISPLAY_INVERSE, ""0"");
        props.applyDefault(ReaderView.PROP_APP_FULLSCREEN, ""0"");
        props.applyDefault(ReaderView.PROP_APP_SCREEN_BACKLIGHT, ""-1"");
		props.applyDefault(ReaderView.PROP_SHOW_BATTERY, ""1""); 
		props.applyDefault(ReaderView.PROP_SHOW_TIME, ""1"");
		props.applyDefault(ReaderView.PROP_FONT_ANTIALIASING, ""2"");
		props.applyDefault(ReaderView.PROP_APP_SHOW_COVERPAGES, ""1"");
		props.applyDefault(ReaderView.PROP_APP_SCREEN_ORIENTATION, ""4"");
		props.applyDefault(ReaderView.PROP_PAGE_ANIMATION, ""1"");
		props.applyDefault(ReaderView.PROP_CONTROLS_ENABLE_VOLUME_KEYS, ""1"");
		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_HILIGHT, ""0"");

		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_LEFT, ""2"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_RIGHT, ""2"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_TOP, ""2"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_BOTTOM, ""2"");
		
        props.applyDefault(ReaderView.PROP_NIGHT_MODE, ""0"");
        if ( props.getBool(ReaderView.PROP_NIGHT_MODE, false) )
        	props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.DEF_NIGHT_BACKGROUND_TEXTURE);
        else
        	props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.DEF_DAY_BACKGROUND_TEXTURE);
        props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_DAY, Engine.DEF_DAY_BACKGROUND_TEXTURE);
        props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_NIGHT, Engine.DEF_NIGHT_BACKGROUND_TEXTURE);
        
		
		props.setProperty(ReaderView.PROP_MIN_FILE_SIZE_TO_CACHE, ""100000"");
		props.setProperty(ReaderView.PROP_FORCED_MIN_FILE_SIZE_TO_CACHE, ""32768"");
		props.applyDefault(ReaderView.PROP_HYPHENATION_DICT, Engine.HyphDict.RUSSIAN.toString());
		return props;
	}
	
	public void saveSettings( Properties settings )
	{
		try {
			Log.v(""cr3"", ""saveSettings() "" + settings);
    		FileOutputStream os = new FileOutputStream(propsFile);
    		settings.store(os, ""Cool Reader 3 settings"");
			Log.i(""cr3"", ""Settings successfully saved to file "" + propsFile.getAbsolutePath());
		} catch ( Exception e ) {
			Log.e(""cr3"", ""exception while saving settings"", e);
		}
	}

	private static Debug.MemoryInfo info = new Debug.MemoryInfo();
	private static Field[] infoFields = Debug.MemoryInfo.class.getFields();
	private static String dumpFields( Field[] fields, Object obj) {
		StringBuilder buf = new StringBuilder();
		try {
			for ( Field f : fields ) {
				if ( buf.length()>0 )
					buf.append("", "");
				buf.append(f.getName());
				buf.append(""="");
				buf.append(f.get(obj));
			}
		} catch ( Exception e ) {
			
		}
		return buf.toString();
	}
	public static void dumpHeapAllocation() {
		Debug.getMemoryInfo(info);
		Log.d(""cr3"", ""nativeHeapAlloc="" + Debug.getNativeHeapAllocatedSize() + "", nativeHeapSize="" + Debug.getNativeHeapSize() + "", info: "" + dumpFields(infoFields, info));
	}
}
",True,26,27,0,0,2,13,10,13,L1
1,org.coolreader.crengine.Selection.java,"package org.coolreader.crengine;

public class Selection {
	// IN
	public int startX;
	public int startY;
	public int endX;
	public int endY;
	// OUT
	public String startPos; 
	public String endPos;
	public String text;
	public int percent;
	
	boolean isEmpty() { return startPos==null || endPos==null; }
}
",False,18,16,4,9,0,0,1,0,L2
2,org.coolreader.crengine.BookInfo.java,"package org.coolreader.crengine;

import java.util.ArrayList;

public class BookInfo {
	private FileInfo fileInfo;
	private Bookmark lastPosition;
	private ArrayList<Bookmark> bookmarks = new ArrayList<Bookmark>();

	synchronized public void setShortcutBookmark(int shortcut, Bookmark bookmark)
	{
		bookmark.setShortcut(shortcut);
		bookmark.setModified(true);
		for ( int i=0; i<bookmarks.size(); i++ ) {
			Bookmark bm = bookmarks.get(i);
			if ( bm.getType()==Bookmark.TYPE_POSITION && bm.getShortcut()==shortcut ) {
				bookmark.setId(bm.getId());
				bookmarks.set(i, bookmark);
				return;
			}
		}
		bookmarks.add(bookmark);
	}
	
	synchronized public Bookmark findShortcutBookmark( int shortcut )
	{
		for ( Bookmark bm : bookmarks )
			if ( bm.getType()==Bookmark.TYPE_POSITION && bm.getShortcut()==shortcut )
				return bm;
		return null;
	}
	
	public void updateAccess()
	{
		// TODO:
	}
	
	public BookInfo( FileInfo fileInfo )
	{
		this.fileInfo = fileInfo; //new FileInfo(fileInfo);
	}
	
	public Bookmark getLastPosition()
	{
		return lastPosition;
	}
	
	synchronized public void setLastPosition( Bookmark position )
	{
		if ( lastPosition!=null )
			position.setId(lastPosition.getId());
		lastPosition = position;
		lastPosition.setModified(true);
		fileInfo.lastAccessTime = lastPosition.getTimeStamp();
		fileInfo.setModified(true);
	}
	
	public FileInfo getFileInfo()
	{
		return fileInfo;
	}
	
	synchronized public void addBookmark( Bookmark bm )
	{
		bookmarks.add(bm);
	}

	synchronized public int getBookmarkCount()
	{
		return bookmarks.size();
	}

	synchronized public Bookmark getBookmark( int index )
	{
		return bookmarks.get(index);
	}

	synchronized public void removeBookmark( int index )
	{
		bookmarks.remove(index);
	}
	
	synchronized void setBookmarks(ArrayList<Bookmark> list)
	{
		if ( list.size()>0 ) {
			if ( list.get(0).getType()==0 ) {
				lastPosition = list.remove(0); 
			}
		}
		if ( list.size()>0 ) {
			bookmarks = list;
		}
	}

	@Override
	public String toString() {
		return ""BookInfo [fileInfo="" + fileInfo + "", lastPosition=""
				+ lastPosition + ""]"";
	}

	
	
}
",False,22,20,3,9,2,2,4,2,L1
3,org.coolreader.crengine.ProgressDialog.java,"package org.coolreader.crengine;

import android.app.AlertDialog;
import android.content.Context;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import org.coolreader.R;

/**
 * Progress dialog, based on source code of android.app.ProgressDialog
 */
public class ProgressDialog extends AlertDialog {
    
    /** Creates a ProgressDialog with a ciruclar, spinning progress
     * bar. This is the default.
     */
    public static final int STYLE_SPINNER = 0;
    
    /** Creates a ProgressDialog with a horizontal progress bar.
     */
    public static final int STYLE_HORIZONTAL = 1;
    
    private ProgressBar mProgress;
    private TextView mMessageView;
    
    private int mProgressStyle = STYLE_SPINNER;
    
    private int mMax;
    private int mProgressVal;
    private int mSecondaryProgressVal;
    private int mIncrementBy;
    private int mIncrementSecondaryBy;
    private Drawable mProgressDrawable;
    private Drawable mIndeterminateDrawable;
    private CharSequence mMessage;
    private boolean mIndeterminate;
    
    private boolean mHasStarted;
    private Handler mViewUpdateHandler;
    private Context mContext;
    
    public ProgressDialog(Context context) {
        super(context);
        mContext = context;
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message) {
        return show(context, title, message, false);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate) {
        return show(context, title, message, indeterminate, false, null);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate, boolean cancelable) {
        return show(context, title, message, indeterminate, cancelable, null);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate,
            boolean cancelable, OnCancelListener cancelListener) {
        ProgressDialog dialog = new ProgressDialog(context);
        dialog.setTitle(title);
        dialog.setMessage(message);
        dialog.setIndeterminate(indeterminate);
        dialog.setCancelable(cancelable);
        dialog.setOnCancelListener(cancelListener);
        dialog.show();
        return dialog;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        LayoutInflater inflater = LayoutInflater.from(mContext);
        if (mProgressStyle == STYLE_HORIZONTAL) {
            
            /* Use a separate handler to update the text views as they
             * must be updated on the same thread that created them.
             */
            mViewUpdateHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                }
            };
            View view = inflater.inflate(R.layout.alert_dialog_progress, null);
            mProgress = (ProgressBar) view.findViewById(R.id.progress);
            setView(view);
        } else {
            View view = inflater.inflate(R.layout.progress_dialog, null);
            mProgress = (ProgressBar) view.findViewById(R.id.progress);
            mMessageView = (TextView) view.findViewById(R.id.message);
            setView(view);
        }
        if (mMax > 0) {
            setMax(mMax);
        }
        if (mProgressVal > 0) {
            setProgress(mProgressVal);
        }
        if (mSecondaryProgressVal > 0) {
            setSecondaryProgress(mSecondaryProgressVal);
        }
        if (mIncrementBy > 0) {
            incrementProgressBy(mIncrementBy);
        }
        if (mIncrementSecondaryBy > 0) {
            incrementSecondaryProgressBy(mIncrementSecondaryBy);
        }
        if (mProgressDrawable != null) {
            setProgressDrawable(mProgressDrawable);
        }
        if (mIndeterminateDrawable != null) {
            setIndeterminateDrawable(mIndeterminateDrawable);
        }
        if (mMessage != null) {
            setMessage(mMessage);
        }
        setIndeterminate(mIndeterminate);
        onProgressChanged();
        super.onCreate(savedInstanceState);
    }
    
    @Override
    public void onStart() {
        super.onStart();
        mHasStarted = true;
    }
    
    @Override
    protected void onStop() {
        super.onStop();
        mHasStarted = false;
    }

    public void setProgress(int value) {
        if (mHasStarted && mProgress!=null) {
            mProgress.setProgress(value);
            onProgressChanged();
        } else {
            mProgressVal = value;
        }
    }

    public void setSecondaryProgress(int secondaryProgress) {
        if (mProgress != null) {
            mProgress.setSecondaryProgress(secondaryProgress);
            onProgressChanged();
        } else {
            mSecondaryProgressVal = secondaryProgress;
        }
    }

    public int getProgress() {
        if (mProgress != null) {
            return mProgress.getProgress();
        }
        return mProgressVal;
    }

    public int getSecondaryProgress() {
        if (mProgress != null) {
            return mProgress.getSecondaryProgress();
        }
        return mSecondaryProgressVal;
    }

    public int getMax() {
        if (mProgress != null) {
            return mProgress.getMax();
        }
        return mMax;
    }

    public void setMax(int max) {
        if (mProgress != null) {
            mProgress.setMax(max);
            onProgressChanged();
        } else {
            mMax = max;
        }
    }

    public void incrementProgressBy(int diff) {
        if (mProgress != null) {
            mProgress.incrementProgressBy(diff);
            onProgressChanged();
        } else {
            mIncrementBy += diff;
        }
    }

    public void incrementSecondaryProgressBy(int diff) {
        if (mProgress != null) {
            mProgress.incrementSecondaryProgressBy(diff);
            onProgressChanged();
        } else {
            mIncrementSecondaryBy += diff;
        }
    }

    public void setProgressDrawable(Drawable d) {
        if (mProgress != null) {
            mProgress.setProgressDrawable(d);
        } else {
            mProgressDrawable = d;
        }
    }

    public void setIndeterminateDrawable(Drawable d) {
        if (mProgress != null) {
            mProgress.setIndeterminateDrawable(d);
        } else {
            mIndeterminateDrawable = d;
        }
    }

    public void setIndeterminate(boolean indeterminate) {
        if (mProgress != null) {
            mProgress.setIndeterminate(indeterminate);
        } else {
            mIndeterminate = indeterminate;
        }
    }

    public boolean isIndeterminate() {
        if (mProgress != null) {
            return mProgress.isIndeterminate();
        }
        return mIndeterminate;
    }
    
    @Override
    public void setMessage(CharSequence message) {
        if (mProgress != null) {
            if (mProgressStyle == STYLE_HORIZONTAL) {
                super.setMessage(message);
            } else {
                mMessageView.setText(message);
            }
        } else {
            mMessage = message;
        }
    }
    
    public void setProgressStyle(int style) {
        mProgressStyle = style;
    }

    private void onProgressChanged() {
        if (mProgressStyle == STYLE_HORIZONTAL) {
            mViewUpdateHandler.sendEmptyMessage(0);
        }
    }
}
",True,4,16,3,9,0,0,1,0,L1
4,org.coolreader.crengine.SearchDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;

public class SearchDlg  extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	private LayoutInflater mInflater;
	View mDialogView;
	EditText mEditView;
	CheckBox mCaseSensitive;
	CheckBox mReverse;
	
	@Override
	protected void onPositiveButtonClick()
	{
		// override it
    	String pattern = mEditView.getText().toString();
    	if ( pattern==null || pattern.length()==0 ) 
    		mCoolReader.showToast(""No pattern specified"");
    	else
    		mReaderView.findText( mEditView.getText().toString(), mReverse.isChecked(), !mCaseSensitive.isChecked() );
        cancel();
	}
	
	@Override
	protected void onNegativeButtonClick()
	{
		// override it
        cancel();
	}

	
	public SearchDlg( CoolReader coolReader, ReaderView readerView )
	{
		super(coolReader, R.string.dlg_button_find, R.string.dlg_button_cancel, false);
        setCancelable(true);
		this.mCoolReader = coolReader;
		this.mReaderView = readerView;
        mInflater = LayoutInflater.from(getContext());
        mDialogView = mInflater.inflate(R.layout.search_dialog, null);
    	mEditView = (EditText)mDialogView.findViewById(R.id.search_text);
    	mCaseSensitive = (CheckBox)mDialogView.findViewById(R.id.search_case_sensitive);
    	mReverse = (CheckBox)mDialogView.findViewById(R.id.search_reverse);
		setTitle(mCoolReader.getResources().getString(R.string.win_title_search));
		// setup buttons
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setView(mDialogView);
	}
}
",False,13,27,0,0,3,21,1,3,L2
5,org.coolreader.crengine.OptionsDialog.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.ColorPickerDialog.OnColorChangedListener;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.database.DataSetObserver;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Log;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.TabHost;
import android.widget.TabHost.TabContentFactory;
import android.widget.TextView;

public class OptionsDialog extends BaseDialog implements TabContentFactory {

	ReaderView mReaderView;
	CoolReader mActivity;
	String[] mFontFaces;
	int[] mFontSizes = new int[] {
		14, 16, 18, 20, 22, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 64, 68
	};
	int[] mStatusFontSizes = new int[] {
			14, 16, 18, 20, 22, 24, 26, 28, 30,
			32
		};
	int[] mBacklightLevels = new int[] {
		-1, 1, 5, 10, 15, 20, 30, 40, 50, 60, 70, 80, 100
	};
	String[] mBacklightLevelsTitles = new String[] {
			""Default"", ""1%"", ""5%"", ""10%"", ""15%"", ""20%"", ""30%"", ""40%"", ""50%"", ""60%"", ""70%"", ""80%"", ""100%"",
	};
	int[] mInterlineSpaces = new int[] {
			80, 90, 100, 110, 120, 130, 140, 150
		};
	int[] mMargins = new int[] {
			0, 1, 2, 3, 4, 5, 10, 15, 20, 25
		};
	int[] mOrientations = new int[] {
			0, 1//, 2, 3
			,4
		};
	int[] mOrientationsTitles = new int[] {
			R.string.options_page_orientation_0, R.string.options_page_orientation_90 //, R.string.options_page_orientation_180, R.string.options_page_orientation_270
			,R.string.options_page_orientation_sensor
		};
	int[] mAnimation = new int[] {
			ReaderView.PAGE_ANIMATION_NONE, ReaderView.PAGE_ANIMATION_SLIDE, 
			ReaderView.PAGE_ANIMATION_PAPER
		};
	int[] mAnimationTitles = new int[] {
			R.string.options_page_animation_none, R.string.options_page_animation_slide,
			R.string.options_page_animation_paperbook
		};
	int[] mAntialias = new int[] {
			0, 1, 2
		};
	int[] mAntialiasTitles = new int[] {
			R.string.options_font_antialias_off, R.string.options_font_antialias_on_for_big, R.string.options_font_antialias_on_for_all
		};
	int[] mLandscapePages = new int[] {
			1, 2
		};
	int[] mLandscapePagesTitles = new int[] {
			R.string.options_page_landscape_pages_one, R.string.options_page_landscape_pages_two
		};
	int[] mViewModes = new int[] {
			1, 0
		};
	int[] mViewModeTitles = new int[] {
			R.string.options_view_mode_pages, R.string.options_view_mode_scroll
		};
	TabHost mTabs;
	LayoutInflater mInflater;
	Properties mProperties;
	Properties mOldProperties;
	OptionsListView mOptionsStyles;
	OptionsListView mOptionsPage;
	OptionsListView mOptionsApplication;
	OptionsListView mOptionsControls;

	private final int OPTION_VIEW_TYPE_NORMAL = 0;
	private final int OPTION_VIEW_TYPE_BOOLEAN = 1;
	private final int OPTION_VIEW_TYPE_COLOR = 2;
	private final int OPTION_VIEW_TYPE_COUNT = 3;
	
	class OptionBase {
		protected View myView;
		public String label;
		public String property;
		public String defaultValue;
		public int iconId = R.drawable.cr3_option_other;
		public OptionsListView optionsListView;
		protected Runnable onChangeHandler;
		public OptionBase( String label, String property ) {
			this.label = label;
			this.property = property;
		}
		public OptionBase setIconId(int id) {
			this.iconId = id;
			return this;
		}
		public OptionBase setDefaultValue(String value) {
			this.defaultValue = value;
			if ( mProperties.getProperty(property)==null )
				mProperties.setProperty(property, value);
			return this;
		}
		public void setOnChangeHandler( Runnable handler ) {
			onChangeHandler = handler;
		}

		public int getItemViewType() {
			return OPTION_VIEW_TYPE_NORMAL;
		}

		protected void refreshItem()
		{
			getView(null, null).invalidate();
			//if ( optionsListView!=null )
			//	optionsListView.refresh();
		}

		protected void refreshList()
		{
			getView(null, null).invalidate();
			if ( optionsListView!=null )
				optionsListView.refresh();
		}

		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			TextView valueView = (TextView)view.findViewById(R.id.option_value);
			labelView.setText(label);
			valueView.setText(getValueLabel());
			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
			icon.setImageResource(iconId);
			return view;
		}

		public String getValueLabel() { return mProperties.getProperty(property); }
		public void onSelect() { refreshList(); }
	}
	
	class ColorOption extends OptionBase {
		final int defColor;
		public ColorOption( String label, String property, int defColor ) {
			super(label, property);
			this.defColor = defColor;
		}
		public String getValueLabel() { return mProperties.getProperty(property); }
		public void onSelect()
		{ 
			ColorPickerDialog dlg = new ColorPickerDialog(mActivity, new OnColorChangedListener() {
				public void colorChanged(int color) {
					mProperties.setColor(property, color);
					if ( property.equals(ReaderView.PROP_BACKGROUND_COLOR) ) {
						String texture = mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.NO_TEXTURE.id);
						if ( texture!=null && !texture.equals(Engine.NO_TEXTURE.id) ) {
							// reset background image
							mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.NO_TEXTURE.id);
							// TODO: show notification?
						}
					}
					refreshList();
				}
			}, mProperties.getColor(property, defColor), label);
			dlg.show();
		}
		public int getItemViewType() {
			return OPTION_VIEW_TYPE_COLOR;
		}
		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item_color, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			ImageView valueView = (ImageView)view.findViewById(R.id.option_value_color);
			labelView.setText(label);
			int cl = mProperties.getColor(property, defColor);
			valueView.setBackgroundColor(cl);
			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
			icon.setImageResource(iconId);
			return view;
		}
	}
	
	class BoolOption extends OptionBase {
		private boolean inverse = false;
		public BoolOption( String label, String property ) {
			super(label, property);
		}
		private boolean getValueBoolean() { return ""1"".equals(mProperties.getProperty(property)) ^ inverse; }
		public String getValueLabel() { return getValueBoolean()  ? getString(R.string.options_value_on) : getString(R.string.options_value_off); }
		public void onSelect() { 
			mProperties.setProperty(property, ""1"".equals(mProperties.getProperty(property)) ? ""0"" : ""1"");
			refreshList();
		}
		public BoolOption setInverse() { inverse = true; return this; }
		public int getItemViewType() {
			return OPTION_VIEW_TYPE_BOOLEAN;
		}
		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item_boolean, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			CheckBox valueView = (CheckBox)view.findViewById(R.id.option_value_cb);
//			valueView.setFocusable(false);
//			valueView.setClickable(false);
			labelView.setText(label);
			valueView.setChecked(getValueBoolean());
			valueView.setOnCheckedChangeListener(new OnCheckedChangeListener() {
					@Override
					public void onCheckedChanged(CompoundButton arg0,
							boolean checked) {
//						mProperties.setBool(property, checked);
//						refreshList();
					}
				});
			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
			icon.setImageResource(iconId);
//			view.setClickable(true);
//			view.setFocusable(true);
			return view;
		}
	}

	static public void saveColor( Properties mProperties, boolean night )
	{
		if ( night ) {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_NIGHT, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR_NIGHT, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR, 0x000000));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR_NIGHT, mProperties.getColor(ReaderView.PROP_FONT_COLOR, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR_NIGHT, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR, 0xFFFFFF));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_NIGHT, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, -1));
		} else {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_DAY, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR_DAY, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR_DAY, mProperties.getColor(ReaderView.PROP_FONT_COLOR, 0x000000));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR_DAY, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR, 0x000000));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_DAY, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, -1));
		}
	}
	static public void restoreColor( Properties mProperties,  boolean night )
	{
		if ( night ) {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_NIGHT, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR_NIGHT, 0x000000));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR, mProperties.getColor(ReaderView.PROP_FONT_COLOR_NIGHT, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR_NIGHT, 0xFFFFFF));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_NIGHT, 70));
		} else {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_DAY, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR_DAY, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR, mProperties.getColor(ReaderView.PROP_FONT_COLOR_DAY, 0x000000));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR_DAY, 0x000000));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_DAY, 80));
		}
	}

	static public void toggleDayNightMode( Properties mProperties ) {
		boolean oldMode = mProperties.getBool(ReaderView.PROP_NIGHT_MODE, false);
		saveColor(mProperties, oldMode);
		boolean newMode = !oldMode;
		restoreColor(mProperties, newMode);
		mProperties.setBool(ReaderView.PROP_NIGHT_MODE, newMode);
	}

	class NightModeOption extends BoolOption {
		public NightModeOption( String label, String property ) {
			super(label, property);
		}
		public void onSelect() { 
			toggleDayNightMode(mProperties);
			refreshList();
		}
	}
	
	class ActionOption extends ListOption {
		public ActionOption( String label, String property, boolean isTap, boolean allowRepeat ) {
			super(label, property);
			ReaderAction[] actions = ReaderAction.AVAILABLE_ACTIONS;
			for ( ReaderAction a : actions )
				if ( !isTap || a.mayAssignOnTap() )
					add(a.id, getString(a.nameId));
			if ( allowRepeat )
				add(ReaderAction.REPEAT.id, getString(ReaderAction.REPEAT.nameId));
			if ( mProperties.getProperty(property)==null )
				mProperties.setProperty(property, ReaderAction.NONE.id);
		}
	}

	class KeyMapOption extends ListOption {
		public KeyMapOption( String label ) {
			super(label, ReaderView.PROP_APP_KEY_ACTIONS_PRESS);
		}
		private void addKey( OptionsListView list, int keyCode, String keyName ) {
			final String propName = ReaderAction.getKeyProp(keyCode, ReaderAction.NORMAL);
			final String longPropName = ReaderAction.getKeyProp(keyCode, ReaderAction.LONG);
			final String dblPropName = ReaderAction.getKeyProp(keyCode, ReaderAction.DOUBLE);
			list.add(new ActionOption(keyName, propName, false, false));
			list.add(new ActionOption(keyName + "" "" + getContext().getString(R.string.options_app_key_long_press), longPropName, false, true));
			list.add(new ActionOption(keyName + "" "" + getContext().getString(R.string.options_app_key_double_press), dblPropName, false, false));
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, R.string.dlg_button_ok, 0, false);
			OptionsListView listView = new OptionsListView(getContext());
			addKey(listView, KeyEvent.KEYCODE_DPAD_LEFT, ""Left"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_RIGHT, ""Right"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_UP, ""Up"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_DOWN, ""Down"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_CENTER, ""Center"");
			addKey(listView, KeyEvent.KEYCODE_BACK, ""Back"");
			addKey(listView, KeyEvent.KEYCODE_MENU, ""Menu"");
			addKey(listView, KeyEvent.KEYCODE_SEARCH, ""Search"");
			addKey(listView, KeyEvent.KEYCODE_VOLUME_UP, ""Volume Up"");
			addKey(listView, KeyEvent.KEYCODE_VOLUME_DOWN, ""Volume Down"");
			addKey(listView, KeyEvent.KEYCODE_CAMERA, ""Camera"");
			dlg.setTitle(label);
			dlg.setView(listView);
			dlg.show();
		}

		public String getValueLabel() { return "">""; }
	}
	
	class StatusBarOption extends ListOption {
		public StatusBarOption( String label ) {
			super(label, ReaderView.PROP_SHOW_TITLE);
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, R.string.dlg_button_ok, 0, false);
			OptionsListView listView = new OptionsListView(getContext());
			listView.add(new BoolOption(getString(R.string.options_page_show_titlebar), ReaderView.PROP_STATUS_LINE).setInverse().setDefaultValue(""0""));
			listView.add(new ListOption(getString(R.string.options_page_titlebar_font_face), ReaderView.PROP_STATUS_FONT_FACE).add(mFontFaces).setDefaultValue(mFontFaces[0]).setIconId(R.drawable.cr3_option_font_face));
			listView.add(new ListOption(getString(R.string.options_page_titlebar_font_size), ReaderView.PROP_STATUS_FONT_SIZE).add(mStatusFontSizes).setDefaultValue(""18"").setIconId(R.drawable.cr3_option_font_size));
			listView.add(new ColorOption(getString(R.string.options_page_titlebar_font_color), ReaderView.PROP_STATUS_FONT_COLOR, 0x000000));
			listView.add(new BoolOption(getString(R.string.options_page_show_titlebar_title), ReaderView.PROP_SHOW_TITLE).setDefaultValue(""1""));
			listView.add(new BoolOption(getString(R.string.options_page_show_titlebar_chapter_marks), ReaderView.PROP_STATUS_CHAPTER_MARKS).setDefaultValue(""1""));
			listView.add(new BoolOption(getString(R.string.options_page_show_titlebar_battery_percent), ReaderView.PROP_SHOW_BATTERY_PERCENT).setDefaultValue(""1""));
			dlg.setTitle(label);
			dlg.setView(listView);
			dlg.show();
		}

		public String getValueLabel() { return "">""; }
	}
	
	class TapZoneOption extends OptionBase {
		public TapZoneOption( String label, String property ) {
			super(label, property);
		}
		View grid;
		private void initTapZone( View view, final int tapZoneId )
		{
			if ( view==null )
				return;
			final TextView text = (TextView)view.findViewById(R.id.tap_zone_action_text_short);
			final TextView longtext = (TextView)view.findViewById(R.id.tap_zone_action_text_long);
			final String propName = property + ""."" + tapZoneId;
			final String longPropName = property + "".long."" + tapZoneId;
			ReaderAction action = ReaderAction.findById( mProperties.getProperty(propName) );
			ReaderAction longAction = ReaderAction.findById( mProperties.getProperty(longPropName) );
			text.setText(getString(action.nameId));
			longtext.setText(getString(longAction.nameId));
			view.setLongClickable(true);
			view.setOnClickListener(new View.OnClickListener () {
				@Override
				public void onClick(View v) {
					// TODO: i18n
					ActionOption option = new ActionOption(getString(R.string.options_app_tap_action_short), propName, true, false);
					option.setOnChangeHandler(new Runnable() {
						public void run() {
							ReaderAction action = ReaderAction.findById( mProperties.getProperty(propName) );
							text.setText(getString(action.nameId));
						}
					});
					option.onSelect();
				}
			});
			view.setOnLongClickListener(new View.OnLongClickListener () {
				@Override
				public boolean onLongClick(View v) {
					// TODO: i18n
					ActionOption option = new ActionOption(getString(R.string.options_app_tap_action_long), longPropName, true, true);
					option.setOnChangeHandler(new Runnable() {
						public void run() {
							ReaderAction longAction = ReaderAction.findById( mProperties.getProperty(longPropName) );
							longtext.setText(getString(longAction.nameId));
						}
					});
					option.onSelect();
					return true;
				}
			});
		}

		public String getValueLabel() { return "">""; }
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, R.string.dlg_button_ok, 0, false);
			grid = (View)mInflater.inflate(R.layout.options_tap_zone_grid, null);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell1), 1);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell2), 2);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell3), 3);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell4), 4);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell5), 5);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell6), 6);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell7), 7);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell8), 8);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell9), 9);
			dlg.setTitle(label);
			dlg.setView(grid);
			dlg.show();
		}
	}
	
	class Pair {
		public String value;
		public String label;
		public Pair(String value, String label) {
			this.value = value;
			this.label = label;
		}
	}

	class ListOption extends OptionBase {
		private ArrayList<Pair> list = new ArrayList<Pair>();
		public ListOption( String label, String property ) {
			super(label, property);
		}
		public void add(String value, String label) {
			list.add( new Pair(value, label) );
		}
		public ListOption add(String[]values) {
			for ( String item : values ) {
				add(item, item);
			}
			return this;
		}
		public ListOption add(int[]values) {
			for ( int item : values ) {
				String s = String.valueOf(item); 
				add(s, s);
			}
			return this;
		}
		public ListOption add(int[]values, int[]labelIDs) {
			for ( int i=0; i<values.length; i++ ) {
				String value = String.valueOf(values[i]); 
				String label = getContext().getString(labelIDs[i]); 
				add(value, label);
			}
			return this;
		}
		public ListOption add(int[]values, String[]labels) {
			for ( int i=0; i<values.length; i++ ) {
				String value = String.valueOf(values[i]); 
				String label = labels[i]; 
				add(value, label);
			}
			return this;
		}
		public ListOption addPercents(int[]values) {
			for ( int item : values ) {
				String s = String.valueOf(item); 
				add(s, s + ""%"");
			}
			return this;
		}
		public String findValueLabel( String value ) {
			for ( Pair pair : list ) {
				if ( value!=null && pair.value.equals(value) )
					return pair.label;
			}
			return null;
		}
		public int findValue( String value ) {
			if ( value==null )
				return -1;
			for ( int i=0; i<list.size(); i++ ) {
				if ( value.equals(list.get(i).value) )
					return i;
			}
			return -1;
		}
		
		public int getSelectedItemIndex() {
			return findValue(mProperties.getProperty(property));
		}

		protected void closed() {
			
		}
		
		protected int getItemLayoutId() {
			return R.layout.option_value; 
		}
		
		protected void updateItemContents( final View layout, final Pair item, final ListView listView, final int position ) {
			TextView view;
			RadioButton cb;
			view = (TextView)layout.findViewById(R.id.option_value_text);
			cb = (RadioButton)layout.findViewById(R.id.option_value_check);
			view.setText(item.label);
			String currValue = mProperties.getProperty(property);
			boolean isSelected = item.value!=null && currValue!=null && item.value.equals(currValue) ;//getSelectedItemIndex()==position;
			cb.setChecked(isSelected);
			cb.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					listView.getOnItemClickListener().onItemClick(listView, listView, position, 0);
//					mProperties.setProperty(property, item.value);
//					dismiss();
//					optionsListView.refresh();
				}
			});
		}
		
		public String getValueLabel() { return findValueLabel(mProperties.getProperty(property)); }
		
		public void onSelect() {
			final BaseDialog dlg = new BaseDialog(mActivity, 0, 0, false);
			//AlertDialog.Builder dlg = new AlertDialog.Builder(getContext());
			dlg.setTitle(label);

			final ListView listView = new ListView(getContext());
			
			
			ListAdapter listAdapter = new ListAdapter() {

				public boolean areAllItemsEnabled() {
					return true;
				}

				public boolean isEnabled(int position) {
					return true;
				}

				public int getCount() {
					return list.size();
				}

				public Object getItem(int position) {
					return list.get(position);
				}

				public long getItemId(int position) {
					return position;
				}

				public int getItemViewType(int position) {
					return 0;
				}

				public View getView(final int position, View convertView,
						ViewGroup parent) {
					ViewGroup layout;
					if ( convertView==null ) {
						layout = (ViewGroup)mInflater.inflate(getItemLayoutId(), null);
						//view = new TextView(getContext());
					} else {
						layout = (ViewGroup)convertView;
					}
					final Pair item = list.get(position);
					updateItemContents( layout, item, listView, position );
					//cb.setClickable(false);
//					cb.setOnClickListener(new View.OnClickListener() {
//						@Override
//						public void onClick(View v) {
//							
//						}
//					});
					return layout;
				}

				public int getViewTypeCount() {
					return 1;
				}

				public boolean hasStableIds() {
					return true;
				}

				public boolean isEmpty() {
					return list.size()==0;
				}

				private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
				
				public void registerDataSetObserver(DataSetObserver observer) {
					observers.add(observer);
				}

				public void unregisterDataSetObserver(DataSetObserver observer) {
					observers.remove(observer);
				}
				
			};
			int selItem = getSelectedItemIndex();
			if ( selItem<0 )
				selItem = 0;
			listView.setAdapter(listAdapter);
			listView.setSelection(selItem);
			dlg.setView(listView);
			//final AlertDialog d = dlg.create();
			listView.setOnItemClickListener(new OnItemClickListener() {

				public void onItemClick(AdapterView<?> adapter, View listview,
						int position, long id) {
					Pair item = list.get(position);
					onClick(item);
					dlg.dismiss();
					closed();
				}
			});
			dlg.show();
		}
		
		public void onClick( Pair item ) {
			mProperties.setProperty(property, item.value);
			refreshList();
			if ( onChangeHandler!=null )
				onChangeHandler.run();
			if ( optionsListView!=null )
				optionsListView.refresh();
		}
	}
	
	class HyphenationOptions extends ListOption
	{
		public HyphenationOptions( String label )
		{
			super( label, ReaderView.PROP_HYPHENATION_DICT );
			setDefaultValue(""RUSSIAN"");
			Engine.HyphDict[] dicts = Engine.HyphDict.values();
			for ( Engine.HyphDict dict : dicts )
				add( dict.toString(), dict.name );
		}
	}
	
	class ThumbnailCache {
		final int maxcount;
		final int dx;
		final int dy;
		class Item {
			Drawable drawable;
			Bitmap bmp;
			String path;
			int id;
			public void clear() {
				if ( bmp!=null ) {
					bmp.recycle();
					bmp = null;
				}
				if ( drawable!=null )
					drawable = null;
			}
		}
		ArrayList<Item> list = new ArrayList<Item>(); 
		public ThumbnailCache( int dx, int dy, int maxcount ) {
			this.dx = dx;
			this.dy = dy;
			this.maxcount = maxcount;
		}
		private void remove( int maxsize ) {
			while ( list.size()>maxsize ) {
				Item item = list.remove(0);
				item.clear();
			}
		}
		private Drawable createDrawable( String path ) {
			File f = new File(path);
			if ( !f.isFile() || !f.exists() )
				return null;
			try { 
				BitmapDrawable drawable = (BitmapDrawable)BitmapDrawable.createFromPath(path);
				if ( drawable==null )
					return null;
				Bitmap src = drawable.getBitmap();
				Bitmap bmp = Bitmap.createScaledBitmap(src, dx, dy, true);
				//Canvas canvas = new Canvas(bmp);
				BitmapDrawable res = new BitmapDrawable(bmp);
				//src.recycle();
				Item item = new Item();
				item.path = path;
				item.drawable = res; //drawable;
				item.bmp = bmp;
				list.add(item);
				remove(maxcount);
				return drawable;
			} catch ( Exception e ) {
				return null;
			}
		}
		private Drawable createDrawable( int resourceId ) {
			try { 
				//Drawable drawable = mReaderView.getActivity().getResources().getDrawable(resourceId);
				InputStream is = getContext().getResources().openRawResource(resourceId);
				if ( is==null )
					return null;
				BitmapDrawable src = new BitmapDrawable(is);
				if ( src==null )
					return null;
				Item item = new Item();
				item.id = resourceId;
				Bitmap bmp = Bitmap.createScaledBitmap(src.getBitmap(), dx, dy, true);
				BitmapDrawable res = new BitmapDrawable(bmp);
				item.drawable = res;
				item.bmp = bmp;
				list.add(item);
				remove(maxcount);
				return res;
			} catch ( Exception e ) {
				return null;
			}
		}
		public Drawable getImage( String path ) {
			if ( path==null || !path.startsWith(""/""))
				return null;
			// find existing
			for ( int i=0; i<list.size(); i++ ) {
				if ( list.get(i).path!=null && path.equals(list.get(i).path) ) {
					Item item = list.remove(i);
					list.add(item);
					return item.drawable;
				}
			}
			return createDrawable( path ); 
		}
		public Drawable getImage( int resourceId ) {
			if ( resourceId==0 )
				return null;
			// find existing
			for ( int i=0; i<list.size(); i++ ) {
				if ( list.get(i).id == resourceId ) {
					Item item = list.remove(i);
					list.add(item);
					return item.drawable;
				}
			}
			return createDrawable( resourceId ); 
		}
		public void clear() {
			remove(0);
		}
	}
	
	ThumbnailCache textureSampleCache = new ThumbnailCache(64, 64, 100);
	
	class TextureOptions extends ListOption
	{
		public TextureOptions( String label )
		{
			super( label, ReaderView.PROP_PAGE_BACKGROUND_IMAGE );
			setDefaultValue(""(NONE)"");
			BackgroundTextureInfo[] textures = mReaderView.getEngine().getAvailableTextures();
			for ( BackgroundTextureInfo item : textures )
				add( item.id, item.name );
		}

		protected void closed() {
			textureSampleCache.clear();
		}

		protected int getItemLayoutId() {
			return R.layout.option_value_image; 
		}
		
		protected void updateItemContents( final View layout, final Pair item, final ListView listView, final int position ) {
			super.updateItemContents(layout, item, listView, position);
			ImageView img = (ImageView)layout.findViewById(R.id.option_value_image);
			int cl = mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR, Color.WHITE);
			BackgroundTextureInfo texture = mReaderView.getEngine().getTextureInfoById(item.value);
			img.setBackgroundColor(cl);
			if ( texture.resourceId!=0 ) {
//				img.setImageDrawable(null);
//				img.setImageResource(texture.resourceId);
//				img.setBackgroundColor(Color.TRANSPARENT);
				Drawable drawable = textureSampleCache.getImage(texture.resourceId);
				if ( drawable!=null ) {
					img.setImageResource(0);
					img.setImageDrawable(drawable);
					img.setBackgroundColor(Color.TRANSPARENT);
				} else {
					img.setBackgroundColor(cl);
					img.setImageResource(0);
					img.setImageDrawable(null);
				}
			} else {
				// load image from file
				Drawable drawable = textureSampleCache.getImage(texture.id);
				if ( drawable!=null ) {
					img.setImageResource(0);
					img.setImageDrawable(drawable);
					img.setBackgroundColor(Color.TRANSPARENT);
				} else {
					img.setBackgroundColor(cl);
					img.setImageResource(0);
					img.setImageDrawable(null);
				}
			}
		}
	}
	
	//byte[] fakeLongArrayForDebug;
	
	public OptionsDialog( CoolReader activity, ReaderView readerView, String[] fontFaces )
	{
		super(activity, R.string.dlg_button_ok, R.string.dlg_button_cancel, false);
		
		mActivity = activity;
		mReaderView = readerView;
		mFontFaces = fontFaces;
		mProperties = readerView.getSettings();

		//fakeLongArrayForDebug = new byte[2000000]; // 2M
		//CoolReader.dumpHeapAllocation();
	}
	
	class OptionsListView extends ListView {
		private ArrayList<OptionBase> mOptions = new ArrayList<OptionBase>();
		private ListAdapter mAdapter;
		public void refresh()
		{
			//setAdapter(mAdapter);
			for ( OptionBase item : mOptions ) {
				item.refreshItem();
			}
			invalidate();
		}
		public OptionsListView add( OptionBase option ) {
			mOptions.add(option);
			option.optionsListView = this;
			return this;
		}
		public OptionsListView( Context context )
		{
			super(context);
			setFocusable(true);
			setFocusableInTouchMode(true);
			mAdapter = new ListAdapter() {
				public boolean areAllItemsEnabled() {
					return false;
				}

				public boolean isEnabled(int position) {
					boolean isPageMode = mProperties.getBool(ReaderView.PROP_PAGE_VIEW_MODE, true);
					OptionBase option = mOptions.get(position);
					String prop = option.property;
					if ( prop.equals(ReaderView.PROP_STATUS_LINE) || prop.equals(ReaderView.PROP_FOOTNOTES) )
						return isPageMode;
					return true;
				}

				public int getCount() {
					return mOptions.size();
				}

				public Object getItem(int position) {
					return mOptions.get(position);
				}

				public long getItemId(int position) {
					return position;
				}

				public int getItemViewType(int position) {
//					OptionBase item = mOptions.get(position);
//					return item.getItemViewType();
					return position;
				}

				
				public View getView(int position, View convertView, ViewGroup parent) {
					OptionBase item = mOptions.get(position);
					return item.getView(convertView, parent);
				}

				public int getViewTypeCount() {
					//return OPTION_VIEW_TYPE_COUNT;
					return mOptions.size() > 0 ? mOptions.size() : 1;
				}

				public boolean hasStableIds() {
					return true;
				}

				public boolean isEmpty() {
					return mOptions.size()==0;
				}

				private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
				
				public void registerDataSetObserver(DataSetObserver observer) {
					observers.add(observer);
				}

				public void unregisterDataSetObserver(DataSetObserver observer) {
					observers.remove(observer);
				}
			};
			setAdapter(mAdapter);
		}
		@Override
		public boolean performItemClick(View view, int position, long id) {
			mOptions.get(position).onSelect();
			return true;
		}
		
	}
	
	public View createTabContent(String tag) {
		if ( ""App"".equals(tag) )
			return mOptionsApplication;
		else if ( ""Styles"".equals(tag) )
			return mOptionsStyles;
		else if ( ""Controls"".equals(tag) )
			return mOptionsControls;
		else if ( ""Page"".equals(tag))
			return mOptionsPage;
		return null;
	}

	private String getString( int resourceId )
	{
		return getContext().getResources().getString(resourceId); 
	}
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		Log.v(""cr3"", ""creating OptionsDialog"");
		CoolReader.dumpHeapAllocation();
		Log.v(""cr3"", ""calling gc"");
		System.gc();
		CoolReader.dumpHeapAllocation();
		Log.v(""cr3"", ""creating options dialog"");
		setTitle(null);
        setCancelable(true);
        setCanceledOnTouchOutside(true);
        mInflater = LayoutInflater.from(getContext());
        mTabs = (TabHost)mInflater.inflate(R.layout.options, null);
		// setup tabs
		//setView(R.layout.options);
		//setContentView(R.layout.options);
		//mTabs = (TabHost)findViewById(android.R.id.tabhost); 
		mTabs.setup();
		//new TabHost(getContext());
		mOptionsStyles = new OptionsListView(getContext());
		mOptionsStyles.add(new ListOption(getString(R.string.options_font_face), ReaderView.PROP_FONT_FACE).add(mFontFaces).setDefaultValue(mFontFaces[0]).setIconId(R.drawable.cr3_option_font_face));
		mOptionsStyles.add(new ListOption(getString(R.string.options_font_size), ReaderView.PROP_FONT_SIZE).add(mFontSizes).setDefaultValue(""24"").setIconId(R.drawable.cr3_option_font_size));
		mOptionsStyles.add(new BoolOption(getString(R.string.options_font_embolden), ReaderView.PROP_FONT_WEIGHT_EMBOLDEN).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_text_bold));
		//mOptionsStyles.add(new BoolOption(getString(R.string.options_font_antialias), ReaderView.PROP_FONT_ANTIALIASING).setInverse().setDefaultValue(""0""));
		mOptionsStyles.add(new ListOption(getString(R.string.options_font_antialias), ReaderView.PROP_FONT_ANTIALIASING).add(mAntialias, mAntialiasTitles).setDefaultValue(""2""));
		mOptionsStyles.add(new ListOption(getString(R.string.options_interline_space), ReaderView.PROP_INTERLINE_SPACE).addPercents(mInterlineSpaces).setDefaultValue(""100""));
		mOptionsStyles.add(new NightModeOption(getString(R.string.options_inverse_view), ReaderView.PROP_NIGHT_MODE));
		mOptionsStyles.add(new ColorOption(getString(R.string.options_color_text), ReaderView.PROP_FONT_COLOR, 0x000000));
		mOptionsStyles.add(new ColorOption(getString(R.string.options_color_background), ReaderView.PROP_BACKGROUND_COLOR, 0xFFFFFF));
		mOptionsStyles.add(new TextureOptions(getString(R.string.options_background_texture)));

		mBacklightLevelsTitles[0] = getString(R.string.options_app_backlight_screen_default);
		mOptionsStyles.add(new ListOption(getString(R.string.options_app_backlight_screen), ReaderView.PROP_APP_SCREEN_BACKLIGHT).add(mBacklightLevels, mBacklightLevelsTitles).setDefaultValue(""-1""));
		//
		mOptionsStyles.add(new HyphenationOptions(getString(R.string.options_hyphenation_dictionary)));
		//
		mOptionsPage = new OptionsListView(getContext());
		mOptionsPage.add(new ListOption(getString(R.string.options_view_mode), ReaderView.PROP_PAGE_VIEW_MODE).add(mViewModes, mViewModeTitles).setDefaultValue(""1""));
		mOptionsPage.add( new StatusBarOption(getString(R.string.options_page_titlebar)));
		mOptionsPage.add(new BoolOption(getString(R.string.options_page_footnotes), ReaderView.PROP_FOOTNOTES).setDefaultValue(""1""));
		//mOptionsPage.add(new ListOption(getString(R.string.options_page_orientation), ReaderView.PROP_ROTATE_ANGLE).add(mOrientations, mOrientationsTitles).setDefaultValue(""0""));
		mOptionsPage.add(new ListOption(getString(R.string.options_page_orientation), ReaderView.PROP_APP_SCREEN_ORIENTATION).add(mOrientations, mOrientationsTitles).setDefaultValue(""0""));
		mOptionsPage.add(new ListOption(getString(R.string.options_page_landscape_pages), ReaderView.PROP_LANDSCAPE_PAGES).add(mLandscapePages, mLandscapePagesTitles).setDefaultValue(""1""));
		mOptionsPage.add(new ListOption(getString(R.string.options_page_animation), ReaderView.PROP_PAGE_ANIMATION).add(mAnimation, mAnimationTitles).setDefaultValue(""1""));
		
		mOptionsPage.add(new ListOption(getString(R.string.options_page_margin_left), ReaderView.PROP_PAGE_MARGIN_LEFT).add(mMargins).setDefaultValue(""5""));
		mOptionsPage.add(new ListOption(getString(R.string.options_page_margin_right), ReaderView.PROP_PAGE_MARGIN_RIGHT).add(mMargins).setDefaultValue(""5""));
		mOptionsPage.add(new ListOption(getString(R.string.options_page_margin_top), ReaderView.PROP_PAGE_MARGIN_TOP).add(mMargins).setDefaultValue(""5""));
		mOptionsPage.add(new ListOption(getString(R.string.options_page_margin_bottom), ReaderView.PROP_PAGE_MARGIN_BOTTOM).add(mMargins).setDefaultValue(""5""));
		mOptionsApplication = new OptionsListView(getContext());
		mOptionsApplication.add(new BoolOption(getString(R.string.options_app_fullscreen), ReaderView.PROP_APP_FULLSCREEN));
		mOptionsApplication.add(new BoolOption(getString(R.string.options_app_show_cover_pages), ReaderView.PROP_APP_SHOW_COVERPAGES));
		mOptionsApplication.add(new BoolOption(getString(R.string.options_controls_enable_volume_keys), ReaderView.PROP_CONTROLS_ENABLE_VOLUME_KEYS).setDefaultValue(""1""));
		mOptionsApplication.add(new TapZoneOption(getString(R.string.options_app_tapzones_normal), ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP));
		mOptionsApplication.add(new KeyMapOption(getString(R.string.options_app_key_actions)));
		mOptionsApplication.add(new BoolOption(getString(R.string.options_app_tapzone_hilite), ReaderView.PROP_APP_TAP_ZONE_HILIGHT).setDefaultValue(""0""));
		mOptionsApplication.add(new BoolOption(getString(R.string.options_app_trackball_disable), ReaderView.PROP_APP_TRACKBALL_DISABLED).setDefaultValue(""0""));
		mOptionsApplication.add(new BoolOption(getString(R.string.options_app_scan_book_props), ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED).setDefaultValue(""1""));
		mOptionsApplication.add(new BoolOption(getString(R.string.options_app_backlight_lock_enabled), ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK).setDefaultValue(""1""));
		
		
		mOptionsStyles.refresh();
		mOptionsPage.refresh();
		mOptionsApplication.refresh();
		
		mOptionsControls = new OptionsListView(getContext());
		mOptionsControls.add(new BoolOption(""Sample option"", ""controls.sample""));
		TabHost.TabSpec tsStyles = mTabs.newTabSpec(""Styles"");
		tsStyles.setIndicator("""", //getContext().getResources().getString(R.string.tab_options_styles) 
				getContext().getResources().getDrawable(android.R.drawable.ic_menu_view)); //R.drawable.cr3_option_style
		tsStyles.setContent(this);
		mTabs.addTab(tsStyles);
		TabHost.TabSpec tsPage = mTabs.newTabSpec(""Page"");
		//getContext().getResources().getString(R.string.tab_options_page)
		tsPage.setIndicator("""", getContext().getResources().getDrawable(android.R.drawable.ic_menu_crop)); //R.drawable.cr3_option_page
		tsPage.setContent(this);
		mTabs.addTab(tsPage);
		TabHost.TabSpec tsApp = mTabs.newTabSpec(""App"");
		//tsApp.setIndicator(null, getContext().getResources().getDrawable(R.drawable.cr3_option_));
		tsApp.setIndicator("""", //getContext().getResources().getString(R.string.tab_options_app), 
				getContext().getResources().getDrawable(android.R.drawable.ic_menu_manage));
		tsApp.setContent(this);
		mTabs.addTab(tsApp);
		
		TabHost.TabSpec tsControls = mTabs.newTabSpec(""Controls"");
		tsControls.setIndicator(getContext().getResources().getString(R.string.tab_options_controls), getContext().getResources().getDrawable(android.R.drawable.ic_menu_manage));
		tsControls.setContent(this);
		//mTabs.addTab(tsControls);

		setView(mTabs);
		
		mOldProperties = new Properties(mProperties);
		
		setOnCancelListener(new OnCancelListener() {

			public void onCancel(DialogInterface dialog) {
				askApply();
			}
		});
		
		super.onCreate(savedInstanceState);
		Log.v(""cr3"", ""OptionsDialog is created"");
	}

	private void askApply()
	{
		Properties diff = mProperties.diff(mOldProperties);
		if ( diff.size()>0 ) {
			Log.d(""cr3"", ""Some properties were changed, ask user whether to apply"");
			AlertDialog.Builder dlg = new AlertDialog.Builder(getContext());
			dlg.setTitle(R.string.win_title_options_apply);
			dlg.setPositiveButton(R.string.dlg_button_ok, new OnClickListener() {
				public void onClick(DialogInterface arg0, int arg1) {
					onPositiveButtonClick();
				}
			});
			dlg.setNegativeButton(R.string.dlg_button_cancel, new OnClickListener() {
				public void onClick(DialogInterface arg0, int arg1) {
					onNegativeButtonClick();
				}
			});
			dlg.show();
		}
	}
	
	@Override
	protected void onPositiveButtonClick() {
        mReaderView.setSettings(mProperties, mOldProperties);
        dismiss();
        //super.onPositiveButtonClick();
	}
	@Override
	protected void onStop() {
		Log.d(""cr3"", ""OptionsDialog.onStop() : calling gc()"");
		System.gc();
		super.onStop();
	}

	
}
",True,21,27,0,0,2,18,2,8,L1
6,org.coolreader.crengine.TOCDlg.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.database.DataSetObserver;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

public class TOCDlg extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	TOCItem mTOC;
	ListView mListView;
	int mCurrentPage;
	TOCItem mCurrentPageItem;
	ArrayList<TOCItem> mItems = new ArrayList<TOCItem>(); 
	private LayoutInflater mInflater;
	
	private void initItems( TOCItem toc, boolean expanded )
	{
		for ( int i=0; i<toc.getChildCount(); i++ ) {
			TOCItem child = toc.getChild(i);
			if ( child.getPage()<=mCurrentPage )
				mCurrentPageItem = child;
			if ( expanded ) {
				child.setGlobalIndex(mItems.size());
				mItems.add(child);
			} else {
				child.setGlobalIndex(-1); // invisible
			}
			initItems(child, expanded && child.getExpanded());
		}
	}
	private void initItems()
	{
		mCurrentPageItem = null;
		mItems.clear();
		initItems(mTOC, true);
	}
	
	private void expand( TOCItem item )
	{
		if ( item==null )
			return;
		item.setExpanded(true);
		// expand all parents
		for ( TOCItem p = item.getParent(); p!=null; p = p.getParent() )
			p.setExpanded(true);
		initItems();
		refreshList();
		if ( mItems.size()>0 ) {
			if ( item.getGlobalIndex()>=0 ) {
				mListView.setSelection(item.getGlobalIndex());
				mListView.setSelectionFromTop(item.getGlobalIndex(), mListView.getHeight()/2);
			} else
				mListView.setSelection(0);
		}
	}
	
	private void collapse( TOCItem item )
	{
		item.setExpanded(false);
		initItems();
		refreshList();
	}
	
	private void refreshList()
	{
		mListView.setAdapter(new ListAdapter() {
			public boolean areAllItemsEnabled() {
				return true;
			}

			public boolean isEnabled(int arg0) {
				return true;
			}

			public int getCount() {
				return mItems.size();
			}

			public Object getItem(int position) {
				return mItems.get(position);
			}

			public long getItemId(int position) {
				return position;
			}

			public int getItemViewType(int position) {
				return 0;
			}

			
			public View getView(int position, View convertView, ViewGroup parent) {
				View view;
				if ( convertView==null ) {
					//view = new TextView(getContext());
					view = mInflater.inflate(R.layout.toc_item, null);
				} else {
					view = (View)convertView;
				}
				TextView pageTextView = (TextView)view.findViewById(R.id.toc_page);
				TextView titleTextView = (TextView)view.findViewById(R.id.toc_title);
				TextView marginTextView = (TextView)view.findViewById(R.id.toc_level_margin);
				ImageView expandImageView = (ImageView)view.findViewById(R.id.toc_expand_icon);
				TOCItem item = mItems.get(position);
				StringBuilder buf = new StringBuilder(item.getLevel()*2);
				for ( int i=1; i<item.getLevel(); i++ )
					buf.append(""  "");
				if ( item.getChildCount()>0 ) {
					if ( item.getExpanded() ) {
						expandImageView.setImageResource(R.drawable.cr3_toc_item_expanded);
					} else {
						expandImageView.setImageResource(R.drawable.cr3_toc_item_collapsed);
					}
				} else {
					expandImageView.setImageResource(R.drawable.cr3_toc_item_normal);
				}
				marginTextView.setText(buf.toString());
				titleTextView.setText(item.getName());
				pageTextView.setText(String.valueOf(item.getPage()+1));
				return view;
			}

			public int getViewTypeCount() {
				return 1;
			}

			public boolean hasStableIds() {
				return true;
			}

			public boolean isEmpty() {
				return false;
			}

			private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
			
			public void registerDataSetObserver(DataSetObserver observer) {
				observers.add(observer);
			}

			public void unregisterDataSetObserver(DataSetObserver observer) {
				observers.remove(observer);
			}
		});
	}

	public TOCDlg( CoolReader coolReader, ReaderView readerView, TOCItem toc, int currentPage )
	{
		super(coolReader, 0, 0, false);
        setCancelable(true);
		this.mCoolReader = coolReader;
		this.mReaderView = readerView;
		this.mTOC = toc;
		this.mCurrentPage = currentPage;
		this.mListView = new ListView(getContext());
		mListView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> listview, View view,
					int position, long id) {
				TOCItem item = mItems.get(position);
				if ( item.getChildCount()==0 || item.getExpanded() ) {
					mReaderView.goToPage(item.getPage()+1);
					dismiss();
				} else {
					expand(item);
				}
			}
		});
		mListView.setOnItemLongClickListener(new OnItemLongClickListener() {

			@Override
			public boolean onItemLongClick(AdapterView<?> listview, View view,
					int position, long id) {
				TOCItem item = mItems.get(position);
				if ( item.getChildCount()==0 ) {
					mReaderView.goToPage(item.getPage()+1);
					dismiss();
				} else {
					if ( item.getExpanded() )
						collapse(item);
					else
						expand(item);
				}
				return true;
			}
		});
		mListView.setLongClickable(true);
		mListView.setClickable(true);
		mListView.setFocusable(true);
		mListView.setFocusableInTouchMode(true);
		mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		setTitle(mCoolReader.getResources().getString(R.string.win_title_toc));
		setView(mListView);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
        mInflater = LayoutInflater.from(getContext());
		super.onCreate(savedInstanceState);
		expand( mTOC );
		expand( mCurrentPageItem );
	}
	
	

}
",False,1,27,0,0,3,20,1,4,L2
7,org.coolreader.crengine.BookmarksDlg.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.Context;
import android.database.DataSetObserver;
import android.os.Bundle;
import android.util.Log;
import android.view.ContextMenu;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.MenuItem.OnMenuItemClickListener;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.AdapterView.AdapterContextMenuInfo;

public class BookmarksDlg  extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	private LayoutInflater mInflater;
	BookInfo mBookInfo;
	BookmarkList mList;
	BookmarksDlg mThis;
	
	final int SHORTCUT_COUNT = 10;
	class BookmarkList extends ListView {
		private ListAdapter mAdapter;
		public BookmarkList( Context context ) {
			super(context);
			//final BookmarkList mThisList = this;
			mAdapter = new ListAdapter() {
				public boolean areAllItemsEnabled() {
					return true;
				}

				public boolean isEnabled(int arg0) {
					return true;
				}

				public int getCount() {
					return SHORTCUT_COUNT;
				}

				public Object getItem(int position) {
					return mBookInfo.findShortcutBookmark(position+1);
				}

				public long getItemId(int position) {
					return position;
				}

				public int getItemViewType(int position) {
					return 0;
				}

				
				public View getView(int position, View convertView, ViewGroup parent) {
					View view;
					if ( convertView==null ) {
						//view = new TextView(getContext());
						view = mInflater.inflate(R.layout.bookmark_shortcut_item, null);
					} else {
						view = (View)convertView;
					}
					TextView labelView = (TextView)view.findViewById(R.id.shortcut_bookmark_item_shortcut);
					//TextView percentView = (TextView)view.findViewById(R.id.shortcut_bookmark_item_percent);
					TextView posTextView = (TextView)view.findViewById(R.id.shortcut_bookmark_item_pos_text);
					TextView titleTextView = (TextView)view.findViewById(R.id.shortcut_bookmark_item_title);
					Bookmark b = mBookInfo!=null ? mBookInfo.findShortcutBookmark(position+1) : null;
					labelView.setText(String.valueOf(position+1));
					if ( b!=null ) {
						String percentString = FileBrowser.formatPercent(b.getPercent());
						String s1 = b.getTitleText();
						String s2 = b.getPosText();
						if ( s1!=null && s2!=null ) {
							s1 = percentString + ""   "" + s1;
						} else if ( s1!=null ) {
							s2 = s1;
							s1 = percentString;  
						} else if ( s2!=null ) {
							s1 = percentString;
						} else {
							s1 = s2 = """";
						}
						//percentView.setText(FileBrowser.formatPercent(b.getPercent()));
						titleTextView.setText(s1);
						posTextView.setText(s2);
					} else {
						//percentView.setText("""");
						titleTextView.setText("""");
						posTextView.setText("""");
					}
					return view;
				}

				public int getViewTypeCount() {
					return 1;
				}

				public boolean hasStableIds() {
					return true;
				}

				public boolean isEmpty() {
					return false;
				}

				private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
				
				public void registerDataSetObserver(DataSetObserver observer) {
					observers.add(observer);
				}

				public void unregisterDataSetObserver(DataSetObserver observer) {
					observers.remove(observer);
				}
			};
			setChoiceMode(ListView.CHOICE_MODE_SINGLE);
			setAdapter(mAdapter);
		}
		@Override
		public boolean performItemClick(View view, int position, long id) {
			Bookmark b = mBookInfo.findShortcutBookmark(position+1);
			if ( b==null ) {
				mReaderView.addBookmark(position+1);
				mThis.dismiss();
				return true;
			}
			selectedItem = position;
			openContextMenu(this);
//			showContextMenu();
			return true;
		}
		
	}
	
	public BookmarksDlg( CoolReader activity, ReaderView readerView )
	{
		super(activity, 0, 0, false);
		mThis = this; // for inner classes
		mCoolReader = activity;
		mReaderView = readerView;
		mBookInfo = mReaderView.getBookInfo();
		mList = new BookmarkList(activity);
		setView(mList);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		Log.v(""cr3"", ""creating BookmarksDlg"");
		setTitle(mCoolReader.getResources().getString(R.string.win_title_bookmarks));
        setCancelable(true);
        mInflater = LayoutInflater.from(getContext());
		super.onCreate(savedInstanceState);
		registerForContextMenu(mList);
		//mList.
	}
	@Override
	public boolean onContextItemSelected(MenuItem item) {
		
		int shortcut = selectedItem; //mList.getSelectedItemPosition();
		if ( shortcut>=0 && shortcut<SHORTCUT_COUNT )
		switch (item.getItemId()) {
		case R.id.bookmark_shortcut_add:
			mReaderView.addBookmark(shortcut+1);
			dismiss();
			return true;
		case R.id.bookmark_shortcut_goto:
			mReaderView.goToBookmark(shortcut+1);
			dismiss();
			return true;
		}
		return super.onContextItemSelected(item);
	}
	
	private int selectedItem;
	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
	    MenuInflater inflater = mCoolReader.getMenuInflater();
	    inflater.inflate(R.menu.cr3_bookmark_shortcut_context_menu, menu);
	    AdapterContextMenuInfo mi = (AdapterContextMenuInfo)menuInfo;
	    if ( mi!=null )
	    	selectedItem = mi.position;
	    menu.setHeaderTitle(getContext().getString(R.string.context_menu_title_bookmark));
	    for ( int i=0; i<menu.size(); i++ ) {
	    	menu.getItem(i).setOnMenuItemClickListener(new OnMenuItemClickListener() {
				public boolean onMenuItemClick(MenuItem item) {
					onContextItemSelected(item);
					return true;
				}
			});
	    }
	}
	

}
",False,11,27,0,0,3,18,1,6,L1
8,org.coolreader.crengine.BaseDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.app.Dialog;
import android.graphics.PixelFormat;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;

public class BaseDialog extends Dialog {

	View layoutView;
	ViewGroup buttonsLayout;
	ViewGroup contentsLayout;
	public static final boolean DARK_THEME = true;
	public BaseDialog( CoolReader activity, int positiveButtonText, int negativeButtonText, boolean windowed )
	{
		this( activity, positiveButtonText, negativeButtonText, activity.isFullscreen(), activity.isNightMode(), windowed );
	}
	public BaseDialog( CoolReader activity, int positiveButtonText, int negativeButtonText, boolean fullscreen, boolean dark, boolean windowed )
	{
		//super(activity, fullscreen ? R.style.Dialog_Fullscreen : R.style.Dialog_Normal);
		//super(activity, fullscreen ? R.style.Dialog_Fullscreen : android.R.style.Theme_Dialog); //android.R.style.Theme_Light_NoTitleBar_Fullscreen : android.R.style.Theme_Light
		super(activity,
				windowed ? (dark||DARK_THEME ? android.R.style.Theme_Dialog : android.R.style.Theme_Dialog) :
				(fullscreen
				? (	dark||DARK_THEME ? R.style.Dialog_Fullscreen_Night : R.style.Dialog_Fullscreen_Day )
				: (	dark||DARK_THEME ? R.style.Dialog_Normal_Night : R.style.Dialog_Normal_Day )
				));
		setOwnerActivity(activity);
		this.mPositiveButtonText = positiveButtonText;
		this.mNegativeButtonText = negativeButtonText;
//		requestWindowFeature(Window.FEATURE_OPTIONS_PANEL);
		WindowManager.LayoutParams lp = new WindowManager.LayoutParams();
		lp.alpha = 1.0f;
		lp.dimAmount = 0.0f;
		lp.format = PixelFormat.RGB_565;
		lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL;
		lp.horizontalMargin = 0;
		lp.verticalMargin = 0;
		lp.windowAnimations = 0;
		lp.layoutAnimationParameters = null;
		//lp.memoryType = WindowManager.LayoutParams.MEMORY_TYPE_PUSH_BUFFERS;
		getWindow().setAttributes(lp);
		Log.i(""cr3"", ""BaseDialog.window="" + getWindow());
        setCancelable(true);
	}

	public void setView( View view )
	{
		this.view = view;
		if ( layoutView==null ) {
			layoutView = createLayout(view);
			setContentView(layoutView);
		}
		contentsLayout.removeAllViews();
		contentsLayout.addView(view);
	}
	
	protected void onPositiveButtonClick()
	{
		// override it
		dismiss();
	}
	
	protected void onNegativeButtonClick()
	{
		// override it
		dismiss();
	}

	protected void createButtonsPane( ViewGroup layout )
	{
		if ( mNegativeButtonText==0 && mPositiveButtonText==0 ) {
			layout.setVisibility(View.INVISIBLE);
			return;
		}
		//getWindow().getDecorView().getWidth()
		if ( mPositiveButtonText!=0 ) {
			Button positiveButton = (Button)layout.findViewById(R.id.base_dlg_btn_positive);
			if ( positiveButton==null ) {
				positiveButton = new Button(getContext());
				layout.addView(positiveButton);
			}
			positiveButton.setText(mPositiveButtonText);
			positiveButton.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					onPositiveButtonClick();
				}
			});
		}
		Button negativeButton = (Button)layout.findViewById(R.id.base_dlg_btn_negative);
		if ( negativeButton==null && mNegativeButtonText!=0 ) {
			negativeButton = new Button(getContext());
			layout.addView(negativeButton);
		}
		if ( negativeButton!=null ) {
			if ( mNegativeButtonText!=0 ) {
				negativeButton.setText(mNegativeButtonText);
				negativeButton.setOnClickListener(new View.OnClickListener() {
					public void onClick(View v) {
						onNegativeButtonClick();
					}
				});
			} else {
				negativeButton.setVisibility(View.INVISIBLE);
			}
		}
	}

	@Override
	public void setTitle(CharSequence title) {
		if ( title!=null )
			super.setTitle(title);
		else {
			getWindow().requestFeature(Window.FEATURE_NO_TITLE);
			//((CoolReader)getOwnerActivity()).applyFullscreen( getWindow() );
		}
	}

	protected View createLayout( View view )
	{
        LayoutInflater mInflater = LayoutInflater.from(getContext());
        ViewGroup layout = (ViewGroup)mInflater.inflate(R.layout.base_dialog, null);
        buttonsLayout = (ViewGroup)layout.findViewById(R.id.base_dialog_buttons_view);
        if ( buttonsLayout!=null ) {
            if ( mPositiveButtonText!=0 || mNegativeButtonText!=0 ) {
            	createButtonsPane(buttonsLayout);
            } else {
            	layout.removeView(buttonsLayout);
            }
        }
        contentsLayout =  (ViewGroup)layout.findViewById(R.id.base_dialog_content_view);
        contentsLayout.addView(view);
		return layout;
	}

	protected int mPositiveButtonText = 0;
	protected int mNegativeButtonText = 0;
	protected View view;
}
",False,10,27,0,0,3,13,6,1,L1
9,org.coolreader.crengine.Bookmark.java,"package org.coolreader.crengine;


public class Bookmark {

	public Bookmark()
	{
	}
	
	public int getType() {
		return type;
	}
	public void setType(int type) {
		this.type = type;
		modified = true;
	}
	public int getPercent() {
		return percent;
	}
	public void setPercent(int percent) {
		this.percent = percent;
		modified = true;
	}
	public String getStartPos() {
		return startPos;
	}
	public void setStartPos(String startPos) {
		this.startPos = startPos;
		modified = true;
	}
	public String getEndPos() {
		return endPos;
	}
	public void setEndPos(String endPos) {
		this.endPos = endPos;
		modified = true;
	}
	public String getCommentText() {
		return commentText;
	}
	public void setCommentText(String commentText) {
		this.commentText = commentText;
		modified = true;
	}
	public String getTitleText() {
		return titleText;
	}
	public String getPosText() {
		return posText;
	}
	
	public void setTitleText(String titleText) {
		this.titleText = titleText;
		modified = true;
	}
	public void setPosText(String posText) {
		this.posText = posText;
		modified = true;
	}
	public int getShortcut() {
		return shortcut;
	}
	public void setShortcut(int shortcut) {
		modified = true;
		this.shortcut = shortcut;
	}
	public long getTimeStamp() {
		return timeStamp;
	}
	public void setTimeStamp(long timeStamp) {
		this.timeStamp = timeStamp;
		modified = true;
	}
	
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}

	public boolean isModified() {
		return modified || id==null;
	}
	public void setModified(boolean modified) {
		this.modified = modified;
	}

	public static final int TYPE_LAST_POSITION = 0;
	public static final int TYPE_POSITION = 1;
	public static final int TYPE_COMMENT = 2;
	public static final int TYPE_CORRECTION = 3;
	private Long id;
	private int type;
	private int percent;
	private int shortcut;
	private String startPos;
	private String endPos;
	private String titleText;
	private String posText;
	private String commentText;
	private long timeStamp; // UTC timestamp
	private boolean modified;
	
}
",False,24,18,3,8,0,0,6,0,L1
10,org.coolreader.crengine.DocumentFormat.java,"package org.coolreader.crengine;

import org.coolreader.R;

public enum DocumentFormat {
	/// lvtinydom.h: source document formats
	//typedef enum {
	NONE(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book, new String[] {}),// doc_format_none,
	FB2(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book_fb2, new String[] {"".fb2"", "".fb2.zip""}), // doc_format_fb2,
	TXT(""txt.css"", R.raw.txt, R.drawable.cr3_browser_book_txt, new String[] {"".txt"", "".tcr""}), // doc_format_txt,
	RTF(""rtf.css"", R.raw.rtf, R.drawable.cr3_browser_book_rtf, new String[] {"".rtf""}), // doc_format_rtf,
	EPUB(""epub.css"", R.raw.epub, R.drawable.cr3_browser_book_epub, new String[] {"".epub""}),// doc_format_epub,
	HTML(""htm.css"", R.raw.htm, R.drawable.cr3_browser_book_html, new String[] {"".htm"", "".html"", "".shtml"", "".xhtml""}),// doc_format_html,
	TXT_BOOKMARK(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book_fb2, new String[] {"".txt.bmk""}), // doc_format_txt_bookmark, // coolreader TXT format bookmark
	CHM(""chm.css"", R.raw.chm, R.drawable.cr3_browser_book_chm, new String[] {"".chm""}); //  doc_format_chm,
	    // don't forget update getDocFormatName() when changing this enum
	//} doc_format_t;
	
	public String getCssName()
	{
		return cssFileName;
	}
	
	public int getCSSResourceId()
	{
		return cssResourceId;
	}
	
	public int getIconResourceId()
	{
		return iconResourceId;
	}
	
	public static DocumentFormat byId( int i )
	{
		if ( i>=0 && i<=CHM.ordinal() )
			return values()[i];
		return null;
	}
	
	public boolean matchExtension( String filename )
	{
		for ( String ext : extensions )
			if ( filename.endsWith(ext) )
				return true;
		return false;
	}
	
	public static DocumentFormat byExtension( String filename )
	{
		String s = filename.toLowerCase();
		for ( int i=0; i<=CHM.ordinal(); i++ )
			if ( values()[i].matchExtension(s))
				return values()[i];
		return null;
	}
	
	private DocumentFormat( String cssFileName, int cssResourceId, int iconResourceId, String extensions[] )
	{
		this.cssFileName = cssFileName;
		this.cssResourceId = cssResourceId;
		this.iconResourceId = iconResourceId;
		this.extensions = extensions;
	}
	final private String cssFileName;
	final private int cssResourceId;
	final private int iconResourceId;
	final private String[] extensions;
}
",False,20,20,3,11,0,0,6,0,L0
11,org.coolreader.crengine.FileInfo.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.coolreader.R;

import android.util.Log;

public class FileInfo {
	Long id; // db id
	String title; // book title
	String authors; // authors, delimited with '|'
	String series; // series name w/o number
	int seriesNumber; // number of book inside series
	String path; // path to directory where file or archive is located
	String filename; // file name w/o path for normal file, with optional path for file inside archive 
	String pathname; // full path+arcname+filename
	String arcname; // archive file name w/o path
	DocumentFormat format;
	int size;
	int arcsize;
	long createTime;
	long lastAccessTime;
	boolean isArchive;
	boolean isDirectory;
	boolean isModified;
	boolean isListed;
	boolean isScanned;
	private ArrayList<FileInfo> files;// files
	private ArrayList<FileInfo> dirs; // directories
	FileInfo parent; // parent item

	/**
	 * To separate archive name from file name inside archive.
	 */
	public static String ARC_SEPARATOR = ""@/"";
	
	/**
	 * Split archive + file path name by ARC_SEPARATOR
	 * @param pathName is pathname like /arc_file_path@/filepath_inside_arc or /file_path 
	 * @return item[0] is pathname, item[1] is archive name (null if no archive)
	 */
	public static String[] splitArcName( String pathName )
	{
		String[] res = new String[2];
		int arcSeparatorPos = pathName.indexOf(ARC_SEPARATOR);
		if ( arcSeparatorPos>=0 ) {
			// from archive
			res[1] = pathName.substring(0, arcSeparatorPos);
			res[0] = pathName.substring(arcSeparatorPos + ARC_SEPARATOR.length());
		} else {
			res[0] = pathName;
		}
		return res;
	}
	
	public FileInfo( String pathName )
	{
		String[] parts = splitArcName( pathName );
		if ( parts[1]!=null ) {
			// from archive
			isArchive = true;
			arcname = parts[1];
			pathname = parts[0];
			File f = new File(pathname);
			filename = f.getName();
			path = f.getPath();
			File arc = new File(arcname);
			if ( arc.isFile() && arc.exists() ) {
				arcsize = (int)arc.length();
				try {
					ZipFile zip = new ZipFile(new File(arcname));
					for ( Enumeration<?> e = zip.entries(); e.hasMoreElements(); ) {
						ZipEntry entry = (ZipEntry)e.nextElement();
						
						String name = entry.getName();
						if ( !entry.isDirectory() && !pathname.equals(name) ) {
							format = DocumentFormat.byExtension(name);
							size = (int)entry.getSize();
							createTime = entry.getTime();
							break;
						}
					}
				} catch ( Exception e ) {
					Log.e(""cr3"", ""error while reading contents of "" + arcname);
				}
			}
		} else {
			fromFile(new File(pathName));
		}
	}
	
	private void fromFile( File f )
	{
		if ( !f.isDirectory() ) {
			DocumentFormat fmt = DocumentFormat.byExtension(f.getName());
			filename = f.getName();
			path = f.getParent();
			pathname = f.getAbsolutePath();
			format = fmt;
			createTime = f.lastModified();
			size = (int)f.length();
		} else {
			filename = f.getName();
			path = f.getParent();
			pathname = f.getAbsolutePath();
			isDirectory = true;
		}
	}
	
	public FileInfo( File f )
	{
		fromFile(f);
	}
	
	public FileInfo()
	{
	}

	/// doesn't copy parent and children
	public FileInfo(FileInfo v)
	{
		title = v.title;
		authors = v.authors;
		series = v.series;
		seriesNumber = v.seriesNumber;
		path = v.path;
		filename = v.filename;
		pathname = v.pathname;
		arcname = v.arcname;
		format = v.format;
		size = v.size;
		arcsize = v.arcsize;
		isArchive = v.isArchive;
		isDirectory = v.isDirectory;
		createTime = v.createTime;
		lastAccessTime = v.lastAccessTime;
	}
	
	/**
	 * @return archive file path and name, null if this object is neither archive nor a file inside archive
	 */
	public String getArchiveName()
	{
		return arcname;
	}
	
	/**
	 * @return file name inside archive, null if this object is not a file inside archive
	 */
	public String getArchiveItemName()
	{
		if ( isArchive && !isDirectory && pathname!=null )
			return pathname;
		return null;
	}
	
	public final static String RECENT_DIR_TAG = ""@recent"";
	public final static String ROOT_DIR_TAG = ""@root"";
	
	public boolean isRecentDir()
	{
		return RECENT_DIR_TAG.equals(pathname);
	}
	
	public boolean isRootDir()
	{
		return ROOT_DIR_TAG.equals(pathname);
	}
	
	public boolean isSpecialDir()
	{
		return pathname.startsWith(""@"");
	}
	
	public boolean isHidden()
	{
		return pathname.startsWith(""."");
	}
	
	/**
	 * Get absolute path to file.
	 * For plain files, returns /abs_path_to_file/filename.ext
	 * For archives, returns /abs_path_to_archive/arc_file_name.zip@/filename_inside_archive.ext
	 * @return full path + filename
	 */
	public String getPathName()
	{
		if ( arcname!=null )
			return arcname + ARC_SEPARATOR + pathname;
		return pathname;
	}

	public int dirCount()
	{
		return dirs!=null ? dirs.size() : 0;
	}

	public int fileCount()
	{
		return files!=null ? files.size() : 0;
	}

	public int itemCount()
	{
		return dirCount() + fileCount();
	}

	public void addDir( FileInfo dir )
	{
		if ( dirs==null )
			dirs = new ArrayList<FileInfo>();
		dirs.add(dir);
	}
	public void addFile( FileInfo file )
	{
		if ( files==null )
			files = new ArrayList<FileInfo>();
		files.add(file);
	}
	public boolean isEmpty()
	{
		return fileCount()==0 && dirCount()==0;
	}
	public FileInfo getItem( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<dirCount())
			return dirs.get(index);
		index -= dirCount();
		if ( index<fileCount())
			return files.get(index);
		Log.e(""cr3"", ""Index out of bounds "" + index + "" at FileInfo.getItem() : returning 0"");
		//throw new IndexOutOfBoundsException();
		return null;
	}
	public FileInfo findItemByPathName( String pathName )
	{
		if ( dirs!=null )
			for ( FileInfo dir : dirs )
				if ( pathName.equals(dir.getPathName() ))
					return dir;
		if ( files!=null )
			for ( FileInfo file : files ) {
				if ( pathName.equals(file.getPathName() ))
					return file;
				if ( file.getPathName().startsWith(pathName+""@/"" ))
					return file;
			}
		return null;
	}
	public int getItemIndex( FileInfo item )
	{
		if ( item==null )
			return -1;
		for ( int i=0; i<dirCount(); i++ ) {
			if ( item.getPathName().equals(getDir(i).getPathName()) )
				return i;
		}
		for ( int i=0; i<fileCount(); i++ ) {
			if ( item.getPathName().equals(getFile(i).getPathName()) )
				return i + dirCount();
		}
		return -1;
	}

	public FileInfo getDir( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<dirCount())
			return dirs.get(index);
		throw new IndexOutOfBoundsException();
	}
	public FileInfo getFile( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<fileCount())
			return files.get(index);
		throw new IndexOutOfBoundsException();
	}

	public void removeEmptyDirs()
	{
		if ( parent==null || pathname.startsWith(""@"") )
			return;
		for ( int i=dirCount()-1; i>=0; i-- )
			if ( getDir(i).dirCount()==0 && getDir(i).fileCount()==0 )
				dirs.remove(i);
	}
	
	private void removeChild( FileInfo item )
	{
		int n = files.indexOf(item);
		if ( n>=0 && n<files.size() )
			files.remove(n);
	}
	
	public boolean deleteFile()
	{
		if ( isArchive ) {
			if ( isDirectory )
				return false;
			File f = new File(arcname);
			if ( f.exists() && !f.isDirectory() ) {
				if ( !f.delete() )
					return false;
				if ( parent!=null ) {
					if ( parent.isArchive ) {
						// remove all files belonging to this archive
					} else {
						parent.removeChild(this);
					}
				}
				return true;
			}
		}
		if ( isDirectory )
			return false;
		if ( !fileExists() )
			return false;
		File f = new File(pathname);
		if ( f.delete() ) {
			if ( parent!=null ) {
				parent.removeChild(this);
			}
			return true;
		}
		return false;
	}
	
	public boolean fileExists()
	{
		if (isDirectory)
			return false;
		if ( isArchive ) {
			if ( arcname!=null )
				return new File(arcname).exists();
			return false;
		}
		return new File(pathname).exists();
	}
	
	public boolean isModified() {
		return isModified || id==null;
	}

	public void setModified(boolean isModified) {
		this.isModified = isModified;
	}

	public void clear()
	{
		dirs = null;
		files = null;
	}
	
	public static enum SortOrder {
		FILENAME(R.string.mi_book_sort_order_filename, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return cmp(f1.filename, f2.filename);
			}
		}),
		FILENAME_DESC(R.string.mi_book_sort_order_filename_desc, FILENAME),
		TIMESTAMP(R.string.mi_book_sort_order_timestamp, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz( cmp(f1.createTime, f2.createTime), cmp(f1.filename, f2.filename) );
			}
		}),
		TIMESTAMP_DESC(R.string.mi_book_sort_order_timestamp_desc, TIMESTAMP),
		AUTHOR_TITLE(R.string.mi_book_sort_order_author, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz(
						cmpNotNullFirst(f1.authors, f2.authors)
						,cmpNotNullFirst(f1.series, f2.series)
						,cmp(f1.seriesNumber, f2.seriesNumber)
						,cmpNotNullFirst(f1.title, f2.title)
						,cmp(f1.filename, f2.filename) 
						);
			}
		}),
		AUTHOR_TITLE_DESC(R.string.mi_book_sort_order_author_desc, AUTHOR_TITLE),
		TITLE_AUTHOR(R.string.mi_book_sort_order_title, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz(
						cmpNotNullFirst(f1.series, f2.series)
						,cmp(f1.seriesNumber, f2.seriesNumber)
						,cmpNotNullFirst(f1.title, f2.title)
						,cmpNotNullFirst(f1.authors, f2.authors)
						,cmp(f1.filename, f2.filename) 
						);
			}
		}),
		TITLE_AUTHOR_DESC(R.string.mi_book_sort_order_title_desc, TITLE_AUTHOR);
		//================================================
		private final Comparator<FileInfo> comparator;
		public final int resourceId;
		private SortOrder( int resourceId, Comparator<FileInfo> comparator )
		{
			this.resourceId = resourceId;
			this.comparator = comparator;
		}
		private SortOrder( int resourceId, final SortOrder base )
		{
			this.resourceId = resourceId;
			this.comparator = new Comparator<FileInfo>() {
				public int compare( FileInfo f1, FileInfo f2 )
				{
					return -base.comparator.compare(f1, f2);
				}
			};
		}
		
		public final Comparator<FileInfo> getComparator()
		{
			return comparator;
		}
		
		/**
		 * Compares two strings
		 * @param str1
		 * @param str2
		 * @return
		 */
		private static int cmp( String str1, String str2 )
		{
			if ( str1==null && str2==null )
				return 0;
			if ( str1==null )
				return -1;
			if ( str2==null )
				return 1;
			return str1.compareTo(str2);
		}
		
		/**
		 * Same as cmp, but not-null comes first
		 * @param str1
		 * @param str2
		 * @return
		 */
		private static int cmpNotNullFirst( String str1, String str2 )
		{
			if ( str1==null && str2==null )
				return 0;
			if ( str1==null )
				return 1;
			if ( str2==null )
				return -1;
			return str1.compareTo(str2);
		}
		
		private static int cmp( long n1, long n2 )
		{
			if ( n1<n2 )
				return -1;
			if ( n1>n2 )
				return 1;
			return 0;
		}
		
		private static int firstNz( int... v)
		{
			for ( int i=0; i<v.length; i++ ) {
				if ( v[i]!=0 )
					return v[i];
			}
			return 0;
		}
	}
	public final static SortOrder DEF_SORT_ORDER = SortOrder.AUTHOR_TITLE;
		
	public void sort( SortOrder SortOrder )
	{
		if ( dirs!=null ) {
			ArrayList<FileInfo> newDirs = new ArrayList<FileInfo>(dirs);
			Collections.sort( newDirs, SortOrder.getComparator() );
			dirs = newDirs;
		}
		if ( files!=null ) {
			ArrayList<FileInfo> newFiles = new ArrayList<FileInfo>(files);
			Collections.sort( newFiles, SortOrder.getComparator() );
			files = newFiles;
		}
	}
	
	@Override
	public String toString()
	{
		return pathname;
	}
}
",True,25,19,2,9,1,1,8,1,L1
12,org.coolreader.crengine.BackgroundTextureInfo.java,"package org.coolreader.crengine;

import java.io.File;

public class BackgroundTextureInfo {
	public String id; // filepath for external image or unique symbolic name for resource
	public String name;
	public int resourceId;
	public boolean tiled;
	public BackgroundTextureInfo(String id, String name, int resourceId) {
		this.id = id;
		this.name = name;
		this.resourceId = resourceId;
		this.tiled = id.startsWith(""tx_"") || id.indexOf(""/textures/"")>0;
	}

	public static BackgroundTextureInfo fromFile( String filename ) {
		if ( filename==null )
			return null;
		File f = new File(filename);
		if ( !f.isFile() || !f.exists() )
			return null;
		String nm = new File(filename).getName();
		String fnlc = nm.toLowerCase();
		if ( fnlc.endsWith("".png"") || fnlc.endsWith("".jpg"") || fnlc.endsWith("".jpeg"") || fnlc.endsWith("".gif"") ) {
			return new BackgroundTextureInfo(filename, nm.substring(0, nm.lastIndexOf('.')), 0);
		}
		return null;
	}

	public static final String NO_TEXTURE_ID = ""(NONE)"";
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + resourceId;
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		BackgroundTextureInfo other = (BackgroundTextureInfo) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (resourceId != other.resourceId)
			return false;
		return true;
	}
	@Override
	public String toString() {
		return ""BackgroundTextureInfo [id="" + id + "", name="" + name + ""]"";
	}
	public boolean isNone() {
		return id==null || id.equals(NO_TEXTURE_ID);
	}
}
",False,8,16,3,9,0,0,3,0,L1
13,org.coolreader.crengine.History.java,"package org.coolreader.crengine;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.util.Log;

public class History {
	private ArrayList<BookInfo> mBooks = new ArrayList<BookInfo>();
	private final CRDB mDB;
	private FileInfo mRecentBooksFolder;
	
	public History(CRDB db)
	{
		this.mDB = db;
	}
	
	public BookInfo getLastBook()
	{
		if ( mBooks.size()==0 )
			return null;
		return mBooks.get(0);
	}

	public BookInfo getOrCreateBookInfo( FileInfo file )
	{
		BookInfo res = getBookInfo(file);
		if ( res==null ) {
			res = new BookInfo( file );
			mBooks.add(0, res);
		}
		return res;
	}
	
	public BookInfo getBookInfo( FileInfo file )
	{
		int index = findBookInfo( file );
		if ( index>=0 )
			return mBooks.get(index);
		return null;
	}

	public BookInfo getBookInfo( String pathname )
	{
		int index = findBookInfo( pathname );
		if ( index>=0 )
			return mBooks.get(index);
		return null;
	}
	
	public void removeBookInfo( FileInfo fileInfo, boolean removeRecentAccessFromDB, boolean removeBookFromDB )
	{
		int index = findBookInfo(fileInfo);
		if ( index>=0 )
			mBooks.remove(index);
		if ( mDB.findByPathname(fileInfo) ) {
			if ( removeBookFromDB )
				mDB.deleteBook(fileInfo);
			else if ( removeRecentAccessFromDB )
				mDB.deleteRecentPosition(fileInfo);
		}
	}
	
	public void updateBookAccess( BookInfo bookInfo )
	{
		Log.v(""cr3"", ""History.updateBookAccess() for "" + bookInfo.getFileInfo().getPathName());
		int index = findBookInfo(bookInfo.getFileInfo());
		if ( index>=0 ) {
			BookInfo info = mBooks.get(index);
			if ( index>0 ) {
				mBooks.remove(index);
				mBooks.add(0, info);
			}
			info.updateAccess();
			updateRecentDir();
		}
	}

	public int findBookInfo( String pathname )
	{
		for ( int i=0; i<mBooks.size(); i++ )
			if ( pathname.equals(mBooks.get(i).getFileInfo().getPathName()) )
				return i;
		return -1;
	}
	
	public int findBookInfo( FileInfo file )
	{
		return findBookInfo( file.getPathName() );
	}
	
	public Bookmark getLastPos( FileInfo file )
	{
		int index = findBookInfo(file);
		if ( index<0 )
			return null;
		return mBooks.get(index).getLastPosition();
	}
	protected void updateRecentDir()
	{
		Log.v(""cr3"", ""History.updateRecentDir()"");
		if ( mRecentBooksFolder!=null ) { 
			mRecentBooksFolder.clear();
			for ( BookInfo book : mBooks )
				mRecentBooksFolder.addFile(book.getFileInfo());
		} else {
			Log.v(""cr3"", ""History.updateRecentDir() : mRecentBooksFolder is null"");
		}
	}
	static class ImageData {
		long bookId;
		byte[] data;
		BitmapDrawable drawable = null;
	}
	class ImageDataCache {
		private final int maxSize;
		private int dataSize = 0;
		private int maxCount = 15;
		private ArrayList<ImageData> list = new ArrayList<ImageData>();
		public ImageDataCache( int maxSize, int maxCount ) {
			this.maxSize = maxSize;
			this.maxCount = maxCount;
		}
		synchronized public void clear() {
			list.clear();
		}
		synchronized public byte[] get( long bookId ) {
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId )
					return list.get(i).data;
			return null;
		}
		synchronized public void put( long bookId, byte[] data ) {
			boolean found = false;
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId ) {
					dataSize -= list.get(i).data.length;  
					dataSize += data.length;  
					list.get(i).data = data;
					if ( i>0 ) {
						ImageData item = list.remove(i);
						list.add(0, item);
					}
					found = true;
					break;
				}
			if ( !found ) {
				ImageData item = new ImageData();
				item.bookId = bookId;
				item.data = data;
				list.add(0, item);
				dataSize += data.length;
			}
			for ( int i=list.size()-1; i>0; i-- ) {
				if ( dataSize>maxSize || list.size()>maxCount ) {
					ImageData item = list.remove(i);
					dataSize -= item.data.length;
				} else
					break;
			}
		}
		synchronized public BitmapDrawable getImage( long bookId )
		{
			ImageData item = null;
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId ) {
					item = list.get(i);
					break;
				}
			if ( item==null )
				return null;
			byte[] data = get(bookId);
			if ( data==null || data.length==0 )
				return null;
			if ( item.drawable!=null )
				return item.drawable;
			// decode & resize
			BitmapDrawable res = decodeCoverPage( data );
			if ( res!=null ) {
	    		item.drawable = res;
			} else {
	    		item.data = new byte[] {};
			}
			return res;
		}
		synchronized void invalidateImages()
		{
			for ( int i=0; i<list.size(); i++ )
				list.get(i).drawable = null;
		}
	}
	
	public BitmapDrawable decodeCoverPage( byte[] data )
	{
		try {
			ByteArrayInputStream is = new ByteArrayInputStream(data);
			BitmapDrawable drawable = new BitmapDrawable(is);
			//BitmapDrawable drawable = new BitmapDrawable(null, is);
			Bitmap bmp = Bitmap.createBitmap(coverPageWidth, coverPageHeight, Bitmap.Config.ARGB_8888);
			Canvas canvas = new Canvas(bmp);
			canvas.drawBitmap(drawable.getBitmap(), new Rect(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()),
					new Rect(0, 0, coverPageWidth, coverPageHeight), null);
    		Log.d(""cr3"", ""cover page format: "" + drawable.getIntrinsicWidth() + ""x"" + drawable.getIntrinsicHeight());
    		BitmapDrawable res = new BitmapDrawable(bmp);
    		return res;
		} catch ( Exception e ) {
    		Log.e(""cr3"", ""exception while decoding coverpage "" + e.getMessage());
    		return null;
		}
	}
	
	private boolean coverPagesEnabled = true;
	public boolean getCoverPagesEnabled()
	{
		return coverPagesEnabled;
	}
	
	public void setCoverPagesEnabled(boolean coverPagesEnabled)
	{
		this.coverPagesEnabled = coverPagesEnabled;
		if ( !coverPagesEnabled ) {
			coverPageCache.clear();
		}
	}
	
	public final static int COVERPAGE_IMAGE_CACHE_DATA_SIZE = 500000;
	public final static int COVERPAGE_IMAGE_CACHE_MAX_COUNT = 20;
	private ImageDataCache coverPageCache = new ImageDataCache(COVERPAGE_IMAGE_CACHE_DATA_SIZE, COVERPAGE_IMAGE_CACHE_MAX_COUNT);
	private int coverPageWidth = 60;
	private int coverPageHeight = 80;
	public void setBookCoverpageData(long bookId, byte[] coverpageData )
	{
		if ( bookId==0 )
			return;
		byte[] oldData = coverPageCache.get(bookId);
		if ( coverpageData==null )
			coverpageData = new byte[] {};
		if ( oldData==null || oldData.length!=coverpageData.length ) { 
			coverPageCache.put(bookId, coverpageData);
			mDB.saveBookCoverpage(bookId, coverpageData);
		}
	}
	public void updateCoverPageSize( int screenDX, int screenDY )
	{
		int min = screenDX<screenDY ? screenDX : screenDY;
		coverPageHeight = min / 4;
		coverPageWidth = coverPageHeight * 3 / 4;
		coverPageCache.invalidateImages();
	}
	public byte[] getBookCoverpageData(long bookId)
	{
		if ( bookId==0 )
			return null;
		byte[] data = coverPageCache.get(bookId);
		if ( data==null ) {
			data = mDB.loadBookCoverpage(bookId);
			if ( data==null )
				data = new byte[] {};
			coverPageCache.put(bookId, data);
		}
		return data.length>0 ? data : null;
	}
	public BitmapDrawable getBookCoverpageImage(Resources resources, long bookId)
	{
		byte[] data = getBookCoverpageData(bookId);
		if ( data==null )
			return null;
		return coverPageCache.getImage( bookId );
	}
	public boolean loadFromDB( Scanner scanner, int maxItems )
	{
		Log.v(""cr3"", ""History.loadFromDB()"");
		mBooks = mDB.loadRecentBooks(scanner.mFileList, maxItems);
		mRecentBooksFolder = scanner.mRoot.getDir(0);
		if ( mRecentBooksFolder==null )
			Log.v(""cr3"", ""History.loadFromDB() : mRecentBooksFolder is null"");
		updateRecentDir();
		return true;
	}

	public boolean saveToDB( )
	{
		Log.v(""cr3"", ""History.saveToDB()"");
		try {
			for ( BookInfo book : mBooks )
				mDB.save(book);
			return true;
		} catch ( Exception e ) {
			Log.e(""cr3"", ""error while saving file history "" + e.getMessage(), e);
			return false;
		}
	}

}
",True,6,27,0,0,4,10,3,5,L1
14,org.coolreader.crengine.PositionProperties.java,"package org.coolreader.crengine;

public class PositionProperties {
	public int x;
	public int y;
	public int fullHeight;
	public int pageHeight;
	public int pageWidth;
	public int pageNumber;
	public int pageCount;
	public int pageMode; // 1, 2 for page mode, 0 for scroll mode
	
	
	
	@Override
	public String toString() {
		return ""PositionProperties [pageMode="" + pageMode + "", pageNumber=""
				+ pageNumber + "", pageCount="" + pageCount + "", x="" + x + "", y=""
				+ y + "", pageHeight="" + pageHeight + "", pageWidth="" + pageWidth
				+ "", fullHeight="" + fullHeight + ""]"";
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + fullHeight;
		result = prime * result + pageCount;
		result = prime * result + pageHeight;
		result = prime * result + pageMode;
		result = prime * result + pageNumber;
		result = prime * result + pageWidth;
		result = prime * result + x;
		result = prime * result + y;
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PositionProperties other = (PositionProperties) obj;
		if (fullHeight != other.fullHeight)
			return false;
		if (pageCount != other.pageCount)
			return false;
		if (pageHeight != other.pageHeight)
			return false;
		if (pageMode != other.pageMode)
			return false;
		if (pageNumber != other.pageNumber)
			return false;
		if (pageWidth != other.pageWidth)
			return false;
		if (x != other.x)
			return false;
		if (y != other.y)
			return false;
		return true;
	}
	
	
}
",False,14,16,4,9,0,0,1,0,L2
15,org.coolreader.crengine.Scanner.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.zip.ZipEntry;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.Engine.EngineTask;

import android.os.Environment;
import android.util.Log;

public class Scanner {
	
	HashMap<String, FileInfo> mFileList = new HashMap<String, FileInfo>();
	ArrayList<FileInfo> mFilesForParsing = new ArrayList<FileInfo>();
	FileInfo mRoot;

//	private boolean scanDirectories( FileInfo baseDir )
//	{
//		try {
//			File dir = new File(baseDir.pathname);
//			File[] items = dir.listFiles();
//			// process normal files
//			for ( File f : items ) {
//				if ( !f.isDirectory() ) {
//					FileInfo item = new FileInfo( f );
//					if ( item.format!=null ) {
//						item.parent = baseDir;
//						baseDir.addFile(item);
//						mFileList.add(item);
//					}
//				}
//			}
//			// process directories 
//			for ( File f : items ) {
//				if ( f.isDirectory() ) {
//					FileInfo item = new FileInfo( f );
//					item.parent = baseDir;
//					scanDirectories(item);
//					if ( !item.isEmpty() ) {
//						baseDir.addDir(item);					
//					}
//				}
//			}
//			return !baseDir.isEmpty();
//		} catch ( Exception e ) {
//			Log.e(""cr3"", ""Exception while scanning directory "" + baseDir.pathname, e);
//			return false;
//		}
//	}
	
	private boolean dirScanEnabled = true;
	public boolean getDirScanEnabled()
	{
		return dirScanEnabled;
	}
	
	public void setDirScanEnabled(boolean dirScanEnabled)
	{
		this.dirScanEnabled = dirScanEnabled;
	}
	
	private FileInfo scanZip( FileInfo zip )
	{
		try {
			File zf = new File(zip.pathname);
			//ZipFile file = new ZipFile(zf);
			ArrayList<ZipEntry> entries = engine.getArchiveItems(zip.pathname);
			ArrayList<FileInfo> items = new ArrayList<FileInfo>();
			//for ( Enumeration<?> e = file.entries(); e.hasMoreElements(); ) {
			for ( ZipEntry entry : entries ) {
				if ( entry.isDirectory() )
					continue;
				String name = entry.getName();
				FileInfo item = new FileInfo();
				item.format = DocumentFormat.byExtension(name);
				if ( item.format==null )
					continue;
				File f = new File(name);
				item.filename = f.getName();
				item.path = f.getPath();
				item.pathname = entry.getName();
				item.size = (int)entry.getSize();
				//item.createTime = entry.getTime();
				item.createTime = zf.lastModified();
				item.arcname = zip.pathname;
				item.arcsize = (int)entry.getSize(); //getCompressedSize();
				item.isArchive = true;
				items.add(item);
			}
			if ( items.size()==0 ) {
				Log.i(""cr3"", ""Supported files not found in "" + zip.pathname);
				return null;
			} else if ( items.size()==1 ) {
				// single supported file in archive
				FileInfo item = items.get(0);
				item.isArchive = true;
				item.isDirectory = false;
				return item;
			} else {
				zip.isArchive = true;
				zip.isDirectory = true;
				zip.isListed = true;
				for ( FileInfo item : items ) {
					item.parent = zip;
					zip.addFile(item);
				}
				return zip;
			}
		} catch ( Exception e ) {
			Log.e(""cr3"", ""IOException while opening "" + zip.pathname + "" "" + e.getMessage());
		}
		return null;
	}
	
	/**
	 * Adds dir and file children to directory FileInfo item.
	 * @param baseDir is directory to list files and dirs for
	 * @return true if successful.
	 */
	public boolean listDirectory( FileInfo baseDir )
	{
		if ( baseDir.isListed )
			return true;
		try {
			File dir = new File(baseDir.pathname);
			File[] items = dir.listFiles();
			// process normal files
			if ( items!=null ) {
				for ( File f : items ) {
					if ( !f.isDirectory() ) {
						if ( f.getName().startsWith(""."") )
							continue; // treat files beginning with '.' as hidden
						String pathName = f.getAbsolutePath();
						boolean isZip = pathName.toLowerCase().endsWith("".zip"");
						FileInfo item = mFileList.get(pathName);
						boolean isNew = false;
						if ( item==null ) {
							item = new FileInfo( f );
							if ( isZip ) {
								item = scanZip( item );
								if ( item==null )
									continue;
								if ( item.isDirectory ) {
									// many supported files in ZIP
									item.parent = baseDir;
									baseDir.addDir(item);
									for ( int i=0; i<item.fileCount(); i++ ) {
										FileInfo file = item.getFile(i);
										mFileList.put(file.getPathName(), file);
									}
								} else {
									item.parent = baseDir;
									baseDir.addFile(item);
									mFileList.put(pathName, item);
								}
								continue;
							}
							isNew = true;
						}
						if ( item.format!=null ) {
							item.parent = baseDir;
							baseDir.addFile(item);
							if ( isNew )
								mFileList.put(pathName, item);
						}
					}
				}
				// process directories 
				for ( File f : items ) {
					if ( f.isDirectory() ) {
						if ( f.getName().startsWith(""."") )
							continue; // treat dirs beginning with '.' as hidden
						FileInfo item = new FileInfo( f );
						item.parent = baseDir;
						baseDir.addDir(item);					
					}
				}
			}
			baseDir.isListed = true;
			return !baseDir.isEmpty();
		} catch ( Exception e ) {
			Log.e(""cr3"", ""Exception while listing directory "" + baseDir.pathname, e);
			baseDir.isListed = true;
			return false;
		}
	}
	
	/**
	 * Scan single directory for dir and file properties in background thread.
	 * @param baseDir is directory to scan
	 * @param readyCallback is called on completion
	 */
	public void scanDirectory( final FileInfo baseDir, final Runnable readyCallback )
	{
		final long startTime = System.currentTimeMillis();
		listDirectory(baseDir);
		listSubtree( baseDir, 2, android.os.SystemClock.uptimeMillis() + 700 );
		if ( !getDirScanEnabled() || baseDir.isScanned ) {
			readyCallback.run();
			return;
		}
		engine.execute(new EngineTask() {
			long nextProgressTime = startTime + 2000;
			boolean progressShown = false;
			void progress( int percent )
			{
				long ts = System.currentTimeMillis();
				if ( ts>=nextProgressTime ) {
					engine.showProgress(percent, R.string.progress_scanning);
					nextProgressTime = ts + 1500;
					progressShown = true;
				}
			}
			
			public void done() {
				baseDir.isScanned = true;
				if ( progressShown )
					engine.hideProgress();
				readyCallback.run();
			}

			public void fail(Exception e) {
				Log.e(""cr3"", ""Exception while scanning directory "" + baseDir.pathname, e);
				baseDir.isScanned = true;
				if ( progressShown )
					engine.hideProgress();
				readyCallback.run();
			}

			public void work() throws Exception {
				// scan (list) directories
				nextProgressTime = System.currentTimeMillis() + 2000;
				progress(1000);
				for ( int i=baseDir.dirCount()-1; i>=0; i-- )
					listDirectory(baseDir.getDir(i));
				baseDir.removeEmptyDirs();
				progress(2000);
				ArrayList<FileInfo> filesForParsing = new ArrayList<FileInfo>();
				int count = baseDir.fileCount();
				for ( int i=0; i<count; i++ ) {
					FileInfo item = baseDir.getFile(i);
					boolean found = db.findByPathname(item);
					if ( found )
						Log.v(""cr3db"", ""File "" + item.pathname + "" is found in DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");

					boolean saveToDB = true;
					if ( !found && item.format==DocumentFormat.FB2 ) {
						filesForParsing.add(item);
						saveToDB = false;
					}

					if ( !found && saveToDB ) {
						db.save(item);
						Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
					}
					progress( 2000 + 3000 * i / count );
				}
				// db lookup files
				count = filesForParsing.size();
				for ( int i=0; i<count; i++ ) {
					FileInfo item = filesForParsing.get(i);
					engine.scanBookProperties(item);
					db.save(item);
					Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
					progress( 5000 + 5000 * i / count );
				}
			}
		});
	}

//	private int lastPercent = 0;
//	private long lastProgressUpdate = 0;
//	private final int PROGRESS_UPDATE_INTERVAL = 2000; // 2 seconds
//	private void updateProgress( int percent )
//	{
//		long ts = System.currentTimeMillis();
//		if ( percent!=lastPercent && ts>lastProgressUpdate+PROGRESS_UPDATE_INTERVAL ) {
//			engine.showProgress(percent, ""Scanning directories..."");
//			lastPercent = percent;
//			lastProgressUpdate = ts;
//		}
//	}
	
//	private void lookupDB()
//	{
//		int count = mFileList.size();
//		for ( int i=0; i<count; i++ ) {
//			FileInfo item = mFileList.get(i);
//			boolean found = db.findByPathname(item);
//			if ( found )
//				Log.v(""cr3db"", ""File "" + item.pathname + "" is found in DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//
//			boolean saveToDB = true;
//			if ( !found && item.format==DocumentFormat.FB2 ) {
//				mFilesForParsing.add(item);
//				saveToDB = false;
//			}
//
//			if ( !found && saveToDB ) {
//				db.save(item);
//				Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//			}
//			updateProgress( 1000 + 4000 * i / count );
//		}
//	}
//	
//	private void parseBookProperties()
//	{
//		int count = mFilesForParsing.size();
//		for ( int i=0; i<count; i++ ) {
//			FileInfo item = mFilesForParsing.get(i);
//			engine.scanBookProperties(item);
//			db.save(item);
//			Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//			updateProgress( 5000 + 5000 * i / count );
//		}
//	}
	
	private boolean addRoot( String pathname, int resourceId, boolean listIt)
	{
		return addRoot( pathname, coolReader.getResources().getString(resourceId), listIt);
	}
	private boolean addRoot( String pathname, String filename, boolean listIt)
	{
		FileInfo dir = new FileInfo();
		dir.isDirectory = true;
		dir.pathname = pathname;
		dir.filename = filename;
		if ( listIt && !listDirectory(dir) )
			return false;
		mRoot.addDir(dir);
		dir.parent = mRoot;
		if ( !listIt ) {
			dir.isListed = true;
			dir.isScanned = true;
		}
		return true;
	}
	
	/**
	 * Lists all directories from root to directory of specified file, returns found directory.
	 * @param file
	 * @param root
	 * @return
	 */
	private FileInfo findParentInternal( FileInfo file, FileInfo root )
	{
		if ( root==null || file==null || root.isRecentDir() )
			return null;
		if ( !root.isRootDir() && !file.getPathName().startsWith( root.getPathName() ) )
			return null;
		// to list all directories starting root dir
		if ( root.isDirectory && !root.isSpecialDir() )
				listDirectory(root);
		for ( int i=0; i<root.dirCount(); i++ ) {
			FileInfo found = findParentInternal( file, root.getDir(i));
			if ( found!=null )
				return found;
		}
		for ( int i=0; i<root.fileCount(); i++ ) {
			if ( root.getFile(i).getPathName().equals(file.getPathName()) )
				return root;
			if ( root.getFile(i).getPathName().startsWith(file.getPathName() + ""@/"") )
				return root;
		}
		return null;
	}
	
	public final static int MAX_DIR_LIST_TIME = 500; // 0.5 seconds
	
	/**
	 * Lists all directories from root to directory of specified file, returns found directory.
	 * @param file
	 * @param root
	 * @return
	 */
	public FileInfo findParent( FileInfo file, FileInfo root )
	{
		FileInfo parent = findParentInternal(file, root);
		if ( parent==null )
			return null;
		long maxTs = android.os.SystemClock.uptimeMillis() + MAX_DIR_LIST_TIME;
		listSubtrees(root, 5, maxTs);
		return parent;
	}
	
	/**
	 * List directories in subtree, limited by runtime and depth; remove empty branches (w/o books).  
	 * @param root is directory to start with
	 * @param maxDepth is maximum depth
	 * @param limitTs is limit for android.os.SystemClock.uptimeMillis()
	 * @return true if completed, false if stopped by limit. 
	 */
	private boolean listSubtree( FileInfo root, int maxDepth, long limitTs )
	{
		long ts = android.os.SystemClock.uptimeMillis();
		if ( ts>limitTs || maxDepth<=0 )
			return false;
		listDirectory(root);
		for ( int i=root.dirCount()-1; i>=-0; i-- ) {
			boolean res = listSubtree(root.getDir(i), maxDepth-1, limitTs);
			if ( !res )
				return false;
		}
		root.removeEmptyDirs();
		return true;
	}
	
	/**
	 * List directories in subtree, limited by runtime and depth; remove empty branches (w/o books).  
	 * @param root is directory to start with
	 * @param maxDepth is maximum depth
	 * @param limitTs is limit for android.os.SystemClock.uptimeMillis()
	 * @return true if completed, false if stopped by limit. 
	 */
	public boolean listSubtrees( FileInfo root, int maxDepth, long limitTs )
	{
		for ( int depth = 1; depth<=maxDepth; depth++ ) {
			boolean res = listSubtree( root, depth, limitTs );
			if ( res )
				return true;
			long ts = android.os.SystemClock.uptimeMillis();
			if ( ts>limitTs )
				return false; // limited by time
			// iterate deeper
		}
		return false; // limited by depth
	}
	
	public void initRoots()
	{
		mRoot.clear();
		// create recent books dir
		addRoot( FileInfo.RECENT_DIR_TAG, R.string.dir_recent_books, false);
		addRoot( Environment.getExternalStorageDirectory().getAbsolutePath(), R.string.dir_sd_card, true);
		// internal SD card on Nook
		addRoot( ""/system/media/sdcard"", R.string.dir_internal_sd_card, true);
		// internal SD card on PocketBook 701 IQ
		addRoot( ""/PocketBook701"", R.string.dir_internal_sd_card, true);
		addRoot( ""/nand"", R.string.dir_internal_memory, true);
		// external SD card Huawei S7
		addRoot( ""/sdcard2"", R.string.dir_sd_card_2, true);
	}
	
//	public boolean scan()
//	{
//		Log.i(""cr3"", ""Started scanning"");
//		long start = System.currentTimeMillis();
//		mFileList.clear();
//		mFilesForParsing.clear();
//		mRoot.clear();
//		// create recent books dir
//		FileInfo recentDir = new FileInfo();
//		recentDir.isDirectory = true;
//		recentDir.pathname = ""@recent"";
//		recentDir.filename = ""Recent Books"";
//		mRoot.addDir(recentDir);
//		recentDir.parent = mRoot;
//		// scan directories
//		lastPercent = -1;
//		lastProgressUpdate = System.currentTimeMillis() - 500;
//		boolean res = scanDirectories( mRoot );
//		// process found files
//		lookupDB();
//		parseBookProperties();
//		updateProgress(9999);
//		Log.i(""cr3"", ""Finished scanning ("" + (System.currentTimeMillis()-start)+ "" ms)"");
//		return res;
//	}
	
	
	public FileInfo getRoot() 
	{
		return mRoot;
	}
	public Scanner( CoolReader coolReader, CRDB db, Engine engine )
	{
		this.engine = engine;
		this.db = db;
		this.coolReader = coolReader;
		mRoot = new FileInfo();
		mRoot.path = FileInfo.ROOT_DIR_TAG;	
		mRoot.filename = ""File Manager"";	
		mRoot.pathname = FileInfo.ROOT_DIR_TAG;
		mRoot.isListed = true;
		mRoot.isScanned = true;
		mRoot.isDirectory = true;
	}

	private final Engine engine;
	private final CRDB db;
	private final CoolReader coolReader;
}
",True,12,27,0,0,3,13,4,5,L1
16,org.coolreader.crengine.ReaderCallback.java,"package org.coolreader.crengine;

public interface ReaderCallback {
    /// on starting file loading
    void OnLoadFileStart( String filename );
    /// format detection finished
    String OnLoadFileFormatDetected( DocumentFormat fileFormat );
    /// file loading is finished successfully - drawCoveTo() may be called there
    void OnLoadFileEnd();
    /// first page is loaded from file an can be formatted for preview
    void OnLoadFileFirstPagesReady();
    /// file progress indicator, called with values 0..100
    boolean OnLoadFileProgress( int percent );
    /// document formatting started
    void OnFormatStart();
    /// document formatting finished
    void OnFormatEnd();
    /// format progress, called with values 0..100
    boolean OnFormatProgress( int percent );
    /// format progress, called with values 0..100
    boolean OnExportProgress( int percent );
    /// file load finiished with error
    void OnLoadFileError( String message );
    /// Override to handle external links
    void OnExternalLink( String url, String nodeXPath );
    /// Override to handle external links
    void OnImageCacheClear();
}
",False,15,17,4,9,1,1,1,1,L2
17,org.coolreader.crengine.ColorPickerDialog.java,"package org.coolreader.crengine;

// based on color picker from 
// http://www.anddev.org/announce_color_picker_dialog-t10771.html

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.res.Resources;
import android.content.res.Resources.NotFoundException;
import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.BitmapFactory;
import android.graphics.BlurMaskFilter;
import android.graphics.BlurMaskFilter.Blur;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.PixelFormat;
import android.graphics.PorterDuff.Mode;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.LayerDrawable;
import android.os.SystemClock;
import android.util.StateSet;
import android.view.LayoutInflater;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Transformation;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;

public class ColorPickerDialog extends BaseDialog implements OnSeekBarChangeListener {

    public interface OnColorChangedListener {
        public void colorChanged(int color);
    }

	private SeekBar mHue;
	private SeekBar mSaturation;
	private SeekBar mValue;
	private OnColorChangedListener mListener;
	private int mColor;
	private GradientDrawable mPreviewDrawable;

	public ColorPickerDialog(CoolReader activity, OnColorChangedListener listener, int color, String title) {
		super(activity, R.string.dlg_button_ok, R.string.dlg_button_cancel, true);
		mListener = listener;

		Resources res = activity.getResources();
		setTitle(title);
		View root = LayoutInflater.from(activity).inflate(R.layout.color_picker, null);
		setView(root);
		
		View preview = root.findViewById(R.id.preview);
		mPreviewDrawable = new GradientDrawable();
		// 2 pix more than color_picker_frame's radius
		mPreviewDrawable.setCornerRadius(7);
		Drawable[] layers;
		layers = new Drawable[] {
				mPreviewDrawable,
				res.getDrawable(R.drawable.color_picker_frame),
		};
		preview.setBackgroundDrawable(new LayerDrawable(layers));
		
		mHue = (SeekBar) root.findViewById(R.id.hue);
		mSaturation = (SeekBar) root.findViewById(R.id.saturation);
		mValue = (SeekBar) root.findViewById(R.id.value);
		
		mColor = color;
		float[] hsv = new float[3];
		Color.colorToHSV(color, hsv);
		int h = (int) (hsv[0] * mHue.getMax() / 360);
		int s = (int) (hsv[1] * mSaturation.getMax());
		int v = (int) (hsv[2] * mValue.getMax());
		setupSeekBar(mHue, R.string.options_color_hue, h, res);
		setupSeekBar(mSaturation, R.string.options_color_saturation, s, res);
		setupSeekBar(mValue, R.string.options_color_brightness, v, res);
		
		updatePreview(color);
	}
	
	private void setupSeekBar(SeekBar seekBar, int id, int value, Resources res) {
		seekBar.setProgressDrawable(new TextSeekBarDrawable(res, id, value < seekBar.getMax() / 2));
		seekBar.setProgress(value);
		seekBar.setOnSeekBarChangeListener(this);
	}

	private void update() {
		float[] hsv = {
			360 * mHue.getProgress() / (float) mHue.getMax(),
			mSaturation.getProgress() / (float) mSaturation.getMax(),
			mValue.getProgress() / (float) mValue.getMax(),
		};
		mColor = Color.HSVToColor(hsv);
		updatePreview(mColor);
	}
	
	private void updatePreview(int color) {
		mPreviewDrawable.setColor(color);
		mPreviewDrawable.invalidateSelf();
	}

	public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
		update();
	}

	public void onStartTrackingTouch(SeekBar seekBar) {
	}

	public void onStopTrackingTouch(SeekBar seekBar) {
	}

	@Override
	protected void onPositiveButtonClick() {
		mListener.colorChanged(mColor);
		super.onPositiveButtonClick();
	}

	static class IconPreviewDrawable extends Drawable {
		private Bitmap mBitmap;
		private Bitmap mTmpBitmap;
		private Canvas mTmpCanvas;
		private int mTintColor;
		

		public IconPreviewDrawable(Resources res, int id) {
			Bitmap b;
			try {
				b = BitmapFactory.decodeResource(res, id);
				if (b == null) {
					b = BitmapFactory.decodeResource(res, R.drawable.color_picker_icon);
				}
			} catch (NotFoundException e) {
				b = BitmapFactory.decodeResource(res, R.drawable.color_picker_icon);
			}
			mBitmap = b;
			mTmpBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Config.ARGB_8888);
			mTmpCanvas = new Canvas(mTmpBitmap);
		}
		
		@Override
		public void draw(Canvas canvas) {
			Rect b = getBounds();
			float x = (b.width() - mBitmap.getWidth()) / 2.0f;
			float y = 0.75f * b.height() - mBitmap.getHeight() / 2.0f;
			
			mTmpCanvas.drawColor(0, Mode.CLEAR);
			mTmpCanvas.drawBitmap(mBitmap, 0, 0, null);
			mTmpCanvas.drawColor(mTintColor, Mode.SRC_ATOP);
			canvas.drawBitmap(mTmpBitmap, x, y, null);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}
		
		@Override
		public void setColorFilter(int color, Mode mode) {
			mTintColor = color;
		}
	}
	
	static final int[] STATE_FOCUSED = {android.R.attr.state_focused};
	static final int[] STATE_PRESSED = {android.R.attr.state_pressed};
	
	static class TextSeekBarDrawable extends Drawable implements Runnable {
		
		private static final String TAG = ""TextSeekBarDrawable"";
		private static final long DELAY = 50;
		private String mText;
		private Drawable mProgress;
		private Paint mPaint;
		private Paint mOutlinePaint;
		private float mTextWidth;
		private boolean mActive;
		private float mTextXScale;
		private int mDelta;
		private ScrollAnimation mAnimation;

		public TextSeekBarDrawable(Resources res, int id, boolean labelOnRight) {
			mText = res.getString(id);
			mProgress = res.getDrawable(android.R.drawable.progress_horizontal);
			mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
			mPaint.setTypeface(Typeface.DEFAULT_BOLD);
			mPaint.setTextSize(16);
			mPaint.setColor(0xff000000);
			mOutlinePaint = new Paint(mPaint);
			mOutlinePaint.setStyle(Style.STROKE);
			mOutlinePaint.setStrokeWidth(3);
			mOutlinePaint.setColor(0xbbffc300);
			mOutlinePaint.setMaskFilter(new BlurMaskFilter(1, Blur.NORMAL));
			mTextWidth = mOutlinePaint.measureText(mText);
			mTextXScale = labelOnRight? 1 : 0;
			mAnimation = new ScrollAnimation();
		}

		@Override
		protected void onBoundsChange(Rect bounds) {
			mProgress.setBounds(bounds);
		}
		
		@Override
		protected boolean onStateChange(int[] state) {
			mActive = StateSet.stateSetMatches(STATE_FOCUSED, state) | StateSet.stateSetMatches(STATE_PRESSED, state);
			invalidateSelf();
			return false;
		}
		
		@Override
		public boolean isStateful() {
			return true;
		}
		
		@Override
		protected boolean onLevelChange(int level) {
//			Log.d(TAG, ""onLevelChange "" + level);
			if (level < 4000 && mDelta <= 0) {
//				Log.d(TAG, ""onLevelChange scheduleSelf ++"");
				mDelta = 1;
				mAnimation.startScrolling(mTextXScale, 1);
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			} else
			if (level > 6000 && mDelta >= 0) {
//				Log.d(TAG, ""onLevelChange scheduleSelf --"");
				mDelta = -1;
				mAnimation.startScrolling(mTextXScale, 0);
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			}
			return mProgress.setLevel(level);
		}
		
		@Override
		public void draw(Canvas canvas) {
			mProgress.draw(canvas);

			if (mAnimation.hasStarted() && !mAnimation.hasEnded()) {
				// pending animation
				mAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), null);
				mTextXScale = mAnimation.getCurrent();
//				Log.d(TAG, ""draw "" + mTextX + "" "" + SystemClock.uptimeMillis());
			}
			
			Rect bounds = getBounds();
			float x = 6 + mTextXScale * (bounds.width() - mTextWidth - 6 - 6);
			float y = (bounds.height() + mPaint.getTextSize()) / 2;
			mOutlinePaint.setAlpha(mActive? 255 : 255 / 2);
			mPaint.setAlpha(mActive? 255 : 255 / 2);
			canvas.drawText(mText, x, y, mOutlinePaint);
			canvas.drawText(mText, x, y, mPaint);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}

		public void run() {
			mAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), null);
			// close interpolation of mTextX
			mTextXScale = mAnimation.getCurrent();
			if (!mAnimation.hasEnded()) {
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			}
			invalidateSelf();
//			Log.d(TAG, ""run "" + mTextX + "" "" + SystemClock.uptimeMillis());
		}
	}
	
	static class ScrollAnimation extends Animation {
		private static final String TAG = ""ScrollAnimation"";
		private static final long DURATION = 750;
		private float mFrom;
		private float mTo;
		private float mCurrent;
		
		public ScrollAnimation() {
			setDuration(DURATION);
			setInterpolator(new DecelerateInterpolator());
		}
		
		public void startScrolling(float from, float to) {
			mFrom = from;
			mTo = to;
			startNow();
		}
		
		@Override
		protected void applyTransformation(float interpolatedTime, Transformation t) {
			mCurrent = mFrom + (mTo - mFrom) * interpolatedTime;
//			Log.d(TAG, ""applyTransformation "" + mCurrent);
		}
		
		public float getCurrent() {
			return mCurrent;
		}
	}
}
",False,2,27,0,0,3,12,1,2,L1
18,org.coolreader.crengine.Engine.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.coolreader.R;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.Context;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Environment;
import android.util.Log;

/**
 * CoolReader Engine class.
 *
 * Only one instance is allowed.
 */
public class Engine {
	
	private final Activity mActivity;
	private final BackgroundThread mBackgroundThread;
	//private final View mMainView;
	//private final ExecutorService mExecutor = Executors.newFixedThreadPool(1);
	
	/**
	 * Get storage root directories.
	 * @return array of r/w storage roots
	 */
	public static File[] getStorageDirectories( boolean writableOnly ) {
		ArrayList<File> res = new ArrayList<File>(2);
		File dir = Environment.getExternalStorageDirectory();
		if ( dir.isDirectory() && (!writableOnly || dir.canWrite()) )
			res.add(dir);
		File dir2 = new File(""/system/media/sdcard"");
		if ( dir2.isDirectory() && (!writableOnly || dir2.canWrite()))
			res.add(dir2);
		File dir22 = new File(""/sdcard2"");
		if ( dir22.isDirectory() && (!writableOnly || dir22.canWrite()))
			res.add(dir22);
		File dir3 = new File(""/nand"");
		if ( dir3.isDirectory() && (!writableOnly || dir3.canWrite()))
			res.add(dir3);
		File dir4 = new File(""/PocketBook701"");
		if ( dir4.isDirectory() && (!writableOnly || dir4.canWrite()))
			res.add(dir4);
		return res.toArray( new File[] {});
	}

	/**
	 * Get or create writable subdirectory for specified base directory
	 * @param dir is base directory
	 * @param subdir is subdirectory name, null to use base directory
	 * @param createIfNotExists is true to force directory creation
	 * @return writable directory, null if not exist or not writable
	 */
	public static File getSubdir( File dir, String subdir, boolean createIfNotExists, boolean writableOnly )
	{
		if ( dir==null )
			return null;
		File dataDir = dir;
		if ( subdir!=null ) {
			dataDir = new File( dataDir, subdir );
			if ( !dataDir.isDirectory() && createIfNotExists )
				dataDir.mkdir();
		}
		if ( dataDir.isDirectory() && (!writableOnly || dataDir.canWrite()) )
			return dataDir;
		return null;
	}
	
	/**
	 * Returns array of writable data directories on external storage 
	 * @param subdir
	 * @param createIfNotExists
	 * @return
	 */
	public static File[] getDataDirectories( String subdir, boolean createIfNotExists, boolean writableOnly  ) {
		File[] roots = getStorageDirectories(writableOnly);
		ArrayList<File> res = new ArrayList<File>(roots.length);
		for ( File dir : roots ) {
			File dataDir = getSubdir( dir, "".cr3"", createIfNotExists, writableOnly );
			if ( subdir!=null )
				dataDir = getSubdir( dataDir, subdir, createIfNotExists, writableOnly );
			if ( dataDir!=null )
				res.add(dataDir);
		}
		return res.toArray(new File[] {});
	}
	
	public interface EngineTask {
		public void work() throws Exception;
		public void done();
		public void fail( Exception e );
	}
	
//	public static class FatalError extends RuntimeException {
//		private Engine engine;
//		private String msg;
//		public FatalError( Engine engine, String msg )
//		{
//			this.engine = engine;
//			this.msg = msg;
//		}
//		public void handle()
//		{
//			engine.fatalError(msg);
//		}
//	}
	
	public final static boolean LOG_ENGINE_TASKS = false;
	private class TaskHandler implements Runnable {
		final EngineTask task;
		public TaskHandler( EngineTask task )
		{
			this.task = task;
		}
		public String toString() {
			return ""[handler for "" + this.task.toString() + ""]"";
		}
		public void run() {
			try {
				if ( LOG_ENGINE_TASKS )
					Log.i(""cr3"", ""running task.work() "" + task.getClass().getName());
				if ( !initialized )
					throw new IllegalStateException(""Engine not initialized"");
				// run task
				task.work();
				if ( LOG_ENGINE_TASKS )
					Log.i(""cr3"", ""exited task.work() "" + task.getClass().getName());
				// post success callback
				mBackgroundThread.postGUI(new Runnable() {
					public void run() {
						if ( LOG_ENGINE_TASKS )
							Log.i(""cr3"", ""running task.done() "" + task.getClass().getName() + "" in gui thread"");
						task.done();
					}
				});
//			} catch ( final FatalError e ) {
				//TODO:
//				Handler h = view.getHandler();
//				
//				if ( h==null ) {
//					View root = view.getRootView();
//					h = root.getHandler();
//				}
//				if ( h==null ) {
//					//
//					e.handle();
//				} else {
//					h.postAtFrontOfQueue(new Runnable() {
//						public void run() {
//							e.handle();
//						}
//					});
//				}
			} catch ( final Exception e ) {
				Log.e(""cr3"", ""exception while running task "" + task.getClass().getName(), e);
				// post error callback
				mBackgroundThread.postGUI(new Runnable() {
					public void run() {
						Log.e(""cr3"", ""running task.fail(""+e.getMessage()+"") "" + task.getClass().getSimpleName() + "" in gui thread "");
						task.fail(e);
					}
				});
			}
		}
	}

	/**
	 * Execute task in Engine thread
	 * @param task is task to execute
	 */
	public void execute( final EngineTask task )
	{
		if ( LOG_ENGINE_TASKS )
			Log.d(""cr3"", ""executing task "" + task.getClass().getSimpleName());
		TaskHandler taskHandler = new TaskHandler( task );
		mBackgroundThread.executeBackground( taskHandler );
	}
	
	/**
	 * Schedule task for execution in Engine thread
	 * @param task is task to execute
	 */
	public void post( final EngineTask task )
	{
		if ( LOG_ENGINE_TASKS )
			Log.d(""cr3"", ""executing task "" + task.getClass().getSimpleName());
		TaskHandler taskHandler = new TaskHandler( task );
		mBackgroundThread.postBackground( taskHandler );
	}
	
	/**
	 * Schedule Runnable for execution in GUI thread after all current Engine queue tasks done.  
	 * @param task
	 */
	public void runInGUI( final Runnable task )
	{
		execute( new EngineTask() {

			public void done() {
				mBackgroundThread.postGUI(task);
			}

			public void fail(Exception e) {
				// do nothing
			}

			public void work() throws Exception {
				// do nothing
			}
		});
	}

	public void fatalError( String msg)
	{
		AlertDialog dlg = new AlertDialog.Builder(mActivity).setMessage(msg).setTitle(""CoolReader fatal error"").show();
		try {
			Thread.sleep(10);
		} catch ( InterruptedException e ) {
			// do nothing
		}
		dlg.dismiss();
		mActivity.finish();
	}
	
	private ProgressDialog mProgress;
	private boolean enable_progress = true; 
	private boolean progressShown = false;
	private static int PROGRESS_STYLE = ProgressDialog.STYLE_HORIZONTAL;
	private Drawable progressIcon = null;
//	public void setProgressDrawable( final BitmapDrawable drawable )
//	{
//		if ( enable_progress ) {
//			mBackgroundThread.executeGUI( new Runnable() {
//				public void run() {
//					// show progress
//					Log.v(""cr3"", ""showProgress() - in GUI thread"");
//					if ( mProgress!=null && progressShown ) {
//						hideProgress();
//						progressIcon = drawable;
//						showProgress(mProgressPos, mProgressMessage);
//						//mProgress.setIcon(drawable);
//					}
//				}
//			});
//		}
//	}
	public void showProgress( final int mainProgress, final int resourceId )
	{
		showProgress( mainProgress, mActivity.getResources().getString(resourceId) );
	}
	private String mProgressMessage = null;
	private int mProgressPos = 0;
	
	private volatile int nextProgressId = 0; 
	private void showProgress( final int mainProgress, final String msg )
	{
		final int progressId = ++nextProgressId;
		mProgressMessage = msg;
		mProgressPos = mainProgress;
		if ( mainProgress==10000 ) {
			Log.v(""cr3"", ""mainProgress==10000 : calling hideProgress"");
			hideProgress();
			return;
		}
		Log.v(""cr3"", ""showProgress("" + mainProgress + "", \"""" + msg + ""\"") is called : "" + Thread.currentThread().getName());
		if ( enable_progress ) {
			mBackgroundThread.executeGUI( new Runnable() {
				public void run() {
					// show progress
					Log.v(""cr3"", ""showProgress() - in GUI thread"");
					if ( progressId!= nextProgressId ) {
						Log.v(""cr3"", ""showProgress() - skipping duplicate progress event"");
						return;
					}
					if ( mProgress==null ) {
						Log.v(""cr3"", ""showProgress() - in GUI thread : creating progress window"");
						if ( PROGRESS_STYLE == ProgressDialog.STYLE_HORIZONTAL ) {
							mProgress = new ProgressDialog(mActivity);
							mProgress.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
							if ( progressIcon!=null )
								mProgress.setIcon(progressIcon);
							else
								mProgress.setIcon(R.drawable.cr3_logo);
							mProgress.setMax(10000);
							mProgress.setCancelable(false);
							mProgress.setProgress(mainProgress);
							mProgress.setTitle(mActivity.getResources().getString(R.string.progress_please_wait));
							mProgress.setMessage(msg);
							mProgress.show();
						} else {
							mProgress = ProgressDialog.show(mActivity, ""Please Wait"", msg);
							mProgress.setCancelable(false);
							mProgress.setProgress(mainProgress);
						}
						progressShown = true;
					} else {
						mProgress.setProgress(mainProgress);
						mProgress.setMessage(msg);
						if ( !mProgress.isShowing() ) {
							mProgress.show();
							progressShown = true;
						}
					}
				}
			});
		}
	}
	
	public void hideProgress()
	{
		final int progressId = ++nextProgressId;
		Log.v(""cr3"", ""hideProgress() - is called : "" + Thread.currentThread().getName());
		//Log.v(""cr3"", ""hideProgress() is called"");
		mBackgroundThread.executeGUI( new Runnable() {
			public void run() {
				// hide progress
				Log.v(""cr3"", ""hideProgress() - in GUI thread"");
				if ( progressId!= nextProgressId ) {
					Log.v(""cr3"", ""hideProgress() - skipping duplicate progress event"");
					return;
				}
				if ( mProgress!=null ) {
//					if ( mProgress.isShowing() )
//						mProgress.hide();
					progressShown = false;
					progressIcon = null;
					mProgress.dismiss();
					mProgress = null;
					Log.v(""cr3"", ""hideProgress() - in GUI thread, finished"");
				}
			}
		});
	}
	
	public boolean isProgressShown()
	{
		return progressShown;
	}
	
	public String loadFileUtf8( File file )
	{
		try {
			InputStream is = new FileInputStream(file);
			return loadResourceUtf8(is);
		} catch ( Exception e ) {
			Log.e(""cr3"", ""cannot load resource from file "" + file);
			return null;
		}
	}

	public String loadResourceUtf8( int id )
	{
		try {
			InputStream is = this.mActivity.getResources().openRawResource( id );
			return loadResourceUtf8(is);
		} catch ( Exception e ) {
			Log.e(""cr3"", ""cannot load resource "" + id);
			return null;
		}
	}
	
	public String loadResourceUtf8( InputStream is )
	{
		try {
			int available = is.available();
			if ( available<=0 )
				return null;
			byte buf[] = new byte[available];
			if ( is.read(buf)!=available )
				throw new IOException(""Resource not read fully"");
			is.close();
			String utf8 = new String(buf, 0, available, ""UTF8"");
			return utf8;
		} catch ( Exception e ) {
			Log.e(""cr3"", ""cannot load resource"");
			return null;
		}
	}
	
	public byte[] loadResourceBytes( int id )
	{
		try {
			InputStream is = this.mActivity.getResources().openRawResource( id );
			return loadResourceBytes(is);
		} catch ( Exception e ) {
			Log.e(""cr3"", ""cannot load resource"");
			return null;
		}
	}
	
	public static byte[] loadResourceBytes( File f )
	{
		if ( f==null || !f.isFile() || !f.exists() )
			return null;
		FileInputStream is = null;
		try {
			is = new FileInputStream(f);
			byte[] res = loadResourceBytes( is );
			return res;
		} catch ( IOException e ) {
			Log.e(""cr3"", ""Cannot open file "" + f);
		}
		return null;
	}
	public static byte[] loadResourceBytes( InputStream is )
	{
		try {
			int available = is.available();
			if ( available<=0 )
				return null;
			byte buf[] = new byte[available];
			if ( is.read(buf)!=available )
				throw new IOException(""Resource not read fully"");
			is.close();
			return buf;
		} catch ( Exception e ) {
			Log.e(""cr3"", ""cannot load resource"");
			return null;
		}
	}
	
	/**
	 * Initialize CoolReader Engine
	 * @param fontList is array of .ttf font pathnames to load
	 */
	public Engine( Activity activity, BackgroundThread backgroundThread )
	{
		this.mActivity = activity;
		this.mBackgroundThread = backgroundThread;
		//this.mMainView = mainView;
		Log.i(""cr3"", ""Engine() : scheduling init task"");
		mBackgroundThread.executeBackground( new Runnable() {
			public void run()
			{
				try {
					Log.i(""cr3"", ""Engine() : running init() in engine thread"");
					init();
//					android.view.ViewRoot.getRunQueue().post(new Runnable() {
//						public void run() {
//							
//						}
//					});
				} catch ( final Exception e ) {
					Log.e(""cr3"", ""Exception while initializing Engine"", e);
//					handler.post(new Runnable() {
//						public void run() {
//							// TODO: fatal error
//						}
//					});
				}
			}
		});			
	}

	private native boolean initInternal( String[] fontList );
	private native void uninitInternal();
	private native String[] getFontFaceListInternal();
	private native String[] getArchiveItemsInternal( String arcName ); // pairs: pathname, size
	private native boolean setCacheDirectoryInternal( String dir, int size  );
    private native boolean scanBookPropertiesInternal( FileInfo info );
    private static final int HYPH_NONE = 0; 
    private static final int HYPH_ALGO = 1; 
    private static final int HYPH_DICT = 2; 
    private native boolean setHyphenationMethod( int type, byte[] dictData );
    
    public ArrayList<ZipEntry> getArchiveItems( String zipFileName )
    {
    	final int itemsPerEntry = 2;
    	String[] in = getArchiveItemsInternal( zipFileName );
    	ArrayList<ZipEntry> list = new ArrayList<ZipEntry>();
    	for ( int i=0; i<=in.length-itemsPerEntry; i+=itemsPerEntry ) {
    		ZipEntry e = new ZipEntry(in[i]);
    		e.setSize(Integer.valueOf(in[i+1])); 
    		e.setCompressedSize(Integer.valueOf(in[i+1])); 
    		list.add(e);
    	}
    	return list;
    }
    
    public enum HyphDict {
    	NONE(HYPH_NONE, 0, ""[None]""),
    	ALGORITHM(HYPH_ALGO,0, ""[Algorythmic]""),
    	RUSSIAN(HYPH_DICT,R.raw.russian_enus_hyphen, ""Russian""),
    	ENGLISH(HYPH_DICT,R.raw.english_us_hyphen, ""English US""),
    	GERMAN(HYPH_DICT,R.raw.german_hyphen, ""German""),
    	UKRAINIAN(HYPH_DICT,R.raw.ukrain_hyphen, ""Ukrainian""),
    	SPANISH(HYPH_DICT,R.raw.spanish_hyphen, ""Spanish""),
    	FRENCH(HYPH_DICT,R.raw.french_hyphen, ""French""),
    	BULGARIAN(HYPH_DICT,R.raw.bulgarian_hyphen, ""Bulgarian""),
    	;
    	public final int type;
    	public final int resource;
    	public final String name;
    	private HyphDict( int type, int resource, String name ) {
    		this.type = type;
    		this.resource = resource;
    		this.name = name;
    	}
    	public static HyphDict byCode( String code )
    	{
    		for ( HyphDict dict : values() )
    			if ( dict.toString().equals(code) )
    				return dict;
    		return NONE;
    	}
    };
    
    private HyphDict currentHyphDict = HyphDict.NONE;
    public boolean setHyphenationDictionary( final HyphDict dict )
    {
		Log.i(""cr3"", ""setHyphenationDictionary( "" + dict + "" ) is called"");
    	if ( currentHyphDict==dict )
    		return false;
    	currentHyphDict = dict;
    	//byte[] image = loadResourceBytes(R.drawable.tx_old_book);
    	BackgroundThread.backgroundExecutor.execute( new Runnable() {
    		public void run() {
				byte[] data = null;
				if ( dict.type==HYPH_DICT && dict.resource!=0 ) {
					data = loadResourceBytes( dict.resource );
				}
				Log.i(""cr3"", ""Setting engine's hyphenation dictionary to "" + dict);
				setHyphenationMethod(dict.type, data);
    		}
    	});
    	return true;
    }
    
    public boolean scanBookProperties(FileInfo info)
    {
		if ( !initialized )
			throw new IllegalStateException(""CREngine is not initialized"");
    	return scanBookPropertiesInternal( info );
    }
	
	public String[] getFontFaceList()
	{
		if ( !initialized )
			throw new IllegalStateException(""CREngine is not initialized"");
		return getFontFaceListInternal();
	}
	
	final int CACHE_DIR_SIZE = 32000000;
	
	private String createCacheDir( File baseDir, String subDir )
	{
		String cacheDirName = null;
		if ( baseDir.isDirectory() ) {
			if ( baseDir.canWrite() ) {
				if ( subDir!=null ) {
					baseDir = new File(baseDir, subDir);
					baseDir.mkdir();
				}
				if ( baseDir.exists() && baseDir.canWrite() ) {
					File cacheDir = new File(baseDir, "".cache"");
					if ( cacheDir.exists() || cacheDir.mkdirs() ) {
						if ( cacheDir.canWrite() ) {
							cacheDirName = cacheDir.getAbsolutePath();
						}
					}
				}
			} else {
				Log.i(""cr3"", baseDir.toString() + "" is read only"");
			}
		} else {
			Log.i(""cr3"", baseDir.toString() + "" is not found"");
		}
		return cacheDirName;
	}
	
	private void initCacheDirectory()
	{
		String cacheDirName = null;
		// SD card
		cacheDirName = createCacheDir( Environment.getExternalStorageDirectory(), ""Books"" );
		// internal SD card on Nook
		if ( cacheDirName==null )
			cacheDirName = createCacheDir( new File(""/system/media/sdcard""), ""Books"" );
		// internal flash
		if ( cacheDirName==null ) {
			File cacheDir = mActivity.getCacheDir();
			if ( !cacheDir.isDirectory() )
				cacheDir.mkdir();
			//File cacheDir = mActivity.getDir(""cache"", Context.MODE_PRIVATE);
			if ( cacheDir.isDirectory() && cacheDir.canWrite() )
				cacheDirName = cacheDir.getAbsolutePath();
		}
		// set cache directory for engine
		if ( cacheDirName!=null ) {
			Log.i(""cr3"", cacheDirName + "" will be used for cache, maxCacheSize="" + CACHE_DIR_SIZE);
			setCacheDirectoryInternal(cacheDirName, CACHE_DIR_SIZE);
		}
	}
	
	private void init() throws IOException
	{
		if ( initialized )
			throw new IllegalStateException(""Already initialized"");
    	installLibrary();
    	String[] fonts = findFonts();
		if ( !initInternal( fonts ) )
			throw new IOException(""Cannot initialize CREngine JNI"");
		// Initialization of cache directory
		initCacheDirectory();
		initialized = true;
	}
	
//	public void waitTasksCompletion()
//	{
//        Log.i(""cr3"", ""waiting for engine tasks completion"");
//		try {
//			mExecutor.awaitTermination(0, TimeUnit.SECONDS);
//		} catch (InterruptedException e) {
//			// ignore
//		}
//	}
	
	/**
	 * Uninitialize engine.
	 */
	public void uninit()
	{
		Log.i(""cr3"", ""Engine.uninit() is called"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			public void run() {
				Log.i(""cr3"", ""Engine.uninit() : in background thread"");
				if ( initialized ) {
					uninitInternal();
					initialized = false;
				}
			}
		});
		//TODO:
		//waitTasksCompletion();
	}
	
	protected void finalize() throws Throwable
	{
		Log.i(""cr3"", ""Engine.finalize() is called"");
//		if ( initialized ) {
//			//uninitInternal();
//			initialized = false;
//		}
	}
	
	static private boolean initialized = false;

	private String[] findFonts()
	{
		ArrayList<File> dirs = new ArrayList<File>(); 
		File[] dataDirs = getDataDirectories(""fonts"", false, false);
		for ( File dir : dataDirs )
			dirs.add(dir);
		File[] rootDirs = getStorageDirectories(false);
		for ( File dir : rootDirs )
			dirs.add(new File(dir, ""fonts"") );
		dirs.add(new File( Environment.getRootDirectory(), ""fonts""));
		ArrayList<String> fontPaths = new ArrayList<String>(); 
		for ( File fontDir : dirs ) {
			if ( fontDir.isDirectory() ) {
				Log.v(""cr3"", ""Scanning directory "" + fontDir.getAbsolutePath() + "" for font files"");
				// get font names
				String[] fileList = fontDir.list(
						new FilenameFilter() { 
							public boolean  accept(File  dir, String  filename)
							{
								return filename.toLowerCase().endsWith("".ttf"") && !filename.endsWith(""Fallback.ttf"");
							}
						});
				// append path
				for ( int i=0; i<fileList.length; i++ ) {
					String pathName = new File(fontDir, fileList[i]).getAbsolutePath();
					fontPaths.add( pathName );
					Log.v(""cr3"", ""found font: "" + pathName);
				}
			}
		}
		return fontPaths.toArray(new String[] {});
	}
	
	private boolean force_install_library = false;
	private void installLibrary()
	{
		try {
			if ( force_install_library )
				throw new Exception(""forcing install"");
			// try loading library w/o manual installation
			Log.i(""cr3"", ""trying to load library cr3engine w/o installation"");
			System.loadLibrary(""cr3engine"");
			Log.i(""cr3"", ""cr3engine loaded successfully"");
		} catch ( Exception ee ) {
			Log.i(""cr3"", ""cr3engine not found using standard paths, will install manually"");
			File sopath = mActivity.getDir(""libs"", Context.MODE_PRIVATE);
			File soname = new File(sopath, ""libcr3engine.so"");
			try {
				sopath.mkdirs();
		    	File zip = new File(mActivity.getPackageCodePath());
		    	ZipFile zipfile = new ZipFile(zip);
		    	ZipEntry zipentry = zipfile.getEntry(""lib/armeabi/libcr3engine.so"");
		    	if ( !soname.exists() || zipentry.getSize()!=soname.length() ) {
			    	InputStream is = zipfile.getInputStream(zipentry);
					OutputStream os = new FileOutputStream(soname);
			        Log.i(""cr3"", ""Installing JNI library "" + soname.getAbsolutePath());
					final int BUF_SIZE = 0x10000;
					byte[] buf = new byte[BUF_SIZE];
					int n;
					while ((n = is.read(buf)) > 0)
					    os.write(buf, 0, n);
			        is.close();
			        os.close();
		    	} else {
			        Log.i(""cr3"", ""JNI library "" + soname.getAbsolutePath() + "" is up to date"");
		    	}
				System.load(soname.getAbsolutePath());
			} catch ( Exception e ) {
		        Log.e(""cr3"", ""cannot install cr3engine library"", e);
			}
		}
	}

	public static final BackgroundTextureInfo NO_TEXTURE = new BackgroundTextureInfo(BackgroundTextureInfo.NO_TEXTURE_ID, ""(SOLID COLOR)"", 0); 
	private static final BackgroundTextureInfo[] internalTextures = {
		NO_TEXTURE,		
		new BackgroundTextureInfo(""bg_paper1"", ""Paper 1"", R.drawable.bg_paper1),		
		new BackgroundTextureInfo(""bg_paper1_dark"", ""Paper 1 (dark)"", R.drawable.bg_paper1_dark),		
		new BackgroundTextureInfo(""tx_wood_dark"", ""Wood (dark)"", R.drawable.tx_wood_dark),		
		new BackgroundTextureInfo(""tx_wood"", ""Wood"", R.drawable.tx_wood),		
		new BackgroundTextureInfo(""tx_wood_dark"", ""Wood (dark)"", R.drawable.tx_wood_dark),		
		new BackgroundTextureInfo(""tx_fabric"", ""Fabric"", R.drawable.tx_fabric),		
		new BackgroundTextureInfo(""tx_fabric_dark"", ""Fabric (dark)"", R.drawable.tx_fabric_dark),		
		new BackgroundTextureInfo(""tx_fabric_indigo_fibre"", ""Fabric fibre"", R.drawable.tx_fabric_indigo_fibre),		
		new BackgroundTextureInfo(""tx_fabric_indigo_fibre_dark"", ""Fabric fibre (dark)"", R.drawable.tx_fabric_indigo_fibre_dark),		
		new BackgroundTextureInfo(""tx_gray_sand"", ""Gray sand"", R.drawable.tx_gray_sand),		
		new BackgroundTextureInfo(""tx_gray_sand_dark"", ""Gray sand (dark)"", R.drawable.tx_gray_sand_dark),		
		new BackgroundTextureInfo(""tx_green_wall"", ""Green wall"", R.drawable.tx_green_wall),		
		new BackgroundTextureInfo(""tx_green_wall_dark"", ""Green wall (dark)"", R.drawable.tx_green_wall_dark),		
		new BackgroundTextureInfo(""tx_metal_red_light"", ""Metall red"", R.drawable.tx_metal_red_light),		
		new BackgroundTextureInfo(""tx_metal_red_dark"", ""Metall red (dark)"", R.drawable.tx_metal_red_dark),		
		new BackgroundTextureInfo(""tx_metall_copper"", ""Metall copper"", R.drawable.tx_metall_copper),		
		new BackgroundTextureInfo(""tx_metall_copper_dark"", ""Metall copper (dark)"", R.drawable.tx_metall_copper_dark),		
		new BackgroundTextureInfo(""tx_metall_old_blue"", ""Metall blue"", R.drawable.tx_metall_old_blue),		
		new BackgroundTextureInfo(""tx_metall_old_blue_dark"", ""Metall blue (dark)"", R.drawable.tx_metall_old_blue_dark),		
		new BackgroundTextureInfo(""tx_old_book"", ""Old book"", R.drawable.tx_old_book),		
		new BackgroundTextureInfo(""tx_old_book_dark"", ""Old book (dark)"", R.drawable.tx_old_book_dark),		
		new BackgroundTextureInfo(""tx_old_paper"", ""Old paper"", R.drawable.tx_old_paper),		
		new BackgroundTextureInfo(""tx_old_paper_dark"", ""Old paper (dark)"", R.drawable.tx_old_paper_dark),		
		new BackgroundTextureInfo(""tx_paper"", ""Paper"", R.drawable.tx_paper),		
		new BackgroundTextureInfo(""tx_paper_dark"", ""Paper (dark)"", R.drawable.tx_paper_dark),		
		new BackgroundTextureInfo(""tx_rust"", ""Rust"", R.drawable.tx_rust),		
		new BackgroundTextureInfo(""tx_rust_dark"", ""Rust (dark)"", R.drawable.tx_rust_dark),		
		new BackgroundTextureInfo(""tx_sand"", ""Sand"", R.drawable.tx_sand),		
		new BackgroundTextureInfo(""tx_sand_dark"", ""Sand (dark)"", R.drawable.tx_sand_dark),		
		new BackgroundTextureInfo(""tx_stones"", ""Stones"", R.drawable.tx_stones),		
		new BackgroundTextureInfo(""tx_stones_dark"", ""Stones (dark)"", R.drawable.tx_stones_dark),		
	};
	public static final String DEF_DAY_BACKGROUND_TEXTURE = ""tx_fabric"";
	public static final String DEF_NIGHT_BACKGROUND_TEXTURE = ""tx_metall_old_blue_dark"";
	
	public BackgroundTextureInfo[] getAvailableTextures() {
		ArrayList<BackgroundTextureInfo> list = new ArrayList<BackgroundTextureInfo>(internalTextures.length);
		list.add(NO_TEXTURE);
		findExternalTextures( list );
		for ( int i=1; i<internalTextures.length; i++ )
			list.add(internalTextures[i]);
		return list.toArray( new BackgroundTextureInfo[] {});
	}

	public void findTexturesFromDirectory( File dir, Collection<BackgroundTextureInfo> listToAppend )
	{
		for ( File f : dir.listFiles() ) {
			if ( !f.isDirectory() ) {
				BackgroundTextureInfo item = BackgroundTextureInfo.fromFile(f.getAbsolutePath());
				if (item!=null )
					listToAppend.add(item);
			}
		}
	}
	
	public void findExternalTextures( Collection<BackgroundTextureInfo> listToAppend )
	{
		for ( File d : getStorageDirectories(false) ) {
			File base = new File(d, "".cr3"");
			if ( !base.isDirectory() )
				base = new File(d, ""cr3"");
			if ( !base.isDirectory() )
				continue;
			File subdirTextures = new File(base, ""textures"");
			File subdirBackgrounds = new File(base, ""backgrounds"");
			if ( subdirTextures.isDirectory() )
				findTexturesFromDirectory( subdirTextures, listToAppend );
			if ( subdirBackgrounds.isDirectory() )
				findTexturesFromDirectory( subdirBackgrounds, listToAppend );
		}
	}

	public byte[] getImageData( BackgroundTextureInfo texture ) {
		if ( texture.isNone() )
			return null;
		if ( texture.resourceId!=0 ) {
			byte[] data = loadResourceBytes(texture.resourceId);
			return data;
		} else if (texture.id!=null && texture.id.startsWith(""/"") ) {
			File f = new File(texture.id);
			byte[] data = loadResourceBytes(f);
			return data;
		}
		return null;
	}

	public BackgroundTextureInfo getTextureInfoById( String id ) {
		if ( id==null )
			return NO_TEXTURE;
		if ( id.startsWith(""/"") ) {
			BackgroundTextureInfo item = BackgroundTextureInfo.fromFile(id);
			if ( item!=null )
				return item;
		} else {
			for ( BackgroundTextureInfo item : internalTextures )
				if ( item.id.equals(id))
					return item;
		}
		return NO_TEXTURE;
	}
	
}
",True,5,27,0,0,4,16,5,4,L1
19,org.coolreader.crengine.FindNextDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.view.View.OnTouchListener;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;

public class FindNextDlg {
	PopupWindow mWindow;
	View mAnchor;
	CoolReader mCoolReader;
	ReaderView mReaderView;
	View mPanel;
	final String pattern;
	final boolean caseInsensitive;
	static public void showDialog( CoolReader coolReader, ReaderView readerView, final String pattern, final boolean caseInsensitive )
	{
		FindNextDlg dlg = new FindNextDlg(coolReader, readerView, pattern, caseInsensitive);
		//dlg.mWindow.update(dlg.mAnchor, width, height)
		Log.d(""cr3"", ""popup: "" + dlg.mWindow.getWidth() + ""x"" + dlg.mWindow.getHeight());
		//dlg.update();
		//dlg.showAtLocation(readerView, Gravity.LEFT|Gravity.TOP, readerView.getLeft()+50, readerView.getTop()+50);
		//dlg.showAsDropDown(readerView);
		//dlg.update();
	}
	public FindNextDlg( CoolReader coolReader, ReaderView readerView, final String pattern, final boolean caseInsensitive )
	{
		this.pattern = pattern;
		this.caseInsensitive = caseInsensitive;
		mCoolReader = coolReader;
		mReaderView = readerView;
		mAnchor = readerView;

		View panel = (LayoutInflater.from(coolReader.getApplicationContext()).inflate(R.layout.search_popup, null));
		panel.measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		
		//mReaderView.getS
		
		mWindow = new PopupWindow( mAnchor.getContext() );
		mWindow.setTouchInterceptor(new OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
					mReaderView.clearSelection();
					mWindow.dismiss();
					return true;
				}
				return false;
			}
		});
		//super(panel);
		mPanel = panel;
		mPanel.findViewById(R.id.search_btn_prev).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.findNext(pattern, true, caseInsensitive);
			}
		});
		mPanel.findViewById(R.id.search_btn_next).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.findNext(pattern, false, caseInsensitive);
			}
		});
		mPanel.findViewById(R.id.search_btn_close).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.setFocusable(true);
		mPanel.setOnKeyListener( new OnKeyListener() {

			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ( event.getAction()==KeyEvent.ACTION_UP ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_BACK:
						mReaderView.clearSelection();
						mWindow.dismiss();
						return true;
					case KeyEvent.KEYCODE_DPAD_LEFT:
					case KeyEvent.KEYCODE_DPAD_UP:
						mReaderView.findNext(pattern, true, caseInsensitive);
						return true;
					case KeyEvent.KEYCODE_DPAD_RIGHT:
					case KeyEvent.KEYCODE_DPAD_DOWN:
						mReaderView.findNext(pattern, false, caseInsensitive);
						return true;
					}
				} else if ( event.getAction()==KeyEvent.ACTION_DOWN ) {
						switch ( keyCode ) {
						case KeyEvent.KEYCODE_BACK:
						case KeyEvent.KEYCODE_DPAD_LEFT:
						case KeyEvent.KEYCODE_DPAD_UP:
						case KeyEvent.KEYCODE_DPAD_RIGHT:
						case KeyEvent.KEYCODE_DPAD_DOWN:
							return true;
						}
					}
				if ( keyCode == KeyEvent.KEYCODE_BACK) {
					return true;
				}
				return false;
			}
			
		});

		mWindow.setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss() {
				mReaderView.clearSelection();
			}
		});
		
		mWindow.setBackgroundDrawable(new BitmapDrawable());
		//mWindow.setAnimationStyle(android.R.style.Animation_Toast);
		mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
		mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
//		setWidth(panel.getWidth());
//		setHeight(panel.getHeight());
		
		mWindow.setFocusable(true);
		mWindow.setTouchable(true);
		mWindow.setOutsideTouchable(true);
		mWindow.setContentView(panel);
		
		
		int [] location = new int[2];
		mAnchor.getLocationOnScreen(location);
		//mWindow.update(location[0], location[1], mPanel.getWidth(), mPanel.getHeight() );
		//mWindow.setWidth(mPanel.getWidth());
		//mWindow.setHeight(mPanel.getHeight());

		mWindow.showAtLocation(mAnchor, Gravity.TOP | Gravity.CENTER_HORIZONTAL, location[0], location[1] + mAnchor.getHeight() - mPanel.getHeight());
//		if ( mWindow.isShowing() )
//			mWindow.update(mAnchor, 50, 50);
		//dlg.mWindow.showAsDropDown(dlg.mAnchor);
	
	}
	
}
",False,3,27,0,0,3,22,1,2,L2
20,org.coolreader.crengine.TOCItem.java,"package org.coolreader.crengine;

import java.util.ArrayList;

public class TOCItem {
	private TOCItem mParent;
	private int mLevel;
	private int mIndex;
	private int mGlobalIndex=-1;
	private int mPage;
	private int mPercent;
	private boolean mExpanded;
	private String mName;
	private String mPath;
	private ArrayList<TOCItem> mChildren;
	// create root item
	public TOCItem() {
	}
	// create child item
	public TOCItem addChild() {
		if ( mChildren==null )
			mChildren = new ArrayList<TOCItem>();
		TOCItem item = new TOCItem();
		item.mParent = this;
		item.mIndex = mChildren.size();
		mChildren.add(item);
		return item;
	}
	public int getChildCount(){
		return mChildren!=null ? mChildren.size() : 0;
	}
	public TOCItem getChild( int index)	{
		return mChildren.get(index);
	}
	public TOCItem getParent() {
		return mParent;
	}
	public int getLevel() {
		return mLevel;
	}
	public int getIndex() {
		return mIndex;
	}
	public int getGlobalIndex() {
		return mGlobalIndex;
	}
	public void setGlobalIndex( int index ) {
		mGlobalIndex = index;
	}
	public boolean getExpanded() {
		return mExpanded;
	}
	public void setExpanded( boolean expanded ) {
		mExpanded = expanded;
	}
	public int getPage() {
		return mPage;
	}
	public int getPercent() {
		return mPercent;
	}
	public String getName() {
		return mName;
	}
	public String getPath() {
		return mPath;
	}
	
}
",False,9,16,4,8,0,0,2,0,L2
21,org.coolreader.crengine.FileBrowser.java,"package org.coolreader.crengine;

import java.io.File;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Locale;
import java.util.TimeZone;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.database.DataSetObserver;
import android.graphics.drawable.Drawable;
import android.util.Log;
import android.view.ContextMenu;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnMenuItemClickListener;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Adapter;
import android.widget.AdapterView;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

public class FileBrowser extends ListView {

	Engine mEngine;
	Scanner mScanner;
	CoolReader mActivity;
	LayoutInflater mInflater;
	History mHistory;
	
	public FileBrowser(CoolReader activity, Engine engine, Scanner scanner, History history) {
		super(activity);
		this.mActivity = activity;
		this.mEngine = engine;
		this.mScanner = scanner;
		this.mInflater = LayoutInflater.from(activity);// activity.getLayoutInflater();
		this.mHistory = history;
        setFocusable(true);
        setFocusableInTouchMode(true);
        setLongClickable(true);
        //registerForContextMenu(this);
        //final FileBrowser _this = this;
        setOnItemLongClickListener(new OnItemLongClickListener() {

			@Override
			public boolean onItemLongClick(AdapterView<?> arg0, View arg1,
					int position, long id) {
				Log.d(""cr3"", ""onItemLongClick(""+position+"")"");
				//return super.performItemClick(view, position, id);
				if ( position==0 && currDirectory.parent!=null ) {
					showParentDirectory();
					return true;
				}
				FileInfo item = (FileInfo) getAdapter().getItem(position);
				if ( item==null )
					return false;
				if ( item.isDirectory ) {
					showDirectory(item, null);
					return true;
				}
				//openContextMenu(_this);
				//mActivity.loadDocument(item);
				selectedItem = item;
				showContextMenu();
				return true;
			}
		});
		setChoiceMode(CHOICE_MODE_SINGLE);
		showDirectory( null, null );
	}
	
	FileInfo selectedItem = null;
	
	public boolean onContextItemSelected(MenuItem item) {
		
		if ( selectedItem==null || selectedItem.isDirectory )
			return false;
			
		switch (item.getItemId()) {
		case R.id.book_open:
			Log.d(""cr3"", ""book_open menu item selected"");
			mActivity.loadDocument(selectedItem);
			return true;
		case R.id.book_sort_order:
			mActivity.showToast(""Sorry, sort order selection is not yet implemented"");
			return true;
		case R.id.book_recent_books:
			showRecentBooks();
			return true;
		case R.id.book_root:
			showRootDirectory();
			return true;
		case R.id.book_back_to_reading:
			if ( mActivity.isBookOpened() )
				mActivity.showReader();
			else
				mActivity.showToast(""No book opened"");
			return true;
		case R.id.book_delete:
			Log.d(""cr3"", ""book_delete menu item selected"");
			mActivity.getReaderView().closeIfOpened(selectedItem);
			if ( selectedItem.deleteFile() ) {
				mHistory.removeBookInfo(selectedItem, true, true);
			}
			showDirectory(currDirectory, null);
			return true;
		case R.id.book_recent_goto:
			Log.d(""cr3"", ""book_recent_goto menu item selected"");
			showDirectory(selectedItem, selectedItem);
			return true;
		case R.id.book_recent_remove:
			Log.d(""cr3"", ""book_recent_remove menu item selected"");
			mActivity.getHistory().removeBookInfo(selectedItem, true, false);
			showRecentBooks();
			return true;
		}
		return false;
	}
	
	@Override
	public void createContextMenu(ContextMenu menu) {
		Log.d(""cr3"", ""createContextMenu()"");
		menu.clear();
	    MenuInflater inflater = mActivity.getMenuInflater();
	    if ( isRecentDir() ) {
		    inflater.inflate(R.menu.cr3_file_browser_recent_context_menu, menu);
		    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_recent_book));
	    } else if (selectedItem!=null && selectedItem.isDirectory) {
		    inflater.inflate(R.menu.cr3_file_browser_folder_context_menu, menu);
		    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_book));
	    } else {
		    inflater.inflate(R.menu.cr3_file_browser_context_menu, menu);
		    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_book));
	    }
	    for ( int i=0; i<menu.size(); i++ ) {
	    	menu.getItem(i).setOnMenuItemClickListener(new OnMenuItemClickListener() {
				public boolean onMenuItemClick(MenuItem item) {
					onContextItemSelected(item);
					return true;
				}
			});
	    }
	    return;
	}



	@Override
	public boolean performItemClick(View view, int position, long id) {
		Log.d(""cr3"", ""performItemClick(""+position+"")"");
		//return super.performItemClick(view, position, id);
		if ( position==0 && currDirectory.parent!=null ) {
			showParentDirectory();
			return true;
		}
		FileInfo item = (FileInfo) getAdapter().getItem(position);
		if ( item==null )
			return false;
		if ( item.isDirectory ) {
			showDirectory(item, null);
			return true;
		}
		mActivity.loadDocument(item);
		return true;
	}

	protected void showParentDirectory()
	{
		if ( currDirectory.parent!=null ) {
			showDirectory(currDirectory.parent, currDirectory);
		}
	}
	
	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if ( keyCode==KeyEvent.KEYCODE_BACK && mActivity.isBookOpened() ) {
			if ( isRootDir() ) {
				if ( mActivity.isBookOpened() ) {
					mActivity.showReader();
					return true;
				} else
					return super.onKeyDown(keyCode, event);
			}
			showParentDirectory();
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}

	boolean mInitStarted = false;
	boolean mInitialized = false;
	public void init()
	{
		if ( mInitStarted )
			return;
		Log.e(""cr3"", ""FileBrowser.init() called"");
		mInitStarted = true;
		//mEngine.showProgress(1000, R.string.progress_scanning);
		execute( new Task() {
			public void work() {
				mHistory.loadFromDB(mScanner, 100);
			}
			public void done() {
				Log.e(""cr3"", ""Directory scan is finished. "" + mScanner.mFileList.size() + "" files found"" + "", root item count is "" + mScanner.mRoot.itemCount());
				mInitialized = true;
				//mEngine.hideProgress();
				//mEngine.hideProgress();
				showDirectory( mScanner.mRoot, null );
				setSelection(0);
			}
			public void fail(Exception e )
			{
				//mEngine.showProgress(9000, ""Scan is failed"");
				//mEngine.hideProgress();
				mActivity.showToast(""Scan is failed"");
				Log.e(""cr3"", ""Exception while scanning directories"", e);
			}
		});
	}
	
	@Override
	public void setSelection(int position) {
		super.setSelection(position);
	}
	
	public static String formatAuthors( String authors ) {
		if ( authors==null || authors.length()==0 )
			return null;
		String[] list = authors.split(""\\|"");
		StringBuilder buf = new StringBuilder(authors.length());
		for ( String a : list ) {
			if ( buf.length()>0 )
				buf.append("", "");
			String[] items = a.split("" "");
			if ( items.length==3 && items[1]!=null && items[1].length()>=1 )
				buf.append(items[0] + "" "" + items[1].charAt(0) + "". "" + items[2]);
			else
				buf.append(a);
		}
		return buf.toString();
	}
	
	public static String formatSize( int size )
	{
		if ( size<10000 )
			return String.valueOf(size);
		else if ( size<1000000 )
			return String.valueOf(size/1000) + ""K"";
		else if ( size<10000000 )
			return String.valueOf(size/1000000) + ""."" + String.valueOf(size%1000000/100000) + ""M"";
		else
			return String.valueOf(size/1000000) + ""M"";
	}

	public static String formatSeries( String name, int number )
	{
		if ( name==null || name.length()==0 )
			return null;
		if ( number>0 )
			return ""#"" + number + "" "" + name;
		else
			return name;
	}
	
	static private SimpleDateFormat dateFormat = new SimpleDateFormat(""dd.MM.yy"", Locale.getDefault());
	static private SimpleDateFormat timeFormat = new SimpleDateFormat(""HH:mm"", Locale.getDefault());
	public static String formatDate( long timeStamp )
	{
		if ( timeStamp<5000*60*60*24*1000 )
			return """";
		TimeZone tz = java.util.TimeZone.getDefault();
		Calendar now = Calendar.getInstance(tz);
		Calendar c = Calendar.getInstance(tz);
		c.setTimeInMillis(timeStamp);
		if ( c.get(Calendar.YEAR)<1980 )
			return """";
		if ( c.get(Calendar.YEAR)==now.get(Calendar.YEAR)
				&& c.get(Calendar.MONTH)==now.get(Calendar.MONTH)
				&& c.get(Calendar.DAY_OF_MONTH)==now.get(Calendar.DAY_OF_MONTH)) {
			timeFormat.setTimeZone(tz);
			return timeFormat.format(c.getTime());
		} else {
			dateFormat.setTimeZone(tz);
			return dateFormat.format(c.getTime());
		}
	}

	public static String formatPercent( int percent )
	{
		if ( percent<=0 )
			return null;
		return String.valueOf(percent/100) + ""."" + String.valueOf(percent/10%10) + ""%"";
	}

	private FileInfo currDirectory;

	public boolean isRootDir()
	{
		return currDirectory == mScanner.getRoot();
	}

	public boolean isRecentDir()
	{
		return currDirectory!=null && currDirectory.isRecentDir();
	}

	public void showRecentBooks()
	{
		showDirectory(null, null);
	}

	public void showLastDirectory()
	{
		if ( currDirectory==null || currDirectory==mScanner.getRoot() )
			showRecentBooks();
		else
			showDirectory(currDirectory, null);
	}

	public void showRootDirectory()
	{
		showDirectory(mScanner.getRoot(), null);
	}

	public void showDirectory( FileInfo fileOrDir, FileInfo itemToSelect )
	{
		if ( fileOrDir==null && mScanner.getRoot()!=null && mScanner.getRoot().dirCount()>0 ) {
			if ( mScanner.getRoot().getDir(0).fileCount()>0 ) {
				fileOrDir = mScanner.getRoot().getDir(0);
				itemToSelect = mScanner.getRoot().getDir(0).getFile(0);
			} else {
				fileOrDir = mScanner.getRoot();
				itemToSelect = mScanner.getRoot().dirCount()>1 ? mScanner.getRoot().getDir(1) : null;
			}
		}
		final FileInfo file = fileOrDir==null || fileOrDir.isDirectory ? itemToSelect : fileOrDir;
		final FileInfo dir = fileOrDir!=null && !fileOrDir.isDirectory ? mScanner.findParent(file, mScanner.getRoot()) : fileOrDir;
		if ( dir!=null ) {
			mScanner.scanDirectory(dir, new Runnable() {
				public void run() {
					if ( !dir.isRootDir() && !dir.isRecentDir() )
						dir.sort(FileInfo.DEF_SORT_ORDER);
					showDirectoryInternal(dir, file);
				}
			});
		} else
			showDirectoryInternal(dir, file);
	}

	private void showDirectoryInternal( final FileInfo dir, final FileInfo file )
	{
		currDirectory = dir;
		if ( dir!=null )
			Log.i(""cr3"", ""Showing directory "" + dir);
		this.setAdapter(new ListAdapter() {

			public boolean areAllItemsEnabled() {
				return true;
			}

			public boolean isEnabled(int arg0) {
				return true;
			}

			public int getCount() {
				if ( dir==null )
					return 0;
				return dir.fileCount() + dir.dirCount() + (dir.parent!=null ? 1 : 0);
			}

			public Object getItem(int position) {
				if ( dir==null )
					return null;
				if ( position<0 )
					return null;
				int start = (dir.parent!=null ? 1 : 0);
				if ( position<start )
					return dir.parent;
				return dir.getItem(position-start);
			}

			public long getItemId(int position) {
				if ( dir==null )
					return 0;
				return position;
			}

			public final int VIEW_TYPE_LEVEL_UP = 0;
			public final int VIEW_TYPE_DIRECTORY = 1;
			public final int VIEW_TYPE_FILE = 2;
			public int getItemViewType(int position) {
				if ( dir==null )
					return 0;
				if ( position<0 )
					return Adapter.IGNORE_ITEM_VIEW_TYPE;
				int start = (dir.parent!=null ? 1 : 0);
				if ( position<start )
					return VIEW_TYPE_LEVEL_UP;
				if ( position<start + dir.dirCount() )
					return VIEW_TYPE_DIRECTORY;
				start += dir.dirCount();
				position -= start;
				if ( position<dir.fileCount() )
					return VIEW_TYPE_FILE;
				return Adapter.IGNORE_ITEM_VIEW_TYPE;
			}

			class ViewHolder {
				ImageView image;
				TextView name;
				TextView author;
				TextView series;
				TextView field1;
				TextView field2;
				TextView field3;
				void setText( TextView view, String text )
				{
					if ( view==null )
						return;
					if ( text!=null && text.length()>0 ) {
						view.setText(text);
						view.setVisibility(VISIBLE);
					} else {
						view.setText(null);
						view.setVisibility(INVISIBLE);
					}
				}
				void setItem(FileInfo item, FileInfo parentItem)
				{
					if ( item==null ) {
						image.setImageResource(R.drawable.cr3_browser_back);
						String thisDir = """";
						if ( parentItem!=null ) {
							if ( parentItem.pathname.startsWith(""@"") )
								thisDir = ""/"" + parentItem.filename;
//							else if ( parentItem.isArchive )
//								thisDir = parentItem.arcname;
							else
								thisDir = parentItem.pathname;
							//parentDir = parentItem.path;
						}
						name.setText(thisDir);
						return;
					}
					if ( item.isDirectory ) {
						if ( item.isRecentDir() )
							image.setImageResource(R.drawable.cr3_browser_folder_recent);
						else if ( item.isArchive )
							image.setImageResource(R.drawable.cr3_browser_folder_zip);
						else
							image.setImageResource(R.drawable.cr3_browser_folder);
						setText(name, item.filename);

						setText(field1, ""books: "" + String.valueOf(item.fileCount()));
						setText(field2, ""folders: "" + String.valueOf(item.dirCount()));
					} else {
						if ( image!=null ) {
							Drawable drawable = null;
							if ( item.id!=null )
								drawable = mHistory.getBookCoverpageImage(null, item.id);
							if ( drawable!=null ) {
								image.setImageDrawable(drawable);
							} else {
								image.setImageResource(item.format.getIconResourceId());
							}
						}
						setText( author, formatAuthors(item.authors) );
						String seriesName = formatSeries(item.series, item.seriesNumber);
						String title = item.title;
						String filename1 = item.filename;
						String filename2 = item.isArchive /*&& !item.isDirectory */
								? new File(item.arcname).getName() : null;
						if ( title==null || title.length()==0 ) {
							title = filename1;
							if (seriesName==null) 
								seriesName = filename2;
						} else if (seriesName==null) 
							seriesName = filename1;
						setText( name, title );
						setText( series, seriesName );

//						field1.setVisibility(VISIBLE);
//						field2.setVisibility(VISIBLE);
//						field3.setVisibility(VISIBLE);
						field1.setText(formatSize(item.size));
						Bookmark pos = mHistory.getLastPos(item);
						field2.setText(formatDate(pos!=null ? pos.getTimeStamp() : item.createTime));
						field3.setText(pos!=null ? formatPercent(pos.getPercent()) : null);
						
					}
				}
			}
			
			public View getView(int position, View convertView, ViewGroup parent) {
				if ( dir==null )
					return null;
				View view;
				ViewHolder holder;
				if ( convertView==null ) {
					int vt = getItemViewType(position);
					if ( vt==VIEW_TYPE_LEVEL_UP )
						view = mInflater.inflate(R.layout.browser_item_parent_dir, null);
					else if ( vt==VIEW_TYPE_DIRECTORY )
						view = mInflater.inflate(R.layout.browser_item_folder, null);
					else
						view = mInflater.inflate(R.layout.browser_item_book, null);
					holder = new ViewHolder();
					holder.image = (ImageView)view.findViewById(R.id.book_icon);
					holder.name = (TextView)view.findViewById(R.id.book_name);
					holder.author = (TextView)view.findViewById(R.id.book_author);
					holder.series = (TextView)view.findViewById(R.id.book_series);
					holder.field1 = (TextView)view.findViewById(R.id.browser_item_field1);
					holder.field2 = (TextView)view.findViewById(R.id.browser_item_field2);
					holder.field3 = (TextView)view.findViewById(R.id.browser_item_field3);
					view.setTag(holder);
				} else {
					view = convertView;
					holder = (ViewHolder)view.getTag();
				}
				int type = getItemViewType(position);
				FileInfo item = (FileInfo)getItem(position);
				FileInfo parentItem = null;//item!=null ? item.parent : null;
				if ( type == VIEW_TYPE_LEVEL_UP ) {
					item = null;
					parentItem = currDirectory;
				}
				holder.setItem(item, parentItem);
				return view;
			}

			public int getViewTypeCount() {
				if ( dir==null )
					return 1;
				return 3;
			}

			public boolean hasStableIds() {
				return true;
			}

			public boolean isEmpty() {
				if ( dir==null )
					return true;
				return mScanner.mFileList.size()==0;
			}

			private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
			
			public void registerDataSetObserver(DataSetObserver observer) {
				observers.add(observer);
			}

			public void unregisterDataSetObserver(DataSetObserver observer) {
				observers.remove(observer);
			}
			
		});
		int index = dir!=null ? dir.getItemIndex(file) : -1;
		if ( dir!=null && !dir.isRootDir() )
			index++;
		setSelection(index);
		setChoiceMode(CHOICE_MODE_SINGLE);
		invalidate();
	}

	private void execute( Engine.EngineTask task )
    {
    	mEngine.execute(task);
    }

    private abstract class Task implements Engine.EngineTask {
    	
		public void done() {
			// override to do something useful
		}

		public void fail(Exception e) {
			// do nothing, just log exception
			// override to do custom action
			Log.e(""cr3"", ""Task "" + this.getClass().getSimpleName() + "" is failed with exception "" + e.getMessage(), e);
		}
    }
    
}
",True,23,27,0,0,3,17,2,8,L1
22,org.coolreader.crengine.CRDB.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;

import android.database.Cursor;
import android.database.DatabaseUtils;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

public class CRDB {
	static final boolean DROP_TABLES = false; // for debug purposes
	SQLiteDatabase mDB;
	File mDBFile;
	protected boolean open( File dbfile )
	{
		mDB = SQLiteDatabase.openOrCreateDatabase(dbfile, null);
		this.mDBFile = dbfile;
		return true;
	}
	protected void dropTables()
	{
		String[] tableNames = new String[] {
			""book_author"", ""bookmark"", ""book"", ""series"", ""author"", ""folder"", ""coverpage""	
		};
		for ( String name : tableNames )
			mDB.execSQL(""DROP TABLE IF EXISTS "" + name);
	}
	
	private void execSQLIgnoreErrors( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""query failed, ignoring: "" + sql);
			}
		}
	}

	private void execSQL( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""query failed: "" + sql);
				throw e;
			}
		}
	}

	private final static String[] COVERPAGE_SCHEMA = new String[] {
		""CREATE TABLE IF NOT EXISTS coverpage ("" +
		""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
		""imagedata BLOB NULL"" +
		"")""
	};
	
	public final int DB_VERSION = 3;
	protected boolean updateSchema()
	{
		if (DROP_TABLES)
			dropTables();
		execSQL(""CREATE TABLE IF NOT EXISTS author ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
                ""author_name_index ON author (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS series ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
		        ""series_name_index ON series (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS folder ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""folder_name_index ON folder (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS book ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""pathname VARCHAR NOT NULL,"" +
				""folder_fk INTEGER REFERENCES folder (id),"" +
				""filename VARCHAR NOT NULL,"" +
				""arcname VARCHAR,"" +
				""title VARCHAR,"" +
				""series_fk INTEGER REFERENCES series (id),"" +
				""series_number INTEGER,"" +
				""format INTEGER,"" +
				""filesize INTEGER,"" +
				""arcsize INTEGER,"" +
				""create_time INTEGER,"" +
				""last_access_time INTEGER"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_folder_index ON book (folder_fk) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_pathname_index ON book (pathname) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_filename_index ON book (filename) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_title_index ON book (title) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_last_access_time_index ON book (last_access_time) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_title_index ON book (title) "");
		execSQL(""CREATE TABLE IF NOT EXISTS book_author ("" +
				""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
				""author_fk INTEGER NOT NULL REFERENCES author (id),"" +
				""PRIMARY KEY (book_fk, author_fk)"" +
				"")"");
		execSQL(""CREATE UNIQUE INDEX IF NOT EXISTS "" +
				""author_book_index ON book_author (author_fk, book_fk) "");
		execSQL(""CREATE TABLE IF NOT EXISTS bookmark ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
				""type INTEGER NOT NULL DEFAULT 0,"" +
				""percent INTEGER DEFAULT 0,"" +
				""shortcut INTEGER DEFAULT 0,"" +
				""time_stamp INTEGER DEFAULT 0,"" +
				""start_pos VARCHAR NOT NULL,"" +
				""end_pos VARCHAR,"" +
				""title_text VARCHAR,"" +
				""pos_text VARCHAR,"" +
				""comment_text VARCHAR"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
		""bookmark_book_index ON bookmark (book_fk) "");
		execSQL(COVERPAGE_SCHEMA);
		int currentVersion = mDB.getVersion();
		// version 1 updates ====================================================================
		if ( currentVersion<1 )
			execSQLIgnoreErrors(""ALTER TABLE bookmark ADD COLUMN shortcut INTEGER DEFAULT 0"");
		if ( currentVersion<3 )
			execSQLIgnoreErrors(COVERPAGE_SCHEMA);
		// version 2 updates ====================================================================
		// TODO: add more updates here
		// set current version
		if ( currentVersion<DB_VERSION )
			mDB.setVersion(DB_VERSION);
		return true;
	}
	
	public CRDB( File dbfile )
	{
		open(dbfile);
		updateSchema();
		dumpStatistics();
	}
	
	public boolean findByPathname( FileInfo fileInfo )
	{
		return findBy( fileInfo, ""pathname"", fileInfo.getPathName());
	}

	public boolean findById( FileInfo fileInfo )
	{
		return findBy( fileInfo, ""b.id"", fileInfo.id);
	}

	private static final String READ_BOOKMARK_SQL = 
		""SELECT "" +
		""id, type, percent, shortcut, time_stamp, "" + 
		""start_pos, end_pos, title_text, pos_text, comment_text "" +
		""FROM bookmark b "";
	private void readBookmarkFromCursor( Bookmark v, Cursor rs )
	{
		int i=0;
		v.setId( rs.getLong(i++) );
		v.setType( (int)rs.getLong(i++) );
		v.setPercent( (int)rs.getLong(i++) );
		v.setShortcut( (int)rs.getLong(i++) );
		v.setTimeStamp( rs.getLong(i++) );
		v.setStartPos( rs.getString(i++) );
		v.setEndPos( rs.getString(i++) );
		v.setTitleText( rs.getString(i++) );
		v.setPosText( rs.getString(i++) );
		v.setCommentText( rs.getString(i++) );
		v.setModified(false);
	}
	synchronized public boolean findBy( Bookmark v, String condition )
	{
		boolean found = false;
		Cursor rs = null;
		try {
			condition = "" WHERE "" + condition;
			rs = mDB.rawQuery(READ_BOOKMARK_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				readBookmarkFromCursor( v, rs );
				found = true;
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	synchronized public boolean load( ArrayList<Bookmark> list, String condition )
	{
		boolean found = false;
		Cursor rs = null;
		try {
			condition = "" WHERE "" + condition;
			rs = mDB.rawQuery(READ_BOOKMARK_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				do {
					Bookmark v = new Bookmark();
					readBookmarkFromCursor( v, rs );
					list.add(v);
					found = true;
				} while ( rs.moveToNext() );
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	private static final String READ_FILEINFO_SQL = 
		""SELECT "" +
		""b.id AS id, pathname,"" +
		""f.name as path, "" +
		""filename, arcname, title, "" +
		""(SELECT GROUP_CONCAT(a.name,'|') FROM author a JOIN book_author ba ON a.id=ba.author_fk WHERE ba.book_fk=b.id) as authors, "" +
		""s.name as series_name, "" +
		""series_number, "" +
		""format, filesize, arcsize, "" +
		""create_time, last_access_time "" +
		""FROM book b "" +
		""LEFT JOIN series s ON s.id=b.series_fk "" +
		""LEFT JOIN folder f ON f.id=b.folder_fk "";
	private void readFileInfoFromCursor( FileInfo fileInfo, Cursor rs )
	{
		int i=0;
		fileInfo.id = rs.getLong(i++);
		String pathName = rs.getString(i++);
		String[] parts = FileInfo.splitArcName(pathName);
		fileInfo.pathname = parts[0];
		fileInfo.path = rs.getString(i++);
		fileInfo.filename = rs.getString(i++);
		fileInfo.arcname = rs.getString(i++);
		fileInfo.title = rs.getString(i++);
		fileInfo.authors = rs.getString(i++);
		fileInfo.series = rs.getString(i++);
		fileInfo.seriesNumber = rs.getInt(i++);
		fileInfo.format = DocumentFormat.byId(rs.getInt(i++));
		fileInfo.size = rs.getInt(i++);
		fileInfo.arcsize = rs.getInt(i++);
		fileInfo.createTime = rs.getInt(i++);
		fileInfo.lastAccessTime = rs.getInt(i++);
		fileInfo.isArchive = fileInfo.arcname!=null; 
	}
	
	
	synchronized public boolean findBy( FileInfo fileInfo, String fieldName, Object fieldValue )
	{
		String condition;
		StringBuilder buf = new StringBuilder("" WHERE "");
		buf.append(fieldName);
		if ( fieldValue==null ) {
			buf.append("" IS NULL "");
		} else {
			buf.append(""="");
			DatabaseUtils.appendValueToSql(buf, fieldValue);
			buf.append("" "");
		}
		condition = buf.toString();
		boolean found = false;
		Cursor rs = null;
		try { 
			rs = mDB.rawQuery(READ_FILEINFO_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				readFileInfoFromCursor( fileInfo, rs );
				found = true;
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}
	
	synchronized public boolean findRecentBooks( ArrayList<FileInfo> list, int maxCount, int limit )
	{
		String sql = READ_FILEINFO_SQL + "" WHERE last_access_time>0 ORDER BY last_access_time DESC LIMIT "" + limit;
		Cursor rs = null;
		boolean found = false;
		try {
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				do {
					FileInfo fileInfo = new FileInfo();
					readFileInfoFromCursor( fileInfo, rs );
					if ( !fileInfo.fileExists() )
						continue;
					list.add(fileInfo);
					found = true;
					if ( list.size()>maxCount )
						break;
				} while (rs.moveToNext());
			}
		} finally {
			rs.close();
		}
		return found;
	}
	
	private Long longQuery( String sql )
	{
		SQLiteStatement stmt = mDB.compileStatement(sql);
		try {
			return stmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found or error
			return null;
		}
	}
	
	public void saveBookCoverpage( long bookId, byte[] data )
	{
		if ( data==null )
			return;
		SQLiteStatement stmt = null;
		try { 
			Long existing = longQuery(""SELECT book_fk FROM coverpage WHERE book_fk="" + bookId);
			if ( existing==null ) {
				stmt = mDB.compileStatement(""INSERT INTO coverpage (book_fk, imagedata) VALUES (""+bookId+"", ?)"");
				stmt.bindBlob(1, data);
				stmt.execute();
				Log.v(""cr3"", ""db: saved "" + data.length + "" bytes of cover page for book "" + bookId);
			}
		} catch ( Exception e ) {
			Log.e(""cr3"", ""Exception while trying to save cover page to DB: "" + e.getMessage() );
		} finally {
			if ( stmt!=null )
				stmt.close();
		}
	}
	public byte[] loadBookCoverpage( long bookId )
	{
		Cursor rs = null;
		try {
			rs = mDB.rawQuery(""SELECT imagedata FROM coverpage WHERE book_fk="" + bookId, null);
			if ( rs.moveToFirst() ) {
				return rs.getBlob(0);
			}
			return null;
		} catch ( SQLException e ) {
			Log.e(""cr3"", ""error while reading coverpage for book "" + bookId + "": "" + e.getMessage());
			return null;
		} finally {
			if ( rs!=null )
				rs.close();
		}
	}
	
	public void dumpStatistics()
	{
		Log.i(""cr3db"", ""DB: "" + longQuery(""SELECT count(*) FROM author"") + "" authors, ""
				 + longQuery(""SELECT count(*) FROM series"") + "" series, ""
				 + longQuery(""SELECT count(*) FROM book"") + "" books, ""
				 + longQuery(""SELECT count(*) FROM bookmark"") + "" bookmarks""
				 + longQuery(""SELECT count(*) FROM folder"") + "" folders""
				 + longQuery(""SELECT count(*) FROM coverpage"") + "" coverpages""
				 );
	}

	private SQLiteStatement seriesStmt;
	private SQLiteStatement seriesSelectStmt;
	private HashMap<String,Long> seriesCache = new HashMap<String,Long>();
	synchronized public Long getSeriesId( String seriesName )
	{
		if ( seriesName==null || seriesName.trim().length()==0 )
			return null;
		Long id = seriesCache.get(seriesName); 
		if ( id!=null )
			return id;
		if ( seriesSelectStmt==null )
			seriesSelectStmt = mDB.compileStatement(""SELECT id FROM series WHERE name=?"");
		try {
			seriesSelectStmt.bindString(1, seriesName);
			return seriesSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( seriesStmt==null )
			seriesStmt = mDB.compileStatement(""INSERT INTO series (id, name) VALUES (NULL,?)"");
		seriesStmt.bindString(1, seriesName);
		id = seriesStmt.executeInsert();
		seriesCache.put( seriesName, id );
		return id;
	}
	
	private SQLiteStatement folderStmt;
	private SQLiteStatement folderSelectStmt;
	private HashMap<String,Long> folderCache = new HashMap<String,Long>();
	synchronized public Long getFolderId( String folderName )
	{
		if ( folderName==null || folderName.trim().length()==0 )
			return null;
		Long id = folderCache.get(folderName); 
		if ( id!=null )
			return id;
		if ( folderSelectStmt==null )
			folderSelectStmt = mDB.compileStatement(""SELECT id FROM folder WHERE name=?"");
		try {
			folderSelectStmt.bindString(1, folderName);
			return folderSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( folderStmt==null )
			folderStmt = mDB.compileStatement(""INSERT INTO folder (id, name) VALUES (NULL,?)"");
		folderStmt.bindString(1, folderName);
		id = folderStmt.executeInsert();
		folderCache.put( folderName, id );
		return id;
	}
	
	private SQLiteStatement authorStmt;
	private SQLiteStatement authorSelectStmt;
	private HashMap<String,Long> authorCache = new HashMap<String,Long>();
	synchronized public Long getAuthorId( String authorName )
	{
		if ( authorName==null || authorName.trim().length()==0 )
			return null;
		Long id = authorCache.get(authorName); 
		if ( id!=null )
			return id;
		if ( authorSelectStmt==null )
			authorSelectStmt = mDB.compileStatement(""SELECT id FROM author WHERE name=?"");
		try {
			authorSelectStmt.bindString(1, authorName);
			return authorSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( authorStmt==null )
			authorStmt = mDB.compileStatement(""INSERT INTO author (id, name) VALUES (NULL,?)"");
		authorStmt.bindString(1, authorName);
		id = authorStmt.executeInsert();
		authorCache.put( authorName, id );
		return id;
	}
	synchronized public Long[] getAuthorIds( String authorNames )
	{
		if ( authorNames==null || authorNames.trim().length()==0 )
			return null;
		String[] names = authorNames.split(""\\|"");
		if ( names==null || names.length==0 )
			return null;
		ArrayList<Long> ids = new ArrayList<Long>(names.length);
		for ( String name : names ) {
			Long id = getAuthorId(name);
			if ( id!=null )
				ids.add(id);
		}
		if ( ids.size()>0 )
			return ids.toArray(new Long[ids.size()]);
		return null;
	}
	
	synchronized public void saveBookAuthors( Long bookId, Long[] authors)
	{
		if ( authors==null || authors.length==0 )
			return;
		String insertQuery = ""INSERT OR IGNORE INTO book_author (book_fk,author_fk) VALUES "";
		for ( Long id : authors ) {
			String sql = insertQuery + ""("" + bookId + "","" + id + "")""; 
			//Log.v(""cr3"", ""executing: "" + sql);
			mDB.execSQL(sql);
		}
	}

	public static boolean eq(String s1, String s2)
	{
		if ( s1!=null )
			return s1.equals(s2);
		return s2==null;
	}
	
	public class QueryHelper {
		String tableName;
		QueryHelper(String tableName)
		{
			this.tableName = tableName;
		}
		ArrayList<String> fields = new ArrayList<String>(); 
		ArrayList<Object> values = new ArrayList<Object>();
		QueryHelper add(String fieldName, int value, int oldValue )
		{
			if ( value!=oldValue ) {
				fields.add(fieldName);
				values.add(Long.valueOf(value));
			}
			return this;
		}
		QueryHelper add(String fieldName, Long value, Long oldValue )
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		QueryHelper add(String fieldName, String value, String oldValue)
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		QueryHelper add(String fieldName, Double value, Double oldValue)
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		Long insert()
		{
			if ( fields.size()==0 )
				return null;
			StringBuilder valueBuf = new StringBuilder();
			try {
				String ignoreOption = """"; //""OR IGNORE "";
				StringBuilder buf = new StringBuilder(""INSERT "" + ignoreOption + "" INTO "");
				buf.append(tableName);
				buf.append("" (id"");
				for ( String field : fields ) {
					buf.append("","");
					buf.append(field);
				}
				buf.append("") VALUES (NULL"");
				for ( String field : fields ) {
					buf.append("","");
					buf.append(""?"");
				}
				buf.append("")"");
				String sql = buf.toString();
				Log.d(""cr3db"", ""going to execute "" + sql);
				SQLiteStatement stmt = null;
				Long id = null;
				try {
					stmt = mDB.compileStatement(sql);
					for ( int i=1; i<=values.size(); i++ ) {
						Object v = values.get(i-1);
						valueBuf.append(v!=null ? v.toString() : ""null"");
						valueBuf.append("","");
						if ( v==null )
							stmt.bindNull(i);
						else if (v instanceof String)
							stmt.bindString(i, (String)v);
						else if (v instanceof Long)
							stmt.bindLong(i, (Long)v);
						else if (v instanceof Double)
							stmt.bindDouble(i, (Double)v);
					}
					id = stmt.executeInsert();
					Log.d(""cr3db"", ""added book, id="" + id + "", query="" + sql);
				} finally {
					if ( stmt!=null )
						stmt.close();
				}
				return id;
			} catch ( Exception e ) {
				Log.e(""cr3db"", ""insert failed: "" + e.getMessage());
				Log.e(""cr3db"", ""values: "" + valueBuf.toString());
				return null;
			}
		}
		boolean update( Long id )
		{
			if ( fields.size()==0 )
				return false;
			StringBuilder buf = new StringBuilder(""UPDATE "");
			buf.append(tableName);
			buf.append("" SET "");
			boolean first = true;
			for ( String field : fields ) {
				if ( !first )
					buf.append("","");
				buf.append(field);
				buf.append(""=?"");
				first = false;
			}
			buf.append("" WHERE id="" + id );
			mDB.execSQL(buf.toString(), values.toArray());
			return true;
		}
		Long fromFormat( DocumentFormat f )
		{
			if ( f==null )
				return null;
			return (long)f.ordinal();
		}
		QueryHelper( FileInfo newValue, FileInfo oldValue )
		{
			this(""book"");
			add(""pathname"", newValue.getPathName(), oldValue.getPathName());
			add(""folder_fk"", getFolderId(newValue.path), getFolderId(oldValue.path));
			add(""filename"", newValue.filename, oldValue.filename);
			add(""arcname"", newValue.arcname, oldValue.arcname);
			add(""title"", newValue.title, oldValue.title);
			add(""series_fk"", getSeriesId(newValue.series), getSeriesId(oldValue.series));
			add(""series_number"", (long)newValue.seriesNumber, (long)oldValue.seriesNumber);
			add(""format"", fromFormat(newValue.format), fromFormat(oldValue.format));
			add(""filesize"", (long)newValue.size, (long)oldValue.size);
			add(""arcsize"", (long)newValue.arcsize, (long)oldValue.arcsize);
			add(""last_access_time"", (long)newValue.lastAccessTime, (long)oldValue.lastAccessTime);
			add(""create_time"", (long)newValue.createTime, (long)oldValue.createTime);
		}
		QueryHelper( Bookmark newValue, Bookmark oldValue, long bookId )
		{
			this(""bookmark"");
			add(""book_fk"", bookId, oldValue.getId()!=null ? bookId : null);
			add(""type"", newValue.getType(), oldValue.getType());
			add(""percent"", newValue.getPercent(), oldValue.getPercent());
			add(""shortcut"", newValue.getShortcut(), oldValue.getShortcut());
			add(""start_pos"", newValue.getStartPos(), oldValue.getStartPos());
			add(""end_pos"", newValue.getEndPos(), oldValue.getEndPos());
			add(""title_text"", newValue.getTitleText(), oldValue.getTitleText());
			add(""pos_text"", newValue.getPosText(), oldValue.getPosText());
			add(""comment_text"", newValue.getCommentText(), oldValue.getCommentText());
			add(""time_stamp"", newValue.getTimeStamp(), oldValue.getTimeStamp());
		}
	}

	/**
	 * @param fileList
	 * @param maxCount
	 * @return
	 */
	public ArrayList<BookInfo> loadRecentBooks( HashMap<String, FileInfo> fileList, int maxCount )
	{
		ArrayList<FileInfo> list = new ArrayList<FileInfo>();
		findRecentBooks( list, maxCount, maxCount*10 );
		ArrayList<BookInfo> res = new ArrayList<BookInfo>(list.size());
		for ( FileInfo file : list ) {
			fileList.put(file.getPathName(), file);
			BookInfo item = new BookInfo( file );
			ArrayList<Bookmark> bookmarks = new ArrayList<Bookmark>(); 
			if ( load( bookmarks, ""book_fk="" + file.id + "" ORDER BY type"" ) ) {
				item.setBookmarks(bookmarks);
			}
			res.add(item);
		}
		return res;
	}

	synchronized public boolean save( BookInfo bookInfo )
	{
		Log.d(""cr3db"", ""saving Book info id="" + bookInfo.getFileInfo().id);
		if ( mDB==null ) {
			Log.e(""cr3db"", ""cannot save book info : DB is closed"");
			return false;
		}
		boolean res = save(bookInfo.getFileInfo());
		for ( int i=0; i<bookInfo.getBookmarkCount(); i++ ) {
			 Bookmark bmk  = bookInfo.getBookmark(i);
			 if (bmk.isModified())
			 	res = save(bmk, bookInfo.getFileInfo().id) || res;
		}
		if ( bookInfo.getLastPosition()!=null && bookInfo.getLastPosition().isModified() )
			res = save(bookInfo.getLastPosition(), bookInfo.getFileInfo().id) || res;
		return res;
	}

	private boolean save( Bookmark v, long bookId )
	{
		if ( !v.isModified() )
			return false;
		Log.d(""cr3db"", ""saving bookmark id="" + v.getId() + "", bookId="" + bookId + "", pos="" + v.getStartPos());
		if ( v.getId()!=null ) {
			// update
			Bookmark oldValue = new Bookmark();
			oldValue.setId(v.getId());
			if ( findBy(oldValue, ""book_fk="" + bookId + "" AND id="" + v.getId()) ) {
				// found, updating
				QueryHelper h = new QueryHelper(v, oldValue, bookId);
				h.update(v.getId());
			} else {
				oldValue = new Bookmark();
				QueryHelper h = new QueryHelper(v, oldValue, bookId);
				v.setId( h.insert() );
			}
		} else {
			Bookmark oldValue = new Bookmark();
			QueryHelper h = new QueryHelper(v, oldValue, bookId);
			v.setId( h.insert() );
		}
		v.setModified(false);
		return true;
	}

	synchronized public void deleteRecentPosition( FileInfo fileInfo )
	{
		if ( fileInfo==null || fileInfo.id==0 )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE book_fk="" + fileInfo.id + "" AND type=0"");
		execSQLIgnoreErrors(""UPDATE book SET last_access_time=0 WHERE id="" + fileInfo.id);
	}
	
	synchronized public void deleteBook( FileInfo fileInfo )
	{
		if ( fileInfo==null || fileInfo.id==0 )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE book_fk="" + fileInfo.id);
		execSQLIgnoreErrors(""DELETE FROM coverpage WHERE book_fk="" + fileInfo.id);
		execSQLIgnoreErrors(""DELETE FROM book WHERE id="" + fileInfo.id);
	}
	
	synchronized public boolean save( FileInfo fileInfo )
	{
		boolean authorsChanged = true;
		if ( fileInfo.id!=null ) {
			// update
			FileInfo oldValue = new FileInfo();
			oldValue.id = fileInfo.id;
			if ( findById(oldValue) ) {
				// found, updating
				QueryHelper h = new QueryHelper(fileInfo, oldValue);
				h.update(fileInfo.id);
				authorsChanged = !eq(fileInfo.authors, oldValue.authors);
			} else {
				oldValue = new FileInfo();
				QueryHelper h = new QueryHelper(fileInfo, oldValue);
				fileInfo.id = h.insert();
			}
		} else {
			FileInfo oldValue = new FileInfo();
			QueryHelper h = new QueryHelper(fileInfo, oldValue);
			fileInfo.id = h.insert();
		}
		fileInfo.setModified(false);
		if ( fileInfo.id!=null ) {
			if ( authorsChanged ) {
				Long[] authorIds = getAuthorIds(fileInfo.authors);
				saveBookAuthors(fileInfo.id, authorIds);
			}
			return true;
		}
		return false;
	}

	public void close()
	{
		Log.i(""cr3db"", ""Closing DB"");
		if ( seriesStmt!=null) {
			seriesStmt.close();
			seriesStmt = null;
		}
		if ( authorStmt!=null) {
			authorStmt.close();
			authorStmt = null;
		}
		if ( seriesSelectStmt!=null) {
			seriesSelectStmt.close();
			seriesSelectStmt = null;
		}
		if ( authorSelectStmt!=null) {
			authorSelectStmt.close();
			authorSelectStmt = null;
		}
		if ( mDB!=null && mDB.isOpen() ) {
			mDB.close();
			mDB = null;
		}
		
	}
}
",True,17,20,3,10,1,4,4,4,L1
23,org.coolreader.crengine.Properties.java,"package org.coolreader.crengine;

import java.util.Map;

public class Properties extends java.util.Properties {
	public Properties()
	{
		super();
	}
	public void setAll(java.util.Properties props)
	{
        for ( Map.Entry<Object, Object> entry : props.entrySet() ) {
    		setProperty((String)entry.getKey(), (String)entry.getValue());
        }
	}
	public Properties(java.util.Properties props)
	{
		setAll(props);
	}
	private static int revBytes( int color )
	{
		return color & 0xFFFFFF;
		//return ((color & 0xFF)<<16)|((color & 0xFF00)<<0)|((color & 0xFF0000)>>16);
	}
	public void setColor( String key, int color )
	{
		color &= 0xFFFFFF;
		color = revBytes(color);
		String value = Integer.toHexString(color);
		while ( value.length()<6 )
			value = ""0"" + value;
		value = ""0x"" + value;
		setProperty(key, value);
	}
	public int getColor( String key, int defColor )
	{
		defColor = revBytes(defColor);
		String value = getProperty(key);
		try {
			if ( value!=null && value.length()>2 && value.startsWith(""0x"") ) {
				int cl = Integer.parseInt(value.substring(2), 16);
				cl = revBytes(cl);
				return cl | 0xFF000000;
			}
		} catch ( Exception e ) {
		}
		return revBytes(defColor) | 0xFF000000;
	}
	public void setInt( String key, int v )
	{
		String value = String.valueOf(v);
		setProperty(key, value);
	}
	public int getInt( String key, int def )
	{
		String value = getProperty(key);
		int res = def;
		try {
			if ( value!=null )
				res = Integer.valueOf(value);
		} catch ( Exception e ) {
		}
		return res;
	}
	public void setBool( String key, boolean value )
	{
		setProperty( key, value ? ""1"" : ""0"" );
	}
	public boolean getBool( String key, boolean defaultValue )
	{
		String value = getProperty(key);
		if ( value==null )
			return defaultValue;
		if ( value.equals(""1"") || value.equals(""true"") || value.equals(""yes"") )
			return true;
		if ( value.equals(""0"") || value.equals(""false"") || value.equals(""no"") )
			return false;
		return defaultValue;
	}
	public void applyDefault( String prop, String defValue )
	{
		if ( getProperty(prop)==null )
			setProperty(prop, defValue);
	}
	
	public static boolean eq(Object obj1, Object obj2)
	{
		if ( obj1==null && obj2==null )
			return true;
		if ( obj1==null || obj2==null )
			return false;
		return obj1.equals(obj2);
	}

	public Properties diff( Properties oldValue )
	{
		Properties res = new Properties();
        for ( Map.Entry<Object, Object> entry : entrySet() ) {
        	if ( !oldValue.containsKey(entry.getKey()) || !eq(entry.getValue(), oldValue.get(entry.getKey()))) {
        		res.setProperty( (String)entry.getKey(), (String)entry.getValue() );
        	}
        }
        return res;
	}
}
",True,16,16,3,9,0,0,4,0,L1
24,org.coolreader.crengine.BackgroundThread.java,"package org.coolreader.crengine;

import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.Executor;

import org.coolreader.crengine.ReaderView.Sync;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.util.Log;
import android.view.View;

/**
 * Allows running tasks either in background thread or in GUI thread.
 */
public class BackgroundThread extends Thread {
	
	private final static Object LOCK = new Object(); 

	private static BackgroundThread instance;
	
	// singleton
	public static BackgroundThread instance()
	{
		if ( instance==null ) {
			synchronized( LOCK ) {
				if ( instance==null )
					instance = new BackgroundThread(); 
			}
		}
		return instance;
	}

	public final static Executor backgroundExecutor = new Executor() {
		public void execute(Runnable task) {
			instance().postBackground(task);
		}
	};
	
	public final static Executor guiExecutor = new Executor() {
		public void execute(Runnable task) {
			instance().postGUI(task);
		}
	};
	
	public final static boolean CHECK_THREAD_CONTEXT = true; 

	/**
	 * Throws exception if not in background thread.
	 */
	public final static void ensureBackground()
	{
		if ( CHECK_THREAD_CONTEXT && !instance().isBackgroundThread() ) {
			Log.e(""cr3"", ""not in background thread"", new Exception(""ensureInBackgroundThread() is failed""));
			throw new RuntimeException(""ensureInBackgroundThread() is failed"");
		}
	}
	
	/**
	 * Throws exception if not in GUI thread.
	 */
	public final static void ensureGUI()
	{
		if ( CHECK_THREAD_CONTEXT && instance().isBackgroundThread() ) {
			Log.e(""cr3"", ""not in GUI thread"", new Exception(""ensureGUI() is failed""));
			throw new RuntimeException(""ensureGUI() is failed"");
		}
	}
	
	// 
	private Handler handler;
	private ArrayList<Runnable> posted = new ArrayList<Runnable>();
	private View guiTarget;
	private ArrayList<Runnable> postedGUI = new ArrayList<Runnable>();

	/**
	 * Set view to post GUI tasks to.
	 * @param guiTarget is view to post GUI tasks to.
	 */
	public void setGUI( View guiTarget ) {
		this.guiTarget = guiTarget;
		if ( guiTarget!=null ) {
			// forward already posted events
			synchronized(postedGUI) {
				Log.d(""cr3"", ""Engine.setGUI: "" + postedGUI.size() + "" posted tasks to copy"");
				for ( Runnable task : postedGUI )
					guiTarget.post( task );
			}
		}
	}

	/**
	 * Create background thread executor.
	 */
	private BackgroundThread() {
		super();
		setName(""BackgroundThread"" + Integer.toHexString(hashCode()));
		start();
	}

	@Override
	public void run() {
		Log.i(""cr3"", ""Entering background thread"");
		Looper.prepare();
		handler = new Handler() {
			public void handleMessage( Message message )
			{
				Log.d(""cr3"", ""message: "" + message);
			}
		};
		Log.i(""cr3"", ""Background thread handler is created"");
		synchronized(posted) {
			for ( Runnable task : posted ) {
				Log.i(""cr3"", ""Copying posted bg task to handler : "" + task);
				handler.post(task);
			}
			posted.clear();
		}
		Looper.loop();
		handler = null;
		Log.i(""cr3"", ""Exiting background thread"");
	}

	private final static boolean USE_LOCK = false;
	private Runnable guard( final Runnable r )
	{
		if ( !USE_LOCK )
			return r;
		return new Runnable() {
			public void run() {
				synchronized (LOCK) {
					r.run();
				}
			}
		};
	}

	/**
	 * Post runnable to be executed in background thread.
	 * @param task is runnable to execute in background thread.
	 */
	public void postBackground( Runnable task )
	{
		if ( mStopped ) {
			Log.i(""cr3"", ""Posting task "" + task + "" to GUI queue since background thread is stopped"");
			postGUI( task );
			return;
		}
		task = guard(task);
		if ( handler==null ) {
			synchronized(posted) {
				Log.i(""cr3"", ""Adding task "" + task + "" to posted list since handler is not yet created"");
				posted.add(task);
			}
		} else {
			handler.post(task);
		}
	}

	/**
	 * Post runnable to be executed in GUI thread
	 * @param task is runnable to execute in GUI thread
	 */
	public void postGUI( Runnable task )
	{
		postGUI(task, 0);
	}

	/**
	 * Post runnable to be executed in GUI thread
	 * @param task is runnable to execute in GUI thread
	 * @param delay is delay before running task, in millis
	 */
	public void postGUI( Runnable task, long delay )
	{
		if ( guiTarget==null ) {
			synchronized( postedGUI ) {
				postedGUI.add(task);
			}
		} else {
			if ( delay>0 )
				guiTarget.postDelayed(task, delay);
			else
				guiTarget.post(task);
		}
	}

	/**
	 * Run task instantly if called from the same thread, or post it through message queue otherwise.
	 * @param task is task to execute
	 */
	public void executeBackground( Runnable task )
	{
		task = guard(task);
		if ( isBackgroundThread() || mStopped )
			task.run(); // run in this thread
		else 
			postBackground(task); // post
	}

	// assume there are only two threads: main GUI and background
	public boolean isGUIThread()
	{
		return !isBackgroundThread();
	}

	public boolean isBackgroundThread()
	{
		return ( Thread.currentThread()==this );
	}

	public void executeGUI( Runnable task )
	{
		//Handler guiHandler = guiTarget.getHandler();
		//if ( guiHandler!=null && guiHandler.getLooper().getThread()==Thread.currentThread() )
		if ( isGUIThread() )
			task.run(); // run in this thread
		else
			postGUI(task);
	}

    public <T> Callable<T> guard( final Callable<T> task )
    {
    	return new Callable<T>() {
    		public T call() throws Exception {
    			return task.call();
    		}
    	};
    }
	
    public <T> T callBackground( final Callable<T> srcTask )
    {
    	final Callable<T> task = guard(srcTask);
    	if ( isBackgroundThread() ) {
    		try {
    			return task.call();
    		} catch ( Exception e ) {
    			return null;
    		}
    	}
    	//Log.d(""cr3"", ""executeSync called"");
    	final Sync<T> sync = new Sync<T>();
    	postBackground( new Runnable() {
    		public void run() {
    			try {
    				sync.set( task.call() );
    			} catch ( Exception e ) {
    				sync.set( null );
    			}
    		}
    	});
    	T res = sync.get();
    	//Log.d(""cr3"", ""executeSync done"");
    	return res;
    }
	
    public <T> T callGUI( final Callable<T> task )
    {
    	if ( isGUIThread() ) {
    		try {
    			return task.call();
    		} catch ( Exception e ) {
    			return null;
    		}
    	}
    	//Log.d(""cr3"", ""executeSync called"");
    	final Sync<T> sync = new Sync<T>();
    	postBackground( new Runnable() {
    		public void run() {
    			try {
    				sync.set( task.call() );
    			} catch ( Exception e ) {
    			}
    		}
    	});
    	T res = sync.get();
    	return res;
    }
	
	private boolean mStopped = false;
	
	public void waitForBackgroundCompletion()
	{
		callBackground(new Callable<Object>() {
			public Object call() {
				return null;
			}
		});
	}
	
//	public void quit()
//	{
//		callBackground(new Callable<Object>() {
//			public Object call() {
//				mStopped = true;
//				Looper.myLooper().quit();
//				return null;
//			}
//		});
//	}
}
",True,7,27,0,0,3,20,3,1,L1
25,org.coolreader.crengine.ReaderView.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.Callable;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.Engine.HyphDict;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.text.ClipboardManager;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

public class ReaderView extends SurfaceView implements android.view.SurfaceHolder.Callback {

    // additional key codes for Nook
    public static final int NOOK_KEY_PREV_LEFT = 96;
    public static final int NOOK_KEY_PREV_RIGHT = 98;
    public static final int NOOK_KEY_NEXT_LEFT = 95;
    public static final int NOOK_KEY_NEXT_RIGHT = 97;    
    public static final int NOOK_KEY_SHIFT_UP = 101;
    public static final int NOOK_KEY_SHIFT_DOWN = 100;
    
    public static final String PROP_PAGE_BACKGROUND_IMAGE       =""background.image"";
    public static final String PROP_PAGE_BACKGROUND_IMAGE_DAY   =""background.image.day"";
    public static final String PROP_PAGE_BACKGROUND_IMAGE_NIGHT =""background.image.night"";
    public static final String PROP_NIGHT_MODE              =""crengine.night.mode"";
    public static final String PROP_FONT_COLOR_DAY          =""font.color.day"";
    public static final String PROP_BACKGROUND_COLOR_DAY    =""background.color.day"";
    public static final String PROP_FONT_COLOR_NIGHT        =""font.color.night"";
    public static final String PROP_BACKGROUND_COLOR_NIGHT  =""background.color.night"";
    public static final String PROP_FONT_COLOR              =""font.color.default"";
    public static final String PROP_BACKGROUND_COLOR        =""background.color.default"";
    public static final String PROP_FONT_ANTIALIASING       =""font.antialiasing.mode"";
    public static final String PROP_FONT_FACE               =""font.face.default"";
    public static final String PROP_FONT_WEIGHT_EMBOLDEN    =""font.face.weight.embolden"";
    public static final String PROP_TXT_OPTION_PREFORMATTED =""crengine.file.txt.preformatted"";
    public static final String PROP_LOG_FILENAME            =""crengine.log.filename"";
    public static final String PROP_LOG_LEVEL               =""crengine.log.level"";
    public static final String PROP_LOG_AUTOFLUSH           =""crengine.log.autoflush"";
    public static final String PROP_FONT_SIZE               =""crengine.font.size"";
    public static final String PROP_STATUS_FONT_COLOR       =""crengine.page.header.font.color"";
    public static final String PROP_STATUS_FONT_COLOR_DAY   =""crengine.page.header.font.color.day"";
    public static final String PROP_STATUS_FONT_COLOR_NIGHT =""crengine.page.header.font.color.night"";
    public static final String PROP_STATUS_FONT_FACE        =""crengine.page.header.font.face"";
    public static final String PROP_STATUS_FONT_SIZE        =""crengine.page.header.font.size"";
    public static final String PROP_STATUS_CHAPTER_MARKS    =""crengine.page.header.chapter.marks"";
    public static final String PROP_PAGE_MARGIN_TOP         =""crengine.page.margin.top"";
    public static final String PROP_PAGE_MARGIN_BOTTOM      =""crengine.page.margin.bottom"";
    public static final String PROP_PAGE_MARGIN_LEFT        =""crengine.page.margin.left"";
    public static final String PROP_PAGE_MARGIN_RIGHT       =""crengine.page.margin.right"";
    public static final String PROP_PAGE_VIEW_MODE          =""crengine.page.view.mode""; // pages/scroll
    public static final String PROP_PAGE_ANIMATION          =""crengine.page.animation"";
    public static final String PROP_INTERLINE_SPACE         =""crengine.interline.space"";
    public static final String PROP_ROTATE_ANGLE            =""window.rotate.angle"";
    public static final String PROP_EMBEDDED_STYLES         =""crengine.doc.embedded.styles.enabled"";
    public static final String PROP_DISPLAY_INVERSE         =""crengine.display.inverse"";
//    public static final String PROP_DISPLAY_FULL_UPDATE_INTERVAL =""crengine.display.full.update.interval"";
//    public static final String PROP_DISPLAY_TURBO_UPDATE_MODE =""crengine.display.turbo.update"";
    public static final String PROP_STATUS_LINE             =""window.status.line"";
    public static final String PROP_BOOKMARK_ICONS          =""crengine.bookmarks.icons"";
    public static final String PROP_FOOTNOTES               =""crengine.footnotes"";
    public static final String PROP_SHOW_TIME               =""window.status.clock"";
    public static final String PROP_SHOW_TITLE              =""window.status.title"";
    public static final String PROP_SHOW_BATTERY            =""window.status.battery"";
    public static final String PROP_SHOW_BATTERY_PERCENT    =""window.status.battery.percent"";
    public static final String PROP_FONT_KERNING_ENABLED    =""font.kerning.enabled"";
    public static final String PROP_LANDSCAPE_PAGES         =""window.landscape.pages"";
    public static final String PROP_HYPHENATION_DICT        =""crengine.hyphenation.dictionary.code""; // non-crengine
    public static final String PROP_AUTOSAVE_BOOKMARKS      =""crengine.autosave.bookmarks"";

    public static final String PROP_MIN_FILE_SIZE_TO_CACHE  =""crengine.cache.filesize.min"";
    public static final String PROP_FORCED_MIN_FILE_SIZE_TO_CACHE  =""crengine.cache.forced.filesize.min"";
    public static final String PROP_PROGRESS_SHOW_FIRST_PAGE=""crengine.progress.show.first.page"";

    public static final String PROP_CONTROLS_ENABLE_VOLUME_KEYS =""app.controls.volume.keys.enabled"";
    
    public static final String PROP_APP_FULLSCREEN          =""app.fullscreen"";
    public static final String PROP_APP_BOOK_PROPERTY_SCAN_ENABLED =""app.browser.fileprops.scan.enabled"";
    public static final String PROP_APP_SHOW_COVERPAGES     =""app.browser.coverpages"";
    public static final String PROP_APP_SCREEN_ORIENTATION  =""app.screen.orientation"";
    public static final String PROP_APP_SCREEN_BACKLIGHT    =""app.screen.backlight"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_DAY   =""app.screen.backlight.day"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_NIGHT =""app.screen.backlight.night"";
    public static final String PROP_APP_TAP_ZONE_ACTIONS_TAP     =""app.tapzone.action.tap"";
    public static final String PROP_APP_KEY_ACTIONS_PRESS     =""app.key.action.press"";
    public static final String PROP_APP_TRACKBALL_DISABLED    =""app.trackball.disabled"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_LOCK    =""app.screen.backlight.lock.enabled"";
    public static final String PROP_APP_TAP_ZONE_HILIGHT     =""app.tapzone.hilight"";

    public static final int PAGE_ANIMATION_NONE = 0;
    public static final int PAGE_ANIMATION_PAPER = 1;
    public static final int PAGE_ANIMATION_SLIDE = 2;
    
    public enum ViewMode
    {
    	PAGES,
    	SCROLL
    }
    
    private ViewMode viewMode = ViewMode.PAGES;
    
    public enum ReaderCommand
    {
    	DCMD_NONE(0),
    	DCMD_REPEAT(1), // repeat last action
    	
    	//definitions from crengine/include/lvdocview.h
    	DCMD_BEGIN(100),
    	DCMD_LINEUP(101),
    	DCMD_PAGEUP(102),
    	DCMD_PAGEDOWN(103),
    	DCMD_LINEDOWN(104),
    	DCMD_LINK_FORWARD(105),
    	DCMD_LINK_BACK(106),
    	DCMD_LINK_NEXT(107),
    	DCMD_LINK_PREV(108),
    	DCMD_LINK_GO(109),
    	DCMD_END(110),
    	DCMD_GO_POS(111),
    	DCMD_GO_PAGE(112),
    	DCMD_ZOOM_IN(113),
    	DCMD_ZOOM_OUT(114),
    	DCMD_TOGGLE_TEXT_FORMAT(115),
    	DCMD_BOOKMARK_SAVE_N(116),
    	DCMD_BOOKMARK_GO_N(117),
    	DCMD_MOVE_BY_CHAPTER(118),
    	DCMD_GO_SCROLL_POS(119),
    	DCMD_TOGGLE_PAGE_SCROLL_VIEW(120),
    	DCMD_LINK_FIRST(121),
    	DCMD_ROTATE_BY(122),
    	DCMD_ROTATE_SET(123),
    	DCMD_SAVE_HISTORY(124),
    	DCMD_SAVE_TO_CACHE(125),
    	DCMD_TOGGLE_BOLD(126),
    	DCMD_SCROLL_BY(127),
    	DCMD_REQUEST_RENDER(128),

    	// definitions from android/jni/readerview.h
    	DCMD_OPEN_RECENT_BOOK(2000),
    	DCMD_CLOSE_BOOK(2001),
    	DCMD_RESTORE_POSITION(2002),

    	// application actions
    	DCMD_RECENT_BOOKS_LIST(2003),
    	DCMD_SEARCH(2004),
    	DCMD_EXIT(2005),
    	DCMD_BOOKMARKS(2005),
    	DCMD_GO_PERCENT_DIALOG(2006),
    	DCMD_GO_PAGE_DIALOG(2007),
    	DCMD_TOC_DIALOG(2008),
    	DCMD_FILE_BROWSER(2009),
    	DCMD_OPTIONS_DIALOG(2010),
    	DCMD_TOGGLE_DAY_NIGHT_MODE(2011),
    	DCMD_READER_MENU(2012),
    	DCMD_TOGGLE_TOUCH_SCREEN_LOCK(2013),
    	;
    	
    	private final int nativeId;
    	private ReaderCommand( int nativeId )
    	{
    		this.nativeId = nativeId;
    	}
    }
    
    private void execute( Engine.EngineTask task )
    {
    	mEngine.execute(task);
    }
    
    private void post( Engine.EngineTask task )
    {
    	mEngine.post(task);
    }
    
    private abstract class Task implements Engine.EngineTask {
    	
		public void done() {
			// override to do something useful
		}

		public void fail(Exception e) {
			// do nothing, just log exception
			// override to do custom action
			Log.e(""cr3"", ""Task "" + this.getClass().getSimpleName() + "" is failed with exception "" + e.getMessage(), e);
		}
    }
    
	static class Sync<T> extends Object {
		private T result = null;
		private boolean completed = false;
		public synchronized void set( T res )
		{
			result = res;
			completed = true;
			notify();
		}
		public synchronized T get()
		{
			while ( !completed ) {
    			try {
    				wait();
    			} catch (Exception e) {
    				// ignore
    			}
			}
			return result;
		}
	}

    private <T> T executeSync( final Callable<T> task )
    {
    	//Log.d(""cr3"", ""executeSync called"");
    	
    	
    	final Sync<T> sync = new Sync<T>();
    	post( new Runnable() {
    		public void run() {
    			try {
    				sync.set( task.call() );
    			} catch ( Exception e ) {
    			}
    		}
    	});
    	T res = sync.get();
    	//Log.d(""cr3"", ""executeSync done"");
    	return res;
    }
    
    // Native functions
    /* implementend by libcr3engine.so */
    
    // get current page image
    private native void getPageImageInternal(Bitmap bitmap);
    // constructor's native part
    private native void createInternal();
    private native void destroyInternal();
    private native boolean loadDocumentInternal( String fileName );
    private native java.util.Properties getSettingsInternal();
    private native boolean applySettingsInternal( java.util.Properties settings );
    private native void setStylesheetInternal( String stylesheet );
    private native void resizeInternal( int dx, int dy );
    private native boolean doCommandInternal( int command, int param );
    private native Bookmark getCurrentPageBookmarkInternal();
    private native boolean goToPositionInternal(String xPath);
    private native PositionProperties getPositionPropsInternal(String xPath);
    private native void updateBookInfoInternal( BookInfo info );
    private native TOCItem getTOCInternal();
    private native void clearSelectionInternal();
    private native boolean findTextInternal( String pattern, int origin, int reverse, int caseInsensitive );
    private native void setBatteryStateInternal( int state );
    private native byte[] getCoverPageDataInternal();
    private native void setPageBackgroundTextureInternal( byte[] imageBytes, int tileFlags );
    private native void updateSelectionInternal( Selection sel );
    
    
    protected int mNativeObject; // used from JNI
    
	private final CoolReader mActivity;
    private final Engine mEngine;
    private final BackgroundThread mBackThread;
    
    private BookInfo mBookInfo;
    
    private Properties mSettings = new Properties();

    public Engine getEngine()
    {
    	return mEngine;
    }
    
    public CoolReader getActivity()
    {
    	return mActivity;
    }
    
	private int lastResizeTaskId = 0;
	@Override
	protected void onSizeChanged(final int w, final int h, int oldw, int oldh) {
		Log.d(""cr3"", ""onSizeChanged(""+w + "", "" + h +"")"");
		super.onSizeChanged(w, h, oldw, oldh);
		final int thisId = ++lastResizeTaskId;
		mActivity.getHistory().updateCoverPageSize(w, h);
		post(new Task() {
			public void work() {
				BackgroundThread.ensureBackground();
				if ( thisId != lastResizeTaskId ) {
					Log.d(""cr3"", ""skipping duplicate resize request"");
					return;
				}
		        internalDX = w;
		        internalDY = h;
				Log.d(""cr3"", ""ResizeTask: resizeInternal(""+w+"",""+h+"")"");
		        resizeInternal(w, h);
//		        if ( mOpened ) {
//					Log.d(""cr3"", ""ResizeTask: done, drawing page"");
//			        drawPage();
//		        }
			}
			public void done() {
				clearImageCache();
				invalidate();
			}
		});
	}
	
	public boolean isBookLoaded()
	{
		BackgroundThread.ensureGUI();
		return mOpened;
	}
	
	public int getOrientation()
	{
		int angle = mSettings.getInt(PROP_APP_SCREEN_ORIENTATION, 0);
		if ( angle==4 )
			angle = mActivity.getOrientationFromSensor();
		return angle;
	}

	private int overrideKey( int keyCode )
	{
		return keyCode;
/*		
		
		int angle = getOrientation();
		int[] subst = new int[] {
			1, 	KeyEvent.KEYCODE_DPAD_UP, KeyEvent.KEYCODE_DPAD_LEFT,
			1, 	KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT,
			1, 	KeyEvent.KEYCODE_DPAD_LEFT, KeyEvent.KEYCODE_DPAD_DOWN,
			1, 	KeyEvent.KEYCODE_DPAD_RIGHT, KeyEvent.KEYCODE_DPAD_UP,
			1, 	KeyEvent.KEYCODE_VOLUME_UP, KeyEvent.KEYCODE_VOLUME_DOWN,
			1, 	KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.KEYCODE_VOLUME_UP,
//			2, 	KeyEvent.KEYCODE_DPAD_UP, KeyEvent.KEYCODE_DPAD_DOWN,
//			2, 	KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_UP,
//			2, 	KeyEvent.KEYCODE_DPAD_LEFT, KeyEvent.KEYCODE_DPAD_RIGHT,
//			2, 	KeyEvent.KEYCODE_DPAD_RIGHT, KeyEvent.KEYCODE_DPAD_LEFT,
//			2, 	KeyEvent.KEYCODE_VOLUME_UP, KeyEvent.KEYCODE_VOLUME_DOWN,
//			2, 	KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.KEYCODE_VOLUME_UP,
//			3, 	KeyEvent.KEYCODE_DPAD_UP, KeyEvent.KEYCODE_DPAD_RIGHT,
//			3, 	KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_LEFT,
//			3, 	KeyEvent.KEYCODE_DPAD_LEFT, KeyEvent.KEYCODE_DPAD_UP,
//			3, 	KeyEvent.KEYCODE_DPAD_RIGHT, KeyEvent.KEYCODE_DPAD_DOWN,
		};
		for ( int i=0; i<subst.length; i+=3 ) {
			if ( angle==subst[i] && keyCode==subst[i+1] )
				return subst[i+2];
		}
		return keyCode;
*/
	}
	
	public int getTapZone( int x, int y, int dx, int dy )
	{
		int x1 = dx / 3;
		int x2 = dx * 2 / 3;
		int y1 = dy / 3;
		int y2 = dy * 2 / 3;
		int zone = 0;
		if ( y<y1 ) {
			if ( x<x1 )
				zone = 1;
			else if ( x<x2 )
				zone = 2;
			else
				zone = 3;
		} else if ( y<y2 ) {
			if ( x<x1 )
				zone = 4;
			else if ( x<x2 )
				zone = 5;
			else
				zone = 6;
		} else {
			if ( x<x1 )
				zone = 7;
			else if ( x<x2 )
				zone = 8;
			else
				zone = 9;
		}
		return zone;
	}
	
	public void onTapZone( int zone, boolean isLongPress )
	{
		ReaderAction action;
		if ( !isLongPress )
			action = ReaderAction.findForTap(zone, mSettings);
		else
			action = ReaderAction.findForLongTap(zone, mSettings);
		if ( action.isNone() )
			return;
		Log.d(""cr3"", ""onTapZone : action "" + action.id + "" is found for tap zone "" + zone + (isLongPress ? "" (long)"":""""));
		onAction( action );
	}
	
	public FileInfo getOpenedFileInfo()
	{
		if ( isBookLoaded() && mBookInfo!=null )
			return mBookInfo.getFileInfo();
		return null;
	}
	
	public final int LONG_KEYPRESS_TIME = 900;
	public final int AUTOREPEAT_KEYPRESS_TIME = 700;
	public final int DOUBLE_CLICK_INTERVAL = 400;
	private ReaderAction currentDoubleClickAction = null;
	private ReaderAction currentSingleClickAction = null;
	private long currentDoubleClickActionStart = 0;
	private int currentDoubleClickActionKeyCode = 0;
	@Override
	public boolean onKeyUp(int keyCode, final KeyEvent event) {
		if ( keyCode==KeyEvent.KEYCODE_VOLUME_DOWN || keyCode==KeyEvent.KEYCODE_VOLUME_UP )
			if ( !enableVolumeKeys )
				return super.onKeyUp(keyCode, event);
		if ( keyCode==KeyEvent.KEYCODE_POWER || keyCode==KeyEvent.KEYCODE_ENDCALL ) {
			mActivity.releaseBacklightControl();
			return false;
		}
		boolean tracked = isTracked(event);
		if ( keyCode!=KeyEvent.KEYCODE_BACK )
			backKeyDownHere = false;
		mActivity.onUserActivity();

		if ( keyCode==KeyEvent.KEYCODE_BACK && !tracked )
			return true;
		backKeyDownHere = false;
		
		// apply orientation
		keyCode = overrideKey( keyCode );
		boolean isLongPress = (event.getEventTime()-event.getDownTime())>=LONG_KEYPRESS_TIME;
		ReaderAction action = ReaderAction.findForKey( keyCode, mSettings );
		ReaderAction longAction = ReaderAction.findForLongKey( keyCode, mSettings );
		ReaderAction dblAction = ReaderAction.findForDoubleKey( keyCode, mSettings );
		stopTracking();

		if ( keyCode>=KeyEvent.KEYCODE_0 && keyCode<=KeyEvent.KEYCODE_9 && tracked ) {
			// goto/set shortcut bookmark
			int shortcut = keyCode - KeyEvent.KEYCODE_0;
			if ( shortcut==0 )
				shortcut = 10;
			if ( isLongPress )
				addBookmark(shortcut);
			else
				goToBookmark(shortcut);
			return true;
		} else if ( keyCode==KeyEvent.KEYCODE_VOLUME_DOWN || keyCode==KeyEvent.KEYCODE_VOLUME_UP )
			return enableVolumeKeys;
		if ( action.isNone() || !tracked ) {
			return super.onKeyUp(keyCode, event);
		}
		if ( !action.isNone() && action.canRepeat() && longAction.isRepeat() ) {
			// already processed by onKeyDown()
			return true;
		}
		
		if ( isLongPress ) {
			action = longAction;
		} else {
			if ( !dblAction.isNone() ) {
				// wait for possible double click
				currentDoubleClickActionStart = android.os.SystemClock.uptimeMillis();
				currentDoubleClickAction = dblAction;
				currentSingleClickAction = action;
				currentDoubleClickActionKeyCode = keyCode;
				final int myKeyCode = keyCode;
				BackgroundThread.instance().postGUI(new Runnable() {
					public void run() {
						if ( currentSingleClickAction!=null && currentDoubleClickActionKeyCode==myKeyCode ) {
							Log.d(""cr3"", ""onKeyUp: single click action "" + currentSingleClickAction.id + "" found for key "" + myKeyCode + "" single click"");
							onAction( currentSingleClickAction );
						}
						currentDoubleClickActionStart = 0;
						currentDoubleClickActionKeyCode = 0;
						currentDoubleClickAction = null;
						currentSingleClickAction = null;
					}
				}, DOUBLE_CLICK_INTERVAL);
				// posted
				return true;
			}
		}
		if ( !action.isNone() ) {
			Log.d(""cr3"", ""onKeyUp: action "" + action.id + "" found for key "" + keyCode + (isLongPress?"" (long)"" : """") );
			onAction( action );
			return true;
		}
		

		// not processed
		return super.onKeyUp(keyCode, event);
	}

	boolean VOLUME_KEYS_ZOOM = false;
	
	private boolean backKeyDownHere = false;

	
	
	@Override
	protected void onFocusChanged(boolean gainFocus, int direction,
			Rect previouslyFocusedRect) {
		stopTracking();
		super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
	}
	
	private boolean startTrackingKey( KeyEvent event ) {
		if ( event.getRepeatCount()==0 ) {
			stopTracking();
			trackedKeyEvent = event;
			return true;
		}
		return false;
	}
	
	private void stopTracking() {
		trackedKeyEvent = null;
		actionToRepeat = null;
		repeatActionActive = false;
	}

	private boolean isTracked( KeyEvent event ) {
		if ( trackedKeyEvent!=null && trackedKeyEvent.getDownTime() == event.getDownTime() )
			return true;
		stopTracking();
		return false;
	}

	@Override
	public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) {
		Log.v(""cr3"", ""onKeyMultiple( keyCode="" + keyCode + "", repeatCount="" + repeatCount + "", event="" + event);
		return super.onKeyMultiple(keyCode, repeatCount, event);
	}


	private KeyEvent trackedKeyEvent = null; 
	private ReaderAction actionToRepeat = null;
	private boolean repeatActionActive = false;
	
	@Override
	public boolean onKeyDown(int keyCode, final KeyEvent event) {
		backKeyDownHere = false;
		if ( event.getRepeatCount()==0 )
			Log.v(""cr3"", ""onKeyDown(""+keyCode + "", "" + event +"")"");
		if ( keyCode==KeyEvent.KEYCODE_POWER || keyCode==KeyEvent.KEYCODE_ENDCALL ) {
			mActivity.releaseBacklightControl();
			return false;
		}
		mActivity.onUserActivity();

    	if ( keyCode==KeyEvent.KEYCODE_VOLUME_UP || keyCode==KeyEvent.KEYCODE_VOLUME_DOWN )
    		if (!enableVolumeKeys)
    			return super.onKeyDown(keyCode, event);
    	
		keyCode = overrideKey( keyCode );
		ReaderAction action = ReaderAction.findForKey( keyCode, mSettings );
		ReaderAction longAction = ReaderAction.findForLongKey( keyCode, mSettings );
		ReaderAction dblAction = ReaderAction.findForDoubleKey( keyCode, mSettings );

		if ( event.getRepeatCount()==0 ) {
			if ( keyCode==currentDoubleClickActionKeyCode && currentDoubleClickActionStart + DOUBLE_CLICK_INTERVAL > android.os.SystemClock.uptimeMillis() ) {
				if ( currentDoubleClickAction!=null ) {
					Log.d(""cr3"", ""executing doubleclick action "" + currentDoubleClickAction);
					onAction(currentDoubleClickAction);
				}
				currentDoubleClickActionStart = 0;
				currentDoubleClickActionKeyCode = 0;
				currentDoubleClickAction = null;
				currentSingleClickAction = null;
				return true;
			} else {
				if ( currentSingleClickAction!=null ) {
					onAction(currentSingleClickAction);
				}
				currentDoubleClickActionStart = 0;
				currentDoubleClickActionKeyCode = 0;
				currentDoubleClickAction = null;
				currentSingleClickAction = null;
			}
			
		}
		
		
    	if ( event.getRepeatCount()>0 ) {
    		if ( !isTracked(event) )
    			return true; // ignore
    		// repeating key down
    		boolean isLongPress = (event.getEventTime()-event.getDownTime())>=AUTOREPEAT_KEYPRESS_TIME;
    		if ( isLongPress ) {
	    		if ( !repeatActionActive && actionToRepeat!=null ) {
	    			Log.v(""cr3"", ""autorepeating action : "" + actionToRepeat );
	    			repeatActionActive = true;
	    			onAction(actionToRepeat, new Runnable() {
	    				public void run() {
	    					if ( trackedKeyEvent!=null && trackedKeyEvent.getDownTime()==event.getDownTime() ) {
	    						Log.v(""cr3"", ""action is completed : "" + actionToRepeat );
	    						repeatActionActive = false;
	    					}
	    				}
	    			});
	    		} else {
	    			stopTracking();
	    			Log.v(""cr3"", ""executing action on long press : "" + longAction );
	    			onAction(longAction);
	    		}
    		}
    		return true;
    	}
		
		if ( !action.isNone() && action.canRepeat() && longAction.isRepeat() ) {
			// start tracking repeat
			startTrackingKey(event);
			actionToRepeat = action;
			Log.v(""cr3"", ""running action with scheduled autorepeat : "" + actionToRepeat );
			repeatActionActive = true;
			onAction(actionToRepeat, new Runnable() {
				public void run() {
					if ( trackedKeyEvent==event ) {
						Log.v(""cr3"", ""action is completed : "" + actionToRepeat );
						repeatActionActive = false;
					}
				}
			});
			return true;
		} else {
			actionToRepeat = null;
		}
		
		if ( keyCode>=KeyEvent.KEYCODE_0 && keyCode<=KeyEvent.KEYCODE_9 ) {
			// will process in keyup handler
			startTrackingKey(event);
			return true;
		}
		if ( action.isNone() && longAction.isNone() )
			return super.onKeyDown(keyCode, event);
		startTrackingKey(event);
		return true;
	}
	
	private int nextUpdateId = 0;
	private void updateSelection(int startX, int startY, int endX, int endY, final boolean isUpdateEnd ) {
		final Selection sel = new Selection();
		final int myId = ++nextUpdateId;
		sel.startX = startX;
		sel.startY = startY;
		sel.endX = endX;
		sel.endY = endY;
		mEngine.execute(new Task() {
			@Override
			public void work() throws Exception {
				if ( myId != nextUpdateId && !isUpdateEnd )
					return;
				updateSelectionInternal(sel);
				if ( !sel.isEmpty() ) {
					invalidImages = true;
					BitmapInfo bi = preparePageImage(0);
					if ( bi!=null ) {
						draw();
					}
				}
			}

			@Override
			public void done() {
				if ( isUpdateEnd ) {
					String text = sel.text;
					if ( text!=null && text.length()>0 ) {
						ClipboardManager cm = mActivity.getClipboardmanager();
						cm.setText(text);
						Log.i(""cr3"", ""Setting clipboard text: "" + text);
						mActivity.showToast(""Selection text copied to clipboard"");
					}
					clearSelection();
				}
			}
		});
	}
	
	private void cancelSelection() {
		//
		selectionInProgress = false;
		clearSelection();
	}

	private boolean isTouchScreenEnabled = true;
	private boolean isManualScrollActive = false;
	private int manualScrollStartPosX = 0;
	private int manualScrollStartPosY = 0;
	volatile private boolean touchEventIgnoreNextUp = false;
	volatile private int longTouchId = 0;
	volatile private long currentDoubleTapActionStart = 0;
	private boolean selectionInProgress = false;
	private int selectionStartX = 0;
	private int selectionStartY = 0;
	private int selectionEndX = 0;
	private int selectionEndY = 0;
	
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		
		if ( !isTouchScreenEnabled ) {
			return true;
		}
		
		int x = (int)event.getX();
		int y = (int)event.getY();
		int dx = getWidth();
		int dy = getHeight();
		int START_DRAG_THRESHOLD = mActivity.getPalmTipPixels();
		final int zone = getTapZone(x, y, dx, dy);
		
		if ( event.getAction()==MotionEvent.ACTION_UP ) {
			longTouchId++;
			if ( selectionInProgress ) {
				Log.v(""cr3"", ""touch ACTION_UP: selection finished"");
				selectionEndX = x;
				selectionEndY = y;
				updateSelection( selectionStartX, selectionStartY, selectionEndX, selectionEndY, true );
				selectionInProgress = false;
				return true;
			}
			if ( touchEventIgnoreNextUp )
				return true;
			mActivity.onUserActivity();
			unhiliteTapZone(); 
			boolean isLongPress = (event.getEventTime()-event.getDownTime())>LONG_KEYPRESS_TIME;
			stopAnimation(x, y);
			if ( isManualScrollActive ) {
				isManualScrollActive = false;
				return true;
			}
			if ( isLongPress ) {
				onTapZone( zone, isLongPress );
				currentDoubleTapActionStart = 0;
			} else {
				currentDoubleTapActionStart = android.os.SystemClock.uptimeMillis();
				final long myStart = currentDoubleTapActionStart;
				BackgroundThread.instance().postGUI(new Runnable() {
					@Override
					public void run() {
						if ( currentDoubleTapActionStart != myStart ) {
							onTapZone( zone, false );
						}
						currentDoubleTapActionStart = 0;
					}
				}, DOUBLE_CLICK_INTERVAL);
			}
			return true;
		} else if ( event.getAction()==MotionEvent.ACTION_DOWN ) {
			touchEventIgnoreNextUp = false;
			if ( currentDoubleTapActionStart + DOUBLE_CLICK_INTERVAL > android.os.SystemClock.uptimeMillis() ) {
				Log.v(""cr3"", ""touch ACTION_DOWN: double tap: starting selection"");
				// double tap started
				selectionInProgress = true;
				longTouchId++;
				selectionStartX = x;
				selectionStartY = y;
				selectionEndX = x;
				selectionEndY = y;
				updateSelection( selectionStartX, selectionStartY, selectionEndX, selectionEndY, false );
				return true;
			}
			selectionInProgress = false;
			manualScrollStartPosX = x;
			manualScrollStartPosY = y;
			currentDoubleTapActionStart = 0;
			if ( hiliteTapZoneOnTap ) {
				hiliteTapZone( true, x, y, dx, dy );
				scheduleUnhilite( LONG_KEYPRESS_TIME );
			}
			final int myId = ++longTouchId;
			mBackThread.postGUI( new Runnable() {
				@Override
				public void run() {
					if ( myId==longTouchId ) {
						touchEventIgnoreNextUp = true;
						onTapZone( zone, true );
					}
				}
				
			}, LONG_KEYPRESS_TIME);
			return true;
		} else if ( event.getAction()==MotionEvent.ACTION_MOVE) {
			if ( selectionInProgress ) {
				Log.v(""cr3"", ""touch ACTION_MOVE: updating selection"");
				selectionEndX = x;
				selectionEndY = y;
				updateSelection( selectionStartX, selectionStartY, selectionEndX, selectionEndY, false );
				return true;
			}
//			if ( viewMode==ViewMode.SCROLL ) {
				if ( !isManualScrollActive ) {
					int deltax = manualScrollStartPosX - x; 
					int deltay = manualScrollStartPosY - y;
					deltax = deltax < 0 ? -deltax : deltax;
					deltay = deltay < 0 ? -deltay : deltay;
					if ( deltax + deltay > START_DRAG_THRESHOLD ) {
						longTouchId++;
						isManualScrollActive = true;
						startAnimation(manualScrollStartPosX, manualScrollStartPosY, dx, dy);
						updateAnimation(x, y);
						return true;
					}
				}
//			}
			if ( !isManualScrollActive )
				return true;
			updateAnimation(x, y);
		} else if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
			if ( selectionInProgress ) {
				// cancel selection
				cancelSelection();
			}
			isManualScrollActive = false;
			currentDoubleTapActionStart = 0;
			longTouchId++;
			stopAnimation(-1, -1);
			hiliteTapZone( false, x, y, dx, dy ); 
		}
		return true;
		//return super.onTouchEvent(event);
	}

	@Override
	public boolean onTrackballEvent(MotionEvent event) {
		Log.d(""cr3"", ""onTrackballEvent("" + event + "")"");
		if ( mSettings.getBool(PROP_APP_TRACKBALL_DISABLED, false) ) {
			Log.d(""cr3"", ""trackball is disabled in settings"");
			return true;
		}
		return super.onTrackballEvent(event);
	}
	
	public void showTOC()
	{
		BackgroundThread.ensureGUI();
		final ReaderView view = this; 
		mEngine.post(new Task() {
			TOCItem toc;
			PositionProperties pos;
			public void work() {
				BackgroundThread.ensureBackground();
				toc = getTOCInternal();
				pos = getPositionPropsInternal(null);
			}
			public void done() {
				BackgroundThread.ensureGUI();
				if ( toc!=null && pos!=null ) {
					TOCDlg dlg = new TOCDlg(mActivity, view, toc, pos.pageNumber);
					dlg.show();
				} else {
					mActivity.showToast(""No Table of Contents found"");
				}
			}
		});
	}
	
	public void showSearchDialog()
	{
		BackgroundThread.ensureGUI();
		SearchDlg dlg = new SearchDlg( mActivity, this );
		dlg.show();
	}

    public void findText( final String pattern, final boolean reverse, final boolean caseInsensitive )
    {
		BackgroundThread.ensureGUI();
		final ReaderView view = this; 
		mEngine.execute(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				boolean res = findTextInternal( pattern, 1, reverse?1:0, caseInsensitive?1:0);
				if ( !res )
					res = findTextInternal( pattern, -1, reverse?1:0, caseInsensitive?1:0);
				if ( !res ) {
					clearSelectionInternal();
					throw new Exception(""pattern not found"");
				}
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
				FindNextDlg.showDialog( mActivity, view, pattern, caseInsensitive );
			}
			public void fail(Exception e) {
				BackgroundThread.ensureGUI();
				mActivity.showToast(""Pattern not found"");
			}
			
		});
    }
    
    public void findNext( final String pattern, final boolean reverse, final boolean caseInsensitive )
    {
		BackgroundThread.ensureGUI();
		mEngine.execute(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				boolean res = findTextInternal( pattern, 1, reverse?1:0, caseInsensitive?1:0);
				if ( !res )
					res = findTextInternal( pattern, -1, reverse?1:0, caseInsensitive?1:0);
				if ( !res ) {
					clearSelectionInternal();
					throw new Exception(""pattern not found"");
				}
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
			}
		});
    }
    
    public void clearSelection()
    {
		BackgroundThread.ensureGUI();
		mEngine.post(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				clearSelectionInternal();
				invalidImages = true;
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
			}
		});
    }

    public void goToBookmark( Bookmark bm )
	{
		BackgroundThread.ensureGUI();
		final String pos = bm.getStartPos();
		mEngine.execute(new Task() {
			public void work() {
				BackgroundThread.ensureBackground();
				goToPositionInternal(pos);
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
			}
		});
	}
	
	public boolean goToBookmark( final int shortcut )
	{
		BackgroundThread.ensureGUI();
		if ( mBookInfo!=null ) {
			Bookmark bm = mBookInfo.findShortcutBookmark(shortcut);
			if ( bm==null ) {
				addBookmark(shortcut);
				return true;
			} else {
				// go to bookmark
				goToBookmark( bm );
				return false;
			}
		}
		return false;
	}
	
	public void addBookmark( final int shortcut )
	{
		BackgroundThread.ensureGUI();
		// set bookmark instead
		mEngine.execute(new Task() {
			Bookmark bm;
			public void work() {
				BackgroundThread.ensureBackground();
				if ( mBookInfo!=null ) {
					bm = getCurrentPageBookmarkInternal();
					bm.setShortcut(shortcut);
				}
			}
			public void done() {
				if ( mBookInfo!=null && bm!=null ) {
					mBookInfo.setShortcutBookmark(shortcut, bm);
					mActivity.getDB().save(mBookInfo);
					mActivity.showToast(""Bookmark "" + (shortcut==10?0:shortcut) + "" is set."");
				}
			}
		});
	}
	
	public boolean onMenuItem( final int itemId )
	{
		BackgroundThread.ensureGUI();
		ReaderAction action = ReaderAction.findByMenuId(itemId);
		if ( action.isNone() )
			return false;
		onAction(action);
		return true;
	}
	
	public void onAction( final ReaderAction action )
	{
		onAction(action, null);
	}
	public void onAction( final ReaderAction action, final Runnable onFinishHandler )
	{
		BackgroundThread.ensureGUI();
		if ( action.cmd!=ReaderCommand.DCMD_NONE )
			onCommand( action.cmd, action.param, onFinishHandler );
	}
	
	public void toggleDayNightMode()
	{
		Properties settings = getSettings();
		OptionsDialog.toggleDayNightMode(settings);
		setSettings(settings, null);
	}
	
	public void onCommand( final ReaderCommand cmd, final int param )
	{
		onCommand( cmd, param, null );
	}

	public void onCommand( final ReaderCommand cmd, final int param, final Runnable onFinishHandler )
	{
		BackgroundThread.ensureGUI();
		Log.i(""cr3"", ""On command "" + cmd + (param!=0?"" (""+param+"")"":"" ""));
		switch ( cmd ) {
		case DCMD_TOGGLE_TOUCH_SCREEN_LOCK:
			isTouchScreenEnabled = !isTouchScreenEnabled;
			if ( isTouchScreenEnabled )
				mActivity.showToast(R.string.action_touch_screen_enabled_toast);
			else
				mActivity.showToast(R.string.action_touch_screen_disabled_toast);
			break;
		case DCMD_ZOOM_OUT:
            doEngineCommand( ReaderCommand.DCMD_ZOOM_OUT, 1);
            syncViewSettings(getSettings());
            break;
		case DCMD_ZOOM_IN:
            doEngineCommand( ReaderCommand.DCMD_ZOOM_IN, 1);
            syncViewSettings(getSettings());
            break;
		case DCMD_PAGEDOWN:
			if ( param==1 )
				animatePageFlip(1, onFinishHandler);
			else
				doEngineCommand(cmd, param, onFinishHandler);
			break;
		case DCMD_PAGEUP:
			if ( param==1 )
				animatePageFlip(-1, onFinishHandler);
			else
				doEngineCommand(cmd, param, onFinishHandler);
			break;
		case DCMD_BEGIN:
		case DCMD_END:
			doEngineCommand(cmd, param);
			break;
		case DCMD_RECENT_BOOKS_LIST:
			mActivity.showBrowserRecentBooks();
			break;
		case DCMD_SEARCH:
			showSearchDialog();
			break;
		case DCMD_EXIT:
			mActivity.finish();
			break;
		case DCMD_BOOKMARKS:
			mActivity.showBookmarksDialog();
			break;
		case DCMD_GO_PERCENT_DIALOG:
			mActivity.showGoToPercentDialog();
			break;
		case DCMD_GO_PAGE_DIALOG:
			mActivity.showGoToPageDialog();
			break;
		case DCMD_TOC_DIALOG:
			showTOC();
			break;
		case DCMD_FILE_BROWSER:
			mActivity.showBrowser(getOpenedFileInfo());
			break;
		case DCMD_OPTIONS_DIALOG:
			mActivity.showOptionsDialog();
			break;
		case DCMD_READER_MENU:
			mActivity.openOptionsMenu();
			break;
		case DCMD_TOGGLE_DAY_NIGHT_MODE:
			toggleDayNightMode();
			break;
		}
	}
	
	public void doEngineCommand( final ReaderCommand cmd, final int param )
	{
		doEngineCommand( cmd, param, null );
	}
	public void doEngineCommand( final ReaderCommand cmd, final int param, final Runnable doneHandler )
	{
		BackgroundThread.ensureGUI();
		Log.d(""cr3"", ""doCommand(""+cmd + "", "" + param +"")"");
		post(new Task() {
			boolean res;
			public void work() {
				BackgroundThread.ensureBackground();
				res = doCommandInternal(cmd.nativeId, param);
			}
			public void done() {
				if ( res )
					drawPage( doneHandler );
			}
		});
	}
	
	public void doCommandFromBackgroundThread( final ReaderCommand cmd, final int param )
	{
		Log.d(""cr3"", ""doCommandFromBackgroundThread(""+cmd + "", "" + param +"")"");
		BackgroundThread.ensureBackground();
		boolean res = doCommandInternal(cmd.nativeId, param);
		if ( res ) {
			BackgroundThread.guiExecutor.execute(new Runnable() {
				public void run() {
					drawPage();
				}
			});
		}
	}
	
	volatile private boolean mInitialized = false;
	volatile private boolean mOpened = false;
	
	//private File historyFile;
	
	private void updateLoadedBookInfo()
	{
		BackgroundThread.ensureBackground();
		// get title, authors, etc.
		updateBookInfoInternal( mBookInfo );
	}
	
	private void applySettings( Properties props )
	{
		BackgroundThread.ensureBackground();
		Log.v(""cr3"", ""applySettings() "" + props);
		boolean isFullScreen = props.getBool(PROP_APP_FULLSCREEN, false );
		props.setBool(PROP_SHOW_BATTERY, isFullScreen); 
		props.setBool(PROP_SHOW_TIME, isFullScreen);
		String backgroundImageId = props.getProperty(PROP_PAGE_BACKGROUND_IMAGE);
		if ( backgroundImageId!=null )
			setBackgroundTexture(backgroundImageId);
        applySettingsInternal(props);
        syncViewSettings(props);
        drawPage();
	}
	
	public static boolean eq(Object obj1, Object obj2)
	{
		if ( obj1==null && obj2==null )
			return true;
		if ( obj1==null || obj2==null )
			return false;
		return obj1.equals(obj2);
	}

	public void saveSettings( Properties settings )
	{
		mActivity.saveSettings(settings);
	}
	
	/**
	 * Read JNI view settings, update and save if changed 
	 */
	private void syncViewSettings( final Properties currSettings )
	{
		post( new Task() {
			Properties props;
			public void work() {
				BackgroundThread.ensureBackground();
				java.util.Properties internalProps = getSettingsInternal(); 
				props = new Properties(internalProps);
			}
			public void done() {
				Properties changedSettings = props.diff(currSettings);
		        for ( Map.Entry<Object, Object> entry : changedSettings.entrySet() ) {
	        		currSettings.setProperty((String)entry.getKey(), (String)entry.getValue());
		        }
	        	mSettings = currSettings;
	        	saveSettings(currSettings);
			}
		});
	}
	
	public Properties getSettings()
	{
		return new Properties(mSettings);
	}

	private boolean hiliteTapZoneOnTap = false;
	private boolean enableVolumeKeys = true; 
	static private final int DEF_PAGE_FLIP_MS = 500; 
	public void applyAppSetting( String key, String value )
	{
		boolean flg = ""1"".equals(value);
        if ( key.equals(PROP_APP_FULLSCREEN) ) {
			this.mActivity.setFullscreen( ""1"".equals(value) );
        } else if ( key.equals(PROP_APP_SHOW_COVERPAGES) ) {
			mActivity.getHistory().setCoverPagesEnabled(flg);
        } else if ( key.equals(PROP_APP_BOOK_PROPERTY_SCAN_ENABLED) ) {
			mActivity.getScanner().setDirScanEnabled(flg);
        } else if ( key.equals(PROP_APP_SCREEN_BACKLIGHT_LOCK) ) {
			mActivity.setWakeLockEnabled(flg);
        } else if ( key.equals(PROP_NIGHT_MODE) ) {
			mActivity.setNightMode(flg);
        } else if ( key.equals(PROP_APP_TAP_ZONE_HILIGHT) ) {
        	hiliteTapZoneOnTap = flg;
        } else if ( key.equals(PROP_APP_SCREEN_ORIENTATION) ) {
			int orientation = ""1"".equals(value) ? 1 : (""4"".equals(value) ? 4 : 0);
        	mActivity.setScreenOrientation(orientation);
        } else if ( PROP_PAGE_ANIMATION.equals(key) ) {
        	try {
        		int n = Integer.valueOf(value);
        		if ( n<0 || n>2 )
        			n = 1;
        		pageFlipAnimationMode = n;
        	} catch ( Exception e ) {
        		// ignore
        	}
			pageFlipAnimationSpeedMs = pageFlipAnimationMode!=PAGE_ANIMATION_NONE ? DEF_PAGE_FLIP_MS : 0; 
        } else if ( PROP_CONTROLS_ENABLE_VOLUME_KEYS.equals(key) ) {
        	enableVolumeKeys = flg;
        } else if ( PROP_APP_SCREEN_BACKLIGHT.equals(key) ) {
        	try {
        		int n = Integer.valueOf(value);
        		mActivity.setScreenBacklightLevel(n);
        	} catch ( Exception e ) {
        		// ignore
        	}
        }
	}
	
	public void setAppSettings( Properties newSettings, Properties oldSettings )
	{
		Log.v(""cr3"", ""setAppSettings() "" + newSettings.toString());
		BackgroundThread.ensureGUI();
		if ( oldSettings==null )
			oldSettings = mSettings;
		Properties changedSettings = newSettings.diff(oldSettings);
        for ( Map.Entry<Object, Object> entry : changedSettings.entrySet() ) {
    		String key = (String)entry.getKey();
    		String value = (String)entry.getValue();
    		applyAppSetting( key, value );
    		if ( PROP_APP_FULLSCREEN.equals(key) ) {
    			boolean flg = mSettings.getBool(PROP_APP_FULLSCREEN, false);
    			newSettings.setBool(PROP_SHOW_BATTERY, flg); 
    			newSettings.setBool(PROP_SHOW_TIME, flg); 
    		} else if ( PROP_PAGE_VIEW_MODE.equals(key) ) {
    			boolean flg = ""1"".equals(value);
    			viewMode = flg ? ViewMode.PAGES : ViewMode.SCROLL;
    		} else if ( PROP_APP_SCREEN_ORIENTATION.equals(key) || PROP_PAGE_ANIMATION.equals(key)
    				|| PROP_CONTROLS_ENABLE_VOLUME_KEYS.equals(key) || PROP_APP_SHOW_COVERPAGES.equals(key) 
    				|| PROP_APP_SCREEN_BACKLIGHT.equals(key) 
    				|| PROP_APP_BOOK_PROPERTY_SCAN_ENABLED.equals(key)
    				|| PROP_APP_SCREEN_BACKLIGHT_LOCK.equals(key)
    				|| PROP_APP_TAP_ZONE_HILIGHT.equals(key)
    				) {
    			newSettings.setProperty(key, value);
    		} else if ( PROP_HYPHENATION_DICT.equals(key) ) {
    			Engine.HyphDict dict = HyphDict.byCode(value);
    			//mEngine.setHyphenationDictionary();
    			if ( mEngine.setHyphenationDictionary(dict) ) {
    				if ( isBookLoaded() ) {
    					doEngineCommand( ReaderCommand.DCMD_REQUEST_RENDER, 0);
    					//drawPage();
    				}
    			}
    			newSettings.setProperty(key, value);
    		}
        }
	}
	
	public ViewMode getViewMode()
	{
		return viewMode;
	}
	
	/**
     * Change settings.
	 * @param newSettings are new settings
	 * @param oldSettings are old settings, null to use mSettings
	 */
	public void setSettings(Properties newSettings, Properties oldSettings)
	{
		Log.v(""cr3"", ""setSettings() "" + newSettings.toString());
		BackgroundThread.ensureGUI();
		if ( oldSettings==null )
			oldSettings = mSettings;
		final Properties currSettings = new Properties(oldSettings);
		setAppSettings( newSettings, currSettings );
		Properties changedSettings = newSettings.diff(currSettings);
		currSettings.setAll(changedSettings);
    	mBackThread.executeBackground(new Runnable() {
    		public void run() {
    			applySettings(currSettings);
    		}
    	});
//        }
	}

	private void setBackgroundTexture( String textureId ) {
		BackgroundTextureInfo[] textures = mEngine.getAvailableTextures();
		for ( BackgroundTextureInfo item : textures ) {
			if ( item.id.equals(textureId) ) {
				setBackgroundTexture( item );
				return;
			}
		}
		setBackgroundTexture( Engine.NO_TEXTURE );
	}

	private void setBackgroundTexture( BackgroundTextureInfo texture ) {
		if ( !currentBackgroundTexture.equals(texture) ) {
		Log.d(""cr3"", ""setBackgroundTexture( "" + texture + "" )"");
			currentBackgroundTexture = texture;
			byte[] data = mEngine.getImageData(currentBackgroundTexture);
			setPageBackgroundTextureInternal(data, texture.tiled ? 1 : 0);
		}
	}
	
	BackgroundTextureInfo currentBackgroundTexture = Engine.NO_TEXTURE;
	class CreateViewTask extends Task
	{
        Properties props = new Properties();
        public CreateViewTask( Properties props ) {
       		this.props = props;
       		Properties oldSettings = new Properties(); // may be changed by setAppSettings 
   			setAppSettings(props, oldSettings);
   			props.setAll(oldSettings);
       		mSettings = props;
        }
		public void work() throws Exception {
			BackgroundThread.ensureBackground();
			Log.d(""cr3"", ""CreateViewTask - in background thread"");
//			BackgroundTextureInfo[] textures = mEngine.getAvailableTextures();
//			byte[] data = mEngine.getImageData(textures[3]);
			byte[] data = mEngine.getImageData(currentBackgroundTexture);
			setPageBackgroundTextureInternal(data, currentBackgroundTexture.tiled?1:0);
			
			//File historyDir = activity.getDir(""settings"", Context.MODE_PRIVATE);
			//File historyDir = new File(Environment.getExternalStorageDirectory(), "".cr3"");
			//historyDir.mkdirs();
			//File historyFile = new File(historyDir, ""cr3hist.ini"");
			
			//File historyFile = new File(activity.getDir(""settings"", Context.MODE_PRIVATE), ""cr3hist.ini"");
			//if ( historyFile.exists() ) {
			//Log.d(""cr3"", ""Reading history from file "" + historyFile.getAbsolutePath());
			//readHistoryInternal(historyFile.getAbsolutePath());
			//}
	        String css = mEngine.loadResourceUtf8(R.raw.fb2);
	        if ( css!=null && css.length()>0 )
       			setStylesheetInternal(css);
   			applySettings(props);
   			mInitialized = true;
		}
		public void done() {
			Log.d(""cr3"", ""InitializationFinishedEvent"");
			BackgroundThread.ensureGUI();
	        //setSettings(props, new Properties());
		}
		public void fail( Exception e )
		{
			Log.e(""cr3"", ""CoolReader engine initialization failed. Exiting."", e);
			mEngine.fatalError(""Failed to init CoolReader engine"");
		}
	}

	public void closeIfOpened( final FileInfo fileInfo )
	{
		if ( this.mBookInfo!=null && this.mBookInfo.getFileInfo().pathname.equals(fileInfo.pathname) && mOpened ) {
			close();
		}
	}
	
	public void loadDocument( final FileInfo fileInfo )
	{
		if ( this.mBookInfo!=null && this.mBookInfo.getFileInfo().pathname.equals(fileInfo.pathname) && mOpened ) {
			Log.d(""cr3"", ""trying to load already opened document"");
			mActivity.showReader();
			drawPage();
			return;
		}
		post(new LoadDocumentTask(fileInfo, null));
	}

	public boolean loadLastDocument( final Runnable errorHandler )
	{
		BackgroundThread.ensureGUI();
		//BookInfo book = mActivity.getHistory().getLastBook();
		String lastBookName = mActivity.getLastSuccessfullyOpenedBook();
		Log.i(""cr3"", ""loadLastDocument() is called, lastBookName = "" + lastBookName);
		return loadDocument( lastBookName, errorHandler );
	}
	
	public boolean loadDocument( String fileName, final Runnable errorHandler )
	{
		BackgroundThread.ensureGUI();
		Log.i(""cr3"", ""loadDocument("" + fileName + "")"");
		if ( fileName==null ) {
			Log.v(""cr3"", ""loadDocument() : no filename specified"");
			errorHandler.run();
			return false;
		}
		BookInfo book = fileName!=null ? mActivity.getHistory().getBookInfo(fileName) : null;
		if ( book!=null )
			Log.v(""cr3"", ""loadDocument() : found book in history : "" + book);
		FileInfo fi = null;
		if ( book==null ) {
			Log.v(""cr3"", ""loadDocument() : book not found in history, looking for location directory"");
			FileInfo dir = mActivity.getScanner().findParent(new FileInfo(fileName), mActivity.getScanner().getRoot());
			if ( dir!=null ) {
				Log.v(""cr3"", ""loadDocument() : document location found : "" + dir);
				fi = dir.findItemByPathName(fileName);
				Log.v(""cr3"", ""loadDocument() : item inside location : "" + fi);
			}
			if ( fi==null ) {
				Log.v(""cr3"", ""loadDocument() : no file item "" + fileName + "" found inside "" + dir);
				errorHandler.run();
				return false;
			}
			if ( fi.isDirectory ) {
				Log.v(""cr3"", ""loadDocument() : is a directory, opening browser"");
				mActivity.showBrowser(fi);
				return true;
			}
		} else {
			fi = book.getFileInfo();
			Log.v(""cr3"", ""loadDocument() : item from history : "" + fi);
		}
		post( new LoadDocumentTask(fi, errorHandler) );
		Log.v(""cr3"", ""loadDocument: LoadDocumentTask("" + fi + "") is posted"");
		return true;
	}
	
	public BookInfo getBookInfo() {
		BackgroundThread.ensureGUI();
		return mBookInfo;
	}
	
	
	private int mBatteryState = 100;
	public void setBatteryState( int state ) {
		mBatteryState = state;
		drawPage();
	}
	
	private static class BitmapFactory {
		public static final int MAX_FREE_LIST_SIZE=2;
		ArrayList<Bitmap> freeList = new ArrayList<Bitmap>(); 
		ArrayList<Bitmap> usedList = new ArrayList<Bitmap>(); 
		public synchronized Bitmap get( int dx, int dy ) {
			for ( int i=0; i<freeList.size(); i++ ) {
				Bitmap bmp = freeList.get(i);
				if ( bmp.getWidth()==dx && bmp.getHeight()==dy ) {
					// found bitmap of proper size
					freeList.remove(i);
					usedList.add(bmp);
					//Log.d(""cr3"", ""BitmapFactory: reused free bitmap, used list = "" + usedList.size() + "", free list="" + freeList.size());
					return bmp;
				}
			}
			for ( int i=freeList.size()-1; i>=0; i-- ) {
				Bitmap bmp = freeList.remove(i);
				//Log.d(""cr3"", ""Recycling free bitmap ""+bmp.getWidth()+""x""+bmp.getHeight());
				bmp.recycle(); 
			}
			Bitmap bmp = Bitmap.createBitmap(dx, dy, Bitmap.Config.RGB_565);
			//bmp.setDensity(0);
			usedList.add(bmp);
			//Log.d(""cr3"", ""Created new bitmap ""+dx+""x""+dy+"". New bitmap list size = "" + usedList.size());
			return bmp;
		}
		public synchronized void compact() {
			while ( freeList.size()>0 ) {
				freeList.get(0).recycle();
				freeList.remove(0);
			}
		}
		public synchronized void release( Bitmap bmp ) {
			for ( int i=0; i<usedList.size(); i++ ) {
				if ( usedList.get(i)==bmp ) {
					freeList.add(bmp);
					usedList.remove(i);
					while ( freeList.size()>MAX_FREE_LIST_SIZE ) {
						freeList.get(0).recycle();
						freeList.remove(0);
					}
					Log.d(""cr3"", ""BitmapFactory: bitmap released, used size = "" + usedList.size() + "", free size="" + freeList.size());
					return;
				}
			}
			// unknown bitmap, just recycle
			bmp.recycle();
		}
	};
	BitmapFactory factory = new BitmapFactory(); 
	
	class BitmapInfo {
		Bitmap bitmap;
		PositionProperties position;
		void recycle()
		{
			factory.release(bitmap);
			bitmap = null;
			position = null;
		}
		@Override
		public String toString() {
			return ""BitmapInfo [position="" + position + ""]"";
		}
		
	}
	
    private BitmapInfo mCurrentPageInfo;
    private BitmapInfo mNextPageInfo;
	/**
	 * Prepare and cache page image.
	 * Cache is represented by two slots: mCurrentPageInfo and mNextPageInfo.  
	 * If page already exists in cache, returns it (if current page requested, 
	 *  ensures that it became stored as mCurrentPageInfo; if another page requested, 
	 *  no mCurrentPageInfo/mNextPageInfo reordering made).
	 * @param offset is kind of page: 0==current, -1=previous, 1=next page
	 * @return page image and properties, null if requested page is unavailable (e.g. requested next/prev page is out of document range)
	 */
	private BitmapInfo preparePageImage( int offset )
	{
		BackgroundThread.ensureBackground();
		Log.v(""cr3"", ""preparePageImage( ""+offset+"")"");
		if ( invalidImages ) {
			if ( mCurrentPageInfo!=null )
				mCurrentPageInfo.recycle();
			mCurrentPageInfo = null;
			if ( mNextPageInfo!=null )
				mNextPageInfo.recycle();
			mNextPageInfo = null;
			invalidImages = false;
		}

		if ( internalDX==0 || internalDY==0 ) {
			internalDX=200;
			internalDY=300;
	        resizeInternal(internalDX, internalDY);
		}
		
		PositionProperties currpos = getPositionPropsInternal(null);
		
		boolean isPageView = currpos.pageMode!=0;
		
		BitmapInfo currposBitmap = null;
		if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(currpos) )
			currposBitmap = mCurrentPageInfo;
		else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(currpos) )
			currposBitmap = mNextPageInfo;
		if ( offset==0 ) {
			// Current page requested
			if ( currposBitmap!=null ) {
				if ( mNextPageInfo==currposBitmap ) {
					// reorder pages
					BitmapInfo tmp = mNextPageInfo;
					mNextPageInfo = mCurrentPageInfo;
					mCurrentPageInfo = tmp;
				}
				// found ready page image
				return mCurrentPageInfo;
			}
			if ( mCurrentPageInfo!=null ) {
				mCurrentPageInfo.recycle();
				mCurrentPageInfo = null;
			}
			BitmapInfo bi = new BitmapInfo();
	        bi.position = currpos;
			bi.bitmap = factory.get(internalDX, internalDY);
	        setBatteryStateInternal(mBatteryState);
	        getPageImageInternal(bi.bitmap);
	        mCurrentPageInfo = bi;
	        //Log.v(""cr3"", ""Prepared new current page image "" + mCurrentPageInfo);
	        return mCurrentPageInfo;
		}
		if ( isPageView ) {
			// PAGES: one of next or prev pages requested, offset is specified as param 
			int cmd1 = offset > 0 ? ReaderCommand.DCMD_PAGEDOWN.nativeId : ReaderCommand.DCMD_PAGEUP.nativeId;
			int cmd2 = offset > 0 ? ReaderCommand.DCMD_PAGEUP.nativeId : ReaderCommand.DCMD_PAGEDOWN.nativeId;
			if ( offset<0 )
				offset = -offset;
			if ( doCommandInternal(cmd1, offset) ) {
				// can move to next page
				PositionProperties nextpos = getPositionPropsInternal(null);
				BitmapInfo nextposBitmap = null;
				if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
					nextposBitmap = mCurrentPageInfo;
				else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
					nextposBitmap = mNextPageInfo;
				if ( nextposBitmap==null ) {
					// existing image not found in cache, overriding mNextPageInfo
					if ( mNextPageInfo!=null )
						mNextPageInfo.recycle();
					mNextPageInfo = null;
					BitmapInfo bi = new BitmapInfo();
			        bi.position = nextpos;
					bi.bitmap = factory.get(internalDX, internalDY);
			        setBatteryStateInternal(mBatteryState);
			        getPageImageInternal(bi.bitmap);
			        mNextPageInfo = bi;
			        nextposBitmap = bi;
			        //Log.v(""cr3"", ""Prepared new current page image "" + mNextPageInfo);
				}
				// return back to previous page
				doCommandInternal(cmd2, offset);
				return nextposBitmap;
			} else {
				// cannot move to page: out of document range
				return null;
			}
		} else {
			// SCROLL next or prev page requested, with pixel offset specified
			int y = currpos.y + offset;
			if ( doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, y) ) {
				PositionProperties nextpos = getPositionPropsInternal(null);
				BitmapInfo nextposBitmap = null;
				if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
					nextposBitmap = mCurrentPageInfo;
				else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
					nextposBitmap = mNextPageInfo;
				if ( nextposBitmap==null ) {
					// existing image not found in cache, overriding mNextPageInfo
					if ( mNextPageInfo!=null )
						mNextPageInfo.recycle();
					mNextPageInfo = null;
					BitmapInfo bi = new BitmapInfo();
			        bi.position = nextpos;
					bi.bitmap = factory.get(internalDX, internalDY);
			        setBatteryStateInternal(mBatteryState);
			        getPageImageInternal(bi.bitmap);
			        mNextPageInfo = bi;
			        nextposBitmap = bi;
				}
				// return back to prev position
				doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, currpos.y);
				return nextposBitmap;
			} else {
				return null;
			}
		}
		
	}
	
	private int lastDrawTaskId = 0;
	private class DrawPageTask extends Task {
		final int id;
		BitmapInfo bi;
		Runnable doneHandler;
		DrawPageTask(Runnable doneHandler)
		{
			this.id = ++lastDrawTaskId;
			this.doneHandler = doneHandler;
		}
		public void work() {
			BackgroundThread.ensureBackground();
			if ( this.id!=lastDrawTaskId ) {
				Log.d(""cr3"", ""skipping duplicate drawPage request"");
				return;
			}
			nextHiliteId++;
			if ( currentAnimation!=null ) {
				Log.d(""cr3"", ""skipping drawPage request while scroll animation is in progress"");
				return;
			}
			Log.e(""cr3"", ""DrawPageTask.work(""+internalDX+"",""+internalDY+"")"");
			bi = preparePageImage(0);
			if ( bi!=null ) {
				draw();
			}
		}
		@Override
		public void done()
		{
			BackgroundThread.ensureGUI();
//			Log.d(""cr3"", ""drawPage : bitmap is ready, invalidating view to draw new bitmap"");
//			if ( bi!=null ) {
//				setBitmap( bi.bitmap );
//				invalidate();
//			}
//    		if (mOpened)
   			mEngine.hideProgress();
   			if ( doneHandler!=null )
   				doneHandler.run();
		}
		@Override
		public void fail(Exception e) {
   			mEngine.hideProgress();
		}
	};
	
	class ReaderSurfaceView extends SurfaceView {
		public ReaderSurfaceView( Context context )
		{
			super(context);
		}
	}
	
	// SurfaceView callbacks
	@Override
	public void surfaceChanged(SurfaceHolder holder, int format, int width,
			int height) {
		Log.i(""cr3"", ""surfaceChanged("" + width + "", "" + height + "")"");
		drawPage();
	}

	boolean mSurfaceCreated = false;
	@Override
	public void surfaceCreated(SurfaceHolder holder) {
		Log.i(""cr3"", ""surfaceCreated()"");
		mSurfaceCreated = true;
		drawPage();
	}

	@Override
	public void surfaceDestroyed(SurfaceHolder holder) {
		Log.i(""cr3"", ""surfaceDestroyed()"");
		mSurfaceCreated = false;
	}
	
	enum AnimationType {
		SCROLL, // for scroll mode
		PAGE_SHIFT, // for simple page shift
	}

	
	
	private ViewAnimationControl currentAnimation = null;

	private int pageFlipAnimationSpeedMs = DEF_PAGE_FLIP_MS; // if 0 : no animation
	private int pageFlipAnimationMode = PAGE_ANIMATION_PAPER; // if 0 : no animation
	private void animatePageFlip( final int dir ) {
		animatePageFlip(dir, null);
	}
	private void animatePageFlip( final int dir, final Runnable onFinishHandler )
	{
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				BackgroundThread.ensureBackground();
				if ( currentAnimation==null ) {
					PositionProperties currPos = getPositionPropsInternal(null);
					if ( currPos==null )
						return;
					int w = currPos.pageWidth;
					int h = currPos.pageHeight;
					int dir2 = dir;
//					if ( currPos.pageMode==2 )
//						if ( dir2==1 )
//							dir2 = 2;
//						else if ( dir2==-1 ) 
//							dir2 = -2;
					int speed = pageFlipAnimationSpeedMs;
					if ( onFinishHandler!=null )
						speed = pageFlipAnimationSpeedMs / 2;
					if ( currPos.pageMode!=0 ) {
						int fromX = dir2>0 ? w : 0;
						int toX = dir2>0 ? 0 : w;
						new PageViewAnimation(fromX, w, dir2);
						if ( currentAnimation!=null ) {
							if ( currentAnimation!=null ) {
								nextHiliteId++;
								hiliteRect = null;
							}
							currentAnimation.update(toX, h/2);
							currentAnimation.move(speed, true);
							currentAnimation.stop(-1, -1);
							if ( onFinishHandler!=null )
								BackgroundThread.guiExecutor.execute(onFinishHandler);
						}
					} else {
						//new ScrollViewAnimation(startY, maxY);
						int fromY = dir>0 ? h*7/8 : 0;
						int toY = dir>0 ? 0 : h*7/8;
						new ScrollViewAnimation(fromY, h);
						if ( currentAnimation!=null ) {
							if ( currentAnimation!=null ) {
								nextHiliteId++;
								hiliteRect = null;
								
							}
							currentAnimation.update(w/2, toY);
							currentAnimation.move(speed, true);
							currentAnimation.stop(-1, -1);
							if ( onFinishHandler!=null )
								BackgroundThread.guiExecutor.execute(onFinishHandler);
						}
					}
				}
			}
		});
	}
	
	static private Rect tapZoneBounds( int startX, int startY, int maxX, int maxY ) {
		if ( startX<0 )
			startX=0;
		if ( startY<0 )
			startY = 0;
		if ( startX>maxX )
			startX = maxX;
		if ( startY>maxY)
			startY = maxY;
		int dx = (maxX + 2) / 3;
		int dy = (maxY + 2) / 3;
		int x0 = startX / dx * dx; 
		int y0 = startY / dy * dy;
		return new Rect(x0, y0, x0+dx, y0+dy);
	}
	
	volatile private int nextHiliteId = 0;
	private final static int HILITE_RECT_ALPHA = 32;
	private Rect hiliteRect = null;
	private void unhiliteTapZone() {
		hiliteTapZone( false, 0, 0, getWidth(), getHeight() );
	}
	private void hiliteTapZone( final boolean hilite, final int startX, final int startY, final int maxX, final int maxY )
	{
		if (DEBUG_ANIMATION) Log.d(""cr3"", ""highliteTapZone(""+startX + "", "" + startY+"")"");
		final int myHiliteId = ++nextHiliteId;
		int txcolor = mSettings.getColor(PROP_FONT_COLOR, Color.BLACK);
		final int color = (txcolor & 0xFFFFFF) | (HILITE_RECT_ALPHA<<24);
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( myHiliteId != nextHiliteId || (!hilite && hiliteRect==null) )
					return;
				BackgroundThread.ensureBackground();
				final BitmapInfo pageImage = preparePageImage(0);
				if ( pageImage!=null && pageImage.bitmap!=null && pageImage.position!=null ) {
					//PositionProperties currPos = pageImage.position;
					final Rect rc = hilite ? tapZoneBounds( startX, startY, maxX, maxY ) : hiliteRect;
					if ( hilite )
						hiliteRect = rc;
					else
						hiliteRect = null;
					if ( rc!=null )
					drawCallback( new DrawCanvasCallback() {
						@Override
						public void drawTo(Canvas canvas) {
				    		if ( mInitialized && mCurrentPageInfo!=null ) {
				        		Log.d(""cr3"", ""onDraw() -- drawing page image"");
				    			canvas.drawBitmap(mCurrentPageInfo.bitmap, rc, rc, null);
				    			if ( hilite ) {
					    			Paint p = new Paint();
					    			p.setColor(color);
					    			if ( true ) {
					    				canvas.drawRect(new Rect(rc.left, rc.top, rc.right-2, rc.top+2), p);
					    				canvas.drawRect(new Rect(rc.left, rc.top+2, rc.left+2, rc.bottom-2), p);
					    				canvas.drawRect(new Rect(rc.right-2-2, rc.top+2, rc.right-2, rc.bottom-2), p);
					    				canvas.drawRect(new Rect(rc.left+2, rc.bottom-2-2, rc.right-2-2, rc.bottom-2), p);
					    			} else {
					    				canvas.drawRect(rc, p);
					    			}
				    			}
				    		}
						}
						
					}, rc);
				}
			}
			
		});
	}
	private void scheduleUnhilite( int delay ) {
		final int myHiliteId = nextHiliteId;
		mBackThread.postGUI(new Runnable() {
			@Override
			public void run() {
				if ( myHiliteId == nextHiliteId && hiliteRect!=null )
					unhiliteTapZone(); 
			}
		}, delay);
	}
	
	private void startAnimation( final int startX, final int startY, final int maxX, final int maxY )
	{
		if (DEBUG_ANIMATION) Log.d(""cr3"", ""startAnimation(""+startX + "", "" + startY+"")"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				BackgroundThread.ensureBackground();
				PositionProperties currPos = getPositionPropsInternal(null);
				if ( currPos.pageMode!=0 ) {
					//int dir = startX > maxX/2 ? currPos.pageMode : -currPos.pageMode;
					int dir = startX > maxX/2 ? 1 : -1;
					int sx = startX;
					if ( dir<0 )
						sx = 0;
					new PageViewAnimation(sx, maxX, dir);
				} else {
					new ScrollViewAnimation(startY, maxY);
				}
				if ( currentAnimation!=null ) {
					nextHiliteId++;
					hiliteRect = null;
				}
			}
			
		});
	}

	
	private final static boolean DEBUG_ANIMATION = false;
	private int updateSerialNumber = 0;
	private void updateAnimation( final int x, final int y )
	{
		if (DEBUG_ANIMATION) Log.d(""cr3"", ""updateAnimation(""+x + "", "" + y+"")"");
		final int serial = ++updateSerialNumber;
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( currentAnimation!=null ) {
					currentAnimation.update(x, y);
					if ( serial==updateSerialNumber ) //|| serial==updateSerialNumber-1 
						currentAnimation.animate();
				}
			}
		});
		try {
			// give a chance to background thread to process event faster
			Thread.sleep(0);
		} catch ( InterruptedException e ) {
			// ignore
		}
	}
	
	private void stopAnimation( final int x, final int y )
	{
		if (DEBUG_ANIMATION) Log.d(""cr3"", ""stopAnimation(""+x+"", ""+y+"")"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( currentAnimation!=null ) {
					currentAnimation.stop(x, y);
				}
			}
			
		});
	}

	private int animationSerialNumber = 0;
	private void scheduleAnimation()
	{
		final int serial = ++animationSerialNumber; 
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( serial!=animationSerialNumber )
					return;
				if ( currentAnimation!=null ) {
					currentAnimation.animate();
				}
			}
		});
	}
	
	interface ViewAnimationControl
	{
		public void update( int x, int y );
		public void stop( int x, int y );
		public void animate();
		public void move( int duration, boolean accelerated );
		public boolean isStarted();
	}

	private Object surfaceLock = new Object(); 

	private static final int[] accelerationShape = new int[] {
		0, 6, 24, 54, 95, 146, 206, 273, 345, 421, 500, 578, 654, 726, 793, 853, 904, 945, 975, 993, 1000  
	};
	static public int accelerate( int x0, int x1, int x )
	{
		if ( x<x0 )
			x = x0;
		if (x>x1)
			x = x1;
		int intervals = accelerationShape.length - 1;
		int pos = 100 * intervals * (x - x0) / (x1-x0);
		int interval = pos / 100;
		int part = pos % 100;
		if ( interval<0 )
			interval = 0;
		else if ( interval>intervals )
			interval = intervals;
		int y = interval==intervals ? 100000 : accelerationShape[interval]*100 + (accelerationShape[interval+1]-accelerationShape[interval]) * part;
		return x0 + (x1 - x0) * y / 100000;
	}

	private interface DrawCanvasCallback {
		public void drawTo( Canvas c );
	}
	private void drawCallback( DrawCanvasCallback callback, Rect rc )
	{
		if ( !mSurfaceCreated )
			return;
		//synchronized(surfaceLock) { }
		//Log.v(""cr3"", ""draw() - in thread "" + Thread.currentThread().getName());
		final SurfaceHolder holder = getHolder();
		//Log.v(""cr3"", ""before synchronized(surfaceLock)"");
		if ( holder!=null )
		//synchronized(surfaceLock) 
		{
			Canvas canvas = null;
			try {
				long startTs = android.os.SystemClock.uptimeMillis();
				canvas = holder.lockCanvas(rc);
				//Log.v(""cr3"", ""before draw(canvas)"");
				if ( canvas!=null ) {
					callback.drawTo(canvas);
					if ( rc==null ) {
						long endTs = android.os.SystemClock.uptimeMillis();
						updateAnimationDurationStats(endTs - startTs);
					}
				}
			} finally {
				//Log.v(""cr3"", ""exiting finally"");
				if ( canvas!=null && getHolder()!=null ) {
					//Log.v(""cr3"", ""before unlockCanvasAndPost"");
					if ( canvas!=null && holder!=null )
						holder.unlockCanvasAndPost(canvas);
					//Log.v(""cr3"", ""after unlockCanvasAndPost"");
				}
			}
		}
		//Log.v(""cr3"", ""exiting draw()"");
	}
	
	abstract class ViewAnimationBase implements ViewAnimationControl {
		long startTimeStamp;
		boolean started;
		public boolean isStarted()
		{
			return started;
		}
		ViewAnimationBase()
		{
			startTimeStamp = android.os.SystemClock.uptimeMillis();
		}
		public void close()
		{
			currentAnimation = null;
		}

		

		public void draw()
		{
			drawCallback( new DrawCanvasCallback() {
				@Override
				public void drawTo(Canvas c) {
					draw(c);
				}
				
			}, null);
		}
		abstract void draw( Canvas canvas );
	}
	
	class ScrollViewAnimation extends ViewAnimationBase {
		int startY;
		int maxY;
		int pointerStartPos;
		int pointerDestPos;
		int pointerCurrPos;
		ScrollViewAnimation( int startY, int maxY )
		{
			super();
			this.startY = startY;
			this.maxY = maxY;
			long start = android.os.SystemClock.uptimeMillis();
			Log.v(""cr3"", ""ScrollViewAnimation -- creating: drawing two pages to buffer"");
			PositionProperties currPos = getPositionPropsInternal(null);
			int pos = currPos.y;
			int pos0 = pos - (maxY - startY);
			if ( pos0<0 )
				pos0 = 0;
			pointerStartPos = pos;
			pointerCurrPos = pos;
			pointerDestPos = startY;
			BitmapInfo image1;
			BitmapInfo image2;
			doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pos0);
			image1 = preparePageImage(0);
			image2 = preparePageImage(image1.position.pageHeight);
//			doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pos0 + image1.position.pageHeight);
//			image2 = preparePageImage(0);
			doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pos);
			if ( image1==null || image2==null ) {
				Log.v(""cr3"", ""ScrollViewAnimation -- not started: image is null"");
				return;
			}
			long duration = android.os.SystemClock.uptimeMillis() - start;
			Log.v(""cr3"", ""ScrollViewAnimation -- created in "" + duration + "" millis"");
			currentAnimation = this;
		}
		
		@Override
		public void stop(int x, int y) {
			//if ( started ) {
				if ( y!=-1 ) {
					int delta = startY - y;
					pointerCurrPos = pointerStartPos + delta;
				}
				pointerDestPos = pointerCurrPos;
				draw();
				doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pointerDestPos);
			//}
			close();
		}

		@Override
		public void move( int duration, boolean accelerated  ) {
			if ( duration>0 ) {
				int steps = (int)(duration / getAvgAnimationDrawDuration()) + 2;
				int x0 = pointerCurrPos;
				int x1 = pointerDestPos;
				if ( (x0-x1)<10 && (x0-x1)>-10 )
					steps = 2;
				for ( int i=1; i<steps; i++ ) {
					int x = x0 + (x1-x0) * i / steps;
					pointerCurrPos = accelerated ? accelerate( x0, x1, x ) : x; 
					draw();
				}
			}
			pointerCurrPos = pointerDestPos; 
			draw();
		}

		@Override
		public void update(int x, int y) {
			int delta = startY - y;
			pointerDestPos = pointerStartPos + delta;
		}

		public void animate()
		{
			//Log.d(""cr3"", ""animate() is called"");
			if ( pointerDestPos != pointerCurrPos ) {
				if ( !started )
					started = true;
				// TODO
				int delta = pointerCurrPos-pointerDestPos;
				if ( delta<0 )
					delta = -delta;
				long avgDraw = getAvgAnimationDrawDuration();
				int maxStep = (int)(maxY * 1500 / avgDraw);
				int step;
				if ( delta > maxStep * 2 )
					step = maxStep;
				else
					step = (delta + 3) / 4;
				//int step = delta<3 ? 1 : (delta<5 ? 2 : (delta<10 ? 3 : (delta<15 ? 6 : (delta<25 ? 10 : (delta<50 ? 15 : 30))))); 
				if ( pointerCurrPos<pointerDestPos )
					pointerCurrPos+=step;
				else if ( pointerCurrPos>pointerDestPos )
					pointerCurrPos-=step;
				Log.d(""cr3"", ""animate(""+pointerCurrPos + "" => "" + pointerDestPos + ""  step="" + step + "")"");
				//pointerCurrPos = pointerDestPos;
				draw();
				if ( pointerDestPos != pointerCurrPos )
					scheduleAnimation();
			}
		}

		public void draw(Canvas canvas)
		{
			BitmapInfo image1 = mCurrentPageInfo;
			BitmapInfo image2 = mNextPageInfo;
			int h = image1.position.pageHeight;
			int rowsFromImg1 = image1.position.y + h - pointerCurrPos;
			int rowsFromImg2 = h - rowsFromImg1;
    		Rect src1 = new Rect(0, h-rowsFromImg1, mCurrentPageInfo.bitmap.getWidth(), h);
    		Rect dst1 = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), rowsFromImg1);
			canvas.drawBitmap(image1.bitmap, src1, dst1, null);
			if (image2!=null) {
	    		Rect src2 = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), rowsFromImg2);
	    		Rect dst2 = new Rect(0, rowsFromImg1, mCurrentPageInfo.bitmap.getWidth(), h);
				canvas.drawBitmap(image2.bitmap, src2, dst2, null);
			}
			//Log.v(""cr3"", ""anim.drawScroll( pos="" + pointerCurrPos + "", "" + src1 + ""=>"" + dst1 + "", "" + src2 + ""=>"" + dst2 + "" )"");
		}
	}

	class PageViewAnimation extends ViewAnimationBase {
		int startX;
		int maxX;
		int page1;
		int page2;
		int direction;
		int currShift;
		int destShift;
		int pageCount;
		private final boolean naturalPageFlip; 
		PageViewAnimation( int startX, int maxX, int direction )
		{
			super();
			this.startX = startX;
			this.maxX = maxX;
			this.direction = direction;
			this.currShift = 0;
			this.destShift = 0;
			this.naturalPageFlip = (pageFlipAnimationMode==PAGE_ANIMATION_PAPER);
			
			long start = android.os.SystemClock.uptimeMillis();
			Log.v(""cr3"", ""PageViewAnimation -- creating: drawing two pages to buffer"");
			
			PositionProperties currPos = mCurrentPageInfo.position;
			if ( currPos==null )
				currPos = getPositionPropsInternal(null);
			page1 = currPos.pageNumber;
			page2 = currPos.pageNumber + direction;
			if ( page2<0 || page2>=currPos.pageCount) {
				currentAnimation = null;
				return;
			}
			this.pageCount = currPos.pageMode;
			BitmapInfo image1 = preparePageImage(0);
			BitmapInfo image2 = preparePageImage(direction);
			if ( image1==null || image2==null ) {
				Log.v(""cr3"", ""PageViewAnimation -- cannot start animation: page image is null"");
				return;
			}
			if ( page1==page2 ) {
				Log.v(""cr3"", ""PageViewAnimation -- cannot start animation: not moved"");
				return;
			}
			page2 = image2.position.pageNumber;
			currentAnimation = this;
			divPaint = new Paint();
			divPaint.setColor(Color.argb(128, 128, 128, 128));

			long duration = android.os.SystemClock.uptimeMillis() - start;
			Log.d(""cr3"", ""PageViewAnimation -- created in "" + duration + "" millis"");
		}
		
		@Override
		public void move( int duration, boolean accelerated ) {
			if ( duration > 0 ) {
				int steps = (int)(duration / getAvgAnimationDrawDuration()) + 2;
				int x0 = currShift;
				int x1 = destShift;
				if ( (x0-x1)<10 && (x0-x1)>-10 )
					steps = 2;
				for ( int i=1; i<steps; i++ ) {
					int x = x0 + (x1-x0) * i / steps;
					currShift = accelerated ? accelerate( x0, x1, x ) : x;
					draw();
				}
			}
			currShift = destShift;
			draw();
		}

		@Override
		public void stop(int x, int y) {
			if (DEBUG_ANIMATION) Log.v(""cr3"", ""PageViewAnimation.stop("" + x + "", "" + y + "")"");
			//if ( started ) {
				boolean moved = false;
				if ( x!=-1 ) {
					int threshold = mActivity.getPalmTipPixels() * 7/8;
					if ( direction>0 ) {
						// |  <=====  |
						int dx = startX - x; 
						if ( dx>threshold )
							moved = true;
					} else {
						// |  =====>  |
						int dx = x - startX; 
						if ( dx>threshold )
							moved = true;
					}
					int duration;
					if ( moved ) {
						destShift = maxX;
						duration = 500; // 500 ms forward
					} else {
						destShift = 0;
						duration = 200; // 200 ms cancel
					}
					move( duration, false );
				} else {
					moved = true;
				}
				doCommandInternal(ReaderCommand.DCMD_GO_PAGE.nativeId, moved ? page2 : page1);
			//}
			close();
			// preparing images for next page flip
			preparePageImage(0);
			preparePageImage(direction);
			//if ( started )
			//	drawPage();
		}

		@Override
		public void update(int x, int y) {
			if (DEBUG_ANIMATION) Log.v(""cr3"", ""PageViewAnimation.update("" + x + "", "" + y + "")"");
			int delta = direction>0 ? startX - x : x - startX;
			if ( delta<=0 )
				destShift = 0;
			else if ( delta<maxX )
				destShift = delta;
			else
				destShift = maxX;
		}

		public void animate()
		{
			if (DEBUG_ANIMATION) Log.v(""cr3"", ""PageViewAnimation.animate(""+currShift + "" => "" + currShift + "")"");
			//Log.d(""cr3"", ""animate() is called"");
			if ( currShift != destShift ) {
				started = true;
				int delta = currShift - destShift;
				if ( delta<0 )
					delta = -delta;
				long avgDraw = getAvgAnimationDrawDuration();
				int maxStep = (int)(maxX * 1500 / avgDraw);
				int step;
				if ( delta > maxStep * 2 )
					step = maxStep;
				else
					step = (delta + 3) / 4;
				//int step = delta<3 ? 1 : (delta<5 ? 2 : (delta<10 ? 3 : (delta<15 ? 6 : (delta<25 ? 10 : (delta<50 ? 15 : 30))))); 
				if ( currShift < destShift )
					currShift+=step;
				else if ( currShift > destShift )
					currShift-=step;
				if (DEBUG_ANIMATION) Log.v(""cr3"", ""PageViewAnimation.animate(""+currShift + "" => "" + destShift + ""  step="" + step + "")"");
				//pointerCurrPos = pointerDestPos;
				draw();
				if ( currShift != destShift )
					scheduleAnimation();
			}
		}

		public void draw(Canvas canvas)
		{
			if (DEBUG_ANIMATION) Log.v(""cr3"", ""PageViewAnimation.draw(""+currShift + "")"");
			BitmapInfo image1 = mCurrentPageInfo;
			BitmapInfo image2 = mNextPageInfo;
			int w = image1.bitmap.getWidth(); 
			int h = image1.bitmap.getHeight();
			int div;
			if ( direction > 0 ) {
				// FORWARD
				div = w-currShift;
				if ( naturalPageFlip ) {
					if ( this.pageCount==2 ) {
						int w2 = w/2;
						if ( div<w2 ) {
							// left - part of old page
				    		Rect src1 = new Rect(0, 0, div, h);
				    		Rect dst1 = new Rect(0, 0, div, h);
							canvas.drawBitmap(image1.bitmap, src1, dst1, null);
							// left, resized part of new page
				    		Rect src2 = new Rect(0, 0, w2, h);
				    		Rect dst2 = new Rect(div, 0, w2, h);
				    		canvas.drawBitmap(image2.bitmap, src2, dst2, null);
							// right, new page
				    		Rect src3 = new Rect(w2, 0, w, h);
				    		Rect dst3 = new Rect(w2, 0, w, h);
				    		canvas.drawBitmap(image2.bitmap, src3, dst3, null);
						} else {
							// left - old page
				    		Rect src1 = new Rect(0, 0, w2, h);
				    		Rect dst1 = new Rect(0, 0, w2, h);
							canvas.drawBitmap(image1.bitmap, src1, dst1, null);
							// right, resized old page
				    		Rect src2 = new Rect(w2, 0, w, h);
				    		Rect dst2 = new Rect(w2, 0, div, h);
				    		canvas.drawBitmap(image1.bitmap, src2, dst2, null);
							// right, new page
				    		Rect src3 = new Rect(div, 0, w, h);
				    		Rect dst3 = new Rect(div, 0, w, h);
				    		canvas.drawBitmap(image2.bitmap, src3, dst3, null);
						}
					} else {
			    		Rect src1 = new Rect(0, 0, w, h);
			    		Rect dst1 = new Rect(0, 0, w-currShift, h);
			    		//Log.v(""cr3"", ""drawing "" + image1);
						canvas.drawBitmap(image1.bitmap, src1, dst1, null);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(w-currShift, 0, w, h);
			    		//Log.v(""cr3"", ""drawing "" + image1);
			    		canvas.drawBitmap(image2.bitmap, src2, dst2, null);
					}
				} else {
		    		Rect src1 = new Rect(currShift, 0, w, h);
		    		Rect dst1 = new Rect(0, 0, w-currShift, h);
		    		//Log.v(""cr3"", ""drawing "" + image1);
					canvas.drawBitmap(image1.bitmap, src1, dst1, null);
		    		Rect src2 = new Rect(w-currShift, 0, w, h);
		    		Rect dst2 = new Rect(w-currShift, 0, w, h);
		    		//Log.v(""cr3"", ""drawing "" + image1);
					canvas.drawBitmap(image2.bitmap, src2, dst2, null);
				}
			} else {
				// BACK
				div = currShift;
				if ( naturalPageFlip ) {
					if ( this.pageCount==2 ) {
						int w2 = w/2;
						if ( div<w2 ) {
							// left - part of old page
				    		Rect src1 = new Rect(0, 0, div, h);
				    		Rect dst1 = new Rect(0, 0, div, h);
							canvas.drawBitmap(image2.bitmap, src1, dst1, null);
							// left, resized part of new page
				    		Rect src2 = new Rect(0, 0, w2, h);
				    		Rect dst2 = new Rect(div, 0, w2, h);
				    		canvas.drawBitmap(image1.bitmap, src2, dst2, null);
							// right, new page
				    		Rect src3 = new Rect(w2, 0, w, h);
				    		Rect dst3 = new Rect(w2, 0, w, h);
				    		canvas.drawBitmap(image1.bitmap, src3, dst3, null);
						} else {
							// left - old page
				    		Rect src1 = new Rect(0, 0, w2, h);
				    		Rect dst1 = new Rect(0, 0, w2, h);
							canvas.drawBitmap(image2.bitmap, src1, dst1, null);
							// right, resized old page
				    		Rect src2 = new Rect(w2, 0, w, h);
				    		Rect dst2 = new Rect(w2, 0, div, h);
				    		canvas.drawBitmap(image2.bitmap, src2, dst2, null);
							// right, new page
				    		Rect src3 = new Rect(div, 0, w, h);
				    		Rect dst3 = new Rect(div, 0, w, h);
				    		canvas.drawBitmap(image1.bitmap, src3, dst3, null);
						}
					} else {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(currShift, 0, w, h);
						canvas.drawBitmap(image1.bitmap, src1, dst1, null);
			    		Rect src2 = new Rect(0, 0, w, h);
			    		Rect dst2 = new Rect(0, 0, currShift, h);
						canvas.drawBitmap(image2.bitmap, src2, dst2, null);
					}
				} else {
		    		Rect src1 = new Rect(currShift, 0, w, h);
		    		Rect dst1 = new Rect(currShift, 0, w, h);
					canvas.drawBitmap(image1.bitmap, src1, dst1, null);
		    		Rect src2 = new Rect(w-currShift, 0, w, h);
		    		Rect dst2 = new Rect(0, 0, currShift, h);
					canvas.drawBitmap(image2.bitmap, src2, dst2, null);
				}
			}
			if ( div>0 && div<w )
				canvas.drawLine(div, 0, div, h, divPaint);
		}
		Paint divPaint;
	}

	private long sumAnimationDrawDuration = 1000;
	private int drawAnimationCount = 10;
	private long getAvgAnimationDrawDuration()
	{
		return sumAnimationDrawDuration / drawAnimationCount; 
	}
	private void updateAnimationDurationStats( long duration )
	{
		if ( duration<=0 )
			duration = 1;
		else if ( duration>1500 )
			return;
		sumAnimationDrawDuration += duration;
		if ( ++drawAnimationCount>100 ) {
			drawAnimationCount /= 2;
			sumAnimationDrawDuration /= 2;
		}
	}
	
	private void drawPage()
	{
		drawPage(null);
	}
	private void drawPage( Runnable doneHandler )
	{
		if ( !mInitialized || !mOpened )
			return;
		Log.v(""cr3"", ""drawPage() : submitting DrawPageTask"");
		post( new DrawPageTask(doneHandler) );
	}
	
	private int internalDX = 0;
	private int internalDY = 0;

	private byte[] coverPageBytes = null;
	private BitmapDrawable coverPageDrawable = null;
	private void findCoverPage()
	{
    	Log.d(""cr3"", ""document is loaded succesfull, checking coverpage data"");
    	if ( mActivity.getHistory().getCoverPagesEnabled() ) {
	    	byte[] coverpageBytes = getCoverPageDataInternal();
	    	if ( coverpageBytes!=null ) {
	    		Log.d(""cr3"", ""Found cover page data: "" + coverpageBytes.length + "" bytes"");
	    		BitmapDrawable drawable = mActivity.getHistory().decodeCoverPage(coverpageBytes);
	    		if ( drawable!=null ) {
	    			coverPageBytes = coverpageBytes;
	    			coverPageDrawable = drawable;
	    		}
	    	}
    	}
	}
	
	private class LoadDocumentTask extends Task
	{
		String filename;
		Runnable errorHandler;
		String pos;
		LoadDocumentTask( FileInfo fileInfo, Runnable errorHandler )
		{
			Log.v(""cr3"", ""LoadDocumentTask for "" + fileInfo);
			BackgroundThread.ensureGUI();
			this.filename = fileInfo.getPathName();
			this.errorHandler = errorHandler;
			//FileInfo fileInfo = new FileInfo(filename);
			mBookInfo = mActivity.getHistory().getOrCreateBookInfo( fileInfo );
	    	if ( mBookInfo!=null && mBookInfo.getLastPosition()!=null )
	    		pos = mBookInfo.getLastPosition().getStartPos();
			Log.v(""cr3"", ""LoadDocumentTask : book info "" + mBookInfo);
    		//mBitmap = null;
	        mEngine.showProgress( 1000, R.string.progress_loading );
	        //init();
		}

		public void work() throws IOException {
			BackgroundThread.ensureBackground();
			coverPageBytes = null;
			coverPageDrawable = null;
			Log.i(""cr3"", ""Loading document "" + filename);
	        boolean success = loadDocumentInternal(filename);
	        if ( success ) {
				Log.v(""cr3"", ""loadDocumentInternal completed successfully"");
	        	findCoverPage();
				Log.v(""cr3"", ""requesting page image, to render"");
	        	preparePageImage(0);
				Log.v(""cr3"", ""updating loaded book info"");
	        	updateLoadedBookInfo();
				Log.i(""cr3"", ""Document "" + filename + "" is loaded successfully"");
				restorePositionBackground(pos);
				CoolReader.dumpHeapAllocation();
	        } else {
				Log.e(""cr3"", ""Error occured while trying to load document "" + filename);
				throw new IOException(""Cannot read document"");
	        }
		}
		public void done()
		{
			BackgroundThread.ensureGUI();
			Log.d(""cr3"", ""LoadDocumentTask, GUI thread is finished successfully"");
    		mActivity.getHistory().updateBookAccess(mBookInfo);
    		mActivity.getHistory().saveToDB();
	        if ( coverPageBytes!=null && coverPageDrawable!=null ) {
	        	mActivity.getHistory().setBookCoverpageData( mBookInfo.getFileInfo().id, coverPageBytes );
	        	//mEngine.setProgressDrawable(coverPageDrawable);
	        }
	        mOpened = true;
	        drawPage();
	        mBackThread.postGUI(new Runnable() {
	        	public void run() {
	    			mActivity.showReader();
	        	}
	        });
	        mActivity.setLastSuccessfullyOpenedBook(filename);
		}
		public void fail( Exception e )
		{
			BackgroundThread.ensureGUI();
			Log.e(""cr3"", ""LoadDocumentTask failed for "" + mBookInfo);
			mActivity.getHistory().removeBookInfo( mBookInfo.getFileInfo(), true, false );
			mBookInfo = null;
			Log.d(""cr3"", ""LoadDocumentTask is finished with exception "" + e.getMessage());
	        mOpened = false;
			drawPage();
			mEngine.hideProgress();
			mActivity.showToast(""Error while loading document"");
			if ( errorHandler!=null ) {
				Log.e(""cr3"", ""LoadDocumentTask: Calling error handler"");
				errorHandler.run();
			}
		}
	}

	protected void doDraw(Canvas canvas)
	{
       	try {
    		Log.d(""cr3"", ""doDraw() called"");
    		if ( mInitialized && mCurrentPageInfo!=null ) {
        		Log.d(""cr3"", ""onDraw() -- drawing page image"");
        		
        		Rect dst = new Rect(0, 0, canvas.getWidth(), canvas.getHeight());
        		Rect src = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), mCurrentPageInfo.bitmap.getHeight());
    			canvas.drawBitmap(mCurrentPageInfo.bitmap, src, dst, null);
    		} else {
        		Log.d(""cr3"", ""onDraw() -- drawing empty screen"");
    			canvas.drawColor(Color.rgb(192, 192, 192));
    		}
    	} catch ( Exception e ) {
    		Log.e(""cr3"", ""exception while drawing"", e);
    	}
	}
	
	protected void draw()
	{
		drawCallback(new DrawCanvasCallback() {
			@Override
			public void drawTo(Canvas c) {
				doDraw(c);
			}
		}, null);
	}
	
    @Override 
    protected void onDraw(Canvas canvas) {
    	try {
    		Log.d(""cr3"", ""onDraw() called"");
    		draw();
//    		if ( mInitialized && mBitmap!=null ) {
//        		Log.d(""cr3"", ""onDraw() -- drawing page image"");
//        		Rect rc = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());
//    			canvas.drawBitmap(mBitmap, rc, rc, null);
//    		} else {
//        		Log.d(""cr3"", ""onDraw() -- drawing empty screen"");
//    			canvas.drawColor(Color.rgb(192, 192, 192));
//    		}
    	} catch ( Exception e ) {
    		Log.e(""cr3"", ""exception while drawing"", e);
    	}
    }

    private void restorePositionBackground( String pos )
    {
		BackgroundThread.ensureBackground();
    	if ( pos!=null ) {
			BackgroundThread.ensureBackground();
    		goToPositionInternal( pos );
    		preparePageImage(0);
    	}
    }
    
//    private void restorePosition()
//    {
//		BackgroundThread.ensureGUI();
//    	if ( mBookInfo!=null ) {
//    		if ( mBookInfo.getLastPosition()!=null ) {
//	    		final String pos = mBookInfo.getLastPosition().getStartPos();
//	    		post( new Task() {
//	    			public void work() {
//	    				BackgroundThread.ensureBackground();
//	    	    		goToPositionInternal( pos );
//	    	    		preparePageImage(0);
//	    			}
//	    		});
//	    		mActivity.getHistory().updateBookAccess(mBookInfo);
//    		}
//    		mActivity.getHistory().saveToDB();
//    	}
//    }
    
//    private void savePosition()
//    {
//		BackgroundThread.ensureBackground();
//    	if ( !mOpened )
//    		return;
//    	Bookmark bmk = getCurrentPageBookmarkInternal();
//    	if ( bmk!=null )
//    		Log.d(""cr3"", ""saving position, bmk="" + bmk.getStartPos());
//    	else
//    		Log.d(""cr3"", ""saving position: no current page bookmark obtained"");
//    	if ( bmk!=null && mBookInfo!=null ) {
//        	bmk.setTimeStamp(System.currentTimeMillis());
//    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
//    		mBookInfo.setLastPosition(bmk);
//    		mActivity.getHistory().updateRecentDir();
//    		mActivity.getHistory().saveToDB();
//    		saveSettings();
//    	}
//    }
    
    private class SavePositionTask extends Task {

    	Bookmark bmk;
    	
		@Override
		public void done() {
	    	if ( bmk!=null && mBookInfo!=null ) {
	        	bmk.setTimeStamp(System.currentTimeMillis());
	    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
	    		mBookInfo.setLastPosition(bmk);
	    		mActivity.getHistory().updateRecentDir();
	    		mActivity.getHistory().saveToDB();
	    	}
		}

		public void work() throws Exception {
			BackgroundThread.ensureBackground();
	    	if ( !mOpened )
	    		return;
	    	bmk = getCurrentPageBookmarkInternal();
	    	if ( bmk!=null )
	    		Log.d(""cr3"", ""saving position, bmk="" + bmk.getStartPos());
	    	else
	    		Log.d(""cr3"", ""saving position: no current page bookmark obtained"");
		}
    	
    }

    public void save()
    {
		BackgroundThread.ensureGUI();
    	post( new SavePositionTask() );
    }
    
    public void close()
    {
		BackgroundThread.ensureGUI();
    	Log.i(""cr3"", ""ReaderView.close() is called"");
    	if ( !mOpened )
    		return;
		//save();
    	post( new Task() {
    		public void work() {
    			BackgroundThread.ensureBackground();
    			if ( mOpened ) {
	    			mOpened = false;
					Log.i(""cr3"", ""ReaderView().close() : closing current document"");
					doCommandInternal(ReaderCommand.DCMD_CLOSE_BOOK.nativeId, 0);
    			}
    		}
    		public void done() {
    			BackgroundThread.ensureGUI();
    			if ( currentAnimation==null ) {
	    			if (  mCurrentPageInfo!=null ) {
	    				mCurrentPageInfo.recycle();
	    				mCurrentPageInfo = null;
	    			}
	    			if (  mNextPageInfo!=null ) {
	    				mNextPageInfo.recycle();
	    				mNextPageInfo = null;
	    			}
    			} else
        	    	invalidImages = true;
    			factory.compact();
    			mCurrentPageInfo = null;
    		}
    	});
    }

    public void destroy()
    {
    	Log.i(""cr3"", ""ReaderView.destroy() is called"");
		BackgroundThread.ensureGUI();
    	if ( mInitialized ) {
        	//close();
        	BackgroundThread.backgroundExecutor.execute( new Runnable() {
        		public void run() {
        			BackgroundThread.ensureBackground();
        	    	if ( mInitialized ) {
        	        	Log.i(""cr3"", ""ReaderView.destroyInternal() calling"");
        	    		destroyInternal();
        	    		mInitialized = false;
        	    		currentBackgroundTexture = Engine.NO_TEXTURE;
        	    	}
        		}
        	});
    		//engine.waitTasksCompletion();
    	}
    }
    
    @Override
	protected void onDetachedFromWindow() {
		// TODO Auto-generated method stub
		super.onDetachedFromWindow();
		Log.d(""cr3"", ""View.onDetachedFromWindow() is called"");
	}

	private String getCSSForFormat( DocumentFormat fileFormat )
	{
		if ( fileFormat==null )
			fileFormat = DocumentFormat.FB2;
		File[] dataDirs = Engine.getDataDirectories(null, false, false);
		for ( File dir : dataDirs ) {
			File file = new File( dir, fileFormat.getCssName() );
			if ( file.exists() ) {
				String css = mEngine.loadFileUtf8(file);
				if ( css!=null )
					return css;
			} 
		}
		String s = mEngine.loadResourceUtf8(fileFormat.getCSSResourceId());
		return s;
	} 

	boolean enable_progress_callback = true;
    ReaderCallback readerCallback = new ReaderCallback() {
    
	    public boolean OnExportProgress(int percent) {
			BackgroundThread.ensureBackground();
	    	Log.d(""cr3"", ""readerCallback.OnExportProgress "" + percent);
			return true;
		}
		public void OnExternalLink(String url, String nodeXPath) {
			BackgroundThread.ensureBackground();
		}
		public void OnFormatEnd() {
			BackgroundThread.ensureBackground();
	    	Log.d(""cr3"", ""readerCallback.OnFormatEnd"");
			//mEngine.hideProgress();
			drawPage();
		}
		public boolean OnFormatProgress(final int percent) {
			BackgroundThread.ensureBackground();
			if ( enable_progress_callback ) {
		    	Log.d(""cr3"", ""readerCallback.OnFormatProgress "" + percent);
		    	mEngine.showProgress( percent*4/10 + 5000, R.string.progress_formatting);
			}
//			executeSync( new Callable<Object>() {
//				public Object call() {
//					BackgroundThread.ensureGUI();
//			    	Log.d(""cr3"", ""readerCallback.OnFormatProgress "" + percent);
//			    	mEngine.showProgress( percent*4/10 + 5000, R.string.progress_formatting);
//			    	return null;
//				}
//			});
			return true;
		}
		public void OnFormatStart() {
			BackgroundThread.ensureBackground();
	    	Log.d(""cr3"", ""readerCallback.OnFormatStart"");
		}
		public void OnLoadFileEnd() {
			BackgroundThread.ensureBackground();
	    	Log.d(""cr3"", ""readerCallback.OnLoadFileEnd"");
		}
		public void OnLoadFileError(String message) {
			BackgroundThread.ensureBackground();
	    	Log.d(""cr3"", ""readerCallback.OnLoadFileError("" + message + "")"");
		}
		public void OnLoadFileFirstPagesReady() {
			BackgroundThread.ensureBackground();
	    	Log.d(""cr3"", ""readerCallback.OnLoadFileFirstPagesReady"");
		}
		public String OnLoadFileFormatDetected(final DocumentFormat fileFormat) {
			BackgroundThread.ensureBackground();
			String res = executeSync( new Callable<String>() {
				public String call() {
					BackgroundThread.ensureGUI();
					Log.i(""cr3"", ""readerCallback.OnLoadFileFormatDetected "" + fileFormat);
					if ( fileFormat!=null ) {
						String s = getCSSForFormat(fileFormat);
						Log.i(""cr3"", ""setting .css for file format "" + fileFormat + "" from resource "" + (fileFormat!=null?fileFormat.getCssName():""[NONE]""));
						return s;
					}
			    	return null;
				}
			});
			return res;
		}
		public boolean OnLoadFileProgress(final int percent) {
			BackgroundThread.ensureBackground();
			if ( enable_progress_callback ) {
		    	Log.d(""cr3"", ""readerCallback.OnLoadFileProgress "" + percent);
		    	mEngine.showProgress( percent*4/10 + 1000, R.string.progress_loading);
			}
//			executeSync( new Callable<Object>() {
//				public Object call() {
//					BackgroundThread.ensureGUI();
//			    	Log.d(""cr3"", ""readerCallback.OnLoadFileProgress "" + percent);
//			    	mEngine.showProgress( percent*4/10 + 1000, R.string.progress_loading);
//			    	return null;
//				}
//			});
			return true;
		}
		public void OnLoadFileStart(String filename) {
			BackgroundThread.ensureBackground();
	    	Log.d(""cr3"", ""readerCallback.OnLoadFileStart "" + filename);
		}
	    /// Override to handle external links
	    public void OnImageCacheClear() {
	    	//Log.d(""cr3"", ""readerCallback.OnImageCacheClear"");
	    	clearImageCache();
	    }
    };
    
    private boolean invalidImages = true;
    private void clearImageCache()
    {
    	BackgroundThread.instance().postBackground( new Runnable() {
    		public void run() {
    	    	invalidImages = true;
    		}
    	});
    }

    public void setStyleSheet( final String css )
    {
		BackgroundThread.ensureGUI();
        if ( css!=null && css.length()>0 ) {
        	post(new Task() {
        		public void work() {
        			setStylesheetInternal(css);
        		}
        	});
        }
    }
    
    public void goToPosition( int position )
    {
		BackgroundThread.ensureGUI();
		doEngineCommand(ReaderView.ReaderCommand.DCMD_GO_POS, position);
    }
    
    public void moveBy( final int delta )
    {
		BackgroundThread.ensureGUI();
		Log.d(""cr3"", ""moveBy("" + delta + "")"");
		post(new Task() {
			public void work() {
				BackgroundThread.ensureBackground();
				doCommandInternal(ReaderCommand.DCMD_SCROLL_BY.nativeId, delta);
			}
			public void done() {
				drawPage();
			}
		});
    }
    
    public void goToPage( int pageNumber )
    {
		BackgroundThread.ensureGUI();
		doEngineCommand(ReaderView.ReaderCommand.DCMD_GO_PAGE, pageNumber-1);
    }
    
    public void goToPercent( final int percent )
    {
		BackgroundThread.ensureGUI();
    	if ( percent>=0 && percent<=100 )
	    	post( new Task() {
	    		public void work() {
	    			PositionProperties pos = getPositionPropsInternal(null);
	    			if ( pos!=null && pos.pageCount>0) {
	    				int pageNumber = pos.pageCount * percent / 100; 
						doCommandFromBackgroundThread(ReaderView.ReaderCommand.DCMD_GO_PAGE, pageNumber);
	    			}
	    		}
	    	});
    }
    
    @Override
    public void finalize()
    {
    	Log.w(""cr3"", ""ReaderView.finalize() is called"");
    	//destroyInternal();
    }

	public ReaderView(CoolReader activity, Engine engine, BackgroundThread backThread, Properties props ) 
    {
        super(activity);
        SurfaceHolder holder = getHolder();
        holder.addCallback(this);
        
		BackgroundThread.ensureGUI();
        this.mActivity = activity;
        this.mEngine = engine;
        this.mBackThread = backThread;
        setFocusable(true);
        setFocusableInTouchMode(true);
        
        mBackThread.postBackground(new Runnable() {

			@Override
			public void run() {
				Log.d(""cr3"", ""ReaderView - in background thread: calling createInternal()"");
				createInternal();
				mInitialized = true;
			}
        	
        });

        post(new CreateViewTask( props ));

    }

}
",True,19,27,0,0,2,21,9,21,M0
26,org.coolreader.crengine.ReaderAction.java,"package org.coolreader.crengine;

import org.coolreader.R;
import org.coolreader.crengine.ReaderView.ReaderCommand;

public class ReaderAction {
	final public String id;
	final public int nameId;
	final public int    iconId;
	final public ReaderView.ReaderCommand cmd;
	final public int param;
	final public int menuItemId;
	private boolean canRepeat = false;
	private boolean mayAssignOnKey = true;
	private boolean mayAssignOnTap = true;
	private ReaderAction setCanRepeat() { canRepeat=true; return this; }
	//private ReaderAction dontAssignOnKey() { mayAssignOnKey=false; return this; }
	private ReaderAction dontAssignOnTap() { mayAssignOnTap=false; return this; }
	public boolean canRepeat() { return canRepeat; }
	public boolean mayAssignOnKey() { return mayAssignOnKey; }
	public boolean mayAssignOnTap() { return mayAssignOnTap; }

	public ReaderAction(String id, int nameId, ReaderCommand cmd, int param) {
		super();
		this.id = id;
		this.nameId = nameId;
		this.cmd = cmd;
		this.param = param;
		this.menuItemId = 0;
		this.iconId = 0;
	}

	public ReaderAction(String id, int nameId, ReaderCommand cmd, int param, int menuItemId) {
		super();
		this.id = id;
		this.nameId = nameId;
		this.cmd = cmd;
		this.param = param;
		this.menuItemId = menuItemId;
		this.iconId = 0;
	}

	public String toString() {
		return id;
	}
	
	public final static ReaderAction NONE = new ReaderAction(""NONE"", R.string.action_none, ReaderCommand.DCMD_NONE, 0 );
	public final static ReaderAction REPEAT = new ReaderAction(""REPEAT"", R.string.action_repeat, ReaderCommand.DCMD_REPEAT, 0 );
	public final static ReaderAction PAGE_DOWN = new ReaderAction(""PAGE_DOWN"", R.string.action_pagedown, ReaderCommand.DCMD_PAGEDOWN, 1 ).setCanRepeat();
	public final static ReaderAction PAGE_DOWN_10 = new ReaderAction(""PAGE_DOWN_10"", R.string.action_pagedown_10, ReaderCommand.DCMD_PAGEDOWN, 10 ).setCanRepeat();
	public final static ReaderAction PAGE_UP = new ReaderAction(""PAGE_UP"", R.string.action_pageup, ReaderCommand.DCMD_PAGEUP, 1 ).setCanRepeat();
	public final static ReaderAction PAGE_UP_10 = new ReaderAction(""PAGE_UP_10"", R.string.action_pageup_10, ReaderCommand.DCMD_PAGEUP, 10 ).setCanRepeat();
	public final static ReaderAction BOOKMARKS = new ReaderAction(""BOOKMARKS"", R.string.action_bookmarks, ReaderCommand.DCMD_BOOKMARKS, 0, R.id.cr3_mi_bookmarks );
	public final static ReaderAction TOC = new ReaderAction(""TOC"", R.string.action_toc, ReaderCommand.DCMD_TOC_DIALOG, 0, R.id.cr3_go_toc );
	public final static ReaderAction SEARCH = new ReaderAction(""SEARCH"", R.string.action_search, ReaderCommand.DCMD_SEARCH, 0, R.id.cr3_mi_search );
	public final static ReaderAction GO_PAGE = new ReaderAction(""GO_PAGE"", R.string.action_go_page, ReaderCommand.DCMD_GO_PAGE_DIALOG, 0, R.id.cr3_mi_go_page );
	public final static ReaderAction GO_PERCENT = new ReaderAction(""GO_PERCENT"", R.string.action_go_percent, ReaderCommand.DCMD_GO_PERCENT_DIALOG, 0, R.id.cr3_mi_go_percent );
	public final static ReaderAction FIRST_PAGE = new ReaderAction(""FIRST_PAGE"", R.string.action_go_first_page, ReaderCommand.DCMD_BEGIN, 0 );
	public final static ReaderAction LAST_PAGE = new ReaderAction(""LAST_PAGE"", R.string.action_go_last_page, ReaderCommand.DCMD_END, 0 );
	public final static ReaderAction OPTIONS = new ReaderAction(""OPTIONS"", R.string.action_options, ReaderCommand.DCMD_OPTIONS_DIALOG, 0, R.id.cr3_mi_options );
	public final static ReaderAction READER_MENU = new ReaderAction(""READER_MENU"", R.string.action_reader_menu, ReaderCommand.DCMD_READER_MENU, 0 );
	public final static ReaderAction TOGGLE_DAY_NIGHT = new ReaderAction(""TOGGLE_DAY_NIGHT"", R.string.action_toggle_day_night, ReaderCommand.DCMD_TOGGLE_DAY_NIGHT_MODE, 0 );
	public final static ReaderAction RECENT_BOOKS = new ReaderAction(""RECENT_BOOKS"", R.string.action_recent_books_list, ReaderCommand.DCMD_RECENT_BOOKS_LIST, R.id.book_recent_books );
	public final static ReaderAction FILE_BROWSER = new ReaderAction(""FILE_BROWSER"", R.string.action_file_browser, ReaderCommand.DCMD_FILE_BROWSER, 0, R.id.cr3_mi_open_file );
	public final static ReaderAction TOGGLE_TOUCH_SCREEN_LOCK = new ReaderAction(""TOGGLE_TOUCH_SCREEN_LOCK"", R.string.action_touch_screen_toggle_lock, ReaderCommand.DCMD_TOGGLE_TOUCH_SCREEN_LOCK, 0 ).dontAssignOnTap();
	public final static ReaderAction EXIT = new ReaderAction(""EXIT"", R.string.action_exit, ReaderCommand.DCMD_EXIT, 0, R.id.cr3_mi_exit );
	
	
	public final static ReaderAction[] AVAILABLE_ACTIONS = {
		NONE,
		PAGE_DOWN,
		PAGE_UP,
		PAGE_DOWN_10,
		PAGE_UP_10,
		FIRST_PAGE,
		LAST_PAGE,
		TOC,
		GO_PAGE,
		GO_PERCENT,
		BOOKMARKS,
		SEARCH,
		OPTIONS,
		TOGGLE_DAY_NIGHT,
		RECENT_BOOKS,
		FILE_BROWSER,
		READER_MENU,
		TOGGLE_TOUCH_SCREEN_LOCK,
		EXIT,
	};

	public boolean isNone() {
		return cmd == NONE.cmd;
	}
	
	public boolean isRepeat() {
		return cmd == REPEAT.cmd;
	}
	
	public static ReaderAction findById( String id ) {
		if ( id==null )
			return NONE;
		for ( ReaderAction a : AVAILABLE_ACTIONS ) {
			if ( id.equals(a.id) )
				return a;
		}
		if ( id.equals(REPEAT.id) )
			return REPEAT;
		return NONE;
	}
	public static ReaderAction findByMenuId( int id ) {
		if ( id==0 )
			return NONE;
		for ( ReaderAction a : AVAILABLE_ACTIONS ) {
			if ( id == a.menuItemId )
				return a;
		}
		return NONE;
	}
	public final static String NORMAL_PROP = ""."";
	public final static String LONG_PROP = "".long."";
	public final static String DOUBLECLICK_PROP = "".dbl."";
	
	public final static int NORMAL = 0;
	public final static int LONG = 1;
	public final static int DOUBLE = 2;
	public final static String[] TYPE_PROP_SUBPATH = new String[] {NORMAL_PROP, LONG_PROP, DOUBLECLICK_PROP};

	public static String getTypeString( int type ) {
		return TYPE_PROP_SUBPATH[type];
	}
	
	public static String getTapZoneProp( int tapZoneNumber, int type ) {
		return ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + getTypeString(type) + tapZoneNumber;
	}
	public static String getKeyProp( int keyCode, int type ) {
		return ReaderView.PROP_APP_KEY_ACTIONS_PRESS + getTypeString(type) + keyCode;
	}
	public static ReaderAction findForTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, NORMAL ) );
		return findById(id);
	}
	public static ReaderAction findForLongTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, LONG ) );
		return findById(id);
	}
	public static ReaderAction findForDoubleTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, DOUBLE ) );
		return findById(id);
	}
	public static ReaderAction findForKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, NORMAL ) );
		return findById(id);
	}
	public static ReaderAction findForLongKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, LONG ) );
		return findById(id);
	}
	public static ReaderAction findForDoubleKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, DOUBLE ) );
		return findById(id);
	}
}
",False,27,27,0,0,3,19,3,2,L1
