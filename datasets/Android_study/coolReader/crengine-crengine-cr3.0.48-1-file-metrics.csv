,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.coolreader.CoolReader.java,"// Main Class
package org.coolreader;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.lang.reflect.Field;

import org.coolreader.crengine.AboutDialog;
import org.coolreader.crengine.BackgroundThread;
import org.coolreader.crengine.BaseDialog;
import org.coolreader.crengine.BookmarksDlg;
import org.coolreader.crengine.CRDB;
import org.coolreader.crengine.Engine;
import org.coolreader.crengine.Engine.HyphDict;
import org.coolreader.crengine.FileBrowser;
import org.coolreader.crengine.FileInfo;
import org.coolreader.crengine.History;
import org.coolreader.crengine.L;
import org.coolreader.crengine.Logger;
import org.coolreader.crengine.OptionsDialog;
import org.coolreader.crengine.Properties;
import org.coolreader.crengine.ReaderAction;
import org.coolreader.crengine.ReaderView;
import org.coolreader.crengine.Scanner;
import org.coolreader.crengine.TTS;
import org.coolreader.crengine.TTS.OnTTSCreatedListener;

import android.app.Activity;
import android.app.SearchManager;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.graphics.PixelFormat;
import android.net.Uri;
import android.os.Bundle;
import android.os.Debug;
import android.os.PowerManager;
import android.text.ClipboardManager;
import android.text.method.DigitsKeyListener;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.Toast;

public class CoolReader extends Activity
{
	public static final Logger log = L.create(""cr"");
	
	Engine mEngine;
	ReaderView mReaderView;
	Scanner mScanner;
	FileBrowser mBrowser;
	FrameLayout mFrame;
	//View startupView;
	History mHistory;
	CRDB mDB;
	private BackgroundThread mBackgroundThread;
	
	public Scanner getScanner()
	{
		return mScanner;
	}
	
	public History getHistory() 
	{
		return mHistory;
	}
	
	public Engine getEngine() {
		return mEngine;
	}
	
	public FileBrowser getBrowser() {
		return mBrowser;
	}
	
	public ReaderView getReaderView() 
	{
		return mReaderView;
	}
	
	public CRDB getDB()
	{
		return mDB;
	}
	
	private static String PREF_FILE = ""CR3LastBook"";
	private static String PREF_LAST_BOOK = ""LastBook"";
	public String getLastSuccessfullyOpenedBook()
	{
		SharedPreferences pref = getSharedPreferences(PREF_FILE, 0);
		String res = pref.getString(PREF_LAST_BOOK, null);
		pref.edit().putString(PREF_LAST_BOOK, null).commit();
		return res;
	}
	
	public void setLastSuccessfullyOpenedBook( String filename )
	{
		SharedPreferences pref = getSharedPreferences(PREF_FILE, 0);
		pref.edit().putString(PREF_LAST_BOOK, filename).commit();
	}
	
	private boolean mNightMode = false;
	public boolean isNightMode() {
		return mNightMode;
	}
	public void setNightMode( boolean nightMode ) {
		mNightMode = nightMode;
	}
	private boolean mFullscreen = false;
	public boolean isFullscreen() {
		return mFullscreen;
	}

	public void applyFullscreen( Window wnd )
	{
		if ( mFullscreen ) {
			//mActivity.getWindow().requestFeature(Window.)
			wnd.setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, 
			        WindowManager.LayoutParams.FLAG_FULLSCREEN );
		} else {
			wnd.setFlags(0, 
			        WindowManager.LayoutParams.FLAG_FULLSCREEN );
		}
	}
	public void setFullscreen( boolean fullscreen )
	{
		if ( mFullscreen!=fullscreen ) {
			mFullscreen = fullscreen;
			applyFullscreen( getWindow() );
		}
	}
	
	private boolean mWakeLockEnabled = false;
	public boolean isWakeLockEnabled() {
		return mWakeLockEnabled;
	}

	public void setWakeLockEnabled( boolean wakeLockEnabled )
	{
		if ( mWakeLockEnabled != wakeLockEnabled ) {
			mWakeLockEnabled = wakeLockEnabled;
			if ( !mWakeLockEnabled )
				backlightControl.release();
			else
				backlightControl.onUserActivity();
		}
	}
	
	int screenOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR;
	public void applyScreenOrientation( Window wnd )
	{
		if ( wnd!=null ) {
			WindowManager.LayoutParams attrs = wnd.getAttributes();
			attrs.screenOrientation = screenOrientation;
			wnd.setAttributes(attrs);
		}
	}

	public int getScreenOrientation()
	{
		switch ( screenOrientation ) {
		case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
			return 0;
		case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
			return 1;
		default:
			return orientationFromSensor;
		}
	}

	public boolean isLandscape()
	{
		return screenOrientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
	}

	public void setScreenOrientation( int angle )
	{
		int newOrientation = screenOrientation;
//		{
//			ActivityManager am = (ActivityManager)getSystemService(
//		            Context.ACTIVITY_SERVICE);
			//am.getDeviceConfigurationInfo().

//			WindowManager wm = (WindowManager)getSystemService(
//		            Context.WINDOW_SERVICE);
			
//		}
		//getWindowManager(). //getDefaultDisplay().getMetrics(outMetrics)
		if ( angle==4 )
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR;
		else if ( (angle&1)!=0 )
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
		else
			newOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
		if ( newOrientation!=screenOrientation ) {
			screenOrientation = newOrientation;
			setRequestedOrientation(screenOrientation);
			applyScreenOrientation(getWindow());
//			if ( newOrientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE )
//				Surface.setOrientation(Display.DEFAULT_DISPLAY, Surface.ROTATION_270);
//			else if ( newOrientation == ActivityInfo.SCREEN_ORIENTATION_PORTRAIT )
//				Surface.setOrientation(Display.DEFAULT_DISPLAY, Surface.ROTATION_180);
		}
	}

	private Runnable backlightTimerTask = null; 
	private class ScreenBacklightControl
	{
		PowerManager.WakeLock wl = null;
		public ScreenBacklightControl()
		{
		}
		public static final int SCREEN_BACKLIGHT_DURATION_STEPS = 3;
		public static final int SCREEN_BACKLIGHT_TIMER_STEP = 60*1000;
		int backlightCountDown = 0; 
		public void onUserActivity()
		{
			if ( !isWakeLockEnabled() )
				return;
			if ( wl==null ) {
				PowerManager pm = (PowerManager)getSystemService(
			            Context.POWER_SERVICE);
				wl = pm.newWakeLock(
			        PowerManager.SCREEN_BRIGHT_WAKE_LOCK
			        | PowerManager.ON_AFTER_RELEASE,
			        ""cr3"");
			}
			if ( !isStarted() ) {
			    release();
			    return;
			}
			if ( !wl.isHeld() )
				wl.acquire();
			backlightCountDown = SCREEN_BACKLIGHT_DURATION_STEPS;
			if ( backlightTimerTask==null ) {
				backlightTimerTask = new Runnable() {
					public void run() {
						if ( backlightTimerTask!=this )
							return;
						if ( backlightCountDown<=0 || !isStarted())
							release();
						else {
							backlightCountDown--;
							BackgroundThread.instance().postGUI(backlightTimerTask, SCREEN_BACKLIGHT_TIMER_STEP);
						}
					}
				};
				BackgroundThread.instance().postGUI(backlightTimerTask, SCREEN_BACKLIGHT_TIMER_STEP);
			}
		}
		public boolean isHeld()
		{
			return wl!=null && wl.isHeld();
		}
		public void release()
		{
			if ( wl!=null && wl.isHeld() )
				wl.release();
			backlightTimerTask = null;
		}
	}
	ScreenBacklightControl backlightControl = new ScreenBacklightControl();
	
	public int getPalmTipPixels()
	{
		return densityDpi / 3; // 1/3""
	}
	
	private int densityDpi = 120;
	int initialBatteryState = -1;
	String fileToLoadOnStart = null;
	BroadcastReceiver intentReceiver;
	
	private String mVersion = ""3.0"";
	
	public String getVersion() {
		return mVersion;
	}
	
	TTS tts;
	boolean ttsInitialized;
	boolean ttsError;
	
	public boolean initTTS(final OnTTSCreatedListener listener) {
		if ( ttsError || !TTS.isFound() ) {
			if ( !ttsError ) {
				ttsError = true;
				showToast(""TTS is not available"");
			}
			return false;
		}
		if ( ttsInitialized && tts!=null ) {
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					listener.onCreated(tts);
				}
			});
			return true;
		}
		if ( ttsInitialized && tts!=null ) {
			showToast(""TTS initialization is already called"");
			return false;
		}
		showToast(""Initializing TTS"");
    	tts = new TTS(this, new TTS.OnInitListener() {
			@Override
			public void onInit(int status) {
				//tts.shutdown();
				L.i(""TTS init status: "" + status);
				if ( status==TTS.SUCCESS ) {
					ttsInitialized = true;
					BackgroundThread.instance().executeGUI(new Runnable() {
						@Override
						public void run() {
							listener.onCreated(tts);
						}
					});
				} else {
					ttsError = true;
					BackgroundThread.instance().executeGUI(new Runnable() {
						@Override
						public void run() {
							showToast(""Cannot initialize TTS"");
						}
					});
				}
			}
		});
		return true;
	}
	
	/** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
    	
    	
		log.i(""CoolReader.onCreate() entered"");
		super.onCreate(savedInstanceState);

		try {
			PackageInfo pi = getPackageManager().getPackageInfo(getPackageName(), 0);
			mVersion = pi.versionName;
		} catch ( NameNotFoundException e ) {
			// ignore
		}
		log.i(""CoolReader version : "" + getVersion());
		
		Display d = getWindowManager().getDefaultDisplay();
		DisplayMetrics m = new DisplayMetrics(); 
		d.getMetrics(m);
		try {
			Field fld = d.getClass().getField(""densityDpi"");
			if ( fld!=null ) {
				Object v = fld.get(m);
				if ( v!=null && v instanceof Integer ) {
					densityDpi = ((Integer)v).intValue();
					log.i(""Screen density detected: "" + densityDpi + ""DPI"");
				}
			}
		} catch ( Exception e ) {
			log.e(""Cannot find field densityDpi, using default value"");
		}
		
		// load settings
		Properties props = loadSettings();
		
		intentReceiver = new BroadcastReceiver() {

			@Override
			public void onReceive(Context context, Intent intent) {
				int level = intent.getIntExtra(""level"", 0);
				if ( mReaderView!=null )
					mReaderView.setBatteryState(level);
				else
					initialBatteryState = level;
			}
			
		};
		registerReceiver(intentReceiver, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));


		log.i(""CoolReader.window="" + getWindow());
		WindowManager.LayoutParams lp = new WindowManager.LayoutParams();
		lp.alpha = 1.0f;
		lp.dimAmount = 0.0f;
		lp.format = PixelFormat.RGB_565;
		lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL;
		lp.horizontalMargin = 0;
		lp.verticalMargin = 0;
		lp.windowAnimations = 0;
		lp.layoutAnimationParameters = null;
		lp.memoryType = WindowManager.LayoutParams.MEMORY_TYPE_NORMAL;
		getWindow().setAttributes(lp);
		
		
		setFullscreen( props.getBool(ReaderView.PROP_APP_FULLSCREEN, false) );
		int orientation = props.getInt(ReaderView.PROP_APP_SCREEN_ORIENTATION, 4);
		if ( orientation!=1 && orientation!=4 )
			orientation = 0;
		setScreenOrientation(orientation);
		int backlight = props.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, -1);
		if ( backlight<-1 || backlight>100 )
			backlight = -1;
		setScreenBacklightLevel(backlight);
		
		// testing background thread
    	mBackgroundThread = BackgroundThread.instance();
		mFrame = new FrameLayout(this);
		mEngine = new Engine(this, mBackgroundThread);
		mBackgroundThread.setGUI(mFrame);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		
        mEngine.showProgress( 0, R.string.progress_starting_cool_reader );

        // wait until all background tasks are executed
        mBackgroundThread.syncWithBackground();
        
		mEngine.setHyphenationDictionary(HyphDict.byCode(props.getProperty(ReaderView.PROP_HYPHENATION_DICT, Engine.HyphDict.RUSSIAN.toString())));
		
		//this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, 
        //       WindowManager.LayoutParams.FLAG_FULLSCREEN );
//		startupView = new View(this) {
//		};
//		startupView.setBackgroundColor(Color.BLACK);
		setWakeLockEnabled(props.getBool(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK, false));

		File dbdir = getDir(""db"", Context.MODE_PRIVATE);
		dbdir.mkdirs();
		File dbfile = new File(dbdir, ""cr3db.sqlite"");
		mDB = new CRDB(dbfile);
		
       	mScanner = new Scanner(this, mDB, mEngine); //, Environment.getExternalStorageDirectory(), ""SD""
       	mHistory = new History(this, mDB);
		mHistory.setCoverPagesEnabled(props.getBool(ReaderView.PROP_APP_SHOW_COVERPAGES, true));

		mReaderView = new ReaderView(this, mEngine, mBackgroundThread, props);
		
		mScanner.setDirScanEnabled(props.getBool(ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED, true));
		log.i(""initializing scanner"");
        mScanner.initRoots();

		mBrowser = new FileBrowser(this, mEngine, mScanner, mHistory);

		
		mFrame.addView(mReaderView);
		mFrame.addView(mBrowser);
//		mFrame.addView(startupView);
		setContentView( mFrame );
        log.i(""initializing browser"");
        mBrowser.init();
		showView(mBrowser, false);
        log.i(""initializing reader"");
        mBrowser.setSortOrder( props.getProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER));
		mBrowser.setSimpleViewMode(props.getBool(ReaderView.PROP_APP_FILE_BROWSER_SIMPLE_MODE, false));
        mBrowser.showDirectory(mScanner.getRoot(), null);
        
        fileToLoadOnStart = null;
		Intent intent = getIntent();
		if ( intent!=null && Intent.ACTION_VIEW.equals(intent.getAction()) ) {
			Uri uri = intent.getData();
			if ( uri!=null ) {
				fileToLoadOnStart = extractFileName(uri);
			}
			intent.setData(null);
		}
		if ( initialBatteryState>=0 )
			mReaderView.setBatteryState(initialBatteryState);
        
        log.i(""CoolReader.onCreate() exiting"");
    }
    
    public ClipboardManager getClipboardmanager() {
    	return (ClipboardManager)getSystemService(CLIPBOARD_SERVICE);
    }
    
    public void setScreenBacklightLevel( int percent )
    {
    	if ( percent<-1 )
    		percent = -1;
    	else if ( percent>100 )
    		percent = -1;
    	screenBacklightBrightness = percent;
    	onUserActivity();
    }
    
    private int screenBacklightBrightness = -1; // use default
    private boolean brightnessHackError = false;
    public void onUserActivity()
    {
    	if ( backlightControl==null )
    		return;
    	backlightControl.onUserActivity();
    	// Hack
    	//if ( backlightControl.isHeld() )
    	BackgroundThread.guiExecutor.execute(new Runnable() {
			@Override
			public void run() {
				try {
			        Window wnd = getWindow();
			        if ( wnd!=null ) {
			        	LayoutParams attrs =  wnd.getAttributes();
			        	boolean changed = false;
			        	float b;
			        	int dimmingAlpha = 255;
			        	if ( screenBacklightBrightness>=0 ) {
		        			float minb = 1/16f; 
			        		if ( screenBacklightBrightness >= 10 ) {
			        			b = (screenBacklightBrightness - 10) / 90.0f;
			        			b = minb + b * (1-minb);
				        		//b = (screenBacklightBrightness - 10) * 10.0f / 9.0f / 95.0f + 0.5f;
					        	if ( b<0.0f ) // BRIGHTNESS_OVERRIDE_OFF
					        		b = 0.0f;
					        	else if ( b>1.0f )
					        		b = 1.0f; //BRIGHTNESS_OVERRIDE_FULL
			        		} else {
				        		b = minb;
				        		dimmingAlpha = 255 - (11-screenBacklightBrightness) * 255 / 10; 
			        		}
			        	} else
			        		b = -1.0f; //BRIGHTNESS_OVERRIDE_NONE
			        	mReaderView.setDimmingAlpha(dimmingAlpha);
			        	log.d(""Brightness: "" + b + "", dim: "" + dimmingAlpha);
			        	if ( attrs.screenBrightness != b ) {
			        		attrs.screenBrightness = b;
			        		changed = true;
			        	}
			        	// hack to set buttonBrightness field
			        	if ( !brightnessHackError )
			        	try {
				        	Field bb = attrs.getClass().getField(""buttonBrightness"");
				        	if ( bb!=null ) {
				        		Float oldValue = (Float)bb.get(attrs);
				        		//if ( oldValue==null || oldValue.floatValue()!=0 ) {
				        			bb.set(attrs, Float.valueOf(0.0f));
					        		changed = true;
				        		//}
				        	}
			        	} catch ( Exception e ) {
			        		log.e(""WindowManager.LayoutParams.buttonBrightness field is not found, cannot turn buttons backlight off"");
			        		brightnessHackError = true;
			        	}
			        	//attrs.buttonBrightness = 0;
			        	if ( changed ) {
			        		log.d(""Window attribute changed: "" + attrs);
			        		wnd.setAttributes(attrs);
			        	}
			        	//attrs.screenOrientation = LayoutParams.SCREEN_;
			        }
				} catch ( Exception e ) {
					// ignore
				}
			}
    	});
    }
    
    boolean mDestroyed = false;
	@Override
	protected void onDestroy() {

		log.i(""CoolReader.onDestroy() entered"");
		mDestroyed = true;
		if ( !CLOSE_BOOK_ON_STOP )
			mReaderView.close();
		
		//if ( mReaderView!=null )
		//	mReaderView.close();
		
		//if ( mHistory!=null && mDB!=null ) {
			//history.saveToDB();
		//}
		if ( intentReceiver!=null ) {
			unregisterReceiver(intentReceiver);
			intentReceiver = null;
		}

		if ( mReaderView!=null ) {
			mReaderView.destroy();
		}
		
		if ( tts!=null ) {
			tts.shutdown();
			tts = null;
			ttsInitialized = false;
			ttsError = false;
		}
		
		if ( mEngine!=null ) {
			mEngine.uninit();
		}

		if ( mDB!=null ) {
			final CRDB db = mDB;
			mBackgroundThread.executeBackground(new Runnable() {
				public void run() {
					db.close();
				}
			});
		}
//		if ( mBackgroundThread!=null ) {
//			mBackgroundThread.quit();
//		}
			
		mDB = null;
		mReaderView = null;
		mEngine = null;
		mBackgroundThread = null;
		log.i(""CoolReader.onDestroy() exiting"");
		super.onDestroy();
	}

	private String extractFileName( Uri uri )
	{
		if ( uri!=null ) {
			if ( uri.equals(Uri.parse(""file:///"")) )
				return null;
			else
				return uri.getPath();
		}
		return null;
	}

	public void showHomeScreen() {
		Intent intent = new Intent(Intent.ACTION_MAIN);
		intent.addCategory(Intent.CATEGORY_HOME);
		startActivity(intent);
	}
	
	@Override
	protected void onNewIntent(Intent intent) {
		log.i(""onNewIntent : "" + intent);
		if ( mDestroyed ) {
			log.e(""engine is already destroyed"");
			return;
		}
		String fileToOpen = null;
		if ( Intent.ACTION_VIEW.equals(intent.getAction()) ) {
			Uri uri = intent.getData();
			if ( uri!=null ) {
				fileToOpen = extractFileName(uri);
			}
			intent.setData(null);
		}
		log.v(""onNewIntent, fileToOpen="" + fileToOpen);
		if ( fileToOpen!=null ) {
			// load document
			final String fn = fileToOpen;
			mReaderView.loadDocument(fileToOpen, new Runnable() {
				public void run() {
					log.v(""onNewIntent, loadDocument error handler called"");
					showToast(""Error occured while loading "" + fn);
					mEngine.hideProgress();
				}
			});
		}
	}

	private boolean mPaused = false; 
	public boolean isPaused() {
		return mPaused;
	}
	
	@Override
	protected void onPause() {
		log.i(""CoolReader.onPause() : saving reader state"");
		mIsStarted = false;
		mPaused = true;
		releaseBacklightControl();
		mReaderView.saveCurrentPositionBookmarkSync(true);
		super.onPause();
	}
	
	public void releaseBacklightControl()
	{
		backlightControl.release();
	}

	@Override
	protected void onPostCreate(Bundle savedInstanceState) {
		log.i(""CoolReader.onPostCreate()"");
		super.onPostCreate(savedInstanceState);
	}

	@Override
	protected void onPostResume() {
		log.i(""CoolReader.onPostResume()"");
		super.onPostResume();
	}

	private boolean restarted = false;
	@Override
	protected void onRestart() {
		log.i(""CoolReader.onRestart()"");
		restarted = true;
		super.onRestart();
	}

	@Override
	protected void onRestoreInstanceState(Bundle savedInstanceState) {
		log.i(""CoolReader.onRestoreInstanceState()"");
		super.onRestoreInstanceState(savedInstanceState);
	}

	@Override
	protected void onResume() {
		log.i(""CoolReader.onResume()"");
		mPaused = false;
		mIsStarted = true;
		super.onResume();
	}

	@Override
	protected void onSaveInstanceState(Bundle outState) {
		log.i(""CoolReader.onSaveInstanceState()"");
		super.onSaveInstanceState(outState);
	}

	static final boolean LOAD_LAST_DOCUMENT_ON_START = true; 
	
	private boolean mIsStarted = false;
	
	public boolean isStarted() { return mIsStarted; }
	
	@Override
	protected void onStart() {
		log.i(""CoolReader.onStart() fileToLoadOnStart="" + fileToLoadOnStart);
		super.onStart();
		
		mPaused = false;
		
		backlightControl.onUserActivity();
		

		if ( fileToLoadOnStart==null ) {
			if ( mReaderView!=null && currentView==mReaderView && mReaderView.isBookLoaded() ) {
				log.v(""Book is already opened, showing ReaderView"");
				showReader();
				return;
			}
			
			//!stopped && 
//			if ( restarted && mReaderView!=null && mReaderView.isBookLoaded() ) {
//				log.v(""Book is already opened, showing ReaderView"");
//		        restarted = false;
//		        return;
//			}
		}
		if ( !stopped ) {
	        mEngine.showProgress( 500, R.string.progress_starting_cool_reader );
			//mEngine.setHyphenationDictionary( HyphDict.RUSSIAN );
		}
        //log.i(""waiting for engine tasks completion"");
        //engine.waitTasksCompletion();
		restarted = false;
		stopped = false;
		final String fileName = fileToLoadOnStart;
		mBackgroundThread.postGUI(new Runnable() {
			public void run() {
		        log.i(""onStart, scheduled runnable: submitting task"");
		        mEngine.execute(new LoadLastDocumentTask(fileName));
			}
		});
		log.i(""CoolReader.onStart() exiting"");
	}
	
	class LoadLastDocumentTask implements Engine.EngineTask {

		final String fileName;
		public LoadLastDocumentTask( String fileName ) {
			super();
			this.fileName = fileName;
		}
		
		public void done() {
	        log.i(""onStart, scheduled task: trying to load "" + fileToLoadOnStart);
			if ( fileName!=null || LOAD_LAST_DOCUMENT_ON_START ) {
				//currentView=mReaderView;
				if ( fileName!=null ) {
					log.v(""onStart() : loading "" + fileName);
					mReaderView.loadDocument(fileName, new Runnable() {
						public void run() {
							// cannot open recent book: load another one
							log.e(""Cannot open document "" + fileToLoadOnStart + "" starting file browser"");
							showBrowser(null);
						}
					});
				} else {
					log.v(""onStart() : loading last document"");
					mReaderView.loadLastDocument(new Runnable() {
						public void run() {
							// cannot open recent book: load another one
							log.e(""Cannot open last document, starting file browser"");
							showBrowser(null);
						}
					});
				}
			} else {
				showBrowser(null);
			}
			fileToLoadOnStart = null;
		}

		public void fail(Exception e) {
	        log.e(""onStart, scheduled task failed"", e);
		}

		public void work() throws Exception {
	        log.v(""onStart, scheduled task work()"");
		}
    }
 

	public final static boolean CLOSE_BOOK_ON_STOP = false;
	private boolean stopped = false;
	@Override
	protected void onStop() {
		log.i(""CoolReader.onStop() entering"");
		stopped = true;
		mPaused = false;
		// will close book at onDestroy()
		if ( CLOSE_BOOK_ON_STOP )
			mReaderView.close();
		super.onStop();
		log.i(""CoolReader.onStop() exiting"");
	}

	private View currentView;
	public void showView( View view )
	{
		showView( view, true );
	}
	public void showView( View view, boolean hideProgress )
	{
		if ( hideProgress )
		mBackgroundThread.postGUI(new Runnable() {
			public void run() {
				mEngine.hideProgress();
			}
		});
		if ( currentView==view ) {
			log.v(""showView : view "" + view.getClass().getSimpleName() + "" is already shown"");
			return;
		}
		log.v(""showView : showing view "" + view.getClass().getSimpleName());
		mFrame.bringChildToFront(view);
		for ( int i=0; i<mFrame.getChildCount(); i++ ) {
			View v = mFrame.getChildAt(i);
			v.setVisibility(view==v?View.VISIBLE:View.INVISIBLE);
		}
		currentView = view;
	}
	
	public void showReader()
	{
		log.v(""showReader() is called"");
		showView(mReaderView);
	}
	
	public boolean isBookOpened()
	{
		return mReaderView.isBookLoaded();
	}
	
	public void loadDocument( FileInfo item )
	{
		//showView(readerView);
		//setContentView(readerView);
		mReaderView.loadDocument(item);
	}
	
	public void showBrowser( final FileInfo fileToShow )
	{
		log.v(""showBrowser() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
		        if ( fileToShow==null )
		        	mBrowser.showLastDirectory();
		        else
		        	mBrowser.showDirectory(fileToShow, fileToShow);
			}
		});
	}

	public void showBrowserRecentBooks()
	{
		log.v(""showBrowserRecentBooks() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
	        	mBrowser.showRecentBooks();
			}
		});
	}

	public void showBrowserRoot()
	{
		log.v(""showBrowserRoot() is called"");
		if ( currentView == mReaderView )
			mReaderView.save();
		mEngine.runInGUI( new Runnable() {
			public void run() {
				showView(mBrowser);
	        	mBrowser.showRootDirectory();
			}
		});
	}

	private void fillMenu(Menu menu) {
		menu.clear();
	    MenuInflater inflater = getMenuInflater();
	    if ( currentView==mReaderView ) {
	    	inflater.inflate(R.menu.cr3_reader_menu, menu);
	    	MenuItem item = menu.findItem(R.id.cr3_mi_toggle_document_styles);
	    	if ( item!=null )
	    		item.setTitle(mReaderView.getDocumentStylesEnabled() ? R.string.mi_book_styles_disable : R.string.mi_book_styles_enable);
	    	item = menu.findItem(R.id.cr3_mi_toggle_day_night);
	    	if ( item!=null )
	    		item.setTitle(mReaderView.isNightMode() ? R.string.mi_night_mode_disable : R.string.mi_night_mode_enable);
	    } else {
	    	inflater.inflate(R.menu.cr3_browser_menu, menu);
	    	if ( !isBookOpened() ) {
	    		MenuItem item = menu.findItem(R.id.book_back_to_reading);
	    		if ( item!=null )
	    			item.setEnabled(false);
	    	}
    		MenuItem item = menu.findItem(R.id.book_toggle_simple_mode);
    		if ( item!=null )
    			item.setTitle(mBrowser.isSimpleViewMode() ? R.string.mi_book_browser_normal_mode : R.string.mi_book_browser_simple_mode );
	    }
	}
	
	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		fillMenu(menu);
	    return true;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		fillMenu(menu);
	    return true;
	}

	public void showToast( int stringResourceId )
	{
		String s = getString(stringResourceId);
		if ( s!=null )
			showToast(s);
	}

	public void showToast( String msg )
	{
		log.v(""showing toast: "" + msg);
		Toast toast = Toast.makeText(this, msg, Toast.LENGTH_LONG);
		toast.show();
	}

	public interface InputHandler {
		boolean validate( String s ) throws Exception;
		void onOk( String s ) throws Exception;
		void onCancel();
	};
	
	public static class InputDialog extends BaseDialog {
		private InputHandler handler;
		private EditText input;
		public InputDialog( CoolReader activity, final String title, boolean isNumberEdit, final InputHandler handler )
		{
			super(activity, R.string.dlg_button_ok, R.string.dlg_button_cancel, true);
			this.handler = handler;
			setTitle(title);
	        input = new EditText(getContext());
	        if ( isNumberEdit )
	        	input.setKeyListener(DigitsKeyListener.getInstance(""0123456789.""));
//		        input.getText().setFilters(new InputFilter[] {
//		        	new DigitsKeyListener()        
//		        });
	        setView(input);
		}
		@Override
		protected void onNegativeButtonClick() {
            cancel();
            handler.onCancel();
		}
		@Override
		protected void onPositiveButtonClick() {
            String value = input.getText().toString().trim();
            try {
            	if ( handler.validate(value) )
            		handler.onOk(value);
            	else
            		handler.onCancel();
            } catch ( Exception e ) {
            	handler.onCancel();
            }
            cancel();
		}
	}
	
	public void showInputDialog( final String title, boolean isNumberEdit, final InputHandler handler )
	{
        final InputDialog dlg = new InputDialog(this, title, isNumberEdit, handler);
        dlg.show();
	}

	private int orientationFromSensor = 0;
	public int getOrientationFromSensor()
	{
		return orientationFromSensor;
	}
	
	@Override
	public void onConfigurationChanged(Configuration newConfig) {
		// pass
		orientationFromSensor = newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE ? 1 : 0;
		//final int orientation = newConfig.orientation==Configuration.ORIENTATION_LANDSCAPE ? ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
//		if ( orientation!=screenOrientation ) {
//			log.d(""Screen orientation has been changed: ask for change"");
//			AlertDialog.Builder dlg = new AlertDialog.Builder(this);
//			dlg.setTitle(R.string.win_title_screen_orientation_change_apply);//R.string.win_title_options_apply);
//			dlg.setPositiveButton(R.string.dlg_button_ok, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					//onPositiveButtonClick();
//					Properties oldSettings = mReaderView.getSettings();
//					Properties newSettings = new Properties(oldSettings);
//					newSettings.setInt(ReaderView.PROP_APP_SCREEN_ORIENTATION, orientation==ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE ? 1 : 0);
//					mReaderView.setSettings(newSettings, oldSettings);
//				}
//			});
//			dlg.setNegativeButton(R.string.dlg_button_cancel, new OnClickListener() {
//				public void onClick(DialogInterface arg0, int arg1) {
//					//onNegativeButtonClick();
//				}
//			});
//		}
		super.onConfigurationChanged(newConfig);
	}

	String[] mFontFaces;

	public void showOptionsDialog()
	{
		final CoolReader _this = this;
		mBackgroundThread.executeBackground(new Runnable() {
			public void run() {
				mFontFaces = mEngine.getFontFaceList();
				mBackgroundThread.executeGUI(new Runnable() {
					public void run() {
						OptionsDialog dlg = new OptionsDialog(_this, mReaderView, mFontFaces);
						dlg.show();
					}
				});
			}
		});
	}
	
	public void saveSetting( String name, String value ) {
		mReaderView.saveSetting(name, value);
	}
	public String getSetting( String name ) {
		return mReaderView.getSetting(name);
	}
	
	public void showBookmarksDialog()
	{
		BackgroundThread.instance().executeGUI(new Runnable() {
			@Override
			public void run() {
				BookmarksDlg dlg = new BookmarksDlg(CoolReader.this, mReaderView);
				dlg.show();
			}
		});
	}
	
	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		int itemId = item.getItemId();
		if ( mReaderView.onMenuItem(itemId))
			return true; // processed by ReaderView
		// other commands
		switch ( itemId ) {
		case R.id.book_toggle_simple_mode:
			mBrowser.setSimpleViewMode(!mBrowser.isSimpleViewMode());
			mReaderView.saveSetting(ReaderView.PROP_APP_FILE_BROWSER_SIMPLE_MODE, mBrowser.isSimpleViewMode()?""1"":""0"");
			return true;
		case R.id.book_sort_order:
			mBrowser.showSortOrderMenu();
			return true;
		case R.id.book_root:
			mBrowser.showRootDirectory();
			return true;
		case R.id.book_opds_root:
			mBrowser.showOPDSRootDirectory();
			return true;
		case R.id.book_recent_books:
			mBrowser.showRecentBooks();
			return true;
		case R.id.book_find:
			mBrowser.showFindBookDialog();
			return true;
		case R.id.book_scan_recursive:
			mBrowser.scanCurrentDirectoryRecursive();
			return true;
		case R.id.book_back_to_reading:
			if ( isBookOpened() )
				showReader();
			else
				showToast(""No book opened"");
			return true;
		default:
			return false;
			//return super.onOptionsItemSelected(item);
		}
	}
	
	public void showGoToPageDialog() {
		showInputDialog(""Enter page number"", true, new InputHandler() {
			int pageNumber = 0;
			public boolean validate(String s) {
				pageNumber = Integer.valueOf(s); 
				return pageNumber>0;
			}
			public void onOk(String s) {
				mReaderView.goToPage(pageNumber);
			}
			public void onCancel() {
			}
		});
	}
	public void showGoToPercentDialog() {
		showInputDialog(""Enter position %"", true, new InputHandler() {
			int percent = 0;
			public boolean validate(String s) {
				percent = Integer.valueOf(s); 
				return percent>=0 && percent<=100;
			}
			public void onOk(String s) {
				mReaderView.goToPercent(percent);
			}
			public void onCancel() {
			}
		});
	}

	private static class DefKeyAction {
		public int keyCode;
		public int type;
		public ReaderAction action;
		public DefKeyAction(int keyCode, int type, ReaderAction action) {
			this.keyCode = keyCode;
			this.type = type;
			this.action = action;
		}
		public String getProp() {
			return ReaderView.PROP_APP_KEY_ACTIONS_PRESS + ReaderAction.getTypeString(type) + keyCode;			
		}
	}
	private static class DefTapAction {
		public int zone;
		public boolean longPress;
		public ReaderAction action;
		public DefTapAction(int zone, boolean longPress, ReaderAction action) {
			this.zone = zone;
			this.longPress = longPress;
			this.action = action;
		}
	}
	private static DefKeyAction[] DEF_KEY_ACTIONS = {
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.NORMAL, ReaderAction.FILE_BROWSER),
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.LONG, ReaderAction.EXIT),
		new DefKeyAction(KeyEvent.KEYCODE_BACK, ReaderAction.DOUBLE, ReaderAction.EXIT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_CENTER, ReaderAction.NORMAL, ReaderAction.RECENT_BOOKS),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_CENTER, ReaderAction.LONG, ReaderAction.BOOKMARKS),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_UP, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_DOWN, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_UP_10),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN_10),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_LEFT, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_DPAD_RIGHT, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_UP, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_VOLUME_DOWN, ReaderAction.LONG, ReaderAction.REPEAT),
		new DefKeyAction(KeyEvent.KEYCODE_MENU, ReaderAction.NORMAL, ReaderAction.READER_MENU),
		new DefKeyAction(KeyEvent.KEYCODE_MENU, ReaderAction.LONG, ReaderAction.OPTIONS),
		new DefKeyAction(KeyEvent.KEYCODE_CAMERA, ReaderAction.NORMAL, ReaderAction.NONE),
		new DefKeyAction(KeyEvent.KEYCODE_CAMERA, ReaderAction.LONG, ReaderAction.NONE),
		new DefKeyAction(KeyEvent.KEYCODE_SEARCH, ReaderAction.NORMAL, ReaderAction.SEARCH),
		new DefKeyAction(KeyEvent.KEYCODE_SEARCH, ReaderAction.LONG, ReaderAction.TOGGLE_SELECTION_MODE),
		new DefKeyAction(ReaderView.NOOK_KEY_NEXT_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_NEXT_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_SHIFT_DOWN, ReaderAction.NORMAL, ReaderAction.PAGE_DOWN),
		new DefKeyAction(ReaderView.NOOK_KEY_PREV_LEFT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.NOOK_KEY_PREV_RIGHT, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
		new DefKeyAction(ReaderView.NOOK_KEY_SHIFT_UP, ReaderAction.NORMAL, ReaderAction.PAGE_UP),
	};
	private static DefTapAction[] DEF_TAP_ACTIONS = {
		new DefTapAction(1, false, ReaderAction.PAGE_UP),
		new DefTapAction(2, false, ReaderAction.PAGE_UP),
		new DefTapAction(4, false, ReaderAction.PAGE_UP),
		new DefTapAction(1, true, ReaderAction.GO_BACK), // back by link
		new DefTapAction(2, true, ReaderAction.TOGGLE_DAY_NIGHT),
		new DefTapAction(4, true, ReaderAction.PAGE_UP_10),
		new DefTapAction(3, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(6, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(7, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(8, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(9, false, ReaderAction.PAGE_DOWN),
		new DefTapAction(3, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(6, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(7, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(8, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(9, true, ReaderAction.PAGE_DOWN_10),
		new DefTapAction(5, false, ReaderAction.READER_MENU),
		new DefTapAction(5, true, ReaderAction.OPTIONS),
	};
	File propsFile;
	private static final String SETTINGS_FILE_NAME = ""cr3.ini"";
	private static boolean DEBUG_RESET_OPTIONS = false;
	private Properties loadSettings()
	{
        Properties props = new Properties();

		File[] dataDirs = Engine.getDataDirectories(null, false, true);
		File existingFile = null;
		for ( File dir : dataDirs ) {
			File f = new File(dir, SETTINGS_FILE_NAME);
			if ( f.exists() && f.isFile() ) {
				existingFile = f;
				break;
			}
		}
        if ( existingFile!=null )
        	propsFile = existingFile;
        else {
	        File propsDir = getDir(""settings"", Context.MODE_PRIVATE);
			propsDir.mkdirs();
			propsFile = new File( propsDir, ""cr3.ini"");
        }
        if ( propsFile.exists() && !DEBUG_RESET_OPTIONS ) {
        	try {
        		FileInputStream is = new FileInputStream(propsFile);
        		props.load(is);
        		log.v("""" + props.size() + "" settings items loaded from file "" + propsFile.getAbsolutePath() );
        	} catch ( Exception e ) {
        		log.e(""error while reading settings"");
        	}
        }
        
        // default key actions
        for ( DefKeyAction ka : DEF_KEY_ACTIONS ) {
        		props.applyDefault(ka.getProp(), ka.action.id);
        }
        // default tap zone actions
        for ( DefTapAction ka : DEF_TAP_ACTIONS ) {
        	if ( ka.longPress )
        		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + "".long."" + ka.zone, ka.action.id);
        	else
        		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + ""."" + ka.zone, ka.action.id);
        }
        
        props.applyDefault(ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK, ""0"");
        props.applyDefault(ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED, ""1"");
        props.applyDefault(ReaderView.PROP_FONT_SIZE, ""20"");
        props.applyDefault(ReaderView.PROP_FONT_FACE, ""Droid Sans"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_FACE, ""Droid Sans"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_SIZE, ""16"");
        props.applyDefault(ReaderView.PROP_FONT_COLOR, ""#000000"");
        props.applyDefault(ReaderView.PROP_FONT_COLOR_DAY, ""#000000"");
        props.applyDefault(ReaderView.PROP_FONT_COLOR_NIGHT, ""#808080"");
        props.applyDefault(ReaderView.PROP_BACKGROUND_COLOR, ""#FFFFFF"");
        props.applyDefault(ReaderView.PROP_BACKGROUND_COLOR_DAY, ""#FFFFFF"");
        props.applyDefault(ReaderView.PROP_BACKGROUND_COLOR_NIGHT, ""#101010"");
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR, ""#FF000000""); // don't use separate color
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR_DAY, ""#FF000000""); // don't use separate color
        props.applyDefault(ReaderView.PROP_STATUS_FONT_COLOR_NIGHT, ""#80000000""); // don't use separate color
        props.setProperty(ReaderView.PROP_ROTATE_ANGLE, ""0""); // crengine's rotation will not be user anymore
        props.setProperty(ReaderView.PROP_DISPLAY_INVERSE, ""0"");
        props.applyDefault(ReaderView.PROP_APP_FULLSCREEN, ""0"");
        props.applyDefault(ReaderView.PROP_APP_SCREEN_BACKLIGHT, ""-1"");
		props.applyDefault(ReaderView.PROP_SHOW_BATTERY, ""1""); 
		props.applyDefault(ReaderView.PROP_SHOW_POS_PERCENT, ""0""); 
		props.applyDefault(ReaderView.PROP_SHOW_PAGE_COUNT, ""1""); 
		props.applyDefault(ReaderView.PROP_SHOW_TIME, ""1"");
		props.applyDefault(ReaderView.PROP_FONT_ANTIALIASING, ""2"");
		props.applyDefault(ReaderView.PROP_APP_SHOW_COVERPAGES, ""1"");
		props.applyDefault(ReaderView.PROP_APP_SCREEN_ORIENTATION, ""4"");
		props.applyDefault(ReaderView.PROP_PAGE_ANIMATION, ReaderView.PAGE_ANIMATION_SLIDE2);
		props.applyDefault(ReaderView.PROP_CONTROLS_ENABLE_VOLUME_KEYS, ""1"");
		props.applyDefault(ReaderView.PROP_APP_TAP_ZONE_HILIGHT, ""0"");
		props.applyDefault(ReaderView.PROP_APP_BOOK_SORT_ORDER, FileInfo.DEF_SORT_ORDER.name());
		props.applyDefault(ReaderView.PROP_APP_DICTIONARY, dicts[0].id);
		props.applyDefault(ReaderView.PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS, ""0"");
		props.applyDefault(ReaderView.PROP_APP_SELECTION_ACTION, ""0"");
		//props.applyDefault(ReaderView.PROP_FALLBACK_FONT_FACE, ""Droid Fallback"");
		props.put(ReaderView.PROP_FALLBACK_FONT_FACE, ""Droid Sans Fallback"");
		
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_LEFT, densityDpi > 160 ? ""10"" : ""4"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_RIGHT, densityDpi > 160 ? ""10"" : ""4"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_TOP, densityDpi > 160 ? ""8"" : ""2"");
		props.applyDefault(ReaderView.PROP_PAGE_MARGIN_BOTTOM, densityDpi > 160 ? ""8"" : ""2"");
		
        props.applyDefault(ReaderView.PROP_NIGHT_MODE, ""0"");
        if ( props.getBool(ReaderView.PROP_NIGHT_MODE, false) )
        	props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.DEF_NIGHT_BACKGROUND_TEXTURE);
        else
        	props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.DEF_DAY_BACKGROUND_TEXTURE);
        props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_DAY, Engine.DEF_DAY_BACKGROUND_TEXTURE);
        props.applyDefault(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_NIGHT, Engine.DEF_NIGHT_BACKGROUND_TEXTURE);
        
		
		props.setProperty(ReaderView.PROP_MIN_FILE_SIZE_TO_CACHE, ""100000"");
		props.setProperty(ReaderView.PROP_FORCED_MIN_FILE_SIZE_TO_CACHE, ""32768"");
		props.applyDefault(ReaderView.PROP_HYPHENATION_DICT, Engine.HyphDict.RUSSIAN.toString());
		props.applyDefault(ReaderView.PROP_APP_FILE_BROWSER_SIMPLE_MODE, ""0"");
		
		return props;
	}

	public static class DictInfo {
		public final String id; 
		public final String name;
		public final String packageName;
		public final String className;
		public final String action;
		public DictInfo ( String id, String name, String packageName, String className, String action ) {
			this.id = id;
			this.name = name;
			this.packageName = packageName;
			this.className = className;
			this.action = action;
		}
	}
	private static final DictInfo dicts[] = {
		new DictInfo(""Fora"", ""Fora Dictionary"", ""com.ngc.fora"", ""com.ngc.fora.ForaDictionary"", Intent.ACTION_SEARCH),	
		new DictInfo(""ColorDict"", ""ColorDict"", ""com.socialnmobile.colordict"", ""com.socialnmobile.colordict.activity.Main"", Intent.ACTION_SEARCH),	
	};

	public DictInfo[] getDictList() {
		return dicts;
	}
	
	private DictInfo currentDict = dicts[0];
	
	public void setDict( String id ) {
		for ( DictInfo d : dicts ) {
			if ( d.id.equals(id) ) {
				currentDict = d;
				return;
			}
		}
	}
	
	public void findInDictionary( String s ) {
		if ( s!=null && s.length()!=0 ) {
			s = s.trim();
			for ( ;s.length()>0; ) {
				char ch = s.charAt(s.length()-1);
				if ( ch>=128 )
					break;
				if ( ch>='0' && ch<='9' || ch>='A' && ch<='Z' || ch>='a' && ch<='z' )
					break;
				s = s.substring(0, s.length()-1);
			}
			if ( s.length()>0 ) {
				//
				Intent intent = new Intent(currentDict.action).setComponent(new ComponentName(
						currentDict.packageName, currentDict.className
						)).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
				intent.putExtra(SearchManager.QUERY, s);
				try {
					startActivity( intent );
				} catch ( ActivityNotFoundException e ) {
					showToast(""Dictionary \"""" + currentDict.name + ""\"" is not installed"");
				}
			}
		}
	}
	
	public void saveSettings( Properties settings )
	{
		try {
			log.v(""saveSettings() "" + settings);
    		FileOutputStream os = new FileOutputStream(propsFile);
    		settings.store(os, ""Cool Reader 3 settings"");
			log.i(""Settings successfully saved to file "" + propsFile.getAbsolutePath());
		} catch ( Exception e ) {
			log.e(""exception while saving settings"", e);
		}
	}

	private static Debug.MemoryInfo info = new Debug.MemoryInfo();
	private static Field[] infoFields = Debug.MemoryInfo.class.getFields();
	private static String dumpFields( Field[] fields, Object obj) {
		StringBuilder buf = new StringBuilder();
		try {
			for ( Field f : fields ) {
				if ( buf.length()>0 )
					buf.append("", "");
				buf.append(f.getName());
				buf.append(""="");
				buf.append(f.get(obj));
			}
		} catch ( Exception e ) {
			
		}
		return buf.toString();
	}
	public static void dumpHeapAllocation() {
		Debug.getMemoryInfo(info);
		log.d(""nativeHeapAlloc="" + Debug.getNativeHeapAllocatedSize() + "", nativeHeapSize="" + Debug.getNativeHeapSize() + "", info: "" + dumpFields(infoFields, info));
	}
	
	public void showAboutDialog() {
		AboutDialog dlg = new AboutDialog(this);
		dlg.show();
	}
}
",True,37,38,0,0,2,20,20,17,L1
1,org.coolreader.crengine.Selection.java,"package org.coolreader.crengine;

public class Selection {
	// IN
	public int startX;
	public int startY;
	public int endX;
	public int endY;
	// OUT
	public String startPos; 
	public String endPos;
	public String text;
	public String chapter;
	public int percent;
	
	boolean isEmpty() { return startPos==null || endPos==null; }
}
",False,25,26,4,11,0,0,2,0,L2
2,org.coolreader.crengine.BookSearchDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.text.Editable;
import android.text.TextWatcher;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.TextView.OnEditorActionListener;

public class BookSearchDialog extends BaseDialog {
	
	private final CoolReader mCoolReader;
	private final LayoutInflater mInflater;
	final EditText authorEdit;
	final EditText titleEdit;
	final EditText seriesEdit;
	final EditText filenameEdit;
	final TextView statusText;
	final SearchCallback callback;
	
	private int searchTaskId = 0;
	private boolean searchActive = false;
	private boolean closing = false;
	
	public BookSearchDialog( CoolReader activity, SearchCallback callback )
	{
		super(activity, R.string.dlg_button_find, R.string.dlg_button_cancel, false);
		mCoolReader = activity;
		this.callback = callback;
		setTitle(mCoolReader.getString( R.string.dlg_book_search));
		mInflater = LayoutInflater.from(getContext());
		View view = mInflater.inflate(R.layout.book_search_dialog, null);
		authorEdit = (EditText)view.findViewById(R.id.search_text_author);
		titleEdit = (EditText)view.findViewById(R.id.search_text_title);
		seriesEdit = (EditText)view.findViewById(R.id.search_text_series);
		filenameEdit = (EditText)view.findViewById(R.id.search_text_filename);
		statusText = (TextView)view.findViewById(R.id.search_status);
		TextWatcher watcher = new TextWatcher() {

			@Override
			public void afterTextChanged(Editable s) {
			}

			@Override
			public void beforeTextChanged(CharSequence s, int start, int count,
					int after) {
			}

			@Override
			public void onTextChanged(CharSequence s, int start, int before,
					int count) {
				postSearchTask();
			}
			
		}; 
		authorEdit.addTextChangedListener(watcher);
		seriesEdit.addTextChangedListener(watcher);
		titleEdit.addTextChangedListener(watcher);
		filenameEdit.addTextChangedListener(watcher);
		setView( view );
	}

	private void postSearchTask() {
		if ( closing )
			return;
		final int mySearchTaskId = ++searchTaskId;
		BackgroundThread.instance().postGUI(new Runnable() {
			@Override
			public void run() {
				if ( searchTaskId == mySearchTaskId ) {
					if ( searchActive )
						return;
					searchActive = true;
					find( new SearchCallback() {
						@Override
						public void done(FileInfo[] results) {
							searchActive = false;
							statusText.setText(mCoolReader.getString(R.string.dlg_book_search_found) + "" "" + results.length);
							if ( searchTaskId != mySearchTaskId ) {
								postSearchTask();
							}
						}
					});
				}
			}
		}, 3000);
	}
	
	public interface SearchCallback {
		public void done( FileInfo[] results );
	}

	private static String addWildcard( String s, boolean before, boolean after ) {
		if ( s==null || s.length()==0 )
			return s;
		if ( before )
			s = ""%"" + s;
		if ( after )
			s = s + ""%"";
		return s;
	}
	
	private final static int MAX_RESULTS = 50; 
	protected void find( final SearchCallback cb ) {
		final String author = addWildcard(authorEdit.getText().toString().trim(), false, true);
		final String series = addWildcard(seriesEdit.getText().toString().trim(), false, true);
		final String title = addWildcard(titleEdit.getText().toString().trim(), true, true);
		final String filename = addWildcard(filenameEdit.getText().toString().trim(), true, true);
		BackgroundThread.instance().executeBackground( new Runnable() {
			@Override
			public void run() {
				final FileInfo[] results = mCoolReader.getDB().findByPatterns(MAX_RESULTS, author, title, series, filename);
				BackgroundThread.instance().executeGUI( new Runnable() {
					@Override
					public void run() {
						cb.done(results);
					}
				});
			}
		});
	}
	
	@Override
	protected void onPositiveButtonClick() {
		searchTaskId++;
		closing = true;
		super.onPositiveButtonClick();
		find( callback );
	}

	@Override
	protected void onNegativeButtonClick() {
		searchTaskId++;
		closing = true;
		super.onNegativeButtonClick();
		callback.done(null);
	}
}
",False,27,38,0,0,3,16,1,5,L1
3,org.coolreader.crengine.SelectionToolbarDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;

public class SelectionToolbarDlg {
	PopupWindow mWindow;
	View mAnchor;
	CoolReader mCoolReader;
	ReaderView mReaderView;
	View mPanel;
	final Selection selection;
	static public void showDialog( CoolReader coolReader, ReaderView readerView, final Selection selection )
	{
		SelectionToolbarDlg dlg = new SelectionToolbarDlg(coolReader, readerView, selection);
		//dlg.mWindow.update(dlg.mAnchor, width, height)
		Log.d(""cr3"", ""popup: "" + dlg.mWindow.getWidth() + ""x"" + dlg.mWindow.getHeight());
		//dlg.update();
		//dlg.showAtLocation(readerView, Gravity.LEFT|Gravity.TOP, readerView.getLeft()+50, readerView.getTop()+50);
		//dlg.showAsDropDown(readerView);
		//dlg.update();
	}
	public SelectionToolbarDlg( CoolReader coolReader, ReaderView readerView, final Selection sel )
	{
		this.selection = sel;
		mCoolReader = coolReader;
		mReaderView = readerView;
		mAnchor = readerView;

		View panel = (LayoutInflater.from(coolReader.getApplicationContext()).inflate(R.layout.selection_toolbar, null));
		panel.measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		
		//mReaderView.getS
		
		mWindow = new PopupWindow( mAnchor.getContext() );
		mWindow.setTouchInterceptor(new OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
					mReaderView.clearSelection();
					mWindow.dismiss();
					return true;
				}
				return false;
			}
		});
		//super(panel);
		mPanel = panel;
		mPanel.findViewById(R.id.selection_copy).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.copyToClipboard(selection.text);
				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.findViewById(R.id.selection_dict).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				//mReaderView.findNext(pattern, false, caseInsensitive);
				mCoolReader.findInDictionary( sel.text );
				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.findViewById(R.id.selection_bookmark).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				//mReaderView.findNext(pattern, false, caseInsensitive);
				mReaderView.showNewBookmarkDialog(sel);
				mWindow.dismiss();
			}
		});
		mPanel.findViewById(R.id.selection_cancel).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.setFocusable(true);
		mPanel.setOnKeyListener( new OnKeyListener() {

			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ( event.getAction()==KeyEvent.ACTION_UP ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_BACK:
						mReaderView.clearSelection();
						mWindow.dismiss();
						return true;
//					case KeyEvent.KEYCODE_DPAD_LEFT:
//					case KeyEvent.KEYCODE_DPAD_UP:
//						//mReaderView.findNext(pattern, true, caseInsensitive);
//						return true;
//					case KeyEvent.KEYCODE_DPAD_RIGHT:
//					case KeyEvent.KEYCODE_DPAD_DOWN:
//						//mReaderView.findNext(pattern, false, caseInsensitive);
//						return true;
					}
				} else if ( event.getAction()==KeyEvent.ACTION_DOWN ) {
						switch ( keyCode ) {
//						case KeyEvent.KEYCODE_BACK:
//						case KeyEvent.KEYCODE_DPAD_LEFT:
//						case KeyEvent.KEYCODE_DPAD_UP:
//						case KeyEvent.KEYCODE_DPAD_RIGHT:
//						case KeyEvent.KEYCODE_DPAD_DOWN:
//							return true;
						}
					}
				if ( keyCode == KeyEvent.KEYCODE_BACK) {
					return true;
				}
				return false;
			}
			
		});

		mWindow.setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss() {
				mReaderView.clearSelection();
			}
		});
		
		mWindow.setBackgroundDrawable(new BitmapDrawable());
		//mWindow.setAnimationStyle(android.R.style.Animation_Toast);
		mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
		mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
//		setWidth(panel.getWidth());
//		setHeight(panel.getHeight());
		
		mWindow.setFocusable(true);
		mWindow.setTouchable(true);
		mWindow.setOutsideTouchable(true);
		mWindow.setContentView(panel);
		
		
		int [] location = new int[2];
		mAnchor.getLocationOnScreen(location);
		//mWindow.update(location[0], location[1], mPanel.getWidth(), mPanel.getHeight() );
		//mWindow.setWidth(mPanel.getWidth());
		//mWindow.setHeight(mPanel.getHeight());

		mWindow.showAtLocation(mAnchor, Gravity.TOP | Gravity.CENTER_HORIZONTAL, location[0], location[1] + mAnchor.getHeight() - mPanel.getHeight());
//		if ( mWindow.isShowing() )
//			mWindow.update(mAnchor, 50, 50);
		//dlg.mWindow.showAsDropDown(dlg.mAnchor);
	
	}
	
}
",False,9,38,0,0,3,29,1,3,L2
4,org.coolreader.crengine.BookInfo.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

import android.util.Log;

public class BookInfo {
	private FileInfo fileInfo;
	private Bookmark lastPosition;
	private ArrayList<Bookmark> bookmarks = new ArrayList<Bookmark>();

	synchronized public void setShortcutBookmark(int shortcut, Bookmark bookmark)
	{
		bookmark.setShortcut(shortcut);
		bookmark.setModified(true);
		for ( int i=0; i<bookmarks.size(); i++ ) {
			Bookmark bm = bookmarks.get(i);
			if ( bm.getType()==Bookmark.TYPE_POSITION && bm.getShortcut()==shortcut ) {
				bookmark.setId(bm.getId());
				bookmarks.set(i, bookmark);
				return;
			}
		}
		bookmarks.add(bookmark);
	}
	
	synchronized public Bookmark findShortcutBookmark( int shortcut )
	{
		for ( Bookmark bm : bookmarks )
			if ( bm.getType()==Bookmark.TYPE_POSITION && bm.getShortcut()==shortcut )
				return bm;
		return null;
	}
	
	public void updateAccess()
	{
		// TODO:
	}
	
	public BookInfo( FileInfo fileInfo )
	{
		this.fileInfo = fileInfo; //new FileInfo(fileInfo);
	}
	
	public Bookmark getLastPosition()
	{
		return lastPosition;
	}
	
	synchronized public void setLastPosition( Bookmark position )
	{
		if ( lastPosition!=null )
			position.setId(lastPosition.getId());
		lastPosition = position;
		lastPosition.setModified(true);
		fileInfo.lastAccessTime = lastPosition.getTimeStamp();
		fileInfo.setModified(true);
	}
	
	public FileInfo getFileInfo()
	{
		return fileInfo;
	}
	
	synchronized public void addBookmark( Bookmark bm )
	{
		bookmarks.add(bm);
	}

	synchronized public int getBookmarkCount()
	{
		return bookmarks.size();
	}

	synchronized public Bookmark getBookmark( int index )
	{
		return bookmarks.get(index);
	}

	synchronized public Bookmark removeBookmark( Bookmark bm )
	{
		if ( bm==null )
			return null;
		int index = -1;
		for ( int i=0; i<bookmarks.size(); i++ ) {
			if ( bm.getShortcut()>0 && bookmarks.get(0).getShortcut()==bm.getShortcut() ) {
				index = i;
				break;
			}
			if ( bm.getStartPos()!=null && bm.getStartPos().equals(bookmarks.get(i).getStartPos())) {
				index = i;
				break;
			}
		}
		if ( index<0 ) {
			Log.e(""cr3"", ""cannot find bookmark "" + bm);
			return null;
		}
		return bookmarks.remove(index);
	}

	synchronized public void sortBookmarks() {
		Collections.sort(bookmarks, new Comparator<Bookmark>() {
			@Override
			public int compare(Bookmark bm1, Bookmark bm2) {
				if ( bm1.getPercent() < bm2.getPercent() )
					return -1;
				if ( bm1.getPercent() > bm2.getPercent() )
					return 1;
				return 0;
			}
		});
	}
	
	synchronized public boolean exportBookmarks( String fileName ) {
		Log.i(""cr3"", ""Exporting bookmarks to file "" + fileName);
		try { 
			FileOutputStream stream = new FileOutputStream(new File(fileName));
			OutputStreamWriter writer = new OutputStreamWriter(stream, ""UTF-8""); 
			writer.write(0xfeff);
			writer.write(""# Cool Reader 3 - exported bookmarks\r\n"");
			File pathname = new File(fileInfo.getPathName());
			writer.write(""# file name: "" + pathname.getName() + ""\r\n"");
			writer.write(""# file path: "" + pathname.getParent() + ""\r\n"");
			writer.write(""# book title: "" + fileInfo.title + ""\r\n"");
			writer.write(""# author: "" + fileInfo.authors + ""\r\n"");
			writer.write(""# series: "" + fileInfo.series + ""\r\n"");
			writer.write(""\r\n"");
			for ( Bookmark bm : bookmarks ) {
				if ( bm.getType()!=Bookmark.TYPE_COMMENT && bm.getType()!=Bookmark.TYPE_CORRECTION )
					continue;
				int percent = bm.getPercent();
				String ps = String.valueOf(percent%100);
				if ( ps.length()<2 )
					ps = ""0"" + ps;
				ps = String.valueOf(percent/100) + ""."" + ps  + ""%"";
				writer.write(""## "" + ps + "" - "" + (bm.getType()!=Bookmark.TYPE_COMMENT ? ""comment"" : ""correction"")  + ""\r\n"");
				if ( bm.getTitleText()!=null )
					writer.write(""## "" + bm.getTitleText() + ""\r\n"");
				if ( bm.getPosText()!=null )
					writer.write(""<< "" + bm.getPosText() + ""\r\n"");
				if ( bm.getCommentText()!=null )
					writer.write("">> "" + bm.getCommentText() + ""\r\n"");
				writer.write(""\r\n"");
			}
			writer.close();
			return true;
		} catch ( IOException e ) {
			Log.e(""cr3"", ""Cannot write bookmark file "" + fileName);
			return false;
		}
	}
	
	
	synchronized public Bookmark removeBookmark( int index )
	{
		return bookmarks.remove(index);
	}
	
	synchronized void setBookmarks(ArrayList<Bookmark> list)
	{
		if ( list.size()>0 ) {
			if ( list.get(0).getType()==0 ) {
				lastPosition = list.remove(0); 
			}
		}
		if ( list.size()>0 ) {
			bookmarks = list;
		}
	}

	@Override
	public String toString() {
		return ""BookInfo [fileInfo="" + fileInfo + "", lastPosition=""
				+ lastPosition + ""]"";
	}

	
	
}
",True,33,30,4,12,2,2,5,2,L1
5,org.coolreader.crengine.ProgressDialog.java,"package org.coolreader.crengine;

import android.app.AlertDialog;
import android.content.Context;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import org.coolreader.R;

/**
 * Progress dialog, based on source code of android.app.ProgressDialog
 */
public class ProgressDialog extends AlertDialog {
    
    /** Creates a ProgressDialog with a ciruclar, spinning progress
     * bar. This is the default.
     */
    public static final int STYLE_SPINNER = 0;
    
    /** Creates a ProgressDialog with a horizontal progress bar.
     */
    public static final int STYLE_HORIZONTAL = 1;
    
    private ProgressBar mProgress;
    private TextView mMessageView;
    
    private int mProgressStyle = STYLE_SPINNER;
    
    private int mMax;
    private int mProgressVal;
    private int mSecondaryProgressVal;
    private int mIncrementBy;
    private int mIncrementSecondaryBy;
    private Drawable mProgressDrawable;
    private Drawable mIndeterminateDrawable;
    private CharSequence mMessage;
    private boolean mIndeterminate;
    
    private boolean mHasStarted;
    private Handler mViewUpdateHandler;
    private Context mContext;
    
    public ProgressDialog(Context context) {
        super(context);
        mContext = context;
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message) {
        return show(context, title, message, false);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate) {
        return show(context, title, message, indeterminate, false, null);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate, boolean cancelable) {
        return show(context, title, message, indeterminate, cancelable, null);
    }

    public static ProgressDialog show(Context context, CharSequence title,
            CharSequence message, boolean indeterminate,
            boolean cancelable, OnCancelListener cancelListener) {
        ProgressDialog dialog = new ProgressDialog(context);
        dialog.setTitle(title);
        dialog.setMessage(message);
        dialog.setIndeterminate(indeterminate);
        dialog.setCancelable(cancelable);
        dialog.setOnCancelListener(cancelListener);
        dialog.show();
        return dialog;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        LayoutInflater inflater = LayoutInflater.from(mContext);
        if (mProgressStyle == STYLE_HORIZONTAL) {
            
            /* Use a separate handler to update the text views as they
             * must be updated on the same thread that created them.
             */
            mViewUpdateHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    super.handleMessage(msg);
                }
            };
            View view = inflater.inflate(R.layout.alert_dialog_progress, null);
            mProgress = (ProgressBar) view.findViewById(R.id.progress);
            setView(view);
        } else {
            View view = inflater.inflate(R.layout.progress_dialog, null);
            mProgress = (ProgressBar) view.findViewById(R.id.progress);
            mMessageView = (TextView) view.findViewById(R.id.message);
            setView(view);
        }
        if (mMax > 0) {
            setMax(mMax);
        }
        if (mProgressVal > 0) {
            setProgress(mProgressVal);
        }
        if (mSecondaryProgressVal > 0) {
            setSecondaryProgress(mSecondaryProgressVal);
        }
        if (mIncrementBy > 0) {
            incrementProgressBy(mIncrementBy);
        }
        if (mIncrementSecondaryBy > 0) {
            incrementSecondaryProgressBy(mIncrementSecondaryBy);
        }
        if (mProgressDrawable != null) {
            setProgressDrawable(mProgressDrawable);
        }
        if (mIndeterminateDrawable != null) {
            setIndeterminateDrawable(mIndeterminateDrawable);
        }
        if (mMessage != null) {
            setMessage(mMessage);
        }
        setIndeterminate(mIndeterminate);
        onProgressChanged();
        super.onCreate(savedInstanceState);
    }
    
    @Override
    public void onStart() {
        super.onStart();
        mHasStarted = true;
    }
    
    @Override
    protected void onStop() {
        super.onStop();
        mHasStarted = false;
    }

    public void setProgress(int value) {
        if (mHasStarted && mProgress!=null) {
            mProgress.setProgress(value);
            onProgressChanged();
        } else {
            mProgressVal = value;
        }
    }

    public void setSecondaryProgress(int secondaryProgress) {
        if (mProgress != null) {
            mProgress.setSecondaryProgress(secondaryProgress);
            onProgressChanged();
        } else {
            mSecondaryProgressVal = secondaryProgress;
        }
    }

    public int getProgress() {
        if (mProgress != null) {
            return mProgress.getProgress();
        }
        return mProgressVal;
    }

    public int getSecondaryProgress() {
        if (mProgress != null) {
            return mProgress.getSecondaryProgress();
        }
        return mSecondaryProgressVal;
    }

    public int getMax() {
        if (mProgress != null) {
            return mProgress.getMax();
        }
        return mMax;
    }

    public void setMax(int max) {
        if (mProgress != null) {
            mProgress.setMax(max);
            onProgressChanged();
        } else {
            mMax = max;
        }
    }

    public void incrementProgressBy(int diff) {
        if (mProgress != null) {
            mProgress.incrementProgressBy(diff);
            onProgressChanged();
        } else {
            mIncrementBy += diff;
        }
    }

    public void incrementSecondaryProgressBy(int diff) {
        if (mProgress != null) {
            mProgress.incrementSecondaryProgressBy(diff);
            onProgressChanged();
        } else {
            mIncrementSecondaryBy += diff;
        }
    }

    public void setProgressDrawable(Drawable d) {
        if (mProgress != null) {
            mProgress.setProgressDrawable(d);
        } else {
            mProgressDrawable = d;
        }
    }

    public void setIndeterminateDrawable(Drawable d) {
        if (mProgress != null) {
            mProgress.setIndeterminateDrawable(d);
        } else {
            mIndeterminateDrawable = d;
        }
    }

    public void setIndeterminate(boolean indeterminate) {
        if (mProgress != null) {
            mProgress.setIndeterminate(indeterminate);
        } else {
            mIndeterminate = indeterminate;
        }
    }

    public boolean isIndeterminate() {
        if (mProgress != null) {
            return mProgress.isIndeterminate();
        }
        return mIndeterminate;
    }
    
    @Override
    public void setMessage(CharSequence message) {
        if (mProgress != null) {
            if (mProgressStyle == STYLE_HORIZONTAL) {
                super.setMessage(message);
            } else {
                mMessageView.setText(message);
            }
        } else {
            mMessage = message;
        }
    }
    
    public void setProgressStyle(int style) {
        mProgressStyle = style;
    }

    private void onProgressChanged() {
        if (mProgressStyle == STYLE_HORIZONTAL) {
            mViewUpdateHandler.sendEmptyMessage(0);
        }
    }
}
",True,5,26,5,15,0,0,2,0,L1
6,org.coolreader.crengine.SearchDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.CheckBox;
import android.widget.EditText;

public class SearchDlg  extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	private LayoutInflater mInflater;
	View mDialogView;
	EditText mEditView;
	CheckBox mCaseSensitive;
	CheckBox mReverse;
	
	@Override
	protected void onPositiveButtonClick()
	{
		// override it
    	String pattern = mEditView.getText().toString();
    	if ( pattern==null || pattern.length()==0 ) 
    		mCoolReader.showToast(""No pattern specified"");
    	else
    		mReaderView.findText( mEditView.getText().toString(), mReverse.isChecked(), !mCaseSensitive.isChecked() );
        cancel();
	}
	
	@Override
	protected void onNegativeButtonClick()
	{
		// override it
        cancel();
	}

	
	public SearchDlg( CoolReader coolReader, ReaderView readerView )
	{
		super(coolReader, R.string.dlg_button_find, R.string.dlg_button_cancel, false);
        setCancelable(true);
		this.mCoolReader = coolReader;
		this.mReaderView = readerView;
        mInflater = LayoutInflater.from(getContext());
        mDialogView = mInflater.inflate(R.layout.search_dialog, null);
    	mEditView = (EditText)mDialogView.findViewById(R.id.search_text);
    	mCaseSensitive = (CheckBox)mDialogView.findViewById(R.id.search_case_sensitive);
    	mReverse = (CheckBox)mDialogView.findViewById(R.id.search_reverse);
		setTitle(mCoolReader.getResources().getString(R.string.win_title_search));
		// setup buttons
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setView(mDialogView);
	}
}
",False,16,38,0,0,3,29,1,3,L2
7,org.coolreader.crengine.OptionsDialog.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.ColorPickerDialog.OnColorChangedListener;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.database.DataSetObserver;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.RadioButton;
import android.widget.TabHost;
import android.widget.TabHost.TabContentFactory;
import android.widget.TextView;

public class OptionsDialog extends BaseDialog implements TabContentFactory, OptionOwner {

	ReaderView mReaderView;
	CoolReader mActivity;
	String[] mFontFaces;
	int[] mFontSizes = new int[] {
		12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 28, 30,
		32, 34, 36, 38, 40, 42, 44, 48, 52, 56, 60, 64, 68, 72
	};
	int[] mStatusFontSizes = new int[] {
			10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 22, 24, 26, 28, 30,
			32
		};
	public static int findBacklightSettingIndex( int value ) {
		int bestIndex = 0;
		int bestDiff = -1;
		for ( int i=0; i<mBacklightLevels.length; i++ ) {
			int diff = mBacklightLevels[i] - value;
			if (diff<0)
				diff = -diff;
			if ( bestDiff==-1 || diff < bestDiff ) {
				bestDiff = diff;
				bestIndex = i;
			}
		}
		return bestIndex;
	}
	public static final int[] mBacklightLevels = new int[] {
		-1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100
	};
	public static final String[] mBacklightLevelsTitles = new String[] {
			""Default"", ""1%"", ""2%"", ""3%"", ""4%"", ""5%"", ""6%"", ""7%"", ""8%"", ""9%"", 
			""10%"", ""12%"", ""15%"", ""20%"", ""25%"", ""30%"", ""35%"", ""40%"", ""45%"", ""50%"", ""55%"", ""60%"", ""65%"", ""70%"", ""75%"", ""80%"", ""85%"", ""90%"", ""95%"", ""100%"",
	};
	int[] mInterlineSpaces = new int[] {
			80, 90, 100, 105, 110, 115, 120, 130, 140, 150, 160, 180, 200
		};
	int[] mMargins = new int[] {
			0, 1, 2, 3, 4, 5, 8, 10, 12, 15, 20, 25, 30
		};
	int[] mOrientations = new int[] {
			0, 1//, 2, 3
			,4
		};
	int[] mOrientationsTitles = new int[] {
			R.string.options_page_orientation_0, R.string.options_page_orientation_90 //, R.string.options_page_orientation_180, R.string.options_page_orientation_270
			,R.string.options_page_orientation_sensor
		};
	int[] mFlickBrightness = new int[] {
			0, 1, 2
		};
	int[] mFlickBrightnessTitles = new int[] {
			R.string.options_controls_flick_brightness_none, R.string.options_controls_flick_brightness_left, R.string.options_controls_flick_brightness_right
		};
	int[] mAnimation = new int[] {
			ReaderView.PAGE_ANIMATION_NONE, ReaderView.PAGE_ANIMATION_SLIDE, ReaderView.PAGE_ANIMATION_SLIDE2, 
			ReaderView.PAGE_ANIMATION_PAPER
		};
	int[] mAnimationTitles = new int[] {
			R.string.options_page_animation_none, R.string.options_page_animation_slide, R.string.options_page_animation_slide_2_pages,
			R.string.options_page_animation_paperbook
		};
	int[] mSelectionAction = new int[] {
			ReaderView.SELECTION_ACTION_TOOLBAR, ReaderView.SELECTION_ACTION_COPY, 
			ReaderView.SELECTION_ACTION_DICTIONARY,
			ReaderView.SELECTION_ACTION_BOOKMARK
		};
	int[] mSelectionActionTitles = new int[] {
			R.string.options_selection_action_toolbar, 
			R.string.options_selection_action_copy, 
			R.string.options_selection_action_dictionary, 
			R.string.options_selection_action_bookmark, 
		};
	int[] mAntialias = new int[] {
			0, 1, 2
		};
	int[] mAntialiasTitles = new int[] {
			R.string.options_font_antialias_off, R.string.options_font_antialias_on_for_big, R.string.options_font_antialias_on_for_all
		};
	int[] mLandscapePages = new int[] {
			1, 2
		};
	int[] mLandscapePagesTitles = new int[] {
			R.string.options_page_landscape_pages_one, R.string.options_page_landscape_pages_two
		};
	int[] mViewModes = new int[] {
			1, 0
		};
	int[] mViewModeTitles = new int[] {
			R.string.options_view_mode_pages, R.string.options_view_mode_scroll
		};
	TabHost mTabs;
	LayoutInflater mInflater;
	Properties mProperties;
	Properties mOldProperties;
	OptionsListView mOptionsStyles;
	OptionsListView mOptionsPage;
	OptionsListView mOptionsApplication;
	OptionsListView mOptionsControls;

	public final static int OPTION_VIEW_TYPE_NORMAL = 0;
	public final static int OPTION_VIEW_TYPE_BOOLEAN = 1;
	public final static int OPTION_VIEW_TYPE_COLOR = 2;
	//public final static int OPTION_VIEW_TYPE_COUNT = 3;

	public CoolReader getActivity() { return mActivity; }
	public Properties getProperties() { return mProperties; }
	public LayoutInflater getInflater() { return mInflater; }
	
	public static class OptionBase {
		protected View myView;
		Properties mProperties;
		CoolReader mActivity;
		OptionOwner mOwner;
		LayoutInflater mInflater;
		public String label;
		public String property;
		public String defaultValue;
		public int iconId = R.drawable.cr3_option_other;
		public OptionsListView optionsListView;
		protected Runnable onChangeHandler;
		public OptionBase( OptionOwner owner, String label, String property ) {
			this.mOwner = owner;
			this.mActivity = owner.getActivity();
			this.mInflater = owner.getInflater();
			this.mProperties = owner.getProperties();
			this.label = label;
			this.property = property;
		}
		public OptionBase setIconId(int id) {
			this.iconId = id;
			return this;
		}
		public OptionBase setDefaultValue(String value) {
			this.defaultValue = value;
			if ( mProperties.getProperty(property)==null )
				mProperties.setProperty(property, value);
			return this;
		}
		public void setOnChangeHandler( Runnable handler ) {
			onChangeHandler = handler;
		}

		public int getItemViewType() {
			return OPTION_VIEW_TYPE_NORMAL;
		}

		protected void refreshItem()
		{
			getView(null, null).invalidate();
			//if ( optionsListView!=null )
			//	optionsListView.refresh();
		}

		protected void refreshList()
		{
			getView(null, null).invalidate();
			if ( optionsListView!=null )
				optionsListView.refresh();
		}

		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			TextView valueView = (TextView)view.findViewById(R.id.option_value);
			labelView.setText(label);
			valueView.setText(getValueLabel());
//			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
//			icon.setImageResource(iconId);
			return view;
		}

		public String getValueLabel() { return mProperties.getProperty(property); }
		public void onSelect() { refreshList(); }
	}
	
	class ColorOption extends OptionBase {
		final int defColor;
		public ColorOption( OptionOwner owner, String label, String property, int defColor ) {
			super(owner, label, property);
			this.defColor = defColor;
		}
		public String getValueLabel() { return mProperties.getProperty(property); }
		public void onSelect()
		{ 
			ColorPickerDialog dlg = new ColorPickerDialog(mActivity, new OnColorChangedListener() {
				public void colorChanged(int color) {
					mProperties.setColor(property, color);
					if ( property.equals(ReaderView.PROP_BACKGROUND_COLOR) ) {
						String texture = mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.NO_TEXTURE.id);
						if ( texture!=null && !texture.equals(Engine.NO_TEXTURE.id) ) {
							// reset background image
							mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, Engine.NO_TEXTURE.id);
							// TODO: show notification?
						}
					}
					refreshList();
				}
			}, mProperties.getColor(property, defColor), label);
			dlg.show();
		}
		public int getItemViewType() {
			return OPTION_VIEW_TYPE_COLOR;
		}
		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item_color, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			ImageView valueView = (ImageView)view.findViewById(R.id.option_value_color);
			labelView.setText(label);
			int cl = mProperties.getColor(property, defColor);
			valueView.setBackgroundColor(cl);
//			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
//			icon.setImageResource(iconId);
			return view;
		}
	}
	
	class BoolOption extends OptionBase {
		private boolean inverse = false;
		public BoolOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		private boolean getValueBoolean() { return ""1"".equals(mProperties.getProperty(property)) ^ inverse; }
		public String getValueLabel() { return getValueBoolean()  ? getString(R.string.options_value_on) : getString(R.string.options_value_off); }
		public void onSelect() { 
			mProperties.setProperty(property, ""1"".equals(mProperties.getProperty(property)) ? ""0"" : ""1"");
			refreshList();
		}
		public BoolOption setInverse() { inverse = true; return this; }
		public int getItemViewType() {
			return OPTION_VIEW_TYPE_BOOLEAN;
		}
		public View getView(View convertView, ViewGroup parent) {
			View view;
			convertView = myView;
			if ( convertView==null ) {
				//view = new TextView(getContext());
				view = mInflater.inflate(R.layout.option_item_boolean, null);
			} else {
				view = (View)convertView;
			}
			myView = view;
			TextView labelView = (TextView)view.findViewById(R.id.option_label);
			CheckBox valueView = (CheckBox)view.findViewById(R.id.option_value_cb);
//			valueView.setFocusable(false);
//			valueView.setClickable(false);
			labelView.setText(label);
			valueView.setChecked(getValueBoolean());
			valueView.setOnCheckedChangeListener(new OnCheckedChangeListener() {
					@Override
					public void onCheckedChanged(CompoundButton arg0,
							boolean checked) {
//						mProperties.setBool(property, checked);
//						refreshList();
					}
				});
//			ImageView icon = (ImageView)view.findViewById(R.id.option_icon);
//			icon.setImageResource(iconId);
//			view.setClickable(true);
//			view.setFocusable(true);
			return view;
		}
	}

	static public void saveColor( Properties mProperties, boolean night )
	{
		if ( night ) {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_NIGHT, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR_NIGHT, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR, 0x000000));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR_NIGHT, mProperties.getColor(ReaderView.PROP_FONT_COLOR, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR_NIGHT, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR, 0xFFFFFF));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_NIGHT, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, -1));
		} else {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_DAY, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR_DAY, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR_DAY, mProperties.getColor(ReaderView.PROP_FONT_COLOR, 0x000000));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR_DAY, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR, 0x000000));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_DAY, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, -1));
		}
	}
	static public void restoreColor( Properties mProperties,  boolean night )
	{
		if ( night ) {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_NIGHT, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR_NIGHT, 0x000000));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR, mProperties.getColor(ReaderView.PROP_FONT_COLOR_NIGHT, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR_NIGHT, 0xFFFFFF));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_NIGHT, 70));
		} else {
			mProperties.setProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE, mProperties.getProperty(ReaderView.PROP_PAGE_BACKGROUND_IMAGE_DAY, ""(NONE)""));
			mProperties.setColor(ReaderView.PROP_BACKGROUND_COLOR, mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR_DAY, 0xFFFFFF));
			mProperties.setColor(ReaderView.PROP_FONT_COLOR, mProperties.getColor(ReaderView.PROP_FONT_COLOR_DAY, 0x000000));
			mProperties.setColor(ReaderView.PROP_STATUS_FONT_COLOR, mProperties.getColor(ReaderView.PROP_STATUS_FONT_COLOR_DAY, 0x000000));
			mProperties.setInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT, mProperties.getInt(ReaderView.PROP_APP_SCREEN_BACKLIGHT_DAY, 80));
		}
	}

	static public void toggleDayNightMode( Properties mProperties ) {
		boolean oldMode = mProperties.getBool(ReaderView.PROP_NIGHT_MODE, false);
		saveColor(mProperties, oldMode);
		boolean newMode = !oldMode;
		restoreColor(mProperties, newMode);
		mProperties.setBool(ReaderView.PROP_NIGHT_MODE, newMode);
	}

	class NightModeOption extends BoolOption {
		public NightModeOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		public void onSelect() { 
			toggleDayNightMode(mProperties);
			refreshList();
		}
	}
	
	class ActionOption extends ListOption {
		public ActionOption( OptionOwner owner, String label, String property, boolean isTap, boolean allowRepeat ) {
			super(owner, label, property);
			ReaderAction[] actions = ReaderAction.AVAILABLE_ACTIONS;
			for ( ReaderAction a : actions )
				if ( !isTap || a.mayAssignOnTap() )
					add(a.id, getString(a.nameId));
			if ( allowRepeat )
				add(ReaderAction.REPEAT.id, getString(ReaderAction.REPEAT.nameId));
			if ( mProperties.getProperty(property)==null )
				mProperties.setProperty(property, ReaderAction.NONE.id);
		}
	}

	class KeyMapOption extends ListOption {
		public KeyMapOption( OptionOwner owner, String label ) {
			super(owner, label, ReaderView.PROP_APP_KEY_ACTIONS_PRESS);
		}
		private void addKey( OptionsListView list, int keyCode, String keyName ) {
			final String propName = ReaderAction.getKeyProp(keyCode, ReaderAction.NORMAL);
			final String longPropName = ReaderAction.getKeyProp(keyCode, ReaderAction.LONG);
			final String dblPropName = ReaderAction.getKeyProp(keyCode, ReaderAction.DOUBLE);
			list.add(new ActionOption(mOwner, keyName, propName, false, false));
			list.add(new ActionOption(mOwner, keyName + "" "" + getContext().getString(R.string.options_app_key_long_press), longPropName, false, true));
			list.add(new ActionOption(mOwner, keyName + "" "" + getContext().getString(R.string.options_app_key_double_press), dblPropName, false, false));
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, R.string.dlg_button_ok, 0, false);
			OptionsListView listView = new OptionsListView(getContext());
			addKey(listView, KeyEvent.KEYCODE_DPAD_LEFT, ""Left"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_RIGHT, ""Right"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_UP, ""Up"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_DOWN, ""Down"");
			addKey(listView, KeyEvent.KEYCODE_DPAD_CENTER, ""Center"");
			addKey(listView, KeyEvent.KEYCODE_BACK, ""Back"");
			addKey(listView, KeyEvent.KEYCODE_MENU, ""Menu"");
			addKey(listView, KeyEvent.KEYCODE_SEARCH, ""Search"");
			addKey(listView, KeyEvent.KEYCODE_VOLUME_UP, ""Volume Up"");
			addKey(listView, KeyEvent.KEYCODE_VOLUME_DOWN, ""Volume Down"");
			addKey(listView, KeyEvent.KEYCODE_CAMERA, ""Camera"");
			dlg.setTitle(label);
			dlg.setView(listView);
			dlg.show();
		}

		public String getValueLabel() { return "">""; }
	}
	
	class StatusBarOption extends ListOption {
		public StatusBarOption( OptionOwner owner, String label ) {
			super(owner, label, ReaderView.PROP_SHOW_TITLE);
		}
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, R.string.dlg_button_ok, 0, false);
			OptionsListView listView = new OptionsListView(getContext());
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar), ReaderView.PROP_STATUS_LINE).setInverse().setDefaultValue(""0""));
			listView.add(new ListOption(mOwner, getString(R.string.options_page_titlebar_font_face), ReaderView.PROP_STATUS_FONT_FACE).add(mFontFaces).setDefaultValue(mFontFaces[0]).setIconId(R.drawable.cr3_option_font_face));
			listView.add(new ListOption(mOwner, getString(R.string.options_page_titlebar_font_size), ReaderView.PROP_STATUS_FONT_SIZE).add(mStatusFontSizes).setDefaultValue(""18"").setIconId(R.drawable.cr3_option_font_size));
			listView.add(new ColorOption(mOwner, getString(R.string.options_page_titlebar_font_color), ReaderView.PROP_STATUS_FONT_COLOR, 0x000000));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_title), ReaderView.PROP_SHOW_TITLE).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_page_number), ReaderView.PROP_SHOW_PAGE_NUMBER).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_page_count), ReaderView.PROP_SHOW_PAGE_COUNT).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_percent), ReaderView.PROP_SHOW_POS_PERCENT).setDefaultValue(""0""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_chapter_marks), ReaderView.PROP_STATUS_CHAPTER_MARKS).setDefaultValue(""1""));
			listView.add(new BoolOption(mOwner, getString(R.string.options_page_show_titlebar_battery_percent), ReaderView.PROP_SHOW_BATTERY_PERCENT).setDefaultValue(""1""));
			dlg.setTitle(label);
			dlg.setView(listView);
			dlg.show();
		}

		public String getValueLabel() { return "">""; }
	}
	
	class TapZoneOption extends OptionBase {
		public TapZoneOption( OptionOwner owner, String label, String property ) {
			super( owner, label, property);
		}
		View grid;
		private void initTapZone( View view, final int tapZoneId )
		{
			if ( view==null )
				return;
			final TextView text = (TextView)view.findViewById(R.id.tap_zone_action_text_short);
			final TextView longtext = (TextView)view.findViewById(R.id.tap_zone_action_text_long);
			final String propName = property + ""."" + tapZoneId;
			final String longPropName = property + "".long."" + tapZoneId;
			ReaderAction action = ReaderAction.findById( mProperties.getProperty(propName) );
			ReaderAction longAction = ReaderAction.findById( mProperties.getProperty(longPropName) );
			text.setText(getString(action.nameId));
			longtext.setText(getString(longAction.nameId));
			view.setLongClickable(true);
			view.setOnClickListener(new View.OnClickListener () {
				@Override
				public void onClick(View v) {
					// TODO: i18n
					ActionOption option = new ActionOption(mOwner, getString(R.string.options_app_tap_action_short), propName, true, false);
					option.setOnChangeHandler(new Runnable() {
						public void run() {
							ReaderAction action = ReaderAction.findById( mProperties.getProperty(propName) );
							text.setText(getString(action.nameId));
						}
					});
					option.onSelect();
				}
			});
			view.setOnLongClickListener(new View.OnLongClickListener () {
				@Override
				public boolean onLongClick(View v) {
					// TODO: i18n
					ActionOption option = new ActionOption(mOwner, getString(R.string.options_app_tap_action_long), longPropName, true, true);
					option.setOnChangeHandler(new Runnable() {
						public void run() {
							ReaderAction longAction = ReaderAction.findById( mProperties.getProperty(longPropName) );
							longtext.setText(getString(longAction.nameId));
						}
					});
					option.onSelect();
					return true;
				}
			});
		}

		public String getValueLabel() { return "">""; }
		public void onSelect() {
			BaseDialog dlg = new BaseDialog(mActivity, R.string.dlg_button_ok, 0, false);
			grid = (View)mInflater.inflate(R.layout.options_tap_zone_grid, null);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell1), 1);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell2), 2);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell3), 3);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell4), 4);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell5), 5);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell6), 6);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell7), 7);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell8), 8);
			initTapZone(grid.findViewById(R.id.tap_zone_grid_cell9), 9);
			dlg.setTitle(label);
			dlg.setView(grid);
			dlg.show();
		}
	}
	
	public static class Pair {
		public String value;
		public String label;
		public Pair(String value, String label) {
			this.value = value;
			this.label = label;
		}
	}

	public static class ListOption extends OptionBase {
		private ArrayList<Pair> list = new ArrayList<Pair>();
		public ListOption( OptionOwner owner, String label, String property ) {
			super(owner, label, property);
		}
		public void add(String value, String label) {
			list.add( new Pair(value, label) );
		}
		public ListOption add(String[]values) {
			for ( String item : values ) {
				add(item, item);
			}
			return this;
		}
		public ListOption add(int[]values) {
			for ( int item : values ) {
				String s = String.valueOf(item); 
				add(s, s);
			}
			return this;
		}
		public ListOption add(int[]values, int[]labelIDs) {
			for ( int i=0; i<values.length; i++ ) {
				String value = String.valueOf(values[i]); 
				String label = mActivity.getString(labelIDs[i]); 
				add(value, label);
			}
			return this;
		}
		public ListOption add(String[]values, int[]labelIDs) {
			for ( int i=0; i<values.length; i++ ) {
				String value = values[i]; 
				String label = mActivity.getString(labelIDs[i]); 
				add(value, label);
			}
			return this;
		}
		public ListOption add(int[]values, String[]labels) {
			for ( int i=0; i<values.length; i++ ) {
				String value = String.valueOf(values[i]); 
				String label = labels[i]; 
				add(value, label);
			}
			return this;
		}
		public ListOption addPercents(int[]values) {
			for ( int item : values ) {
				String s = String.valueOf(item); 
				add(s, s + ""%"");
			}
			return this;
		}
		public String findValueLabel( String value ) {
			for ( Pair pair : list ) {
				if ( value!=null && pair.value.equals(value) )
					return pair.label;
			}
			return null;
		}
		public int findValue( String value ) {
			if ( value==null )
				return -1;
			for ( int i=0; i<list.size(); i++ ) {
				if ( value.equals(list.get(i).value) )
					return i;
			}
			return -1;
		}
		
		public int getSelectedItemIndex() {
			return findValue(mProperties.getProperty(property));
		}

		protected void closed() {
			
		}
		
		protected int getItemLayoutId() {
			return R.layout.option_value; 
		}
		
		protected void updateItemContents( final View layout, final Pair item, final ListView listView, final int position ) {
			TextView view;
			RadioButton cb;
			view = (TextView)layout.findViewById(R.id.option_value_text);
			cb = (RadioButton)layout.findViewById(R.id.option_value_check);
			view.setText(item.label);
			String currValue = mProperties.getProperty(property);
			boolean isSelected = item.value!=null && currValue!=null && item.value.equals(currValue) ;//getSelectedItemIndex()==position;
			cb.setChecked(isSelected);
			cb.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					listView.getOnItemClickListener().onItemClick(listView, listView, position, 0);
//					mProperties.setProperty(property, item.value);
//					dismiss();
//					optionsListView.refresh();
				}
			});
		}
		
		public String getValueLabel() { return findValueLabel(mProperties.getProperty(property)); }
		
		public void onSelect() {
			final BaseDialog dlg = new BaseDialog(mActivity, 0, 0, false);
			//AlertDialog.Builder dlg = new AlertDialog.Builder(getContext());
			dlg.setTitle(label);

			final ListView listView = new ListView(mActivity);
			
			
			ListAdapter listAdapter = new ListAdapter() {

				public boolean areAllItemsEnabled() {
					return true;
				}

				public boolean isEnabled(int position) {
					return true;
				}

				public int getCount() {
					return list.size();
				}

				public Object getItem(int position) {
					return list.get(position);
				}

				public long getItemId(int position) {
					return position;
				}

				public int getItemViewType(int position) {
					return 0;
				}

				public View getView(final int position, View convertView,
						ViewGroup parent) {
					ViewGroup layout;
					if ( convertView==null ) {
						layout = (ViewGroup)mInflater.inflate(getItemLayoutId(), null);
						//view = new TextView(getContext());
					} else {
						layout = (ViewGroup)convertView;
					}
					final Pair item = list.get(position);
					updateItemContents( layout, item, listView, position );
					//cb.setClickable(false);
//					cb.setOnClickListener(new View.OnClickListener() {
//						@Override
//						public void onClick(View v) {
//							
//						}
//					});
					return layout;
				}

				public int getViewTypeCount() {
					return 1;
				}

				public boolean hasStableIds() {
					return true;
				}

				public boolean isEmpty() {
					return list.size()==0;
				}

				private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
				
				public void registerDataSetObserver(DataSetObserver observer) {
					observers.add(observer);
				}

				public void unregisterDataSetObserver(DataSetObserver observer) {
					observers.remove(observer);
				}
				
			};
			int selItem = getSelectedItemIndex();
			if ( selItem<0 )
				selItem = 0;
			listView.setAdapter(listAdapter);
			listView.setSelection(selItem);
			dlg.setView(listView);
			//final AlertDialog d = dlg.create();
			listView.setOnItemClickListener(new OnItemClickListener() {

				public void onItemClick(AdapterView<?> adapter, View listview,
						int position, long id) {
					Pair item = list.get(position);
					onClick(item);
					dlg.dismiss();
					closed();
				}
			});
			dlg.show();
		}
		
		public void onClick( Pair item ) {
			mProperties.setProperty(property, item.value);
			refreshList();
			if ( onChangeHandler!=null )
				onChangeHandler.run();
			if ( optionsListView!=null )
				optionsListView.refresh();
		}
	}
	
	class DictOptions extends ListOption
	{
		public DictOptions( OptionOwner owner, String label )
		{
			super( owner, label, ReaderView.PROP_APP_DICTIONARY );
			CoolReader.DictInfo[] dicts = mActivity.getDictList();
			setDefaultValue(dicts[0].id);
			for ( CoolReader.DictInfo dict : dicts )
				add( dict.id, dict.name );
		}
	} 
	
	class HyphenationOptions extends ListOption
	{
		public HyphenationOptions( OptionOwner owner, String label )
		{
			super( owner, label, ReaderView.PROP_HYPHENATION_DICT );
			setDefaultValue(""RUSSIAN"");
			Engine.HyphDict[] dicts = Engine.HyphDict.values();
			for ( Engine.HyphDict dict : dicts )
				add( dict.toString(), dict.name );
		}
	}
	
	class ThumbnailCache {
		final int maxcount;
		final int dx;
		final int dy;
		class Item {
			Drawable drawable;
			Bitmap bmp;
			String path;
			int id;
			public void clear() {
				if ( bmp!=null ) {
					//bmp.recycle();
					bmp = null;
				}
				if ( drawable!=null )
					drawable = null;
			}
		}
		ArrayList<Item> list = new ArrayList<Item>(); 
		public ThumbnailCache( int dx, int dy, int maxcount ) {
			this.dx = dx;
			this.dy = dy;
			this.maxcount = maxcount;
		}
		private void remove( int maxsize ) {
			while ( list.size()>maxsize ) {
				Item item = list.remove(0);
				item.clear();
			}
		}
		private Drawable createDrawable( String path ) {
			File f = new File(path);
			if ( !f.isFile() || !f.exists() )
				return null;
			try { 
				BitmapDrawable drawable = (BitmapDrawable)BitmapDrawable.createFromPath(path);
				if ( drawable==null )
					return null;
				Bitmap src = drawable.getBitmap();
				Bitmap bmp = Bitmap.createScaledBitmap(src, dx, dy, true);
				//Canvas canvas = new Canvas(bmp);
				BitmapDrawable res = new BitmapDrawable(bmp);
				//src.recycle();
				Item item = new Item();
				item.path = path;
				item.drawable = res; //drawable;
				item.bmp = bmp;
				list.add(item);
				remove(maxcount);
				return drawable;
			} catch ( Exception e ) {
				return null;
			}
		}
		private Drawable createDrawable( int resourceId ) {
			try { 
				//Drawable drawable = mReaderView.getActivity().getResources().getDrawable(resourceId);
				InputStream is = getContext().getResources().openRawResource(resourceId);
				if ( is==null )
					return null;
				BitmapDrawable src = new BitmapDrawable(is);
				if ( src==null )
					return null;
				Item item = new Item();
				item.id = resourceId;
				Bitmap bmp = Bitmap.createScaledBitmap(src.getBitmap(), dx, dy, true);
				BitmapDrawable res = new BitmapDrawable(bmp);
				item.drawable = res;
				item.bmp = bmp;
				list.add(item);
				remove(maxcount);
				return res;
			} catch ( Exception e ) {
				return null;
			}
		}
		public Drawable getImage( String path ) {
			if ( path==null || !path.startsWith(""/""))
				return null;
			// find existing
			for ( int i=0; i<list.size(); i++ ) {
				if ( list.get(i).path!=null && path.equals(list.get(i).path) ) {
					Item item = list.remove(i);
					list.add(item);
					return item.drawable;
				}
			}
			return createDrawable( path ); 
		}
		public Drawable getImage( int resourceId ) {
			if ( resourceId==0 )
				return null;
			// find existing
			for ( int i=0; i<list.size(); i++ ) {
				if ( list.get(i).id == resourceId ) {
					Item item = list.remove(i);
					list.add(item);
					return item.drawable;
				}
			}
			return createDrawable( resourceId ); 
		}
		public void clear() {
			remove(0);
		}
	}
	
	ThumbnailCache textureSampleCache = new ThumbnailCache(64, 64, 100);
	
	class TextureOptions extends ListOption
	{
		public TextureOptions( OptionOwner owner, String label )
		{
			super( owner, label, ReaderView.PROP_PAGE_BACKGROUND_IMAGE );
			setDefaultValue(""(NONE)"");
			BackgroundTextureInfo[] textures = mReaderView.getEngine().getAvailableTextures();
			for ( BackgroundTextureInfo item : textures )
				add( item.id, item.name );
		}

		protected void closed() {
			textureSampleCache.clear();
		}

		protected int getItemLayoutId() {
			return R.layout.option_value_image; 
		}
		
		protected void updateItemContents( final View layout, final Pair item, final ListView listView, final int position ) {
			super.updateItemContents(layout, item, listView, position);
			ImageView img = (ImageView)layout.findViewById(R.id.option_value_image);
			int cl = mProperties.getColor(ReaderView.PROP_BACKGROUND_COLOR, Color.WHITE);
			BackgroundTextureInfo texture = mReaderView.getEngine().getTextureInfoById(item.value);
			img.setBackgroundColor(cl);
			if ( texture.resourceId!=0 ) {
//				img.setImageDrawable(null);
//				img.setImageResource(texture.resourceId);
//				img.setBackgroundColor(Color.TRANSPARENT);
				Drawable drawable = textureSampleCache.getImage(texture.resourceId);
				if ( drawable!=null ) {
					img.setImageResource(0);
					img.setImageDrawable(drawable);
					img.setBackgroundColor(Color.TRANSPARENT);
				} else {
					img.setBackgroundColor(cl);
					img.setImageResource(0);
					img.setImageDrawable(null);
				}
			} else {
				// load image from file
				Drawable drawable = textureSampleCache.getImage(texture.id);
				if ( drawable!=null ) {
					img.setImageResource(0);
					img.setImageDrawable(drawable);
					img.setBackgroundColor(Color.TRANSPARENT);
				} else {
					img.setBackgroundColor(cl);
					img.setImageResource(0);
					img.setImageDrawable(null);
				}
			}
		}
	}
	
	//byte[] fakeLongArrayForDebug;
	
	public OptionsDialog( CoolReader activity, ReaderView readerView, String[] fontFaces )
	{
		super(activity, R.string.dlg_button_ok, R.string.dlg_button_cancel, false);
		
		mActivity = activity;
		mReaderView = readerView;
		mFontFaces = fontFaces;
		mProperties = readerView.getSettings();

		//fakeLongArrayForDebug = new byte[2000000]; // 2M
		//CoolReader.dumpHeapAllocation();
	}
	
	class OptionsListView extends ListView {
		private ArrayList<OptionBase> mOptions = new ArrayList<OptionBase>();
		private ListAdapter mAdapter;
		public void refresh()
		{
			//setAdapter(mAdapter);
			for ( OptionBase item : mOptions ) {
				item.refreshItem();
			}
			invalidate();
		}
		public OptionsListView add( OptionBase option ) {
			mOptions.add(option);
			option.optionsListView = this;
			return this;
		}
		public OptionsListView( Context context )
		{
			super(context);
			setFocusable(true);
			setFocusableInTouchMode(true);
			mAdapter = new ListAdapter() {
				public boolean areAllItemsEnabled() {
					return false;
				}

				public boolean isEnabled(int position) {
					boolean isPageMode = mProperties.getBool(ReaderView.PROP_PAGE_VIEW_MODE, true);
					OptionBase option = mOptions.get(position);
					String prop = option.property;
					if ( prop.equals(ReaderView.PROP_STATUS_LINE) || prop.equals(ReaderView.PROP_FOOTNOTES) )
						return isPageMode;
					return true;
				}

				public int getCount() {
					return mOptions.size();
				}

				public Object getItem(int position) {
					return mOptions.get(position);
				}

				public long getItemId(int position) {
					return position;
				}

				public int getItemViewType(int position) {
//					OptionBase item = mOptions.get(position);
//					return item.getItemViewType();
					return position;
				}

				
				public View getView(int position, View convertView, ViewGroup parent) {
					OptionBase item = mOptions.get(position);
					return item.getView(convertView, parent);
				}

				public int getViewTypeCount() {
					//return OPTION_VIEW_TYPE_COUNT;
					return mOptions.size() > 0 ? mOptions.size() : 1;
				}

				public boolean hasStableIds() {
					return true;
				}

				public boolean isEmpty() {
					return mOptions.size()==0;
				}

				private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
				
				public void registerDataSetObserver(DataSetObserver observer) {
					observers.add(observer);
				}

				public void unregisterDataSetObserver(DataSetObserver observer) {
					observers.remove(observer);
				}
			};
			setAdapter(mAdapter);
		}
		@Override
		public boolean performItemClick(View view, int position, long id) {
			mOptions.get(position).onSelect();
			return true;
		}
		
	}
	
	public View createTabContent(String tag) {
		if ( ""App"".equals(tag) )
			return mOptionsApplication;
		else if ( ""Styles"".equals(tag) )
			return mOptionsStyles;
		else if ( ""Controls"".equals(tag) )
			return mOptionsControls;
		else if ( ""Page"".equals(tag))
			return mOptionsPage;
		return null;
	}

	private String getString( int resourceId )
	{
		return getContext().getResources().getString(resourceId); 
	}
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		L.v(""creating OptionsDialog"");
		CoolReader.dumpHeapAllocation();
		L.v(""calling gc"");
		System.gc();
		CoolReader.dumpHeapAllocation();
		L.v(""creating options dialog"");
		setTitle(null);
        setCancelable(true);
        setCanceledOnTouchOutside(true);
        mInflater = LayoutInflater.from(getContext());
        mTabs = (TabHost)mInflater.inflate(R.layout.options, null);
		// setup tabs
		//setView(R.layout.options);
		//setContentView(R.layout.options);
		//mTabs = (TabHost)findViewById(android.R.id.tabhost); 
		mTabs.setup();
		//new TabHost(getContext());
		mOptionsStyles = new OptionsListView(getContext());
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_font_face), ReaderView.PROP_FONT_FACE).add(mFontFaces).setDefaultValue(mFontFaces[0]).setIconId(R.drawable.cr3_option_font_face));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_font_size), ReaderView.PROP_FONT_SIZE).add(mFontSizes).setDefaultValue(""24"").setIconId(R.drawable.cr3_option_font_size));
		mOptionsStyles.add(new BoolOption(this, getString(R.string.options_font_embolden), ReaderView.PROP_FONT_WEIGHT_EMBOLDEN).setDefaultValue(""0"").setIconId(R.drawable.cr3_option_text_bold));
		//mOptionsStyles.add(new BoolOption(getString(R.string.options_font_antialias), ReaderView.PROP_FONT_ANTIALIASING).setInverse().setDefaultValue(""0""));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_font_antialias), ReaderView.PROP_FONT_ANTIALIASING).add(mAntialias, mAntialiasTitles).setDefaultValue(""2""));
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_interline_space), ReaderView.PROP_INTERLINE_SPACE).addPercents(mInterlineSpaces).setDefaultValue(""100""));
		mOptionsStyles.add(new NightModeOption(this, getString(R.string.options_inverse_view), ReaderView.PROP_NIGHT_MODE));
		mOptionsStyles.add(new ColorOption(this, getString(R.string.options_color_text), ReaderView.PROP_FONT_COLOR, 0x000000));
		mOptionsStyles.add(new ColorOption(this, getString(R.string.options_color_background), ReaderView.PROP_BACKGROUND_COLOR, 0xFFFFFF));
		mOptionsStyles.add(new TextureOptions(this, getString(R.string.options_background_texture)));

		mBacklightLevelsTitles[0] = getString(R.string.options_app_backlight_screen_default);
		mOptionsStyles.add(new ListOption(this, getString(R.string.options_app_backlight_screen), ReaderView.PROP_APP_SCREEN_BACKLIGHT).add(mBacklightLevels, mBacklightLevelsTitles).setDefaultValue(""-1""));
		//
		mOptionsStyles.add(new HyphenationOptions(this, getString(R.string.options_hyphenation_dictionary)));
		mOptionsStyles.add(new BoolOption(this, getString(R.string.options_style_floating_punctuation), ReaderView.PROP_FLOATING_PUNCTUATION).setDefaultValue(""1""));
		mOptionsStyles.add(new BoolOption(this, getString(R.string.options_font_kerning), ReaderView.PROP_FONT_KERNING_ENABLED).setDefaultValue(""0""));
		
		//
		mOptionsPage = new OptionsListView(getContext());
		mOptionsPage.add(new ListOption(this, getString(R.string.options_view_mode), ReaderView.PROP_PAGE_VIEW_MODE).add(mViewModes, mViewModeTitles).setDefaultValue(""1""));
		mOptionsPage.add( new StatusBarOption(this, getString(R.string.options_page_titlebar)));
		mOptionsPage.add(new BoolOption(this, getString(R.string.options_page_footnotes), ReaderView.PROP_FOOTNOTES).setDefaultValue(""1""));
		//mOptionsPage.add(new ListOption(getString(R.string.options_page_orientation), ReaderView.PROP_ROTATE_ANGLE).add(mOrientations, mOrientationsTitles).setDefaultValue(""0""));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_orientation), ReaderView.PROP_APP_SCREEN_ORIENTATION).add(mOrientations, mOrientationsTitles).setDefaultValue(""0"").setIconId(android.R.drawable.ic_menu_always_landscape_portrait));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_landscape_pages), ReaderView.PROP_LANDSCAPE_PAGES).add(mLandscapePages, mLandscapePagesTitles).setDefaultValue(""1""));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_animation), ReaderView.PROP_PAGE_ANIMATION).add(mAnimation, mAnimationTitles).setDefaultValue(""1""));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_selection_action), ReaderView.PROP_APP_SELECTION_ACTION).add(mSelectionAction, mSelectionActionTitles).setDefaultValue(""0""));
		
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_left), ReaderView.PROP_PAGE_MARGIN_LEFT).add(mMargins).setDefaultValue(""5""));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_right), ReaderView.PROP_PAGE_MARGIN_RIGHT).add(mMargins).setDefaultValue(""5""));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_top), ReaderView.PROP_PAGE_MARGIN_TOP).add(mMargins).setDefaultValue(""5""));
		mOptionsPage.add(new ListOption(this, getString(R.string.options_page_margin_bottom), ReaderView.PROP_PAGE_MARGIN_BOTTOM).add(mMargins).setDefaultValue(""5""));
		mOptionsApplication = new OptionsListView(getContext());
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_fullscreen), ReaderView.PROP_APP_FULLSCREEN));
		mOptionsApplication.add(new DictOptions(this, getString(R.string.options_app_dictionary)));
		mOptionsApplication.add(new TapZoneOption(this, getString(R.string.options_app_tapzones_normal), ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP));
		mOptionsApplication.add(new KeyMapOption(this, getString(R.string.options_app_key_actions)));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_show_cover_pages), ReaderView.PROP_APP_SHOW_COVERPAGES));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_controls_enable_volume_keys), ReaderView.PROP_CONTROLS_ENABLE_VOLUME_KEYS).setDefaultValue(""1""));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_double_tap_selection), ReaderView.PROP_APP_DOUBLE_TAP_SELECTION).setDefaultValue(""0""));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_tapzone_hilite), ReaderView.PROP_APP_TAP_ZONE_HILIGHT).setDefaultValue(""0""));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_trackball_disable), ReaderView.PROP_APP_TRACKBALL_DISABLED).setDefaultValue(""0""));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_scan_book_props), ReaderView.PROP_APP_BOOK_PROPERTY_SCAN_ENABLED).setDefaultValue(""1""));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_backlight_lock_enabled), ReaderView.PROP_APP_SCREEN_BACKLIGHT_LOCK).setDefaultValue(""0""));
		mOptionsApplication.add(new ListOption(this, getString(R.string.options_controls_flick_brightness), ReaderView.PROP_APP_FLICK_BACKLIGHT_CONTROL).add(mFlickBrightness, mFlickBrightnessTitles).setDefaultValue(""1""));
		mOptionsApplication.add(new BoolOption(this, getString(R.string.options_app_browser_hide_empty_dirs), ReaderView.PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS).setDefaultValue(""0""));
		
		mOptionsStyles.refresh();
		mOptionsPage.refresh();
		mOptionsApplication.refresh();
		
//		mOptionsControls = new OptionsListView(getContext());
//		mOptionsControls.add(new BoolOption(mProperties, ""Sample option"", ""controls.sample""));
		TabHost.TabSpec tsStyles = mTabs.newTabSpec(""Styles"");
		tsStyles.setIndicator("""", //getContext().getResources().getString(R.string.tab_options_styles) 
				getContext().getResources().getDrawable(android.R.drawable.ic_menu_view)); //R.drawable.cr3_option_style
		tsStyles.setContent(this);
		mTabs.addTab(tsStyles);
		TabHost.TabSpec tsPage = mTabs.newTabSpec(""Page"");
		//getContext().getResources().getString(R.string.tab_options_page)
		tsPage.setIndicator("""", getContext().getResources().getDrawable(android.R.drawable.ic_menu_crop)); //R.drawable.cr3_option_page
		tsPage.setContent(this);
		mTabs.addTab(tsPage);
		TabHost.TabSpec tsApp = mTabs.newTabSpec(""App"");
		//tsApp.setIndicator(null, getContext().getResources().getDrawable(R.drawable.cr3_option_));
		tsApp.setIndicator("""", //getContext().getResources().getString(R.string.tab_options_app), 
				getContext().getResources().getDrawable(android.R.drawable.ic_menu_manage));
		tsApp.setContent(this);
		mTabs.addTab(tsApp);
		
		TabHost.TabSpec tsControls = mTabs.newTabSpec(""Controls"");
		tsControls.setIndicator(getContext().getResources().getString(R.string.tab_options_controls), getContext().getResources().getDrawable(android.R.drawable.ic_menu_manage));
		tsControls.setContent(this);
		//mTabs.addTab(tsControls);

		setView(mTabs);
		
		mOldProperties = new Properties(mProperties);
		
		setOnCancelListener(new OnCancelListener() {

			public void onCancel(DialogInterface dialog) {
				askApply();
			}
		});
		
		super.onCreate(savedInstanceState);
		L.v(""OptionsDialog is created"");
	}

	private void askApply()
	{
		Properties diff = mProperties.diff(mOldProperties);
		if ( diff.size()>0 ) {
			L.d(""Some properties were changed, ask user whether to apply"");
			AlertDialog.Builder dlg = new AlertDialog.Builder(getContext());
			dlg.setTitle(R.string.win_title_options_apply);
			dlg.setPositiveButton(R.string.dlg_button_ok, new OnClickListener() {
				public void onClick(DialogInterface arg0, int arg1) {
					onPositiveButtonClick();
				}
			});
			dlg.setNegativeButton(R.string.dlg_button_cancel, new OnClickListener() {
				public void onClick(DialogInterface arg0, int arg1) {
					onNegativeButtonClick();
				}
			});
			dlg.show();
		}
	}
	
	@Override
	protected void onPositiveButtonClick() {
        mReaderView.setSettings(mProperties, mOldProperties);
        dismiss();
        //super.onPositiveButtonClick();
	}
	@Override
	protected void onStop() {
		L.d(""OptionsDialog.onStop() : calling gc()"");
		System.gc();
		super.onStop();
	}

	
}
",True,32,38,0,0,3,25,3,10,L1
8,org.coolreader.crengine.TOCDlg.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.database.DataSetObserver;
import android.os.Bundle;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

public class TOCDlg extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	TOCItem mTOC;
	ListView mListView;
	int mCurrentPage;
	TOCItem mCurrentPageItem;
	ArrayList<TOCItem> mItems = new ArrayList<TOCItem>(); 
	private LayoutInflater mInflater;
	
	private void initItems( TOCItem toc, boolean expanded )
	{
		for ( int i=0; i<toc.getChildCount(); i++ ) {
			TOCItem child = toc.getChild(i);
			if ( child.getPage()<=mCurrentPage )
				mCurrentPageItem = child;
			if ( expanded ) {
				child.setGlobalIndex(mItems.size());
				mItems.add(child);
			} else {
				child.setGlobalIndex(-1); // invisible
			}
			initItems(child, expanded && child.getExpanded());
		}
	}
	private void initItems()
	{
		mCurrentPageItem = null;
		mItems.clear();
		initItems(mTOC, true);
	}
	
	private void expand( TOCItem item )
	{
		if ( item==null )
			return;
		item.setExpanded(true);
		// expand all parents
		for ( TOCItem p = item.getParent(); p!=null; p = p.getParent() )
			p.setExpanded(true);
		initItems();
		refreshList();
		if ( mItems.size()>0 ) {
			if ( item.getGlobalIndex()>=0 ) {
				mListView.setSelection(item.getGlobalIndex());
				mListView.setSelectionFromTop(item.getGlobalIndex(), mListView.getHeight()/2);
			} else
				mListView.setSelection(0);
		}
	}
	
	private void collapse( TOCItem item )
	{
		item.setExpanded(false);
		initItems();
		refreshList();
	}
	
	private void refreshList()
	{
		mListView.setAdapter(new ListAdapter() {
			public boolean areAllItemsEnabled() {
				return true;
			}

			public boolean isEnabled(int arg0) {
				return true;
			}

			public int getCount() {
				return mItems.size();
			}

			public Object getItem(int position) {
				return mItems.get(position);
			}

			public long getItemId(int position) {
				return position;
			}

			public int getItemViewType(int position) {
				return 0;
			}

			
			public View getView(int position, View convertView, ViewGroup parent) {
				View view;
				if ( convertView==null ) {
					//view = new TextView(getContext());
					view = mInflater.inflate(R.layout.toc_item, null);
				} else {
					view = (View)convertView;
				}
				TextView pageTextView = (TextView)view.findViewById(R.id.toc_page);
				TextView titleTextView = (TextView)view.findViewById(R.id.toc_title);
				TextView marginTextView = (TextView)view.findViewById(R.id.toc_level_margin);
				ImageView expandImageView = (ImageView)view.findViewById(R.id.toc_expand_icon);
				TOCItem item = mItems.get(position);
				StringBuilder buf = new StringBuilder(item.getLevel()*2);
				for ( int i=1; i<item.getLevel(); i++ )
					buf.append(""  "");
				if ( item.getChildCount()>0 ) {
					if ( item.getExpanded() ) {
						expandImageView.setImageResource(R.drawable.cr3_toc_item_expanded);
					} else {
						expandImageView.setImageResource(R.drawable.cr3_toc_item_collapsed);
					}
				} else {
					expandImageView.setImageResource(R.drawable.cr3_toc_item_normal);
				}
				marginTextView.setText(buf.toString());
				titleTextView.setText(item.getName());
				pageTextView.setText(String.valueOf(item.getPage()+1));
				return view;
			}

			public int getViewTypeCount() {
				return 1;
			}

			public boolean hasStableIds() {
				return true;
			}

			public boolean isEmpty() {
				return false;
			}

			private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
			
			public void registerDataSetObserver(DataSetObserver observer) {
				observers.add(observer);
			}

			public void unregisterDataSetObserver(DataSetObserver observer) {
				observers.remove(observer);
			}
		});
	}

	public TOCDlg( CoolReader coolReader, ReaderView readerView, TOCItem toc, int currentPage )
	{
		super(coolReader, 0, 0, false);
        setCancelable(true);
		this.mCoolReader = coolReader;
		this.mReaderView = readerView;
		this.mTOC = toc;
		this.mCurrentPage = currentPage;
		this.mListView = new ListView(getContext());
		mListView.setOnItemClickListener(new OnItemClickListener() {

			@Override
			public void onItemClick(AdapterView<?> listview, View view,
					int position, long id) {
				TOCItem item = mItems.get(position);
				if ( item.getChildCount()==0 || item.getExpanded() ) {
					mReaderView.goToPage(item.getPage()+1);
					dismiss();
				} else {
					expand(item);
				}
			}
		});
		mListView.setOnItemLongClickListener(new OnItemLongClickListener() {

			@Override
			public boolean onItemLongClick(AdapterView<?> listview, View view,
					int position, long id) {
				TOCItem item = mItems.get(position);
				if ( item.getChildCount()==0 ) {
					mReaderView.goToPage(item.getPage()+1);
					dismiss();
				} else {
					if ( item.getExpanded() )
						collapse(item);
					else
						expand(item);
				}
				return true;
			}
		});
		mListView.setLongClickable(true);
		mListView.setClickable(true);
		mListView.setFocusable(true);
		mListView.setFocusableInTouchMode(true);
		mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
		setTitle(mCoolReader.getResources().getString(R.string.win_title_toc));
		setView(mListView);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
        mInflater = LayoutInflater.from(getContext());
		super.onCreate(savedInstanceState);
		expand( mTOC );
		expand( mCurrentPageItem );
	}
	
	

}
",False,1,38,0,0,3,28,1,4,L2
9,org.coolreader.crengine.BookmarksDlg.java,"package org.coolreader.crengine;

import java.util.ArrayList;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.Context;
import android.database.DataSetObserver;
import android.graphics.Paint;
import android.os.Bundle;
import android.util.Log;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnMenuItemClickListener;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.ScrollView;
import android.widget.TextView;

public class BookmarksDlg  extends BaseDialog {
	CoolReader mCoolReader;
	ReaderView mReaderView;
	private LayoutInflater mInflater;
	BookInfo mBookInfo;
	BookmarkList mList;
	BookmarksDlg mThis;

	private final int ITEM_POSITION=0;
	private final int ITEM_COMMENT=1;
	private final int ITEM_CORRECTION=2;
	private final int ITEM_SHORTCUT=3;
	
	class BookmarkListAdapter implements ListAdapter {
		public boolean areAllItemsEnabled() {
			return true;
		}

		public boolean isEnabled(int arg0) {
			return true;
		}

		public int getCount() {
			return mBookInfo.getBookmarkCount();
		}

		public Object getItem(int position) {
			if ( position<0 || position>=mBookInfo.getBookmarkCount() )
				return null;
			return mBookInfo.getBookmark(position);
		}

		public long getItemId(int position) {
			return position;
		}

		
		
		public int getItemViewType(int position) {
			Bookmark bm = (Bookmark)getItem(position);
			if ( bm==null )
				return ITEM_POSITION;
			switch ( bm.getType() ) {
			case Bookmark.TYPE_COMMENT:
				return ITEM_COMMENT;
			case Bookmark.TYPE_CORRECTION:
				return ITEM_CORRECTION;
			default:
				if ( bm.getShortcut()>0 )
					return ITEM_SHORTCUT;
				return ITEM_POSITION;
			}
		}

		public int getViewTypeCount() {
			return 4;
		}

		
		public View getView(int position, View convertView, ViewGroup parent) {
			View view;
			int type = getItemViewType(position);
			if ( convertView==null ) {
				//view = new TextView(getContext());
				int res = R.layout.bookmark_position_item;
				switch ( type ) {
				case ITEM_COMMENT:
					res = R.layout.bookmark_comment_item;
					break;
				case ITEM_CORRECTION:
					res = R.layout.bookmark_correction_item;
					break;
				case ITEM_SHORTCUT:
					res = R.layout.bookmark_shortcut_item;
					break;
				}
				view = mInflater.inflate(res, null);
			} else {
				view = (View)convertView;
			}
			TextView labelView = (TextView)view.findViewById(R.id.bookmark_item_shortcut);
			TextView posTextView = (TextView)view.findViewById(R.id.bookmark_item_pos_text);
			TextView titleTextView = (TextView)view.findViewById(R.id.bookmark_item_title);
			TextView commentTextView = (TextView)view.findViewById(R.id.bookmark_item_comment_text);
			if ( type==ITEM_CORRECTION && posTextView!=null )
				posTextView.setPaintFlags(posTextView.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG );
				
			Bookmark b = (Bookmark)getItem(position);
			if ( labelView!=null ) {
				if ( b!=null && b.getShortcut()>0 )
					labelView.setText(String.valueOf(b.getShortcut()));
				else
					labelView.setText(String.valueOf(position+1));
			}
			if ( b!=null ) {
				String percentString = FileBrowser.formatPercent(b.getPercent());
				String s1 = b.getTitleText();
				String s2 = b.getPosText();
				String s3 = b.getCommentText();
				if ( s1!=null && s2!=null ) {
					s1 = percentString + ""   "" + s1;
				} else if ( s1!=null ) {
					s2 = s1;
					s1 = percentString;  
				} else if ( s2!=null ) {
					s1 = percentString;
				} else {
					s1 = s2 = """";
				}
				if ( titleTextView!=null )
					titleTextView.setText(s1);
				if ( posTextView!=null )
					posTextView.setText(s2);
				if ( commentTextView!=null )
					commentTextView.setText(s3);
			} else {
				if ( commentTextView!=null )
					commentTextView.setText("""");
				if ( titleTextView!=null )
					titleTextView.setText("""");
				if ( posTextView!=null )
					posTextView.setText("""");
			}
			return view;
		}

		public boolean hasStableIds() {
			return true;
		}

		public boolean isEmpty() {
			return mBookInfo.getBookmarkCount()==0;
		}

		private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
		
		public void registerDataSetObserver(DataSetObserver observer) {
			observers.add(observer);
		}

		public void unregisterDataSetObserver(DataSetObserver observer) {
			observers.remove(observer);
		}
	}
	
	class ShortcutBookmarkListAdapter extends BookmarkListAdapter {
		public int getCount() {
			return SHORTCUT_COUNT;
		}

		public Object getItem(int position) {
			return mBookInfo.findShortcutBookmark(position+1);
		}

		public int getItemViewType(int position) {
			return ITEM_SHORTCUT;
		}
	}
	
	class BookmarkList extends ListView {
		private ListAdapter mAdapter;
		private boolean mShortcutMode = false;
		
		public boolean isShortcutMode() {
			return mShortcutMode;
		}
		public void setShortcutMode( boolean shortcutMode ) {
			if ( !shortcutMode )
				mBookInfo.sortBookmarks();
			updateAdapter( shortcutMode ? new ShortcutBookmarkListAdapter() : new BookmarkListAdapter() );
		}
		public void updateAdapter( BookmarkListAdapter adapter ) {
			mAdapter = adapter;
			setAdapter(mAdapter);
		}
		public BookmarkList( Context context, boolean shortcutMode ) {
			super(context);
			setChoiceMode(ListView.CHOICE_MODE_SINGLE);
			setShortcutMode(shortcutMode);
			setLongClickable(true);
			setOnItemLongClickListener(new OnItemLongClickListener() {
				@Override
				public boolean onItemLongClick(AdapterView<?> arg0, View arg1,
						int position, long arg3) {
					selectedItem = position;
					openContextMenu(BookmarkList.this);
					return true;
				}
			});
		}

		public Bookmark getSelectedBookmark() {
			return (Bookmark)mAdapter.getItem(selectedItem);
		}
		
		@Override
		public boolean performItemClick(View view, int position, long id) {
			if ( mShortcutMode ) {
				Bookmark b = mBookInfo.findShortcutBookmark(position+1);
				if ( b==null ) {
					mReaderView.addBookmark(position+1);
					mThis.dismiss();
					return true;
				}
				selectedItem = position;
				openContextMenu(this);
			} else {
				Bookmark bm = (Bookmark)mAdapter.getItem(position);
				if ( bm!=null ) {
					mReaderView.goToBookmark(bm);
					dismiss();
				}
			}
			return true;
		}
		
		
	}
	
	final int SHORTCUT_COUNT = 10;
	
	public BookmarksDlg( CoolReader activity, ReaderView readerView )
	{
		super(activity, 0, 0, false);
		mThis = this; // for inner classes
        mInflater = LayoutInflater.from(getContext());
		mCoolReader = activity;
		mReaderView = readerView;
		mBookInfo = mReaderView.getBookInfo();
		setTitle(null);
		View frame = mInflater.inflate(R.layout.bookmark_list_dialog, null);
		ImageButton btnClose = (ImageButton)frame.findViewById(R.id.bookmark_close);
		btnClose.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				BookmarksDlg.this.dismiss();
			}
		});
		ImageButton btnAdd = (ImageButton)frame.findViewById(R.id.bookmark_add);
		btnAdd.setOnClickListener(new View.OnClickListener() {
			@Override
			public void onClick(View v) {
				BookmarksDlg.this.dismiss();
				mReaderView.addBookmark(0);
			}
		});
		ViewGroup body = (ViewGroup)frame.findViewById(R.id.bookmark_list);
		mList = new BookmarkList(activity, false);
		body.addView(mList);
		setView(frame);
	}

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		Log.v(""cr3"", ""creating BookmarksDlg"");
		//setTitle(mCoolReader.getResources().getString(R.string.win_title_bookmarks));
        setCancelable(true);
		super.onCreate(savedInstanceState);
		registerForContextMenu(mList);
	}
	@Override
	public boolean onContextItemSelected(MenuItem item) {
		
		int shortcut = selectedItem; //mList.getSelectedItemPosition();
		Bookmark bm = mList.getSelectedBookmark();
		if ( mList.isShortcutMode() ) {
			if ( shortcut>=0 && shortcut<SHORTCUT_COUNT ) {
				switch (item.getItemId()) {
				case R.id.bookmark_shortcut_add:
					mReaderView.addBookmark(shortcut+1);
					dismiss();
					return true;
				case R.id.bookmark_delete:
					Bookmark removed = mBookInfo.removeBookmark(bm);
					if ( removed.getId()!=null ) {
						mCoolReader.getDB().deleteBookmark(removed);
						mList.setShortcutMode(mList.isShortcutMode());
					}
					return true;
				case R.id.bookmark_shortcut_goto:
					mReaderView.goToBookmark(shortcut+1);
					dismiss();
					return true;
				}
			}
			return super.onContextItemSelected(item);
		}
		switch (item.getItemId()) {
		case R.id.bookmark_add:
			mReaderView.addBookmark(0);
			dismiss();
			return true;
		case R.id.bookmark_delete:
			Bookmark removed = mBookInfo.removeBookmark(bm);
			if ( removed.getId()!=null ) {
				mCoolReader.getDB().deleteBookmark(removed);
				mList.setShortcutMode(mList.isShortcutMode());
			}
			return true;
		case R.id.bookmark_goto:
			if ( bm!=null )
				mReaderView.goToBookmark(bm);
			dismiss();
			return true;
		case R.id.bookmark_edit:
			if ( bm!=null && (bm.getType()==Bookmark.TYPE_COMMENT || bm.getType()==Bookmark.TYPE_CORRECTION)) {
				BookmarkEditDialog dlg = new BookmarkEditDialog(mCoolReader, mReaderView, mBookInfo, bm, false);
				dlg.show();
			}
			dismiss();
			return true;
		case R.id.bookmark_export:
			if ( mBookInfo.getBookmarkCount()>0 ) {
				FileInfo fi = mBookInfo.getFileInfo();
				String s = fi.getPathName();
				s = s.replace(FileInfo.ARC_SEPARATOR, ""_"");
				s = s + "".bmk.txt"";
				if ( mBookInfo.exportBookmarks(s) )
					mCoolReader.showToast( getContext().getString(R.string.toast_bookmark_export_ok) + "" "" + s);
				else
					mCoolReader.showToast(getContext().getString(R.string.toast_bookmark_export_failed) + "" "" + s);
			}
			dismiss();
			return true;
		}
		return super.onContextItemSelected(item);
	}
	
	private int selectedItem;
	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
	    MenuInflater inflater = mCoolReader.getMenuInflater();
	    menu.clear();
	    inflater.inflate(mList.isShortcutMode() ? R.menu.cr3_bookmark_shortcut_context_menu : R.menu.cr3_bookmark_context_menu, menu);
	    AdapterContextMenuInfo mi = (AdapterContextMenuInfo)menuInfo;
	    if ( mi!=null )
	    	selectedItem = mi.position;
		Bookmark bm = mList.getSelectedBookmark();
	    menu.setHeaderTitle(getContext().getString(R.string.context_menu_title_bookmark));
	    for ( int i=0; i<menu.size(); i++ ) {
	    	MenuItem menuItem = menu.getItem(i);
	    	if ( menuItem.getItemId()==R.id.bookmark_shortcut_goto || menuItem.getItemId()==R.id.bookmark_edit ||
	    			menuItem.getItemId()==R.id.bookmark_delete )
	    		menuItem.setEnabled(bm!=null);
	    	if ( menuItem.getItemId()==R.id.bookmark_edit )
	    		menuItem.setEnabled(bm!=null && (bm.getType()==Bookmark.TYPE_COMMENT || bm.getType()==Bookmark.TYPE_CORRECTION));
	    	menuItem.setOnMenuItemClickListener(new OnMenuItemClickListener() {
				public boolean onMenuItemClick(MenuItem item) {
					onContextItemSelected(item);
					return true;
				}
			});
	    }
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if ( keyCode==KeyEvent.KEYCODE_MENU ) {
			openContextMenu(mList);
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}
	
	

}
",False,15,38,0,0,3,27,1,9,L1
10,org.coolreader.crengine.BaseDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.app.Dialog;
import android.graphics.PixelFormat;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;

public class BaseDialog extends Dialog {

	View layoutView;
	ViewGroup buttonsLayout;
	ViewGroup contentsLayout;
	public static final boolean DARK_THEME = true;
	public BaseDialog( CoolReader activity, int positiveButtonText, int negativeButtonText, boolean windowed )
	{
		this( activity, positiveButtonText, negativeButtonText, activity.isFullscreen(), activity.isNightMode(), windowed );
	}
	public BaseDialog( CoolReader activity, int positiveButtonText, int negativeButtonText, boolean fullscreen, boolean dark, boolean windowed )
	{
		//super(activity, fullscreen ? R.style.Dialog_Fullscreen : R.style.Dialog_Normal);
		//super(activity, fullscreen ? R.style.Dialog_Fullscreen : android.R.style.Theme_Dialog); //android.R.style.Theme_Light_NoTitleBar_Fullscreen : android.R.style.Theme_Light
		super(activity,
				windowed ? (dark||DARK_THEME ? android.R.style.Theme_Dialog : android.R.style.Theme_Dialog) :
				(fullscreen
				? (	dark||DARK_THEME ? R.style.Dialog_Fullscreen_Night : R.style.Dialog_Fullscreen_Day )
				: (	dark||DARK_THEME ? R.style.Dialog_Normal_Night : R.style.Dialog_Normal_Day )
				));
		setOwnerActivity(activity);
		this.mPositiveButtonText = positiveButtonText;
		this.mNegativeButtonText = negativeButtonText;
//		requestWindowFeature(Window.FEATURE_OPTIONS_PANEL);
		WindowManager.LayoutParams lp = new WindowManager.LayoutParams();
		lp.alpha = 1.0f;
		lp.dimAmount = 0.0f;
		lp.format = PixelFormat.RGB_565;
		lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL;
		lp.horizontalMargin = 0;
		lp.verticalMargin = 0;
		lp.windowAnimations = 0;
		lp.layoutAnimationParameters = null;
		//lp.memoryType = WindowManager.LayoutParams.MEMORY_TYPE_PUSH_BUFFERS;
		getWindow().setAttributes(lp);
		Log.i(""cr3"", ""BaseDialog.window="" + getWindow());
        setCancelable(true);
	}

	public void setView( View view )
	{
		this.view = view;
		if ( layoutView==null ) {
			layoutView = createLayout(view);
			setContentView(layoutView);
		}
		contentsLayout.removeAllViews();
		contentsLayout.addView(view);
	}
	
	protected void onPositiveButtonClick()
	{
		// override it
		dismiss();
	}
	
	protected void onNegativeButtonClick()
	{
		// override it
		dismiss();
	}

	protected void createButtonsPane( ViewGroup layout )
	{
		if ( mNegativeButtonText==0 && mPositiveButtonText==0 ) {
			layout.setVisibility(View.INVISIBLE);
			return;
		}
		//getWindow().getDecorView().getWidth()
		if ( mPositiveButtonText!=0 ) {
			Button positiveButton = (Button)layout.findViewById(R.id.base_dlg_btn_positive);
			if ( positiveButton==null ) {
				positiveButton = new Button(getContext());
				layout.addView(positiveButton);
			}
			positiveButton.setText(mPositiveButtonText);
			positiveButton.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					onPositiveButtonClick();
				}
			});
		}
		Button negativeButton = (Button)layout.findViewById(R.id.base_dlg_btn_negative);
		if ( negativeButton==null && mNegativeButtonText!=0 ) {
			negativeButton = new Button(getContext());
			layout.addView(negativeButton);
		}
		if ( negativeButton!=null ) {
			if ( mNegativeButtonText!=0 ) {
				negativeButton.setText(mNegativeButtonText);
				negativeButton.setOnClickListener(new View.OnClickListener() {
					public void onClick(View v) {
						onNegativeButtonClick();
					}
				});
			} else {
				negativeButton.setVisibility(View.INVISIBLE);
			}
		}
	}

	@Override
	public void setTitle(CharSequence title) {
		if ( title!=null )
			super.setTitle(title);
		else {
			getWindow().requestFeature(Window.FEATURE_NO_TITLE);
			//((CoolReader)getOwnerActivity()).applyFullscreen( getWindow() );
		}
	}

	protected View createLayout( View view )
	{
        LayoutInflater mInflater = LayoutInflater.from(getContext());
        ViewGroup layout = (ViewGroup)mInflater.inflate(R.layout.base_dialog, null);
        buttonsLayout = (ViewGroup)layout.findViewById(R.id.base_dialog_buttons_view);
        if ( buttonsLayout!=null ) {
            if ( mPositiveButtonText!=0 || mNegativeButtonText!=0 ) {
            	createButtonsPane(buttonsLayout);
            } else {
            	layout.removeView(buttonsLayout);
            }
        }
        contentsLayout =  (ViewGroup)layout.findViewById(R.id.base_dialog_content_view);
        contentsLayout.addView(view);
		return layout;
	}

	protected int mPositiveButtonText = 0;
	protected int mNegativeButtonText = 0;
	protected View view;
}
",False,13,38,0,0,3,20,10,1,L1
11,org.coolreader.crengine.TTSToolbarDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.view.View.OnTouchListener;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;

public class TTSToolbarDlg {
	PopupWindow mWindow;
	View mAnchor;
	CoolReader mCoolReader;
	ReaderView mReaderView;
	View mPanel;
	TTS mTTS;
	static public void showDialog( CoolReader coolReader, ReaderView readerView, TTS tts)
	{
		TTSToolbarDlg dlg = new TTSToolbarDlg(coolReader, readerView, tts);
		//dlg.mWindow.update(dlg.mAnchor, width, height)
		Log.d(""cr3"", ""popup: "" + dlg.mWindow.getWidth() + ""x"" + dlg.mWindow.getHeight());
		//dlg.update();
		//dlg.showAtLocation(readerView, Gravity.LEFT|Gravity.TOP, readerView.getLeft()+50, readerView.getTop()+50);
		//dlg.showAsDropDown(readerView);
		//dlg.update();
	}

	private boolean closed; 
	public void stopAndClose() {
		if (closed)
			return;
		closed = true;
		BackgroundThread.instance().executeGUI(new Runnable() {
			@Override
			public void run() {
				if ( mTTS!=null )
					mTTS.stop();
				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
	}
	
	public TTSToolbarDlg( CoolReader coolReader, ReaderView readerView, TTS tts )
	{
		mCoolReader = coolReader;
		mReaderView = readerView;
		mAnchor = readerView;
		mTTS = tts;

		View panel = (LayoutInflater.from(coolReader.getApplicationContext()).inflate(R.layout.tts_toolbar, null));
		panel.measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		
		//mReaderView.getS
		
		mWindow = new PopupWindow( mAnchor.getContext() );
		mWindow.setTouchInterceptor(new OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
					stopAndClose();
					return true;
				}
				return false;
			}
		});
		//super(panel);
		mPanel = panel;
		mPanel.findViewById(R.id.tts_play_pause).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
//				mReaderView.copyToClipboard(selection.text);
//				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.findViewById(R.id.tts_back).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
//				mCoolReader.findInDictionary( sel.text );
//				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.findViewById(R.id.tts_forward).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
//				mReaderView.showNewBookmarkDialog(sel);
				mWindow.dismiss();
			}
		});
		mPanel.findViewById(R.id.tts_stop).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				stopAndClose();
			}
		});
		mPanel.setFocusable(true);
		mPanel.setOnKeyListener( new OnKeyListener() {

			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ( event.getAction()==KeyEvent.ACTION_UP ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_BACK:
						mReaderView.clearSelection();
						mWindow.dismiss();
						return true;
//					case KeyEvent.KEYCODE_DPAD_LEFT:
//					case KeyEvent.KEYCODE_DPAD_UP:
//						//mReaderView.findNext(pattern, true, caseInsensitive);
//						return true;
//					case KeyEvent.KEYCODE_DPAD_RIGHT:
//					case KeyEvent.KEYCODE_DPAD_DOWN:
//						//mReaderView.findNext(pattern, false, caseInsensitive);
//						return true;
					}
				} else if ( event.getAction()==KeyEvent.ACTION_DOWN ) {
						switch ( keyCode ) {
//						case KeyEvent.KEYCODE_BACK:
//						case KeyEvent.KEYCODE_DPAD_LEFT:
//						case KeyEvent.KEYCODE_DPAD_UP:
//						case KeyEvent.KEYCODE_DPAD_RIGHT:
//						case KeyEvent.KEYCODE_DPAD_DOWN:
//							return true;
						}
					}
				if ( keyCode == KeyEvent.KEYCODE_BACK) {
					return true;
				}
				return false;
			}
			
		});

		mWindow.setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss() {
				mReaderView.clearSelection();
			}
		});
		
		mWindow.setBackgroundDrawable(new BitmapDrawable());
		//mWindow.setAnimationStyle(android.R.style.Animation_Toast);
		mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
		mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
//		setWidth(panel.getWidth());
//		setHeight(panel.getHeight());
		
		mWindow.setFocusable(true);
		mWindow.setTouchable(true);
		mWindow.setOutsideTouchable(true);
		mWindow.setContentView(panel);
		
		
		int [] location = new int[2];
		mAnchor.getLocationOnScreen(location);
		//mWindow.update(location[0], location[1], mPanel.getWidth(), mPanel.getHeight() );
		//mWindow.setWidth(mPanel.getWidth());
		//mWindow.setHeight(mPanel.getHeight());

		mWindow.showAtLocation(mAnchor, Gravity.TOP | Gravity.CENTER_HORIZONTAL, location[0], location[1] + mAnchor.getHeight() - mPanel.getHeight());
//		if ( mWindow.isShowing() )
//			mWindow.update(mAnchor, 50, 50);
		//dlg.mWindow.showAsDropDown(dlg.mAnchor);
	
	}
	
}
",False,21,38,0,0,3,28,1,4,L2
12,org.coolreader.crengine.Logger.java,"package org.coolreader.crengine;

public interface Logger {
	public void i(String msg); 
	public void i(String msg, Exception e); 
	public void w(String msg); 
	public void w(String msg, Exception e); 
	public void e(String msg); 
	public void e(String msg, Exception e); 
	public void d(String msg); 
	public void d(String msg, Exception e); 
	public void v(String msg); 
	public void v(String msg, Exception e);
	public void setLevel( int level );
}
",False,20,26,2,19,0,0,6,0,L1
13,org.coolreader.crengine.OptionOwner.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;

import android.view.LayoutInflater;

public interface OptionOwner {
	public CoolReader getActivity();
	public Properties getProperties();
	public LayoutInflater getInflater();
}
",False,31,38,0,0,3,19,2,2,L1
14,org.coolreader.crengine.OPDSUtil.java,"package org.coolreader.crengine;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Stack;
import java.util.concurrent.Callable;

import javax.net.ssl.HttpsURLConnection;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.coolreader.CoolReader;
import org.coolreader.crengine.Engine.DelayedProgress;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

import android.R;

public class OPDSUtil {

	/*
<?xml version=""1.0"" encoding=""utf-8""?>
<feed xmlns:opensearch=""http://a9.com/-/spec/opensearch/1.1/"" xmlns:relevance=""http://a9.com/-/opensearch/extensions/relevance/1.0/"" 
xmlns=""http://www.w3.org/2005/Atom"" 
xml:base=""http://lib.ololo.cc/opds/"">
<id>http://lib.ololo.cc/opds/</id>
<updated>2011-05-31T10:28:22+04:00</updated>
<title>OPDS: lib.ololo.cc</title>
<subtitle>Librusec mirror.</subtitle>
<author>
  <name>ololo team</name>
  <uri>http://lib.ololo.cc</uri><email>libololo@gmail.com</email>
</author>
<icon>http://lib.ololo.cc/book.png</icon>
<link rel=""self"" title=""This Page"" type=""application/atom+xml"" href=""/opds/""/>
<link rel=""alternate"" type=""text/html"" title=""HTML Page"" href=""/""/>
<entry>
   <updated>2011-05-31T10:28:22+04:00</updated>
   <id>http://lib.ololo.cc/opds/asearch/</id>
   <title></title>
   <content type=""text"">  </content>
   <link type=""application/atom+xml"" href=""http://lib.ololo.cc/opds/asearch/""/>
</entry>
</feed>
	 */
	/**
	 * Callback interface for OPDS.
	 */
	public interface DownloadCallback {
		/**
		 * Some entries are downloaded.
		 * @param doc is document
		 * @param entries is list of entries to add
		 */
		public void onEntries( DocInfo doc, Collection<EntryInfo> entries );
		/**
		 * All entries are downloaded.
		 * @param doc is document
		 * @param entries is list of entries to add
		 */
		public void onFinish( DocInfo doc, Collection<EntryInfo> entries );
		/**
		 * Before download: request filename to save as.
		 */
		public File onDownloadStart( String type, String url );
		/**
		 * Download progress
		 */
		public void onDownloadProgress( String type, String url, int percent );
		/**
		 * Book is downloaded.
		 */
		public void onDownloadEnd( String type, String url, File file );
		/**
		 * Error occured
		 */
		public void onError( String message );
	}
	
	public static class DocInfo {
		public String id;
		public long updated;
		public String title;
		public String subtitle;
		public String icon;
		public LinkInfo selfLink;
		public LinkInfo alternateLink;
	}
	
	public static class LinkInfo {
		public String href;
		public String rel;
		public String title;
		public String type;
		public LinkInfo( URL baseURL, Attributes attributes ) {
			rel = attributes.getValue(""rel"");
			type = attributes.getValue(""type"");
			title = attributes.getValue(""title"");
			href = convertHref( baseURL, attributes.getValue(""href"") );
		}
		public static String convertHref( URL baseURL, String href ) {
			if ( href==null )
				return href;
			if ( href.startsWith(""/"") )
				return baseURL.getProtocol() + ""://"" + baseURL.getHost() + href;
			if ( !href.startsWith(""http://"") )
				return baseURL.getProtocol() + ""://"" + baseURL.getHost() + ""/"" + baseURL.getPath() + ""/"" + href;
			return href;
		}
		public boolean isValid() {
			return href!=null && href.length()!=0;
		}
		public int getPriority() {
			if ( type==null )
				return 0;
			DocumentFormat df = DocumentFormat.byMimeType(type);
			if ( rel!=null && rel.indexOf(""acquisition"")<0 && df!=DocumentFormat.FB2 && df!=DocumentFormat.EPUB 
					&& df!=DocumentFormat.RTF && df!=DocumentFormat.DOC)
				return 0;
			return df!=null ? df.getPriority() : 0;
		}
		@Override
		public String toString() {
			return ""[ rel="" + rel + "", type="" + type
					+ "", title="" + title + "", href="" + href + ""]"";
		}
		
	}
	
	public static class AuthorInfo {
		public String name;
		public String uri;
	}
	
	public static class EntryInfo {
		public String id;
		public long updated;
		public String title="""";
		public String content="""";
		public String summary="""";
		public LinkInfo link;
		public ArrayList<LinkInfo> links = new ArrayList<LinkInfo>();
		public String icon;
		public ArrayList<String> categories = new ArrayList<String>(); 
		public ArrayList<AuthorInfo> authors = new ArrayList<AuthorInfo>(); 
		public LinkInfo getBestAcquisitionLink() {
			LinkInfo best = null;
			int bestPriority = 0; 
			for ( LinkInfo link : links ) {
				//boolean isAcquisition = link.rel!=null && link.rel.indexOf(""acquisition"")>=0;
				int priority = link.getPriority();
				if (priority>0 && priority>bestPriority) {
					if ( link.getPriority()>0 && (best==null || best.getPriority()<link.getPriority()) ) {
						best = link;
						bestPriority = priority;
					}
				}
			}
			return best;
		}
		public String getAuthors() {
			if ( authors.size()==0 )
				return null;
			StringBuilder buf = new StringBuilder(100);
			for ( AuthorInfo a : authors ) {
				if ( buf.length()>0 )
					buf.append("", "");
				buf.append(a.name);
			}
			return buf.toString();
		}
	}
	
	public static class OPDSHandler extends DefaultHandler {
		private URL url;
		private DocInfo docInfo = new DocInfo(); 
		private EntryInfo entryInfo = new EntryInfo(); 
		private ArrayList<EntryInfo> entries = new ArrayList<EntryInfo>(); 
		private Stack<String> elements = new Stack<String>();
		private Attributes currentAttributes;
		private AuthorInfo authorInfo;
		private boolean insideFeed;
		private boolean insideEntry;
		private boolean singleEntry;
		private int level = 0;
		//2011-05-31T10:28:22+04:00
		private static SimpleDateFormat tsFormat = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ssZ""); 
		private static SimpleDateFormat tsFormat2 = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss'Z'"");
		public OPDSHandler( URL url ) {
			this.url = url;
		}
		private long parseTimestamp( String ts ) {
			if ( ts==null )
				return 0;
			ts = ts.trim();
			try {
				if ( ts.length()==""2010-01-10T10:01:10Z"".length() )
					return tsFormat2.parse(ts).getTime();
				if ( ts.length()==""2011-11-11T11:11:11+67:87"".length()&& ts.lastIndexOf("":"")==ts.length()-3 ) {
					ts = ts.substring(0, ts.length()-3) + ts.substring(0, ts.length()-2);
					return tsFormat.parse(ts).getTime();
				}
				if ( ts.length()==""2011-11-11T11:11:11+6787"".length()) {
					return tsFormat.parse(ts).getTime();
				}
			} catch (ParseException e) {
			}
			L.e(""cannot parse timestamp "" + ts);
			return 0;
		}
		
		@Override
		public void characters(char[] ch, int start, int length)
				throws SAXException {
			super.characters(ch, start, length);
			
			String s = new String( ch, start, length);
			s = s.trim();
			if (s.length()==0 || (s.length()==1 && s.charAt(0) == '\n') )
				return; // ignore empty line
			L.d(tab() + ""  {"" + s + ""}"");
			String currentElement = elements.peek();
			if ( currentElement==null )
				return;
			if ( insideFeed ) {
				if ( ""id"".equals(currentElement) ) {
					if ( insideEntry )
						entryInfo.id = s;
					else
						docInfo.id = s;
				} else if ( ""updated"".equals(currentElement) ) {
					long ts = parseTimestamp(s);
					if ( insideEntry )
						entryInfo.updated = ts;
					else
						docInfo.updated = ts;
				} else if ( ""title"".equals(currentElement) ) {
					if ( !insideEntry )
						docInfo.title = s;
					else
						entryInfo.title = entryInfo.title + s;
				} else if ( ""summary"".equals(currentElement) ) {
					if ( insideEntry )
						entryInfo.summary = entryInfo.summary + s;
				} else if ( ""name"".equals(currentElement) ) {
					if ( authorInfo!=null )
						authorInfo.name = s;
				} else if ( ""uri"".equals(currentElement) ) {
					if ( authorInfo!=null )
						authorInfo.uri = s;
				} else if ( ""icon"".equals(currentElement) ) {
					if ( !insideEntry )
						docInfo.icon = s;
					else
						entryInfo.icon = s;
				} else if ( ""link"".equals(currentElement) ) {
					// rel, type, title, href
					if ( !insideEntry )
						docInfo.icon = s;
					else
						entryInfo.icon = s;
				} else if ( ""content"".equals(currentElement) ) {
					if ( insideEntry )
						entryInfo.content = entryInfo.content + s;
				} else if ( ""subtitle"".equals(currentElement) ) {
					if ( !insideEntry )
						docInfo.subtitle = s;
				}
			}
		}

		@Override
		public void endDocument() throws SAXException {
			super.endDocument();
			L.d(""endDocument: "" + entries.size() + "" entries parsed"");
			for ( EntryInfo entry : entries ) {
				L.d(""   "" + entry.title + "" : "" + entry.link.toString());
			}
		}

		private String tab() {
			if ( level<=1 )
				return """";
			StringBuffer buf = new StringBuffer(level*2);
			for ( int i=1; i<level; i++ )
				buf.append(""  "");
			return buf.toString();
		}
		
		@Override
		public void startElement(String uri, String localName,
				String qName, Attributes attributes)
				throws SAXException {
			super.startElement(uri, localName, qName, attributes);
			if ( qName!=null && qName.length()>0 )
				localName = qName;
			level++;
			L.d(tab() + ""<"" + localName + "">"");
			currentAttributes = attributes;
			elements.push(localName);
			//String currentElement = elements.peek();
			if ( !insideFeed && ""feed"".equals(localName) ) {
				insideFeed = true;
			} else if ( ""entry"".equals(localName) ) {
				if ( !insideFeed ) {
					insideFeed = true;
					singleEntry = true;
				}
				insideEntry = true;
				entryInfo = new EntryInfo();
			} else if ( ""category"".equals(localName) ) {
				if ( insideEntry ) {
					String category = attributes.getValue(""label"");
					if ( category!=null )
						entryInfo.categories.add(category);
				}
			} else if ( ""id"".equals(localName) ) {
				
			} else if ( ""updated"".equals(localName) ) {
				
			} else if ( ""title"".equals(localName) ) {
				
			} else if ( ""link"".equals(localName) ) {
				LinkInfo link = new LinkInfo(url, attributes);
				if ( link.isValid() && insideFeed ) {
					L.d(tab()+link.toString());
					if ( insideEntry ) {
						if ( link.type!=null ) {
							entryInfo.links.add(link);
							int priority = link.getPriority();
							if ( link.type.startsWith(""application/atom+xml"") ) {
								entryInfo.link = link;
							} else if (priority>0 && (entryInfo.link==null || entryInfo.link.getPriority()<priority)) {
								entryInfo.link = link;
							}
						}
					} else {
						if ( ""self"".equals(link.rel) )
							docInfo.selfLink = link;
						else if ( ""alternate"".equals(link.rel) )
							docInfo.alternateLink = link;
					}
				}
			} else if ( ""author"".equals(localName) ) {
				authorInfo = new AuthorInfo();
			}
		}
		
		@Override
		public void endElement(String uri, String localName,
				String qName) throws SAXException {
			super.endElement(uri, localName, qName);
			if ( qName!=null && qName.length()>0 )
				localName = qName;
			L.d(tab() + ""</"" + localName + "">"");
			//String currentElement = elements.peek();
			if ( insideFeed && ""feed"".equals(localName) ) {
				insideFeed = false;
			} else if ( ""entry"".equals(localName) ) {
				if ( !insideFeed || !insideEntry )
					throw new SAXException(""unexpected element "" + localName);
				if ( entryInfo.link!=null || entryInfo.getBestAcquisitionLink()!=null ) {
					entries.add(entryInfo);
				}
				insideEntry = false;
				entryInfo = null;
			} else if ( ""author"".equals(localName) ) {
				if ( authorInfo!=null && authorInfo.name!=null )
					entryInfo.authors.add(authorInfo);
				authorInfo = null;
			} 
			currentAttributes = null;
			if ( level>0 )
				level--;
		}

		@Override
		public void startDocument() throws SAXException {
			// TODO Auto-generated method stub
			super.startDocument();
		}

	}
	
	public static class DownloadTask {
		final private CoolReader coolReader; 
		final private URL url;
		final private String expectedType;
		final private String referer;
		final private String defaultFileName;
		final private DownloadCallback callback;
		private String progressMessage = ""Dowloading..."";
		private HttpURLConnection connection;
		private DelayedProgress delayedProgress;
		OPDSHandler handler;
		public DownloadTask( CoolReader coolReader, URL url, String defaultFileName, String expectedType, String referer, DownloadCallback callback ) {
			this.url = url;
			this.coolReader = coolReader;
			this.callback = callback; 
			this.referer = referer;
			this.expectedType = expectedType;
			this.defaultFileName = defaultFileName;
		}
		private void setProgressMessage( String url, int totalSize ) {
			progressMessage = coolReader.getString(org.coolreader.R.string.progress_downloading) + "" "" + url;
			if ( totalSize>0 )
				progressMessage = progressMessage + "" ("" + totalSize + "")"";
		}
		private void onError(final String msg) {
			BackgroundThread.guiExecutor.execute(new Runnable() {
				@Override
				public void run() {
					if ( delayedProgress!=null ) {
						delayedProgress.cancel();
						delayedProgress.hide();
					}
					coolReader.getEngine().hideProgress();
					callback.onError(msg);
				}
			});
		}
		private void parseFeed( InputStream is ) throws Exception {
			try {
				handler = new OPDSHandler(url);
				String[] namespaces = new String[] { 
                        ""access"", ""http://www.bloglines.com/about/specs/fac-1.0"",
                        ""admin"", ""http://webns.net/mvcb/"",
                        ""ag"", ""http://purl.org/rss/1.0/modules/aggregation/"",
                        ""annotate"", ""http://purl.org/rss/1.0/modules/annotate/"",
                        ""app"", ""http://www.w3.org/2007/app"",
                        ""atom"", ""http://www.w3.org/2005/Atom"",
                        ""audio"", ""http://media.tangent.org/rss/1.0/"",
                        ""blogChannel"", ""http://backend.userland.com/blogChannelModule"",
                        ""cc"", ""http://web.resource.org/cc/"",
                        ""cf"", ""http://www.microsoft.com/schemas/rss/core/2005"",
                        ""company"", ""http://purl.org/rss/1.0/modules/company"",
                        ""content"", ""http://purl.org/rss/1.0/modules/content/"",
                        ""conversationsNetwork"", ""http://conversationsnetwork.org/rssNamespace-1.0/"",
                        ""cp"", ""http://my.theinfo.org/changed/1.0/rss/"",
                        ""creativeCommons"", ""http://backend.userland.com/creativeCommonsRssModule"",
                        ""dc"", ""http://purl.org/dc/elements/1.1/"",
                        ""dcterms"", ""http://purl.org/dc/terms/"",
                        ""email"", ""http://purl.org/rss/1.0/modules/email/"",
                        ""ev"", ""http://purl.org/rss/1.0/modules/event/"",
                        ""feedburner"", ""http://rssnamespace.org/feedburner/ext/1.0"",
                        ""fh"", ""http://purl.org/syndication/history/1.0"",
                        ""foaf"", ""http://xmlns.com/foaf/0.1/"",
                        ""foaf"", ""http://xmlns.com/foaf/0.1"",
                        ""geo"", ""http://www.w3.org/2003/01/geo/wgs84_pos#"",
                        ""georss"", ""http://www.georss.org/georss"",
                        ""geourl"", ""http://geourl.org/rss/module/"",
                        ""g"", ""http://base.google.com/ns/1.0"",
                        ""gml"", ""http://www.opengis.net/gml"",
                        ""icbm"", ""http://postneo.com/icbm"",
                        ""image"", ""http://purl.org/rss/1.0/modules/image/"",
                        ""indexing"", ""urn:atom-extension:indexing"",
                        ""itunes"", ""http://www.itunes.com/dtds/podcast-1.0.dtd"",
                        ""kml20"", ""http://earth.google.com/kml/2.0"",
                        ""kml21"", ""http://earth.google.com/kml/2.1"",
                        ""kml22"", ""http://www.opengis.net/kml/2.2"",
                        ""l"", ""http://purl.org/rss/1.0/modules/link/"",
                        ""mathml"", ""http://www.w3.org/1998/Math/MathML"",
                        ""media"", ""http://search.yahoo.com/mrss/"",
                        ""openid"", ""http://openid.net/xmlns/1.0"",
                        ""opensearch10"", ""http://a9.com/-/spec/opensearchrss/1.0/"",
                        ""opensearch"", ""http://a9.com/-/spec/opensearch/1.1/"",
                        ""opml"", ""http://www.opml.org/spec2"",
                        ""rdf"", ""http://www.w3.org/1999/02/22-rdf-syntax-ns#"",
                        ""rdfs"", ""http://www.w3.org/2000/01/rdf-schema#"",
                        ""ref"", ""http://purl.org/rss/1.0/modules/reference/"",
                        ""reqv"", ""http://purl.org/rss/1.0/modules/richequiv/"",
                        ""rss090"", ""http://my.netscape.com/rdf/simple/0.9/"",
                        ""rss091"", ""http://purl.org/rss/1.0/modules/rss091#"",
                        ""rss1"", ""http://purl.org/rss/1.0/"",
                        ""rss11"", ""http://purl.org/net/rss1.1#"",
                        ""search"", ""http://purl.org/rss/1.0/modules/search/"",
                        ""slash"", ""http://purl.org/rss/1.0/modules/slash/"",
                        ""ss"", ""http://purl.org/rss/1.0/modules/servicestatus/"",
                        ""str"", ""http://hacks.benhammersley.com/rss/streaming/"",
                        ""sub"", ""http://purl.org/rss/1.0/modules/subscription/"",
                        ""svg"", ""http://www.w3.org/2000/svg"",
                        ""sx"", ""http://feedsync.org/2007/feedsync"",
                        ""sy"", ""http://purl.org/rss/1.0/modules/syndication/"",
                        ""taxo"", ""http://purl.org/rss/1.0/modules/taxonomy/"",
                        ""thr"", ""http://purl.org/rss/1.0/modules/threading/"",
                        ""thr"", ""http://purl.org/syndication/thread/1.0"",
                        ""trackback"", ""http://madskills.com/public/xml/rss/module/trackback/"",
                        ""wfw"", ""http://wellformedweb.org/CommentAPI/"",
                        ""wiki"", ""http://purl.org/rss/1.0/modules/wiki/"",
                        ""xhtml"", ""http://www.w3.org/1999/xhtml"",
                        ""xlink"", ""http://www.w3.org/1999/xlink"",
                        ""xrd"", ""xri://$xrd*($v*2.0)"",
                        ""xrds"", ""xri://$xrds""
				};
				for ( int i=0; i<namespaces.length-1; i+=2 )
					handler.startPrefixMapping(namespaces[i], namespaces[i+1]);
				SAXParserFactory spf = SAXParserFactory.newInstance();
				spf.setValidating(false);
//				spf.setNamespaceAware(true);
//				spf.setFeature(""http://xml.org/sax/features/namespaces"", false);
				SAXParser sp = spf.newSAXParser();
				//XMLReader xr = sp.getXMLReader();				
				sp.parse(is, handler);
			} catch (SAXException se) {
				L.e(""sax error"", se);
				throw se;
			} catch (IOException ioe) {
				L.e(""sax parse io error"", ioe);
				throw ioe;
			}
			BackgroundThread.guiExecutor.execute(new Runnable() {
				@Override
				public void run() {
					L.d(""Parsing is finished successfully. "" + handler.entries.size() + "" entries found"");
					callback.onFinish(handler.docInfo, handler.entries);
				}
			});
		}
		
		private File generateFileName( File outDir, String fileName, String type, boolean isZip ) {
			DocumentFormat fmt = type!=null ? DocumentFormat.byMimeType(type) : null;
			//DocumentFormat fmtext = fileName!=null ? DocumentFormat.byExtension(fileName) : null;
			if ( fileName==null )
				fileName = ""noname"";
			String ext = null;
			if ( fileName.lastIndexOf(""."")>0 ) {
				ext = fileName.substring(fileName.lastIndexOf(""."")+1);
				fileName = fileName.substring(0, fileName.lastIndexOf("".""));
			}
			fileName = transcribeFileName( fileName );
			if ( fmt!=null ) {
				if ( fmt==DocumentFormat.FB2 && isZip )
					ext = "".fb2.zip"";
				else
					ext = fmt.getExtensions()[0].substring(1);
			}
			for (int i=0; i<1000; i++ ) {
				String fn = fileName + (i==0 ? """" : ""("" + i + "")"") + ""."" + ext; 
				File f = new File(outDir, fn);
				if ( !f.exists() && !f.isDirectory() )
					return f;
			}
			return null;
		}
		private void downloadBook( final String type, final String url, InputStream is, int contentLength, final String fileName, final boolean isZip ) throws Exception {
			L.d(""Download requested: "" + type + "" "" + url + "" "" + contentLength);
			DocumentFormat fmt = DocumentFormat.byMimeType(type);
			if ( fmt==null ) {
				L.d(""Download: unknown type "" + type);
				throw new Exception(""Unknown file type "" + type);
			}
			final File outDir = BackgroundThread.instance().callGUI(new Callable<File>() {
				@Override
				public File call() throws Exception {
					return callback.onDownloadStart(type, url);
				}
			});
			if ( outDir==null ) {
				L.d(""Cannot find writable location for downloaded file "" + url);
				throw new Exception(""Cannot save file "" + url);
			}
			final File outFile = generateFileName( outDir, fileName, type, isZip );
			if ( outFile==null ) {
				L.d(""Cannot generate file name"");
				throw new Exception(""Cannot generate file name"");
			}
			L.d(""Creating file: "" + outFile.getAbsolutePath());
			if ( outFile.exists() || !outFile.createNewFile() ) {
				L.d(""Cannot create file "" + outFile.getAbsolutePath());
				throw new Exception(""Cannot create file"");
			}
			
			L.d(""Download started: "" + outFile.getAbsolutePath());
//			long lastTs = System.currentTimeMillis(); 
//			int lastPercent = -1;
			FileOutputStream os = null;
			boolean success = false;
			try {
				os = new FileOutputStream(outFile);
				byte[] buf = new byte[16384];
				int totalWritten = 0;
				while (totalWritten<contentLength || contentLength==-1) {
					int bytesRead = is.read(buf);
					if ( bytesRead<=0 )
						break;
					os.write(buf, 0, bytesRead);
					totalWritten += bytesRead;
//					final int percent = totalWritten * 100 / contentLength;
//					long ts = System.currentTimeMillis(); 
//					if ( percent!=lastPercent && ts - lastTs > 1500 ) {
//						L.d(""Download progress: "" + percent + ""%"");
//						BackgroundThread.instance().postGUI(new Runnable() {
//							@Override
//							public void run() {
//								callback.onDownloadProgress(type, url, percent);
//							}
//						});
//					}
				}
				success = true;
			} finally {
				if ( os!=null )
					os.close();
				if ( !success ) {
					if ( outFile.exists() && outFile.isFile() ) {
						L.w(""deleting unsuccessully downloaded file "" + outFile);
						outFile.delete();
					}
				}
			}
			L.d(""Download finished"");
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					callback.onDownloadEnd(type, url, outFile);
				}
			});
		}
		public static int findSubstring( byte[]buf, String str ) {
			for ( int i=0; i<buf.length-str.length(); i++ ) {
				boolean found = true;
				for ( int j=0; j<str.length(); j++ )
					if ( str.charAt(j)!=buf[i+j] ) {
						found = false;
						break;
					}
				if ( found )
					return i;
			}
			return -1; // not found
		}
		public void runInternal() {
			connection = null;
		    
			try {
				setProgressMessage( url.toString(), -1 );
				long startTimeStamp = System.currentTimeMillis();
				delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS); 
				URLConnection conn = url.openConnection();
				if ( conn instanceof HttpsURLConnection ) {
					onError(""HTTPs is not supported yet"");
					return;
				}
				if ( !(conn instanceof HttpURLConnection) ) {
					onError(""Only HTTP supported"");
					return;
				}
				connection = (HttpURLConnection)conn;
	            connection.setRequestProperty(""User-Agent"", ""CoolReader/3(Android)"");
	            if ( referer!=null )
	            	connection.setRequestProperty(""Referer"", referer);
	            connection.setInstanceFollowRedirects(true);
	            connection.setAllowUserInteraction(false);
	            connection.setConnectTimeout(20000);
	            connection.setReadTimeout(40000);
	            connection.setDoInput(true);
	            String fileName = null;
	            String disp = connection.getHeaderField(""Content-Disposition"");
	            if ( disp!=null ) {
	            	int p = disp.indexOf(""filename="");
	            	if ( p>0 ) {
	            		fileName = disp.substring(p + 9);
	            	}
	            }
	            //connection.setDoOutput(true);
	            //connection.set
	            
	            int response = -1;
				
				response = connection.getResponseCode();
				L.d(""Response: "" + response);
				if ( response!=200 ) {
					onError(""Error "" + response);
					return;
				}
				String contentType = connection.getContentType();
				String contentEncoding = connection.getContentEncoding();
				int contentLen = connection.getContentLength();
				//connection.getC
				L.d(""Entity content length: "" + contentLen);
				L.d(""Entity content type: "" + contentType);
				L.d(""Entity content encoding: "" + contentEncoding);
				setProgressMessage( url.toString(), contentLen );
				InputStream is = connection.getInputStream();
				delayedProgress.cancel();
				is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);
				final int MAX_CONTENT_LEN_TO_BUFFER = 256*1024;
				boolean isZip = contentType!=null && contentType.equals(""application/zip"");
				if ( expectedType!=null )
					contentType = expectedType;
				else if ( contentLen>0 && contentLen<MAX_CONTENT_LEN_TO_BUFFER) { // autodetect type
					byte[] buf = new byte[contentLen];
					if ( is.read(buf)!=contentLen ) {
						onError(""Wrong content length"");
						return;
					}
					is.close();
					is = null;
					is = new ByteArrayInputStream(buf);
					if ( findSubstring(buf, ""<?xml version="")>=0 && findSubstring(buf, ""<feed"")>=0  )
						contentType = ""application/atom+xml""; // override type
				}
				if ( contentType.startsWith(""application/atom+xml"") ) {
					L.d(""Parsing feed"");
					parseFeed( is );
				} else {
					if ( fileName==null )
						fileName = defaultFileName;
					L.d(""Downloading book: "" + contentEncoding);
					downloadBook( contentType, url.toString(), is, contentLen, fileName, isZip );
				}
			} catch (Exception e) {
				L.e(""Exception while trying to open URI "" + url.toString(), e);
				onError(""Error occured while reading OPDS catalog"");
			} finally {
				if ( connection!=null )
					try {
						connection.disconnect();
					} catch ( Exception e ) {
						// ignore
					}
			}
		}

		public void run() {
			BackgroundThread.backgroundExecutor.execute(new Runnable() {
				@Override
				public void run() {
					try {
						runInternal();
					} catch ( Exception e ) {
						L.e(""exception while opening OPDS"", e);
					}
				}
			});
		}

		public void cancel() {
		}

	
		public class ProgressInputStream extends InputStream {

			private static final int TIMEOUT = 1500;  
			
			private final InputStream sourceStream;
			private final int totalSize;
			private final String progressMessage;
			private long lastUpdate;
			private int lastPercent;
			private int maxPercentToStartShowingProgress;
			private boolean progressShown;
			private int bytesRead;
			
			public ProgressInputStream( InputStream sourceStream, long startTimeStamp, String progressMessage, int totalSize, int maxPercentToStartShowingProgress ) {
				this.sourceStream = sourceStream;
				this.totalSize = totalSize;
				this.maxPercentToStartShowingProgress = maxPercentToStartShowingProgress * 100;
				this.progressMessage = progressMessage;
				this.lastUpdate = startTimeStamp;
				this.bytesRead = 0;
				this.progressShown = false;
			}

			private void updateProgress() {
				long ts = System.currentTimeMillis();
				long delay = ts - lastUpdate;
				if ( delay > TIMEOUT ) {
					lastUpdate = ts;
					int percent = 0;
					if ( totalSize>0 ) {
						percent = bytesRead * 100 / totalSize * 100;
					}
					if ( (!progressShown || percent!=lastPercent) && (progressShown || percent<maxPercentToStartShowingProgress || delay > TIMEOUT*2 ) ) {
						coolReader.getEngine().showProgress(percent, progressMessage);
						lastPercent = percent;
						progressShown = true;
					}
				}
					
			}
			
			@Override
			public int read() throws IOException {
				bytesRead++;
				updateProgress();
				return sourceStream.read();
			}

			@Override
			public void close() throws IOException {
				super.close();
				if ( progressShown )
					coolReader.getEngine().hideProgress();
			}
			
			
			
		}
		
	}
	private static DownloadTask currentTask;
	public static DownloadTask create( CoolReader coolReader, URL uri, String defaultFileName, String expectedType, String referer, DownloadCallback callback ) {
		final DownloadTask task = new DownloadTask(coolReader, uri, defaultFileName, expectedType, referer, callback);
		currentTask = task;
		return task;
	}

	private static class SubstTable {
		private final int startChar;
		private final String[] replacements;
		public SubstTable( int startChar, String[] replacements ) {
			this.startChar = startChar;
			this.replacements = replacements;
		}
		boolean isInRange( char ch ) {
			return ch>=startChar && ch<startChar + replacements.length;
		}
		String get( char ch ) {
			return (ch>=startChar && ch<startChar + replacements.length) ? replacements[ch - startChar] : """";
		}
	}
	
	private final static SubstTable[] substTables = { 
		new SubstTable(0x430, new String[]{""a"", ""b"", ""v"", ""g"", ""d"", ""e"", ""zh"", ""z"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""r"", ""s"", ""t"", ""u"", ""f"", ""h"", ""c"", ""ch"", ""sh"", ""sch"", ""'"", ""y"", ""i"", ""e"", ""yu"", ""ya""}),
		new SubstTable(0x410, new String[]{""A"", ""B"", ""V"", ""G"", ""D"", ""E"", ""Zh"", ""Z"", ""I"", ""J"", ""K"", ""L"", ""M"", ""N"", ""O"", ""P"", ""R"", ""S"", ""T"", ""U"", ""F"", ""H"", ""C"", ""Ch"", ""Sh"", ""Sch"", ""'"", ""Y"", ""I"", ""E"", ""Yu"", ""Ya""}),
	};
	
	public static String transcribeFileName( String fileName ) {
		StringBuilder buf = new StringBuilder(fileName.length());
		for ( char ch : fileName.toCharArray() ) {
			boolean found = false;
			if ( ((ch>='a' && ch<='z') || (ch>='A' && ch<='Z') || (ch>='0' && ch<='9') || ch=='-' || ch=='_' || ch=='(' || ch==')')) {
				buf.append(ch);
				continue;
			}
			for ( SubstTable t : substTables ) {
				if ( t.isInRange(ch) ) {
					buf.append(t.get(ch));
					found = true;
				}
			}
			if ( found )
				continue;
			buf.append(""_"");
		}
		return buf.toString();
	}
	
	public static final int PROGRESS_DELAY_MILLIS = 1500; 
}
",True,30,38,0,0,3,16,1,5,L1
15,org.coolreader.crengine.Bookmark.java,"package org.coolreader.crengine;


public class Bookmark {

	public Bookmark()
	{
	}
	
	public Bookmark( Bookmark v )
	{
		id=v.id;
		type=v.type;
		percent=v.percent;
		shortcut=v.shortcut;
		startPos=v.startPos;
		endPos=v.endPos;
		titleText=v.titleText;
		posText=v.posText;
		commentText=v.commentText;
		timeStamp=v.timeStamp;
		modified=v.modified;
	}
	
	
	public int getType() {
		return type;
	}
	public void setType(int type) {
		this.type = type;
		modified = true;
	}
	public int getPercent() {
		return percent;
	}
	public void setPercent(int percent) {
		this.percent = percent;
		modified = true;
	}
	public String getStartPos() {
		return startPos;
	}
	public void setStartPos(String startPos) {
		this.startPos = startPos;
		modified = true;
	}
	public String getEndPos() {
		return endPos;
	}
	public void setEndPos(String endPos) {
		this.endPos = endPos;
		modified = true;
	}
	public String getCommentText() {
		return commentText;
	}
	private boolean changed( String v1, String v2 ) {
		if ( v1==null && v2==null )
			return false;
		if ( v1==null || v2==null )
			return true;
		return !v1.equals(v2);
	}
	public boolean setCommentText(String commentText) {
		if ( !changed(this.commentText, commentText) )
			return false;
		this.commentText = commentText;
		modified = true;
		return true;
	}
	public String getTitleText() {
		return titleText;
	}
	public String getPosText() {
		return posText;
	}
	
	public void setTitleText(String titleText) {
		this.titleText = titleText;
		modified = true;
	}
	public void setPosText(String posText) {
		this.posText = posText;
		modified = true;
	}
	public int getShortcut() {
		return shortcut;
	}
	public void setShortcut(int shortcut) {
		modified = true;
		this.shortcut = shortcut;
	}
	public long getTimeStamp() {
		return timeStamp;
	}
	public void setTimeStamp(long timeStamp) {
		if ( this.timeStamp == timeStamp )
			return;
		this.timeStamp = timeStamp;
		modified = true;
	}
	
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id = id;
	}

	public boolean isModified() {
		return modified || id==null;
	}
	public void setModified(boolean modified) {
		this.modified = modified;
	}

	public static final int TYPE_LAST_POSITION = 0;
	public static final int TYPE_POSITION = 1;
	public static final int TYPE_COMMENT = 2;
	public static final int TYPE_CORRECTION = 3;
	private Long id;
	private int type;
	private int percent;
	private int shortcut;
	private String startPos;
	private String endPos;
	private String titleText;
	private String posText;
	private String commentText;
	private long timeStamp = System.currentTimeMillis(); // UTC timestamp
	private boolean modified;
	
}
",False,36,28,4,11,0,0,7,0,L1
16,org.coolreader.crengine.DocumentFormat.java,"package org.coolreader.crengine;

import org.coolreader.R;

public enum DocumentFormat {
	/// lvtinydom.h: source document formats
	//typedef enum {
	NONE(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book, false, 0, 
			new String[] {},
			new String[] {}),// doc_format_none,
	FB2(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book_fb2, true, 10, 
			new String[] {"".fb2"", "".fb2.zip""},
			new String[] {""application/fb2+zip""}), // doc_format_fb2,
	TXT(""txt.css"", R.raw.txt, R.drawable.cr3_browser_book_txt, false, 3, 
			new String[] {"".txt"", "".tcr"", "".pml""},
			new String[] {""text/plain""}), // doc_format_txt,
	PDB(""htm.css"", R.raw.htm, R.drawable.cr3_browser_book_pdb, false, 4, 
			new String[] {"".pdb"", "".prc"", "".mobi"", "".azw""},
			new String[] {}), // doc_format_txt/html/...,
	RTF(""rtf.css"", R.raw.rtf, R.drawable.cr3_browser_book_rtf, false, 7, 
			new String[] {"".rtf""},
			new String[] {}), // doc_format_rtf,
	EPUB(""epub.css"", R.raw.epub, R.drawable.cr3_browser_book_epub, true, 9, 
			new String[] {"".epub""},
			new String[] {""application/epub+zip""}),// doc_format_epub,
	HTML(""htm.css"", R.raw.htm, R.drawable.cr3_browser_book_html, false, 8, 
			new String[] {"".htm"", "".html"", "".shtml"", "".xhtml""},
			new String[] {""text/html""}),// doc_format_html,
	TXT_BOOKMARK(""fb2.css"", R.raw.fb2, R.drawable.cr3_browser_book_fb2, false, 0, 
			new String[] {"".txt.bmk""},
			new String[] {}), // doc_format_txt_bookmark, // coolreader TXT format bookmark
	CHM(""chm.css"", R.raw.chm, R.drawable.cr3_browser_book_chm, false, 6, 
			new String[] {"".chm""},
			new String[] {}), //  doc_format_chm,
	DOC(""doc.css"", R.raw.doc, R.drawable.cr3_browser_book_doc, false, 5, 
			new String[] {"".doc""},
			new String[] {}); // doc_format_doc,
    // don't forget update getDocFormatName() when changing this enum
	//} doc_format_t;
	
	public String getCssName()
	{
		return cssFileName;
	}
	
	public int getPriority()
	{
		return priority;
	}
	
	public String[] getExtensions()
	{
		return extensions;
	}
	
	public int getCSSResourceId()
	{
		return cssResourceId;
	}
	
	public int getIconResourceId()
	{
		return iconResourceId;
	}
	
	public String[] getMimeFormats()
	{
		return mimeFormats;
	}
	
	public String getMimeFormat()
	{
		return mimeFormats.length>0 ? mimeFormats[0] : null;
	}
	
	public boolean canParseProperties()
	{
		return canParseProperties;
	}
	
	public static DocumentFormat byId( int i )
	{
		if ( i>=0 && i<DocumentFormat.values().length )
			return values()[i];
		return null;
	}
	
	public boolean matchExtension( String filename )
	{
		for ( String ext : extensions )
			if ( filename.endsWith(ext) )
				return true;
		return false;
	}
	
	public boolean matchMimeType( String type )
	{
		for ( String s : mimeFormats ) {
			if ( type.equals(s) || type.startsWith(s+"";""))
				return true;
		}
		return false;
	}
	
	public static DocumentFormat byExtension( String filename )
	{
		String s = filename.toLowerCase();
		for ( int i=0; i<DocumentFormat.values().length; i++ )
			if ( values()[i].matchExtension(s))
				return values()[i];
		return null;
	}
	
	public static DocumentFormat byMimeType( String format )
	{
		if ( format==null )
			return null;
		String s = format.toLowerCase();
		for ( int i=0; i<DocumentFormat.values().length; i++ )
			if ( values()[i].matchMimeType(s))
				return values()[i];
		return null;
	}
	
	private DocumentFormat( String cssFileName, int cssResourceId, int iconResourceId, boolean canParseProperties, int priority, String extensions[], String mimeFormats[] )
	{
		this.cssFileName = cssFileName;
		this.cssResourceId = cssResourceId;
		this.iconResourceId = iconResourceId;
		this.extensions = extensions;
		this.canParseProperties = canParseProperties;
		this.mimeFormats = mimeFormats;
		this.priority = priority;
	}
	final private String cssFileName;
	final private int cssResourceId;
	final private int iconResourceId;
	final private String[] extensions;
	final boolean canParseProperties;
	final private String[] mimeFormats;
	final private int priority;
}
",False,29,30,4,15,0,0,7,0,L0
17,org.coolreader.crengine.FileInfo.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.coolreader.R;

import android.util.Log;

public class FileInfo {

	public final static String RECENT_DIR_TAG = ""@recent"";
	public final static String SEARCH_RESULT_DIR_TAG = ""@search"";
	public final static String ROOT_DIR_TAG = ""@root"";
	public final static String OPDS_LIST_TAG = ""@opds"";
	public final static String OPDS_DIR_PREFIX = ""@opds:"";
	public final static String AUTHORS_TAG = ""@authors"";
	public final static String AUTHOR_PREFIX = ""@author:"";
	
	
	
	Long id; // db id
	String title; // book title
	String authors; // authors, delimited with '|'
	String series; // series name w/o number
	int seriesNumber; // number of book inside series
	String path; // path to directory where file or archive is located
	String filename; // file name w/o path for normal file, with optional path for file inside archive 
	String pathname; // full path+arcname+filename
	String arcname; // archive file name w/o path
	DocumentFormat format;
	int size;
	int arcsize;
	long createTime;
	long lastAccessTime;
	int flags;
	boolean isArchive;
	boolean isDirectory;
	boolean isModified;
	boolean isListed;
	boolean isScanned;
	private ArrayList<FileInfo> files;// files
	private ArrayList<FileInfo> dirs; // directories
	FileInfo parent; // parent item
	
	Object tag; // some additional information
	
	public static final int DONT_USE_DOCUMENT_STYLES_FLAG = 1;

	/**
	 * To separate archive name from file name inside archive.
	 */
	public static final String ARC_SEPARATOR = ""@/"";
	
	
	public void setFlag( int flag, boolean value ) {
		flags = flags & (~flag) | (value? flag : 0);
	}
	
	public boolean getFlag( int flag ) {
		return (flags & flag)!=0;
	}
	
	/**
	 * Split archive + file path name by ARC_SEPARATOR
	 * @param pathName is pathname like /arc_file_path@/filepath_inside_arc or /file_path 
	 * @return item[0] is pathname, item[1] is archive name (null if no archive)
	 */
	public static String[] splitArcName( String pathName )
	{
		String[] res = new String[2];
		int arcSeparatorPos = pathName.indexOf(ARC_SEPARATOR);
		if ( arcSeparatorPos>=0 ) {
			// from archive
			res[1] = pathName.substring(0, arcSeparatorPos);
			res[0] = pathName.substring(arcSeparatorPos + ARC_SEPARATOR.length());
		} else {
			res[0] = pathName;
		}
		return res;
	}
	
	public FileInfo( String pathName )
	{
		String[] parts = splitArcName( pathName );
		if ( parts[1]!=null ) {
			// from archive
			isArchive = true;
			arcname = parts[1];
			pathname = parts[0];
			File f = new File(pathname);
			filename = f.getName();
			path = f.getPath();
			File arc = new File(arcname);
			if ( arc.isFile() && arc.exists() ) {
				arcsize = (int)arc.length();
				try {
					ZipFile zip = new ZipFile(new File(arcname));
					for ( Enumeration<?> e = zip.entries(); e.hasMoreElements(); ) {
						ZipEntry entry = (ZipEntry)e.nextElement();
						
						String name = entry.getName();
						if ( !entry.isDirectory() && !pathname.equals(name) ) {
							format = DocumentFormat.byExtension(name);
							size = (int)entry.getSize();
							createTime = entry.getTime();
							break;
						}
					}
				} catch ( Exception e ) {
					Log.e(""cr3"", ""error while reading contents of "" + arcname);
				}
			}
		} else {
			fromFile(new File(pathName));
		}
	}
	
	public String getFileNameToDisplay() {
		boolean isSingleFileArchive = (isArchive && parent!=null && !parent.isArchive && arcname!=null);
		return isSingleFileArchive
			? new File(arcname).getName() : filename;
	}
	
	private void fromFile( File f )
	{
		if ( !f.isDirectory() ) {
			DocumentFormat fmt = DocumentFormat.byExtension(f.getName());
			filename = f.getName();
			path = f.getParent();
			pathname = f.getAbsolutePath();
			format = fmt;
			createTime = f.lastModified();
			size = (int)f.length();
		} else {
			filename = f.getName();
			path = f.getParent();
			pathname = f.getAbsolutePath();
			isDirectory = true;
		}
	}
	
	public FileInfo( File f )
	{
		fromFile(f);
	}
	
	public FileInfo()
	{
	}

	/// doesn't copy parent and children
	public FileInfo(FileInfo v)
	{
		title = v.title;
		authors = v.authors;
		series = v.series;
		seriesNumber = v.seriesNumber;
		path = v.path;
		filename = v.filename;
		pathname = v.pathname;
		arcname = v.arcname;
		format = v.format;
		size = v.size;
		arcsize = v.arcsize;
		isArchive = v.isArchive;
		isDirectory = v.isDirectory;
		createTime = v.createTime;
		lastAccessTime = v.lastAccessTime;
	}
	
	/**
	 * @return archive file path and name, null if this object is neither archive nor a file inside archive
	 */
	public String getArchiveName()
	{
		return arcname;
	}
	
	/**
	 * @return file name inside archive, null if this object is not a file inside archive
	 */
	public String getArchiveItemName()
	{
		if ( isArchive && !isDirectory && pathname!=null )
			return pathname;
		return null;
	}
	
	public boolean isRecentDir()
	{
		return RECENT_DIR_TAG.equals(pathname);
	}
	
	public boolean isSearchDir()
	{
		return SEARCH_RESULT_DIR_TAG.equals(pathname);
	}
	
	public boolean isRootDir()
	{
		return ROOT_DIR_TAG.equals(pathname);
	}
	
	public boolean isSpecialDir()
	{
		return pathname!=null && pathname.startsWith(""@"");
	}
	
	public boolean isOPDSDir()
	{
		return pathname!=null && pathname.startsWith(OPDS_DIR_PREFIX);
	}
	
	public boolean isOPDSRoot()
	{
		return OPDS_LIST_TAG.equals(pathname);
	}
	
	public boolean isHidden()
	{
		return pathname.startsWith(""."");
	}
	
	public String getOPDSUrl()
	{
		if ( !pathname.startsWith(OPDS_DIR_PREFIX) )
			return null;
		return pathname.substring(OPDS_DIR_PREFIX.length());
	}
	
	/**
	 * Get absolute path to file.
	 * For plain files, returns /abs_path_to_file/filename.ext
	 * For archives, returns /abs_path_to_archive/arc_file_name.zip@/filename_inside_archive.ext
	 * @return full path + filename
	 */
	public String getPathName()
	{
		if ( arcname!=null )
			return arcname + ARC_SEPARATOR + pathname;
		return pathname;
	}

	public String getBasePath()
	{
		if ( arcname!=null )
			return arcname;
		return pathname;
	}

	public int dirCount()
	{
		return dirs!=null ? dirs.size() : 0;
	}

	public int fileCount()
	{
		return files!=null ? files.size() : 0;
	}

	public int itemCount()
	{
		return dirCount() + fileCount();
	}

	public void addDir( FileInfo dir )
	{
		if ( dirs==null )
			dirs = new ArrayList<FileInfo>();
		dirs.add(dir);
	}
	public void addFile( FileInfo file )
	{
		if ( files==null )
			files = new ArrayList<FileInfo>();
		files.add(file);
	}
	public void addItems( Collection<FileInfo> items )
	{
		for ( FileInfo item : items ) {
			if ( item.isDirectory )
				addDir(item);
			else
				addFile(item);
			item.parent = this;
		}
	}
	public void replaceItems( Collection<FileInfo> items )
	{
		files = null;
		dirs = null;
		addItems( items );
	}
	public boolean isEmpty()
	{
		return fileCount()==0 && dirCount()==0;
	}
	public FileInfo getItem( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<dirCount())
			return dirs.get(index);
		index -= dirCount();
		if ( index<fileCount())
			return files.get(index);
		Log.e(""cr3"", ""Index out of bounds "" + index + "" at FileInfo.getItem() : returning 0"");
		//throw new IndexOutOfBoundsException();
		return null;
	}
	public FileInfo findItemByPathName( String pathName )
	{
		if ( dirs!=null )
			for ( FileInfo dir : dirs )
				if ( pathName.equals(dir.getPathName() ))
					return dir;
		if ( files!=null )
			for ( FileInfo file : files ) {
				if ( pathName.equals(file.getPathName() ))
					return file;
				if ( file.getPathName().startsWith(pathName+""@/"" ))
					return file;
			}
		return null;
	}
	public int getItemIndex( FileInfo item )
	{
		if ( item==null )
			return -1;
		for ( int i=0; i<dirCount(); i++ ) {
			if ( item.getPathName().equals(getDir(i).getPathName()) )
				return i;
		}
		for ( int i=0; i<fileCount(); i++ ) {
			if ( item.getPathName().equals(getFile(i).getPathName()) )
				return i + dirCount();
		}
		return -1;
	}

	public FileInfo getDir( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<dirCount())
			return dirs.get(index);
		throw new IndexOutOfBoundsException();
	}
	public FileInfo getFile( int index )
	{
		if ( index<0 )
			throw new IndexOutOfBoundsException();
		if ( index<fileCount())
			return files.get(index);
		throw new IndexOutOfBoundsException();
	}

	public void removeEmptyDirs()
	{
		if ( parent==null || pathname.startsWith(""@"") )
			return;
		for ( int i=dirCount()-1; i>=0; i-- )
			if ( getDir(i).dirCount()==0 && getDir(i).fileCount()==0 )
				dirs.remove(i);
	}
	
	public void removeChild( FileInfo item )
	{
		if ( item.isSpecialDir() )
			return;
		if ( files!=null ) {
			int n = files.indexOf(item);
			if ( n>=0 && n<files.size() ) {
				files.remove(n);
				return;
			}
		}
		if ( dirs!=null ) {
			int n = dirs.indexOf(item);
			if ( n>=0 && n<dirs.size() ) {
				dirs.remove(n);
			}
		}
	}
	
	public boolean deleteFile()
	{
		if ( isArchive ) {
			if ( isDirectory )
				return false;
			File f = new File(arcname);
			if ( f.exists() && !f.isDirectory() ) {
				if ( !f.delete() )
					return false;
				if ( parent!=null ) {
					if ( parent.isArchive ) {
						// remove all files belonging to this archive
					} else {
						parent.removeChild(this);
					}
				}
				return true;
			}
		}
		if ( isDirectory )
			return false;
		if ( !fileExists() )
			return false;
		File f = new File(pathname);
		if ( f.delete() ) {
			if ( parent!=null ) {
				parent.removeChild(this);
			}
			return true;
		}
		return false;
	}
	
	public boolean fileExists()
	{
		if (isDirectory)
			return false;
		if ( isArchive ) {
			if ( arcname!=null )
				return new File(arcname).exists();
			return false;
		}
		return new File(pathname).exists();
	}
	
	/**
	 * @return true if item (file, directory, or archive) exists
	 */
	public boolean exists()
	{
		if ( isArchive ) {
			if ( arcname==null )
				return false;
			File f = new File(arcname);
			return f.exists();
		}
		File f = new File(pathname);
		return f.exists();
	}
	
	public boolean isModified() {
		return isModified || id==null;
	}

	public void setModified(boolean isModified) {
		this.isModified = isModified;
	}

	public void clear()
	{
		dirs = null;
		files = null;
	}
	
	public static enum SortOrder {
		FILENAME(R.string.mi_book_sort_order_filename, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return cmp(f1.getFileNameToDisplay(), f2.getFileNameToDisplay());
			}
		}),
		FILENAME_DESC(R.string.mi_book_sort_order_filename_desc, FILENAME),
		TIMESTAMP(R.string.mi_book_sort_order_timestamp, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz( cmp(f1.createTime, f2.createTime), cmp(f1.filename, f2.filename) );
			}
		}),
		TIMESTAMP_DESC(R.string.mi_book_sort_order_timestamp_desc, TIMESTAMP),
		AUTHOR_TITLE(R.string.mi_book_sort_order_author, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz(
						cmpNotNullFirst(f1.authors, f2.authors)
						,cmpNotNullFirst(f1.series, f2.series)
						,cmp(f1.seriesNumber, f2.seriesNumber)
						,cmpNotNullFirst(f1.title, f2.title)
						,cmp(f1.filename, f2.filename) 
						);
			}
		}),
		AUTHOR_TITLE_DESC(R.string.mi_book_sort_order_author_desc, AUTHOR_TITLE),
		TITLE_AUTHOR(R.string.mi_book_sort_order_title, new Comparator<FileInfo>() {
			public int compare( FileInfo f1, FileInfo f2 )
			{
				if ( f1==null || f2==null )
					return 0;
				return firstNz(
						cmpNotNullFirst(f1.series, f2.series)
						,cmp(f1.seriesNumber, f2.seriesNumber)
						,cmpNotNullFirst(f1.title, f2.title)
						,cmpNotNullFirst(f1.authors, f2.authors)
						,cmp(f1.filename, f2.filename) 
						);
			}
		}),
		TITLE_AUTHOR_DESC(R.string.mi_book_sort_order_title_desc, TITLE_AUTHOR);
		//================================================
		private final Comparator<FileInfo> comparator;
		public final int resourceId;
		private SortOrder( int resourceId, Comparator<FileInfo> comparator )
		{
			this.resourceId = resourceId;
			this.comparator = comparator;
		}
		private SortOrder( int resourceId, final SortOrder base )
		{
			this.resourceId = resourceId;
			this.comparator = new Comparator<FileInfo>() {
				public int compare( FileInfo f1, FileInfo f2 )
				{
					return -base.comparator.compare(f1, f2);
				}
			};
		}
		
		public final Comparator<FileInfo> getComparator()
		{
			return comparator;
		}
		
		/**
		 * Compares two strings - with numbers sorted by value.
		 * @param str1
		 * @param str2
		 * @return
		 */
		private static int cmp( String str1, String str2 )
		{
			if ( str1==null && str2==null )
				return 0;
			if ( str1==null )
				return -1;
			if ( str2==null )
				return 1;
			
			int p1 = 0;
			int p2 = 0;
			for ( ;; ) {
				if ( p1>=str1.length() ) {
					if ( p2>=str2.length() )
						return 0;
					return 1;
				}
				if ( p2>=str2.length() )
					return -1;
				char ch1 = str1.charAt(p1);
				char ch2 = str2.charAt(p2);
				if ( ch1>='0' && ch1<='9' && ch2>='0' && ch2<='9' ) {
					int n1 = 0;
					int n2 = 0;
					while ( ch1>='0' && ch1<='9' ) {
						p1++;
						n1 = n1 * 10 + (ch1-'0');
						if ( p1>=str1.length() )
							break;
						ch1 = str1.charAt(p1);
					}
					while ( ch2>='0' && ch2<='9' ) {
						p2++;
						n2 = n2 * 10 + (ch2-'0');
						if ( p2>=str2.length() )
							break;
						ch2 = str2.charAt(p2);
					}
					int c = cmp(n1, n2);
					if ( c!=0 )
						return c;
				} else {
					if ( ch1<ch2 )
						return -1;
					if ( ch1>ch2 )
						return 1;
					p1++;
					p2++;
				}
			}
		}
		
		/**
		 * Same as cmp, but not-null comes first
		 * @param str1
		 * @param str2
		 * @return
		 */
		private static int cmpNotNullFirst( String str1, String str2 )
		{
			if ( str1==null && str2==null )
				return 0;
			if ( str1==null )
				return 1;
			if ( str2==null )
				return -1;
			return cmp(str1, str2);
		}
		
		private static int cmp( long n1, long n2 )
		{
			if ( n1<n2 )
				return -1;
			if ( n1>n2 )
				return 1;
			return 0;
		}
		
		private static int firstNz( int... v)
		{
			for ( int i=0; i<v.length; i++ ) {
				if ( v[i]!=0 )
					return v[i];
			}
			return 0;
		}
		public static SortOrder fromName( String name ) {
			if ( name!=null )
				for ( SortOrder order : values() )
					if ( order.name().equals(name) )
						return order;
			return DEF_SORT_ORDER;
		}
	}
	public final static SortOrder DEF_SORT_ORDER = SortOrder.AUTHOR_TITLE;
		
	public void sort( SortOrder SortOrder )
	{
		if ( dirs!=null ) {
			ArrayList<FileInfo> newDirs = new ArrayList<FileInfo>(dirs);
			Collections.sort( newDirs, SortOrder.getComparator() );
			dirs = newDirs;
		}
		if ( files!=null ) {
			ArrayList<FileInfo> newFiles = new ArrayList<FileInfo>(files);
			Collections.sort( newFiles, SortOrder.getComparator() );
			files = newFiles;
		}
	}
	
	@Override
	public String toString()
	{
		return pathname;
	}
	
	public boolean allowSorting() {
		return isDirectory && !isRootDir() && !isRecentDir() && !isOPDSDir();
	}
}
",True,35,29,4,15,1,1,10,1,L1
18,org.coolreader.crengine.BackgroundTextureInfo.java,"package org.coolreader.crengine;

import java.io.File;

public class BackgroundTextureInfo {
	public String id; // filepath for external image or unique symbolic name for resource
	public String name;
	public int resourceId;
	public boolean tiled;
	public BackgroundTextureInfo(String id, String name, int resourceId) {
		this.id = id;
		this.name = name;
		this.resourceId = resourceId;
		this.tiled = id.startsWith(""tx_"") || id.indexOf(""/textures/"")>0;
	}

	public static BackgroundTextureInfo fromFile( String filename ) {
		if ( filename==null )
			return null;
		File f = new File(filename);
		if ( !f.isFile() || !f.exists() )
			return null;
		String nm = new File(filename).getName();
		String fnlc = nm.toLowerCase();
		if ( fnlc.endsWith("".png"") || fnlc.endsWith("".jpg"") || fnlc.endsWith("".jpeg"") || fnlc.endsWith("".gif"") ) {
			return new BackgroundTextureInfo(filename, nm.substring(0, nm.lastIndexOf('.')), 0);
		}
		return null;
	}

	public static final String NO_TEXTURE_ID = ""(NONE)"";
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((id == null) ? 0 : id.hashCode());
		result = prime * result + ((name == null) ? 0 : name.hashCode());
		result = prime * result + resourceId;
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		BackgroundTextureInfo other = (BackgroundTextureInfo) obj;
		if (id == null) {
			if (other.id != null)
				return false;
		} else if (!id.equals(other.id))
			return false;
		if (name == null) {
			if (other.name != null)
				return false;
		} else if (!name.equals(other.name))
			return false;
		if (resourceId != other.resourceId)
			return false;
		return true;
	}
	@Override
	public String toString() {
		return ""BackgroundTextureInfo [id="" + id + "", name="" + name + ""]"";
	}
	public boolean isNone() {
		return id==null || id.equals(NO_TEXTURE_ID);
	}
}
",False,11,26,4,13,0,0,3,0,L1
19,org.coolreader.crengine.History.java,"package org.coolreader.crengine;

import java.io.ByteArrayInputStream;
import java.lang.reflect.Method;
import java.util.ArrayList;

import org.coolreader.CoolReader;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.util.Log;

public class History {
	private ArrayList<BookInfo> mBooks = new ArrayList<BookInfo>();
	private final CRDB mDB;
	private final CoolReader mCoolReader;
	private FileInfo mRecentBooksFolder;
	
	public History(CoolReader cr, CRDB db)
	{
		this.mCoolReader = cr;
		this.mDB = db;
	}
	
	public BookInfo getLastBook()
	{
		if ( mBooks.size()==0 )
			return null;
		return mBooks.get(0);
	}

	public BookInfo getOrCreateBookInfo( FileInfo file )
	{
		BookInfo res = getBookInfo(file);
		if ( res==null ) {
			res = new BookInfo( file );
			mBooks.add(0, res);
		}
		return res;
	}
	
	public BookInfo getBookInfo( FileInfo file )
	{
		int index = findBookInfo( file );
		if ( index>=0 )
			return mBooks.get(index);
		return null;
	}

	public BookInfo getBookInfo( String pathname )
	{
		int index = findBookInfo( pathname );
		if ( index>=0 )
			return mBooks.get(index);
		return null;
	}
	
	public void removeBookInfo( FileInfo fileInfo, boolean removeRecentAccessFromDB, boolean removeBookFromDB )
	{
		int index = findBookInfo(fileInfo);
		if ( index>=0 )
			mBooks.remove(index);
		if ( mDB.findByPathname(fileInfo) ) {
			if ( removeBookFromDB )
				mDB.deleteBook(fileInfo);
			else if ( removeRecentAccessFromDB )
				mDB.deleteRecentPosition(fileInfo);
		}
	}
	
	public void updateBookAccess( BookInfo bookInfo )
	{
		Log.v(""cr3"", ""History.updateBookAccess() for "" + bookInfo.getFileInfo().getPathName());
		int index = findBookInfo(bookInfo.getFileInfo());
		if ( index>=0 ) {
			BookInfo info = mBooks.get(index);
			if ( index>0 ) {
				mBooks.remove(index);
				mBooks.add(0, info);
			}
			info.updateAccess();
			updateRecentDir();
		}
	}

	public int findBookInfo( String pathname )
	{
		for ( int i=0; i<mBooks.size(); i++ )
			if ( pathname.equals(mBooks.get(i).getFileInfo().getPathName()) )
				return i;
		return -1;
	}
	
	public int findBookInfo( FileInfo file )
	{
		return findBookInfo( file.getPathName() );
	}
	
	public Bookmark getLastPos( FileInfo file )
	{
		int index = findBookInfo(file);
		if ( index<0 )
			return null;
		return mBooks.get(index).getLastPosition();
	}
	protected void updateRecentDir()
	{
		Log.v(""cr3"", ""History.updateRecentDir()"");
		if ( mRecentBooksFolder!=null ) { 
			mRecentBooksFolder.clear();
			for ( BookInfo book : mBooks )
				mRecentBooksFolder.addFile(book.getFileInfo());
		} else {
			Log.v(""cr3"", ""History.updateRecentDir() : mRecentBooksFolder is null"");
		}
	}
	static class ImageData {
		long bookId;
		byte[] data;
		BitmapDrawable drawable = null;
	}
	class ImageDataCache {
		private final int maxSize;
		private int dataSize = 0;
		private int maxCount = 15;
		private ArrayList<ImageData> list = new ArrayList<ImageData>();
		public ImageDataCache( int maxSize, int maxCount ) {
			this.maxSize = maxSize;
			this.maxCount = maxCount;
		}
		synchronized public void clear() {
			list.clear();
		}
		synchronized public byte[] get( long bookId ) {
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId )
					return list.get(i).data;
			return null;
		}
		synchronized public void put( long bookId, byte[] data ) {
			boolean found = false;
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId ) {
					dataSize -= list.get(i).data.length;  
					dataSize += data.length;  
					list.get(i).data = data;
					if ( i>0 ) {
						ImageData item = list.remove(i);
						list.add(0, item);
					}
					found = true;
					break;
				}
			if ( !found ) {
				ImageData item = new ImageData();
				item.bookId = bookId;
				item.data = data;
				list.add(0, item);
				dataSize += data.length;
			}
			for ( int i=list.size()-1; i>0; i-- ) {
				if ( dataSize>maxSize || list.size()>maxCount ) {
					ImageData item = list.remove(i);
					dataSize -= item.data.length;
				} else
					break;
			}
		}
		synchronized public BitmapDrawable getImage( long bookId )
		{
			ImageData item = null;
			for ( int i=0; i<list.size(); i++ )
				if ( list.get(i).bookId==bookId ) {
					item = list.get(i);
					break;
				}
			if ( item==null )
				return null;
			byte[] data = get(bookId);
			if ( data==null || data.length==0 )
				return null;
			if ( item.drawable!=null )
				return item.drawable;
			// decode & resize
			BitmapDrawable res = decodeCoverPage( data );
			if ( res!=null ) {
	    		item.drawable = res;
			} else {
	    		item.data = new byte[] {};
			}
			return res;
		}
		synchronized void invalidateImages()
		{
			for ( int i=0; i<list.size(); i++ )
				list.get(i).drawable = null;
		}
	}
	
	private static Method bitmapSetDensityMethod;
	private static Method canvasSetDensityMethod;
	private static boolean isNewApiChecked;
	public BitmapDrawable decodeCoverPage( byte[] data )
	{
		try {
			ByteArrayInputStream is = new ByteArrayInputStream(data);
			Bitmap srcbmp = BitmapFactory.decodeStream(is);
			//BitmapDrawable drawable = new BitmapDrawable(mCoolReader.getResources(), is);
			//BitmapDrawable drawable = new BitmapDrawable(null, is);
			
			if ( !isNewApiChecked ) {
				isNewApiChecked = true;
				try {
					bitmapSetDensityMethod = Bitmap.class.getMethod(""setDensity"", new Class[] {int.class});
					canvasSetDensityMethod = Canvas.class.getMethod(""setDensity"", new Class[] {int.class});
				} catch ( Exception e ) {
					L.w(""No Bitmap.setDensity() method found"");
				}
			}
			
			Bitmap bmp = Bitmap.createBitmap(coverPageWidth, coverPageHeight, Bitmap.Config.ARGB_8888);
			if ( bitmapSetDensityMethod!=null )
				bitmapSetDensityMethod.invoke(bmp, Bitmap.DENSITY_NONE);
			//bmp.setDensity(Bitmap.DENSITY_NONE); // mCoolReader.getResources().getDisplayMetrics().densityDpi
			Canvas canvas = new Canvas(bmp);
			if ( canvasSetDensityMethod!=null )
				canvasSetDensityMethod.invoke(canvas, Bitmap.DENSITY_NONE);
			//canvas.setDensity(Bitmap.DENSITY_NONE); // mCoolReader.getResources().getDisplayMetrics().densityDpi
			canvas.drawBitmap(srcbmp, new Rect(0, 0, srcbmp.getWidth(), srcbmp.getHeight()),
					new Rect(0, 0, coverPageWidth, coverPageHeight), null);
    		Log.d(""cr3"", ""cover page format: "" + srcbmp.getWidth() + ""x"" + srcbmp.getHeight());
    		BitmapDrawable res = new BitmapDrawable(bmp);

    		
//			BitmapDrawable drawable = new BitmapDrawable(mCoolReader.getResources(), is);
//			//BitmapDrawable drawable = new BitmapDrawable(null, is);
//			Bitmap bmp = Bitmap.createBitmap(coverPageWidth, coverPageHeight, Bitmap.Config.ARGB_8888);
//			bmp.setDensity(mCoolReader.getResources().getDisplayMetrics().densityDpi); //Bitmap.DENSITY_NONE
//			Canvas canvas = new Canvas(bmp);
//			canvas.setDensity(mCoolReader.getResources().getDisplayMetrics().densityDpi); //Bitmap.DENSITY_NONE
//			canvas.drawBitmap(drawable.getBitmap(), new Rect(0, 0, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight()),
//					new Rect(0, 0, coverPageWidth, coverPageHeight), null);
//    		Log.d(""cr3"", ""cover page format: "" + drawable.getIntrinsicWidth() + ""x"" + drawable.getIntrinsicHeight());
//    		BitmapDrawable res = new BitmapDrawable(bmp);
    		
    		
    		return res;
		} catch ( Exception e ) {
    		Log.e(""cr3"", ""exception while decoding coverpage "" + e.getMessage());
    		return null;
		}
	}
	
	private boolean coverPagesEnabled = true;
	public boolean getCoverPagesEnabled()
	{
		return coverPagesEnabled;
	}
	
	public void setCoverPagesEnabled(boolean coverPagesEnabled)
	{
		this.coverPagesEnabled = coverPagesEnabled;
		if ( !coverPagesEnabled ) {
			coverPageCache.clear();
		}
	}
	
	public final static int COVERPAGE_IMAGE_CACHE_DATA_SIZE = 500000;
	public final static int COVERPAGE_IMAGE_CACHE_MAX_COUNT = 20;
	private ImageDataCache coverPageCache = new ImageDataCache(COVERPAGE_IMAGE_CACHE_DATA_SIZE, COVERPAGE_IMAGE_CACHE_MAX_COUNT);
	private int coverPageWidth = 60;
	private int coverPageHeight = 80;
	public void setBookCoverpageData(long bookId, byte[] coverpageData )
	{
		if ( bookId==0 )
			return;
		byte[] oldData = coverPageCache.get(bookId);
		if ( coverpageData==null )
			coverpageData = new byte[] {};
		if ( oldData==null || oldData.length!=coverpageData.length ) { 
			coverPageCache.put(bookId, coverpageData);
			mDB.saveBookCoverpage(bookId, coverpageData);
		}
	}
	public void updateCoverPageSize( int screenDX, int screenDY )
	{
		int min = screenDX<screenDY ? screenDX : screenDY;
		coverPageHeight = min / 4;
		coverPageWidth = coverPageHeight * 3 / 4;
		coverPageCache.invalidateImages();
	}
	public byte[] getBookCoverpageData(long bookId)
	{
		if ( bookId==0 )
			return null;
		byte[] data = coverPageCache.get(bookId);
		if ( data==null ) {
			data = mDB.loadBookCoverpage(bookId);
			if ( data==null )
				data = new byte[] {};
			coverPageCache.put(bookId, data);
		}
		return data.length>0 ? data : null;
	}
	public BitmapDrawable getBookCoverpageImage(Resources resources, long bookId)
	{
		byte[] data = getBookCoverpageData(bookId);
		if ( data==null )
			return null;
		return coverPageCache.getImage( bookId );
	}
	public boolean loadFromDB( Scanner scanner, int maxItems )
	{
		Log.v(""cr3"", ""History.loadFromDB()"");
		mBooks = mDB.loadRecentBooks(scanner.mFileList, maxItems);
		mRecentBooksFolder = scanner.mRoot.getDir(0);
		if ( mRecentBooksFolder==null )
			Log.v(""cr3"", ""History.loadFromDB() : mRecentBooksFolder is null"");
		updateRecentDir();
		return true;
	}

	public boolean saveToDB( )
	{
		Log.v(""cr3"", ""History.saveToDB()"");
		try {
			for ( BookInfo book : mBooks )
				mDB.save(book);
			return true;
		} catch ( Exception e ) {
			Log.e(""cr3"", ""error while saving file history "" + e.getMessage(), e);
			return false;
		}
	}

}
",True,8,38,0,0,3,17,3,7,L1
20,org.coolreader.crengine.PositionProperties.java,"package org.coolreader.crengine;

public class PositionProperties {
	public int x;
	public int y;
	public int fullHeight;
	public int pageHeight;
	public int pageWidth;
	public int pageNumber;
	public int pageCount;
	public int pageMode; // 1, 2 for page mode, 0 for scroll mode
	
	
	
	@Override
	public String toString() {
		return ""PositionProperties [pageMode="" + pageMode + "", pageNumber=""
				+ pageNumber + "", pageCount="" + pageCount + "", x="" + x + "", y=""
				+ y + "", pageHeight="" + pageHeight + "", pageWidth="" + pageWidth
				+ "", fullHeight="" + fullHeight + ""]"";
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + fullHeight;
		result = prime * result + pageCount;
		result = prime * result + pageHeight;
		result = prime * result + pageMode;
		result = prime * result + pageNumber;
		result = prime * result + pageWidth;
		result = prime * result + x;
		result = prime * result + y;
		return result;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		PositionProperties other = (PositionProperties) obj;
		if (fullHeight != other.fullHeight)
			return false;
		if (pageCount != other.pageCount)
			return false;
		if (pageHeight != other.pageHeight)
			return false;
		if (pageMode != other.pageMode)
			return false;
		if (pageNumber != other.pageNumber)
			return false;
		if (pageWidth != other.pageWidth)
			return false;
		if (x != other.x)
			return false;
		if (y != other.y)
			return false;
		return true;
	}
	
	
}
",False,18,26,4,12,0,0,1,0,L2
21,org.coolreader.crengine.Scanner.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.zip.ZipEntry;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.Engine.EngineTask;

import android.os.Environment;
import android.util.Log;

public class Scanner {
	
	HashMap<String, FileInfo> mFileList = new HashMap<String, FileInfo>();
	ArrayList<FileInfo> mFilesForParsing = new ArrayList<FileInfo>();
	FileInfo mRoot;
	
	boolean mHideEmptyDirs = true;
	
	void setHideEmptyDirs( boolean flgHide ) {
		mHideEmptyDirs = flgHide;
	}

//	private boolean scanDirectories( FileInfo baseDir )
//	{
//		try {
//			File dir = new File(baseDir.pathname);
//			File[] items = dir.listFiles();
//			// process normal files
//			for ( File f : items ) {
//				if ( !f.isDirectory() ) {
//					FileInfo item = new FileInfo( f );
//					if ( item.format!=null ) {
//						item.parent = baseDir;
//						baseDir.addFile(item);
//						mFileList.add(item);
//					}
//				}
//			}
//			// process directories 
//			for ( File f : items ) {
//				if ( f.isDirectory() ) {
//					FileInfo item = new FileInfo( f );
//					item.parent = baseDir;
//					scanDirectories(item);
//					if ( !item.isEmpty() ) {
//						baseDir.addDir(item);					
//					}
//				}
//			}
//			return !baseDir.isEmpty();
//		} catch ( Exception e ) {
//			L.e(""Exception while scanning directory "" + baseDir.pathname, e);
//			return false;
//		}
//	}
	
	private boolean dirScanEnabled = true;
	public boolean getDirScanEnabled()
	{
		return dirScanEnabled;
	}
	
	public void setDirScanEnabled(boolean dirScanEnabled)
	{
		this.dirScanEnabled = dirScanEnabled;
	}
	
	private FileInfo scanZip( FileInfo zip )
	{
		try {
			File zf = new File(zip.pathname);
			//ZipFile file = new ZipFile(zf);
			ArrayList<ZipEntry> entries = engine.getArchiveItems(zip.pathname);
			ArrayList<FileInfo> items = new ArrayList<FileInfo>();
			//for ( Enumeration<?> e = file.entries(); e.hasMoreElements(); ) {
			for ( ZipEntry entry : entries ) {
				if ( entry.isDirectory() )
					continue;
				String name = entry.getName();
				FileInfo item = new FileInfo();
				item.format = DocumentFormat.byExtension(name);
				if ( item.format==null )
					continue;
				File f = new File(name);
				item.filename = f.getName();
				item.path = f.getPath();
				item.pathname = entry.getName();
				item.size = (int)entry.getSize();
				//item.createTime = entry.getTime();
				item.createTime = zf.lastModified();
				item.arcname = zip.pathname;
				item.arcsize = (int)entry.getSize(); //getCompressedSize();
				item.isArchive = true;
				items.add(item);
			}
			if ( items.size()==0 ) {
				L.i(""Supported files not found in "" + zip.pathname);
				return null;
			} else if ( items.size()==1 ) {
				// single supported file in archive
				FileInfo item = items.get(0);
				item.isArchive = true;
				item.isDirectory = false;
				return item;
			} else {
				zip.isArchive = true;
				zip.isDirectory = true;
				zip.isListed = true;
				for ( FileInfo item : items ) {
					item.parent = zip;
					zip.addFile(item);
				}
				return zip;
			}
		} catch ( Exception e ) {
			L.e(""IOException while opening "" + zip.pathname + "" "" + e.getMessage());
		}
		return null;
	}
	
	/**
	 * Adds dir and file children to directory FileInfo item.
	 * @param baseDir is directory to list files and dirs for
	 * @return true if successful.
	 */
	public boolean listDirectory( FileInfo baseDir )
	{
		Set<String> knownItems = null;
		if ( baseDir.isListed ) {
			knownItems = new HashSet<String>();
			for ( int i=baseDir.itemCount()-1; i>=0; i-- ) {
				FileInfo item = baseDir.getItem(i);
				if ( !item.exists() ) {
					// remove item from list
					baseDir.removeChild(item);
				} else {
					knownItems.add(item.getBasePath());
				}
			}
		}
		try {
			File dir = new File(baseDir.pathname);
			File[] items = dir.listFiles();
			// process normal files
			if ( items!=null ) {
				for ( File f : items ) {
					if ( !f.isDirectory() ) {
						if ( f.getName().startsWith(""."") )
							continue; // treat files beginning with '.' as hidden
						String pathName = f.getAbsolutePath();
						if ( knownItems!=null && knownItems.contains(pathName) )
							continue;
						boolean isZip = pathName.toLowerCase().endsWith("".zip"");
						FileInfo item = mFileList.get(pathName);
						boolean isNew = false;
						if ( item==null ) {
							item = new FileInfo( f );
							if ( isZip ) {
								item = scanZip( item );
								if ( item==null )
									continue;
								if ( item.isDirectory ) {
									// many supported files in ZIP
									item.parent = baseDir;
									baseDir.addDir(item);
									for ( int i=0; i<item.fileCount(); i++ ) {
										FileInfo file = item.getFile(i);
										mFileList.put(file.getPathName(), file);
									}
								} else {
									item.parent = baseDir;
									baseDir.addFile(item);
									mFileList.put(pathName, item);
								}
								continue;
							}
							isNew = true;
						}
						if ( item.format!=null ) {
							item.parent = baseDir;
							baseDir.addFile(item);
							if ( isNew )
								mFileList.put(pathName, item);
						}
					}
				}
				// process directories 
				for ( File f : items ) {
					if ( f.isDirectory() ) {
						if ( f.getName().startsWith(""."") )
							continue; // treat dirs beginning with '.' as hidden
						FileInfo item = new FileInfo( f );
						if ( knownItems!=null && knownItems.contains(item.getPathName()) )
							continue;
						item.parent = baseDir;
						baseDir.addDir(item);					
					}
				}
			}
			baseDir.isListed = true;
			return !baseDir.isEmpty();
		} catch ( Exception e ) {
			L.e(""Exception while listing directory "" + baseDir.pathname, e);
			baseDir.isListed = true;
			return false;
		}
	}
	
	public static class ScanControl {
		volatile private boolean stopped = false;
		public boolean isStopped() {
			return stopped;
		}
		public void stop() {
			stopped = true;
		}
	}
	
	/**
	 * Scan single directory for dir and file properties in background thread.
	 * @param baseDir is directory to scan
	 * @param readyCallback is called on completion
	 */
	public void scanDirectory( final FileInfo baseDir, final Runnable readyCallback, final boolean recursiveScan, final ScanControl scanControl )
	{
		final long startTime = System.currentTimeMillis();
		listDirectory(baseDir);
		listSubtree( baseDir, 2, android.os.SystemClock.uptimeMillis() + 700 );
		if ( (!getDirScanEnabled() || baseDir.isScanned) && !recursiveScan ) {
			readyCallback.run();
			return;
		}
		engine.execute(new EngineTask() {
			long nextProgressTime = startTime + 2000;
			boolean progressShown = false;
			void progress( int percent )
			{
				if ( recursiveScan )
					return; // no progress dialog for recursive scan
				long ts = System.currentTimeMillis();
				if ( ts>=nextProgressTime ) {
					engine.showProgress(percent, R.string.progress_scanning);
					nextProgressTime = ts + 1500;
					progressShown = true;
				}
			}
			
			public void done() {
				baseDir.isScanned = true;
				if ( progressShown )
					engine.hideProgress();
				readyCallback.run();
			}

			public void fail(Exception e) {
				L.e(""Exception while scanning directory "" + baseDir.pathname, e);
				baseDir.isScanned = true;
				if ( progressShown )
					engine.hideProgress();
				readyCallback.run();
			}

			public void scan( FileInfo baseDir ) {
				if ( baseDir.isRecentDir() )
					return;
				//listDirectory(baseDir);
				progress(1000);
				if ( scanControl.isStopped() )
					return;
				for ( int i=baseDir.dirCount()-1; i>=0; i-- ) {
					if ( scanControl.isStopped() )
						return;
					listDirectory(baseDir.getDir(i));
				}
				progress(2000);
				if ( mHideEmptyDirs )
					baseDir.removeEmptyDirs();
				if ( scanControl.isStopped() )
					return;
				ArrayList<FileInfo> filesForParsing = new ArrayList<FileInfo>();
				int count = baseDir.fileCount();
				for ( int i=0; i<count; i++ ) {
					FileInfo item = baseDir.getFile(i);
					boolean found = db.findByPathname(item);
					if ( found )
						Log.v(""cr3db"", ""File "" + item.pathname + "" is found in DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");

					boolean saveToDB = true;
					if ( !found && item.format.canParseProperties() ) {
						filesForParsing.add(item);
						saveToDB = false;
					}

					if ( !found && saveToDB ) {
						db.save(item);
						Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
					}
					progress( 2000 + 3000 * i / count );
				}
				// db lookup files
				count = filesForParsing.size();
				for ( int i=0; i<count; i++ ) {
					if ( scanControl.isStopped() )
						return;
					FileInfo item = filesForParsing.get(i);
					engine.scanBookProperties(item);
					db.save(item);
					Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
					progress( 5000 + 5000 * i / count );
				}
				if ( recursiveScan ) {
					if ( scanControl.isStopped() )
						return;
					for ( int i=baseDir.dirCount()-1; i>=0; i-- )
						scan(baseDir.getDir(i));
				}
			}
			
			public void work() throws Exception {
				// scan (list) directories
				nextProgressTime = startTime + 1500;
				scan( baseDir );
			}
		});
	}

//	private int lastPercent = 0;
//	private long lastProgressUpdate = 0;
//	private final int PROGRESS_UPDATE_INTERVAL = 2000; // 2 seconds
//	private void updateProgress( int percent )
//	{
//		long ts = System.currentTimeMillis();
//		if ( percent!=lastPercent && ts>lastProgressUpdate+PROGRESS_UPDATE_INTERVAL ) {
//			engine.showProgress(percent, ""Scanning directories..."");
//			lastPercent = percent;
//			lastProgressUpdate = ts;
//		}
//	}
	
//	private void lookupDB()
//	{
//		int count = mFileList.size();
//		for ( int i=0; i<count; i++ ) {
//			FileInfo item = mFileList.get(i);
//			boolean found = db.findByPathname(item);
//			if ( found )
//				Log.v(""cr3db"", ""File "" + item.pathname + "" is found in DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//
//			boolean saveToDB = true;
//			if ( !found && item.format==DocumentFormat.FB2 ) {
//				mFilesForParsing.add(item);
//				saveToDB = false;
//			}
//
//			if ( !found && saveToDB ) {
//				db.save(item);
//				Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//			}
//			updateProgress( 1000 + 4000 * i / count );
//		}
//	}
//	
//	private void parseBookProperties()
//	{
//		int count = mFilesForParsing.size();
//		for ( int i=0; i<count; i++ ) {
//			FileInfo item = mFilesForParsing.get(i);
//			engine.scanBookProperties(item);
//			db.save(item);
//			Log.v(""cr3db"", ""File "" + item.pathname + "" is added to DB (id=""+item.id+"", title="" + item.title + "", authors="" + item.authors +"")"");
//			updateProgress( 5000 + 5000 * i / count );
//		}
//	}
	
	private boolean addRoot( String pathname, int resourceId, boolean listIt)
	{
		return addRoot( pathname, coolReader.getResources().getString(resourceId), listIt);
	}
	private boolean addRoot( String pathname, String filename, boolean listIt)
	{
		FileInfo dir = new FileInfo();
		dir.isDirectory = true;
		dir.pathname = pathname;
		dir.filename = filename;
		if ( mRoot.findItemByPathName(pathname)!=null )
			return false; // exclude duplicates
		if ( listIt && !listDirectory(dir) )
			return false;
		mRoot.addDir(dir);
		dir.parent = mRoot;
		if ( !listIt ) {
			dir.isListed = true;
			dir.isScanned = true;
		}
		return true;
	}
	
	private void addOPDSRoot() {
		FileInfo dir = new FileInfo();
		dir.isDirectory = true;
		dir.pathname = FileInfo.OPDS_LIST_TAG;
		dir.filename = ""OPDS Catalogs"";
		dir.isListed = true;
		dir.isScanned = true;
		dir.parent = mRoot;
		mRoot.addDir(dir);
		String[] urls = {
				""http://www.feedbooks.com/catalog/"", ""Feedbooks"",
				""http://bookserver.archive.org/catalog/"", ""Internet Archive"",
				""http://m.gutenberg.org/"", ""Project Gutenberg"", 
				""http://ebooksearch.webfactional.com/catalog.atom"", ""eBookSearch"", 
				""http://bookserver.revues.org/"", ""Revues.org"", 
				""http://www.legimi.com/opds/root.atom"", ""Legimi"",
				""http://www.ebooksgratuits.com/opds/"", ""Ebooks libres et gratuits"",
				""http://213.5.65.159/opds/"", ""Flibusta"", 
				""http://lib.ololo.cc/opds/"", ""lib.ololo.cc"",
		};
		for ( int i=0; i<urls.length-1; i+=2 ) {
			String url = urls[i];
			String title = urls[i+1];
			FileInfo odps = new FileInfo();
			odps.isDirectory = true;
			odps.pathname = FileInfo.OPDS_DIR_PREFIX + url;
			odps.filename = title;
			odps.isListed = true;
			odps.isScanned = true;
			odps.parent = dir;
			dir.addDir(odps);
		}
	}
	
	/**
	 * Lists all directories from root to directory of specified file, returns found directory.
	 * @param file
	 * @param root
	 * @return
	 */
	private FileInfo findParentInternal( FileInfo file, FileInfo root )
	{
		if ( root==null || file==null || root.isRecentDir() )
			return null;
		if ( !root.isRootDir() && !file.getPathName().startsWith( root.getPathName() ) )
			return null;
		// to list all directories starting root dir
		if ( root.isDirectory && !root.isSpecialDir() )
				listDirectory(root);
		for ( int i=0; i<root.dirCount(); i++ ) {
			FileInfo found = findParentInternal( file, root.getDir(i));
			if ( found!=null )
				return found;
		}
		for ( int i=0; i<root.fileCount(); i++ ) {
			if ( root.getFile(i).getPathName().equals(file.getPathName()) )
				return root;
			if ( root.getFile(i).getPathName().startsWith(file.getPathName() + ""@/"") )
				return root;
		}
		return null;
	}
	
	public final static int MAX_DIR_LIST_TIME = 500; // 0.5 seconds
	
	/**
	 * Lists all directories from root to directory of specified file, returns found directory.
	 * @param file
	 * @param root
	 * @return
	 */
	public FileInfo findParent( FileInfo file, FileInfo root )
	{
		FileInfo parent = findParentInternal(file, root);
		if ( parent==null ) {
			autoAddRootForFile(new File(file.pathname) );
			parent = findParentInternal(file, root);
			if ( parent==null ) {
				L.e(""Cannot find root directory for file "" + file.pathname);
				return null;
			}
		}
		long maxTs = android.os.SystemClock.uptimeMillis() + MAX_DIR_LIST_TIME;
		listSubtrees(root, mHideEmptyDirs ? 5 : 1, maxTs);
		return parent;
	}
	
	/**
	 * List directories in subtree, limited by runtime and depth; remove empty branches (w/o books).  
	 * @param root is directory to start with
	 * @param maxDepth is maximum depth
	 * @param limitTs is limit for android.os.SystemClock.uptimeMillis()
	 * @return true if completed, false if stopped by limit. 
	 */
	private boolean listSubtree( FileInfo root, int maxDepth, long limitTs )
	{
		long ts = android.os.SystemClock.uptimeMillis();
		if ( ts>limitTs || maxDepth<=0 )
			return false;
		listDirectory(root);
		for ( int i=root.dirCount()-1; i>=-0; i-- ) {
			boolean res = listSubtree(root.getDir(i), maxDepth-1, limitTs);
			if ( !res )
				return false;
		}
		if ( mHideEmptyDirs )
			root.removeEmptyDirs();
		return true;
	}
	
	/**
	 * List directories in subtree, limited by runtime and depth; remove empty branches (w/o books).  
	 * @param root is directory to start with
	 * @param maxDepth is maximum depth
	 * @param limitTs is limit for android.os.SystemClock.uptimeMillis()
	 * @return true if completed, false if stopped by limit. 
	 */
	public boolean listSubtrees( FileInfo root, int maxDepth, long limitTs )
	{
		for ( int depth = 1; depth<=maxDepth; depth++ ) {
			boolean res = listSubtree( root, depth, limitTs );
			if ( res )
				return true;
			long ts = android.os.SystemClock.uptimeMillis();
			if ( ts>limitTs )
				return false; // limited by time
			// iterate deeper
		}
		return false; // limited by depth
	}
	
	public FileInfo setSearchResults( FileInfo[] results ) {
		FileInfo existingResults = null;
		for ( int i=0; i<mRoot.dirCount(); i++ ) {
			FileInfo dir = mRoot.getDir(i);
			if ( dir.isSearchDir() ) {
				existingResults = dir;
				dir.clear();
				break;
			}
		}
		if ( existingResults==null ) {
			FileInfo dir = new FileInfo();
			dir.isDirectory = true;
			dir.pathname = FileInfo.SEARCH_RESULT_DIR_TAG;
			dir.filename = coolReader.getResources().getString(R.string.dir_search_results);
			dir.parent = mRoot;
			dir.isListed = true;
			dir.isScanned = true;
			mRoot.addDir(dir);
			existingResults = dir;
		}
		for ( FileInfo item : results )
			existingResults.addFile(item);
		return existingResults;
	}

	private void autoAddRoots( String rootPath, String[] pathsToExclude )
	{
		try {
			File root = new File(rootPath);
			File[] files = root.listFiles();
			if ( files!=null ) {
				for ( File f : files ) {
					if ( !f.isDirectory() )
						continue;
					String fullPath = f.getAbsolutePath();
					if ( engine.isLink(fullPath) ) {
						L.d(""skipping symlink "" + fullPath);
						continue;
					}
					boolean skip = false;
					for ( String path : pathsToExclude ) {
						if ( fullPath.startsWith(path) ) {
							skip = true;
							break;
						}
					}
					if ( skip )
						continue;
					if ( !f.canWrite() )
						continue;
					L.i(""Found possible mount point "" + f.getAbsolutePath());
					addRoot(f.getAbsolutePath(), f.getAbsolutePath(), true);
				}
			}
		} catch ( Exception e ) {
			L.w(""Exception while trying to auto add roots"");
		}
	}
	
	public void initRoots()
	{
		mRoot.clear();
		// create recent books dir
		addRoot( FileInfo.RECENT_DIR_TAG, R.string.dir_recent_books, false);
		String sdpath = Environment.getExternalStorageDirectory().getAbsolutePath();
		if ( ""/nand"".equals(sdpath) && new File(""/sdcard"").isDirectory() )
			sdpath = ""/sdcard"";
		addRoot( sdpath, R.string.dir_sd_card, true);
		// internal SD card on Nook
		addRoot( ""/system/media/sdcard"", R.string.dir_internal_sd_card, true);
		// internal memory
		addRoot( ""/media"", R.string.dir_internal_memory, true);
		addRoot( ""/nand"", R.string.dir_internal_memory, true);
		// internal SD card on PocketBook 701 IQ
		addRoot( ""/PocketBook701"", R.string.dir_internal_sd_card, true);
		// external SD
		addRoot( ""/mnt/extsd"", ""External SD /mnt/extsd"", true);
		// external SD card Huawei S7
		addRoot( ""/sdcard2"", R.string.dir_sd_card_2, true);
		//addRoot( ""/mnt/localdisk"", ""/mnt/localdisk"", true);
		autoAddRoots( ""/"", SYSTEM_ROOT_PATHS );
		autoAddRoots( ""/mnt"", new String[] {} );
		
		addOPDSRoot();
	}
	
	public boolean autoAddRootForFile( File f ) {
		File p = f.getParentFile();
		while ( p!=null ) {
			if ( p.getParentFile()==null || p.getParentFile().getParentFile()==null )
				break;
			p = p.getParentFile();
		}
		if ( p!=null ) {
			L.i(""Found possible mount point "" + p.getAbsolutePath());
			return addRoot(p.getAbsolutePath(), p.getAbsolutePath(), true);
		}
		return false;
	}
	
	private static final String[] SYSTEM_ROOT_PATHS = {""/system"", ""/data"", ""/mnt""};
	
//	public boolean scan()
//	{
//		L.i(""Started scanning"");
//		long start = System.currentTimeMillis();
//		mFileList.clear();
//		mFilesForParsing.clear();
//		mRoot.clear();
//		// create recent books dir
//		FileInfo recentDir = new FileInfo();
//		recentDir.isDirectory = true;
//		recentDir.pathname = ""@recent"";
//		recentDir.filename = ""Recent Books"";
//		mRoot.addDir(recentDir);
//		recentDir.parent = mRoot;
//		// scan directories
//		lastPercent = -1;
//		lastProgressUpdate = System.currentTimeMillis() - 500;
//		boolean res = scanDirectories( mRoot );
//		// process found files
//		lookupDB();
//		parseBookProperties();
//		updateProgress(9999);
//		L.i(""Finished scanning ("" + (System.currentTimeMillis()-start)+ "" ms)"");
//		return res;
//	}
	
	
	public FileInfo getDownloadDirectory() {
		for ( int i=0; i<mRoot.dirCount(); i++ ) {
			FileInfo item = mRoot.getDir(i);
			if ( !item.isSpecialDir() && !item.isArchive ) {
				FileInfo books = item.findItemByPathName(item.pathname+""/Books"");
				if ( books.exists() )
					return books;
				File dir = new File(item.getPathName());
				if ( dir.isDirectory() && dir.canWrite() ) {
					File f = new File( dir, ""Books"" );
					if ( f.mkdirs() ) {
						books = new FileInfo(f);
						books.parent = item;
						item.addDir(books);
						books.isScanned = true;
						books.isListed = true;
						return books;
					}
				}
			}
		}
		return null;
	}
	
	public FileInfo getRoot() 
	{
		return mRoot;
	}

	public FileInfo getOPDSRoot() 
	{
		for ( int i=0; i<mRoot.dirCount(); i++ ) {
			if ( mRoot.getDir(i).isOPDSRoot() )
				return mRoot.getDir(i);
		}
		L.w(""OPDS root directory not found!"");
		return null;
	}
	
	public Scanner( CoolReader coolReader, CRDB db, Engine engine )
	{
		this.engine = engine;
		this.db = db;
		this.coolReader = coolReader;
		mRoot = new FileInfo();
		mRoot.path = FileInfo.ROOT_DIR_TAG;	
		mRoot.filename = ""File Manager"";	
		mRoot.pathname = FileInfo.ROOT_DIR_TAG;
		mRoot.isListed = true;
		mRoot.isScanned = true;
		mRoot.isDirectory = true;
	}

	private final Engine engine;
	private final CRDB db;
	private final CoolReader coolReader;
}
",True,17,38,0,0,3,16,4,6,L1
22,org.coolreader.crengine.ReaderCallback.java,"package org.coolreader.crengine;

public interface ReaderCallback {
    /// on starting file loading
    void OnLoadFileStart( String filename );
    /// format detection finished
    String OnLoadFileFormatDetected( DocumentFormat fileFormat );
    /// file loading is finished successfully - drawCoveTo() may be called there
    void OnLoadFileEnd();
    /// first page is loaded from file an can be formatted for preview
    void OnLoadFileFirstPagesReady();
    /// file progress indicator, called with values 0..100
    boolean OnLoadFileProgress( int percent );
    /// document formatting started
    void OnFormatStart();
    /// document formatting finished
    void OnFormatEnd();
    /// format progress, called with values 0..100
    boolean OnFormatProgress( int percent );
    /// format progress, called with values 0..100
    boolean OnExportProgress( int percent );
    /// file load finiished with error
    void OnLoadFileError( String message );
    /// Override to handle external links
    void OnExternalLink( String url, String nodeXPath );
    /// Override to handle external links
    void OnImageCacheClear();
}
",False,22,27,4,12,1,1,1,1,L2
23,org.coolreader.crengine.ColorPickerDialog.java,"package org.coolreader.crengine;

// based on color picker from 
// http://www.anddev.org/announce_color_picker_dialog-t10771.html

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.res.Resources;
import android.content.res.Resources.NotFoundException;
import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.BitmapFactory;
import android.graphics.BlurMaskFilter;
import android.graphics.BlurMaskFilter.Blur;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.ColorFilter;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.PixelFormat;
import android.graphics.PorterDuff.Mode;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.GradientDrawable;
import android.graphics.drawable.LayerDrawable;
import android.os.SystemClock;
import android.util.StateSet;
import android.view.LayoutInflater;
import android.view.View;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Transformation;
import android.widget.SeekBar;
import android.widget.SeekBar.OnSeekBarChangeListener;
import android.widget.TextView;

public class ColorPickerDialog extends BaseDialog implements OnSeekBarChangeListener {

    public interface OnColorChangedListener {
        public void colorChanged(int color);
    }

	private SeekBar mR;
	private SeekBar mG;
	private SeekBar mB;
	private SeekBar mHue;
	private SeekBar mSaturation;
	private SeekBar mValue;
	private TextView mLabel;
	private OnColorChangedListener mListener;
	private int mColor;
	private GradientDrawable mPreviewDrawable;

	public ColorPickerDialog(CoolReader activity, OnColorChangedListener listener, int color, String title) {
		super(activity, R.string.dlg_button_ok, R.string.dlg_button_cancel, true);
		mListener = listener;

		Resources res = activity.getResources();
		setTitle(title);
		View root = LayoutInflater.from(activity).inflate(R.layout.color_picker, null);
		setView(root);
		
		View preview = root.findViewById(R.id.preview);
		mPreviewDrawable = new GradientDrawable();
		// 2 pix more than color_picker_frame's radius
		mPreviewDrawable.setCornerRadius(7);
		Drawable[] layers;
		layers = new Drawable[] {
				mPreviewDrawable,
				res.getDrawable(R.drawable.color_picker_frame),
		};
		preview.setBackgroundDrawable(new LayerDrawable(layers));
		
		mR = (SeekBar) root.findViewById(R.id.r);
		mG = (SeekBar) root.findViewById(R.id.g);
		mB = (SeekBar) root.findViewById(R.id.b);
		mHue = (SeekBar) root.findViewById(R.id.hue);
		mSaturation = (SeekBar) root.findViewById(R.id.saturation);
		mValue = (SeekBar) root.findViewById(R.id.value);
		mLabel = (TextView) root.findViewById(R.id.value_label);
		
		mColor = color;
		int r = Color.red(mColor);
		int g = Color.green(mColor);
		int b = Color.blue(mColor);
		float[] hsv = new float[3];
		Color.colorToHSV(color, hsv);
		int h = (int) (hsv[0] * mHue.getMax() / 360);
		int s = (int) (hsv[1] * mSaturation.getMax());
		int v = (int) (hsv[2] * mValue.getMax());
		setupSeekBar(mR, R.string.options_color_r, r, res);
		setupSeekBar(mG, R.string.options_color_g, g, res);
		setupSeekBar(mB, R.string.options_color_b, b, res);
		setupSeekBar(mHue, R.string.options_color_hue, h, res);
		setupSeekBar(mSaturation, R.string.options_color_saturation, s, res);
		setupSeekBar(mValue, R.string.options_color_brightness, v, res);
		
		updatePreview(color);
	}
	
	private void setupSeekBar(SeekBar seekBar, int id, int value, Resources res) {
		seekBar.setProgressDrawable(new TextSeekBarDrawable(res, id, value < seekBar.getMax() / 2));
		seekBar.setProgress(value);
		seekBar.setOnSeekBarChangeListener(this);
	}

	private void updateHSV() {
		float[] hsv = {
			360 * mHue.getProgress() / (float) mHue.getMax(),
			mSaturation.getProgress() / (float) mSaturation.getMax(),
			mValue.getProgress() / (float) mValue.getMax(),
		};
		mColor = Color.HSVToColor(hsv);
		mR.setProgress(Color.red(mColor));
		mG.setProgress(Color.green(mColor));
		mB.setProgress(Color.blue(mColor));
		updatePreview(mColor);
	}
	
	private void updateRGB() {
		mColor = Color.rgb(mR.getProgress(), mG.getProgress(), mB.getProgress());
		float[] hsv = new float[3];
		Color.colorToHSV(mColor, hsv);
		int h = (int) (hsv[0] * mHue.getMax() / 360);
		int s = (int) (hsv[1] * mSaturation.getMax());
		int v = (int) (hsv[2] * mValue.getMax());
		mHue.setProgress(h);
		mSaturation.setProgress(s);
		mValue.setProgress(v);
		updatePreview(mColor);
	}
	
	private static String byteToHex(int n) {
		String s = Integer.toHexString(n & 255);
		if (s.length()<2)
			s = ""0"" + s;
		return s;
	}
	private static String colorToHex(int n) {
		return (""#"" + byteToHex(Color.red(n))
			 + byteToHex(Color.green(n))
			 + byteToHex(Color.blue(n))).toUpperCase();
	}
	private void updatePreview(int color) {
		mPreviewDrawable.setColor(color);
		mPreviewDrawable.invalidateSelf();
		mLabel.setText(colorToHex(mColor));
	}

	public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
		if ( fromUser ) {
			if ( seekBar==mR || seekBar==mG || seekBar==mB )
				updateRGB();
			else
				updateHSV();
		}
	}

	public void onStartTrackingTouch(SeekBar seekBar) {
	}

	public void onStopTrackingTouch(SeekBar seekBar) {
	}

	@Override
	protected void onPositiveButtonClick() {
		mListener.colorChanged(mColor);
		super.onPositiveButtonClick();
	}

	static class IconPreviewDrawable extends Drawable {
		private Bitmap mBitmap;
		private Bitmap mTmpBitmap;
		private Canvas mTmpCanvas;
		private int mTintColor;
		

		public IconPreviewDrawable(Resources res, int id) {
			Bitmap b;
			try {
				b = BitmapFactory.decodeResource(res, id);
				if (b == null) {
					b = BitmapFactory.decodeResource(res, R.drawable.color_picker_icon);
				}
			} catch (NotFoundException e) {
				b = BitmapFactory.decodeResource(res, R.drawable.color_picker_icon);
			}
			mBitmap = b;
			mTmpBitmap = Bitmap.createBitmap(b.getWidth(), b.getHeight(), Config.ARGB_8888);
			mTmpCanvas = new Canvas(mTmpBitmap);
		}
		
		@Override
		public void draw(Canvas canvas) {
			Rect b = getBounds();
			float x = (b.width() - mBitmap.getWidth()) / 2.0f;
			float y = 0.75f * b.height() - mBitmap.getHeight() / 2.0f;
			
			mTmpCanvas.drawColor(0, Mode.CLEAR);
			mTmpCanvas.drawBitmap(mBitmap, 0, 0, null);
			mTmpCanvas.drawColor(mTintColor, Mode.SRC_ATOP);
			canvas.drawBitmap(mTmpBitmap, x, y, null);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}
		
		@Override
		public void setColorFilter(int color, Mode mode) {
			mTintColor = color;
		}
	}
	
	static final int[] STATE_FOCUSED = {android.R.attr.state_focused};
	static final int[] STATE_PRESSED = {android.R.attr.state_pressed};
	
	static class TextSeekBarDrawable extends Drawable implements Runnable {
		
		private static final String TAG = ""TextSeekBarDrawable"";
		private static final long DELAY = 50;
		private String mText;
		private Drawable mProgress;
		private Paint mPaint;
		private Paint mOutlinePaint;
		private float mTextWidth;
		private boolean mActive;
		private float mTextXScale;
		private int mDelta;
		private ScrollAnimation mAnimation;

		public TextSeekBarDrawable(Resources res, int id, boolean labelOnRight) {
			mText = res.getString(id);
			mProgress = res.getDrawable(android.R.drawable.progress_horizontal);
			mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
			mPaint.setTypeface(Typeface.DEFAULT_BOLD);
			mPaint.setTextSize(16);
			mPaint.setColor(0xff000000);
			mOutlinePaint = new Paint(mPaint);
			mOutlinePaint.setStyle(Style.STROKE);
			mOutlinePaint.setStrokeWidth(3);
			mOutlinePaint.setColor(0xbbffc300);
			mOutlinePaint.setMaskFilter(new BlurMaskFilter(1, Blur.NORMAL));
			mTextWidth = mOutlinePaint.measureText(mText);
			mTextXScale = labelOnRight? 1 : 0;
			mAnimation = new ScrollAnimation();
		}

		@Override
		protected void onBoundsChange(Rect bounds) {
			mProgress.setBounds(bounds);
		}
		
		@Override
		protected boolean onStateChange(int[] state) {
			mActive = StateSet.stateSetMatches(STATE_FOCUSED, state) | StateSet.stateSetMatches(STATE_PRESSED, state);
			invalidateSelf();
			return false;
		}
		
		@Override
		public boolean isStateful() {
			return true;
		}
		
		@Override
		protected boolean onLevelChange(int level) {
//			Log.d(TAG, ""onLevelChange "" + level);
			if (level < 4000 && mDelta <= 0) {
//				Log.d(TAG, ""onLevelChange scheduleSelf ++"");
				mDelta = 1;
				mAnimation.startScrolling(mTextXScale, 1);
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			} else
			if (level > 6000 && mDelta >= 0) {
//				Log.d(TAG, ""onLevelChange scheduleSelf --"");
				mDelta = -1;
				mAnimation.startScrolling(mTextXScale, 0);
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			}
			return mProgress.setLevel(level);
		}
		
		@Override
		public void draw(Canvas canvas) {
			mProgress.draw(canvas);

			if (mAnimation.hasStarted() && !mAnimation.hasEnded()) {
				// pending animation
				mAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), null);
				mTextXScale = mAnimation.getCurrent();
//				Log.d(TAG, ""draw "" + mTextX + "" "" + SystemClock.uptimeMillis());
			}
			
			Rect bounds = getBounds();
			float x = 6 + mTextXScale * (bounds.width() - mTextWidth - 6 - 6);
			float y = (bounds.height() + mPaint.getTextSize()) / 2;
			mOutlinePaint.setAlpha(mActive? 255 : 255 / 2);
			mPaint.setAlpha(mActive? 255 : 255 / 2);
			canvas.drawText(mText, x, y, mOutlinePaint);
			canvas.drawText(mText, x, y, mPaint);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}

		public void run() {
			mAnimation.getTransformation(AnimationUtils.currentAnimationTimeMillis(), null);
			// close interpolation of mTextX
			mTextXScale = mAnimation.getCurrent();
			if (!mAnimation.hasEnded()) {
				scheduleSelf(this, SystemClock.uptimeMillis() + DELAY);
			}
			invalidateSelf();
//			Log.d(TAG, ""run "" + mTextX + "" "" + SystemClock.uptimeMillis());
		}
	}
	
	static class ScrollAnimation extends Animation {
		private static final String TAG = ""ScrollAnimation"";
		private static final long DURATION = 750;
		private float mFrom;
		private float mTo;
		private float mCurrent;
		
		public ScrollAnimation() {
			setDuration(DURATION);
			setInterpolator(new DecelerateInterpolator());
		}
		
		public void startScrolling(float from, float to) {
			mFrom = from;
			mTo = to;
			startNow();
		}
		
		@Override
		protected void applyTransformation(float interpolatedTime, Transformation t) {
			mCurrent = mFrom + (mTo - mFrom) * interpolatedTime;
//			Log.d(TAG, ""applyTransformation "" + mCurrent);
		}
		
		public float getCurrent() {
			return mCurrent;
		}
	}
}
",False,2,38,0,0,3,19,1,2,L1
24,org.coolreader.crengine.TTS.java,"package org.coolreader.crengine;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.HashMap;
import java.util.Locale;

import android.content.Context;

/**
 * Wrapper for android.speech.tts.TextToSpeech
 * 
 * For compatibility with Android 1.5
 */
public class TTS {
	
	public static final Logger log = L.create(""tts"");
	
	// constants from TextToSpeech
	public final static String	ACTION_TTS_QUEUE_PROCESSING_COMPLETED=""android.speech.tts.TTS_QUEUE_PROCESSING_COMPLETED"";	//Broadcast Action: The TextToSpeech synthesizer has completed processing of all the text in the speech queue.
	public final static int	ERROR=1;	//Denotes a generic operation failure.
	public final static int	LANG_AVAILABLE=0;	//Denotes the language is available for the language by the locale, but not the country and variant.
	public final static int	LANG_COUNTRY_AVAILABLE=1;	//Denotes the language is available for the language and country specified by the locale, but not the variant.
	public final static int	LANG_COUNTRY_VAR_AVAILABLE=2;	//Denotes the language is available exactly as specified by the locale.
	public final static int	LANG_MISSING_DATA=-1;	//Denotes the language data is missing.
	public final static int	LANG_NOT_SUPPORTED=-2;	//Denotes the language is not supported.
	public final static int	QUEUE_ADD=1;	//Queue mode where the new entry is added at the end of the playback queue.
	public final static int	QUEUE_FLUSH=0;	//Queue mode where all entries in the playback queue (media to be played and text to be synthesized) are dropped and replaced by the new entry.
	public final static int	SUCCESS=0;  //Denotes a successful operation.
	
	private static Class<?> textToSpeechClass;
	private static Constructor<?> textToSpeech_constructor;
	private static Class<?> onInitListenerClass;
	//private static Method onInitListener_onInit; //	void onInit(int status)
	private static Class<?> onUtteranceCompletedListenerClass;
	//private static Method onUtteranceCompletedListener_onUtteranceCompleted;
	
	private static Method textToSpeech_addEarcon; //int addEarcon(String earcon, String filename); // Adds a mapping between a string of text and a sound file.
	private static Method textToSpeech_addEarcon2; //int 	addEarcon(String earcon, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
	private static Method textToSpeech_addSpeech; //int 	addSpeech(String text, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
	private static Method textToSpeech_addSpeech2; //int 	addSpeech(String text, String filename); //Adds a mapping between a string of text and a sound file.
	private static Method textToSpeech_areDefaultsEnforced; //boolean 	areDefaultsEnforced(); // Returns whether or not the user is forcing their defaults to override the Text-To-Speech settings set by applications.
	private static Method textToSpeech_getDefaultEngine; //String 	getDefaultEngine(); // Gets the packagename of the default speech synthesis engine.
	private static Method textToSpeech_getLanguage; //Locale 	getLanguage(); // Returns a Locale instance describing the language currently being used by the TextToSpeech engine.
	private static Method textToSpeech_isLanguageAvailable; //int 	isLanguageAvailable(Locale loc); // Checks if the specified language as represented by the Locale is available and supported.
	private static Method textToSpeech_isSpeaking; //boolean isSpeaking(); // Returns whether or not the TextToSpeech engine is busy speaking.
	private static Method textToSpeech_playEarcon; //int 	playEarcon(String earcon, int queueMode, HashMap<String, String> params); // Plays the earcon using the specified queueing mode and parameters.
	private static Method textToSpeech_playSilence; //int 	playSilence(long durationInMs, int queueMode, HashMap<String, String> params); // Plays silence for the specified amount of time using the specified queue mode.
	private static Method textToSpeech_setEngineByPackageName; //int 	setEngineByPackageName(String enginePackageName); // Sets the speech synthesis engine to be used by its packagename.
	private static Method textToSpeech_setLanguage; //int 	setLanguage(Locale loc); // Sets the language for the TextToSpeech engine.
	private static Method textToSpeech_setOnUtteranceCompletedListener; //int 	setOnUtteranceCompletedListener(TextToSpeech.OnUtteranceCompletedListener listener); // Sets the OnUtteranceCompletedListener that will fire when an utterance completes.
	private static Method textToSpeech_setPitch; //int 	setPitch(float pitch); // Sets the speech pitch for the TextToSpeech engine.
	private static Method textToSpeech_setSpeechRate; //int 	setSpeechRate(float speechRate); // Sets the speech rate for the TextToSpeech engine.
	private static Method textToSpeech_shutdown; //void 	shutdown() ; // Releases the resources used by the TextToSpeech engine.
	private static Method textToSpeech_speak; //int 	speak(String text, int queueMode, HashMap<String, String> params); // Speaks the string using the specified queuing strategy and speech parameters.
	private static Method textToSpeech_stop; //int 	stop() ; // Interrupts the current utterance (whether played or rendered to file) and discards other utterances in the queue.
	private static Method textToSpeech_synthesizeToFile; //int 	synthesizeToFile(String text, HashMap<String, String> params, String filename); // Synthesizes the given text to a file using the specified parameters.

	private Object tts;
	private boolean initialized;
	
	/**
	 * @param listener is listener to call on init finished
	 * @return proxy
	 */
	private Object createOnInitProxy( final OnInitListener listener ) {
		InvocationHandler handler = new InvocationHandler() {

			@Override
			public Object invoke(Object proxy, Method method, Object[] args)
					throws Throwable {
                log.d(""invoking OnInit - "" + method.getName());
				if ( ""onInit"".equals(method.getName()) ) {
					int status = (Integer)(args[0]);
					log.i(""OnInitListener.onInit() is called: status="" + status);
					if ( status==SUCCESS )
						initialized = true;
					listener.onInit(status);
				}
				return null;
			}
			
		};
		return Proxy.newProxyInstance(
				onInitListenerClass.getClassLoader(),
		        new Class[] { onInitListenerClass },
		        handler);		
	}
	
	/**
	 * @param listener is listener to call on init finished
	 * @return proxy
	 */
	private Object createOnUtteranceCompletedListener( final OnUtteranceCompletedListener listener ) {
		InvocationHandler handler = new InvocationHandler() {

			@Override
			public Object invoke(Object proxy, Method method, Object[] args)
					throws Throwable {
				log.d(""invoking OnUtteranceCompletedListener - "" + method.getName());
                if ( ""onUtteranceCompleted"".equals(method.getName()) ) {
					String id = (String)(args[0]);
					log.d(""OnUtteranceCompletedListener.onUtteranceCompleted() is called: id="" + id);
					listener.onUtteranceCompleted(id);
				}
				return null;
			}
			
		};
		return Proxy.newProxyInstance(
				onUtteranceCompletedListenerClass.getClassLoader(),
		        new Class[] { onUtteranceCompletedListenerClass },
		        handler);		
	}
	
	private static boolean classesFound;
	static {
		try {
			onInitListenerClass = Class.forName(""android.speech.tts.TextToSpeech$OnInitListener"");
			//onInitListener_onInit = onInitListenerClass.getMethod(""onInit"", new Class[] {int.class});
			onUtteranceCompletedListenerClass = Class.forName(""android.speech.tts.TextToSpeech$OnUtteranceCompletedListener"");
			//onUtteranceCompletedListener_onUtteranceCompleted = onUtteranceCompletedListenerClass.getMethod(""onUtteranceCompleted"", new Class[] {String.class});
			textToSpeechClass = Class.forName(""android.speech.tts.TextToSpeech"");
			textToSpeech_constructor = textToSpeechClass.getConstructor(new Class[] {Context.class, onInitListenerClass}); 
			textToSpeech_addEarcon = textToSpeechClass.getMethod(""addEarcon"", new Class[] {String.class, String.class}); //int addEarcon(String earcon, String filename); // Adds a mapping between a string of text and a sound file.
			textToSpeech_addEarcon2 = textToSpeechClass.getMethod(""addEarcon"", new Class[] {String.class, String.class, int.class}); //int 	addEarcon(String earcon, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
			textToSpeech_addSpeech = textToSpeechClass.getMethod(""addSpeech"", new Class[] {String.class, String.class, int.class}); //int 	addSpeech(String text, String packagename, int resourceId); // Adds a mapping between a string of text and a sound resource in a package.
			textToSpeech_addSpeech2 = textToSpeechClass.getMethod(""addSpeech"", new Class[] {String.class, String.class}); //int 	addSpeech(String text, String filename); //Adds a mapping between a string of text and a sound file.
			textToSpeech_areDefaultsEnforced = textToSpeechClass.getMethod(""areDefaultsEnforced"", new Class[] {}); //boolean 	areDefaultsEnforced(); // Returns whether or not the user is forcing their defaults to override the Text-To-Speech settings set by applications.
			textToSpeech_getDefaultEngine = textToSpeechClass.getMethod(""getDefaultEngine"", new Class[] {}); //String 	getDefaultEngine(); // Gets the packagename of the default speech synthesis engine.
			textToSpeech_getLanguage = textToSpeechClass.getMethod(""getLanguage"", new Class[] {}); //Locale 	getLanguage(); // Returns a Locale instance describing the language currently being used by the TextToSpeech engine.
			textToSpeech_isLanguageAvailable = textToSpeechClass.getMethod(""isLanguageAvailable"", new Class[] {Locale.class}); //int 	isLanguageAvailable(Locale loc); // Checks if the specified language as represented by the Locale is available and supported.
			textToSpeech_isSpeaking = textToSpeechClass.getMethod(""isSpeaking"", new Class[] {}); //boolean isSpeaking(); // Returns whether or not the TextToSpeech engine is busy speaking.
			textToSpeech_playEarcon = textToSpeechClass.getMethod(""playEarcon"", new Class[] {String.class, int.class, HashMap.class}); //int 	playEarcon(String earcon, int queueMode, HashMap<String, String> params); // Plays the earcon using the specified queueing mode and parameters.
			textToSpeech_playSilence = textToSpeechClass.getMethod(""playSilence"", new Class[] {long.class, int.class, HashMap.class}); //int 	playSilence(long durationInMs, int queueMode, HashMap<String, String> params); // Plays silence for the specified amount of time using the specified queue mode.
			textToSpeech_setEngineByPackageName = textToSpeechClass.getMethod(""setEngineByPackageName"", new Class[] {String.class}); //int 	setEngineByPackageName(String enginePackageName); // Sets the speech synthesis engine to be used by its packagename.
			textToSpeech_setLanguage = textToSpeechClass.getMethod(""setLanguage"", new Class[] {Locale.class}); //int 	setLanguage(Locale loc); // Sets the language for the TextToSpeech engine.
			textToSpeech_setOnUtteranceCompletedListener = textToSpeechClass.getMethod(""setOnUtteranceCompletedListener"", new Class[] {onUtteranceCompletedListenerClass}); //int 	setOnUtteranceCompletedListener(TextToSpeech.OnUtteranceCompletedListener listener); // Sets the OnUtteranceCompletedListener that will fire when an utterance completes.
			textToSpeech_setPitch = textToSpeechClass.getMethod(""setPitch"", new Class[] {float.class}); //int 	setPitch(float pitch); // Sets the speech pitch for the TextToSpeech engine.
			textToSpeech_setSpeechRate = textToSpeechClass.getMethod(""setSpeechRate"", new Class[] {float.class}); //int 	setSpeechRate(float speechRate); // Sets the speech rate for the TextToSpeech engine.
			textToSpeech_shutdown = textToSpeechClass.getMethod(""shutdown"", new Class[] {}); //void 	shutdown() ; // Releases the resources used by the TextToSpeech engine.
			textToSpeech_speak = textToSpeechClass.getMethod(""speak"", new Class[] {String.class, int.class, HashMap.class}); //int 	speak(String text, int queueMode, HashMap<String, String> params); // Speaks the string using the specified queuing strategy and speech parameters.
			textToSpeech_stop = textToSpeechClass.getMethod(""stop"", new Class[] {}); //int 	stop() ; // Interrupts the current utterance (whether played or rendered to file) and discards other utterances in the queue.
			textToSpeech_synthesizeToFile = textToSpeechClass.getMethod(""synthesizeToFile"", new Class[] {String.class, HashMap.class, String.class}); //int 	synthesizeToFile(String text, HashMap<String, String> params, String filename); // Synthesizes the given text to a file using the specified parameters.
			classesFound = true;
			L.i(""TTS classes initialized successfully"");
		} catch ( Exception e ) {
			L.e(""Exception while initializing TTS classes: tts will be disabled"", e);
			classesFound = false;
		}
	}
	
	public interface OnInitListener {
		void onInit(int status);
	}
	
	public interface OnUtteranceCompletedListener {
		/**
		 * Called to signal the completion of the synthesis of the utterance that was identified with the string parameter.
		 * @param utteranceId
		 */
		void 	onUtteranceCompleted(String utteranceId);
	}
	
	public interface OnTTSCreatedListener {
		void onCreated(TTS tts);
	}
	

	public TTS(Context context, OnInitListener listener ) {
		if ( !classesFound ) {
			L.e(""Cannot create TTS object : TTS classes not initialized"");
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		}
		try {
			tts = textToSpeech_constructor.newInstance(context, createOnInitProxy(listener));
			L.i(""TTS object created successfully"");
	    	setOnUtteranceCompletedListener(new TTS.OnUtteranceCompletedListener() {
				
				@Override
				public void onUtteranceCompleted(String utteranceId) {
					L.i(""TTS utterance completed: "" + utteranceId);
					// TODO
				}
			});
		} catch ( InvocationTargetException e ) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		} catch (IllegalArgumentException e) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		} catch (InstantiationException e) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		} catch (IllegalAccessException e) {
			classesFound = false;
			L.e(""Cannot create TTS object"", e);
			throw new IllegalStateException(""Cannot instanciate TextToSpeech"");
		}
	}

	// Adds a mapping between a string of text and a sound file.
	public int addEarcon(String earcon, String filename) {
		try {
			return (Integer)textToSpeech_addEarcon.invoke(tts, earcon, filename);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	
	// Adds a mapping between a string of text and a sound resource in a package.
	public int 	addEarcon(String earcon, String packagename, int resourceId) {
		try {
			return (Integer)textToSpeech_addEarcon2.invoke(tts, packagename, resourceId);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	
	// Adds a mapping between a string of text and a sound resource in a package.
	public int 	addSpeech(String text, String packagename, int resourceId) {
		try {
			return (Integer)textToSpeech_addSpeech.invoke(tts, text, packagename, resourceId);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	//Adds a mapping between a string of text and a sound file.
	public int 	addSpeech(String text, String filename) {
		try {
			return (Integer)textToSpeech_addSpeech2.invoke(tts, text, filename);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Returns whether or not the user is forcing their defaults to override the Text-To-Speech settings set by applications.
	public boolean areDefaultsEnforced() {
		try {
			return (Boolean)textToSpeech_areDefaultsEnforced.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Gets the packagename of the default speech synthesis engine.
	public String 	getDefaultEngine() {
		try {
			return (String)textToSpeech_getDefaultEngine.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Returns a Locale instance describing the language currently being used by the TextToSpeech engine.
	public Locale 	getLanguage() {
		try {
			return (Locale)textToSpeech_getLanguage.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Checks if the specified language as represented by the Locale is available and supported.
	public int 	isLanguageAvailable(Locale loc) {
		try {
			return (Integer)textToSpeech_isLanguageAvailable.invoke(tts, loc);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Returns whether or not the TextToSpeech engine is busy speaking.
	public boolean isSpeaking() {
		try {
			return (Boolean)textToSpeech_isSpeaking.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Plays the earcon using the specified queueing mode and parameters.
	public int playEarcon(String earcon, int queueMode, HashMap<String, String> params) {
		try {
			return (Integer)textToSpeech_playEarcon.invoke(tts, earcon, queueMode, params);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Plays silence for the specified amount of time using the specified queue mode.
	public int 	playSilence(long durationInMs, int queueMode, HashMap<String, String> params) {
		try {
			return (Integer)textToSpeech_playSilence.invoke(tts, durationInMs, queueMode, params);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the speech synthesis engine to be used by its packagename.
	public int setEngineByPackageName(String enginePackageName) {
		try {
			return (Integer)textToSpeech_setEngineByPackageName.invoke(tts, enginePackageName);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the language for the TextToSpeech engine.
	public int setLanguage(Locale loc) {
		try {
			return (Integer)textToSpeech_setLanguage.invoke(tts, loc);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the OnUtteranceCompletedListener that will fire when an utterance completes.
	public int setOnUtteranceCompletedListener(OnUtteranceCompletedListener listener) {
		try {
			return (Integer)textToSpeech_setOnUtteranceCompletedListener.invoke(tts, createOnUtteranceCompletedListener(listener));
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the speech pitch for the TextToSpeech engine.
	public int 	setPitch(float pitch) {
		try {
			return (Integer)textToSpeech_setPitch.invoke(tts, pitch);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Sets the speech rate for the TextToSpeech engine.
	public int 	setSpeechRate(float speechRate) {
		try {
			return (Integer)textToSpeech_setSpeechRate.invoke(tts, speechRate);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}

	// Releases the resources used by the TextToSpeech engine.
	public void shutdown() {
		if ( tts!=null && initialized )
		try {
			initialized = false;
			textToSpeech_shutdown.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}

	// Speaks the string using the specified queuing strategy and speech parameters.
	public int speak(String text, int queueMode, HashMap<String, String> params) {
        try {
            L.v(""speak("" + text + "")"");
            int res = (Integer) textToSpeech_speak.invoke(tts, text, queueMode,
                    params);
            L.v(""speak() returned "" + res);
            return res;
        } catch (Exception e) {
            L.e(""Exception while calling tts"", e);
            throw new IllegalStateException(e);
        }
	}
	// Interrupts the current utterance (whether played or rendered to file) and discards other utterances in the queue.
	public int 	stop() {
		try {
			return (Integer)textToSpeech_stop.invoke(tts);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	// Synthesizes the given text to a file using the specified parameters.
	public int 	synthesizeToFile(String text, HashMap<String, String> params, String filename) {
		try {
			return (Integer)textToSpeech_synthesizeToFile.invoke(tts, text, params, filename);
		} catch ( Exception e ) {
			L.e(""Exception while calling tts"", e);
			throw new IllegalStateException(e);
		}
	}
	
	public boolean isInitialized() {
		return false;
	}
	
	public static boolean isFound() {
		return classesFound;
	}
}
",True,6,38,0,0,5,25,3,2,L1
25,org.coolreader.crengine.BookInfoDialog.java,"package org.coolreader.crengine;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.TabHost.TabContentFactory;
import android.widget.TableLayout;
import android.widget.TableLayout.LayoutParams;
import android.widget.TableRow;
import android.widget.TextView;

public class BookInfoDialog extends BaseDialog {
	private final CoolReader mCoolReader;
	private final LayoutInflater mInflater; 
	private Map<String, Integer> mLabelMap;
	private void fillMap() {
		mLabelMap = new HashMap<String, Integer>();
		mLabelMap.put(""section.system"", R.string.book_info_section_system);
		mLabelMap.put(""system.version"", R.string.book_info_system_version);
		mLabelMap.put(""system.battery"", R.string.book_info_system_battery);
		mLabelMap.put(""system.time"", R.string.book_info_system_time);
		mLabelMap.put(""section.file"", R.string.book_info_section_file_properties);
		mLabelMap.put(""file.name"", R.string.book_info_file_name);
		mLabelMap.put(""file.path"", R.string.book_info_file_path);
		mLabelMap.put(""file.arcname"", R.string.book_info_file_arcname);
		mLabelMap.put(""file.arcpath"", R.string.book_info_file_arcpath);
		mLabelMap.put(""file.arcsize"", R.string.book_info_file_arcsize);
		mLabelMap.put(""file.size"", R.string.book_info_file_size);
		mLabelMap.put(""file.format"", R.string.book_info_file_format);
		mLabelMap.put(""section.position"", R.string.book_info_section_current_position);
		mLabelMap.put(""position.percent"", R.string.book_info_position_percent);
		mLabelMap.put(""position.page"", R.string.book_info_position_page);
		mLabelMap.put(""position.chapter"", R.string.book_info_position_chapter);
		mLabelMap.put(""section.book"", R.string.book_info_section_book_properties);
		mLabelMap.put(""book.authors"", R.string.book_info_book_authors);
		mLabelMap.put(""book.title"", R.string.book_info_book_title);
		mLabelMap.put(""book.series"", R.string.book_info_book_series_name);
	}
	
	private void addItem(TableLayout table, String item) {
		int p = item.indexOf(""="");
		if ( p<0 )
			return;
		String name = item.substring(0, p).trim();
		String value = item.substring(p+1).trim();
		if ( name.length()==0 || value.length()==0 )
			return;
		boolean isSection = false;
		if ( ""section"".equals(name) ) {
			name = """";
			Integer id = mLabelMap.get(value);
			if ( id==null )
				return;
			String section = getContext().getString(id);
			if ( section!=null )
				value = section;
			isSection = true;
		} else {
			Integer id = mLabelMap.get(name);
			String title = id!=null ? getContext().getString(id) : name;
			if ( title!=null )
				name = title;
		}
		TableRow tableRow = (TableRow)mInflater.inflate(isSection ? R.layout.book_info_section : R.layout.book_info_item, null);
		TextView nameView = (TextView)tableRow.findViewById(R.id.name);
		TextView valueView = (TextView)tableRow.findViewById(R.id.value);
		nameView.setText(name);
		valueView.setText(value);
		table.addView(tableRow);
	}
	
	public BookInfoDialog( CoolReader activity, Collection<String> items)
	{
		super(activity, 0, 0, false);
		mCoolReader = activity;
		setTitle(mCoolReader.getString(R.string.dlg_book_info));
		fillMap();
		mInflater = LayoutInflater.from(getContext());
		View view = mInflater.inflate(R.layout.book_info_dialog, null);
		TableLayout table = (TableLayout)view.findViewById(R.id.table);
		for ( String item : items ) {
			addItem(table, item);
		}
		setView( view );
	}

}
",False,3,38,0,0,3,19,1,2,L2
26,org.coolreader.crengine.Engine.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.app.AlertDialog;
import android.content.Context;
import android.graphics.drawable.Drawable;
import android.os.Environment;
import android.util.Log;

/**
 * CoolReader Engine class.
 * 
 * Only one instance is allowed.
 */
public class Engine {

	public static final Logger log = L.create(""en"");
	
	private final CoolReader mActivity;
	private final BackgroundThread mBackgroundThread;
	
	static final private String LIBRARY_NAME = ""cr3engine-45-15"";

	// private final View mMainView;
	// private final ExecutorService mExecutor =
	// Executors.newFixedThreadPool(1);

	/**
	 * Get storage root directories.
	 * 
	 * @return array of r/w storage roots
	 */
	public static File[] getStorageDirectories(boolean writableOnly) {
		ArrayList<File> res = new ArrayList<File>(2);
		File dir = Environment.getExternalStorageDirectory();
		if (dir.isDirectory() && (!writableOnly || dir.canWrite()))
			res.add(dir);
		File dir2 = new File(""/system/media/sdcard"");
		if (dir2.isDirectory() && (!writableOnly || dir2.canWrite()))
			res.add(dir2);
		File dir22 = new File(""/sdcard2"");
		if (dir22.isDirectory() && (!writableOnly || dir22.canWrite()))
			res.add(dir22);
		File dir3 = new File(""/nand"");
		if (dir3.isDirectory() && (!writableOnly || dir3.canWrite()))
			res.add(dir3);
		File dir4 = new File(""/PocketBook701"");
		if (dir4.isDirectory() && (!writableOnly || dir4.canWrite()))
			res.add(dir4);
		return res.toArray(new File[] {});
	}

	/**
	 * Get or create writable subdirectory for specified base directory
	 * 
	 * @param dir
	 *            is base directory
	 * @param subdir
	 *            is subdirectory name, null to use base directory
	 * @param createIfNotExists
	 *            is true to force directory creation
	 * @return writable directory, null if not exist or not writable
	 */
	public static File getSubdir(File dir, String subdir,
			boolean createIfNotExists, boolean writableOnly) {
		if (dir == null)
			return null;
		File dataDir = dir;
		if (subdir != null) {
			dataDir = new File(dataDir, subdir);
			if (!dataDir.isDirectory() && createIfNotExists)
				dataDir.mkdir();
		}
		if (dataDir.isDirectory() && (!writableOnly || dataDir.canWrite()))
			return dataDir;
		return null;
	}

	/**
	 * Returns array of writable data directories on external storage
	 * 
	 * @param subdir
	 * @param createIfNotExists
	 * @return
	 */
	public static File[] getDataDirectories(String subdir,
			boolean createIfNotExists, boolean writableOnly) {
		File[] roots = getStorageDirectories(writableOnly);
		ArrayList<File> res = new ArrayList<File>(roots.length);
		for (File dir : roots) {
			File dataDir = getSubdir(dir, "".cr3"", createIfNotExists,
					writableOnly);
			if (subdir != null)
				dataDir = getSubdir(dataDir, subdir, createIfNotExists,
						writableOnly);
			if (dataDir != null)
				res.add(dataDir);
		}
		return res.toArray(new File[] {});
	}

	public interface EngineTask {
		public void work() throws Exception;

		public void done();

		public void fail(Exception e);
	}

	// public static class FatalError extends RuntimeException {
	// private Engine engine;
	// private String msg;
	// public FatalError( Engine engine, String msg )
	// {
	// this.engine = engine;
	// this.msg = msg;
	// }
	// public void handle()
	// {
	// engine.fatalError(msg);
	// }
	// }

	public final static boolean LOG_ENGINE_TASKS = false;

	private class TaskHandler implements Runnable {
		final EngineTask task;

		public TaskHandler(EngineTask task) {
			this.task = task;
		}

		public String toString() {
			return ""[handler for "" + this.task.toString() + ""]"";
		}

		public void run() {
			try {
				if (LOG_ENGINE_TASKS)
					log.i(""running task.work() ""
							+ task.getClass().getName());
				if (!initialized)
					throw new IllegalStateException(""Engine not initialized"");
				// run task
				task.work();
				if (LOG_ENGINE_TASKS)
					log.i(""exited task.work() ""
							+ task.getClass().getName());
				// post success callback
				mBackgroundThread.postGUI(new Runnable() {
					public void run() {
						if (LOG_ENGINE_TASKS)
							log.i(""running task.done() ""
									+ task.getClass().getName()
									+ "" in gui thread"");
						task.done();
					}
				});
				// } catch ( final FatalError e ) {
				// TODO:
				// Handler h = view.getHandler();
				//
				// if ( h==null ) {
				// View root = view.getRootView();
				// h = root.getHandler();
				// }
				// if ( h==null ) {
				// //
				// e.handle();
				// } else {
				// h.postAtFrontOfQueue(new Runnable() {
				// public void run() {
				// e.handle();
				// }
				// });
				// }
			} catch (final Exception e) {
				log.e(""exception while running task ""
						+ task.getClass().getName(), e);
				// post error callback
				mBackgroundThread.postGUI(new Runnable() {
					public void run() {
						log.e(""running task.fail("" + e.getMessage()
								+ "") "" + task.getClass().getSimpleName()
								+ "" in gui thread "");
						task.fail(e);
					}
				});
			}
		}
	}

	/**
	 * Execute task in Engine thread
	 * 
	 * @param task
	 *            is task to execute
	 */
	public void execute(final EngineTask task) {
		if (LOG_ENGINE_TASKS)
			log.d(""executing task "" + task.getClass().getSimpleName());
		TaskHandler taskHandler = new TaskHandler(task);
		mBackgroundThread.executeBackground(taskHandler);
	}

	/**
	 * Schedule task for execution in Engine thread
	 * 
	 * @param task
	 *            is task to execute
	 */
	public void post(final EngineTask task) {
		if (LOG_ENGINE_TASKS)
			log.d(""executing task "" + task.getClass().getSimpleName());
		TaskHandler taskHandler = new TaskHandler(task);
		mBackgroundThread.postBackground(taskHandler);
	}

	/**
	 * Schedule Runnable for execution in GUI thread after all current Engine
	 * queue tasks done.
	 * 
	 * @param task
	 */
	public void runInGUI(final Runnable task) {
		execute(new EngineTask() {

			public void done() {
				mBackgroundThread.postGUI(task);
			}

			public void fail(Exception e) {
				// do nothing
			}

			public void work() throws Exception {
				// do nothing
			}
		});
	}

	public void fatalError(String msg) {
		AlertDialog dlg = new AlertDialog.Builder(mActivity).setMessage(msg)
				.setTitle(""CoolReader fatal error"").show();
		try {
			Thread.sleep(10);
		} catch (InterruptedException e) {
			// do nothing
		}
		dlg.dismiss();
		mActivity.finish();
	}

	private ProgressDialog mProgress;
	private boolean enable_progress = true;
	private boolean progressShown = false;
	private static int PROGRESS_STYLE = ProgressDialog.STYLE_HORIZONTAL;
	private Drawable progressIcon = null;

	// public void setProgressDrawable( final BitmapDrawable drawable )
	// {
	// if ( enable_progress ) {
	// mBackgroundThread.executeGUI( new Runnable() {
	// public void run() {
	// // show progress
	// log.v(""showProgress() - in GUI thread"");
	// if ( mProgress!=null && progressShown ) {
	// hideProgress();
	// progressIcon = drawable;
	// showProgress(mProgressPos, mProgressMessage);
	// //mProgress.setIcon(drawable);
	// }
	// }
	// });
	// }
	// }
	public void showProgress(final int mainProgress, final int resourceId) {
		showProgress(mainProgress,
				mActivity.getResources().getString(resourceId));
	}

	private String mProgressMessage = null;
	private int mProgressPos = 0;

	private volatile int nextProgressId = 0;

	public class DelayedProgress {
		private volatile boolean cancelled;
		private volatile boolean shown;

		/**
		 * Cancel scheduled progress.
		 */
		public void cancel() {
			cancelled = true;
		}
		/**
		 * Cancel and hide scheduled progress.
		 */
		public void hide() {
			this.cancelled = true;
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					if ( shown )
						hideProgress();
					shown = false;
				}
				
			});
		}

		DelayedProgress( final int percent, final String msg, final int delayMillis ) {
			this.cancelled = false;
			BackgroundThread.instance().postGUI(new Runnable() {
				@Override
				public void run() {
					if ( !cancelled ) {
						showProgress( percent, msg );
						shown = true;
					}
				}
				
			}, delayMillis);
		}
	}
	
	/**
	 * Display progress dialog after delay.
	 * (thread-safe)
	 * @param mainProgress is percent*100
	 * @param msg is progress message text
	 * @param delayMillis is delay before display of progress
	 * @return DelayedProgress object which can be use to hide or cancel this schedule
	 */
	public DelayedProgress showProgressDelayed(final int mainProgress, final String msg, final int delayMillis ) {
		return new DelayedProgress(mainProgress, msg, delayMillis);
	}
	
	/**
	 * Show progress dialog.
	 * (thread-safe)
	 * @param mainProgress is percent*100
	 * @param msg is progress message
	 */
	public void showProgress(final int mainProgress, final String msg) {
		final int progressId = ++nextProgressId;
		mProgressMessage = msg;
		mProgressPos = mainProgress;
		if (mainProgress == 10000) {
			//log.v(""mainProgress==10000 : calling hideProgress"");
			hideProgress();
			return;
		}
		log.v(""showProgress("" + mainProgress + "", \"""" + msg
				+ ""\"") is called : "" + Thread.currentThread().getName());
		if (enable_progress) {
			mBackgroundThread.executeGUI(new Runnable() {
				public void run() {
					// show progress
					//log.v(""showProgress() - in GUI thread"");
					if (progressId != nextProgressId) {
						//Log.v(""cr3"",
						//		""showProgress() - skipping duplicate progress event"");
						return;
					}
					if (mProgress == null) {
						try {
							if (mActivity != null && mActivity.isStarted()) {
//								Log.v(""cr3"",
//										""showProgress() - in GUI thread : creating progress window"");
								if (PROGRESS_STYLE == ProgressDialog.STYLE_HORIZONTAL) {
									mProgress = new ProgressDialog(mActivity);
									mProgress
											.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
									if (progressIcon != null)
										mProgress.setIcon(progressIcon);
									else
										mProgress.setIcon(R.drawable.cr3_logo);
									mProgress.setMax(10000);
									mProgress.setCancelable(false);
									mProgress.setProgress(mainProgress);
									mProgress
											.setTitle(mActivity
													.getResources()
													.getString(
															R.string.progress_please_wait));
									mProgress.setMessage(msg);
									mProgress.show();
								} else {
//									mProgress = ProgressDialog.show(mActivity,
//											""Please Wait"", msg);
									mProgress.setCancelable(false);
									mProgress.setProgress(mainProgress);
								}
								progressShown = true;
							}
						} catch (Exception e) {
							Log.e(""cr3"",
									""Exception while trying to show progress dialog"",
									e);
							progressShown = false;
							mProgress = null;
						}
					} else {
						mProgress.setProgress(mainProgress);
						mProgress.setMessage(msg);
						if (!mProgress.isShowing()) {
							mProgress.show();
							progressShown = true;
						}
					}
				}
			});
		}
	}

	/**
	 * Hide progress dialog (if shown).
	 * (thread-safe)
	 */
	public void hideProgress() {
		final int progressId = ++nextProgressId;
		log.v(""hideProgress() - is called : ""
				+ Thread.currentThread().getName());
		// log.v(""hideProgress() is called"");
		mBackgroundThread.executeGUI(new Runnable() {
			public void run() {
				// hide progress
//				log.v(""hideProgress() - in GUI thread"");
				if (progressId != nextProgressId) {
//					Log.v(""cr3"",
//							""hideProgress() - skipping duplicate progress event"");
					return;
				}
				if (mProgress != null) {
					// if ( mProgress.isShowing() )
					// mProgress.hide();
					progressShown = false;
					progressIcon = null;
					mProgress.dismiss();
					mProgress = null;
//					log.v(""hideProgress() - in GUI thread, finished"");
				}
			}
		});
	}

	public boolean isProgressShown() {
		return progressShown;
	}

	public String loadFileUtf8(File file) {
		try {
			InputStream is = new FileInputStream(file);
			return loadResourceUtf8(is);
		} catch (Exception e) {
			log.e(""cannot load resource from file "" + file);
			return null;
		}
	}

	public String loadResourceUtf8(int id) {
		try {
			InputStream is = this.mActivity.getResources().openRawResource(id);
			return loadResourceUtf8(is);
		} catch (Exception e) {
			log.e(""cannot load resource "" + id);
			return null;
		}
	}

	public String loadResourceUtf8(InputStream is) {
		try {
			int available = is.available();
			if (available <= 0)
				return null;
			byte buf[] = new byte[available];
			if (is.read(buf) != available)
				throw new IOException(""Resource not read fully"");
			is.close();
			String utf8 = new String(buf, 0, available, ""UTF8"");
			return utf8;
		} catch (Exception e) {
			log.e(""cannot load resource"");
			return null;
		}
	}

	public byte[] loadResourceBytes(int id) {
		try {
			InputStream is = this.mActivity.getResources().openRawResource(id);
			return loadResourceBytes(is);
		} catch (Exception e) {
			log.e(""cannot load resource"");
			return null;
		}
	}

	public static byte[] loadResourceBytes(File f) {
		if (f == null || !f.isFile() || !f.exists())
			return null;
		FileInputStream is = null;
		try {
			is = new FileInputStream(f);
			byte[] res = loadResourceBytes(is);
			return res;
		} catch (IOException e) {
			log.e(""Cannot open file "" + f);
		}
		return null;
	}

	public static byte[] loadResourceBytes(InputStream is) {
		try {
			int available = is.available();
			if (available <= 0)
				return null;
			byte buf[] = new byte[available];
			if (is.read(buf) != available)
				throw new IOException(""Resource not read fully"");
			is.close();
			return buf;
		} catch (Exception e) {
			log.e(""cannot load resource"");
			return null;
		}
	}

	/**
	 * Initialize CoolReader Engine
	 * 
	 * @param fontList
	 *            is array of .ttf font pathnames to load
	 */
	public Engine(CoolReader activity, BackgroundThread backgroundThread) {
		this.mActivity = activity;
		this.mBackgroundThread = backgroundThread;
		// this.mMainView = mainView;
		//
//		log.i(""Engine() : initializing Engine in UI thread"");
//		if (!initialized) {
//			installLibrary();
//		}
		initializeStarted = true;
		log.i(""Engine() : scheduling init task"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			public void run() {
				try {
					log.i(""Engine() : running init() in engine thread"");
					init();
					// android.view.ViewRoot.getRunQueue().post(new Runnable() {
					// public void run() {
					//
					// }
					// });
				} catch (final Exception e) {
					log.e(""Exception while initializing Engine"", e);
					// handler.post(new Runnable() {
					// public void run() {
					// // TODO: fatal error
					// }
					// });
				}
			}
		});
	}

	private native boolean initInternal(String[] fontList);

	private native void uninitInternal();

	private native String[] getFontFaceListInternal();

	private native String[] getArchiveItemsInternal(String arcName); // pairs:
																		// pathname,
																		// size

	private native boolean setCacheDirectoryInternal(String dir, int size);

	private native boolean scanBookPropertiesInternal(FileInfo info);

	/**
	 * Checks whether specified directlry or file is symbolic link.
	 * (thread-safe)
	 * @param pathName is path to check
	 * @return true if specified directory or file is link (symlink)
	 */
	public native boolean isLink(String pathName);
	
	private static final int HYPH_NONE = 0;
	private static final int HYPH_ALGO = 1;
	private static final int HYPH_DICT = 2;

	private native boolean setHyphenationMethod(int type, byte[] dictData);

	public ArrayList<ZipEntry> getArchiveItems(String zipFileName) {
		final int itemsPerEntry = 2;
		String[] in = getArchiveItemsInternal(zipFileName);
		ArrayList<ZipEntry> list = new ArrayList<ZipEntry>();
		for (int i = 0; i <= in.length - itemsPerEntry; i += itemsPerEntry) {
			ZipEntry e = new ZipEntry(in[i]);
			e.setSize(Integer.valueOf(in[i + 1]));
			e.setCompressedSize(Integer.valueOf(in[i + 1]));
			list.add(e);
		}
		return list;
	}

	public enum HyphDict {
		NONE(HYPH_NONE, 0, ""[None]""), ALGORITHM(HYPH_ALGO, 0, ""[Algorythmic]""), RUSSIAN(
				HYPH_DICT, R.raw.russian_enus_hyphen, ""Russian""), ENGLISH(
				HYPH_DICT, R.raw.english_us_hyphen, ""English US""), GERMAN(
				HYPH_DICT, R.raw.german_hyphen, ""German""), UKRAINIAN(HYPH_DICT,
				R.raw.ukrain_hyphen, ""Ukrainian""), SPANISH(HYPH_DICT,
				R.raw.spanish_hyphen, ""Spanish""), FRENCH(HYPH_DICT,
				R.raw.french_hyphen, ""French""), BULGARIAN(HYPH_DICT,
				R.raw.bulgarian_hyphen, ""Bulgarian""), SWEDISH(HYPH_DICT,
				R.raw.swedish_hyphen, ""Swedish""), POLISH(HYPH_DICT,
				R.raw.polish_hyphen, ""Polish""), ;
		public final int type;
		public final int resource;
		public final String name;

		private HyphDict(int type, int resource, String name) {
			this.type = type;
			this.resource = resource;
			this.name = name;
		}

		public static HyphDict byCode(String code) {
			for (HyphDict dict : values())
				if (dict.toString().equals(code))
					return dict;
			return NONE;
		}
	};

	private HyphDict currentHyphDict = HyphDict.NONE;

	public boolean setHyphenationDictionary(final HyphDict dict) {
		log.i(""setHyphenationDictionary( "" + dict + "" ) is called"");
		if (currentHyphDict == dict)
			return false;
		currentHyphDict = dict;
		// byte[] image = loadResourceBytes(R.drawable.tx_old_book);
		mBackgroundThread.postBackground(new Runnable() {
			public void run() {
				if (!initialized)
					throw new IllegalStateException(""CREngine is not initialized"");
				byte[] data = null;
				if (dict.type == HYPH_DICT && dict.resource != 0) {
					data = loadResourceBytes(dict.resource);
				}
				log.i(""Setting engine's hyphenation dictionary to ""
						+ dict);
				setHyphenationMethod(dict.type, data);
			}
		});
		return true;
	}

	public boolean scanBookProperties(FileInfo info) {
		if (!initialized)
			throw new IllegalStateException(""CREngine is not initialized"");
		return scanBookPropertiesInternal(info);
	}

	public String[] getFontFaceList() {
		if (!initialized)
			throw new IllegalStateException(""CREngine is not initialized"");
		return getFontFaceListInternal();
	}

	final int CACHE_DIR_SIZE = 32000000;

	private String createCacheDir(File baseDir, String subDir) {
		String cacheDirName = null;
		if (baseDir.isDirectory()) {
			if (baseDir.canWrite()) {
				if (subDir != null) {
					baseDir = new File(baseDir, subDir);
					baseDir.mkdir();
				}
				if (baseDir.exists() && baseDir.canWrite()) {
					File cacheDir = new File(baseDir, "".cache"");
					if (cacheDir.exists() || cacheDir.mkdirs()) {
						if (cacheDir.canWrite()) {
							cacheDirName = cacheDir.getAbsolutePath();
						}
					}
				}
			} else {
				log.i(baseDir.toString() + "" is read only"");
			}
		} else {
			log.i(baseDir.toString() + "" is not found"");
		}
		return cacheDirName;
	}

	private void initCacheDirectory() {
		String cacheDirName = null;
		// SD card
		cacheDirName = createCacheDir(
				Environment.getExternalStorageDirectory(), ""Books"");
		// internal SD card on Nook
		if (cacheDirName == null)
			cacheDirName = createCacheDir(new File(""/system/media/sdcard""),
					""Books"");
		// internal flash
		if (cacheDirName == null) {
			File cacheDir = mActivity.getCacheDir();
			if (!cacheDir.isDirectory())
				cacheDir.mkdir();
			// File cacheDir = mActivity.getDir(""cache"", Context.MODE_PRIVATE);
			if (cacheDir.isDirectory() && cacheDir.canWrite())
				cacheDirName = cacheDir.getAbsolutePath();
		}
		// set cache directory for engine
		if (cacheDirName != null) {
			log.i(cacheDirName
					+ "" will be used for cache, maxCacheSize="" + CACHE_DIR_SIZE);
			setCacheDirectoryInternal(cacheDirName, CACHE_DIR_SIZE);
		}
	}

	private void init() throws IOException {
		if (initialized)
			throw new IllegalStateException(""Already initialized"");
		installLibrary();
		String[] fonts = findFonts();
		if (!initInternal(fonts))
			throw new IOException(""Cannot initialize CREngine JNI"");
		// Initialization of cache directory
		initCacheDirectory();
		initialized = true;
	}

	// public void waitTasksCompletion()
	// {
	// log.i(""waiting for engine tasks completion"");
	// try {
	// mExecutor.awaitTermination(0, TimeUnit.SECONDS);
	// } catch (InterruptedException e) {
	// // ignore
	// }
	// }

	/**
	 * Uninitialize engine.
	 */
	public void uninit() {
		log.i(""Engine.uninit() is called"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			public void run() {
				log.i(""Engine.uninit() : in background thread"");
				if (initialized) {
					uninitInternal();
					initialized = false;
				}
			}
		});
	}

	protected void finalize() throws Throwable {
		log.i(""Engine.finalize() is called"");
		// if ( initialized ) {
		// //uninitInternal();
		// initialized = false;
		// }
	}

	static private boolean initialized = false;
	static private boolean initializeStarted = false;

	private String[] findFonts() {
		ArrayList<File> dirs = new ArrayList<File>();
		File[] dataDirs = getDataDirectories(""fonts"", false, false);
		for (File dir : dataDirs)
			dirs.add(dir);
		File[] rootDirs = getStorageDirectories(false);
		for (File dir : rootDirs)
			dirs.add(new File(dir, ""fonts""));
		dirs.add(new File(Environment.getRootDirectory(), ""fonts""));
		ArrayList<String> fontPaths = new ArrayList<String>();
		for (File fontDir : dirs) {
			if (fontDir.isDirectory()) {
				log.v(""Scanning directory "" + fontDir.getAbsolutePath()
						+ "" for font files"");
				// get font names
				String[] fileList = fontDir.list(new FilenameFilter() {
					public boolean accept(File dir, String filename) {
						String lc = filename.toLowerCase();
						return (lc.endsWith("".ttf"") || lc.endsWith("".otf"")
								|| lc.endsWith("".pfb"") || lc.endsWith("".pfa""))
//								&& !filename.endsWith(""Fallback.ttf"")
								;
					}
				});
				// append path
				for (int i = 0; i < fileList.length; i++) {
					String pathName = new File(fontDir, fileList[i])
							.getAbsolutePath();
					fontPaths.add(pathName);
					log.v(""found font: "" + pathName);
				}
			}
		}
		return fontPaths.toArray(new String[] {});
	}

	private String SO_NAME = ""lib"" + LIBRARY_NAME + "".so"";
	private boolean force_install_library = false;

	private void installLibrary() {
		try {
			if (force_install_library)
				throw new Exception(""forcing install"");
			// try loading library w/o manual installation
			log.i(""trying to load library "" + LIBRARY_NAME
					+ "" w/o installation"");
			System.loadLibrary(LIBRARY_NAME);
			// try invoke native method
			//log.i(""trying execute native method "");
			//setHyphenationMethod(HYPH_NONE, new byte[] {});
			log.i(LIBRARY_NAME + "" loaded successfully"");
		} catch (Exception ee) {
			log.i(SO_NAME + "" not found using standard paths, will install manually"");
			File sopath = mActivity.getDir(""libs"", Context.MODE_PRIVATE);
			File soname = new File(sopath, SO_NAME);
			try {
				sopath.mkdirs();
				File zip = new File(mActivity.getPackageCodePath());
				ZipFile zipfile = new ZipFile(zip);
				ZipEntry zipentry = zipfile.getEntry(""lib/armeabi/"" + SO_NAME);
				if (!soname.exists() || zipentry.getSize() != soname.length()) {
					InputStream is = zipfile.getInputStream(zipentry);
					OutputStream os = new FileOutputStream(soname);
					Log.i(""cr3"",
							""Installing JNI library ""
									+ soname.getAbsolutePath());
					final int BUF_SIZE = 0x10000;
					byte[] buf = new byte[BUF_SIZE];
					int n;
					while ((n = is.read(buf)) > 0)
						os.write(buf, 0, n);
					is.close();
					os.close();
				} else {
					log.i(""JNI library "" + soname.getAbsolutePath()
							+ "" is up to date"");
				}
				System.load(soname.getAbsolutePath());
				//setHyphenationMethod(HYPH_NONE, new byte[] {});
			} catch (Exception e) {
				log.e(""cannot install "" + LIBRARY_NAME + "" library"", e);
			}
		}
	}

	public static final BackgroundTextureInfo NO_TEXTURE = new BackgroundTextureInfo(
			BackgroundTextureInfo.NO_TEXTURE_ID, ""(SOLID COLOR)"", 0);
	private static final BackgroundTextureInfo[] internalTextures = {
			NO_TEXTURE,
			new BackgroundTextureInfo(""bg_paper1"", ""Paper 1"",
					R.drawable.bg_paper1),
			new BackgroundTextureInfo(""bg_paper1_dark"", ""Paper 1 (dark)"",
					R.drawable.bg_paper1_dark),
			new BackgroundTextureInfo(""tx_wood_dark"", ""Wood (dark)"",
					R.drawable.tx_wood_dark),
			new BackgroundTextureInfo(""tx_wood"", ""Wood"", R.drawable.tx_wood),
			new BackgroundTextureInfo(""tx_wood_dark"", ""Wood (dark)"",
					R.drawable.tx_wood_dark),
			new BackgroundTextureInfo(""tx_fabric"", ""Fabric"",
					R.drawable.tx_fabric),
			new BackgroundTextureInfo(""tx_fabric_dark"", ""Fabric (dark)"",
					R.drawable.tx_fabric_dark),
			new BackgroundTextureInfo(""tx_fabric_indigo_fibre"", ""Fabric fibre"",
					R.drawable.tx_fabric_indigo_fibre),
			new BackgroundTextureInfo(""tx_fabric_indigo_fibre_dark"",
					""Fabric fibre (dark)"",
					R.drawable.tx_fabric_indigo_fibre_dark),
			new BackgroundTextureInfo(""tx_gray_sand"", ""Gray sand"",
					R.drawable.tx_gray_sand),
			new BackgroundTextureInfo(""tx_gray_sand_dark"", ""Gray sand (dark)"",
					R.drawable.tx_gray_sand_dark),
			new BackgroundTextureInfo(""tx_green_wall"", ""Green wall"",
					R.drawable.tx_green_wall),
			new BackgroundTextureInfo(""tx_green_wall_dark"",
					""Green wall (dark)"", R.drawable.tx_green_wall_dark),
			new BackgroundTextureInfo(""tx_metal_red_light"", ""Metall red"",
					R.drawable.tx_metal_red_light),
			new BackgroundTextureInfo(""tx_metal_red_dark"", ""Metall red (dark)"",
					R.drawable.tx_metal_red_dark),
			new BackgroundTextureInfo(""tx_metall_copper"", ""Metall copper"",
					R.drawable.tx_metall_copper),
			new BackgroundTextureInfo(""tx_metall_copper_dark"",
					""Metall copper (dark)"", R.drawable.tx_metall_copper_dark),
			new BackgroundTextureInfo(""tx_metall_old_blue"", ""Metall blue"",
					R.drawable.tx_metall_old_blue),
			new BackgroundTextureInfo(""tx_metall_old_blue_dark"",
					""Metall blue (dark)"", R.drawable.tx_metall_old_blue_dark),
			new BackgroundTextureInfo(""tx_old_book"", ""Old book"",
					R.drawable.tx_old_book),
			new BackgroundTextureInfo(""tx_old_book_dark"", ""Old book (dark)"",
					R.drawable.tx_old_book_dark),
			new BackgroundTextureInfo(""tx_old_paper"", ""Old paper"",
					R.drawable.tx_old_paper),
			new BackgroundTextureInfo(""tx_old_paper_dark"", ""Old paper (dark)"",
					R.drawable.tx_old_paper_dark),
			new BackgroundTextureInfo(""tx_paper"", ""Paper"", R.drawable.tx_paper),
			new BackgroundTextureInfo(""tx_paper_dark"", ""Paper (dark)"",
					R.drawable.tx_paper_dark),
			new BackgroundTextureInfo(""tx_rust"", ""Rust"", R.drawable.tx_rust),
			new BackgroundTextureInfo(""tx_rust_dark"", ""Rust (dark)"",
					R.drawable.tx_rust_dark),
			new BackgroundTextureInfo(""tx_sand"", ""Sand"", R.drawable.tx_sand),
			new BackgroundTextureInfo(""tx_sand_dark"", ""Sand (dark)"",
					R.drawable.tx_sand_dark),
			new BackgroundTextureInfo(""tx_stones"", ""Stones"",
					R.drawable.tx_stones),
			new BackgroundTextureInfo(""tx_stones_dark"", ""Stones (dark)"",
					R.drawable.tx_stones_dark), };
	public static final String DEF_DAY_BACKGROUND_TEXTURE = ""bg_paper1"";
	public static final String DEF_NIGHT_BACKGROUND_TEXTURE = ""bg_paper1_dark"";

	public BackgroundTextureInfo[] getAvailableTextures() {
		ArrayList<BackgroundTextureInfo> list = new ArrayList<BackgroundTextureInfo>(
				internalTextures.length);
		list.add(NO_TEXTURE);
		findExternalTextures(list);
		for (int i = 1; i < internalTextures.length; i++)
			list.add(internalTextures[i]);
		return list.toArray(new BackgroundTextureInfo[] {});
	}

	public void findTexturesFromDirectory(File dir,
			Collection<BackgroundTextureInfo> listToAppend) {
		for (File f : dir.listFiles()) {
			if (!f.isDirectory()) {
				BackgroundTextureInfo item = BackgroundTextureInfo.fromFile(f
						.getAbsolutePath());
				if (item != null)
					listToAppend.add(item);
			}
		}
	}

	public void findExternalTextures(
			Collection<BackgroundTextureInfo> listToAppend) {
		for (File d : getStorageDirectories(false)) {
			File base = new File(d, "".cr3"");
			if (!base.isDirectory())
				base = new File(d, ""cr3"");
			if (!base.isDirectory())
				continue;
			File subdirTextures = new File(base, ""textures"");
			File subdirBackgrounds = new File(base, ""backgrounds"");
			if (subdirTextures.isDirectory())
				findTexturesFromDirectory(subdirTextures, listToAppend);
			if (subdirBackgrounds.isDirectory())
				findTexturesFromDirectory(subdirBackgrounds, listToAppend);
		}
	}

	public byte[] getImageData(BackgroundTextureInfo texture) {
		if (texture.isNone())
			return null;
		if (texture.resourceId != 0) {
			byte[] data = loadResourceBytes(texture.resourceId);
			return data;
		} else if (texture.id != null && texture.id.startsWith(""/"")) {
			File f = new File(texture.id);
			byte[] data = loadResourceBytes(f);
			return data;
		}
		return null;
	}

	public BackgroundTextureInfo getTextureInfoById(String id) {
		if (id == null)
			return NO_TEXTURE;
		if (id.startsWith(""/"")) {
			BackgroundTextureInfo item = BackgroundTextureInfo.fromFile(id);
			if (item != null)
				return item;
		} else {
			for (BackgroundTextureInfo item : internalTextures)
				if (item.id.equals(id))
					return item;
		}
		return NO_TEXTURE;
	}

}
",True,7,38,0,0,3,17,6,7,L1
27,org.coolreader.crengine.L.java,"package org.coolreader.crengine;

import android.util.Log;

public class L {
	public static String getThreadLabel() {
		return BackgroundThread.instance().isGUIThread() ? ""G|"" : ""B|"";
	}
	public static void i(String msg) {
		Log.i(""cr3"", getThreadLabel() + msg);
	}
	public static void i(String msg, Exception e) {
		Log.i(""cr3"", getThreadLabel() + msg, e);
	}
	public static void w(String msg) {
		Log.w(""cr3"", getThreadLabel() + msg);
	}
	public static void w(String msg, Exception e) {
		Log.w(""cr3"", getThreadLabel() + msg, e);
	}
	public static void e(String msg) {
		Log.e(""cr3"", getThreadLabel() + msg);
	}
	public static void e(String msg, Exception e) {
		Log.e(""cr3"", getThreadLabel() + msg, e);
	}
	public static void d(String msg) {
		Log.d(""cr3"", getThreadLabel() + msg);
	}
	public static void d(String msg, Exception e) {
		Log.d(""cr3"", getThreadLabel() + msg, e);
	}
	public static void v(String msg) {
		Log.v(""cr3"", getThreadLabel() + msg);
	}
	public static void v(String msg, Exception e) {
		Log.v(""cr3"", getThreadLabel() + msg, e);
	}
	public static Logger create(String name) {
		return new LoggerImpl(name, Log.VERBOSE);
	}
	public static Logger create(String name, int level) {
		return new LoggerImpl(name, level);
	}
}

class LoggerImpl implements Logger {
	private final String name;
	private int level;
	public LoggerImpl( String name, int level ) {
		this.name = name;
		this.level = level;
	}
	public void setLevel( int level ) {
		this.level = level;
	}
	private String addName( String msg ) {
		return name + ""| "" + msg;
	}
	@Override
	public void i(String msg) {
		if ( level>=Log.INFO )
			L.i(addName(msg));
	}
	@Override
	public void i(String msg, Exception e) {
		if ( level>=Log.INFO )
			L.i(addName(msg), e);
	}
	@Override
	public void w(String msg) {
		if ( level>=Log.WARN )
			L.w(addName(msg));
	}
	@Override
	public void w(String msg, Exception e) {
		if ( level>=Log.WARN )
			L.w(addName(msg), e);
	}
	@Override
	public void e(String msg) {
		if ( level>=Log.ERROR )
			L.e(addName(msg));
	}
	@Override
	public void e(String msg, Exception e) {
		if ( level>=Log.ERROR )
			L.e(addName(msg), e);
	}
	@Override
	public void d(String msg) {
		if ( level>=Log.DEBUG )
			L.d(addName(msg));
	}
	@Override
	public void d(String msg, Exception e) {
		if ( level>=Log.DEBUG )
			L.d(addName(msg), e);
	}
	@Override
	public void v(String msg) {
		if ( level>=Log.VERBOSE )
			L.v(addName(msg));
	}
	@Override
	public void v(String msg, Exception e) {
		if ( level>=Log.VERBOSE )
			L.v(addName(msg), e);
	}
}
",True,14,38,0,0,4,26,10,2,L1
28,org.coolreader.crengine.AboutDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.net.Uri;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Button;
import android.widget.TabHost;
import android.widget.TabHost.TabContentFactory;
import android.widget.TextView;

public class AboutDialog extends BaseDialog implements TabContentFactory {
	final CoolReader mCoolReader;
	
	private View mAppTab;
	private View mLicenseTab;
	private View mDonationTab;
	
	private boolean isPackageInstalled( String packageName ) {
		try {
			mCoolReader.getPackageManager().getApplicationInfo(packageName, 0);
			return true;
		} catch ( Exception e ) {
			return false;
		}
	}

	private void installPackage( String packageName ) {
		Log.i(""cr3"", ""installPackageL "" + packageName);
		try {
			mCoolReader.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(""market://details?id="" + packageName)));
		} catch ( ActivityNotFoundException e ) {
			mCoolReader.showToast(""Cannot run Android Market application"");
		}
	}
	
	private void setupDonationButton( final Button btn, final String packageName ) {
		if ( isPackageInstalled(packageName)) {
			btn.setEnabled(false);
			btn.setText(R.string.dlg_about_donation_installed);
		} else {
			btn.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					installPackage(packageName);
				}
			});
		}
	}
	
	public AboutDialog( CoolReader activity)
	{
		super(activity, 0, 0, false);
		mCoolReader = activity;
		setTitle(null); //mCoolReader.getString(R.string.dlg_about));
		LayoutInflater inflater = LayoutInflater.from(getContext());
		TabHost tabs = (TabHost)inflater.inflate(R.layout.about_dialog, null);
		mAppTab = (View)inflater.inflate(R.layout.about_dialog_app, null);
		((TextView)mAppTab.findViewById(R.id.version)).setText(""Cool Reader "" + mCoolReader.getVersion());
		mLicenseTab = (View)inflater.inflate(R.layout.about_dialog_license, null);
		String license = mCoolReader.getEngine().loadResourceUtf8(R.raw.license);
		((TextView)mLicenseTab.findViewById(R.id.license)).setText(license);
		mDonationTab = (View)inflater.inflate(R.layout.about_dialog_donation, null);

		setupDonationButton( (Button)mDonationTab.findViewById(R.id.btn_about_donation_install_gold), ""org.coolreader.donation.gold"");
		setupDonationButton( (Button)mDonationTab.findViewById(R.id.btn_about_donation_install_silver), ""org.coolreader.donation.silver"");
		setupDonationButton( (Button)mDonationTab.findViewById(R.id.btn_about_donation_install_bronze), ""org.coolreader.donation.bronze"");
		
		tabs.setup();
		TabHost.TabSpec tsApp = tabs.newTabSpec(""App"");
		tsApp.setIndicator("""", 
				getContext().getResources().getDrawable(R.drawable.cr3_menu_link));
		tsApp.setContent(this);
		tabs.addTab(tsApp);

		TabHost.TabSpec tsLicense = tabs.newTabSpec(""License"");
		tsLicense.setIndicator("""", 
				getContext().getResources().getDrawable(R.drawable.ic_menu_star));
		tsLicense.setContent(this);
		tabs.addTab(tsLicense);
		
		TabHost.TabSpec tsDonation = tabs.newTabSpec(""Donation"");
		tsDonation.setIndicator("""", 
				getContext().getResources().getDrawable(R.drawable.ic_menu_emoticons));
		tsDonation.setContent(this);
		tabs.addTab(tsDonation);
		
		setView( tabs );
	}



	@Override
	public View createTabContent(String tag) {
		if ( ""App"".equals(tag) )
			return mAppTab;
		else if ( ""License"".equals(tag) )
			return mLicenseTab;
		else if ( ""Donation"".equals(tag) )
			return mDonationTab;
		return null;
	}
}
",True,19,38,0,0,3,20,1,2,L1
29,org.coolreader.crengine.FindNextDlg.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.graphics.drawable.BitmapDrawable;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.View.OnClickListener;
import android.view.View.OnKeyListener;
import android.view.View.OnTouchListener;
import android.widget.PopupWindow;
import android.widget.PopupWindow.OnDismissListener;

public class FindNextDlg {
	PopupWindow mWindow;
	View mAnchor;
	CoolReader mCoolReader;
	ReaderView mReaderView;
	View mPanel;
	final String pattern;
	final boolean caseInsensitive;
	static public void showDialog( CoolReader coolReader, ReaderView readerView, final String pattern, final boolean caseInsensitive )
	{
		FindNextDlg dlg = new FindNextDlg(coolReader, readerView, pattern, caseInsensitive);
		//dlg.mWindow.update(dlg.mAnchor, width, height)
		Log.d(""cr3"", ""popup: "" + dlg.mWindow.getWidth() + ""x"" + dlg.mWindow.getHeight());
		//dlg.update();
		//dlg.showAtLocation(readerView, Gravity.LEFT|Gravity.TOP, readerView.getLeft()+50, readerView.getTop()+50);
		//dlg.showAsDropDown(readerView);
		//dlg.update();
	}
	public FindNextDlg( CoolReader coolReader, ReaderView readerView, final String pattern, final boolean caseInsensitive )
	{
		this.pattern = pattern;
		this.caseInsensitive = caseInsensitive;
		mCoolReader = coolReader;
		mReaderView = readerView;
		mAnchor = readerView;

		View panel = (LayoutInflater.from(coolReader.getApplicationContext()).inflate(R.layout.search_popup, null));
		panel.measure(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
		
		//mReaderView.getS
		
		mWindow = new PopupWindow( mAnchor.getContext() );
		mWindow.setTouchInterceptor(new OnTouchListener() {
			
			@Override
			public boolean onTouch(View v, MotionEvent event) {
				if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
					mReaderView.clearSelection();
					mWindow.dismiss();
					return true;
				}
				return false;
			}
		});
		//super(panel);
		mPanel = panel;
		mPanel.findViewById(R.id.search_btn_prev).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.findNext(pattern, true, caseInsensitive);
			}
		});
		mPanel.findViewById(R.id.search_btn_next).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.findNext(pattern, false, caseInsensitive);
			}
		});
		mPanel.findViewById(R.id.search_btn_close).setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				mReaderView.clearSelection();
				mWindow.dismiss();
			}
		});
		mPanel.setFocusable(true);
		mPanel.setOnKeyListener( new OnKeyListener() {

			public boolean onKey(View v, int keyCode, KeyEvent event) {
				if ( event.getAction()==KeyEvent.ACTION_UP ) {
					switch ( keyCode ) {
					case KeyEvent.KEYCODE_BACK:
						mReaderView.clearSelection();
						mWindow.dismiss();
						return true;
					case KeyEvent.KEYCODE_DPAD_LEFT:
					case KeyEvent.KEYCODE_DPAD_UP:
						mReaderView.findNext(pattern, true, caseInsensitive);
						return true;
					case KeyEvent.KEYCODE_DPAD_RIGHT:
					case KeyEvent.KEYCODE_DPAD_DOWN:
						mReaderView.findNext(pattern, false, caseInsensitive);
						return true;
					}
				} else if ( event.getAction()==KeyEvent.ACTION_DOWN ) {
						switch ( keyCode ) {
						case KeyEvent.KEYCODE_BACK:
						case KeyEvent.KEYCODE_DPAD_LEFT:
						case KeyEvent.KEYCODE_DPAD_UP:
						case KeyEvent.KEYCODE_DPAD_RIGHT:
						case KeyEvent.KEYCODE_DPAD_DOWN:
							return true;
						}
					}
				if ( keyCode == KeyEvent.KEYCODE_BACK) {
					return true;
				}
				return false;
			}
			
		});

		mWindow.setOnDismissListener(new OnDismissListener() {
			@Override
			public void onDismiss() {
				mReaderView.clearSelection();
			}
		});
		
		mWindow.setBackgroundDrawable(new BitmapDrawable());
		//mWindow.setAnimationStyle(android.R.style.Animation_Toast);
		mWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);
		mWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);
//		setWidth(panel.getWidth());
//		setHeight(panel.getHeight());
		
		mWindow.setFocusable(true);
		mWindow.setTouchable(true);
		mWindow.setOutsideTouchable(true);
		mWindow.setContentView(panel);
		
		
		int [] location = new int[2];
		mAnchor.getLocationOnScreen(location);
		//mWindow.update(location[0], location[1], mPanel.getWidth(), mPanel.getHeight() );
		//mWindow.setWidth(mPanel.getWidth());
		//mWindow.setHeight(mPanel.getHeight());

		mWindow.showAtLocation(mAnchor, Gravity.TOP | Gravity.CENTER_HORIZONTAL, location[0], location[1] + mAnchor.getHeight() - mPanel.getHeight());
//		if ( mWindow.isShowing() )
//			mWindow.update(mAnchor, 50, 50);
		//dlg.mWindow.showAsDropDown(dlg.mAnchor);
	
	}
	
}
",False,4,38,0,0,3,30,1,2,L2
30,org.coolreader.crengine.TOCItem.java,"package org.coolreader.crengine;

import java.util.ArrayList;

public class TOCItem {
	private TOCItem mParent;
	private int mLevel;
	private int mIndex;
	private int mGlobalIndex=-1;
	private int mPage;
	private int mPercent;
	private boolean mExpanded;
	private String mName;
	private String mPath;
	private ArrayList<TOCItem> mChildren;
	// create root item
	public TOCItem() {
	}
	// create child item
	public TOCItem addChild() {
		if ( mChildren==null )
			mChildren = new ArrayList<TOCItem>();
		TOCItem item = new TOCItem();
		item.mParent = this;
		item.mIndex = mChildren.size();
		mChildren.add(item);
		return item;
	}
	public int getChildCount(){
		return mChildren!=null ? mChildren.size() : 0;
	}
	public TOCItem getChild( int index)	{
		return mChildren.get(index);
	}
	public TOCItem getParent() {
		return mParent;
	}
	public int getLevel() {
		return mLevel;
	}
	public int getIndex() {
		return mIndex;
	}
	public int getGlobalIndex() {
		return mGlobalIndex;
	}
	public void setGlobalIndex( int index ) {
		mGlobalIndex = index;
	}
	public boolean getExpanded() {
		return mExpanded;
	}
	public void setExpanded( boolean expanded ) {
		mExpanded = expanded;
	}
	public int getPage() {
		return mPage;
	}
	public int getPercent() {
		return mPercent;
	}
	public String getName() {
		return mName;
	}
	public String getPath() {
		return mPath;
	}
	
}
",False,12,26,4,11,0,0,2,0,L2
31,org.coolreader.crengine.FileBrowser.java,"package org.coolreader.crengine;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Locale;
import java.util.TimeZone;
import java.util.concurrent.Callable;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.OPDSUtil.DocInfo;
import org.coolreader.crengine.OPDSUtil.DownloadCallback;
import org.coolreader.crengine.OPDSUtil.EntryInfo;

import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.database.DataSetObserver;
import android.graphics.drawable.Drawable;
import android.view.ContextMenu;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MenuItem.OnMenuItemClickListener;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Adapter;
import android.widget.AdapterView;
import android.widget.ImageView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.TextView;

public class FileBrowser extends ListView {

	public static final Logger log = L.create(""fb"");
	
	Engine mEngine;
	Scanner mScanner;
	CoolReader mActivity;
	LayoutInflater mInflater;
	History mHistory;

	public static final int MAX_SUBDIR_LEN = 32;
	
	public FileBrowser(CoolReader activity, Engine engine, Scanner scanner, History history) {
		super(activity);
		this.mActivity = activity;
		this.mEngine = engine;
		this.mScanner = scanner;
		this.mInflater = LayoutInflater.from(activity);// activity.getLayoutInflater();
		this.mHistory = history;
        setFocusable(true);
        setFocusableInTouchMode(true);
        setLongClickable(true);
        //registerForContextMenu(this);
        //final FileBrowser _this = this;
        setOnItemLongClickListener(new OnItemLongClickListener() {

			@Override
			public boolean onItemLongClick(AdapterView<?> arg0, View arg1,
					int position, long id) {
				log.d(""onItemLongClick(""+position+"")"");
				//return super.performItemClick(view, position, id);
				if ( position==0 && currDirectory.parent!=null ) {
					showParentDirectory();
					return true;
				}
				FileInfo item = (FileInfo) getAdapter().getItem(position);
				if ( item==null )
					return false;
				if ( item.isDirectory ) {
					showDirectory(item, null);
					return true;
				}
				//openContextMenu(_this);
				//mActivity.loadDocument(item);
				selectedItem = item;
				showContextMenu();
				return true;
			}
		});
		setChoiceMode(CHOICE_MODE_SINGLE);
		showDirectory( null, null );
	}
	
	FileInfo selectedItem = null;
	
	public boolean onContextItemSelected(MenuItem item) {
		
		if ( selectedItem==null || selectedItem.isDirectory )
			return false;
			
		switch (item.getItemId()) {
		case R.id.book_open:
			log.d(""book_open menu item selected"");
			if ( selectedItem.isOPDSDir() )
				showOPDSDir(selectedItem, null);
			else
				mActivity.loadDocument(selectedItem);
			return true;
		case R.id.book_sort_order:
			mActivity.showToast(""Sorry, sort order selection is not yet implemented"");
			return true;
		case R.id.book_recent_books:
			showRecentBooks();
			return true;
		case R.id.book_opds_root:
			showOPDSRootDirectory();
			return true;
		case R.id.book_root:
			showRootDirectory();
			return true;
		case R.id.book_back_to_reading:
			if ( mActivity.isBookOpened() )
				mActivity.showReader();
			else
				mActivity.showToast(""No book opened"");
			return true;
		case R.id.book_delete:
			log.d(""book_delete menu item selected"");
			mActivity.getReaderView().closeIfOpened(selectedItem);
			if ( selectedItem.deleteFile() ) {
				mHistory.removeBookInfo(selectedItem, true, true);
			}
			showDirectory(currDirectory, null);
			return true;
		case R.id.book_recent_goto:
			log.d(""book_recent_goto menu item selected"");
			showDirectory(selectedItem, selectedItem);
			return true;
		case R.id.book_recent_remove:
			log.d(""book_recent_remove menu item selected"");
			mActivity.getHistory().removeBookInfo(selectedItem, true, false);
			showRecentBooks();
			return true;
		}
		return false;
	}
	
	@Override
	public void createContextMenu(ContextMenu menu) {
		log.d(""createContextMenu()"");
		menu.clear();
	    MenuInflater inflater = mActivity.getMenuInflater();
	    if ( isRecentDir() ) {
		    inflater.inflate(R.menu.cr3_file_browser_recent_context_menu, menu);
		    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_recent_book));
	    } else if (selectedItem!=null && selectedItem.isDirectory) {
		    inflater.inflate(R.menu.cr3_file_browser_folder_context_menu, menu);
		    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_book));
	    } else {
		    inflater.inflate(R.menu.cr3_file_browser_context_menu, menu);
		    menu.setHeaderTitle(mActivity.getString(R.string.context_menu_title_book));
	    }
	    for ( int i=0; i<menu.size(); i++ ) {
	    	menu.getItem(i).setOnMenuItemClickListener(new OnMenuItemClickListener() {
				public boolean onMenuItemClick(MenuItem item) {
					onContextItemSelected(item);
					return true;
				}
			});
	    }
	    return;
	}



	@Override
	public boolean performItemClick(View view, int position, long id) {
		log.d(""performItemClick(""+position+"")"");
		//return super.performItemClick(view, position, id);
		if ( position==0 && currDirectory.parent!=null ) {
			showParentDirectory();
			return true;
		}
		FileInfo item = (FileInfo) getAdapter().getItem(position);
		if ( item==null )
			return false;
		if ( item.isDirectory ) {
			showDirectory(item, null);
			return true;
		}
		if ( item.isOPDSDir() )
			showOPDSDir(item, null);
		else
			mActivity.loadDocument(item);
		return true;
	}

	protected void showParentDirectory()
	{
		if ( currDirectory.parent!=null ) {
			showDirectory(currDirectory.parent, currDirectory);
		}
	}
	
	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if ( keyCode==KeyEvent.KEYCODE_BACK && mActivity.isBookOpened() ) {
			if ( isRootDir() ) {
				if ( mActivity.isBookOpened() ) {
					mActivity.showReader();
					return true;
				} else
					return super.onKeyDown(keyCode, event);
			}
			showParentDirectory();
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}

	boolean mInitStarted = false;
	boolean mInitialized = false;
	public void init()
	{
		if ( mInitStarted )
			return;
		log.e(""FileBrowser.init() called"");
		mInitStarted = true;
		//mEngine.showProgress(1000, R.string.progress_scanning);
		execute( new Task() {
			public void work() {
				mHistory.loadFromDB(mScanner, 100);
			}
			public void done() {
				log.e(""Directory scan is finished. "" + mScanner.mFileList.size() + "" files found"" + "", root item count is "" + mScanner.mRoot.itemCount());
				mInitialized = true;
				//mEngine.hideProgress();
				//mEngine.hideProgress();
				showDirectory( mScanner.mRoot, null );
				setSelection(0);
			}
			public void fail(Exception e )
			{
				//mEngine.showProgress(9000, ""Scan is failed"");
				//mEngine.hideProgress();
				mActivity.showToast(""Scan is failed"");
				log.e(""Exception while scanning directories"", e);
			}
		});
	}
	
	@Override
	public void setSelection(int position) {
		super.setSelection(position);
	}
	
	public static String formatAuthors( String authors ) {
		if ( authors==null || authors.length()==0 )
			return null;
		String[] list = authors.split(""\\|"");
		StringBuilder buf = new StringBuilder(authors.length());
		for ( String a : list ) {
			if ( buf.length()>0 )
				buf.append("", "");
			String[] items = a.split("" "");
			if ( items.length==3 && items[1]!=null && items[1].length()>=1 )
				buf.append(items[0] + "" "" + items[1].charAt(0) + "". "" + items[2]);
			else
				buf.append(a);
		}
		return buf.toString();
	}
	
	public static String formatSize( int size )
	{
		if ( size==0 )
			return """";
		if ( size<10000 )
			return String.valueOf(size);
		else if ( size<1000000 )
			return String.valueOf(size/1000) + ""K"";
		else if ( size<10000000 )
			return String.valueOf(size/1000000) + ""."" + String.valueOf(size%1000000/100000) + ""M"";
		else
			return String.valueOf(size/1000000) + ""M"";
	}

	public static String formatSeries( String name, int number )
	{
		if ( name==null || name.length()==0 )
			return null;
		if ( number>0 )
			return ""#"" + number + "" "" + name;
		else
			return name;
	}
	
	static private SimpleDateFormat dateFormat = new SimpleDateFormat(""dd.MM.yy"", Locale.getDefault());
	static private SimpleDateFormat timeFormat = new SimpleDateFormat(""HH:mm"", Locale.getDefault());
	public static String formatDate( long timeStamp )
	{
		if ( timeStamp<5000*60*60*24*1000 )
			return """";
		TimeZone tz = java.util.TimeZone.getDefault();
		Calendar now = Calendar.getInstance(tz);
		Calendar c = Calendar.getInstance(tz);
		c.setTimeInMillis(timeStamp);
		if ( c.get(Calendar.YEAR)<1980 )
			return """";
		if ( c.get(Calendar.YEAR)==now.get(Calendar.YEAR)
				&& c.get(Calendar.MONTH)==now.get(Calendar.MONTH)
				&& c.get(Calendar.DAY_OF_MONTH)==now.get(Calendar.DAY_OF_MONTH)) {
			timeFormat.setTimeZone(tz);
			return timeFormat.format(c.getTime());
		} else {
			dateFormat.setTimeZone(tz);
			return dateFormat.format(c.getTime());
		}
	}

	public static String formatPercent( int percent )
	{
		if ( percent<=0 )
			return null;
		return String.valueOf(percent/100) + ""."" + String.valueOf(percent/10%10) + ""%"";
	}

	private FileInfo currDirectory;

	public boolean isRootDir()
	{
		return currDirectory == mScanner.getRoot();
	}

	public boolean isRecentDir()
	{
		return currDirectory!=null && currDirectory.isRecentDir();
	}

	public void showRecentBooks()
	{
		showDirectory(null, null);
	}

	public void showLastDirectory()
	{
		if ( currDirectory==null || currDirectory==mScanner.getRoot() )
			showRecentBooks();
		else
			showDirectory(currDirectory, null);
	}

	public void showSearchResult( FileInfo[] books ) {
		FileInfo dir = mScanner.setSearchResults( books );
		showDirectory(dir, null);
	}
	
	public void showFindBookDialog()
	{
		BookSearchDialog dlg = new BookSearchDialog( mActivity, new BookSearchDialog.SearchCallback() {
			@Override
			public void done(FileInfo[] results) {
				if ( results!=null ) {
					if ( results.length==0 ) {
						mActivity.showToast(R.string.dlg_book_search_not_found);
					} else {
						showSearchResult( results );
					}
				}
			}
		});
		dlg.show();
	}

	public void showRootDirectory()
	{
		log.v(""showRootDirectory()"");
		showDirectory(mScanner.getRoot(), null);
	}

	public void showOPDSRootDirectory()
	{
		log.v(""showOPDSRootDirectory()"");
		FileInfo opdsRoot = mScanner.getOPDSRoot();
		if ( opdsRoot!=null )
			showDirectory(opdsRoot, null);
	}

	private FileInfo.SortOrder mSortOrder = FileInfo.DEF_SORT_ORDER; 
	public void setSortOrder(FileInfo.SortOrder order) {
		if ( mSortOrder == order )
			return;
		mSortOrder = order!=null ? order : FileInfo.DEF_SORT_ORDER;
		if ( currDirectory!=null && currDirectory.allowSorting() ) {
			currDirectory.sort(mSortOrder);
			showDirectory(currDirectory, null);
			mActivity.saveSetting(ReaderView.PROP_APP_BOOK_SORT_ORDER, mSortOrder.name());
		}
	}
	public void setSortOrder(String orderName) {
		setSortOrder(FileInfo.SortOrder.fromName(orderName));
	}
	public void showSortOrderMenu() {
		final Properties properties = new Properties();
		properties.setProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER, mActivity.getSetting(ReaderView.PROP_APP_BOOK_SORT_ORDER));
		final String oldValue = properties.getProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER);
		int[] optionLabels = {
			FileInfo.SortOrder.FILENAME.resourceId,	
			FileInfo.SortOrder.FILENAME_DESC.resourceId,	
			FileInfo.SortOrder.AUTHOR_TITLE.resourceId,	
			FileInfo.SortOrder.AUTHOR_TITLE_DESC.resourceId,	
			FileInfo.SortOrder.TITLE_AUTHOR.resourceId,	
			FileInfo.SortOrder.TITLE_AUTHOR_DESC.resourceId,	
			FileInfo.SortOrder.TIMESTAMP.resourceId,	
			FileInfo.SortOrder.TIMESTAMP_DESC.resourceId,	
		};
		String[] optionValues = {
			FileInfo.SortOrder.FILENAME.name(),	
			FileInfo.SortOrder.FILENAME_DESC.name(),	
			FileInfo.SortOrder.AUTHOR_TITLE.name(),	
			FileInfo.SortOrder.AUTHOR_TITLE_DESC.name(),	
			FileInfo.SortOrder.TITLE_AUTHOR.name(),	
			FileInfo.SortOrder.TITLE_AUTHOR_DESC.name(),	
			FileInfo.SortOrder.TIMESTAMP.name(),	
			FileInfo.SortOrder.TIMESTAMP_DESC.name(),	
		};
		OptionsDialog.ListOption dlg = new OptionsDialog.ListOption(
			new OptionOwner() {
				public CoolReader getActivity() { return mActivity; }
				public Properties getProperties() { return properties; }
				public LayoutInflater getInflater() { return mInflater; }
			}, 
			mActivity.getString(R.string.mi_book_sort_order), 
			ReaderView.PROP_APP_BOOK_SORT_ORDER).add(optionValues, optionLabels); 
		dlg.setOnChangeHandler(new Runnable() {
			public void run() {
				final String newValue = properties.getProperty(ReaderView.PROP_APP_BOOK_SORT_ORDER);
				if ( newValue!=null && oldValue!=null && !newValue.equals(oldValue) ) {
					log.d(""New sort order: "" + newValue);
					setSortOrder(newValue);
				}
			}
		});
		dlg.onSelect();
	}
	
	private void showOPDSDir( final FileInfo fileOrDir, final FileInfo itemToSelect ) {
		
		if ( fileOrDir.fileCount()>0 || fileOrDir.dirCount()>0 ) {
			// already downloaded
			BackgroundThread.instance().executeGUI(new Runnable() {
				@Override
				public void run() {
					showDirectoryInternal(fileOrDir, itemToSelect);					
				}
			});
			return;
		}
		
		String url = fileOrDir.getOPDSUrl();
		final FileInfo myCurrDirectory = currDirectory;
		if ( url!=null ) {
			try {
				final URL uri = new URL(url);
				DownloadCallback callback = new DownloadCallback() {

					@Override
					public void onEntries(DocInfo doc,
							Collection<EntryInfo> entries) {
						// TODO Auto-generated method stub
					}

					@Override
					public void onFinish(DocInfo doc,
							Collection<EntryInfo> entries) {
						if ( myCurrDirectory != currDirectory ) {
							log.w(""current directory has been changed: ignore downloaded items"");
							return;
						}
						ArrayList<FileInfo> items = new ArrayList<FileInfo>();
						for ( EntryInfo entry : entries ) {
							OPDSUtil.LinkInfo acquisition = entry.getBestAcquisitionLink();
							if ( acquisition!=null ) {
								FileInfo file = new FileInfo();
								file.isDirectory = false;
								file.pathname = FileInfo.OPDS_DIR_PREFIX + acquisition.href;
								file.filename = entry.content;
								file.title = entry.title;
								file.format = DocumentFormat.byMimeType(acquisition.type);
								file.authors = entry.getAuthors();
								file.isListed = true;
								file.isScanned = true;
								file.parent = fileOrDir;
								file.tag = entry;
								items.add(file);
							} else if ( entry.link.type!=null && entry.link.type.startsWith(""application/atom+xml"") ) {
								FileInfo file = new FileInfo();
								file.isDirectory = true;
								file.pathname = FileInfo.OPDS_DIR_PREFIX + entry.link.href;
								file.filename = entry.title;
								file.isListed = true;
								file.isScanned = true;
								file.tag = entry;
								file.parent = fileOrDir;
								items.add(file);
							}
						}
						if ( items.size()>0 ) {
							fileOrDir.replaceItems(items);
							showDirectoryInternal(fileOrDir, null);
						} else {
							mActivity.showToast(""No OPDS entries found"");
						}
					}

					@Override
					public void onError(String message) {
						mEngine.hideProgress();
						mActivity.showToast(message);
					}

					FileInfo downloadDir;
					@Override
					public File onDownloadStart(String type, String url) {
						//mEngine.showProgress(0, ""Downloading "" + url);
						//mActivity.showToast(""Starting download of "" + type + "" from "" + url);
						log.d(""onDownloadStart: called for "" + type + "" "" + url );
						downloadDir = mActivity.getScanner().getDownloadDirectory();
						log.d(""onDownloadStart: after getDownloadDirectory()"" );
						String subdir = null;
						if ( fileOrDir.authors!=null ) {
							subdir = OPDSUtil.transcribeFileName(fileOrDir.authors);
							if ( subdir.length()>MAX_SUBDIR_LEN )
								subdir = subdir.substring(0, MAX_SUBDIR_LEN);
						} else {
							subdir = ""NoAuthor"";
						}
						if ( downloadDir==null )
							return null;
						File result = new File(downloadDir.getPathName());
						result = new File(result, subdir);
						result.mkdirs();
						downloadDir.findItemByPathName(result.getAbsolutePath());
						log.d(""onDownloadStart: returning "" + result.getAbsolutePath() );
						return result;
					}

					@Override
					public void onDownloadEnd(String type, String url, File file) {
						mEngine.hideProgress();
						//mActivity.showToast(""Download is finished"");
						FileInfo fi = new FileInfo(file);
						FileInfo dir = mScanner.findParent(fi, downloadDir);
						if ( dir==null )
							dir = downloadDir;
						mScanner.listDirectory(dir);
						FileInfo item = dir.findItemByPathName(file.getAbsolutePath());
						if ( item!=null )
							mActivity.loadDocument(item);
						else
							mActivity.loadDocument(fi);
					}

					@Override
					public void onDownloadProgress(String type, String url,
							int percent) {
						mEngine.showProgress(percent * 100, ""Downloading"");
					}
					
				};
				String fileMimeType = fileOrDir.format!=null ? fileOrDir.format.getMimeFormat() : null;
				String defFileName = OPDSUtil.transcribeFileName( fileOrDir.title!=null ? fileOrDir.title : fileOrDir.filename );
				if ( fileOrDir.format!=null )
					defFileName = defFileName + fileOrDir.format.getExtensions()[0];
				final OPDSUtil.DownloadTask downloadTask = OPDSUtil.create(mActivity, uri, defFileName, fileOrDir.isDirectory?""application/atom+xml"":fileMimeType, 
						myCurrDirectory.getOPDSUrl(), callback);
				downloadTask.run();
			} catch (MalformedURLException e) {
				log.e(""MalformedURLException: "" + url);
				mActivity.showToast(""Wrong URI: "" + url);
			}
		}
	}
	
	public void showDirectory( FileInfo fileOrDir, FileInfo itemToSelect )
	{
		if ( !BackgroundThread.instance().isGUIThread() ) {
			try {
				throw new Exception(""showDirectory called from background thread!"");
			} catch ( Exception e ) {
				log.e(e.getMessage(), e);
			}
			final FileInfo dir = fileOrDir;
			final FileInfo item = itemToSelect;
			BackgroundThread.instance().callGUI(new Callable<Object>() {
				@Override
				public Object call() throws Exception {
					showDirectory( dir, item );
					return null;
				}
			});
			return;
		}
		if ( fileOrDir!=null && fileOrDir.isOPDSDir() ) {
			showOPDSDir(fileOrDir, itemToSelect);
			return;
		}
		if ( fileOrDir==null && mScanner.getRoot()!=null && mScanner.getRoot().dirCount()>0 ) {
			if ( mScanner.getRoot().getDir(0).fileCount()>0 ) {
				fileOrDir = mScanner.getRoot().getDir(0);
				itemToSelect = mScanner.getRoot().getDir(0).getFile(0);
			} else {
				fileOrDir = mScanner.getRoot();
				itemToSelect = mScanner.getRoot().dirCount()>1 ? mScanner.getRoot().getDir(1) : null;
			}
		}
		final FileInfo file = fileOrDir==null || fileOrDir.isDirectory ? itemToSelect : fileOrDir;
		final FileInfo dir = fileOrDir!=null && !fileOrDir.isDirectory ? mScanner.findParent(file, mScanner.getRoot()) : fileOrDir;
		if ( dir!=null ) {
			mScanner.scanDirectory(dir, new Runnable() {
				public void run() {
					if ( dir.allowSorting() )
						dir.sort(mSortOrder);
					showDirectoryInternal(dir, file);
				}
			}, false, new Scanner.ScanControl() );
		} else
			showDirectoryInternal(dir, file);
	}
	
	public void scanCurrentDirectoryRecursive() {
		if ( currDirectory==null )
			return;
		log.i(""scanCurrentDirectoryRecursive started"");
		final Scanner.ScanControl control = new Scanner.ScanControl(); 
		final ProgressDialog dlg = ProgressDialog.show(getContext(), 
				mActivity.getString(R.string.dlg_scan_title), 
				mActivity.getString(R.string.dlg_scan_message),
				true, true, new OnCancelListener() {
					@Override
					public void onCancel(DialogInterface dialog) {
						log.i(""scanCurrentDirectoryRecursive : stop handler"");
						control.stop();
					}
		});
		mScanner.scanDirectory(currDirectory, new Runnable() {
			@Override
			public void run() {
				log.i(""scanCurrentDirectoryRecursive : finish handler"");
				if ( dlg.isShowing() )
					dlg.dismiss();
			}
		}, true, control); 
	}


	public boolean isSimpleViewMode() {
		return isSimpleViewMode;
	}

	public void setSimpleViewMode( boolean isSimple ) {
		if ( isSimpleViewMode!=isSimple ) {
			isSimpleViewMode = isSimple;
			mSortOrder = FileInfo.SortOrder.FILENAME;
			mActivity.saveSetting(ReaderView.PROP_APP_BOOK_SORT_ORDER, mSortOrder.name());
			if ( isShown() && currDirectory!=null ) {
				showDirectory(currDirectory, null);
			}
		}
	}
	private boolean isSimpleViewMode = true;

	private void showDirectoryInternal( final FileInfo dir, final FileInfo file )
	{
		if ( !BackgroundThread.instance().isGUIThread() ) {
			try {
				throw new Exception(""showDirectoryInternal called from background thread!"");
			} catch ( Exception e ) {
				log.e(e.getMessage(), e);
			}
			BackgroundThread.instance().callGUI(new Callable<Object>() {
				@Override
				public Object call() throws Exception {
					showDirectoryInternal( dir, file );
					return null;
				}
			});
			return;
		}
		currDirectory = dir;
		if ( dir!=null )
			log.i(""Showing directory "" + dir + "" "" + Thread.currentThread().getName());
		if ( !BackgroundThread.instance().isGUIThread() )
			throw new IllegalStateException(""showDirectoryInternal should be called from GUI thread!"");
		this.setAdapter(new ListAdapter() {

			public boolean areAllItemsEnabled() {
				return true;
			}

			public boolean isEnabled(int arg0) {
				return true;
			}

			public int getCount() {
				if ( dir==null )
					return 0;
				return dir.fileCount() + dir.dirCount() + (dir.parent!=null ? 1 : 0);
			}

			public Object getItem(int position) {
				if ( dir==null )
					return null;
				if ( position<0 )
					return null;
				int start = (dir.parent!=null ? 1 : 0);
				if ( position<start )
					return dir.parent;
				return dir.getItem(position-start);
			}

			public long getItemId(int position) {
				if ( dir==null )
					return 0;
				return position;
			}

			public final int VIEW_TYPE_LEVEL_UP = 0;
			public final int VIEW_TYPE_DIRECTORY = 1;
			public final int VIEW_TYPE_FILE = 2;
			public final int VIEW_TYPE_FILE_SIMPLE = 3;
			public final int VIEW_TYPE_COUNT = 4;
			public int getItemViewType(int position) {
				if ( dir==null )
					return 0;
				if ( position<0 )
					return Adapter.IGNORE_ITEM_VIEW_TYPE;
				int start = (dir.parent!=null ? 1 : 0);
				if ( position<start )
					return VIEW_TYPE_LEVEL_UP;
				if ( position<start + dir.dirCount() )
					return VIEW_TYPE_DIRECTORY;
				start += dir.dirCount();
				position -= start;
				if ( position<dir.fileCount() )
					return isSimpleViewMode ? VIEW_TYPE_FILE_SIMPLE : VIEW_TYPE_FILE;
				return Adapter.IGNORE_ITEM_VIEW_TYPE;
			}

			class ViewHolder {
				int viewType;
				ImageView image;
				TextView name;
				TextView author;
				TextView series;
				TextView filename;
				TextView field1;
				TextView field2;
				//TextView field3;
				void setText( TextView view, String text )
				{
					if ( view==null )
						return;
					if ( text!=null && text.length()>0 ) {
						view.setText(text);
						view.setVisibility(VISIBLE);
					} else {
						view.setText(null);
						view.setVisibility(INVISIBLE);
					}
				}
				void setItem(FileInfo item, FileInfo parentItem)
				{
					if ( item==null ) {
						image.setImageResource(R.drawable.cr3_browser_back);
						String thisDir = """";
						if ( parentItem!=null ) {
							if ( parentItem.pathname.startsWith(""@"") )
								thisDir = ""/"" + parentItem.filename;
//							else if ( parentItem.isArchive )
//								thisDir = parentItem.arcname;
							else
								thisDir = parentItem.pathname;
							//parentDir = parentItem.path;
						}
						name.setText(thisDir);
						return;
					}
					if ( item.isDirectory ) {
						if ( item.isRecentDir() )
							image.setImageResource(R.drawable.cr3_browser_folder_recent);
						else if ( item.isArchive )
							image.setImageResource(R.drawable.cr3_browser_folder_zip);
						else
							image.setImageResource(R.drawable.cr3_browser_folder);
						setText(name, item.filename);

						if ( !item.isOPDSDir() ) {
							setText(field1, ""books: "" + String.valueOf(item.fileCount()));
							setText(field2, ""folders: "" + String.valueOf(item.dirCount()));
						} else {
							setText(field1, """");
							setText(field2, """");
						}
					} else {
						boolean isSimple = (viewType == VIEW_TYPE_FILE_SIMPLE);
						if ( image!=null ) {
							if ( isSimple ) {
								image.setImageResource(item.format.getIconResourceId());
							} else {
								Drawable drawable = null;
								if ( item.id!=null )
									drawable = mHistory.getBookCoverpageImage(null, item.id);
								if ( drawable!=null ) {
									image.setImageDrawable(drawable);
								} else {
									int resId = item.format!=null ? item.format.getIconResourceId() : 0;
									if ( resId!=0 )
										image.setImageResource(item.format.getIconResourceId());
								}
							}
						}
						if ( isSimple ) {
							String fn = item.getFileNameToDisplay();
							setText( filename, fn );
						} else {
							setText( author, formatAuthors(item.authors) );
							String seriesName = formatSeries(item.series, item.seriesNumber);
							String title = item.title;
							String filename1 = item.filename;
							String filename2 = item.isArchive /*&& !item.isDirectory */
									? new File(item.arcname).getName() : null;
							if ( title==null || title.length()==0 ) {
								title = filename1;
								if (seriesName==null) 
									seriesName = filename2;
							} else if (seriesName==null) 
								seriesName = filename1;
							setText( name, title );
							setText( series, seriesName );
	
	//						field1.setVisibility(VISIBLE);
	//						field2.setVisibility(VISIBLE);
	//						field3.setVisibility(VISIBLE);
							field1.setText(formatSize(item.size) + "" "" + (item.format!=null ? item.format.name().toLowerCase() : """") + "" "" + formatDate(item.createTime) + ""  "");
							//field2.setText(formatDate(pos!=null ? pos.getTimeStamp() : item.createTime));
							Bookmark pos = mHistory.getLastPos(item);
							if ( pos!=null ) {
								field2.setText(formatPercent(pos.getPercent()) + "" "" + formatDate(pos.getTimeStamp())) ;
							} else {
								field2.setText("""");
							}
							//field3.setText(pos!=null ? formatPercent(pos.getPercent()) : null);
						} 
						
					}
				}
			}
			
			public View getView(int position, View convertView, ViewGroup parent) {
				if ( dir==null )
					return null;
				View view;
				ViewHolder holder;
				int vt = getItemViewType(position);
				if ( convertView==null ) {
					if ( vt==VIEW_TYPE_LEVEL_UP )
						view = mInflater.inflate(R.layout.browser_item_parent_dir, null);
					else if ( vt==VIEW_TYPE_DIRECTORY )
						view = mInflater.inflate(R.layout.browser_item_folder, null);
					else if ( vt==VIEW_TYPE_FILE_SIMPLE )
						view = mInflater.inflate(R.layout.browser_item_book_simple, null);
					else
						view = mInflater.inflate(R.layout.browser_item_book, null);
					holder = new ViewHolder();
					holder.image = (ImageView)view.findViewById(R.id.book_icon);
					holder.name = (TextView)view.findViewById(R.id.book_name);
					holder.author = (TextView)view.findViewById(R.id.book_author);
					holder.series = (TextView)view.findViewById(R.id.book_series);
					holder.filename = (TextView)view.findViewById(R.id.book_filename);
					holder.field1 = (TextView)view.findViewById(R.id.browser_item_field1);
					holder.field2 = (TextView)view.findViewById(R.id.browser_item_field2);
					//holder.field3 = (TextView)view.findViewById(R.id.browser_item_field3);
					view.setTag(holder);
				} else {
					view = convertView;
					holder = (ViewHolder)view.getTag();
				}
				holder.viewType = vt;
				FileInfo item = (FileInfo)getItem(position);
				FileInfo parentItem = null;//item!=null ? item.parent : null;
				if ( vt == VIEW_TYPE_LEVEL_UP ) {
					item = null;
					parentItem = currDirectory;
				}
				holder.setItem(item, parentItem);
				return view;
			}

			public int getViewTypeCount() {
				if ( dir==null )
					return 1;
				return VIEW_TYPE_COUNT;
			}

			public boolean hasStableIds() {
				return true;
			}

			public boolean isEmpty() {
				if ( dir==null )
					return true;
				return mScanner.mFileList.size()==0;
			}

			private ArrayList<DataSetObserver> observers = new ArrayList<DataSetObserver>();
			
			public void registerDataSetObserver(DataSetObserver observer) {
				observers.add(observer);
			}

			public void unregisterDataSetObserver(DataSetObserver observer) {
				observers.remove(observer);
			}
			
		});
		int index = dir!=null ? dir.getItemIndex(file) : -1;
		if ( dir!=null && !dir.isRootDir() )
			index++;
		setSelection(index);
		setChoiceMode(CHOICE_MODE_SINGLE);
		invalidate();
	}

	private void execute( Engine.EngineTask task )
    {
    	mEngine.execute(task);
    }

    private abstract class Task implements Engine.EngineTask {
    	
		public void done() {
			// override to do something useful
		}

		public void fail(Exception e) {
			// do nothing, just log exception
			// override to do custom action
			log.e(""Task "" + this.getClass().getSimpleName() + "" is failed with exception "" + e.getMessage(), e);
		}
    }
    
}
",True,34,38,0,0,2,20,3,17,L1
32,org.coolreader.crengine.CRDB.java,"package org.coolreader.crengine;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;

import android.database.Cursor;
import android.database.DatabaseUtils;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

public class CRDB {
	static final boolean DROP_TABLES = false; // for debug purposes
	SQLiteDatabase mDB;
	File mDBFile;
	protected boolean open( File dbfile )
	{
		mDB = SQLiteDatabase.openOrCreateDatabase(dbfile, null);
		this.mDBFile = dbfile;
		return true;
	}
	protected void dropTables()
	{
		String[] tableNames = new String[] {
			""book_author"", ""bookmark"", ""book"", ""series"", ""author"", ""folder"", ""coverpage""	
		};
		for ( String name : tableNames )
			mDB.execSQL(""DROP TABLE IF EXISTS "" + name);
	}
	
	private void execSQLIgnoreErrors( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""query failed, ignoring: "" + sql);
			}
		}
	}

	private void execSQL( String... sqls )
	{
		for ( String sql : sqls ) {
			try { 
				mDB.execSQL(sql);
			} catch ( SQLException e ) {
				// ignore
				Log.w(""cr3"", ""query failed: "" + sql);
				throw e;
			}
		}
	}

	private final static String[] COVERPAGE_SCHEMA = new String[] {
		""CREATE TABLE IF NOT EXISTS coverpage ("" +
		""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
		""imagedata BLOB NULL"" +
		"")""
	};
	
	public final int DB_VERSION = 4;
	protected boolean updateSchema()
	{
		if (DROP_TABLES)
			dropTables();
		execSQL(""CREATE TABLE IF NOT EXISTS author ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL COLLATE NOCASE"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
                ""author_name_index ON author (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS series ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL COLLATE NOCASE"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
		        ""series_name_index ON series (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS folder ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""name VARCHAR NOT NULL"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""folder_name_index ON folder (name) "");
		execSQL(""CREATE TABLE IF NOT EXISTS book ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""pathname VARCHAR NOT NULL,"" +
				""folder_fk INTEGER REFERENCES folder (id),"" +
				""filename VARCHAR NOT NULL,"" +
				""arcname VARCHAR,"" +
				""title VARCHAR COLLATE NOCASE,"" +
				""series_fk INTEGER REFERENCES series (id),"" +
				""series_number INTEGER,"" +
				""format INTEGER,"" +
				""filesize INTEGER,"" +
				""arcsize INTEGER,"" +
				""create_time INTEGER,"" +
				""last_access_time INTEGER, "" +
				""flags INTEGER DEFAULT 0"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_folder_index ON book (folder_fk) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_pathname_index ON book (pathname) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_filename_index ON book (filename) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_title_index ON book (title) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_last_access_time_index ON book (last_access_time) "");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
				""book_title_index ON book (title) "");
		execSQL(""CREATE TABLE IF NOT EXISTS book_author ("" +
				""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
				""author_fk INTEGER NOT NULL REFERENCES author (id),"" +
				""PRIMARY KEY (book_fk, author_fk)"" +
				"")"");
		execSQL(""CREATE UNIQUE INDEX IF NOT EXISTS "" +
				""author_book_index ON book_author (author_fk, book_fk) "");
		execSQL(""CREATE TABLE IF NOT EXISTS bookmark ("" +
				""id INTEGER PRIMARY KEY AUTOINCREMENT,"" +
				""book_fk INTEGER NOT NULL REFERENCES book (id),"" +
				""type INTEGER NOT NULL DEFAULT 0,"" +
				""percent INTEGER DEFAULT 0,"" +
				""shortcut INTEGER DEFAULT 0,"" +
				""time_stamp INTEGER DEFAULT 0,"" +
				""start_pos VARCHAR NOT NULL,"" +
				""end_pos VARCHAR,"" +
				""title_text VARCHAR,"" +
				""pos_text VARCHAR,"" +
				""comment_text VARCHAR"" +
				"")"");
		execSQL(""CREATE INDEX IF NOT EXISTS "" +
		""bookmark_book_index ON bookmark (book_fk) "");
		execSQL(COVERPAGE_SCHEMA);
		int currentVersion = mDB.getVersion();
		// version 1 updates ====================================================================
		if ( currentVersion<1 )
			execSQLIgnoreErrors(""ALTER TABLE bookmark ADD COLUMN shortcut INTEGER DEFAULT 0"");
		if ( currentVersion<3 )
			execSQLIgnoreErrors(COVERPAGE_SCHEMA);
		if ( currentVersion<4 )
			execSQLIgnoreErrors(""ALTER TABLE book ADD COLUMN flags INTEGER DEFAULT 0"");
		// version 2 updates ====================================================================
		// TODO: add more updates here
		// set current version
		if ( currentVersion<DB_VERSION )
			mDB.setVersion(DB_VERSION);
		return true;
	}
	
	public CRDB( File dbfile )
	{
		open(dbfile);
		updateSchema();
		dumpStatistics();
	}
	
	public boolean findByPathname( FileInfo fileInfo )
	{
		return findBy( fileInfo, ""pathname"", fileInfo.getPathName());
	}

	public boolean findById( FileInfo fileInfo )
	{
		return findBy( fileInfo, ""b.id"", fileInfo.id);
	}

	private static final String READ_BOOKMARK_SQL = 
		""SELECT "" +
		""id, type, percent, shortcut, time_stamp, "" + 
		""start_pos, end_pos, title_text, pos_text, comment_text "" +
		""FROM bookmark b "";
	private void readBookmarkFromCursor( Bookmark v, Cursor rs )
	{
		int i=0;
		v.setId( rs.getLong(i++) );
		v.setType( (int)rs.getLong(i++) );
		v.setPercent( (int)rs.getLong(i++) );
		v.setShortcut( (int)rs.getLong(i++) );
		v.setTimeStamp( rs.getLong(i++) );
		v.setStartPos( rs.getString(i++) );
		v.setEndPos( rs.getString(i++) );
		v.setTitleText( rs.getString(i++) );
		v.setPosText( rs.getString(i++) );
		v.setCommentText( rs.getString(i++) );
		v.setModified(false);
	}
	synchronized public boolean findBy( Bookmark v, String condition )
	{
		boolean found = false;
		Cursor rs = null;
		try {
			condition = "" WHERE "" + condition;
			rs = mDB.rawQuery(READ_BOOKMARK_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				readBookmarkFromCursor( v, rs );
				found = true;
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	synchronized public boolean load( ArrayList<Bookmark> list, String condition )
	{
		boolean found = false;
		Cursor rs = null;
		try {
			condition = "" WHERE "" + condition;
			rs = mDB.rawQuery(READ_BOOKMARK_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				do {
					Bookmark v = new Bookmark();
					readBookmarkFromCursor( v, rs );
					list.add(v);
					found = true;
				} while ( rs.moveToNext() );
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	private static final String READ_FILEINFO_FIELDS = 
		""b.id AS id, pathname,"" +
		""f.name as path, "" +
		""filename, arcname, title, "" +
		""(SELECT GROUP_CONCAT(a.name,'|') FROM author a JOIN book_author ba ON a.id=ba.author_fk WHERE ba.book_fk=b.id) as authors, "" +
		""s.name as series_name, "" +
		""series_number, "" +
		""format, filesize, arcsize, "" +
		""create_time, last_access_time, flags "";
	
	private static final String READ_FILEINFO_SQL = 
		""SELECT "" +
		READ_FILEINFO_FIELDS +
		""FROM book b "" +
		""LEFT JOIN series s ON s.id=b.series_fk "" +
		""LEFT JOIN folder f ON f.id=b.folder_fk "";
	private void readFileInfoFromCursor( FileInfo fileInfo, Cursor rs )
	{
		int i=0;
		fileInfo.id = rs.getLong(i++);
		String pathName = rs.getString(i++);
		String[] parts = FileInfo.splitArcName(pathName);
		fileInfo.pathname = parts[0];
		fileInfo.path = rs.getString(i++);
		fileInfo.filename = rs.getString(i++);
		fileInfo.arcname = rs.getString(i++);
		fileInfo.title = rs.getString(i++);
		fileInfo.authors = rs.getString(i++);
		fileInfo.series = rs.getString(i++);
		fileInfo.seriesNumber = rs.getInt(i++);
		fileInfo.format = DocumentFormat.byId(rs.getInt(i++));
		fileInfo.size = rs.getInt(i++);
		fileInfo.arcsize = rs.getInt(i++);
		fileInfo.createTime = rs.getInt(i++);
		fileInfo.lastAccessTime = rs.getInt(i++);
		fileInfo.flags = rs.getInt(i++);
		fileInfo.isArchive = fileInfo.arcname!=null; 
	}
	
	
	synchronized public boolean findBy( FileInfo fileInfo, String fieldName, Object fieldValue )
	{
		String condition;
		StringBuilder buf = new StringBuilder("" WHERE "");
		buf.append(fieldName);
		if ( fieldValue==null ) {
			buf.append("" IS NULL "");
		} else {
			buf.append(""="");
			DatabaseUtils.appendValueToSql(buf, fieldValue);
			buf.append("" "");
		}
		condition = buf.toString();
		boolean found = false;
		Cursor rs = null;
		try { 
			rs = mDB.rawQuery(READ_FILEINFO_SQL +
					condition, null);
			if ( rs.moveToFirst() ) {
				readFileInfoFromCursor( fileInfo, rs );
				found = true;
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return found;
	}

	synchronized public FileInfo[] findByPatterns( int maxCount, String author, String title, String series, String filename )
	{
		ArrayList<FileInfo> list = new ArrayList<FileInfo>();
		
		StringBuilder buf = new StringBuilder();
		if ( author!=null && author.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.id IN (SELECT ba.book_fk FROM author a JOIN book_author ba ON a.id=ba.author_fk WHERE a.name LIKE "");
			DatabaseUtils.appendValueToSql(buf, author);
			buf.append("") "");
		}
		if ( series!=null && series.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.series_fk IN (SELECT s.name FROM series s WHERE s.name LIKE "");
			DatabaseUtils.appendValueToSql(buf, series);
			buf.append("") "");
		}
		if ( title!=null && title.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.title LIKE "");
			DatabaseUtils.appendValueToSql(buf, title);
			buf.append("" "");
		}
		if ( filename!=null && filename.length()>0 ) {
			if ( buf.length()>0 )
				buf.append("" AND "");
			buf.append("" b.filename LIKE "");
			DatabaseUtils.appendValueToSql(buf, filename);
			buf.append("" "");
		}
		if ( buf.length()==0 )
			return new FileInfo[0];
		
		String condition = "" WHERE "" + buf.toString();
		String sql = READ_FILEINFO_SQL + condition;
		Log.d(""cr3"", ""sql: "" + sql );
		if ( condition.length()==0 )
			return new FileInfo[] { };
		Cursor rs = null;
		try { 
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				int count = 0;
				do {
					FileInfo fi = new FileInfo(); 
					readFileInfoFromCursor( fi, rs );
					list.add(fi);
					count++;
				} while ( count<maxCount && rs.moveToNext() );
			}
		} finally {
			if ( rs!=null )
				rs.close();
		}
		return list.toArray(new FileInfo[list.size()]);
	}
	
	synchronized public boolean findRecentBooks( ArrayList<FileInfo> list, int maxCount, int limit )
	{
		String sql = READ_FILEINFO_SQL + "" WHERE last_access_time>0 ORDER BY last_access_time DESC LIMIT "" + limit;
		Cursor rs = null;
		boolean found = false;
		try {
			rs = mDB.rawQuery(sql, null);
			if ( rs.moveToFirst() ) {
				do {
					FileInfo fileInfo = new FileInfo();
					readFileInfoFromCursor( fileInfo, rs );
					if ( !fileInfo.fileExists() )
						continue;
					list.add(fileInfo);
					found = true;
					if ( list.size()>maxCount )
						break;
				} while (rs.moveToNext());
			}
		} finally {
			rs.close();
		}
		return found;
	}
	
	private Long longQuery( String sql )
	{
		SQLiteStatement stmt = mDB.compileStatement(sql);
		try {
			return stmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found or error
			return null;
		}
	}
	
	public void saveBookCoverpage( long bookId, byte[] data )
	{
		if ( data==null )
			return;
		SQLiteStatement stmt = null;
		try { 
			Long existing = longQuery(""SELECT book_fk FROM coverpage WHERE book_fk="" + bookId);
			if ( existing==null ) {
				stmt = mDB.compileStatement(""INSERT INTO coverpage (book_fk, imagedata) VALUES (""+bookId+"", ?)"");
				stmt.bindBlob(1, data);
				stmt.execute();
				Log.v(""cr3"", ""db: saved "" + data.length + "" bytes of cover page for book "" + bookId);
			}
		} catch ( Exception e ) {
			Log.e(""cr3"", ""Exception while trying to save cover page to DB: "" + e.getMessage() );
		} finally {
			if ( stmt!=null )
				stmt.close();
		}
	}
	public byte[] loadBookCoverpage( long bookId )
	{
		Cursor rs = null;
		try {
			rs = mDB.rawQuery(""SELECT imagedata FROM coverpage WHERE book_fk="" + bookId, null);
			if ( rs.moveToFirst() ) {
				return rs.getBlob(0);
			}
			return null;
		} catch ( SQLException e ) {
			Log.e(""cr3"", ""error while reading coverpage for book "" + bookId + "": "" + e.getMessage());
			return null;
		} finally {
			if ( rs!=null )
				rs.close();
		}
	}
	
	public void dumpStatistics()
	{
		Log.i(""cr3db"", ""DB: "" + longQuery(""SELECT count(*) FROM author"") + "" authors, ""
				 + longQuery(""SELECT count(*) FROM series"") + "" series, ""
				 + longQuery(""SELECT count(*) FROM book"") + "" books, ""
				 + longQuery(""SELECT count(*) FROM bookmark"") + "" bookmarks""
				 + longQuery(""SELECT count(*) FROM folder"") + "" folders""
				 + longQuery(""SELECT count(*) FROM coverpage"") + "" coverpages""
				 );
	}

	private SQLiteStatement seriesStmt;
	private SQLiteStatement seriesSelectStmt;
	private HashMap<String,Long> seriesCache = new HashMap<String,Long>();
	synchronized public Long getSeriesId( String seriesName )
	{
		if ( seriesName==null || seriesName.trim().length()==0 )
			return null;
		Long id = seriesCache.get(seriesName); 
		if ( id!=null )
			return id;
		if ( seriesSelectStmt==null )
			seriesSelectStmt = mDB.compileStatement(""SELECT id FROM series WHERE name=?"");
		try {
			seriesSelectStmt.bindString(1, seriesName);
			return seriesSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( seriesStmt==null )
			seriesStmt = mDB.compileStatement(""INSERT INTO series (id, name) VALUES (NULL,?)"");
		seriesStmt.bindString(1, seriesName);
		id = seriesStmt.executeInsert();
		seriesCache.put( seriesName, id );
		return id;
	}
	
	private SQLiteStatement folderStmt;
	private SQLiteStatement folderSelectStmt;
	private HashMap<String,Long> folderCache = new HashMap<String,Long>();
	synchronized public Long getFolderId( String folderName )
	{
		if ( folderName==null || folderName.trim().length()==0 )
			return null;
		Long id = folderCache.get(folderName); 
		if ( id!=null )
			return id;
		if ( folderSelectStmt==null )
			folderSelectStmt = mDB.compileStatement(""SELECT id FROM folder WHERE name=?"");
		try {
			folderSelectStmt.bindString(1, folderName);
			return folderSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( folderStmt==null )
			folderStmt = mDB.compileStatement(""INSERT INTO folder (id, name) VALUES (NULL,?)"");
		folderStmt.bindString(1, folderName);
		id = folderStmt.executeInsert();
		folderCache.put( folderName, id );
		return id;
	}
	
	private SQLiteStatement authorStmt;
	private SQLiteStatement authorSelectStmt;
	private HashMap<String,Long> authorCache = new HashMap<String,Long>();
	synchronized public Long getAuthorId( String authorName )
	{
		if ( authorName==null || authorName.trim().length()==0 )
			return null;
		Long id = authorCache.get(authorName); 
		if ( id!=null )
			return id;
		if ( authorSelectStmt==null )
			authorSelectStmt = mDB.compileStatement(""SELECT id FROM author WHERE name=?"");
		try {
			authorSelectStmt.bindString(1, authorName);
			return authorSelectStmt.simpleQueryForLong();
		} catch ( Exception e ) {
			// not found
		}
		if ( authorStmt==null )
			authorStmt = mDB.compileStatement(""INSERT INTO author (id, name) VALUES (NULL,?)"");
		authorStmt.bindString(1, authorName);
		id = authorStmt.executeInsert();
		authorCache.put( authorName, id );
		return id;
	}
	synchronized public Long[] getAuthorIds( String authorNames )
	{
		if ( authorNames==null || authorNames.trim().length()==0 )
			return null;
		String[] names = authorNames.split(""\\|"");
		if ( names==null || names.length==0 )
			return null;
		ArrayList<Long> ids = new ArrayList<Long>(names.length);
		for ( String name : names ) {
			Long id = getAuthorId(name);
			if ( id!=null )
				ids.add(id);
		}
		if ( ids.size()>0 )
			return ids.toArray(new Long[ids.size()]);
		return null;
	}
	
	synchronized public void saveBookAuthors( Long bookId, Long[] authors)
	{
		if ( authors==null || authors.length==0 )
			return;
		String insertQuery = ""INSERT OR IGNORE INTO book_author (book_fk,author_fk) VALUES "";
		for ( Long id : authors ) {
			String sql = insertQuery + ""("" + bookId + "","" + id + "")""; 
			//Log.v(""cr3"", ""executing: "" + sql);
			mDB.execSQL(sql);
		}
	}

	public static boolean eq(String s1, String s2)
	{
		if ( s1!=null )
			return s1.equals(s2);
		return s2==null;
	}
	
	public class QueryHelper {
		String tableName;
		QueryHelper(String tableName)
		{
			this.tableName = tableName;
		}
		ArrayList<String> fields = new ArrayList<String>(); 
		ArrayList<Object> values = new ArrayList<Object>();
		QueryHelper add(String fieldName, int value, int oldValue )
		{
			if ( value!=oldValue ) {
				fields.add(fieldName);
				values.add(Long.valueOf(value));
			}
			return this;
		}
		QueryHelper add(String fieldName, Long value, Long oldValue )
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		QueryHelper add(String fieldName, String value, String oldValue)
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		QueryHelper add(String fieldName, Double value, Double oldValue)
		{
			if ( value!=null && (oldValue==null || !oldValue.equals(value))) {
				fields.add(fieldName);
				values.add(value);
			}
			return this;
		}
		Long insert()
		{
			if ( fields.size()==0 )
				return null;
			StringBuilder valueBuf = new StringBuilder();
			try {
				String ignoreOption = """"; //""OR IGNORE "";
				StringBuilder buf = new StringBuilder(""INSERT "" + ignoreOption + "" INTO "");
				buf.append(tableName);
				buf.append("" (id"");
				for ( String field : fields ) {
					buf.append("","");
					buf.append(field);
				}
				buf.append("") VALUES (NULL"");
				for ( String field : fields ) {
					buf.append("","");
					buf.append(""?"");
				}
				buf.append("")"");
				String sql = buf.toString();
				Log.d(""cr3db"", ""going to execute "" + sql);
				SQLiteStatement stmt = null;
				Long id = null;
				try {
					stmt = mDB.compileStatement(sql);
					for ( int i=1; i<=values.size(); i++ ) {
						Object v = values.get(i-1);
						valueBuf.append(v!=null ? v.toString() : ""null"");
						valueBuf.append("","");
						if ( v==null )
							stmt.bindNull(i);
						else if (v instanceof String)
							stmt.bindString(i, (String)v);
						else if (v instanceof Long)
							stmt.bindLong(i, (Long)v);
						else if (v instanceof Double)
							stmt.bindDouble(i, (Double)v);
					}
					id = stmt.executeInsert();
					Log.d(""cr3db"", ""added book, id="" + id + "", query="" + sql);
				} finally {
					if ( stmt!=null )
						stmt.close();
				}
				return id;
			} catch ( Exception e ) {
				Log.e(""cr3db"", ""insert failed: "" + e.getMessage());
				Log.e(""cr3db"", ""values: "" + valueBuf.toString());
				return null;
			}
		}
		boolean update( Long id )
		{
			if ( fields.size()==0 )
				return false;
			StringBuilder buf = new StringBuilder(""UPDATE "");
			buf.append(tableName);
			buf.append("" SET "");
			boolean first = true;
			for ( String field : fields ) {
				if ( !first )
					buf.append("","");
				buf.append(field);
				buf.append(""=?"");
				first = false;
			}
			buf.append("" WHERE id="" + id );
			mDB.execSQL(buf.toString(), values.toArray());
			return true;
		}
		Long fromFormat( DocumentFormat f )
		{
			if ( f==null )
				return null;
			return (long)f.ordinal();
		}
		QueryHelper( FileInfo newValue, FileInfo oldValue )
		{
			this(""book"");
			add(""pathname"", newValue.getPathName(), oldValue.getPathName());
			add(""folder_fk"", getFolderId(newValue.path), getFolderId(oldValue.path));
			add(""filename"", newValue.filename, oldValue.filename);
			add(""arcname"", newValue.arcname, oldValue.arcname);
			add(""title"", newValue.title, oldValue.title);
			add(""series_fk"", getSeriesId(newValue.series), getSeriesId(oldValue.series));
			add(""series_number"", (long)newValue.seriesNumber, (long)oldValue.seriesNumber);
			add(""format"", fromFormat(newValue.format), fromFormat(oldValue.format));
			add(""filesize"", (long)newValue.size, (long)oldValue.size);
			add(""arcsize"", (long)newValue.arcsize, (long)oldValue.arcsize);
			add(""last_access_time"", (long)newValue.lastAccessTime, (long)oldValue.lastAccessTime);
			add(""create_time"", (long)newValue.createTime, (long)oldValue.createTime);
			add(""flags"", (long)newValue.flags, (long)oldValue.flags);
		}
		QueryHelper( Bookmark newValue, Bookmark oldValue, long bookId )
		{
			this(""bookmark"");
			add(""book_fk"", bookId, oldValue.getId()!=null ? bookId : null);
			add(""type"", newValue.getType(), oldValue.getType());
			add(""percent"", newValue.getPercent(), oldValue.getPercent());
			add(""shortcut"", newValue.getShortcut(), oldValue.getShortcut());
			add(""start_pos"", newValue.getStartPos(), oldValue.getStartPos());
			add(""end_pos"", newValue.getEndPos(), oldValue.getEndPos());
			add(""title_text"", newValue.getTitleText(), oldValue.getTitleText());
			add(""pos_text"", newValue.getPosText(), oldValue.getPosText());
			add(""comment_text"", newValue.getCommentText(), oldValue.getCommentText());
			add(""time_stamp"", newValue.getTimeStamp(), oldValue.getTimeStamp());
		}
	}

	/**
	 * @param fileList
	 * @param maxCount
	 * @return
	 */
	public ArrayList<BookInfo> loadRecentBooks( HashMap<String, FileInfo> fileList, int maxCount )
	{
		ArrayList<FileInfo> list = new ArrayList<FileInfo>();
		findRecentBooks( list, maxCount, maxCount*10 );
		ArrayList<BookInfo> res = new ArrayList<BookInfo>(list.size());
		for ( FileInfo file : list ) {
			fileList.put(file.getPathName(), file);
			BookInfo item = new BookInfo( file );
			ArrayList<Bookmark> bookmarks = new ArrayList<Bookmark>(); 
			if ( load( bookmarks, ""book_fk="" + file.id + "" ORDER BY type"" ) ) {
				item.setBookmarks(bookmarks);
			}
			res.add(item);
		}
		return res;
	}

	synchronized public boolean save( BookInfo bookInfo )
	{
		Log.d(""cr3db"", ""saving Book info id="" + bookInfo.getFileInfo().id);
		if ( mDB==null ) {
			Log.e(""cr3db"", ""cannot save book info : DB is closed"");
			return false;
		}
		boolean res = save(bookInfo.getFileInfo());
		for ( int i=0; i<bookInfo.getBookmarkCount(); i++ ) {
			 Bookmark bmk  = bookInfo.getBookmark(i);
			 if (bmk.isModified())
			 	res = save(bmk, bookInfo.getFileInfo().id) || res;
		}
		if ( bookInfo.getLastPosition()!=null && bookInfo.getLastPosition().isModified() )
			res = save(bookInfo.getLastPosition(), bookInfo.getFileInfo().id) || res;
		return res;
	}

	private boolean save( Bookmark v, long bookId )
	{
		if ( !v.isModified() )
			return false;
		Log.d(""cr3db"", ""saving bookmark id="" + v.getId() + "", bookId="" + bookId + "", pos="" + v.getStartPos());
		if ( v.getId()!=null ) {
			// update
			Bookmark oldValue = new Bookmark();
			oldValue.setId(v.getId());
			if ( findBy(oldValue, ""book_fk="" + bookId + "" AND id="" + v.getId()) ) {
				// found, updating
				QueryHelper h = new QueryHelper(v, oldValue, bookId);
				h.update(v.getId());
			} else {
				oldValue = new Bookmark();
				QueryHelper h = new QueryHelper(v, oldValue, bookId);
				v.setId( h.insert() );
			}
		} else {
			Bookmark oldValue = new Bookmark();
			QueryHelper h = new QueryHelper(v, oldValue, bookId);
			v.setId( h.insert() );
		}
		v.setModified(false);
		return true;
	}

	synchronized public void deleteRecentPosition( FileInfo fileInfo )
	{
		if ( fileInfo==null || fileInfo.id==0 )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE book_fk="" + fileInfo.id + "" AND type=0"");
		execSQLIgnoreErrors(""UPDATE book SET last_access_time=0 WHERE id="" + fileInfo.id);
	}
	
	synchronized public void deleteBookmark( Bookmark bm )
	{
		if ( bm.getId()==null )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE id="" + bm.getId());
	}
	
	synchronized public void deleteBook( FileInfo fileInfo )
	{
		if ( fileInfo==null || fileInfo.id==0 )
			return;
		execSQLIgnoreErrors(""DELETE FROM bookmark WHERE book_fk="" + fileInfo.id);
		execSQLIgnoreErrors(""DELETE FROM coverpage WHERE book_fk="" + fileInfo.id);
		execSQLIgnoreErrors(""DELETE FROM book WHERE id="" + fileInfo.id);
	}
	
	synchronized public boolean save( FileInfo fileInfo )
	{
		boolean authorsChanged = true;
		if ( fileInfo.id!=null ) {
			// update
			FileInfo oldValue = new FileInfo();
			oldValue.id = fileInfo.id;
			if ( findById(oldValue) ) {
				// found, updating
				QueryHelper h = new QueryHelper(fileInfo, oldValue);
				h.update(fileInfo.id);
				authorsChanged = !eq(fileInfo.authors, oldValue.authors);
			} else {
				oldValue = new FileInfo();
				QueryHelper h = new QueryHelper(fileInfo, oldValue);
				fileInfo.id = h.insert();
			}
		} else {
			FileInfo oldValue = new FileInfo();
			QueryHelper h = new QueryHelper(fileInfo, oldValue);
			fileInfo.id = h.insert();
		}
		fileInfo.setModified(false);
		if ( fileInfo.id!=null ) {
			if ( authorsChanged ) {
				Long[] authorIds = getAuthorIds(fileInfo.authors);
				saveBookAuthors(fileInfo.id, authorIds);
			}
			return true;
		}
		return false;
	}

    public void flush()
    {
        Log.i(""cr3db"", ""Flushing DB"");
        if ( seriesStmt!=null) {
            seriesStmt.close();
            seriesStmt = null;
        }
        if ( authorStmt!=null) {
            authorStmt.close();
            authorStmt = null;
        }
        if ( seriesSelectStmt!=null) {
            seriesSelectStmt.close();
            seriesSelectStmt = null;
        }
        if ( authorSelectStmt!=null) {
            authorSelectStmt.close();
            authorSelectStmt = null;
        }
        SQLiteDatabase.releaseMemory();
    }
    
	public void close()
	{
	    flush();
		Log.i(""cr3db"", ""Closing DB"");
		if ( mDB!=null && mDB.isOpen() ) {
			mDB.close();
			mDB = null;
		}
		
	}
}
",True,24,30,4,17,1,4,6,4,L1
33,org.coolreader.crengine.Properties.java,"package org.coolreader.crengine;

import java.util.Map;

public class Properties extends java.util.Properties {
	public Properties()
	{
		super();
	}
	public void setAll(java.util.Properties props)
	{
        for ( Map.Entry<Object, Object> entry : props.entrySet() ) {
    		setProperty((String)entry.getKey(), (String)entry.getValue());
        }
	}
	public Properties(java.util.Properties props)
	{
		setAll(props);
	}
	private static int revBytes( int color )
	{
		return color & 0xFFFFFF;
		//return ((color & 0xFF)<<16)|((color & 0xFF00)<<0)|((color & 0xFF0000)>>16);
	}
	public void setColor( String key, int color )
	{
		color &= 0xFFFFFF;
		color = revBytes(color);
		String value = Integer.toHexString(color);
		while ( value.length()<6 )
			value = ""0"" + value;
		value = ""0x"" + value;
		setProperty(key, value);
	}
	public int getColor( String key, int defColor )
	{
		defColor = revBytes(defColor);
		String value = getProperty(key);
		try {
			if ( value!=null && value.length()>2 && value.startsWith(""0x"") ) {
				int cl = Integer.parseInt(value.substring(2), 16);
				cl = revBytes(cl);
				return cl | 0xFF000000;
			}
		} catch ( Exception e ) {
		}
		return revBytes(defColor) | 0xFF000000;
	}
	public void setInt( String key, int v )
	{
		String value = String.valueOf(v);
		setProperty(key, value);
	}
	public int getInt( String key, int def )
	{
		String value = getProperty(key);
		int res = def;
		try {
			if ( value!=null )
				res = Integer.valueOf(value);
		} catch ( Exception e ) {
		}
		return res;
	}
	public void setBool( String key, boolean value )
	{
		setProperty( key, value ? ""1"" : ""0"" );
	}
	public boolean getBool( String key, boolean defaultValue )
	{
		String value = getProperty(key);
		if ( value==null )
			return defaultValue;
		if ( value.equals(""1"") || value.equals(""true"") || value.equals(""yes"") )
			return true;
		if ( value.equals(""0"") || value.equals(""false"") || value.equals(""no"") )
			return false;
		return defaultValue;
	}

	public void applyDefault( String prop, String defValue )
	{
		if ( getProperty(prop)==null )
			setProperty(prop, defValue);
	}
	
	public void applyDefault( String prop, int defValue )
	{
		if ( getProperty(prop)==null )
			setInt(prop, defValue);
	}
	
	public static boolean eq(Object obj1, Object obj2)
	{
		if ( obj1==null && obj2==null )
			return true;
		if ( obj1==null || obj2==null )
			return false;
		return obj1.equals(obj2);
	}

	public Properties diff( Properties oldValue )
	{
		Properties res = new Properties();
        for ( Map.Entry<Object, Object> entry : entrySet() ) {
        	if ( !oldValue.containsKey(entry.getKey()) || !eq(entry.getValue(), oldValue.get(entry.getKey()))) {
        		res.setProperty( (String)entry.getKey(), (String)entry.getValue() );
        	}
        }
        return res;
	}
}
",True,23,26,4,17,0,0,6,0,L1
34,org.coolreader.crengine.BackgroundThread.java,"package org.coolreader.crengine;

import java.util.ArrayList;
import java.util.concurrent.Callable;
import java.util.concurrent.Executor;

import org.coolreader.crengine.ReaderView.Sync;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.view.View;

/**
 * Allows running tasks either in background thread or in GUI thread.
 */
public class BackgroundThread extends Thread {
	
	private final static Object LOCK = new Object(); 

	private static BackgroundThread instance;
	
	// singleton
	public static BackgroundThread instance()
	{
		if ( instance==null ) {
			synchronized( LOCK ) {
				if ( instance==null )
					instance = new BackgroundThread(); 
			}
		}
		return instance;
	}

	public final static Executor backgroundExecutor = new Executor() {
		public void execute(Runnable task) {
			instance().postBackground(task);
		}
	};
	
	public final static Executor guiExecutor = new Executor() {
		public void execute(Runnable task) {
			instance().postGUI(task);
		}
	};
	
	public final static boolean CHECK_THREAD_CONTEXT = true; 

	/**
	 * Throws exception if not in background thread.
	 */
	public final static void ensureBackground()
	{
		if ( CHECK_THREAD_CONTEXT && !instance().isBackgroundThread() ) {
			L.e(""not in background thread"", new Exception(""ensureInBackgroundThread() is failed""));
			throw new RuntimeException(""ensureInBackgroundThread() is failed"");
		}
	}
	
	/**
	 * Throws exception if not in GUI thread.
	 */
	public final static void ensureGUI()
	{
		if ( CHECK_THREAD_CONTEXT && instance().isBackgroundThread() ) {
			L.e(""not in GUI thread"", new Exception(""ensureGUI() is failed""));
			throw new RuntimeException(""ensureGUI() is failed"");
		}
	}
	
	// 
	private Handler handler;
	private ArrayList<Runnable> posted = new ArrayList<Runnable>();
	private View guiTarget;
	private ArrayList<Runnable> postedGUI = new ArrayList<Runnable>();

	/**
	 * Set view to post GUI tasks to.
	 * @param guiTarget is view to post GUI tasks to.
	 */
	public void setGUI( View guiTarget ) {
		this.guiTarget = guiTarget;
		if ( guiTarget!=null ) {
			// forward already posted events
			synchronized(postedGUI) {
				L.d(""Engine.setGUI: "" + postedGUI.size() + "" posted tasks to copy"");
				for ( Runnable task : postedGUI )
					guiTarget.post( task );
			}
		}
	}

	/**
	 * Create background thread executor.
	 */
	private BackgroundThread() {
		super();
		setName(""BackgroundThread"" + Integer.toHexString(hashCode()));
		start();
	}

	@Override
	public void run() {
		L.i(""Entering background thread"");
		Looper.prepare();
		handler = new Handler() {
			public void handleMessage( Message message )
			{
				L.d(""message: "" + message);
			}
		};
		L.i(""Background thread handler is created"");
		synchronized(posted) {
			for ( Runnable task : posted ) {
				L.i(""Copying posted bg task to handler : "" + task);
				handler.post(task);
			}
			posted.clear();
		}
		Looper.loop();
		handler = null;
		L.i(""Exiting background thread"");
	}

	private final static boolean USE_LOCK = false;
	private Runnable guard( final Runnable r )
	{
		if ( !USE_LOCK )
			return r;
		return new Runnable() {
			public void run() {
				synchronized (LOCK) {
					r.run();
				}
			}
		};
	}

	/**
	 * Post runnable to be executed in background thread.
	 * @param task is runnable to execute in background thread.
	 */
	public void postBackground( Runnable task )
	{
		if ( mStopped ) {
			L.i(""Posting task "" + task + "" to GUI queue since background thread is stopped"");
			postGUI( task );
			return;
		}
		task = guard(task);
		if ( handler==null ) {
			synchronized(posted) {
				L.i(""Adding task "" + task + "" to posted list since handler is not yet created"");
				posted.add(task);
			}
		} else {
			handler.post(task);
		}
	}

	/**
	 * Post runnable to be executed in GUI thread
	 * @param task is runnable to execute in GUI thread
	 */
	public void postGUI( Runnable task )
	{
		postGUI(task, 0);
	}

	/**
	 * Post runnable to be executed in GUI thread
	 * @param task is runnable to execute in GUI thread
	 * @param delay is delay before running task, in millis
	 */
	public void postGUI( Runnable task, long delay )
	{
		if ( guiTarget==null ) {
			synchronized( postedGUI ) {
				postedGUI.add(task);
			}
		} else {
			if ( delay>0 )
				guiTarget.postDelayed(task, delay);
			else
				guiTarget.post(task);
		}
	}

	/**
	 * Run task instantly if called from the same thread, or post it through message queue otherwise.
	 * @param task is task to execute
	 */
	public void executeBackground( Runnable task )
	{
		task = guard(task);
		if ( isBackgroundThread() || mStopped )
			task.run(); // run in this thread
		else 
			postBackground(task); // post
	}

	// assume there are only two threads: main GUI and background
	public boolean isGUIThread()
	{
		return !isBackgroundThread();
	}

	public boolean isBackgroundThread()
	{
		return ( Thread.currentThread()==this );
	}

	public void executeGUI( Runnable task )
	{
		//Handler guiHandler = guiTarget.getHandler();
		//if ( guiHandler!=null && guiHandler.getLooper().getThread()==Thread.currentThread() )
		if ( isGUIThread() )
			task.run(); // run in this thread
		else
			postGUI(task);
	}

    public <T> Callable<T> guard( final Callable<T> task )
    {
    	return new Callable<T>() {
    		public T call() throws Exception {
    			return task.call();
    		}
    	};
    }
    
    
    /**
     * Waits until all pending background tasks are executed.
     */
    public void syncWithBackground() {
    	callBackground( new Callable<Integer>() {
			@Override
			public Integer call() throws Exception {
				return null;
			}
    	});
    }
	
    public <T> T callBackground( final Callable<T> srcTask )
    {
    	final Callable<T> task = srcTask; //guard(srcTask);
    	if ( isBackgroundThread() ) {
    		try {
    			return task.call();
    		} catch ( Exception e ) {
    			return null;
    		}
    	}
    	//L.d(""executeSync called"");
    	if(DBG) L.d(""callBackground : posting Background task "" + Thread.currentThread().getName());
    	final Sync<T> sync = new Sync<T>();
    	postBackground( new Runnable() {
    		public void run() {
    			if(DBG) L.d(""callBackground : inside background thread "" + Thread.currentThread().getName());
    			try {
    				sync.set( task.call() );
    			} catch ( Exception e ) {
    				sync.set( null );
    			}
    		}
    	});
    	if(DBG) L.d(""callBackground : calling get "" + Thread.currentThread().getName());
    	T res = sync.get();
    	if(DBG) L.d(""callBackground : returned from get "" + Thread.currentThread().getName());
    	//L.d(""executeSync done"");
    	return res;
    }
	
    private final static boolean DBG = false; 
    
    public <T> T callGUI( final Callable<T> task )
    {
    	if ( isGUIThread() ) {
    		try {
    			return task.call();
    		} catch ( Exception e ) {
    			return null;
    		}
    	}
    	if(DBG) L.d(""callGUI : posting GUI task "" + Thread.currentThread().getName());
    	final Sync<T> sync = new Sync<T>();
    	postGUI( new Runnable() {
    		public void run() {
    			if(DBG) L.d(""callGUI : inside GUI thread "" + Thread.currentThread().getName());
    	    	T result = null;
    			try {
        	    	L.d(""callGUI : calling source callable "" + Thread.currentThread().getName());
    				result = task.call();
    			} catch ( Exception e ) {
    				if(DBG) L.e(""exception in postGUI"", e);
    			}
    			try {
    				if(DBG) L.d(""callGUI : calling sync.set "" + Thread.currentThread().getName());
    				sync.set( result );
    				if(DBG) L.d(""callGUI : returned from sync.set "" + Thread.currentThread().getName());
    			} catch ( Exception e ) {
    				if(DBG) L.e(""exception in postGUI"", e);
    			}
    		}
    	});
    	if(DBG) L.d(""callGUI : calling get "" + Thread.currentThread().getName());
    	T res = sync.get();
    	if(DBG) L.d(""callGUI : returned from get "" + Thread.currentThread().getName());
    	return res;
    }
	
	private boolean mStopped = false;
	
	public void waitForBackgroundCompletion()
	{
		callBackground(new Callable<Object>() {
			public Object call() {
				return null;
			}
		});
	}
	
//	public void quit()
//	{
//		callBackground(new Callable<Object>() {
//			public Object call() {
//				mStopped = true;
//				Looper.myLooper().quit();
//				return null;
//			}
//		});
//	}
}
",True,10,38,0,0,3,27,8,2,L1
35,org.coolreader.crengine.BookmarkEditDialog.java,"package org.coolreader.crengine;

import org.coolreader.CoolReader;
import org.coolreader.R;

import android.view.LayoutInflater;
import android.view.View;
import android.widget.CompoundButton;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.TextView;

public class BookmarkEditDialog extends BaseDialog {
	
	private final CoolReader mCoolReader;
	private final LayoutInflater mInflater;
	private final ReaderView mReaderView;
	private final Bookmark mOriginalBookmark;
	private final Bookmark mBookmark;
	private final boolean mIsNew;
	private final BookInfo mBookInfo;
	final EditText commentEdit;
	
	public BookmarkEditDialog( CoolReader activity, ReaderView readerView, BookInfo bookInfo, Bookmark bookmark, boolean isNew)
	{
		super(activity, R.string.dlg_button_ok, R.string.dlg_button_cancel, false);
		mCoolReader = activity;
		mReaderView = readerView;
		mIsNew = isNew;
		mOriginalBookmark = bookmark;
		if ( !isNew )
			mBookmark = new Bookmark(bookmark);
		else
			mBookmark = bookmark;
		mBookInfo = bookInfo;
		boolean isComment = bookmark.getType()==Bookmark.TYPE_COMMENT;
		setTitle(mCoolReader.getString( mIsNew ? R.string.dlg_bookmark_create : R.string.dlg_bookmark_edit));
		mInflater = LayoutInflater.from(getContext());
		View view = mInflater.inflate(R.layout.bookmark_edit_dialog, null);
		final RadioButton btnComment = (RadioButton)view.findViewById(R.id.rb_comment);
		final RadioButton btnCorrection = (RadioButton)view.findViewById(R.id.rb_correction);
		final TextView posLabel = (TextView)view.findViewById(R.id.lbl_position); 
		final TextView commentLabel = (TextView)view.findViewById(R.id.lbl_comment_text); 
		final EditText posEdit = (EditText)view.findViewById(R.id.position_text); 
		commentEdit = (EditText)view.findViewById(R.id.comment_edit);
		String postext = mBookmark.getPercent()/100 + ""%"";
		if ( mBookmark.getTitleText()!=null )
			postext = postext + ""  "" + mBookmark.getTitleText();
		posLabel.setText(postext);
		commentLabel.setText(isComment ? R.string.dlg_bookmark_edit_comment : R.string.dlg_bookmark_edit_correction);
		posEdit.setText(mBookmark.getPosText());
		commentEdit.setText(bookmark.getCommentText());
		if ( isNew ) {
			btnComment.setChecked(isComment);
			btnCorrection.setChecked(!isComment);
			btnComment.setOnCheckedChangeListener(new OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					if ( isChecked ) {
						mBookmark.setType(Bookmark.TYPE_COMMENT); 
						commentLabel.setText(R.string.dlg_bookmark_edit_comment); // : R.string.dlg_bookmark_edit_correction
					}
				}
			});
			btnCorrection.setOnCheckedChangeListener(new OnCheckedChangeListener() {
				@Override
				public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
					if ( isChecked ) {
						mBookmark.setType(Bookmark.TYPE_CORRECTION); 
						commentLabel.setText(R.string.dlg_bookmark_edit_correction);
						String oldText = commentEdit.getText().toString();
						if ( oldText==null || oldText.length()==0 )
							commentEdit.setText(mBookmark.getPosText());
					}
				}
			});
		} else {
			btnComment.setClickable(false);
			btnCorrection.setClickable(false);
		}
		setView( view );
	}

	@Override
	protected void onPositiveButtonClick() {
		if ( mIsNew ) {
			mBookmark.setCommentText( commentEdit.getText().toString() );
			mBookInfo.addBookmark(mBookmark);
		} else {
			if ( mOriginalBookmark.setCommentText(mBookmark.getCommentText()) )
				mOriginalBookmark.setTimeStamp(System.currentTimeMillis());
		}
		super.onPositiveButtonClick();
	}

	@Override
	protected void onNegativeButtonClick() {
		super.onNegativeButtonClick();
	}

	
}
",False,26,38,0,0,3,27,2,5,L1
36,org.coolreader.crengine.ReaderView.java,"package org.coolreader.crengine;

import java.io.File;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Callable;

import org.coolreader.CoolReader;
import org.coolreader.R;
import org.coolreader.crengine.Engine.HyphDict;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.text.ClipboardManager;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

public class ReaderView extends SurfaceView implements android.view.SurfaceHolder.Callback {

	public static final Logger log = L.create(""rv"");
	
    // additional key codes for Nook
    public static final int NOOK_KEY_PREV_LEFT = 96;
    public static final int NOOK_KEY_PREV_RIGHT = 98;
    public static final int NOOK_KEY_NEXT_LEFT = 95;
    public static final int NOOK_KEY_NEXT_RIGHT = 97;    
    public static final int NOOK_KEY_SHIFT_UP = 101;
    public static final int NOOK_KEY_SHIFT_DOWN = 100;
    
    public static final String PROP_PAGE_BACKGROUND_IMAGE       =""background.image"";
    public static final String PROP_PAGE_BACKGROUND_IMAGE_DAY   =""background.image.day"";
    public static final String PROP_PAGE_BACKGROUND_IMAGE_NIGHT =""background.image.night"";
    public static final String PROP_NIGHT_MODE              =""crengine.night.mode"";
    public static final String PROP_FONT_COLOR_DAY          =""font.color.day"";
    public static final String PROP_BACKGROUND_COLOR_DAY    =""background.color.day"";
    public static final String PROP_FONT_COLOR_NIGHT        =""font.color.night"";
    public static final String PROP_BACKGROUND_COLOR_NIGHT  =""background.color.night"";
    public static final String PROP_FONT_COLOR              =""font.color.default"";
    public static final String PROP_BACKGROUND_COLOR        =""background.color.default"";
    public static final String PROP_FONT_ANTIALIASING       =""font.antialiasing.mode"";
    public static final String PROP_FONT_FACE               =""font.face.default"";
    public static final String PROP_FONT_WEIGHT_EMBOLDEN    =""font.face.weight.embolden"";
    public static final String PROP_TXT_OPTION_PREFORMATTED =""crengine.file.txt.preformatted"";
    public static final String PROP_LOG_FILENAME            =""crengine.log.filename"";
    public static final String PROP_LOG_LEVEL               =""crengine.log.level"";
    public static final String PROP_LOG_AUTOFLUSH           =""crengine.log.autoflush"";
    public static final String PROP_FONT_SIZE               =""crengine.font.size"";
    public static final String PROP_FALLBACK_FONT_FACE      =""crengine.font.fallback.face"";
    public static final String PROP_STATUS_FONT_COLOR       =""crengine.page.header.font.color"";
    public static final String PROP_STATUS_FONT_COLOR_DAY   =""crengine.page.header.font.color.day"";
    public static final String PROP_STATUS_FONT_COLOR_NIGHT =""crengine.page.header.font.color.night"";
    public static final String PROP_STATUS_FONT_FACE        =""crengine.page.header.font.face"";
    public static final String PROP_STATUS_FONT_SIZE        =""crengine.page.header.font.size"";
    public static final String PROP_STATUS_CHAPTER_MARKS    =""crengine.page.header.chapter.marks"";
    public static final String PROP_PAGE_MARGIN_TOP         =""crengine.page.margin.top"";
    public static final String PROP_PAGE_MARGIN_BOTTOM      =""crengine.page.margin.bottom"";
    public static final String PROP_PAGE_MARGIN_LEFT        =""crengine.page.margin.left"";
    public static final String PROP_PAGE_MARGIN_RIGHT       =""crengine.page.margin.right"";
    public static final String PROP_PAGE_VIEW_MODE          =""crengine.page.view.mode""; // pages/scroll
    public static final String PROP_PAGE_ANIMATION          =""crengine.page.animation"";
    public static final String PROP_INTERLINE_SPACE         =""crengine.interline.space"";
    public static final String PROP_ROTATE_ANGLE            =""window.rotate.angle"";
    public static final String PROP_EMBEDDED_STYLES         =""crengine.doc.embedded.styles.enabled"";
    public static final String PROP_DISPLAY_INVERSE         =""crengine.display.inverse"";
//    public static final String PROP_DISPLAY_FULL_UPDATE_INTERVAL =""crengine.display.full.update.interval"";
//    public static final String PROP_DISPLAY_TURBO_UPDATE_MODE =""crengine.display.turbo.update"";
    public static final String PROP_STATUS_LINE             =""window.status.line"";
    public static final String PROP_BOOKMARK_ICONS          =""crengine.bookmarks.icons"";
    public static final String PROP_FOOTNOTES               =""crengine.footnotes"";
    public static final String PROP_SHOW_TIME               =""window.status.clock"";
    public static final String PROP_SHOW_TITLE              =""window.status.title"";
    public static final String PROP_SHOW_BATTERY            =""window.status.battery"";
    public static final String PROP_SHOW_BATTERY_PERCENT    =""window.status.battery.percent"";
    public static final String PROP_SHOW_POS_PERCENT        =""window.status.pos.percent"";
    public static final String PROP_SHOW_PAGE_COUNT         =""window.status.pos.page.count"";
    public static final String PROP_SHOW_PAGE_NUMBER        =""window.status.pos.page.number"";
    public static final String PROP_FONT_KERNING_ENABLED    =""font.kerning.enabled"";
    public static final String PROP_FLOATING_PUNCTUATION    =""crengine.style.floating.punctuation.enabled"";
    public static final String PROP_LANDSCAPE_PAGES         =""window.landscape.pages"";
    public static final String PROP_HYPHENATION_DICT        =""crengine.hyphenation.dictionary.code""; // non-crengine
    public static final String PROP_AUTOSAVE_BOOKMARKS      =""crengine.autosave.bookmarks"";

    public static final String PROP_MIN_FILE_SIZE_TO_CACHE  =""crengine.cache.filesize.min"";
    public static final String PROP_FORCED_MIN_FILE_SIZE_TO_CACHE  =""crengine.cache.forced.filesize.min"";
    public static final String PROP_PROGRESS_SHOW_FIRST_PAGE=""crengine.progress.show.first.page"";

    public static final String PROP_CONTROLS_ENABLE_VOLUME_KEYS =""app.controls.volume.keys.enabled"";
    
    public static final String PROP_APP_FULLSCREEN          =""app.fullscreen"";
    public static final String PROP_APP_BOOK_PROPERTY_SCAN_ENABLED =""app.browser.fileprops.scan.enabled"";
    public static final String PROP_APP_SHOW_COVERPAGES     =""app.browser.coverpages"";
    public static final String PROP_APP_SCREEN_ORIENTATION  =""app.screen.orientation"";
    public static final String PROP_APP_SCREEN_BACKLIGHT    =""app.screen.backlight"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_DAY   =""app.screen.backlight.day"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_NIGHT =""app.screen.backlight.night"";
    public static final String PROP_APP_DOUBLE_TAP_SELECTION     =""app.controls.doubletap.selection"";
    public static final String PROP_APP_TAP_ZONE_ACTIONS_TAP     =""app.tapzone.action.tap"";
    public static final String PROP_APP_KEY_ACTIONS_PRESS     =""app.key.action.press"";
    public static final String PROP_APP_TRACKBALL_DISABLED    =""app.trackball.disabled"";
    public static final String PROP_APP_SCREEN_BACKLIGHT_LOCK    =""app.screen.backlight.lock.enabled"";
    public static final String PROP_APP_TAP_ZONE_HILIGHT     =""app.tapzone.hilight"";
    public static final String PROP_APP_FLICK_BACKLIGHT_CONTROL = ""app.screen.backlight.control.flick"";
    public static final String PROP_APP_BOOK_SORT_ORDER = ""app.browser.sort.order"";
    public static final String PROP_APP_DICTIONARY = ""app.dictionary.current"";
    public static final String PROP_APP_SELECTION_ACTION = ""app.selection.action"";
    public static final String PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS = ""app.browser.hide.empty.folders"";
    public static final String PROP_APP_FILE_BROWSER_SIMPLE_MODE = ""app.browser.simple.mode"";

    public static final int PAGE_ANIMATION_NONE = 0;
    public static final int PAGE_ANIMATION_PAPER = 1;
    public static final int PAGE_ANIMATION_SLIDE = 2;
    public static final int PAGE_ANIMATION_SLIDE2 = 3;
    public static final int PAGE_ANIMATION_MAX = 3;
    
    public static final int SELECTION_ACTION_TOOLBAR = 0;
    public static final int SELECTION_ACTION_COPY = 1;
    public static final int SELECTION_ACTION_DICTIONARY = 2;
    public static final int SELECTION_ACTION_BOOKMARK = 3;
    
    public static final int SEL_CMD_SELECT_FIRST_SENTENCE_ON_PAGE = 1;
    public static final int SEL_CMD_NEXT_SENTENCE = 2;
    public static final int SEL_CMD_PREV_SENTENCE = 3;
    
    
    public enum ViewMode
    {
    	PAGES,
    	SCROLL
    }
    
    private ViewMode viewMode = ViewMode.PAGES;
    
    public enum ReaderCommand
    {
    	DCMD_NONE(0),
    	DCMD_REPEAT(1), // repeat last action
    	
    	//definitions from crengine/include/lvdocview.h
    	DCMD_BEGIN(100),
    	DCMD_LINEUP(101),
    	DCMD_PAGEUP(102),
    	DCMD_PAGEDOWN(103),
    	DCMD_LINEDOWN(104),
    	DCMD_LINK_FORWARD(105),
    	DCMD_LINK_BACK(106),
    	DCMD_LINK_NEXT(107),
    	DCMD_LINK_PREV(108),
    	DCMD_LINK_GO(109),
    	DCMD_END(110),
    	DCMD_GO_POS(111),
    	DCMD_GO_PAGE(112),
    	DCMD_ZOOM_IN(113),
    	DCMD_ZOOM_OUT(114),
    	DCMD_TOGGLE_TEXT_FORMAT(115),
    	DCMD_BOOKMARK_SAVE_N(116),
    	DCMD_BOOKMARK_GO_N(117),
    	DCMD_MOVE_BY_CHAPTER(118),
    	DCMD_GO_SCROLL_POS(119),
    	DCMD_TOGGLE_PAGE_SCROLL_VIEW(120),
    	DCMD_LINK_FIRST(121),
    	DCMD_ROTATE_BY(122),
    	DCMD_ROTATE_SET(123),
    	DCMD_SAVE_HISTORY(124),
    	DCMD_SAVE_TO_CACHE(125),
    	DCMD_TOGGLE_BOLD(126),
    	DCMD_SCROLL_BY(127),
    	DCMD_REQUEST_RENDER(128),
    	DCMD_GO_PAGE_DONT_SAVE_HISTORY(129),
    	DCMD_SET_INTERNAL_STYLES(130),
    	
    	// definitions from android/jni/readerview.h
    	DCMD_OPEN_RECENT_BOOK(2000),
    	DCMD_CLOSE_BOOK(2001),
    	DCMD_RESTORE_POSITION(2002),

    	// application actions
    	DCMD_RECENT_BOOKS_LIST(2003),
    	DCMD_SEARCH(2004),
    	DCMD_EXIT(2005),
    	DCMD_BOOKMARKS(2005),
    	DCMD_GO_PERCENT_DIALOG(2006),
    	DCMD_GO_PAGE_DIALOG(2007),
    	DCMD_TOC_DIALOG(2008),
    	DCMD_FILE_BROWSER(2009),
    	DCMD_OPTIONS_DIALOG(2010),
    	DCMD_TOGGLE_DAY_NIGHT_MODE(2011),
    	DCMD_READER_MENU(2012),
    	DCMD_TOGGLE_TOUCH_SCREEN_LOCK(2013),
    	DCMD_TOGGLE_SELECTION_MODE(2014),
    	DCMD_TOGGLE_ORIENTATION(2015),
    	DCMD_TOGGLE_FULLSCREEN(2016),
    	DCMD_SHOW_HOME_SCREEN(2017), // home screen activity
    	DCMD_TOGGLE_DOCUMENT_STYLES(2018),
    	DCMD_ABOUT(2019),
    	DCMD_BOOK_INFO(2020),
    	DCMD_TTS_PLAY(2021),
    	;
    	
    	private final int nativeId;
    	private ReaderCommand( int nativeId )
    	{
    		this.nativeId = nativeId;
    	}
    }
    
    private void execute( Engine.EngineTask task )
    {
    	mEngine.execute(task);
    }
    
    private void post( Engine.EngineTask task )
    {
    	mEngine.post(task);
    }
    
    private abstract class Task implements Engine.EngineTask {
    	
		public void done() {
			// override to do something useful
		}

		public void fail(Exception e) {
			// do nothing, just log exception
			// override to do custom action
			log.e(""Task "" + this.getClass().getSimpleName() + "" is failed with exception "" + e.getMessage(), e);
		}
    }
    
	static class Sync<T> extends Object {
		private volatile T result = null;
		private volatile boolean completed = false;
		public void set( T res )
		{
			log.d(""sync.set() called from "" + Thread.currentThread().getName());
			result = res;
			completed = true;
			synchronized(this) {
				notify();
			}
			log.d(""sync.set() returned from notify "" + Thread.currentThread().getName());
		}
		public T get()
		{
			log.d(""sync.get() called from "" + Thread.currentThread().getName());
			while ( !completed ) {
    			try {
    				log.d(""sync.get() before wait "" + Thread.currentThread().getName());
    				synchronized(this) {
    					if ( !completed )
    						wait();
    				}
    				log.d(""sync.get() after wait wait "" + Thread.currentThread().getName());
    			} catch (InterruptedException e) {
    				log.d(""sync.get() exception"", e);
    				// ignore
    			} catch (Exception e) {
    				log.d(""sync.get() exception"", e);
    				// ignore
    			}
			}
			log.d(""sync.get() returning "" + Thread.currentThread().getName());
			return result;
		}
	}

    private <T> T executeSync( final Callable<T> task )
    {
    	//log.d(""executeSync called"");
    	
    	
    	final Sync<T> sync = new Sync<T>();
    	post( new Runnable() {
    		public void run() {
    			log.d(""executeSync "" + Thread.currentThread().getName());
    			try {
    				sync.set( task.call() );
    			} catch ( Exception e ) {
    			}
    		}
    	});
    	T res = sync.get();
    	//log.d(""executeSync done"");
    	return res;
    }
    
    // Native functions
    /* implementend by libcr3engine.so */
    
    // get current page image
    private native void getPageImageInternal(Bitmap bitmap);
    // constructor's native part
    private native void createInternal();
    private native void destroyInternal();
    private native boolean loadDocumentInternal( String fileName );
    private native java.util.Properties getSettingsInternal();
    private native boolean applySettingsInternal( java.util.Properties settings );
    private native void setStylesheetInternal( String stylesheet );
    private native void resizeInternal( int dx, int dy );
    private native boolean doCommandInternal( int command, int param );
    private native Bookmark getCurrentPageBookmarkInternal();
    private native boolean goToPositionInternal(String xPath);
    private native PositionProperties getPositionPropsInternal(String xPath);
    private native void updateBookInfoInternal( BookInfo info );
    private native TOCItem getTOCInternal();
    private native void clearSelectionInternal();
    private native boolean findTextInternal( String pattern, int origin, int reverse, int caseInsensitive );
    private native void setBatteryStateInternal( int state );
    private native byte[] getCoverPageDataInternal();
    private native void setPageBackgroundTextureInternal( byte[] imageBytes, int tileFlags );
    private native void updateSelectionInternal( Selection sel );
    private native boolean moveSelectionInternal( Selection sel, int moveCmd, int params );
    private native String checkLinkInternal( int x, int y, int delta );
    private native int goLinkInternal( String link );
    
    
    protected int mNativeObject; // used from JNI
    
	private final CoolReader mActivity;
    private final Engine mEngine;
    private final BackgroundThread mBackThread;
    
    private BookInfo mBookInfo;
    
    private Properties mSettings = new Properties();

    public Engine getEngine()
    {
    	return mEngine;
    }
    
    public CoolReader getActivity()
    {
    	return mActivity;
    }
    
	private int lastResizeTaskId = 0;
	@Override
	protected void onSizeChanged(final int w, final int h, int oldw, int oldh) {
		log.i(""onSizeChanged(""+w + "", "" + h +"")"");
		super.onSizeChanged(w, h, oldw, oldh);
		final int thisId = ++lastResizeTaskId;
	    if ( w<h && mActivity.isLandscape() ) {
	    	log.i(""ignoring size change to portrait since landscape is set"");
	    	return;
	    }
//		if ( mActivity.isPaused() ) {
//			log.i(""ignoring size change since activity is paused"");
//			return;
//		}
		// update size with delay: chance to avoid extra unnecessary resizing
		
	    Runnable task = new Runnable() {
	    	public void run() {
	    		if ( thisId != lastResizeTaskId ) {
					log.d(""skipping duplicate resize request in GUI thread"");
	    			return;
	    		}
	    		mActivity.getHistory().updateCoverPageSize(w, h);
	    		post(new Task() {
	    			public void work() {
	    				BackgroundThread.ensureBackground();
	    				if ( thisId != lastResizeTaskId ) {
	    					log.d(""skipping duplicate resize request"");
	    					return;
	    				}
	    		        internalDX = w;
	    		        internalDY = h;
	    				log.d(""ResizeTask: resizeInternal(""+w+"",""+h+"")"");
	    		        resizeInternal(w, h);
//	    		        if ( mOpened ) {
//	    					log.d(""ResizeTask: done, drawing page"");
//	    			        drawPage();
//	    		        }
	    			}
	    			public void done() {
	    				clearImageCache();
	    				invalidate();
	    			}
	    		});
	    	}
	    };
	    if ( mOpened ) {
	    	log.d(""scheduling delayed resize task id=""+thisId);
	    	BackgroundThread.instance().postGUI( task, 1500);
	    } else {
	    	log.d(""executing resize without delay"");
	    	task.run();
	    }
	    
	}
	
	public boolean isBookLoaded()
	{
		BackgroundThread.ensureGUI();
		return mOpened;
	}
	
	public int getOrientation()
	{
		int angle = mSettings.getInt(PROP_APP_SCREEN_ORIENTATION, 0);
		if ( angle==4 )
			angle = mActivity.getOrientationFromSensor();
		return angle;
	}

	private int overrideKey( int keyCode )
	{
		return keyCode;
/*		
		
		int angle = getOrientation();
		int[] subst = new int[] {
			1, 	KeyEvent.KEYCODE_DPAD_UP, KeyEvent.KEYCODE_DPAD_LEFT,
			1, 	KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_RIGHT,
			1, 	KeyEvent.KEYCODE_DPAD_LEFT, KeyEvent.KEYCODE_DPAD_DOWN,
			1, 	KeyEvent.KEYCODE_DPAD_RIGHT, KeyEvent.KEYCODE_DPAD_UP,
			1, 	KeyEvent.KEYCODE_VOLUME_UP, KeyEvent.KEYCODE_VOLUME_DOWN,
			1, 	KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.KEYCODE_VOLUME_UP,
//			2, 	KeyEvent.KEYCODE_DPAD_UP, KeyEvent.KEYCODE_DPAD_DOWN,
//			2, 	KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_UP,
//			2, 	KeyEvent.KEYCODE_DPAD_LEFT, KeyEvent.KEYCODE_DPAD_RIGHT,
//			2, 	KeyEvent.KEYCODE_DPAD_RIGHT, KeyEvent.KEYCODE_DPAD_LEFT,
//			2, 	KeyEvent.KEYCODE_VOLUME_UP, KeyEvent.KEYCODE_VOLUME_DOWN,
//			2, 	KeyEvent.KEYCODE_VOLUME_DOWN, KeyEvent.KEYCODE_VOLUME_UP,
//			3, 	KeyEvent.KEYCODE_DPAD_UP, KeyEvent.KEYCODE_DPAD_RIGHT,
//			3, 	KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_LEFT,
//			3, 	KeyEvent.KEYCODE_DPAD_LEFT, KeyEvent.KEYCODE_DPAD_UP,
//			3, 	KeyEvent.KEYCODE_DPAD_RIGHT, KeyEvent.KEYCODE_DPAD_DOWN,
		};
		for ( int i=0; i<subst.length; i+=3 ) {
			if ( angle==subst[i] && keyCode==subst[i+1] )
				return subst[i+2];
		}
		return keyCode;
*/
	}
	
	public int getTapZone( int x, int y, int dx, int dy )
	{
		int x1 = dx / 3;
		int x2 = dx * 2 / 3;
		int y1 = dy / 3;
		int y2 = dy * 2 / 3;
		int zone = 0;
		if ( y<y1 ) {
			if ( x<x1 )
				zone = 1;
			else if ( x<x2 )
				zone = 2;
			else
				zone = 3;
		} else if ( y<y2 ) {
			if ( x<x1 )
				zone = 4;
			else if ( x<x2 )
				zone = 5;
			else
				zone = 6;
		} else {
			if ( x<x1 )
				zone = 7;
			else if ( x<x2 )
				zone = 8;
			else
				zone = 9;
		}
		return zone;
	}
	
	public void onTapZone( int zone, boolean isLongPress )
	{
		ReaderAction action;
		if ( !isLongPress )
			action = ReaderAction.findForTap(zone, mSettings);
		else
			action = ReaderAction.findForLongTap(zone, mSettings);
		if ( action.isNone() )
			return;
		log.d(""onTapZone : action "" + action.id + "" is found for tap zone "" + zone + (isLongPress ? "" (long)"":""""));
		onAction( action );
	}
	
	public FileInfo getOpenedFileInfo()
	{
		if ( isBookLoaded() && mBookInfo!=null )
			return mBookInfo.getFileInfo();
		return null;
	}
	
	public final int LONG_KEYPRESS_TIME = 900;
	public final int AUTOREPEAT_KEYPRESS_TIME = 700;
	public final int DOUBLE_CLICK_INTERVAL = 400;
	private ReaderAction currentDoubleClickAction = null;
	private ReaderAction currentSingleClickAction = null;
	private long currentDoubleClickActionStart = 0;
	private int currentDoubleClickActionKeyCode = 0;
	@Override
	public boolean onKeyUp(int keyCode, final KeyEvent event) {
		if ( keyCode==KeyEvent.KEYCODE_VOLUME_DOWN || keyCode==KeyEvent.KEYCODE_VOLUME_UP )
			if ( !enableVolumeKeys )
				return super.onKeyUp(keyCode, event);
		if ( keyCode==KeyEvent.KEYCODE_POWER || keyCode==KeyEvent.KEYCODE_ENDCALL ) {
			mActivity.releaseBacklightControl();
			return false;
		}
		boolean tracked = isTracked(event);
		if ( keyCode!=KeyEvent.KEYCODE_BACK )
			backKeyDownHere = false;
		mActivity.onUserActivity();

		if ( keyCode==KeyEvent.KEYCODE_BACK && !tracked )
			return true;
		backKeyDownHere = false;
		
		// apply orientation
		keyCode = overrideKey( keyCode );
		boolean isLongPress = false;
		Long keyDownTs = keyDownTimestampMap.get(keyCode);
		if ( keyDownTs!=null && System.currentTimeMillis()-keyDownTs>=LONG_KEYPRESS_TIME )
			isLongPress = true;
		ReaderAction action = ReaderAction.findForKey( keyCode, mSettings );
		ReaderAction longAction = ReaderAction.findForLongKey( keyCode, mSettings );
		ReaderAction dblAction = ReaderAction.findForDoubleKey( keyCode, mSettings );
		stopTracking();

		if ( keyCode>=KeyEvent.KEYCODE_0 && keyCode<=KeyEvent.KEYCODE_9 && tracked ) {
			// goto/set shortcut bookmark
			int shortcut = keyCode - KeyEvent.KEYCODE_0;
			if ( shortcut==0 )
				shortcut = 10;
			if ( isLongPress )
				addBookmark(shortcut);
			else
				goToBookmark(shortcut);
			return true;
		}
		if ( action.isNone() || !tracked ) {
			return super.onKeyUp(keyCode, event);
		}
		if ( !action.isNone() && action.canRepeat() && longAction.isRepeat() ) {
			// already processed by onKeyDown()
			return true;
		}
		
		if ( isLongPress ) {
			action = longAction;
		} else {
			if ( !dblAction.isNone() ) {
				// wait for possible double click
				currentDoubleClickActionStart = android.os.SystemClock.uptimeMillis();
				currentDoubleClickAction = dblAction;
				currentSingleClickAction = action;
				currentDoubleClickActionKeyCode = keyCode;
				final int myKeyCode = keyCode;
				BackgroundThread.instance().postGUI(new Runnable() {
					public void run() {
						if ( currentSingleClickAction!=null && currentDoubleClickActionKeyCode==myKeyCode ) {
							log.d(""onKeyUp: single click action "" + currentSingleClickAction.id + "" found for key "" + myKeyCode + "" single click"");
							onAction( currentSingleClickAction );
						}
						currentDoubleClickActionStart = 0;
						currentDoubleClickActionKeyCode = 0;
						currentDoubleClickAction = null;
						currentSingleClickAction = null;
					}
				}, DOUBLE_CLICK_INTERVAL);
				// posted
				return true;
			}
		}
		if ( !action.isNone() ) {
			log.d(""onKeyUp: action "" + action.id + "" found for key "" + keyCode + (isLongPress?"" (long)"" : """") );
			onAction( action );
			return true;
		}
		

		// not processed
		return super.onKeyUp(keyCode, event);
	}

	boolean VOLUME_KEYS_ZOOM = false;
	
	private boolean backKeyDownHere = false;

	
	
	@Override
	protected void onFocusChanged(boolean gainFocus, int direction,
			Rect previouslyFocusedRect) {
		stopTracking();
		super.onFocusChanged(gainFocus, direction, previouslyFocusedRect);
	}
	
	private boolean startTrackingKey( KeyEvent event ) {
		if ( event.getRepeatCount()==0 ) {
			stopTracking();
			trackedKeyEvent = event;
			return true;
		}
		return false;
	}
	
	private void stopTracking() {
		trackedKeyEvent = null;
		actionToRepeat = null;
		repeatActionActive = false;
	}

	private boolean isTracked( KeyEvent event ) {
        if ( trackedKeyEvent!=null) {
            int tkeKc = trackedKeyEvent.getKeyCode();
            int eKc = event.getKeyCode();
            // check if tracked key and current key are the same
            if (tkeKc == eKc) {
                long tkeDt = trackedKeyEvent.getDownTime();
                long eDt = event.getDownTime();
                // empirical value (could be changed or moved to constant)
                long delta = 300l;
                // time difference between tracked and current event
                long diff = eDt - tkeDt;
                // needed for correct function on HTC Desire for CENTER_KEY
                if (delta > diff)
                    return true;
            }
            else {
                log.v(""isTracked( trackedKeyEvent="" + trackedKeyEvent + "", event="" + event + "" )"");
            }
        }
		stopTracking();
		return false;
	}

	@Override
	public boolean onKeyMultiple(int keyCode, int repeatCount, KeyEvent event) {
		log.v(""onKeyMultiple( keyCode="" + keyCode + "", repeatCount="" + repeatCount + "", event="" + event);
		return super.onKeyMultiple(keyCode, repeatCount, event);
	}


	private KeyEvent trackedKeyEvent = null; 
	private ReaderAction actionToRepeat = null;
	private boolean repeatActionActive = false;
	private Map<Integer, Long> keyDownTimestampMap = new HashMap<Integer, Long>();
	
	@Override
	public boolean onKeyDown(int keyCode, final KeyEvent event) {
		backKeyDownHere = false;
		if ( event.getRepeatCount()==0 ) {
			log.v(""onKeyDown(""+keyCode + "", "" + event +"")"");
			keyDownTimestampMap.put(keyCode, System.currentTimeMillis());
		}
		if ( keyCode==KeyEvent.KEYCODE_POWER || keyCode==KeyEvent.KEYCODE_ENDCALL ) {
			mActivity.releaseBacklightControl();
			boolean res = super.onKeyDown(keyCode, event);
			mActivity.onUserActivity();
			return res;
		}

    	if ( keyCode==KeyEvent.KEYCODE_VOLUME_UP || keyCode==KeyEvent.KEYCODE_VOLUME_DOWN )
    		if (!enableVolumeKeys) {
    			boolean res = super.onKeyDown(keyCode, event);
    			mActivity.onUserActivity();
    			return res;
    		}
    	
		mActivity.onUserActivity();
		keyCode = overrideKey( keyCode );
		ReaderAction action = ReaderAction.findForKey( keyCode, mSettings );
		ReaderAction longAction = ReaderAction.findForLongKey( keyCode, mSettings );
		//ReaderAction dblAction = ReaderAction.findForDoubleKey( keyCode, mSettings );

		if ( event.getRepeatCount()==0 ) {
			if ( keyCode==currentDoubleClickActionKeyCode && currentDoubleClickActionStart + DOUBLE_CLICK_INTERVAL > android.os.SystemClock.uptimeMillis() ) {
				if ( currentDoubleClickAction!=null ) {
					log.d(""executing doubleclick action "" + currentDoubleClickAction);
					onAction(currentDoubleClickAction);
				}
				currentDoubleClickActionStart = 0;
				currentDoubleClickActionKeyCode = 0;
				currentDoubleClickAction = null;
				currentSingleClickAction = null;
				return true;
			} else {
				if ( currentSingleClickAction!=null ) {
					onAction(currentSingleClickAction);
				}
				currentDoubleClickActionStart = 0;
				currentDoubleClickActionKeyCode = 0;
				currentDoubleClickAction = null;
				currentSingleClickAction = null;
			}
			
		}
		
		
    	if ( event.getRepeatCount()>0 ) {
    		if ( !isTracked(event) )
    			return true; // ignore
    		// repeating key down
    		boolean isLongPress = (event.getEventTime()-event.getDownTime())>=AUTOREPEAT_KEYPRESS_TIME;
    		if ( isLongPress ) {
	    		if ( actionToRepeat!=null ) {
	    			if ( !repeatActionActive ) {
		    			log.v(""autorepeating action : "" + actionToRepeat );
		    			repeatActionActive = true;
		    			onAction(actionToRepeat, new Runnable() {
		    				public void run() {
		    					if ( trackedKeyEvent!=null && trackedKeyEvent.getDownTime()==event.getDownTime() ) {
		    						log.v(""action is completed : "" + actionToRepeat );
		    						repeatActionActive = false;
		    					}
		    				}
		    			});
	    			}
	    		} else {
	    			stopTracking();
	    			log.v(""executing action on long press : "" + longAction );
	    			onAction(longAction);
	    		}
    		}
    		return true;
    	}
		
		if ( !action.isNone() && action.canRepeat() && longAction.isRepeat() ) {
			// start tracking repeat
			startTrackingKey(event);
			actionToRepeat = action;
			log.v(""running action with scheduled autorepeat : "" + actionToRepeat );
			repeatActionActive = true;
			onAction(actionToRepeat, new Runnable() {
				public void run() {
					if ( trackedKeyEvent==event ) {
						log.v(""action is completed : "" + actionToRepeat );
						repeatActionActive = false;
					}
				}
			});
			return true;
		} else {
			actionToRepeat = null;
		}
		
		if ( keyCode>=KeyEvent.KEYCODE_0 && keyCode<=KeyEvent.KEYCODE_9 ) {
			// will process in keyup handler
			startTrackingKey(event);
			return true;
		}
		if ( action.isNone() && longAction.isNone() )
			return super.onKeyDown(keyCode, event);
		startTrackingKey(event);
		return true;
	}
	
	private int nextUpdateId = 0;
	private void updateSelection(int startX, int startY, int endX, int endY, final boolean isUpdateEnd ) {
		final Selection sel = new Selection();
		final int myId = ++nextUpdateId;
		sel.startX = startX;
		sel.startY = startY;
		sel.endX = endX;
		sel.endY = endY;
		mEngine.execute(new Task() {
			@Override
			public void work() throws Exception {
				if ( myId != nextUpdateId && !isUpdateEnd )
					return;
				updateSelectionInternal(sel);
				if ( !sel.isEmpty() ) {
					invalidImages = true;
					BitmapInfo bi = preparePageImage(0);
					if ( bi!=null ) {
						draw();
					}
				}
			}

			@Override
			public void done() {
				if ( isUpdateEnd ) {
					String text = sel.text;
					if ( text!=null && text.length()>0 ) {
						onSelectionComplete( sel );
					} else {
						clearSelection();
					}
				}
			}
		});
	}

	private int mSelectionAction = SELECTION_ACTION_TOOLBAR;
	private void onSelectionComplete( Selection sel ) {
		switch ( mSelectionAction ) {
		case SELECTION_ACTION_TOOLBAR:
			SelectionToolbarDlg.showDialog(mActivity, ReaderView.this, sel);
			break;
		case SELECTION_ACTION_COPY:
			copyToClipboard(sel.text);
			clearSelection();
			break;
		case SELECTION_ACTION_DICTIONARY:
			mActivity.findInDictionary( sel.text );
			clearSelection();
			break;
		case SELECTION_ACTION_BOOKMARK:
			clearSelection();
			showNewBookmarkDialog( sel );
			break;
		default:
			clearSelection();
			break;
		}
		
	}
	
	public void showNewBookmarkDialog( Selection sel ) {
		if ( mBookInfo==null )
			return;
		Bookmark bmk = new Bookmark();
		bmk.setType(Bookmark.TYPE_COMMENT);
		bmk.setPosText(sel.text);
		bmk.setStartPos(sel.startPos);
		bmk.setEndPos(sel.endPos);
		bmk.setPercent(sel.percent);
		bmk.setTitleText(sel.chapter);
		BookmarkEditDialog dlg = new BookmarkEditDialog(mActivity, this, mBookInfo, bmk, true);
		dlg.show();
	}
	
	public void copyToClipboard( String text ) {
		if ( text!=null && text.length()>0 ) {
			ClipboardManager cm = mActivity.getClipboardmanager();
			cm.setText(text);
			log.i(""Setting clipboard text: "" + text);
			mActivity.showToast(""Selection text copied to clipboard"");
		}
	}
	
	private void cancelSelection() {
		//
		selectionInProgress = false;
		clearSelection();
	}

	private int isBacklightControlFlick = 1;
	private boolean isTouchScreenEnabled = true;
	private boolean isManualScrollActive = false;
	private boolean isBrightnessControlActive = false;
	private int manualScrollStartPosX = -1;
	private int manualScrollStartPosY = -1;
	volatile private boolean touchEventIgnoreNextUp = false;
	volatile private int longTouchId = 0;
	volatile private long currentDoubleTapActionStart = 0;
	private boolean selectionInProgress = false;
	private int selectionStartX = 0;
	private int selectionStartY = 0;
	private int selectionEndX = 0;
	private int selectionEndY = 0;
	private boolean doubleTapSelectionEnabled = false;
	private boolean selectionModeActive = false;
	
	public void toggleSelectionMode() {
		selectionModeActive = !selectionModeActive;
		mActivity.showToast( selectionModeActive ? R.string.action_toggle_selection_mode_on : R.string.action_toggle_selection_mode_off);
	}
	
	public void onLongTap( final int x, final int y, final int zone ) {
		mEngine.execute(new Task() {
			String link;
			public void work() {
				link = checkLinkInternal(x, y, mActivity.getPalmTipPixels() / 2 );
				if ( link!=null ) {
					if ( link.startsWith(""#"") ) {
						log.d(""go to "" + link);
						goLinkInternal(link);
						drawPage();
					}
				}
			}
			public void done() {
				if ( link==null )
					onTapZone( zone, true );
				else if (!link.startsWith(""#"")) {
					mActivity.showToast(""External links are not yet supported"");
				}
			}
		});
	}
	
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		
		if ( !isTouchScreenEnabled ) {
			return true;
		}
		
		int x = (int)event.getX();
		int y = (int)event.getY();
		int dx = getWidth();
		int dy = getHeight();
		int START_DRAG_THRESHOLD = mActivity.getPalmTipPixels();
		final int zone = getTapZone(x, y, dx, dy);
		
		if ( event.getAction()==MotionEvent.ACTION_UP ) {
			longTouchId++;
			if ( selectionInProgress ) {
				log.v(""touch ACTION_UP: selection finished"");
				selectionEndX = x;
				selectionEndY = y;
				updateSelection( selectionStartX, selectionStartY, selectionEndX, selectionEndY, true );
				selectionInProgress = false;
				selectionModeActive = false; // TODO: multiple selection mode
				return true;
			}
			if ( touchEventIgnoreNextUp )
				return true;
			mActivity.onUserActivity();
			unhiliteTapZone(); 
			boolean isLongPress = (event.getEventTime()-event.getDownTime())>LONG_KEYPRESS_TIME;
			stopAnimation(x, y);
			stopBrightnessControl(x, y);
			if ( isManualScrollActive || isBrightnessControlActive ) {
				isManualScrollActive = false;
				isBrightnessControlActive = false;
				manualScrollStartPosX = manualScrollStartPosY = -1;
				return true;
			}
			if ( isLongPress || !doubleTapSelectionEnabled ) {
				currentDoubleTapActionStart = 0;
				if ( !isLongPress )
					onTapZone( zone, isLongPress );
				else {
					onLongTap( x, y, zone );
				}
			} else {
				currentDoubleTapActionStart = android.os.SystemClock.uptimeMillis();
				final long myStart = currentDoubleTapActionStart;
				BackgroundThread.instance().postGUI(new Runnable() {
					@Override
					public void run() {
						if ( currentDoubleTapActionStart == myStart ) {
							onTapZone( zone, false );
						}
						currentDoubleTapActionStart = 0;
					}
				}, DOUBLE_CLICK_INTERVAL);
			}
			return true;
		} else if ( event.getAction()==MotionEvent.ACTION_DOWN ) {
			touchEventIgnoreNextUp = false;
			if ( selectionModeActive || currentDoubleTapActionStart + DOUBLE_CLICK_INTERVAL > android.os.SystemClock.uptimeMillis() ) {
				log.v(""touch ACTION_DOWN: double tap: starting selection"");
				// double tap started
				selectionInProgress = true;
				longTouchId++;
				selectionStartX = x;
				selectionStartY = y;
				selectionEndX = x;
				selectionEndY = y;
				currentDoubleTapActionStart = 0;
				updateSelection( selectionStartX, selectionStartY, selectionEndX, selectionEndY, false );
				return true;
			}
			currentDoubleTapActionStart = 0;
			selectionInProgress = false;
			manualScrollStartPosX = x;
			manualScrollStartPosY = y;
			currentDoubleTapActionStart = 0;
			if ( hiliteTapZoneOnTap ) {
				hiliteTapZone( true, x, y, dx, dy );
				scheduleUnhilite( LONG_KEYPRESS_TIME );
			}
			final int myId = ++longTouchId;
			mBackThread.postGUI( new Runnable() {
				@Override
				public void run() {
					log.v(""onTouchEvent: long tap delayed event myId="" + myId + "", currentId="" + longTouchId);
					if ( myId==longTouchId ) {
						touchEventIgnoreNextUp = true;
						isBrightnessControlActive = false;
						isManualScrollActive = false;
						onLongTap( manualScrollStartPosX, manualScrollStartPosY, zone );
						manualScrollStartPosX = manualScrollStartPosY = -1;
					}
				}
				
			}, LONG_KEYPRESS_TIME);
			return true;
		} else if ( event.getAction()==MotionEvent.ACTION_MOVE) {
			if ( selectionInProgress ) {
				log.v(""touch ACTION_MOVE: updating selection"");
				selectionEndX = x;
				selectionEndY = y;
				updateSelection( selectionStartX, selectionStartY, selectionEndX, selectionEndY, false );
				return true;
			}
			if ( touchEventIgnoreNextUp )
				return true;
			if ( !isManualScrollActive && !isBrightnessControlActive && manualScrollStartPosX>=0 && manualScrollStartPosY>=0 ) {
				int movex = manualScrollStartPosX - x;
				int deltay = manualScrollStartPosY - y;
				int deltax = movex < 0 ? -movex : movex;
				deltay = deltay < 0 ? -deltay : deltay;
				if ( deltax + deltay > START_DRAG_THRESHOLD ) {
					log.v(""onTouchEvent: move threshold reached"");
					longTouchId++;
					if ( manualScrollStartPosX < START_DRAG_THRESHOLD * 170 / 100 && deltay>deltax && isBacklightControlFlick==1 ) {
						// brightness
						isBrightnessControlActive = true;
						startBrightnessControl(x, y);
						return true;
					} else if ( manualScrollStartPosX > dx - START_DRAG_THRESHOLD * 170 / 100 && deltay>deltax && isBacklightControlFlick==2 ) {
							// brightness
							isBrightnessControlActive = true;
							startBrightnessControl(x, y);
							return true;
					} else {
						//pageFlipAnimationSpeedMs
						// scroll
						boolean isPageMode = mSettings.getInt(PROP_PAGE_VIEW_MODE, 1)==1;
						boolean startScrollEnabled = true;
						if ( isPageMode ) {
							if ( deltax < START_DRAG_THRESHOLD ) // check only horizontal distance
								startScrollEnabled = false;
							if ( movex>0 && x>dx*2/3 )
								startScrollEnabled = false;
							if ( movex<0 && x<dx/3 )
								startScrollEnabled = false;
						}
						if ( startScrollEnabled ) {
							if ( pageFlipAnimationSpeedMs!=0 ) {
								isManualScrollActive = true;
								startAnimation(manualScrollStartPosX, manualScrollStartPosY, dx, dy);
								int nx = x;
								int ny = y;
								if ( isPageMode )
									nx = movex < 0 ? (x + dx) / 2 : x / 2;
								else
									ny = (manualScrollStartPosY + y) / 2;
								updateAnimation(nx, ny);
								updateAnimation(x, y);
								return true;
							} else {
								touchEventIgnoreNextUp = true;
								if ( movex<0 ) {
									// back
									onCommand(ReaderCommand.DCMD_PAGEUP, 1);
								} else {
									// forward
									onCommand(ReaderCommand.DCMD_PAGEDOWN, 1);
								}
								return true;
							}
						}
					}
				}
			}
			if ( isManualScrollActive )
				updateAnimation(x, y);
			else if ( isBrightnessControlActive ) 
				updateBrightnessControl(x, y);
			return true;
		} else if ( event.getAction()==MotionEvent.ACTION_OUTSIDE ) {
			if ( selectionInProgress ) {
				// cancel selection
				cancelSelection();
			}
			isManualScrollActive = false;
			isBrightnessControlActive = false;
			selectionModeActive = false;
			currentDoubleTapActionStart = 0;
			longTouchId++;
			stopAnimation(-1, -1);
			stopBrightnessControl(-1, -1);
			hiliteTapZone( false, x, y, dx, dy ); 
		}
		return true;
		//return super.onTouchEvent(event);
	}

	@Override
	public boolean onTrackballEvent(MotionEvent event) {
		log.d(""onTrackballEvent("" + event + "")"");
		if ( mSettings.getBool(PROP_APP_TRACKBALL_DISABLED, false) ) {
			log.d(""trackball is disabled in settings"");
			return true;
		}
		return super.onTrackballEvent(event);
	}
	
	public void showTOC()
	{
		BackgroundThread.ensureGUI();
		final ReaderView view = this; 
		mEngine.post(new Task() {
			TOCItem toc;
			PositionProperties pos;
			public void work() {
				BackgroundThread.ensureBackground();
				toc = getTOCInternal();
				pos = getPositionPropsInternal(null);
			}
			public void done() {
				BackgroundThread.ensureGUI();
				if ( toc!=null && pos!=null ) {
					TOCDlg dlg = new TOCDlg(mActivity, view, toc, pos.pageNumber);
					dlg.show();
				} else {
					mActivity.showToast(""No Table of Contents found"");
				}
			}
		});
	}
	
	public void showSearchDialog()
	{
		BackgroundThread.ensureGUI();
		SearchDlg dlg = new SearchDlg( mActivity, this );
		dlg.show();
	}

    public void findText( final String pattern, final boolean reverse, final boolean caseInsensitive )
    {
		BackgroundThread.ensureGUI();
		final ReaderView view = this; 
		mEngine.execute(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				boolean res = findTextInternal( pattern, 1, reverse?1:0, caseInsensitive?1:0);
				if ( !res )
					res = findTextInternal( pattern, -1, reverse?1:0, caseInsensitive?1:0);
				if ( !res ) {
					clearSelectionInternal();
					throw new Exception(""pattern not found"");
				}
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
				FindNextDlg.showDialog( mActivity, view, pattern, caseInsensitive );
			}
			public void fail(Exception e) {
				BackgroundThread.ensureGUI();
				mActivity.showToast(""Pattern not found"");
			}
			
		});
    }
    
    public void findNext( final String pattern, final boolean reverse, final boolean caseInsensitive )
    {
		BackgroundThread.ensureGUI();
		mEngine.execute(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				boolean res = findTextInternal( pattern, 1, reverse?1:0, caseInsensitive?1:0);
				if ( !res )
					res = findTextInternal( pattern, -1, reverse?1:0, caseInsensitive?1:0);
				if ( !res ) {
					clearSelectionInternal();
					throw new Exception(""pattern not found"");
				}
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
			}
		});
    }
    
    public void clearSelection()
    {
		BackgroundThread.ensureGUI();
		mEngine.post(new Task() {
			public void work() throws Exception {
				BackgroundThread.ensureBackground();
				clearSelectionInternal();
				invalidImages = true;
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
			}
		});
    }

    public void goToBookmark( Bookmark bm )
	{
		BackgroundThread.ensureGUI();
		final String pos = bm.getStartPos();
		mEngine.execute(new Task() {
			public void work() {
				BackgroundThread.ensureBackground();
				goToPositionInternal(pos);
			}
			public void done() {
				BackgroundThread.ensureGUI();
				drawPage();
			}
		});
	}
	
	public boolean goToBookmark( final int shortcut )
	{
		BackgroundThread.ensureGUI();
		if ( mBookInfo!=null ) {
			Bookmark bm = mBookInfo.findShortcutBookmark(shortcut);
			if ( bm==null ) {
				addBookmark(shortcut);
				return true;
			} else {
				// go to bookmark
				goToBookmark( bm );
				return false;
			}
		}
		return false;
	}
	
	public void addBookmark( final int shortcut )
	{
		BackgroundThread.ensureGUI();
		// set bookmark instead
		mEngine.execute(new Task() {
			Bookmark bm;
			public void work() {
				BackgroundThread.ensureBackground();
				if ( mBookInfo!=null ) {
					bm = getCurrentPageBookmarkInternal();
					bm.setShortcut(shortcut);
				}
			}
			public void done() {
				if ( mBookInfo!=null && bm!=null ) {
					if ( shortcut==0 )
						mBookInfo.addBookmark(bm);
					else
						mBookInfo.setShortcutBookmark(shortcut, bm);
					mActivity.getDB().save(mBookInfo);
					String s;
					if ( shortcut==0 )
						s = mActivity.getString(R.string.toast_position_bookmark_is_set);
					else {
						s = mActivity.getString(R.string.toast_shortcut_bookmark_is_set);
						s.replace(""$1"", String.valueOf(shortcut));
					}
					mActivity.showToast(s);
				}
			}
		});
	}
	
	public boolean onMenuItem( final int itemId )
	{
		BackgroundThread.ensureGUI();
		ReaderAction action = ReaderAction.findByMenuId(itemId);
		if ( action.isNone() )
			return false;
		onAction(action);
		return true;
	}
	
	public void onAction( final ReaderAction action )
	{
		onAction(action, null);
	}
	public void onAction( final ReaderAction action, final Runnable onFinishHandler )
	{
		BackgroundThread.ensureGUI();
		if ( action.cmd!=ReaderCommand.DCMD_NONE )
			onCommand( action.cmd, action.param, onFinishHandler );
	}
	
	public void toggleDayNightMode()
	{
		Properties settings = getSettings();
		OptionsDialog.toggleDayNightMode(settings);
		setSettings(settings, null);
		invalidImages = true;
	}
	
	public boolean isNightMode() {
		return mSettings.getBool(PROP_NIGHT_MODE, false);
	}

	public String getSetting( String name ) {
		return mSettings.getProperty(name);
	}
	public void saveSetting( String name, String value ) {
		mSettings.setProperty(name, value);
		mActivity.saveSettings(mSettings);
	}
	
	public void toggleScreenOrientation()
	{
		int orientation = mActivity.getScreenOrientation();
		orientation = ( orientation==0 )? 1 : 0;
		saveSetting(PROP_APP_SCREEN_ORIENTATION, String.valueOf(orientation));
		mActivity.setScreenOrientation(orientation);
	}
	
	public void toggleFullscreen()
	{
		boolean newBool = !mActivity.isFullscreen();
		String newValue = newBool ? ""1"" : ""0"";
		saveSetting(PROP_APP_FULLSCREEN, newValue);
		mActivity.setFullscreen(newBool);
	}
	
	public void toggleDocumentStyles()
	{
		if ( mOpened && mBookInfo!=null ) {
			log.d(""toggleDocumentStyles()"");
			boolean flg = !mBookInfo.getFileInfo().getFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG);
			mBookInfo.getFileInfo().setFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG, flg);
            doEngineCommand( ReaderCommand.DCMD_SET_INTERNAL_STYLES, flg ? 0 : 1);
            doEngineCommand( ReaderCommand.DCMD_REQUEST_RENDER, 1);
		}
	}
	
	public boolean getDocumentStylesEnabled() {
		if ( mOpened && mBookInfo!=null ) {
			boolean flg = !mBookInfo.getFileInfo().getFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG);
			return flg;
		}
		return true;
	}
	
	static private SimpleDateFormat timeFormat = new SimpleDateFormat(""HH:mm"", Locale.getDefault());
	public void showBookInfo() {
		final ArrayList<String> items = new ArrayList<String>();
		items.add(""section=section.system"");
		items.add(""system.version=Cool Reader "" + mActivity.getVersion());
		items.add(""system.battery="" + mBatteryState + ""%"");
		items.add(""system.time="" + timeFormat.format(new Date()));
		final BookInfo bi = mBookInfo;
		if ( bi!=null ) {
			FileInfo fi = bi.getFileInfo();
			items.add(""section=section.file"");
			String fname = new File(fi.pathname).getName();
			items.add(""file.name="" + fname);
			if ( new File(fi.pathname).getParent()!=null )
				items.add(""file.path="" + new File(fi.pathname).getParent());
			items.add(""file.size="" + fi.size);
			if ( fi.arcname!=null ) {
				items.add(""file.arcname="" + new File(fi.arcname).getName());
				if ( new File(fi.arcname).getParent()!=null )
					items.add(""file.arcpath="" + new File(fi.arcname).getParent());
				items.add(""file.arcsize="" + fi.arcsize);
			}
			items.add(""file.format="" + fi.format.name());
		}
		execute( new Task() {
			Bookmark bm;
			@Override
			public void work() {
				bm = getCurrentPageBookmarkInternal();
				if ( bm!=null ) {
					PositionProperties prop = getPositionPropsInternal(bm.getStartPos());
					items.add(""section=section.position"");
					if ( prop.pageMode!=0 ) {
						items.add(""position.page="" + (prop.pageNumber+1) + "" / "" + prop.pageCount);
					}
					int percent = (int)(10000 * (long)prop.y / prop.fullHeight);
					items.add(""position.percent="" + (percent/100) + ""."" + (percent%100) + ""%"" );
					String chapter = bm.getTitleText();
					if ( chapter!=null && chapter.length()>100 )
						chapter = chapter.substring(0, 100) + ""..."";
					items.add(""position.chapter="" + chapter);
				}
			}
			public void done() {
				FileInfo fi = bi.getFileInfo();
				items.add(""section=section.book"");
				if ( fi.authors!=null || fi.title!=null || fi.series!=null) { 
					items.add(""book.authors="" + fi.authors);
					items.add(""book.title="" + fi.title);
					if ( fi.series!=null ) {
						String s = fi.series;
						if ( fi.seriesNumber>0 )
							s = s + "" #"" + fi.seriesNumber; 
						items.add(""book.series="" + s);
					}
				}
				BookInfoDialog dlg = new BookInfoDialog(mActivity, items);
				dlg.show();
			}
		});
	}
	
	public void onCommand( final ReaderCommand cmd, final int param )
	{
		onCommand( cmd, param, null );
	}
	
	public void onCommand( final ReaderCommand cmd, final int param, final Runnable onFinishHandler )
	{
		BackgroundThread.ensureGUI();
		log.i(""On command "" + cmd + (param!=0?"" (""+param+"")"":"" ""));
		switch ( cmd ) {
		case DCMD_ABOUT:
			mActivity.showAboutDialog();
			break;
		case DCMD_BOOK_INFO:
			showBookInfo();
			break;
		case DCMD_TTS_PLAY:
			{
				log.i(""DCMD_TTS_PLAY: initializing TTS"");
				if ( !mActivity.initTTS(new TTS.OnTTSCreatedListener() {
					@Override
					public void onCreated(TTS tts) {
						log.i(""TTS created: opening TTS toolbar"");
						TTSToolbarDlg.showDialog(mActivity, ReaderView.this, tts);
					}
				}) ) {
					log.e(""Cannot initilize TTS"");
				}
			}
			break;
		case DCMD_TOGGLE_DOCUMENT_STYLES:
			toggleDocumentStyles();
			break;
		case DCMD_SHOW_HOME_SCREEN:
			mActivity.showHomeScreen();
			break;
		case DCMD_TOGGLE_ORIENTATION:
			toggleScreenOrientation();
			break;
		case DCMD_TOGGLE_FULLSCREEN:
			toggleFullscreen();
			break;
		case DCMD_TOGGLE_SELECTION_MODE:
			toggleSelectionMode();
			break;
		case DCMD_TOGGLE_TOUCH_SCREEN_LOCK:
			isTouchScreenEnabled = !isTouchScreenEnabled;
			if ( isTouchScreenEnabled )
				mActivity.showToast(R.string.action_touch_screen_enabled_toast);
			else
				mActivity.showToast(R.string.action_touch_screen_disabled_toast);
			break;
		case DCMD_LINK_BACK:
		case DCMD_LINK_FORWARD:
            doEngineCommand( cmd, 0);
            drawPage();
            break;
		case DCMD_ZOOM_OUT:
            doEngineCommand( ReaderCommand.DCMD_ZOOM_OUT, param);
            syncViewSettings(getSettings());
            break;
		case DCMD_ZOOM_IN:
            doEngineCommand( ReaderCommand.DCMD_ZOOM_IN, param);
            syncViewSettings(getSettings());
            break;
		case DCMD_PAGEDOWN:
			if ( param==1 )
				animatePageFlip(1, onFinishHandler);
			else
				doEngineCommand(cmd, param, onFinishHandler);
			break;
		case DCMD_PAGEUP:
			if ( param==1 )
				animatePageFlip(-1, onFinishHandler);
			else
				doEngineCommand(cmd, param, onFinishHandler);
			break;
		case DCMD_BEGIN:
		case DCMD_END:
			doEngineCommand(cmd, param);
			break;
		case DCMD_RECENT_BOOKS_LIST:
			mActivity.showBrowserRecentBooks();
			break;
		case DCMD_SEARCH:
			showSearchDialog();
			break;
		case DCMD_EXIT:
			mActivity.finish();
			break;
		case DCMD_BOOKMARKS:
			mActivity.showBookmarksDialog();
			break;
		case DCMD_GO_PERCENT_DIALOG:
			mActivity.showGoToPercentDialog();
			break;
		case DCMD_GO_PAGE_DIALOG:
			mActivity.showGoToPageDialog();
			break;
		case DCMD_TOC_DIALOG:
			showTOC();
			break;
		case DCMD_FILE_BROWSER:
			mActivity.showBrowser(getOpenedFileInfo());
			break;
		case DCMD_OPTIONS_DIALOG:
			mActivity.showOptionsDialog();
			break;
		case DCMD_READER_MENU:
			mActivity.openOptionsMenu();
			break;
		case DCMD_TOGGLE_DAY_NIGHT_MODE:
			toggleDayNightMode();
			break;
		}
	}
	
	public void doEngineCommand( final ReaderCommand cmd, final int param )
	{
		doEngineCommand( cmd, param, null );
	}
	public void doEngineCommand( final ReaderCommand cmd, final int param, final Runnable doneHandler )
	{
		BackgroundThread.ensureGUI();
		log.d(""doCommand(""+cmd + "", "" + param +"")"");
		post(new Task() {
			boolean res;
			public void work() {
				BackgroundThread.ensureBackground();
				res = doCommandInternal(cmd.nativeId, param);
			}
			public void done() {
				if ( res )
					drawPage( doneHandler );
			}
		});
	}
	
	public void doCommandFromBackgroundThread( final ReaderCommand cmd, final int param )
	{
		log.d(""doCommandFromBackgroundThread(""+cmd + "", "" + param +"")"");
		BackgroundThread.ensureBackground();
		boolean res = doCommandInternal(cmd.nativeId, param);
		if ( res ) {
			BackgroundThread.guiExecutor.execute(new Runnable() {
				public void run() {
					drawPage();
				}
			});
		}
	}
	
	volatile private boolean mInitialized = false;
	volatile private boolean mOpened = false;
	
	//private File historyFile;
	
	private void updateLoadedBookInfo()
	{
		BackgroundThread.ensureBackground();
		// get title, authors, etc.
		updateBookInfoInternal( mBookInfo );
	}
	
	private void applySettings( Properties props )
	{
		BackgroundThread.ensureBackground();
		log.v(""applySettings() "" + props);
		boolean isFullScreen = props.getBool(PROP_APP_FULLSCREEN, false );
		props.setBool(PROP_SHOW_BATTERY, isFullScreen); 
		props.setBool(PROP_SHOW_TIME, isFullScreen);
		String backgroundImageId = props.getProperty(PROP_PAGE_BACKGROUND_IMAGE);
		if ( backgroundImageId!=null )
			setBackgroundTexture(backgroundImageId);
		props.remove(PROP_EMBEDDED_STYLES);
        applySettingsInternal(props);
        syncViewSettings(props);
        drawPage();
	}
	
	public static boolean eq(Object obj1, Object obj2)
	{
		if ( obj1==null && obj2==null )
			return true;
		if ( obj1==null || obj2==null )
			return false;
		return obj1.equals(obj2);
	}

	public void saveSettings( Properties settings )
	{
		mActivity.saveSettings(settings);
	}
	
	/**
	 * Read JNI view settings, update and save if changed 
	 */
	private void syncViewSettings( final Properties currSettings )
	{
		post( new Task() {
			Properties props;
			public void work() {
				BackgroundThread.ensureBackground();
				java.util.Properties internalProps = getSettingsInternal(); 
				props = new Properties(internalProps);
				props.remove(PROP_EMBEDDED_STYLES);
			}
			public void done() {
				Properties changedSettings = props.diff(currSettings);
		        for ( Map.Entry<Object, Object> entry : changedSettings.entrySet() ) {
	        		currSettings.setProperty((String)entry.getKey(), (String)entry.getValue());
		        }
	        	mSettings = currSettings;
	        	saveSettings(currSettings);
			}
		});
	}
	
	public Properties getSettings()
	{
		return new Properties(mSettings);
	}

	private boolean hiliteTapZoneOnTap = false;
	private boolean enableVolumeKeys = true; 
	static private final int DEF_PAGE_FLIP_MS = 700; 
	public void applyAppSetting( String key, String value )
	{
		boolean flg = ""1"".equals(value);
        if ( key.equals(PROP_APP_FULLSCREEN) ) {
			this.mActivity.setFullscreen( ""1"".equals(value) );
        } else if ( key.equals(PROP_APP_SHOW_COVERPAGES) ) {
			mActivity.getHistory().setCoverPagesEnabled(flg);
        } else if ( key.equals(PROP_APP_BOOK_PROPERTY_SCAN_ENABLED) ) {
			mActivity.getScanner().setDirScanEnabled(flg);
        } else if ( key.equals(PROP_APP_SCREEN_BACKLIGHT_LOCK) ) {
			mActivity.setWakeLockEnabled(flg);
        } else if ( key.equals(PROP_APP_FILE_BROWSER_SIMPLE_MODE) ) {
        	if ( mActivity.getBrowser()!=null )
        		mActivity.getBrowser().setSimpleViewMode(flg);
        } else if ( key.equals(PROP_NIGHT_MODE) ) {
			mActivity.setNightMode(flg);
        } else if ( key.equals(PROP_APP_TAP_ZONE_HILIGHT) ) {
        	hiliteTapZoneOnTap = flg;
        } else if ( key.equals(PROP_APP_DICTIONARY) ) {
        	mActivity.setDict(value);
        } else if ( key.equals(PROP_APP_DOUBLE_TAP_SELECTION) ) {
        	doubleTapSelectionEnabled = flg;
        } else if ( key.equals(PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS) ) {
        	mActivity.getScanner().setHideEmptyDirs(flg);
        } else if ( key.equals(PROP_APP_FLICK_BACKLIGHT_CONTROL) ) {
        	isBacklightControlFlick = ""1"".equals(value) ? 1 : (""2"".equals(value) ? 2 : 0);
        } else if ( key.equals(PROP_APP_SCREEN_ORIENTATION) ) {
			int orientation = ""1"".equals(value) ? 1 : (""4"".equals(value) ? 4 : 0);
        	mActivity.setScreenOrientation(orientation);
        } else if ( PROP_PAGE_ANIMATION.equals(key) ) {
        	try {
        		int n = Integer.valueOf(value);
        		if ( n<0 || n>PAGE_ANIMATION_MAX )
        			n = PAGE_ANIMATION_SLIDE2;
        		pageFlipAnimationMode = n;
        	} catch ( Exception e ) {
        		// ignore
        	}
			pageFlipAnimationSpeedMs = pageFlipAnimationMode!=PAGE_ANIMATION_NONE ? DEF_PAGE_FLIP_MS : 0; 
        } else if ( PROP_CONTROLS_ENABLE_VOLUME_KEYS.equals(key) ) {
        	enableVolumeKeys = flg;
        } else if ( PROP_APP_SCREEN_BACKLIGHT.equals(key) ) {
        	try {
        		final int n = Integer.valueOf(value);
        		// delay before setting brightness
        		mBackThread.postGUI(new Runnable() {
        			public void run() {
        				execute( new Task() {

							@Override
							public void work() throws Exception {
								// do nothing
							}

							@Override
							public void done() {
				        		mActivity.setScreenBacklightLevel(n);
								super.done();
							}
        					
        				});
        			}
        		}, 100);
        	} catch ( Exception e ) {
        		// ignore
        	}
        } else if ( PROP_APP_SELECTION_ACTION.equals(key) ) {
        	try {
        		int n = Integer.valueOf(value);
        		mSelectionAction = n;
        	} catch ( Exception e ) {
        		// ignore
        	}
        }
        //
	}
	
	public void setAppSettings( Properties newSettings, Properties oldSettings )
	{
		log.v(""setAppSettings() "" + newSettings.toString());
		BackgroundThread.ensureGUI();
		if ( oldSettings==null )
			oldSettings = mSettings;
		Properties changedSettings = newSettings.diff(oldSettings);
        for ( Map.Entry<Object, Object> entry : changedSettings.entrySet() ) {
    		String key = (String)entry.getKey();
    		String value = (String)entry.getValue();
    		applyAppSetting( key, value );
    		if ( PROP_APP_FULLSCREEN.equals(key) ) {
    			boolean flg = mSettings.getBool(PROP_APP_FULLSCREEN, false);
    			newSettings.setBool(PROP_SHOW_BATTERY, flg); 
    			newSettings.setBool(PROP_SHOW_TIME, flg); 
    		} else if ( PROP_PAGE_VIEW_MODE.equals(key) ) {
    			boolean flg = ""1"".equals(value);
    			viewMode = flg ? ViewMode.PAGES : ViewMode.SCROLL;
    		} else if ( PROP_APP_SCREEN_ORIENTATION.equals(key) || PROP_PAGE_ANIMATION.equals(key)
    				|| PROP_CONTROLS_ENABLE_VOLUME_KEYS.equals(key) || PROP_APP_SHOW_COVERPAGES.equals(key) 
    				|| PROP_APP_SCREEN_BACKLIGHT.equals(key) 
    				|| PROP_APP_BOOK_PROPERTY_SCAN_ENABLED.equals(key)
    				|| PROP_APP_SCREEN_BACKLIGHT_LOCK.equals(key)
    				|| PROP_APP_TAP_ZONE_HILIGHT.equals(key)
    				|| PROP_APP_DICTIONARY.equals(key)
    				|| PROP_APP_DOUBLE_TAP_SELECTION.equals(key)
    				|| PROP_APP_FLICK_BACKLIGHT_CONTROL.equals(key)
    				|| PROP_APP_FILE_BROWSER_HIDE_EMPTY_FOLDERS.equals(key)
    				|| PROP_APP_SELECTION_ACTION.equals(key)
    				|| PROP_APP_FILE_BROWSER_SIMPLE_MODE.equals(key)
    				// TODO: redesign all this mess!
    				) {
    			newSettings.setProperty(key, value);
    		} else if ( PROP_HYPHENATION_DICT.equals(key) ) {
    			Engine.HyphDict dict = HyphDict.byCode(value);
    			//mEngine.setHyphenationDictionary();
    			if ( mEngine.setHyphenationDictionary(dict) ) {
    				if ( isBookLoaded() ) {
    					doEngineCommand( ReaderCommand.DCMD_REQUEST_RENDER, 0);
    					//drawPage();
    				}
    			}
    			newSettings.setProperty(key, value);
    		}
        }
	}
	
	public ViewMode getViewMode()
	{
		return viewMode;
	}
	
	/**
     * Change settings.
	 * @param newSettings are new settings
	 * @param oldSettings are old settings, null to use mSettings
	 */
	public void setSettings(Properties newSettings, Properties oldSettings)
	{
		log.v(""setSettings() "" + newSettings.toString());
		BackgroundThread.ensureGUI();
		if ( oldSettings==null )
			oldSettings = mSettings;
		final Properties currSettings = new Properties(oldSettings);
		setAppSettings( newSettings, currSettings );
		Properties changedSettings = newSettings.diff(currSettings);
		currSettings.setAll(changedSettings);
    	mBackThread.executeBackground(new Runnable() {
    		public void run() {
    			applySettings(currSettings);
    		}
    	});
//        }
	}

	private void setBackgroundTexture( String textureId ) {
		BackgroundTextureInfo[] textures = mEngine.getAvailableTextures();
		for ( BackgroundTextureInfo item : textures ) {
			if ( item.id.equals(textureId) ) {
				setBackgroundTexture( item );
				return;
			}
		}
		setBackgroundTexture( Engine.NO_TEXTURE );
	}

	private void setBackgroundTexture( BackgroundTextureInfo texture ) {
		if ( !currentBackgroundTexture.equals(texture) ) {
		log.d(""setBackgroundTexture( "" + texture + "" )"");
			currentBackgroundTexture = texture;
			byte[] data = mEngine.getImageData(currentBackgroundTexture);
			setPageBackgroundTextureInternal(data, texture.tiled ? 1 : 0);
		}
	}
	
	BackgroundTextureInfo currentBackgroundTexture = Engine.NO_TEXTURE;
	class CreateViewTask extends Task
	{
        Properties props = new Properties();
        public CreateViewTask( Properties props ) {
       		this.props = props;
       		Properties oldSettings = new Properties(); // may be changed by setAppSettings 
   			setAppSettings(props, oldSettings);
   			props.setAll(oldSettings);
       		mSettings = props;
        }
		public void work() throws Exception {
			BackgroundThread.ensureBackground();
			log.d(""CreateViewTask - in background thread"");
//			BackgroundTextureInfo[] textures = mEngine.getAvailableTextures();
//			byte[] data = mEngine.getImageData(textures[3]);
			byte[] data = mEngine.getImageData(currentBackgroundTexture);
			setPageBackgroundTextureInternal(data, currentBackgroundTexture.tiled?1:0);
			
			//File historyDir = activity.getDir(""settings"", Context.MODE_PRIVATE);
			//File historyDir = new File(Environment.getExternalStorageDirectory(), "".cr3"");
			//historyDir.mkdirs();
			//File historyFile = new File(historyDir, ""cr3hist.ini"");
			
			//File historyFile = new File(activity.getDir(""settings"", Context.MODE_PRIVATE), ""cr3hist.ini"");
			//if ( historyFile.exists() ) {
			//log.d(""Reading history from file "" + historyFile.getAbsolutePath());
			//readHistoryInternal(historyFile.getAbsolutePath());
			//}
	        String css = mEngine.loadResourceUtf8(R.raw.fb2);
	        if ( css!=null && css.length()>0 )
       			setStylesheetInternal(css);
   			applySettings(props);
   			mInitialized = true;
		}
		public void done() {
			log.d(""InitializationFinishedEvent"");
			BackgroundThread.ensureGUI();
	        //setSettings(props, new Properties());
		}
		public void fail( Exception e )
		{
			log.e(""CoolReader engine initialization failed. Exiting."", e);
			mEngine.fatalError(""Failed to init CoolReader engine"");
		}
	}

	public void closeIfOpened( final FileInfo fileInfo )
	{
		if ( this.mBookInfo!=null && this.mBookInfo.getFileInfo().pathname.equals(fileInfo.pathname) && mOpened ) {
			close();
		}
	}
	
	public void loadDocument( final FileInfo fileInfo )
	{
		if ( this.mBookInfo!=null && this.mBookInfo.getFileInfo().pathname.equals(fileInfo.pathname) && mOpened ) {
			log.d(""trying to load already opened document"");
			mActivity.showReader();
			drawPage();
			return;
		}
		post(new LoadDocumentTask(fileInfo, null));
	}

	public boolean loadLastDocument( final Runnable errorHandler )
	{
		BackgroundThread.ensureGUI();
		//BookInfo book = mActivity.getHistory().getLastBook();
		String lastBookName = mActivity.getLastSuccessfullyOpenedBook();
		log.i(""loadLastDocument() is called, lastBookName = "" + lastBookName);
		return loadDocument( lastBookName, errorHandler );
	}
	
	public boolean loadDocument( String fileName, final Runnable errorHandler )
	{
		BackgroundThread.ensureGUI();
		log.i(""loadDocument("" + fileName + "")"");
		if ( fileName==null ) {
			log.v(""loadDocument() : no filename specified"");
			errorHandler.run();
			return false;
		}
		BookInfo book = fileName!=null ? mActivity.getHistory().getBookInfo(fileName) : null;
		if ( book!=null )
			log.v(""loadDocument() : found book in history : "" + book);
		FileInfo fi = null;
		if ( book==null ) {
			log.v(""loadDocument() : book not found in history, looking for location directory"");
			FileInfo dir = mActivity.getScanner().findParent(new FileInfo(fileName), mActivity.getScanner().getRoot());
			if ( dir!=null ) {
				log.v(""loadDocument() : document location found : "" + dir);
				fi = dir.findItemByPathName(fileName);
				log.v(""loadDocument() : item inside location : "" + fi);
			}
			if ( fi==null ) {
				log.v(""loadDocument() : no file item "" + fileName + "" found inside "" + dir);
				errorHandler.run();
				return false;
			}
			if ( fi.isDirectory ) {
				log.v(""loadDocument() : is a directory, opening browser"");
				mActivity.showBrowser(fi);
				return true;
			}
		} else {
			fi = book.getFileInfo();
			log.v(""loadDocument() : item from history : "" + fi);
		}
		post( new LoadDocumentTask(fi, errorHandler) );
		log.v(""loadDocument: LoadDocumentTask("" + fi + "") is posted"");
		return true;
	}
	
	public BookInfo getBookInfo() {
		BackgroundThread.ensureGUI();
		return mBookInfo;
	}
	
	
	private int mBatteryState = 100;
	public void setBatteryState( int state ) {
		if ( state!=mBatteryState ) {
			log.i(""Battery state changed: "" + state);
			mBatteryState = state;
			drawPage();
		}
	}
	
	public int getBatteryState() {
		return mBatteryState;
	}
	
	private static class BitmapFactory {
		public static final int MAX_FREE_LIST_SIZE=2;
		ArrayList<Bitmap> freeList = new ArrayList<Bitmap>(); 
		ArrayList<Bitmap> usedList = new ArrayList<Bitmap>(); 
		public synchronized Bitmap get( int dx, int dy ) {
			for ( int i=0; i<freeList.size(); i++ ) {
				Bitmap bmp = freeList.get(i);
				if ( bmp.getWidth()==dx && bmp.getHeight()==dy ) {
					// found bitmap of proper size
					freeList.remove(i);
					usedList.add(bmp);
					//log.d(""BitmapFactory: reused free bitmap, used list = "" + usedList.size() + "", free list="" + freeList.size());
					return bmp;
				}
			}
			for ( int i=freeList.size()-1; i>=0; i-- ) {
				Bitmap bmp = freeList.remove(i);
				//log.d(""Recycling free bitmap ""+bmp.getWidth()+""x""+bmp.getHeight());
				//bmp.recycle(); //20110109 
			}
			Bitmap bmp = Bitmap.createBitmap(dx, dy, Bitmap.Config.RGB_565);
			//bmp.setDensity(0);
			usedList.add(bmp);
			//log.d(""Created new bitmap ""+dx+""x""+dy+"". New bitmap list size = "" + usedList.size());
			return bmp;
		}
		public synchronized void compact() {
			while ( freeList.size()>0 ) {
				//freeList.get(0).recycle();//20110109
				freeList.remove(0);
			}
		}
		public synchronized void release( Bitmap bmp ) {
			for ( int i=0; i<usedList.size(); i++ ) {
				if ( usedList.get(i)==bmp ) {
					freeList.add(bmp);
					usedList.remove(i);
					while ( freeList.size()>MAX_FREE_LIST_SIZE ) {
						//freeList.get(0).recycle(); //20110109
						freeList.remove(0);
					}
					log.d(""BitmapFactory: bitmap released, used size = "" + usedList.size() + "", free size="" + freeList.size());
					return;
				}
			}
			// unknown bitmap, just recycle
			//bmp.recycle();//20110109
		}
	};
	BitmapFactory factory = new BitmapFactory(); 
	
	class BitmapInfo {
		Bitmap bitmap;
		PositionProperties position;
		void recycle()
		{
			factory.release(bitmap);
			bitmap = null;
			position = null;
		}
		@Override
		public String toString() {
			return ""BitmapInfo [position="" + position + ""]"";
		}
		
	}
	
    private BitmapInfo mCurrentPageInfo;
    private BitmapInfo mNextPageInfo;
	/**
	 * Prepare and cache page image.
	 * Cache is represented by two slots: mCurrentPageInfo and mNextPageInfo.  
	 * If page already exists in cache, returns it (if current page requested, 
	 *  ensures that it became stored as mCurrentPageInfo; if another page requested, 
	 *  no mCurrentPageInfo/mNextPageInfo reordering made).
	 * @param offset is kind of page: 0==current, -1=previous, 1=next page
	 * @return page image and properties, null if requested page is unavailable (e.g. requested next/prev page is out of document range)
	 */
	private BitmapInfo preparePageImage( int offset )
	{
		BackgroundThread.ensureBackground();
		log.v(""preparePageImage( ""+offset+"")"");
		if ( invalidImages ) {
			if ( mCurrentPageInfo!=null )
				mCurrentPageInfo.recycle();
			mCurrentPageInfo = null;
			if ( mNextPageInfo!=null )
				mNextPageInfo.recycle();
			mNextPageInfo = null;
			invalidImages = false;
		}

		if ( internalDX==0 || internalDY==0 ) {
			internalDX=200;
			internalDY=300;
	        resizeInternal(internalDX, internalDY);
		}
		
		PositionProperties currpos = getPositionPropsInternal(null);
		
		boolean isPageView = currpos.pageMode!=0;
		
		BitmapInfo currposBitmap = null;
		if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(currpos) )
			currposBitmap = mCurrentPageInfo;
		else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(currpos) )
			currposBitmap = mNextPageInfo;
		if ( offset==0 ) {
			// Current page requested
			if ( currposBitmap!=null ) {
				if ( mNextPageInfo==currposBitmap ) {
					// reorder pages
					BitmapInfo tmp = mNextPageInfo;
					mNextPageInfo = mCurrentPageInfo;
					mCurrentPageInfo = tmp;
				}
				// found ready page image
				return mCurrentPageInfo;
			}
			if ( mCurrentPageInfo!=null ) {
				mCurrentPageInfo.recycle();
				mCurrentPageInfo = null;
			}
			BitmapInfo bi = new BitmapInfo();
	        bi.position = currpos;
			bi.bitmap = factory.get(internalDX, internalDY);
	        setBatteryStateInternal(mBatteryState);
	        getPageImageInternal(bi.bitmap);
	        mCurrentPageInfo = bi;
	        //log.v(""Prepared new current page image "" + mCurrentPageInfo);
	        return mCurrentPageInfo;
		}
		if ( isPageView ) {
			// PAGES: one of next or prev pages requested, offset is specified as param 
			int cmd1 = offset > 0 ? ReaderCommand.DCMD_PAGEDOWN.nativeId : ReaderCommand.DCMD_PAGEUP.nativeId;
			int cmd2 = offset > 0 ? ReaderCommand.DCMD_PAGEUP.nativeId : ReaderCommand.DCMD_PAGEDOWN.nativeId;
			if ( offset<0 )
				offset = -offset;
			if ( doCommandInternal(cmd1, offset) ) {
				// can move to next page
				PositionProperties nextpos = getPositionPropsInternal(null);
				BitmapInfo nextposBitmap = null;
				if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
					nextposBitmap = mCurrentPageInfo;
				else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
					nextposBitmap = mNextPageInfo;
				if ( nextposBitmap==null ) {
					// existing image not found in cache, overriding mNextPageInfo
					if ( mNextPageInfo!=null )
						mNextPageInfo.recycle();
					mNextPageInfo = null;
					BitmapInfo bi = new BitmapInfo();
			        bi.position = nextpos;
					bi.bitmap = factory.get(internalDX, internalDY);
			        setBatteryStateInternal(mBatteryState);
			        getPageImageInternal(bi.bitmap);
			        mNextPageInfo = bi;
			        nextposBitmap = bi;
			        //log.v(""Prepared new current page image "" + mNextPageInfo);
				}
				// return back to previous page
				doCommandInternal(cmd2, offset);
				return nextposBitmap;
			} else {
				// cannot move to page: out of document range
				return null;
			}
		} else {
			// SCROLL next or prev page requested, with pixel offset specified
			int y = currpos.y + offset;
			if ( doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, y) ) {
				PositionProperties nextpos = getPositionPropsInternal(null);
				BitmapInfo nextposBitmap = null;
				if ( mCurrentPageInfo!=null && mCurrentPageInfo.position.equals(nextpos) )
					nextposBitmap = mCurrentPageInfo;
				else if ( mNextPageInfo!=null && mNextPageInfo.position.equals(nextpos) )
					nextposBitmap = mNextPageInfo;
				if ( nextposBitmap==null ) {
					// existing image not found in cache, overriding mNextPageInfo
					if ( mNextPageInfo!=null )
						mNextPageInfo.recycle();
					mNextPageInfo = null;
					BitmapInfo bi = new BitmapInfo();
			        bi.position = nextpos;
					bi.bitmap = factory.get(internalDX, internalDY);
			        setBatteryStateInternal(mBatteryState);
			        getPageImageInternal(bi.bitmap);
			        mNextPageInfo = bi;
			        nextposBitmap = bi;
				}
				// return back to prev position
				doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, currpos.y);
				return nextposBitmap;
			} else {
				return null;
			}
		}
		
	}
	
	private int lastDrawTaskId = 0;
	private class DrawPageTask extends Task {
		final int id;
		BitmapInfo bi;
		Runnable doneHandler;
		DrawPageTask(Runnable doneHandler)
		{
			this.id = ++lastDrawTaskId;
			this.doneHandler = doneHandler;
		}
		public void work() {
			BackgroundThread.ensureBackground();
			if ( this.id!=lastDrawTaskId ) {
				log.d(""skipping duplicate drawPage request"");
				return;
			}
			nextHiliteId++;
			if ( currentAnimation!=null ) {
				log.d(""skipping drawPage request while scroll animation is in progress"");
				return;
			}
			log.e(""DrawPageTask.work(""+internalDX+"",""+internalDY+"")"");
			bi = preparePageImage(0);
			if ( bi!=null ) {
				draw();
			}
		}
		@Override
		public void done()
		{
			BackgroundThread.ensureGUI();
//			log.d(""drawPage : bitmap is ready, invalidating view to draw new bitmap"");
//			if ( bi!=null ) {
//				setBitmap( bi.bitmap );
//				invalidate();
//			}
//    		if (mOpened)
   			mEngine.hideProgress();
   			if ( doneHandler!=null )
   				doneHandler.run();
		}
		@Override
		public void fail(Exception e) {
   			mEngine.hideProgress();
		}
	};
	
	class ReaderSurfaceView extends SurfaceView {
		public ReaderSurfaceView( Context context )
		{
			super(context);
		}
	}
	
	// SurfaceView callbacks
	@Override
	public void surfaceChanged(SurfaceHolder holder, int format, int width,
			int height) {
		log.i(""surfaceChanged("" + width + "", "" + height + "")"");
		drawPage();
	}

	boolean mSurfaceCreated = false;
	@Override
	public void surfaceCreated(SurfaceHolder holder) {
		log.i(""surfaceCreated()"");
		mSurfaceCreated = true;
		drawPage();
	}

	@Override
	public void surfaceDestroyed(SurfaceHolder holder) {
		log.i(""surfaceDestroyed()"");
		mSurfaceCreated = false;
	}
	
	enum AnimationType {
		SCROLL, // for scroll mode
		PAGE_SHIFT, // for simple page shift
	}

	
	
	private ViewAnimationControl currentAnimation = null;

	private int pageFlipAnimationSpeedMs = DEF_PAGE_FLIP_MS; // if 0 : no animation
	private int pageFlipAnimationMode = PAGE_ANIMATION_SLIDE2; //PAGE_ANIMATION_PAPER; // if 0 : no animation
	private void animatePageFlip( final int dir ) {
		animatePageFlip(dir, null);
	}
	private void animatePageFlip( final int dir, final Runnable onFinishHandler )
	{
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				BackgroundThread.ensureBackground();
				if ( currentAnimation==null ) {
					PositionProperties currPos = getPositionPropsInternal(null);
					if ( currPos==null )
						return;
					int w = currPos.pageWidth;
					int h = currPos.pageHeight;
					int dir2 = dir;
//					if ( currPos.pageMode==2 )
//						if ( dir2==1 )
//							dir2 = 2;
//						else if ( dir2==-1 ) 
//							dir2 = -2;
					int speed = pageFlipAnimationSpeedMs;
					if ( onFinishHandler!=null )
						speed = pageFlipAnimationSpeedMs / 2;
					if ( currPos.pageMode!=0 ) {
						int fromX = dir2>0 ? w : 0;
						int toX = dir2>0 ? 0 : w;
						new PageViewAnimation(fromX, w, dir2);
						if ( currentAnimation!=null ) {
							if ( currentAnimation!=null ) {
								nextHiliteId++;
								hiliteRect = null;
							}
							currentAnimation.update(toX, h/2);
							currentAnimation.move(speed, true);
							currentAnimation.stop(-1, -1);
							if ( onFinishHandler!=null )
								BackgroundThread.guiExecutor.execute(onFinishHandler);
						}
					} else {
						//new ScrollViewAnimation(startY, maxY);
						int fromY = dir>0 ? h*7/8 : 0;
						int toY = dir>0 ? 0 : h*7/8;
						new ScrollViewAnimation(fromY, h);
						if ( currentAnimation!=null ) {
							if ( currentAnimation!=null ) {
								nextHiliteId++;
								hiliteRect = null;
								
							}
							currentAnimation.update(w/2, toY);
							currentAnimation.move(speed, true);
							currentAnimation.stop(-1, -1);
							if ( onFinishHandler!=null )
								BackgroundThread.guiExecutor.execute(onFinishHandler);
						}
					}
				}
			}
		});
	}
	
	static private Rect tapZoneBounds( int startX, int startY, int maxX, int maxY ) {
		if ( startX<0 )
			startX=0;
		if ( startY<0 )
			startY = 0;
		if ( startX>maxX )
			startX = maxX;
		if ( startY>maxY)
			startY = maxY;
		int dx = (maxX + 2) / 3;
		int dy = (maxY + 2) / 3;
		int x0 = startX / dx * dx; 
		int y0 = startY / dy * dy;
		return new Rect(x0, y0, x0+dx, y0+dy);
	}
	
	volatile private int nextHiliteId = 0;
	private final static int HILITE_RECT_ALPHA = 32;
	private Rect hiliteRect = null;
	private void unhiliteTapZone() {
		hiliteTapZone( false, 0, 0, getWidth(), getHeight() );
	}
	private void hiliteTapZone( final boolean hilite, final int startX, final int startY, final int maxX, final int maxY )
	{
		if (DEBUG_ANIMATION) log.d(""highliteTapZone(""+startX + "", "" + startY+"")"");
		final int myHiliteId = ++nextHiliteId;
		int txcolor = mSettings.getColor(PROP_FONT_COLOR, Color.BLACK);
		final int color = (txcolor & 0xFFFFFF) | (HILITE_RECT_ALPHA<<24);
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( myHiliteId != nextHiliteId || (!hilite && hiliteRect==null) )
					return;
				BackgroundThread.ensureBackground();
				final BitmapInfo pageImage = preparePageImage(0);
				if ( pageImage!=null && pageImage.bitmap!=null && pageImage.position!=null ) {
					//PositionProperties currPos = pageImage.position;
					final Rect rc = hilite ? tapZoneBounds( startX, startY, maxX, maxY ) : hiliteRect;
					if ( hilite )
						hiliteRect = rc;
					else
						hiliteRect = null;
					if ( rc!=null )
					drawCallback( new DrawCanvasCallback() {
						@Override
						public void drawTo(Canvas canvas) {
				    		if ( mInitialized && mCurrentPageInfo!=null ) {
				        		log.d(""onDraw() -- drawing page image"");
				        		drawDimmedBitmap(canvas, mCurrentPageInfo.bitmap, rc, rc);
				    			if ( hilite ) {
					    			Paint p = new Paint();
					    			p.setColor(color);
					    			if ( true ) {
					    				canvas.drawRect(new Rect(rc.left, rc.top, rc.right-2, rc.top+2), p);
					    				canvas.drawRect(new Rect(rc.left, rc.top+2, rc.left+2, rc.bottom-2), p);
					    				canvas.drawRect(new Rect(rc.right-2-2, rc.top+2, rc.right-2, rc.bottom-2), p);
					    				canvas.drawRect(new Rect(rc.left+2, rc.bottom-2-2, rc.right-2-2, rc.bottom-2), p);
					    			} else {
					    				canvas.drawRect(rc, p);
					    			}
				    			}
				    		}
						}
						
					}, rc);
				}
			}
			
		});
	}
	private void scheduleUnhilite( int delay ) {
		final int myHiliteId = nextHiliteId;
		mBackThread.postGUI(new Runnable() {
			@Override
			public void run() {
				if ( myHiliteId == nextHiliteId && hiliteRect!=null )
					unhiliteTapZone(); 
			}
		}, delay);
	}
	
	int currentBrightnessValueIndex = -1;
	private void startBrightnessControl(final int startX, final int startY)
	{
		currentBrightnessValueIndex = -1;
		updateBrightnessControl(startX, startY);
	}
	private void updateBrightnessControl(final int x, final int y) {
		int n = OptionsDialog.mBacklightLevels.length;
		int index = n - 1 - y * n / getHeight();
		if ( index<0 )
			index = 0;
		else if ( index>=n )
			index = n-1;
		if ( index != currentBrightnessValueIndex ) {
			currentBrightnessValueIndex = index;
			int newValue = OptionsDialog.mBacklightLevels[currentBrightnessValueIndex]; 
			mActivity.setScreenBacklightLevel(newValue);
		}
		
	}
	private void stopBrightnessControl(final int x, final int y) {
		if ( currentBrightnessValueIndex>=0 ) {
			if ( x>=0 && y>=0 ) {
				updateBrightnessControl(x, y);
			}
			mSettings.setInt(PROP_APP_SCREEN_BACKLIGHT, OptionsDialog.mBacklightLevels[currentBrightnessValueIndex]);
			OptionsDialog.mBacklightLevelsTitles[0] = mActivity.getString(R.string.options_app_backlight_screen_default);
			String s = OptionsDialog.mBacklightLevelsTitles[currentBrightnessValueIndex];
			if ( showBrightnessFlickToast )
				mActivity.showToast(s);
			mActivity.saveSettings(mSettings);
			currentBrightnessValueIndex = -1;
		}
	}
	private static final boolean showBrightnessFlickToast = false;


	private void startAnimation( final int startX, final int startY, final int maxX, final int maxY )
	{
		if (DEBUG_ANIMATION) log.d(""startAnimation(""+startX + "", "" + startY+"")"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				BackgroundThread.ensureBackground();
				PositionProperties currPos = getPositionPropsInternal(null);
				if ( currPos!=null && currPos.pageMode!=0 ) {
					//int dir = startX > maxX/2 ? currPos.pageMode : -currPos.pageMode;
					int dir = startX > maxX/2 ? 1 : -1;
					int sx = startX;
					if ( dir<0 )
						sx = 0;
					new PageViewAnimation(sx, maxX, dir);
				} else {
					new ScrollViewAnimation(startY, maxY);
				}
				if ( currentAnimation!=null ) {
					nextHiliteId++;
					hiliteRect = null;
				}
			}
			
		});
	}

	
	private final static boolean DEBUG_ANIMATION = false;
	private volatile int updateSerialNumber = 0;
	private void updateAnimation( final int x, final int y )
	{
		if (DEBUG_ANIMATION) log.d(""updateAnimation(""+x + "", "" + y+"")"");
		final int serial = ++updateSerialNumber;
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( currentAnimation!=null ) {
					currentAnimation.update(x, y);
					if ( serial==updateSerialNumber ) //|| serial==updateSerialNumber-1 
						currentAnimation.animate();
				}
			}
		});
		try {
			// give a chance to background thread to process event faster
			Thread.sleep(0);
		} catch ( InterruptedException e ) {
			// ignore
		}
	}
	
	private void stopAnimation( final int x, final int y )
	{
		if (DEBUG_ANIMATION) log.d(""stopAnimation(""+x+"", ""+y+"")"");
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( currentAnimation!=null ) {
					currentAnimation.stop(x, y);
				}
			}
			
		});
	}

	private int animationSerialNumber = 0;
	private void scheduleAnimation()
	{
		final int serial = ++animationSerialNumber; 
		BackgroundThread.backgroundExecutor.execute(new Runnable() {
			@Override
			public void run() {
				if ( serial!=animationSerialNumber )
					return;
				if ( currentAnimation!=null ) {
					currentAnimation.animate();
				}
			}
		});
	}
	
	interface ViewAnimationControl
	{
		public void update( int x, int y );
		public void stop( int x, int y );
		public void animate();
		public void move( int duration, boolean accelerated );
		public boolean isStarted();
	}

	private Object surfaceLock = new Object(); 

	private static final int[] accelerationShape = new int[] {
		0, 6, 24, 54, 95, 146, 206, 273, 345, 421, 500, 578, 654, 726, 793, 853, 904, 945, 975, 993, 1000  
	};
	static public int accelerate( int x0, int x1, int x )
	{
		if ( x<x0 )
			x = x0;
		if (x>x1)
			x = x1;
		int intervals = accelerationShape.length - 1;
		int pos = 100 * intervals * (x - x0) / (x1-x0);
		int interval = pos / 100;
		int part = pos % 100;
		if ( interval<0 )
			interval = 0;
		else if ( interval>intervals )
			interval = intervals;
		int y = interval==intervals ? 100000 : accelerationShape[interval]*100 + (accelerationShape[interval+1]-accelerationShape[interval]) * part;
		return x0 + (x1 - x0) * y / 100000;
	}

	private interface DrawCanvasCallback {
		public void drawTo( Canvas c );
	}
	private void drawCallback( DrawCanvasCallback callback, Rect rc )
	{
		if ( !mSurfaceCreated )
			return;
		//synchronized(surfaceLock) { }
		//log.v(""draw() - in thread "" + Thread.currentThread().getName());
		final SurfaceHolder holder = getHolder();
		//log.v(""before synchronized(surfaceLock)"");
		if ( holder!=null )
		//synchronized(surfaceLock) 
		{
			Canvas canvas = null;
			long startTs = android.os.SystemClock.uptimeMillis();
			try {
				canvas = holder.lockCanvas(rc);
				//log.v(""before draw(canvas)"");
				if ( canvas!=null ) {
					callback.drawTo(canvas);
				}
			} finally {
				//log.v(""exiting finally"");
				if ( canvas!=null && getHolder()!=null ) {
					//log.v(""before unlockCanvasAndPost"");
					if ( canvas!=null && holder!=null ) {
						holder.unlockCanvasAndPost(canvas);
						//if ( rc==null ) {
							long endTs = android.os.SystemClock.uptimeMillis();
							updateAnimationDurationStats(endTs - startTs);
						//}
					}
					//log.v(""after unlockCanvasAndPost"");
				}
			}
		}
		//log.v(""exiting draw()"");
	}
	
	abstract class ViewAnimationBase implements ViewAnimationControl {
		long startTimeStamp;
		boolean started;
		public boolean isStarted()
		{
			return started;
		}
		ViewAnimationBase()
		{
			startTimeStamp = android.os.SystemClock.uptimeMillis();
		}
		public void close()
		{
			currentAnimation = null;
		}

		

		public void draw()
		{
			drawCallback( new DrawCanvasCallback() {
				@Override
				public void drawTo(Canvas c) {
					//long startTs = android.os.SystemClock.uptimeMillis();
					draw(c);
					//long endTs = android.os.SystemClock.uptimeMillis();
					//updateAnimationDurationStats(endTs - startTs);
				}
				
			}, null);
		}
		abstract void draw( Canvas canvas );
	}
	
	//private static final int PAGE_ANIMATION_DURATION = 3000;
	class ScrollViewAnimation extends ViewAnimationBase {
		int startY;
		int maxY;
		int pointerStartPos;
		int pointerDestPos;
		int pointerCurrPos;
		ScrollViewAnimation( int startY, int maxY )
		{
			super();
			this.startY = startY;
			this.maxY = maxY;
			long start = android.os.SystemClock.uptimeMillis();
			log.v(""ScrollViewAnimation -- creating: drawing two pages to buffer"");
			PositionProperties currPos = getPositionPropsInternal(null);
			int pos = currPos.y;
			int pos0 = pos - (maxY - startY);
			if ( pos0<0 )
				pos0 = 0;
			pointerStartPos = pos;
			pointerCurrPos = pos;
			pointerDestPos = startY;
			BitmapInfo image1;
			BitmapInfo image2;
			doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pos0);
			image1 = preparePageImage(0);
			image2 = preparePageImage(image1.position.pageHeight);
//			doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pos0 + image1.position.pageHeight);
//			image2 = preparePageImage(0);
			doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pos);
			if ( image1==null || image2==null ) {
				log.v(""ScrollViewAnimation -- not started: image is null"");
				return;
			}
			long duration = android.os.SystemClock.uptimeMillis() - start;
			log.v(""ScrollViewAnimation -- created in "" + duration + "" millis"");
			currentAnimation = this;
		}
		
		@Override
		public void stop(int x, int y) {
			//if ( started ) {
				if ( y!=-1 ) {
					int delta = startY - y;
					pointerCurrPos = pointerStartPos + delta;
				}
				pointerDestPos = pointerCurrPos;
				draw();
				doCommandInternal(ReaderCommand.DCMD_GO_POS.nativeId, pointerDestPos);
			//}
			close();
		}

		@Override
		public void move( int duration, boolean accelerated  ) {
			if ( duration>0  && pageFlipAnimationSpeedMs!=0 ) {
				int steps = (int)(duration / getAvgAnimationDrawDuration()) + 2;
				int x0 = pointerCurrPos;
				int x1 = pointerDestPos;
				if ( (x0-x1)<10 && (x0-x1)>-10 )
					steps = 2;
				for ( int i=1; i<steps; i++ ) {
					int x = x0 + (x1-x0) * i / steps;
					pointerCurrPos = accelerated ? accelerate( x0, x1, x ) : x; 
					draw();
				}
			}
			pointerCurrPos = pointerDestPos; 
			draw();
		}

		@Override
		public void update(int x, int y) {
			int delta = startY - y;
			pointerDestPos = pointerStartPos + delta;
		}

		public void animate()
		{
			//log.d(""animate() is called"");
			if ( pointerDestPos != pointerCurrPos ) {
				if ( !started )
					started = true;
				if ( pageFlipAnimationSpeedMs==0 )
					pointerCurrPos = pointerDestPos;
				else {
					int delta = pointerCurrPos-pointerDestPos;
					if ( delta<0 )
						delta = -delta;
					long avgDraw = getAvgAnimationDrawDuration();
					//int maxStep = (int)(maxY * PAGE_ANIMATION_DURATION / avgDraw);
					int maxStep = pageFlipAnimationSpeedMs > 0 ? (int)(maxY * 1000 / avgDraw / pageFlipAnimationSpeedMs) : maxY;
					int step;
					if ( delta > maxStep * 2 )
						step = maxStep;
					else
						step = (delta + 3) / 4;
					//int step = delta<3 ? 1 : (delta<5 ? 2 : (delta<10 ? 3 : (delta<15 ? 6 : (delta<25 ? 10 : (delta<50 ? 15 : 30))))); 
					if ( pointerCurrPos<pointerDestPos )
						pointerCurrPos+=step;
					else if ( pointerCurrPos>pointerDestPos )
						pointerCurrPos-=step;
					log.d(""animate(""+pointerCurrPos + "" => "" + pointerDestPos + ""  step="" + step + "")"");
				}
				//pointerCurrPos = pointerDestPos;
				draw();
				if ( pointerDestPos != pointerCurrPos )
					scheduleAnimation();
			}
		}

		public void draw(Canvas canvas)
		{
			BitmapInfo image1 = mCurrentPageInfo;
			BitmapInfo image2 = mNextPageInfo;
			int h = image1.position.pageHeight;
			int rowsFromImg1 = image1.position.y + h - pointerCurrPos;
			int rowsFromImg2 = h - rowsFromImg1;
    		Rect src1 = new Rect(0, h-rowsFromImg1, mCurrentPageInfo.bitmap.getWidth(), h);
    		Rect dst1 = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), rowsFromImg1);
    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			if (image2!=null) {
	    		Rect src2 = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), rowsFromImg2);
	    		Rect dst2 = new Rect(0, rowsFromImg1, mCurrentPageInfo.bitmap.getWidth(), h);
	    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
			}
			//log.v(""anim.drawScroll( pos="" + pointerCurrPos + "", "" + src1 + ""=>"" + dst1 + "", "" + src2 + ""=>"" + dst2 + "" )"");
		}
	}

	private final static int SIN_TABLE_SIZE = 1024;
	private final static int SIN_TABLE_SCALE = 0x10000;
	private final static int PI_DIV_2 = (int)(Math.PI / 2 * SIN_TABLE_SCALE);
	/// sin table, for 0..PI/2
	private static int[] SIN_TABLE = new int[SIN_TABLE_SIZE+1];
	private static int[] ASIN_TABLE = new int[SIN_TABLE_SIZE+1];
	// mapping of 0..1 shift to angle
	private static int[] SRC_TABLE = new int[SIN_TABLE_SIZE+1];
	// mapping of 0..1 shift to sin(angle)
	private static int[] DST_TABLE = new int[SIN_TABLE_SIZE+1];
	// for dx=0..1 find such alpha (0..pi/2) that alpha - sin(alpha) = dx  
	private static double shiftfn( double dx ) {
		double a = 0;
		double b = Math.PI/2;
		double c = 0;
		for ( int i=0; i<15; i++ ) {
			c = (a + b) / 2;
			double cq = c - Math.sin(c);
			if ( cq < dx )
				a = c;
			else
				b = c;
		}
		return c;
	}
	static {
		for ( int i=0; i<=SIN_TABLE_SIZE; i++ ) {
			double angle = Math.PI / 2 * i / SIN_TABLE_SIZE;
			int s = (int)Math.round(Math.sin(angle) * SIN_TABLE_SCALE);
			SIN_TABLE[i] = s;
			double x = (double)i / SIN_TABLE_SIZE;
			s = (int)Math.round(Math.asin(x) * SIN_TABLE_SCALE);
			ASIN_TABLE[i] = s;
			
			double dx = i * (Math.PI/2 - 1.0) / SIN_TABLE_SIZE;
			angle = shiftfn( dx );
			SRC_TABLE[i] = (int)Math.round(angle * SIN_TABLE_SCALE);
			DST_TABLE[i] = (int)Math.round(Math.sin(angle) * SIN_TABLE_SCALE);
		}
	}
	
	class PageViewAnimation extends ViewAnimationBase {
		int startX;
		int maxX;
		int page1;
		int page2;
		int direction;
		int currShift;
		int destShift;
		int pageCount;
		Paint divPaint;
		Paint[] shadePaints;
		Paint[] hilitePaints;
		private final boolean naturalPageFlip; 
		private final boolean flipTwoPages; 
		PageViewAnimation( int startX, int maxX, int direction )
		{
			super();
			this.startX = startX;
			this.maxX = maxX;
			this.direction = direction;
			this.currShift = 0;
			this.destShift = 0;
			this.naturalPageFlip = (pageFlipAnimationMode==PAGE_ANIMATION_PAPER);
			this.flipTwoPages = (pageFlipAnimationMode==PAGE_ANIMATION_SLIDE2);
			
			long start = android.os.SystemClock.uptimeMillis();
			log.v(""PageViewAnimation -- creating: drawing two pages to buffer"");
			
			PositionProperties currPos = mCurrentPageInfo.position;
			if ( currPos==null )
				currPos = getPositionPropsInternal(null);
			page1 = currPos.pageNumber;
			page2 = currPos.pageNumber + direction;
			if ( page2<0 || page2>=currPos.pageCount) {
				currentAnimation = null;
				return;
			}
			this.pageCount = currPos.pageMode;
			BitmapInfo image1 = preparePageImage(0);
			BitmapInfo image2 = preparePageImage(direction);
			if ( image1==null || image2==null ) {
				log.v(""PageViewAnimation -- cannot start animation: page image is null"");
				return;
			}
			if ( page1==page2 ) {
				log.v(""PageViewAnimation -- cannot start animation: not moved"");
				return;
			}
			page2 = image2.position.pageNumber;
			currentAnimation = this;
			divPaint = new Paint();
			divPaint.setStyle(Paint.Style.FILL);
			divPaint.setColor(Color.argb(128, 128, 128, 128));
			final int numPaints = 16;
			shadePaints = new Paint[numPaints];
			hilitePaints = new Paint[numPaints];
			for ( int i=0; i<numPaints; i++ ) {
				shadePaints[i] = new Paint();
				hilitePaints[i] = new Paint();
				hilitePaints[i].setStyle(Paint.Style.FILL);
				shadePaints[i].setStyle(Paint.Style.FILL);
				if ( mActivity.isNightMode() ) {
					shadePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 0, 0, 0));
					hilitePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 128, 128, 128));
				} else {
					shadePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 0, 0, 0));
					hilitePaints[i].setColor(Color.argb((i+1)*96 / numPaints, 255, 255, 255));
				}
			}

			
			long duration = android.os.SystemClock.uptimeMillis() - start;
			log.d(""PageViewAnimation -- created in "" + duration + "" millis"");
		}
		
		private void drawGradient( Canvas canvas, Rect rc, Paint[] paints, int startIndex, int endIndex ) {
			int n = (startIndex<endIndex) ? endIndex-startIndex+1 : startIndex-endIndex + 1;
			int dir = (startIndex<endIndex) ? 1 : -1;
			int dx = rc.right - rc.left;
			Rect rect = new Rect(rc);
			for ( int i=0; i<n; i++ ) {
				int index = startIndex + i*dir;
				int x1 = rc.left + dx*i/n;
				int x2 = rc.left + dx*(i+1)/n;
				if ( x2>rc.right )
					x2 = rc.right;
				rect.left = x1;
				rect.right = x2;
				if ( x2>x1 ) {
					canvas.drawRect(rect, paints[index]);
				}
			}
		}
		
		private void drawShadow( Canvas canvas, Rect rc ) {
			drawGradient(canvas, rc, shadePaints, shadePaints.length/2, shadePaints.length/10);
		}
		
		private final int DISTORT_PART_PERCENT = 30;
		private void drawDistorted( Canvas canvas, Bitmap bmp, Rect src, Rect dst, int dir) {
			int srcdx = src.width();
			int dstdx = dst.width();
			int dx = srcdx - dstdx;
			int maxdistortdx = srcdx * DISTORT_PART_PERCENT / 100;
			int maxdx = maxdistortdx * (PI_DIV_2 - SIN_TABLE_SCALE) / SIN_TABLE_SCALE;
			int maxdistortsrc = maxdistortdx * PI_DIV_2 / SIN_TABLE_SCALE;
			
			int distortdx = dx < maxdistortdx ? dx : maxdistortdx;
			int distortsrcstart = -1;
			int distortsrcend = -1;
			int distortdststart = -1;
			int distortdstend = -1;
			int distortanglestart = -1;
			int distortangleend = -1;
			int normalsrcstart = -1;
			int normalsrcend = -1;
			int normaldststart = -1;
			int normaldstend = -1;
			
			if ( dx < maxdx ) {
				// start
				int index = dx>=0 ? dx * SIN_TABLE_SIZE / maxdx : 0;
				int dstv = DST_TABLE[index] * maxdistortdx / SIN_TABLE_SCALE;
				distortdststart = distortsrcstart = dstdx - dstv;
				distortsrcend = srcdx;
				distortdstend = dstdx;
				normalsrcstart = normaldststart = 0;
				normalsrcend = distortsrcstart;
				normaldstend = distortdststart;
				distortanglestart = 0;
				distortangleend = SRC_TABLE[index];
				distortdx = maxdistortdx;
			} else if (dstdx>maxdistortdx) {
				// middle
				distortdststart = distortsrcstart = dstdx - maxdistortdx;
				distortsrcend = distortsrcstart + maxdistortsrc;
				distortdstend = dstdx;
				normalsrcstart = normaldststart = 0;
				normalsrcend = distortsrcstart;
				normaldstend = distortdststart;
				distortanglestart = 0;
				distortangleend = PI_DIV_2;
			} else {
				// end
				normalsrcstart = normaldststart = normalsrcend = normaldstend = -1;
				distortdx = dstdx;
				distortsrcstart = 0;
				int n = maxdistortdx >= dstdx ? maxdistortdx - dstdx : 0;
				distortsrcend = ASIN_TABLE[SIN_TABLE_SIZE * n/maxdistortdx ] * maxdistortsrc / SIN_TABLE_SCALE;
				distortdststart = 0;
				distortdstend = dstdx;
				distortangleend = PI_DIV_2; 
				n = maxdistortdx >= distortdx ? maxdistortdx - distortdx : 0;
				distortanglestart = ASIN_TABLE[SIN_TABLE_SIZE * (maxdistortdx - distortdx)/maxdistortdx ];
			}
			
			Rect srcrc = new Rect(src);
			Rect dstrc = new Rect(dst);
			if ( normalsrcstart<normalsrcend ) {
				if ( dir>0 ) {
					srcrc.left = src.left + normalsrcstart;
					srcrc.right = src.left + normalsrcend;
					dstrc.left = dst.left + normaldststart;
					dstrc.right = dst.left + normaldstend;
				} else {
					srcrc.right = src.right - normalsrcstart;
					srcrc.left = src.right - normalsrcend;
					dstrc.right = dst.right - normaldststart;
					dstrc.left = dst.right - normaldstend;
				}
				drawDimmedBitmap(canvas, bmp, srcrc, dstrc);
			}
			if ( distortdststart<distortdstend ) {
				int n = distortdx / 5 + 1;
				int dst0 = SIN_TABLE[distortanglestart * SIN_TABLE_SIZE / PI_DIV_2] * maxdistortdx / SIN_TABLE_SCALE; 
				int src0 = distortanglestart * maxdistortdx / SIN_TABLE_SCALE;
				for ( int i=0; i<n; i++ ) {
					int angledelta = distortangleend - distortanglestart;
					int startangle = distortanglestart + i * angledelta / n;
					int endangle = distortanglestart + (i+1) * angledelta / n;
					int src1 = startangle * maxdistortdx / SIN_TABLE_SCALE - src0;
					int src2 = endangle * maxdistortdx / SIN_TABLE_SCALE - src0;
					int dst1 = SIN_TABLE[startangle * SIN_TABLE_SIZE / PI_DIV_2] * maxdistortdx / SIN_TABLE_SCALE - dst0;
					int dst2 = SIN_TABLE[endangle * SIN_TABLE_SIZE / PI_DIV_2] * maxdistortdx / SIN_TABLE_SCALE - dst0;
					int hiliteIndex = startangle * hilitePaints.length / PI_DIV_2;
					Paint[] paints;
					if ( dir>0 ) {
						dstrc.left = dst.left + distortdststart + dst1; 
						dstrc.right = dst.left + distortdststart + dst2;
						srcrc.left = src.left + distortsrcstart + src1;
						srcrc.right = src.left + distortsrcstart + src2;
						paints = hilitePaints;
					} else {
						dstrc.right = dst.right - distortdststart - dst1; 
						dstrc.left = dst.right - distortdststart - dst2;
						srcrc.right = src.right - distortsrcstart - src1;
						srcrc.left = src.right - distortsrcstart - src2;
						paints = shadePaints;
					}
					drawDimmedBitmap(canvas, bmp, srcrc, dstrc);
					canvas.drawRect(dstrc, paints[hiliteIndex]);
				}
			}
		}
		
		@Override
		public void move( int duration, boolean accelerated ) {
			if ( duration > 0 && pageFlipAnimationSpeedMs!=0 ) {
				int steps = (int)(duration / getAvgAnimationDrawDuration()) + 2;
				int x0 = currShift;
				int x1 = destShift;
				if ( (x0-x1)<10 && (x0-x1)>-10 )
					steps = 2;
				for ( int i=1; i<steps; i++ ) {
					int x = x0 + (x1-x0) * i / steps;
					currShift = accelerated ? accelerate( x0, x1, x ) : x;
					draw();
				}
			}
			currShift = destShift;
			draw();
		}

		@Override
		public void stop(int x, int y) {
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.stop("" + x + "", "" + y + "")"");
			//if ( started ) {
				boolean moved = false;
				if ( x!=-1 ) {
					int threshold = mActivity.getPalmTipPixels() * 7/8;
					if ( direction>0 ) {
						// |  <=====  |
						int dx = startX - x; 
						if ( dx>threshold )
							moved = true;
					} else {
						// |  =====>  |
						int dx = x - startX; 
						if ( dx>threshold )
							moved = true;
					}
					int duration;
					if ( moved ) {
						destShift = maxX;
						duration = 300; // 500 ms forward
					} else {
						destShift = 0;
						duration = 200; // 200 ms cancel
					}
					move( duration, false );
				} else {
					moved = true;
				}
				doCommandInternal(ReaderCommand.DCMD_GO_PAGE_DONT_SAVE_HISTORY.nativeId, moved ? page2 : page1);
			//}
			close();
			// preparing images for next page flip
			preparePageImage(0);
			preparePageImage(direction);
			//if ( started )
			//	drawPage();
		}

		@Override
		public void update(int x, int y) {
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.update("" + x + "", "" + y + "")"");
			int delta = direction>0 ? startX - x : x - startX;
			if ( delta<=0 )
				destShift = 0;
			else if ( delta<maxX )
				destShift = delta;
			else
				destShift = maxX;
		}

		public void animate()
		{
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.animate(""+currShift + "" => "" + destShift + "") speed="" + pageFlipAnimationSpeedMs);
			//log.d(""animate() is called"");
			if ( currShift != destShift ) {
				started = true;
				if ( pageFlipAnimationSpeedMs==0 )
					currShift = destShift;
				else {
					int delta = currShift - destShift;
					if ( delta<0 )
						delta = -delta;
					long avgDraw = getAvgAnimationDrawDuration();
					int maxStep = pageFlipAnimationSpeedMs > 0 ? (int)(maxX * 1000 / avgDraw / pageFlipAnimationSpeedMs) : maxX;
					int step;
					if ( delta > maxStep * 2 )
						step = maxStep;
					else
						step = (delta + 3) / 4;
					//int step = delta<3 ? 1 : (delta<5 ? 2 : (delta<10 ? 3 : (delta<15 ? 6 : (delta<25 ? 10 : (delta<50 ? 15 : 30))))); 
					if ( currShift < destShift )
						currShift+=step;
					else if ( currShift > destShift )
						currShift-=step;
					if (DEBUG_ANIMATION) log.v(""PageViewAnimation.animate(""+currShift + "" => "" + destShift + ""  step="" + step + "")"");
				}
				//pointerCurrPos = pointerDestPos;
				draw();
				if ( currShift != destShift )
					scheduleAnimation();
			}
		}

		public void draw(Canvas canvas)
		{
			if (DEBUG_ANIMATION) log.v(""PageViewAnimation.draw(""+currShift + "")"");
			BitmapInfo image1 = mCurrentPageInfo;
			BitmapInfo image2 = mNextPageInfo;
			int w = image1.bitmap.getWidth(); 
			int h = image1.bitmap.getHeight();
			int div;
			if ( direction > 0 ) {
				// FORWARD
				div = w-currShift;
				Rect shadowRect = new Rect(div, 0, div+w/10, h);
				if ( naturalPageFlip ) {
					if ( this.pageCount==2 ) {
						int w2 = w/2;
						if ( div<w2 ) {
							// left - part of old page
				    		Rect src1 = new Rect(0, 0, div, h);
				    		Rect dst1 = new Rect(0, 0, div, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
							// left, resized part of new page
				    		Rect src2 = new Rect(0, 0, w2, h);
				    		Rect dst2 = new Rect(div, 0, w2, h);
				    		//canvas.drawBitmap(image2.bitmap, src2, dst2, null);
							drawDistorted(canvas, image2.bitmap, src2, dst2, -1);
							// right, new page
				    		Rect src3 = new Rect(w2, 0, w, h);
				    		Rect dst3 = new Rect(w2, 0, w, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src3, dst3);

						} else {
							// left - old page
				    		Rect src1 = new Rect(0, 0, w2, h);
				    		Rect dst1 = new Rect(0, 0, w2, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
							// right, resized old page
				    		Rect src2 = new Rect(w2, 0, w, h);
				    		Rect dst2 = new Rect(w2, 0, div, h);
				    		//canvas.drawBitmap(image1.bitmap, src2, dst2, null);
							drawDistorted(canvas, image1.bitmap, src2, dst2, 1);
							// right, new page
				    		Rect src3 = new Rect(div, 0, w, h);
				    		Rect dst3 = new Rect(div, 0, w, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src3, dst3);

							if ( div>0 && div<w )
								drawShadow( canvas, shadowRect );
						}
					} else {
			    		Rect src1 = new Rect(0, 0, w, h);
			    		Rect dst1 = new Rect(0, 0, w-currShift, h);
			    		//log.v(""drawing "" + image1);
						//canvas.drawBitmap(image1.bitmap, src1, dst1, null);
						drawDistorted(canvas, image1.bitmap, src1, dst1, 1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(w-currShift, 0, w, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);

						if ( div>0 && div<w )
							drawShadow( canvas, shadowRect );
					}
				} else {
					if ( flipTwoPages ) {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(0, 0, w-currShift, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(0, 0, currShift, h);
			    		Rect dst2 = new Rect(w-currShift, 0, w, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					} else {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(0, 0, w-currShift, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(w-currShift, 0, w, h);
			    		//log.v(""drawing "" + image1);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					}
				}
			} else {
				// BACK
				div = currShift;
				Rect shadowRect = new Rect(div, 0, div+10, h);
				if ( naturalPageFlip ) {
					if ( this.pageCount==2 ) {
						int w2 = w/2;
						if ( div<w2 ) {
							// left - part of old page
				    		Rect src1 = new Rect(0, 0, div, h);
				    		Rect dst1 = new Rect(0, 0, div, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src1, dst1);
							// left, resized part of new page
				    		Rect src2 = new Rect(0, 0, w2, h);
				    		Rect dst2 = new Rect(div, 0, w2, h);
				    		//canvas.drawBitmap(image1.bitmap, src2, dst2, null);
							drawDistorted(canvas, image1.bitmap, src2, dst2, -1);
							// right, new page
				    		Rect src3 = new Rect(w2, 0, w, h);
				    		Rect dst3 = new Rect(w2, 0, w, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src3, dst3);
						} else {
							// left - old page
				    		Rect src1 = new Rect(0, 0, w2, h);
				    		Rect dst1 = new Rect(0, 0, w2, h);
				    		drawDimmedBitmap(canvas, image2.bitmap, src1, dst1);
							// right, resized old page
				    		Rect src2 = new Rect(w2, 0, w, h);
				    		Rect dst2 = new Rect(w2, 0, div, h);
				    		//canvas.drawBitmap(image2.bitmap, src2, dst2, null);
							drawDistorted(canvas, image2.bitmap, src2, dst2, 1);
							// right, new page
				    		Rect src3 = new Rect(div, 0, w, h);
				    		Rect dst3 = new Rect(div, 0, w, h);
				    		drawDimmedBitmap(canvas, image1.bitmap, src3, dst3);

							if ( div>0 && div<w )
								drawShadow( canvas, shadowRect );
						}
					} else {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(currShift, 0, w, h);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(0, 0, w, h);
			    		Rect dst2 = new Rect(0, 0, currShift, h);
						//canvas.drawBitmap(image2.bitmap, src2, dst2, null);
						drawDistorted(canvas, image2.bitmap, src2, dst2, 1);

						if ( div>0 && div<w )
							drawShadow( canvas, shadowRect );
					}
				} else {
					if ( flipTwoPages ) {
			    		Rect src1 = new Rect(0, 0, w-currShift, h);
			    		Rect dst1 = new Rect(currShift, 0, w, h);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(0, 0, currShift, h);
			    		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					} else {
			    		Rect src1 = new Rect(currShift, 0, w, h);
			    		Rect dst1 = new Rect(currShift, 0, w, h);
			    		drawDimmedBitmap(canvas, image1.bitmap, src1, dst1);
			    		Rect src2 = new Rect(w-currShift, 0, w, h);
			    		Rect dst2 = new Rect(0, 0, currShift, h);
		        		drawDimmedBitmap(canvas, image2.bitmap, src2, dst2);
					}
				}
			}
			if ( div>0 && div<w ) {
				canvas.drawLine(div, 0, div, h, divPaint);
			}
		}
	}

	private long sumAnimationDrawDuration = 500;
	private int drawAnimationCount = 10;
	private long getAvgAnimationDrawDuration()
	{
		return sumAnimationDrawDuration / drawAnimationCount; 
//		return sumAnimationDrawDuration;// / drawAnimationCount; 
	}
	
	private void updateAnimationDurationStats( long duration )
	{
		if ( duration<=0 )
			duration = 1;
		else if ( duration>1000 )
			return;
//		sumAnimationDrawDuration = (sumAnimationDrawDuration*7 + duration * 1)/8;
		sumAnimationDrawDuration += duration;
		if ( ++drawAnimationCount>20 ) {
			drawAnimationCount /= 2;
			sumAnimationDrawDuration /= 2;
		}
	}
	
	private void drawPage()
	{
		drawPage(null);
	}
	private void drawPage( Runnable doneHandler )
	{
		if ( !mInitialized || !mOpened )
			return;
		log.v(""drawPage() : submitting DrawPageTask"");
		post( new DrawPageTask(doneHandler) );
	}
	
	private int internalDX = 0;
	private int internalDY = 0;

	private byte[] coverPageBytes = null;
	private BitmapDrawable coverPageDrawable = null;
	private void findCoverPage()
	{
    	log.d(""document is loaded succesfull, checking coverpage data"");
    	if ( mActivity.getHistory().getCoverPagesEnabled() ) {
	    	byte[] coverpageBytes = getCoverPageDataInternal();
	    	if ( coverpageBytes!=null ) {
	    		log.d(""Found cover page data: "" + coverpageBytes.length + "" bytes"");
	    		BitmapDrawable drawable = mActivity.getHistory().decodeCoverPage(coverpageBytes);
	    		if ( drawable!=null ) {
	    			coverPageBytes = coverpageBytes;
	    			coverPageDrawable = drawable;
	    		}
	    	}
    	}
	}
	
	private class LoadDocumentTask extends Task
	{
		String filename;
		Runnable errorHandler;
		String pos;
		LoadDocumentTask( FileInfo fileInfo, Runnable errorHandler )
		{
			log.v(""LoadDocumentTask for "" + fileInfo);
			BackgroundThread.ensureGUI();
			this.filename = fileInfo.getPathName();
			this.errorHandler = errorHandler;
			//FileInfo fileInfo = new FileInfo(filename);
			mBookInfo = mActivity.getHistory().getOrCreateBookInfo( fileInfo );
	    	if ( mBookInfo!=null && mBookInfo.getLastPosition()!=null )
	    		pos = mBookInfo.getLastPosition().getStartPos();
			log.v(""LoadDocumentTask : book info "" + mBookInfo);
			log.v(""LoadDocumentTask : last position = "" + pos);
    		//mBitmap = null;
	        mEngine.showProgress( 1000, R.string.progress_loading );
	        //init();
		}

		public void work() throws IOException {
			BackgroundThread.ensureBackground();
			coverPageBytes = null;
			coverPageDrawable = null;
			log.i(""Loading document "" + filename);
	        boolean success = loadDocumentInternal(filename);
	        if ( success ) {
				log.v(""loadDocumentInternal completed successfully"");
	        	findCoverPage();
				log.v(""requesting page image, to render"");
	        	preparePageImage(0);
				log.v(""updating loaded book info"");
	        	updateLoadedBookInfo();
				log.i(""Document "" + filename + "" is loaded successfully"");
				if ( pos!=null ) {
					log.i(""Restoring position : "" + pos);
					restorePositionBackground(pos);
				}
				CoolReader.dumpHeapAllocation();
	        } else {
				log.e(""Error occured while trying to load document "" + filename);
				throw new IOException(""Cannot read document"");
	        }
		}
		public void done()
		{
			BackgroundThread.ensureGUI();
			log.d(""LoadDocumentTask, GUI thread is finished successfully"");
			if ( mActivity.getHistory()!=null ) {
	    		mActivity.getHistory().updateBookAccess(mBookInfo);
	    		mActivity.getHistory().saveToDB();
		        if ( coverPageBytes!=null && coverPageDrawable!=null && mBookInfo!=null && mBookInfo.getFileInfo()!=null ) {
		        	mActivity.getHistory().setBookCoverpageData( mBookInfo.getFileInfo().id, coverPageBytes );
		        	//mEngine.setProgressDrawable(coverPageDrawable);
		        }
		        mOpened = true;
		        drawPage();
		        mBackThread.postGUI(new Runnable() {
		        	public void run() {
		    			mActivity.showReader();
		        	}
		        });
		        mActivity.setLastSuccessfullyOpenedBook(filename);
			}
		}
		public void fail( Exception e )
		{
			BackgroundThread.ensureGUI();
			log.e(""LoadDocumentTask failed for "" + mBookInfo);
			mActivity.getHistory().removeBookInfo( mBookInfo.getFileInfo(), true, false );
			mBookInfo = null;
			log.d(""LoadDocumentTask is finished with exception "" + e.getMessage());
	        mOpened = false;
			drawPage();
			mEngine.hideProgress();
			mActivity.showToast(""Error while loading document"");
			if ( errorHandler!=null ) {
				log.e(""LoadDocumentTask: Calling error handler"");
				errorHandler.run();
			}
		}
	}

	private final static boolean dontStretchWhileDrawing = true;
	private final static boolean centerPageInsteadOfResizing = true;
	
	private void dimRect( Canvas canvas, Rect dst ) {
		int alpha = dimmingAlpha;
		if ( alpha!=255 ) {
			Paint p = new Paint();
			p.setColor((255-alpha)<<24);
			canvas.drawRect(dst, p);
		}
	}
	
	private void drawDimmedBitmap( Canvas canvas, Bitmap bmp, Rect src, Rect dst ) {
		canvas.drawBitmap(bmp, src, dst, null);
		dimRect( canvas, dst );
	}
	
	protected void doDraw(Canvas canvas)
	{
       	try {
    		log.d(""doDraw() called"");
    		if ( mInitialized && mCurrentPageInfo!=null ) {
        		log.d(""onDraw() -- drawing page image"");
        		
        		Rect dst = new Rect(0, 0, canvas.getWidth(), canvas.getHeight());
        		Rect src = new Rect(0, 0, mCurrentPageInfo.bitmap.getWidth(), mCurrentPageInfo.bitmap.getHeight());
        		if ( dontStretchWhileDrawing ) {
	        		if ( dst.right>src.right )
	        			dst.right = src.right;
	        		if ( dst.bottom>src.bottom )
	        			dst.bottom = src.bottom;
	        		if ( src.right>dst.right )
	        			src.right = dst.right;
	        		if ( src.bottom>dst.bottom )
	        			src.bottom = dst.bottom;
	        		if ( centerPageInsteadOfResizing ) {
		        		int ddx = (canvas.getWidth() - dst.width()) / 2;
		        		int ddy = (canvas.getHeight() - dst.height()) / 2;
		        		dst.left += ddx; 
		        		dst.right += ddx; 
		        		dst.top += ddy; 
		        		dst.bottom += ddy; 
	        		}
        		}
        		if ( dst.width()!=canvas.getWidth() || dst.height()!=canvas.getHeight() )
        			canvas.drawColor(Color.rgb(32, 32, 32));
        		drawDimmedBitmap(canvas, mCurrentPageInfo.bitmap, src, dst);
    		} else {
        		log.d(""onDraw() -- drawing empty screen"");
    			canvas.drawColor(Color.rgb(64, 64, 64));
    		}
    	} catch ( Exception e ) {
    		log.e(""exception while drawing"", e);
    	}
	}
	
	protected void draw()
	{
		drawCallback(new DrawCanvasCallback() {
			@Override
			public void drawTo(Canvas c) {
				doDraw(c);
			}
		}, null);
	}
	
    @Override 
    protected void onDraw(Canvas canvas) {
    	try {
    		log.d(""onDraw() called"");
    		draw();
//    		if ( mInitialized && mBitmap!=null ) {
//        		log.d(""onDraw() -- drawing page image"");
//        		Rect rc = new Rect(0, 0, mBitmap.getWidth(), mBitmap.getHeight());
//    			canvas.drawBitmap(mBitmap, rc, rc, null);
//    		} else {
//        		log.d(""onDraw() -- drawing empty screen"");
//    			canvas.drawColor(Color.rgb(192, 192, 192));
//    		}
    	} catch ( Exception e ) {
    		log.e(""exception while drawing"", e);
    	}
    }
    
    private int dimmingAlpha = 255; // no dimming
    public void setDimmingAlpha( int alpha ) {
    	if ( alpha>255 )
    		alpha = 255;
    	if ( alpha<32 )
    		alpha = 32;
    	if ( dimmingAlpha!=alpha ) {
    		dimmingAlpha = alpha;
    		mEngine.execute(new Task() {
				@Override
				public void work() throws Exception {
		    		draw();
				}
    			
    		});
    	}
    }

    private void restorePositionBackground( String pos )
    {
		BackgroundThread.ensureBackground();
    	if ( pos!=null ) {
			BackgroundThread.ensureBackground();
    		goToPositionInternal( pos );
    		preparePageImage(0);
    	}
    }
    
//    private void restorePosition()
//    {
//		BackgroundThread.ensureGUI();
//    	if ( mBookInfo!=null ) {
//    		if ( mBookInfo.getLastPosition()!=null ) {
//	    		final String pos = mBookInfo.getLastPosition().getStartPos();
//	    		post( new Task() {
//	    			public void work() {
//	    				BackgroundThread.ensureBackground();
//	    	    		goToPositionInternal( pos );
//	    	    		preparePageImage(0);
//	    			}
//	    		});
//	    		mActivity.getHistory().updateBookAccess(mBookInfo);
//    		}
//    		mActivity.getHistory().saveToDB();
//    	}
//    }
    
//    private void savePosition()
//    {
//		BackgroundThread.ensureBackground();
//    	if ( !mOpened )
//    		return;
//    	Bookmark bmk = getCurrentPageBookmarkInternal();
//    	if ( bmk!=null )
//    		log.d(""saving position, bmk="" + bmk.getStartPos());
//    	else
//    		log.d(""saving position: no current page bookmark obtained"");
//    	if ( bmk!=null && mBookInfo!=null ) {
//        	bmk.setTimeStamp(System.currentTimeMillis());
//    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
//    		mBookInfo.setLastPosition(bmk);
//    		mActivity.getHistory().updateRecentDir();
//    		mActivity.getHistory().saveToDB();
//    		saveSettings();
//    	}
//    }
    
    public Bookmark saveCurrentPositionBookmarkSync( boolean saveToDB ) {
        Bookmark bmk = mBackThread.callBackground(new Callable<Bookmark>() {
            @Override
            public Bookmark call() throws Exception {
                if ( !mOpened )
                    return null;
                return getCurrentPageBookmarkInternal();
            }
        });
        if ( bmk!=null ) {
            bmk.setTimeStamp(System.currentTimeMillis());
            bmk.setType(Bookmark.TYPE_LAST_POSITION);
            if ( mBookInfo!=null )
                mBookInfo.setLastPosition(bmk);
            if ( saveToDB ) {
                mActivity.getHistory().updateRecentDir();
                mActivity.getHistory().saveToDB();
                mActivity.getDB().flush();
            }
        }
        return bmk;
    }
    
    private class SavePositionTask extends Task {

    	Bookmark bmk;
    	
		@Override
		public void done() {
	    	if ( bmk!=null && mBookInfo!=null ) {
	        	bmk.setTimeStamp(System.currentTimeMillis());
	    		bmk.setType(Bookmark.TYPE_LAST_POSITION);
	    		mBookInfo.setLastPosition(bmk);
	    		mActivity.getHistory().updateRecentDir();
	    		mActivity.getHistory().saveToDB();
                log.i(""SavePositionTask.done()"");
	    	}
		}

		public void work() throws Exception {
			BackgroundThread.ensureBackground();
	    	if ( !mOpened )
	    		return;
	    	bmk = getCurrentPageBookmarkInternal();
	    	if ( bmk!=null )
	    		log.d(""saving position, bmk="" + bmk.getStartPos());
	    	else
	    		log.d(""saving position: no current page bookmark obtained"");
		}
    	
    }

    public void save()
    {
		BackgroundThread.ensureGUI();
    	post( new SavePositionTask() );
    }
    
    public void close()
    {
		BackgroundThread.ensureGUI();
    	log.i(""ReaderView.close() is called"");
    	if ( !mOpened )
    		return;
		//save();
    	post( new Task() {
    		public void work() {
    			BackgroundThread.ensureBackground();
    			if ( mOpened ) {
	    			mOpened = false;
					log.i(""ReaderView().close() : closing current document"");
					doCommandInternal(ReaderCommand.DCMD_CLOSE_BOOK.nativeId, 0);
    			}
    		}
    		public void done() {
    			BackgroundThread.ensureGUI();
    			if ( currentAnimation==null ) {
	    			if (  mCurrentPageInfo!=null ) {
	    				mCurrentPageInfo.recycle();
	    				mCurrentPageInfo = null;
	    			}
	    			if (  mNextPageInfo!=null ) {
	    				mNextPageInfo.recycle();
	    				mNextPageInfo = null;
	    			}
    			} else
        	    	invalidImages = true;
    			factory.compact();
    			mCurrentPageInfo = null;
    		}
    	});
    }

    public void destroy()
    {
    	log.i(""ReaderView.destroy() is called"");
		BackgroundThread.ensureGUI();
    	if ( mInitialized ) {
        	//close();
        	BackgroundThread.backgroundExecutor.execute( new Runnable() {
        		public void run() {
        			BackgroundThread.ensureBackground();
        	    	if ( mInitialized ) {
        	        	log.i(""ReaderView.destroyInternal() calling"");
        	    		destroyInternal();
        	    		mInitialized = false;
        	    		currentBackgroundTexture = Engine.NO_TEXTURE;
        	    	}
        		}
        	});
    		//engine.waitTasksCompletion();
    	}
    }
    
    @Override
	protected void onDetachedFromWindow() {
		// TODO Auto-generated method stub
		super.onDetachedFromWindow();
		log.d(""View.onDetachedFromWindow() is called"");
	}

    public final static String DEFAULT_CSS_IMPORT_PATTERN = ""@include \""default.css\""\\;"";
	private String getCSSForFormat( DocumentFormat fileFormat )
	{
		if ( fileFormat==null )
			fileFormat = DocumentFormat.FB2;
		File[] dataDirs = Engine.getDataDirectories(null, false, false);
		String defaultCss = mEngine.loadResourceUtf8(fileFormat.getCSSResourceId());
		for ( File dir : dataDirs ) {
			File file = new File( dir, fileFormat.getCssName() );
			if ( file.exists() ) {
				String css = mEngine.loadFileUtf8(file);
				if ( css!=null ) {
					css = css.replaceFirst(DEFAULT_CSS_IMPORT_PATTERN, ""\n"" + defaultCss + ""\n"");
					return css;
				}
			} 
		}
		return defaultCss;
	} 

	boolean enable_progress_callback = true;
    ReaderCallback readerCallback = new ReaderCallback() {
    
	    public boolean OnExportProgress(int percent) {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnExportProgress "" + percent);
			return true;
		}
		public void OnExternalLink(String url, String nodeXPath) {
			BackgroundThread.ensureBackground();
		}
		public void OnFormatEnd() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnFormatEnd"");
			//mEngine.hideProgress();
			drawPage();
		}
		public boolean OnFormatProgress(final int percent) {
			BackgroundThread.ensureBackground();
			if ( enable_progress_callback ) {
		    	log.d(""readerCallback.OnFormatProgress "" + percent);
		    	mEngine.showProgress( percent*4/10 + 5000, R.string.progress_formatting);
			}
//			executeSync( new Callable<Object>() {
//				public Object call() {
//					BackgroundThread.ensureGUI();
//			    	log.d(""readerCallback.OnFormatProgress "" + percent);
//			    	mEngine.showProgress( percent*4/10 + 5000, R.string.progress_formatting);
//			    	return null;
//				}
//			});
			return true;
		}
		public void OnFormatStart() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnFormatStart"");
		}
		public void OnLoadFileEnd() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileEnd"");
		}
		public void OnLoadFileError(String message) {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileError("" + message + "")"");
		}
		public void OnLoadFileFirstPagesReady() {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileFirstPagesReady"");
		}
		public String OnLoadFileFormatDetected(final DocumentFormat fileFormat) {
			BackgroundThread.ensureBackground();
			String res = executeSync( new Callable<String>() {
				public String call() {
					BackgroundThread.ensureGUI();
					log.i(""readerCallback.OnLoadFileFormatDetected "" + fileFormat);
					if ( fileFormat!=null ) {
						String s = getCSSForFormat(fileFormat);
						log.i(""setting .css for file format "" + fileFormat + "" from resource "" + (fileFormat!=null?fileFormat.getCssName():""[NONE]""));
						return s;
					}
			    	return null;
				}
			});
			int internalStyles = mBookInfo.getFileInfo().getFlag(FileInfo.DONT_USE_DOCUMENT_STYLES_FLAG)? 0 : 1; 
			log.d(""internalStyles: "" + internalStyles);
			doCommandInternal(ReaderCommand.DCMD_SET_INTERNAL_STYLES.nativeId, internalStyles);
			return res;
		}
		public boolean OnLoadFileProgress(final int percent) {
			BackgroundThread.ensureBackground();
			if ( enable_progress_callback ) {
		    	log.d(""readerCallback.OnLoadFileProgress "" + percent);
		    	mEngine.showProgress( percent*4/10 + 1000, R.string.progress_loading);
			}
//			executeSync( new Callable<Object>() {
//				public Object call() {
//					BackgroundThread.ensureGUI();
//			    	log.d(""readerCallback.OnLoadFileProgress "" + percent);
//			    	mEngine.showProgress( percent*4/10 + 1000, R.string.progress_loading);
//			    	return null;
//				}
//			});
			return true;
		}
		public void OnLoadFileStart(String filename) {
			BackgroundThread.ensureBackground();
	    	log.d(""readerCallback.OnLoadFileStart "" + filename);
		}
	    /// Override to handle external links
	    public void OnImageCacheClear() {
	    	//log.d(""readerCallback.OnImageCacheClear"");
	    	clearImageCache();
	    }
    };
    
    private boolean invalidImages = true;
    private void clearImageCache()
    {
    	BackgroundThread.instance().postBackground( new Runnable() {
    		public void run() {
    	    	invalidImages = true;
    		}
    	});
    }

    public void setStyleSheet( final String css )
    {
		BackgroundThread.ensureGUI();
        if ( css!=null && css.length()>0 ) {
        	post(new Task() {
        		public void work() {
        			setStylesheetInternal(css);
        		}
        	});
        }
    }
    
    public void goToPosition( int position )
    {
		BackgroundThread.ensureGUI();
		doEngineCommand(ReaderView.ReaderCommand.DCMD_GO_POS, position);
    }
    
    public void moveBy( final int delta )
    {
		BackgroundThread.ensureGUI();
		log.d(""moveBy("" + delta + "")"");
		post(new Task() {
			public void work() {
				BackgroundThread.ensureBackground();
				doCommandInternal(ReaderCommand.DCMD_SCROLL_BY.nativeId, delta);
			}
			public void done() {
				drawPage();
			}
		});
    }
    
    public void goToPage( int pageNumber )
    {
		BackgroundThread.ensureGUI();
		doEngineCommand(ReaderView.ReaderCommand.DCMD_GO_PAGE, pageNumber-1);
    }
    
    public void goToPercent( final int percent )
    {
		BackgroundThread.ensureGUI();
    	if ( percent>=0 && percent<=100 )
	    	post( new Task() {
	    		public void work() {
	    			PositionProperties pos = getPositionPropsInternal(null);
	    			if ( pos!=null && pos.pageCount>0) {
	    				int pageNumber = pos.pageCount * percent / 100; 
						doCommandFromBackgroundThread(ReaderView.ReaderCommand.DCMD_GO_PAGE, pageNumber);
	    			}
	    		}
	    	});
    }
    
    @Override
    public void finalize()
    {
    	log.w(""ReaderView.finalize() is called"");
    	//destroyInternal();
    }

	public ReaderView(CoolReader activity, Engine engine, BackgroundThread backThread, Properties props ) 
    {
        super(activity);
        SurfaceHolder holder = getHolder();
        holder.addCallback(this);
        
		BackgroundThread.ensureGUI();
        this.mActivity = activity;
        this.mEngine = engine;
        this.mBackThread = backThread;
        setFocusable(true);
        setFocusableInTouchMode(true);
        
        mBackThread.postBackground(new Runnable() {

			@Override
			public void run() {
				log.d(""ReaderView - in background thread: calling createInternal()"");
				createInternal();
				mInitialized = true;
			}
        	
        });

        post(new CreateViewTask( props ));

    }

}
",True,28,38,0,0,2,29,12,29,M0
37,org.coolreader.crengine.ReaderAction.java,"package org.coolreader.crengine;

import org.coolreader.R;
import org.coolreader.crengine.ReaderView.ReaderCommand;

public class ReaderAction {
	final public String id;
	final public int nameId;
	final public int    iconId;
	final public ReaderView.ReaderCommand cmd;
	final public int param;
	final public int menuItemId;
	private boolean canRepeat = false;
	private boolean mayAssignOnKey = true;
	private boolean mayAssignOnTap = true;
	private ReaderAction setCanRepeat() { canRepeat=true; return this; }
	//private ReaderAction dontAssignOnKey() { mayAssignOnKey=false; return this; }
	private ReaderAction dontAssignOnTap() { mayAssignOnTap=false; return this; }
	public boolean canRepeat() { return canRepeat; }
	public boolean mayAssignOnKey() { return mayAssignOnKey; }
	public boolean mayAssignOnTap() { return mayAssignOnTap; }

	public ReaderAction(String id, int nameId, ReaderCommand cmd, int param) {
		super();
		this.id = id;
		this.nameId = nameId;
		this.cmd = cmd;
		this.param = param;
		this.menuItemId = 0;
		this.iconId = 0;
	}

	public ReaderAction(String id, int nameId, ReaderCommand cmd, int param, int menuItemId) {
		super();
		this.id = id;
		this.nameId = nameId;
		this.cmd = cmd;
		this.param = param;
		this.menuItemId = menuItemId;
		this.iconId = 0;
	}

	public String toString() {
		return id;
	}
	
	public final static ReaderAction NONE = new ReaderAction(""NONE"", R.string.action_none, ReaderCommand.DCMD_NONE, 0 );
	public final static ReaderAction REPEAT = new ReaderAction(""REPEAT"", R.string.action_repeat, ReaderCommand.DCMD_REPEAT, 0 );
	public final static ReaderAction PAGE_DOWN = new ReaderAction(""PAGE_DOWN"", R.string.action_pagedown, ReaderCommand.DCMD_PAGEDOWN, 1 ).setCanRepeat();
	public final static ReaderAction PAGE_DOWN_10 = new ReaderAction(""PAGE_DOWN_10"", R.string.action_pagedown_10, ReaderCommand.DCMD_PAGEDOWN, 10 ).setCanRepeat();
	public final static ReaderAction PAGE_UP = new ReaderAction(""PAGE_UP"", R.string.action_pageup, ReaderCommand.DCMD_PAGEUP, 1 ).setCanRepeat();
	public final static ReaderAction PAGE_UP_10 = new ReaderAction(""PAGE_UP_10"", R.string.action_pageup_10, ReaderCommand.DCMD_PAGEUP, 10 ).setCanRepeat();
	public final static ReaderAction ZOOM_IN = new ReaderAction(""ZOOM_IN"", R.string.action_zoom_in, ReaderCommand.DCMD_ZOOM_IN, 2 );
	public final static ReaderAction ZOOM_OUT = new ReaderAction(""ZOOM_OUT"", R.string.action_zoom_out, ReaderCommand.DCMD_ZOOM_OUT, 2 );
	public final static ReaderAction DOCUMENT_STYLES = new ReaderAction(""DOCUMENT_STYLES"", R.string.action_toggle_document_styles, ReaderCommand.DCMD_TOGGLE_DOCUMENT_STYLES, 0, R.id.cr3_mi_toggle_document_styles );
	public final static ReaderAction BOOKMARKS = new ReaderAction(""BOOKMARKS"", R.string.action_bookmarks, ReaderCommand.DCMD_BOOKMARKS, 0, R.id.cr3_mi_bookmarks );
	public final static ReaderAction ABOUT = new ReaderAction(""ABOUT"", R.string.dlg_about, ReaderCommand.DCMD_ABOUT, 0, R.id.cr3_mi_about );
	public final static ReaderAction BOOK_INFO = new ReaderAction(""BOOK_INFO"", R.string.dlg_book_info, ReaderCommand.DCMD_BOOK_INFO, 0, R.id.cr3_mi_book_info );
	public final static ReaderAction TOC = new ReaderAction(""TOC"", R.string.action_toc, ReaderCommand.DCMD_TOC_DIALOG, 0, R.id.cr3_go_toc );
	public final static ReaderAction SEARCH = new ReaderAction(""SEARCH"", R.string.action_search, ReaderCommand.DCMD_SEARCH, 0, R.id.cr3_mi_search );
	public final static ReaderAction GO_PAGE = new ReaderAction(""GO_PAGE"", R.string.action_go_page, ReaderCommand.DCMD_GO_PAGE_DIALOG, 0, R.id.cr3_mi_go_page );
	public final static ReaderAction GO_PERCENT = new ReaderAction(""GO_PERCENT"", R.string.action_go_percent, ReaderCommand.DCMD_GO_PERCENT_DIALOG, 0, R.id.cr3_mi_go_percent );
	public final static ReaderAction FIRST_PAGE = new ReaderAction(""FIRST_PAGE"", R.string.action_go_first_page, ReaderCommand.DCMD_BEGIN, 0 );
	public final static ReaderAction LAST_PAGE = new ReaderAction(""LAST_PAGE"", R.string.action_go_last_page, ReaderCommand.DCMD_END, 0 );
	public final static ReaderAction OPTIONS = new ReaderAction(""OPTIONS"", R.string.action_options, ReaderCommand.DCMD_OPTIONS_DIALOG, 0, R.id.cr3_mi_options );
	public final static ReaderAction READER_MENU = new ReaderAction(""READER_MENU"", R.string.action_reader_menu, ReaderCommand.DCMD_READER_MENU, 0 );
	public final static ReaderAction TOGGLE_DAY_NIGHT = new ReaderAction(""TOGGLE_DAY_NIGHT"", R.string.action_toggle_day_night, ReaderCommand.DCMD_TOGGLE_DAY_NIGHT_MODE, 0, R.id.cr3_mi_toggle_day_night );
	public final static ReaderAction RECENT_BOOKS = new ReaderAction(""RECENT_BOOKS"", R.string.action_recent_books_list, ReaderCommand.DCMD_RECENT_BOOKS_LIST, R.id.book_recent_books );
	public final static ReaderAction FILE_BROWSER = new ReaderAction(""FILE_BROWSER"", R.string.action_file_browser, ReaderCommand.DCMD_FILE_BROWSER, 0, R.id.cr3_mi_open_file );
	public final static ReaderAction TOGGLE_TOUCH_SCREEN_LOCK = new ReaderAction(""TOGGLE_TOUCH_SCREEN_LOCK"", R.string.action_touch_screen_toggle_lock, ReaderCommand.DCMD_TOGGLE_TOUCH_SCREEN_LOCK, 0 ).dontAssignOnTap();
	public final static ReaderAction TOGGLE_ORIENTATION = new ReaderAction(""TOGGLE_ORIENTATION"", R.string.action_toggle_screen_orientation, ReaderCommand.DCMD_TOGGLE_ORIENTATION, 0 );
	public final static ReaderAction TOGGLE_FULLSCREEN = new ReaderAction(""TOGGLE_FULLSCREEN"", R.string.action_toggle_fullscreen, ReaderCommand.DCMD_TOGGLE_FULLSCREEN, 0 );
	public final static ReaderAction TOGGLE_SELECTION_MODE = new ReaderAction(""TOGGLE_SELECTION_MODE"", R.string.action_toggle_selection_mode, ReaderCommand.DCMD_TOGGLE_SELECTION_MODE, 0, R.id.cr3_mi_select_text );
	public final static ReaderAction HOME_SCREEN = new ReaderAction(""HOME_SCREEN"", R.string.action_exit_home_screen, ReaderCommand.DCMD_SHOW_HOME_SCREEN, 0 );
	public final static ReaderAction GO_BACK = new ReaderAction(""GO_BACK"", R.string.action_go_back, ReaderCommand.DCMD_LINK_BACK, 0, R.id.cr3_go_back );
	public final static ReaderAction GO_FORWARD = new ReaderAction(""GO_FORWARD"", R.string.action_go_forward, ReaderCommand.DCMD_LINK_FORWARD, 0, R.id.cr3_go_forward );
	public final static ReaderAction TTS_PLAY = new ReaderAction(""TTS_PLAY"", R.string.mi_tts_play, ReaderCommand.DCMD_TTS_PLAY, 0, R.id.cr3_mi_tts_play );
	public final static ReaderAction EXIT = new ReaderAction(""EXIT"", R.string.action_exit, ReaderCommand.DCMD_EXIT, 0, R.id.cr3_mi_exit );
	
	
	public final static ReaderAction[] AVAILABLE_ACTIONS = {
		NONE,
		PAGE_DOWN,
		PAGE_UP,
		PAGE_DOWN_10,
		PAGE_UP_10,
		FIRST_PAGE,
		LAST_PAGE,
		TOC,
		GO_PAGE,
		GO_PERCENT,
		BOOKMARKS,
		SEARCH,
		OPTIONS,
		EXIT,
		TOGGLE_DAY_NIGHT,
		RECENT_BOOKS,
		FILE_BROWSER,
		READER_MENU,
		TOGGLE_TOUCH_SCREEN_LOCK,
		TOGGLE_SELECTION_MODE,
		TOGGLE_ORIENTATION,
		TOGGLE_FULLSCREEN,
		GO_BACK,
		GO_FORWARD,
		HOME_SCREEN,
		ZOOM_IN,
		ZOOM_OUT,
		DOCUMENT_STYLES,
		ABOUT,
		BOOK_INFO,
		TTS_PLAY,
	};

	public boolean isNone() {
		return cmd == NONE.cmd;
	}
	
	public boolean isRepeat() {
		return cmd == REPEAT.cmd;
	}
	
	public static ReaderAction findById( String id ) {
		if ( id==null )
			return NONE;
		for ( ReaderAction a : AVAILABLE_ACTIONS ) {
			if ( id.equals(a.id) )
				return a;
		}
		if ( id.equals(REPEAT.id) )
			return REPEAT;
		return NONE;
	}
	public static ReaderAction findByMenuId( int id ) {
		if ( id==0 )
			return NONE;
		for ( ReaderAction a : AVAILABLE_ACTIONS ) {
			if ( id == a.menuItemId )
				return a;
		}
		return NONE;
	}
	public final static String NORMAL_PROP = ""."";
	public final static String LONG_PROP = "".long."";
	public final static String DOUBLECLICK_PROP = "".dbl."";
	
	public final static int NORMAL = 0;
	public final static int LONG = 1;
	public final static int DOUBLE = 2;
	public final static String[] TYPE_PROP_SUBPATH = new String[] {NORMAL_PROP, LONG_PROP, DOUBLECLICK_PROP};

	public static String getTypeString( int type ) {
		return TYPE_PROP_SUBPATH[type];
	}
	
	public static String getTapZoneProp( int tapZoneNumber, int type ) {
		return ReaderView.PROP_APP_TAP_ZONE_ACTIONS_TAP + getTypeString(type) + tapZoneNumber;
	}
	public static String getKeyProp( int keyCode, int type ) {
		return ReaderView.PROP_APP_KEY_ACTIONS_PRESS + getTypeString(type) + keyCode;
	}
	public static ReaderAction findForTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, NORMAL ) );
		return findById(id);
	}
	public static ReaderAction findForLongTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, LONG ) );
		return findById(id);
	}
	public static ReaderAction findForDoubleTap( int tapZoneNumber, Properties settings ) {
		String id = settings.getProperty( getTapZoneProp( tapZoneNumber, DOUBLE ) );
		return findById(id);
	}
	public static ReaderAction findForKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, NORMAL ) );
		return findById(id);
	}
	public static ReaderAction findForLongKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, LONG ) );
		return findById(id);
	}
	public static ReaderAction findForDoubleKey( int keyCode, Properties settings ) {
		String id = settings.getProperty( getKeyProp( keyCode, DOUBLE ) );
		return findById(id);
	}
}
",False,38,38,0,0,3,27,3,2,L1
