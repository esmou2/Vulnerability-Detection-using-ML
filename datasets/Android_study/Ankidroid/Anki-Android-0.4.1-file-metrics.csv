,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth
0,com.ichi2.anki.AnkiDroidApp.java,"/****************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
* Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import android.app.Application;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Resources;
import android.os.Environment;

import com.ichi2.async.Connection;
import com.tomgibara.android.veecheck.Veecheck;
import com.tomgibara.android.veecheck.util.PrefSettings;

/**
 * Application class.
 * This file mainly contains Veecheck stuff.
 */
public class AnkiDroidApp extends Application {

	/**
	 * Singleton instance of this class.
	 */
    private static AnkiDroidApp instance;
    
    /**
     * Base path to the available external storage
     */
    private String storageDirectory; 
    
    /**
     * Currently loaded Anki deck.
     */
    private Deck loadedDeck;
    
    /**
     * Resources
     */
    private Resources res;
    
    /**
     * On application creation.
     */
	@Override
	public void onCreate() {
		super.onCreate();
		instance = this;
		
		Connection.setContext(getApplicationContext());
		
		CustomExceptionHandler customExceptionHandler = CustomExceptionHandler.getInstance();
		customExceptionHandler.Init(instance.getApplicationContext());
		Thread.setDefaultUncaughtExceptionHandler(customExceptionHandler);
		
		DoImportantStuff();
	}
	
	private void DoImportantStuff() {
		storageDirectory = Environment.getExternalStorageDirectory().getAbsolutePath();
		res = getResources();
		SharedPreferences prefs = PrefSettings.getSharedPrefs(this);
		// Assign some default settings if necessary
		if (prefs.getString(PrefSettings.KEY_CHECK_URI, null) == null) {
			Editor editor = prefs.edit();
			// Test Update Notifications
			// Some ridiculously fast polling, just to demonstrate it working...
			/*editor.putBoolean(PrefSettings.KEY_ENABLED, true);
			editor.putLong(PrefSettings.KEY_PERIOD, 30 * 1000L);
			editor.putLong(PrefSettings.KEY_CHECK_INTERVAL, 60 * 1000L);
			editor.putString(PrefSettings.KEY_CHECK_URI, ""http://ankidroid.googlecode.com/files/test_notifications.xml"");*/
			editor.putString(PrefSettings.KEY_CHECK_URI, ""http://ankidroid.googlecode.com/files/last_release.xml"");
			// Put the base path to the external storage on preferences
			editor.putString(""deckPath"", storageDirectory);
			editor.commit();
		}

		// Reschedule the checks - we need to do this if the settings have changed (as above)
		// It may also necessary in the case where an application has been updated
		// Here for simplicity, we do it every time the application is launched
		Intent intent = new Intent(Veecheck.getRescheduleAction(this));
		sendBroadcast(intent);
	}

    public static AnkiDroidApp getInstance()
    {
        return instance;
    }

    public static String getStorageDirectory()
    {
    	return instance.storageDirectory;
    }
    
    public static Resources getAppResources()
    {
    	return instance.res;
    }
    
    public static Deck getDeck()
    {
        return instance.loadedDeck;
    }

    public static void setDeck( Deck deck )
    {
        instance.loadedDeck = deck;
    }

}
",True,42,30,1,4,4,10
1,com.ichi2.anki.CardModel.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
* Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.Comparator;
import java.util.HashMap;
import java.util.TreeMap;

import android.database.Cursor;

/**
 * Card model.
 * 
 * Card models are used to make question/answer pairs for the information you add to facts.
 * You can display any number of fields on the question side and answer side.
 * 
 * @see http://ichi2.net/anki/wiki/ModelProperties#Card_Templates
 */
public class CardModel implements Comparator<CardModel> {

	// TODO: Javadoc.
	// TODO: Methods for reading/writing from/to DB.

	// BEGIN SQL table columns
	long id; // Primary key
	int ordinal;
	long modelId; // Foreign key models.id
	String name;
	String description = """";
	int active = 1;
	// Formats: question/answer/last (not used)
	String qformat;
	String aformat;
	String lformat;
	// Question/answer editor format (not used yet)
	String qedformat;
	String aedformat;
	int questionInAnswer = 0;
	// Display
	String questionFontFamily = ""Arial"";
	int questionFontSize = 20;
	String questionFontColour = ""#000000"";
	int questionAlign = 0;
	String answerFontFamily = ""Arial"";
	int answerFontSize = 20;
	String answerFontColour = ""#000000"";
	int answerAlign = 0;
	// Not used
	String lastFontFamily = ""Arial"";
	int lastFontSize = 20;
	// Used as background colour
	String lastFontColour = ""#FFFFFF"";
	String editQuestionFontFamily = """";
	int editQuestionFontSize = 0;
	String editAnswerFontFamily = """";
	int editAnswerFontSize = 0;
	// Empty answer
	int allowEmptyAnswer = 1;
	String typeAnswer = """";
	// END SQL table entries

	/**
	 * Backward reference
	 */
	Model model;

	/**
	 * Constructor.
	 */
	public CardModel(String name, String qformat, String aformat, boolean active) {
		this.name = name;
		this.qformat = qformat;
		this.aformat = aformat;
		this.active = active ? 1 : 0;
		this.id = Utils.genID();
	}

	/**
	 * Constructor.
	 */
	public CardModel() {
		this("""", ""q"", ""a"", true);
	}

	/** SELECT string with only those fields, which are used in AnkiDroid */
	private final static String SELECT_STRING = ""SELECT id, ordinal, modelId, name, description, active, qformat, aformat"" //lformat left out
		//qedformat, aedformat left out
		+ "", questionInAnswer""
		+ "", questionFontFamily, questionFontSize, questionFontColour, questionAlign""
		+ "", answerFontFamily, answerFontSize, answerFontColour, answerAlign""
		+ "", lastFontColour"" //lastFontFamily, lastFontSize left out
		//rest left out
		+ "" FROM cardModels"";

	/**
	 * 
	 * @param modelId
	 * @param models will be changed by adding all found CardModels into it
	 * @return unordered CardModels which are related to a given Model and eventually active put into the parameter ""models""
	 */
	protected static final void fromDb(long modelId, TreeMap<Long, CardModel> models) {
		Cursor cursor = null;
		CardModel myCardModel = null;
		try {
			StringBuffer query = new StringBuffer(SELECT_STRING);
			query.append("" WHERE modelId = "");
			query.append(modelId);
			
			cursor = AnkiDb.database.rawQuery(query.toString(), null);

			if (cursor.moveToFirst()) {
				do {
					myCardModel = new CardModel();
					
					myCardModel.id = cursor.getLong(0);
					myCardModel.ordinal = cursor.getInt(1);
					myCardModel.modelId = cursor.getLong(2);
					myCardModel.name = cursor.getString(3);
					myCardModel.description = cursor.getString(4);
					myCardModel.active = cursor.getInt(5);
					myCardModel.qformat = cursor.getString(6);
					myCardModel.aformat = cursor.getString(7);
					myCardModel.questionInAnswer = cursor.getInt(8);
					myCardModel.questionFontFamily = cursor.getString(9);
					myCardModel.questionFontSize = cursor.getInt(10);
					myCardModel.questionFontColour = cursor.getString(11);
					myCardModel.questionAlign = cursor.getInt(12);
					myCardModel.answerFontFamily = cursor.getString(13);
					myCardModel.answerFontSize = cursor.getInt(14);
					myCardModel.answerFontColour = cursor.getString(15);
					myCardModel.answerAlign = cursor.getInt(16);
					myCardModel.lastFontColour = cursor.getString(17);
					models.put(myCardModel.id, myCardModel);
				} while (cursor.moveToNext());
			}
		} finally {
			if (cursor != null && !cursor.isClosed()) {
				cursor.close();
			}
		}
	}
	
	/**
	 * 
	 * @param cardModelId
	 * @return the modelId for a given cardModel or 0, if it cannot be found
	 */
	protected static final long modelIdFromDB(long cardModelId) {
		Cursor cursor = null;
		long modelId = -1;
		try {
			String query = ""SELECT modelId FROM cardModels WHERE id = "" + cardModelId;
			cursor = AnkiDb.database.rawQuery(query, null);
			cursor.moveToFirst();
			modelId = cursor.getLong(0);
		} finally {
			if (cursor != null && !cursor.isClosed()) {
				cursor.close();
			}
		}
		return modelId;
	}
	
	/**
	 * Return a copy of this object.
	 */
	public CardModel copy() {
		CardModel cardModel = new CardModel(
				this.name,
				this.qformat,
				this.aformat,
				(this.active == 1) ? true : false);
		cardModel.ordinal = this.ordinal;
		cardModel.modelId = this.modelId;
		cardModel.description = this.description;
		cardModel.lformat = this.lformat;
		cardModel.qedformat = this.qedformat;
		cardModel.aedformat = this.aedformat;
		cardModel.questionInAnswer = this.questionInAnswer;
		cardModel.questionFontFamily = this.questionFontFamily;
		cardModel.questionFontSize = this.questionFontSize;
		cardModel.questionFontColour = this.questionFontColour;
		cardModel.questionAlign = this.questionAlign;
		cardModel.answerFontFamily = this.answerFontFamily;
		cardModel.answerFontSize = this.answerFontSize;
		cardModel.answerFontColour = this.answerFontColour;
		cardModel.answerAlign = this.answerAlign;
		cardModel.lastFontFamily = this.lastFontFamily;
		cardModel.lastFontSize = this.lastFontSize;
		cardModel.lastFontColour = this.lastFontColour;
		cardModel.editQuestionFontFamily = this.editQuestionFontFamily;
		cardModel.editQuestionFontSize = this.editQuestionFontSize;
		cardModel.editAnswerFontFamily = this.editAnswerFontFamily;
		cardModel.editAnswerFontSize = this.editAnswerFontSize;
		cardModel.allowEmptyAnswer = this.allowEmptyAnswer;
		cardModel.typeAnswer = this.typeAnswer;
		cardModel.model = null;

		return cardModel;
	}

	public static HashMap<String, String> formatQA(Fact fact, CardModel cm) {
	    
	    //Not pretty, I know.
	    String question = cm.qformat;
	    String answer = cm.aformat;
	    
	    int replaceAt = question.indexOf(""%("");
	    while (replaceAt != -1)
	    {
	        question = replaceField(question, fact, replaceAt, true);
	        replaceAt = question.indexOf(""%("");
	    }
	    
	    replaceAt = answer.indexOf(""%("");
        while (replaceAt != -1)
        {
            answer = replaceField(answer, fact, replaceAt, true);
            replaceAt = answer.indexOf(""%("");
        }
        
		HashMap<String,String> returnMap = new HashMap<String, String>();
		returnMap.put(""question"", question);
		returnMap.put(""answer"", answer);
		
		return returnMap;
	}

    private static String replaceField(String replaceFrom, Fact fact, int replaceAt, boolean isQuestion) {
        int endIndex = replaceFrom.indexOf("")"", replaceAt);
        String fieldName =  replaceFrom.substring(replaceAt + 2, endIndex);
        char fieldType = replaceFrom.charAt(endIndex + 1);
        if (isQuestion)
        {
            String replace = ""%("" + fieldName + "")"" + fieldType;
            String with = ""<span class=\""fm"" + Long.toHexString(fact.getFieldModelId(fieldName)) + ""\"">"" +  fact.getFieldValue(fieldName) + ""</span>"";
            replaceFrom = replaceFrom.replace(replace, with);
        } 
        else
        {
            replaceFrom.replace(""%("" + fieldName + "")"" + fieldType, ""<span class=\""fma"" + Long.toHexString(fact.getFieldModelId(fieldName)) + ""\"">"" +  fact.getFieldValue(fieldName) + ""</span"");
        }
        return replaceFrom;
    }
    
	/**
	 * Implements Comparator by comparing the field ""ordinal"".
	 * @param object1
	 * @param object2
	 * @return 
	 */
	public int compare(CardModel object1, CardModel object2) {
		return object1.ordinal - object2.ordinal;
	}
}
",True,44,26,0,0,5,10
2,com.ichi2.anki.Preferences.java,"/****************************************************************************************
* Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.anki;

import android.content.Intent;
import android.os.Bundle;
import android.preference.PreferenceActivity;

import com.tomgibara.android.veecheck.Veecheck;
import com.tomgibara.android.veecheck.util.PrefSettings;

/**
 * Preferences dialog.
 */
public class Preferences extends PreferenceActivity
{

	@Override
	protected void onCreate(Bundle savedInstanceState)
	{
		super.onCreate(savedInstanceState);
		getPreferenceManager().setSharedPreferencesName(PrefSettings.SHARED_PREFS_NAME);
		addPreferencesFromResource(R.layout.preferences);
	}

    @Override
    protected void onPause() {
    	super.onPause();
    	// Reschedule the checking in case the user has changed anything
		sendBroadcast(new Intent(Veecheck.getRescheduleAction(this)));
    }

}
",False,21,4,0,0,2,2
3,com.ichi2.anki.Sound.java,"/****************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.media.AudioManager;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.util.Log;

/**
 * Class used to handle, load and play sound files on AnkiDroid.
 */
public class Sound {

	/**
	 * Tag for logging messages
	 */
	private static final String TAG = ""AnkiDroid"";
	/**
	 * Pattern used to identify the markers for sound files
	 */
	private static Pattern pattern = Pattern.compile(""\\[sound\\:([^\\[\\]]*)\\]"");
	/**
	 * ArrayList to store the current sound files
	 */
	private static ArrayList<MediaPlayer> sounds;
	
	/**
	 * Searches and loads the sound files specified on content (belonging to deck deckFilename) and cleans the markers used for it
	 * @param deckFilename Deck's filename whose sound files we are loading
	 * @param content HTML content of a card's side (question or answer)
	 * @return content Content without the markers of sounds, ready to be displayed
	 */
	public static String extractSounds(String deckFilename, String content)
	{
		Log.i(TAG, ""getSounds"");
		sounds = new ArrayList<MediaPlayer>();
		Matcher matcher = pattern.matcher(content);
		while(matcher.find())
		{
			String contentToReplace = matcher.group();
			content = content.replace(contentToReplace, """");
			String sound = matcher.group(1);
			Log.i(TAG, ""Sound "" + matcher.groupCount() + "": "" + sound);
			MediaPlayer soundPlayer = new MediaPlayer();
			String soundPath = deckFilename.replaceAll("".anki"", """") + "".media/"" + sound;
			Log.i(TAG, ""getSounds - soundPath = "" + soundPath);
			try 
			{
				soundPlayer.setDataSource(soundPath);
				soundPlayer.setVolume(AudioManager.STREAM_MUSIC, AudioManager.STREAM_MUSIC);
				soundPlayer.prepare();
				sounds.add(soundPlayer);

				if(sounds.size() > 1)
				{
					sounds.get(sounds.size() - 2).setOnCompletionListener(new OnCompletionListener() {

						public void onCompletion(MediaPlayer mp) {
							try
							{
								int i = sounds.indexOf(mp) + 1;
								sounds.get(i).start();
							} catch (Exception e)
							{
								Log.e(TAG, ""playSounds - Error reproducing a sound = "" + e.getMessage());
							}
						}
				
					});
				}
			} catch (Exception e)
			{
				Log.e(TAG, ""getSounds - Error setting data source for Media Player = "" + e.getMessage());
			}

		}
		return content;
	}
	
	/**
	 * Play the sounds that were previously extracted from a side of a card
	 */
	public static void playSounds()
	{
		if(!sounds.isEmpty())
		{
			sounds.get(0).start();
		}
	}
}
",True,2,20,6,5,0,0
4,com.ichi2.anki.ErrorReporter.java,"package com.ichi2.anki;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.TextView;

public class ErrorReporter extends Activity {
	public static String TAG = ""ErrorReporter"";

	private ArrayList<String> getErrorFiles() {
		ArrayList<String> files = new ArrayList<String>();
		String[] errors = fileList();

		for (String file : errors) {
			if (file.endsWith("".stacktrace""))
				files.add(file);
		}

		return files;
	}

	@Override
	public void onCreate(Bundle savedInstanceState) {
		Log.i(TAG, ""OnCreate"");

		super.onCreate(savedInstanceState);
		setContentView(R.layout.email_error);

		int noErrors = getErrorFiles().size();

		TextView tvErrorText = (TextView) findViewById(R.id.tvErrorText);
		Button btnOk = (Button) findViewById(R.id.btnSendEmail);
		Button btnCancel = (Button) findViewById(R.id.btnIgnoreError);

		btnOk.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				try {
					sendErrorReport();
				} catch (Exception e) {
					Log.e(TAG, e.toString());
				}

				deleteFiles();
				setResult(RESULT_OK);
				finish();
			}
		});

		btnCancel.setOnClickListener(new OnClickListener() {
			public void onClick(View v) {
				deleteFiles();
				setResult(RESULT_OK);
				finish();
			}
		});

		String errorText = String.format(getString(R.string.error_message), noErrors);
		tvErrorText.setText(errorText);
	}
	
	private void deleteFiles() {
		ArrayList<String> files = getErrorFiles();
		
		for(String file : files) {
			try {
				deleteFile(file);
			}
			catch(Exception e) {
				Log.e(TAG, String.format(""Could not delete file: %s"", file));
			}
		}
	}

	private void sendErrorReport() throws IOException {
		ArrayList<String> files = getErrorFiles();
		StringBuilder report = new StringBuilder();
		int count = 1;

		for (String filename : files) {
			try {
				report.append(String.format(""--> BEGIN REPORT %d <--\n"", count));
				
				FileInputStream fi = openFileInput(filename);

				if (fi == null)
					continue;

				int ch;

				while ((ch = fi.read()) != -1) {
					report.append((char) ch);
				}

				fi.close();
				
				report.append(String.format(""--> END REPORT %d <--"", count++));
			} catch (Exception ex) {
				Log.e(TAG, ex.toString());
			}
		}

		sendEmail(report.toString());
	}
	
	private void sendEmail(String body) {
		Intent sendIntent = new Intent(Intent.ACTION_SEND);
		String subject = String.format(""Bug Report on %s"", new Date());
		sendIntent.putExtra(Intent.EXTRA_EMAIL, new String[] {getString(R.string.error_email)});
		sendIntent.putExtra(Intent.EXTRA_TEXT, body);
		sendIntent.putExtra(Intent.EXTRA_SUBJECT, subject);
		sendIntent.setType(""message/rfc822"");
		
		startActivity( Intent.createChooser(sendIntent, ""Send Error Report"") );
	}
}
",True,41,1,0,0,0,0
5,com.ichi2.anki.FieldModel.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
* Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.Comparator;
import java.util.TreeMap;

import android.database.Cursor;

/**
 * Fields are the different pieces of data which make up a fact. 
 * @see http://ichi2.net/anki/wiki/ModelProperties#Fields
 */
public class FieldModel implements Comparator<FieldModel> {

	// BEGIN SQL table entries
	long id;
	int ordinal;
	long modelId;
	String name = """";
	String description = """";
	// Reused as RTL marker
	String features = """";
	int required = 1;
	int unique = 1;
	int numeric = 0;
	// Display
	String quizFontFamily;
	int quizFontSize;
	String quizFontColour;
	String editFontFamily;
	int editFontSize = 20;
	// END SQL table entries

	/**
	 * Backward reference
	 */
	Model model;

	public FieldModel(long id, int ordinal, long modelId, String name,
            String description) {
        this.id = id;
        this.ordinal = ordinal;
        this.modelId = modelId;
        this.name = name;
        this.description = description;
    }

    public FieldModel(String name, boolean required, boolean unique) {
		this.name = name;
		this.required = required ? 1 : 0;
		this.unique = unique ? 1 : 0;
		this.id = Utils.genID();
	}

	public FieldModel() {
		this("""", true, true);
	}
	
	/** SELECT string with only those fields, which are used in AnkiDroid */
	private final static String SELECT_STRING = ""SELECT id, ordinal, modelId, name, description""
			// features, required, unique, numeric left out
			+ "", quizFontSize, quizFontColour"" // quizFontFamily
			// editFontFamily, editFontSize left out
			+ "" FROM fieldModels"";

	/**
	 * 
	 * @param modelId
	 * @param models will be changed by adding all found FieldModels into it
	 * @return unordered FieldModels which are related to a given Model put into the parameter ""models""
	 */
	protected static final void fromDb(long modelId, TreeMap<Long, FieldModel> models) {
		Cursor cursor = null;
		FieldModel myFieldModel = null;
		try {
			StringBuffer query = new StringBuffer(SELECT_STRING);
			query.append("" WHERE modelId = "");
			query.append(modelId);

			cursor = AnkiDb.database.rawQuery(query.toString(), null);

			if (cursor.moveToFirst()) {
				do {
					myFieldModel = new FieldModel();

					myFieldModel.id = cursor.getLong(0);
					myFieldModel.ordinal = cursor.getInt(1);
					myFieldModel.modelId = cursor.getLong(2);
					myFieldModel.name = cursor.getString(3);
					myFieldModel.description = cursor.getString(4);
					myFieldModel.quizFontSize = cursor.getInt(5);
					myFieldModel.quizFontColour = cursor.getString(6);
					models.put(myFieldModel.id, myFieldModel);
				} while (cursor.moveToNext());
			}
		} finally {
			if (cursor != null && !cursor.isClosed()) {
				cursor.close();
			}
		}
	}

	public FieldModel copy() {
		FieldModel fieldModel = new FieldModel(
				this.name,
				(this.required == 1) ? true : false,
				(this.unique == 1) ? true : false);
		fieldModel.ordinal = this.ordinal;
		fieldModel.modelId = this.modelId;
		fieldModel.description = this.description;
		fieldModel.features = this.features;
		fieldModel.numeric = this.numeric;
		fieldModel.quizFontFamily = this.quizFontFamily;
		fieldModel.quizFontSize = this.quizFontSize;
		fieldModel.quizFontColour = this.quizFontColour;
		fieldModel.editFontFamily = this.editFontFamily;
		fieldModel.editFontSize = this.editFontSize;
		fieldModel.model = null;

		return fieldModel;
	}
	
	/**
	 * Implements Comparator by comparing the field ""ordinal"".
	 * @param object1
	 * @param object2
	 * @return 
	 */
	public int compare(FieldModel object1, FieldModel object2) {
		return object1.ordinal - object2.ordinal;
	}

}
",False,20,27,1,1,5,12
6,com.ichi2.anki.Model.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
* Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

import android.database.Cursor;

/**
 * Anki model.
 * A model describes the type of information you want to input, and the type of cards which should be generated.
 * See http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Models
 * There can be several models in a Deck.
 * A Model is related to a Deck via attribute deckId.
 * A CardModel is related to a Model via CardModel's modelId.
 * A FieldModel is related to a Model via FieldModel's modelId
 * A Card has a link to CardModel via Card's cardModelId
 * A Card has a link to a Fact via Card's factId
 * A Field has a link to a Fact via Field's factId
 * A Field has a link to a FieldModel via Field's fieldModelId
 * => In order to get the CardModel and all FieldModels for a given Card:
 *     % the CardModel can directly be retrieved from the DB using the Card's cardModelId
 *     % then from the retrieved CardModel we can get the modelId
 *     % using the modelId we can get all FieldModels from the DB
 *     % (alternatively in the CardModel the qformat and aformat fields could be parsed for relevant field names and 
 *     then this used to only get the necessary fields. But this adds a lot overhead vs. using a bit more memory)
 */
public class Model {
	
	/** Singleton */
	//private static Model currentModel;
	
	/**
	 * A Map of the currently loaded Models. The Models are loaded from the database as soon
	 * as they are needed for the first time. This is a compromise between RAM need, speed
	 * and the probability with which more than one Model is needed.
	 * If only one model is needed, then RAM consumption is basically the same as having a 
	 * static ""currentModel"" variable. If more than one Model is needed, then more RAM is
	 * needed, but on the other hand side Model and its related CardModel and FieldModel are not
	 * reloaded again and again.
	 * 
	 * This Map uses the Model.id field as key
	 */
	private static HashMap<Long,Model> models = new HashMap<Long, Model>();
	
	/**
	 * As above but mapping from CardModel to related Model (because when one has a Card, then 
	 * you need to jump from CardModel to Model.
	 */
	private static HashMap<Long,Model> cardModelToModelMap = new HashMap<Long, Model>();

	// BEGIN SQL table entries
	long id; // Primary key
	long deckId; // Foreign key
	double created = System.currentTimeMillis() / 1000.0;
	double modified = System.currentTimeMillis() / 1000.0;
	String tags = """";
	String name;
	String description = """";
	String features = """"; // obsolete
	double spacing = 0.1;
	double initialSpacing = 60;
	int source = 0;
	// BEGIN SQL table entries

	/** Map for convenience and speed which contains CardModels from current model */
	private TreeMap<Long, CardModel> cardModelsMap = new TreeMap<Long, CardModel>();
	
	/** Map for convenience and speed which contains FieldModels from current model */
	private TreeMap<Long, FieldModel> fieldModelsMap = new TreeMap<Long, FieldModel>();
	
	/** Map for convenience and speed which contains the CSS code related to a CardModel */
	private HashMap<Long, String> cssCardModelMap = new HashMap<Long, String>();
	
	/**
	 * The percentage chosen in preferences for font sizing at the time when the css for the CardModels
	 * related to this Model was calcualted in prepareCSSForCardModels.
	 */
	private transient int displayPercentage = 0;

	/** Text align constants */
	private final static String[] align_text = {""center"", ""left"", ""right""};

	private Model(String name) {
		this.name = name;
		this.id = Utils.genID();
	}

	private Model() {
		this("""");
	}

	public void setModified() {
		this.modified = System.currentTimeMillis() / 1000.0;
	}
	
	/**
	 * FIXME: this should be called whenever the deck is changed.
	 * Otherwise unnecessary space will be used.
	 */
	protected static final void reset() {
		models = new HashMap<Long, Model>();
		cardModelToModelMap = new HashMap<Long, Model>();
	}
	
	/**
	 * Returns a Model based on the submitted identifier.
	 * If a model id is submitted (isModelId = true), then the Model data and all related CardModel and FieldModel data are loaded,
	 * unless the id is the same as one of the currentModel.
	 * If a cardModel id is submitted, then the related Model data and all related CardModel and FieldModel data are loaded
	 * unless the cardModel id is already in the cardModel map.
	 * FIXME: nothing is done to treat db failure or non-existing identifiers
	 * @param identifier a cardModel id or a model id
	 * @param isModelId if true then the submitted identifier is a model id; otherwise the identifier is a cardModel id
	 * @return
	 */
	protected static Model getModel(long identifier, boolean isModelId) {
		if (false == isModelId) {
			//check whether the identifier is in the cardModelToModelMap
			if (false == cardModelToModelMap.containsKey(identifier)) {
				//get the modelId
				long myModelId = CardModel.modelIdFromDB(identifier);
				//get the model
				loadFromDBPlusRelatedModels(myModelId);
			}
			return cardModelToModelMap.get(identifier);
		}
		//else it is a modelId
		if (false == models.containsKey(identifier)) {
			//get the model
			loadFromDBPlusRelatedModels(identifier);
		}
		return models.get(identifier);
	}
	
	protected final CardModel getCardModel(long identifier) {
		return cardModelsMap.get(identifier);
	}
	
	/**
	 * Loads the Model from the database.
	 * then loads the related CardModels and FieldModels from the database.
	 * @param modelId
	 */
	private static final void loadFromDBPlusRelatedModels(long modelId) {
		Model currentModel = fromDb(modelId);
		
		//load related card models
		CardModel.fromDb(currentModel.id, currentModel.cardModelsMap);
		
		//load related field models
		FieldModel.fromDb(modelId, currentModel.fieldModelsMap);
		
		//make relations to maps
		models.put(currentModel.id, currentModel);
		CardModel myCardModel = null;
		for (Map.Entry<Long, CardModel> entry : currentModel.cardModelsMap.entrySet()) {
			myCardModel = entry.getValue();
			cardModelToModelMap.put(myCardModel.id, currentModel);
		}
	}
	
	/**
	 * Loads a model from the database based on the id
	 * FIXME: nothing is done in case of db error or no returned row
	 * @param id
	 * @return
	 */
	private static final Model fromDb(long id) {
		Cursor cursor = null;
		Model model = null;
		try {
			StringBuffer query = new StringBuffer();
			query.append(""SELECT id, deckId, created, modified, tags, name, description"");
			query.append("", features, spacing, initialSpacing, source"");
			query.append("" FROM models"");
			query.append("" WHERE id = "").append(id);
			cursor = AnkiDb.database.rawQuery(query.toString(), null);

			cursor.moveToFirst();
			model = new Model();
			
			model.id = cursor.getLong(0); // Primary key
			model.deckId = cursor.getLong(1); // Foreign key
			model.created = cursor.getDouble(2);
			model.modified = cursor.getDouble(3);
			model.tags = cursor.getString(4);
			model.name = cursor.getString(5);
			model.description = cursor.getString(6);
			model.features = cursor.getString(7);
			model.spacing = cursor.getDouble(8);
			model.initialSpacing = cursor.getDouble(9);
			model.source = cursor.getInt(10);
		} finally {
			if (cursor != null)
				cursor.close();
		}
		return model;
	}
	
	/**
	 * Prepares the CSS for all CardModels in this Model
	 */
	private final void prepareCSSForCardModels() {
		CardModel myCardModel = null;
		String cssString = null;
		for (Map.Entry<Long, CardModel> entry : cardModelsMap.entrySet()) {
			myCardModel = entry.getValue();
			cssString = createCSSForFontColorSize(myCardModel.id, displayPercentage);
			this.cssCardModelMap.put(myCardModel.id, cssString);
		}
	}
	
	/**
	 * Returns a cached CSS for the font color and font size of a given CardModel taking into account the included fields
	 * @param myCardModelId
	 * @param percentage the preference factor to use for calculating the display font size from the cardmodel and fontmodel font size
	 * @return the html contents surrounded by a css style which contains class styles for answer/question and fields
	 */
	protected final String getCSSForFontColorSize(long myCardModelId, int percentage) {
		//tjek whether the percentage is this the same as last time
		if (this.displayPercentage != percentage) {
			this.displayPercentage = percentage;
			prepareCSSForCardModels();
		}
		return this.cssCardModelMap.get(myCardModelId);
	}
	
	/**
	 * @param myCardModelId
	 * @param percentage the factor to apply to the font size in card model to the display size (in %)
	 * @return the html contents surrounded by a css style which contains class styles for answer/question and fields
	 */
	private final String createCSSForFontColorSize(long myCardModelId, int percentage) {
		StringBuffer sb = new StringBuffer();
		sb.append(""<!-- "").append(percentage).append("" % display font size-->"");
		sb.append(""<style type=\""text/css\"">\n"");
		CardModel myCardModel = cardModelsMap.get(myCardModelId);
		
		//body background
		if (null != myCardModel.lastFontColour && 0 < myCardModel.lastFontColour.trim().length()) {
			sb.append(""body {background-color:"").append(myCardModel.lastFontColour).append("";}\n"");
		}
		//question
		sb.append(""."").append(AnkiDroid.QUESTION_CLASS).append("" {\n"");
		sb.append(calculateDisplay(percentage, myCardModel.questionFontFamily, myCardModel.questionFontSize, myCardModel.questionFontColour, myCardModel.questionAlign, false));
		sb.append(""}\n"");
		//answer
		sb.append(""."").append(AnkiDroid.ANSWER_CLASS).append("" {\n"");
		sb.append(calculateDisplay(percentage, myCardModel.answerFontFamily, myCardModel.answerFontSize, myCardModel.answerFontColour, myCardModel.answerAlign, false));
		sb.append(""}\n"");
		//css for fields. Gets css for all fields no matter whether they actually are used in a given card model
		FieldModel myFieldModel = null;
		String hexId = null; //a FieldModel id in unsigned hexa code for the class attribute
		for (Map.Entry<Long, FieldModel> entry : fieldModelsMap.entrySet()) {
			myFieldModel = entry.getValue();
			hexId = ""fm"" + Long.toHexString(myFieldModel.id);
			sb.append(""."").append(hexId).append("" {\n"");
			sb.append(calculateDisplay(percentage, myFieldModel.quizFontFamily, myFieldModel.quizFontSize, myFieldModel.quizFontColour, 0, true));
			sb.append(""}\n"");
		}
		
		//finish
		sb.append(""</style>"");
		return sb.toString();
	}
	
	private final static String calculateDisplay(int percentage, String fontFamily, int fontSize, String fontColour, int align, boolean isField) {
		StringBuffer sb = new StringBuffer();
		if (null != fontFamily && 0 < fontFamily.trim().length()) {
			sb.append(""font-family:\"""").append(fontFamily).append(""\"";\n"");
		}
		if (null != fontColour && 0 < fontColour.trim().length()) {
			sb.append(""color:"").append(fontColour).append("";\n"");
		}
		if (0 < fontSize) {
			sb.append(""font-size:"");
			sb.append((percentage * fontSize)/100);
			sb.append(""px;\n"");
		}
		
        if (!isField) {
            sb.append(""text-align:"");
            sb.append(align_text[align]);
            sb.append("";\n"");
            sb.append(""padding-left:5px;\n"");
            sb.append(""padding-right:5px;\n"");
        }

		return sb.toString();
	}

}
",False,25,26,0,0,4,12
7,com.ichi2.anki.Utils.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.List;
import java.util.Random;
import java.util.TreeSet;

import org.json.JSONArray;
import org.json.JSONException;

/**
 * TODO comments
 */
public class Utils {
	
	private static TreeSet<Integer> idTree;
	private static long idTime;

	public static long genID() {
		long time = System.currentTimeMillis();
		long id;
		int rand;
		Random random = new Random();

		if (idTree == null) {
			idTree = new TreeSet<Integer>();
			idTime = time;
		}
		else if (idTime != time) {
			idTime = time;
			idTree.clear();
		}

		while (true) {
			rand = random.nextInt(2^23);
			if (!idTree.contains(new Integer(rand))) {
				idTree.add(new Integer(rand));
				break;
			}
		}
		id = rand << 41 | time;
		return id;
	}
	
	/**
	 * Returns a SQL string from an array of integers.
	 *
	 * @param ids
	 *            The array of integers to include in the list.
	 * @return An SQL compatible string in the format (ids[0],ids[1],..).
	 */
	public static String ids2str(long[] ids)
	{
		String str = ""("";
		int len = ids.length;
		for (int i = 0; i < len; i++)
		{
			if (i == (len - 1))
				str += ids[i];
			else
				str += ids[i] + "","";
		}
		str += "")"";
		return str;
	}

	/**
	 * Returns a SQL string from an array of integers.
	 *
	 * @param ids
	 *            The array of integers to include in the list.
	 * @return An SQL compatible string in the format (ids[0],ids[1],..).
	 */
	public static String ids2str(JSONArray ids)
	{
		String str = ""("";
		int len = ids.length();
		for (int i = 0; i < len; i++)
		{
			try {
				if (i == (len - 1))
				{
					str += ids.get(i);
				}	
				else
				{
					str += ids.get(i) + "","";
				}
			} catch (JSONException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		str += "")"";
		return str;
	}
	
	public static JSONArray listToJSONArray(List<Object> list)
	{
		JSONArray jsonArray = new JSONArray();
		
		int len = list.size();
		for(int i = 0; i < len; i++)
		{
			jsonArray.put(list.get(i));
		}
		
		return jsonArray;
	}
	
	/**
	 * Returns a SQL string from an array of integers.
	 *
	 * @param ids
	 *            The array of integers to include in the list.
	 * @return An SQL compatible string in the format (ids[0],ids[1],..).
	 */
	public static String ids2str(List<String> ids)
	{
		String str = ""("";
		int len = ids.size();
		for (int i = 0; i < len; i++)
		{
			if (i == (len - 1))
			{
				str += ids.get(i);
			}	
			else
			{
				str += ids.get(i) + "","";
			}
		}
		str += "")"";
		return str;
	}
}
",True,7,20,5,6,0,0
8,com.ichi2.anki.AnkiDroidContentProvider.java,"/****************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.io.File;
import java.io.FileNotFoundException;

import android.content.ContentProvider;
import android.content.ContentValues;
import android.database.Cursor;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.util.Log;

/**
 * Content Provider for AnkiDroid
 */
public class AnkiDroidContentProvider extends ContentProvider {
	
	/**
	 * Tag for logging messages
	 */
	private static final String TAG = ""AnkiDroid"";


	/**
	 * Opens the file located on uri, with permissions mode and retrieves a ParcelFileDescriptor representing it
	 * @param uri URI where the file is located
	 * @param mode Permissions which the file will be opened with
	 * @return ParcelFileDescriptor of the file located on uri
	 */
	@Override
	public ParcelFileDescriptor openFile( Uri uri, String mode ){
		Log.i(TAG, ""AnkiDroidContentProvider - openFile = "" + uri.getEncodedPath() + "", "" + uri.getPath());
		
		File file = null;
		ParcelFileDescriptor parcel = null;

		try {
			file = new File(uri.getPath());
			parcel = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);
			Log.i(TAG, ""AnkiDroidContentProvider - File opened succesfully"");
		} catch (FileNotFoundException e)
		{
			Log.e( TAG, ""Error finding: "" + uri.getPath() + ""\n"" + e.toString() );
		} catch (Exception e)
		{
			Log.e(TAG, ""Could not open the file = "" + uri.getPath() + "", "" + e.getMessage());
		}
	
		return parcel;
	}
   

	@Override
	public boolean onCreate() {
		return true;
	}

	@Override
	public int delete(Uri uri, String s, String[] as) {
		throw new UnsupportedOperationException(""Not supported by this provider"");
	}

	@Override
	public String getType(Uri uri) {
		throw new UnsupportedOperationException(""Not supported by this provider"");
	}

	@Override
	public Uri insert(Uri uri, ContentValues contentvalues) {
		throw new UnsupportedOperationException(""Not supported by this provider"");
	}

	@Override
	public Cursor query(Uri uri, String[] as, String s, String[] as1, String s1) {
		throw new UnsupportedOperationException(""Not supported by this provider"");
	}

	@Override
	public int update(Uri uri, ContentValues contentvalues, String s, String[] as) {
		throw new UnsupportedOperationException(""Not supported by this provider"");
	}

}
",True,37,1,0,0,0,0
9,com.ichi2.anki.AnkiDb.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
* Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
* Copyright (c) 2009 Andrew <andrewdubya@gmail.com>                                    *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.anki;

import java.util.ArrayList;

import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

/**
 * Database layer for AnkiDroid.
 * Can read the native Anki format through Android's SQLite driver.
 */
public class AnkiDb
{

	/**
	 * The deck, which is actually an SQLite database.
	 */
	static public SQLiteDatabase database;

	/**
	 * Tag for logging messages
	 */
	private static final String TAG = ""AnkiDroid"";

	/**
	 * Open a database connection to an "".anki"" SQLite file.
	 */
	static public void openDatabase(String ankiFilename) throws SQLException
	{

		if (database != null)
		{
			database.close();
		}

		database = SQLiteDatabase.openDatabase(ankiFilename, null, SQLiteDatabase.OPEN_READWRITE
		        | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
		Log.i(TAG, ""AnkiDb - openDatabase, database "" + ankiFilename + "" opened = "" + database.isOpen());
	}

	/**
	 * Closes a previously opened database connection.
	 */
	static public void closeDatabase()
	{
		if (database != null)
		{
			database.close();
			Log.i(TAG, ""AnkiDb - closeDatabase, database "" + database.getPath() + "" closed = "" + !database.isOpen());
			database = null;
		}
	}

	/**
	 * Convenience method for querying the database for a single integer result.
	 *
	 * @param query
	 *            The raw SQL query to use.
	 * @return The integer result of the query.
	 */
	static public long queryScalar(String query) throws SQLException
	{
		Cursor cursor = null;
		long scalar;
		try {
			cursor = AnkiDb.database.rawQuery(query, null);
			if (!cursor.moveToFirst())
				throw new SQLException(""No result for query: "" + query);
	
			scalar = cursor.getLong(0);
		} finally {
			if (cursor != null) cursor.close();
		}

		return scalar;
	}
	
	/**
	 * Convenience method for querying the database for an entire column. The column
	 * will be returned as an ArrayList of the specified class.
	 * 
	 * See Deck.initUndo() for a usage example.
	 * 
	 * @param type The class of the column's data type. Example: int.class, String.class.
	 * @param query The SQL query statement.
	 * @param column The column id in the result set to return.
	 * @return An ArrayList with the contents of the specified column.
	 */
	static public <T> ArrayList<T> queryColumn(Class<T> type, String query, int column) {
		ArrayList<T> results = new ArrayList<T>();
		Cursor cursor = null;
		
		try {
			cursor = AnkiDb.database.rawQuery(query, null);
			cursor.moveToFirst();
			String methodName = getCursorMethodName(type.getSimpleName());
			do {
				// The magical line. Almost as illegible as python code ;)
				results.add(type.cast(Cursor.class.getMethod(methodName, int.class).invoke(cursor, column)));
			} while (cursor.moveToNext());
		} catch (Exception e) {
			Log.e(TAG, ""queryColumn: Got Exception: "" + e.getMessage());
			return null;
		} finally {
			if (cursor != null) cursor.close();
		}
		
		return results;
	}
	
	/**
	 * Mapping of Java type names to the corresponding Cursor.get method.
	 * 
	 * @param typeName The simple name of the type's class. Example: String.class.getSimpleName().
	 * @return The name of the Cursor method to be called.
	 */
	static private String getCursorMethodName(String typeName) {
		if (typeName.equals(""String""))
			return ""getString"";
		else if (typeName.equals(""Long""))
			return ""getLong"";
		else if (typeName.equals(""Integer""))
			return ""getInt"";
		else if (typeName.equals(""Float""))
			return ""getFloat"";
		else if (typeName.equals(""Double""))
			return ""getDouble"";
		else
			return null;
	}
}",True,5,20,4,9,0,0
10,com.ichi2.anki.Fact.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeSet;

import android.content.ContentValues;
import android.database.Cursor;
import android.util.Log;

/**
 * Anki fact.
 * A fact is a single piece of information, made up of a number of fields.
 * See http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Facts
 */
public class Fact {

    // TODO: Javadoc.
    // TODO: Finish porting from facts.py.
    // TODO: Methods to read/write from/to DB.

    long id;
    long modelId;
    double created;
    double modified;
    String tags;
    double spaceUntil;

    Model model;
    TreeSet<Field> fields;

    /*
    public Fact(Model model) {
        this.model = model;
        this.id = Utils.genID();
        if (model != null) {
            Iterator<FieldModel> iter = model.fieldModels.iterator();
            while (iter.hasNext()) {
                this.fields.add(new Field(iter.next()));
            }
        }
    }
    */

    // Generate fact object from its ID
    public Fact(long id)
    {
        fromDb(id);
        //TODO: load fields associated with this fact.

    }



    /**
     * @return the fields
     */
    public TreeSet<Field> getFields() {
        return fields;
    }

    /**
     * @param fields the fields to set
     */
    public void setFields(TreeSet<Field> fields) {
        this.fields = fields;
    }

    public boolean fromDb(long id)
    {
        this.id = id;
        Cursor cursor = null;
        
        try {
	        cursor = AnkiDb.database.rawQuery(
	                ""SELECT id, modelId, created, modified, tags, spaceUntil "" +
	                ""FROM facts "" +
	                ""WHERE id = "" +
	                id,
	                null);
	        if (!cursor.moveToFirst()) {
	            Log.w(""anki"", ""Fact.java (constructor): No result from query."");
	            return false;
	        }
	
	        this.id = cursor.getLong(0);
	        this.modelId = cursor.getLong(1);
	        this.created = cursor.getDouble(2);
	        this.modified = cursor.getDouble(3);
	        this.tags = cursor.getString(4);
        } finally {
        	if (cursor != null) cursor.close();
        }

        Cursor fieldsCursor = null;
        try {
	        fieldsCursor = AnkiDb.database.rawQuery(
	                ""SELECT id, factId, fieldModelId, value "" +
	                ""FROM fields "" +
	                ""WHERE factId = "" +
	                id, 
	                null);
	
	        fields = new TreeSet<Field>(new FieldOrdinalComparator());
	        while (fieldsCursor.moveToNext())
	        {
	            long fieldId = fieldsCursor.getLong(0);
	            long fieldModelId = fieldsCursor.getLong(2);
	            String fieldValue = fieldsCursor.getString(3);
	
	            Cursor fieldModelCursor = null;
	            FieldModel currentFieldModel = null;
	            try {
		            // Get the field model for this field
		            fieldModelCursor = AnkiDb.database.rawQuery(
		                    ""SELECT id, ordinal, modelId, name, description "" +
		                    ""FROM fieldModels "" +
		                    ""WHERE id = "" +
		                    fieldModelId,
		                    null);
		
		            fieldModelCursor.moveToFirst();
		            currentFieldModel = new FieldModel(fieldModelCursor.getLong(0), 
		                    fieldModelCursor.getInt(1), fieldModelCursor.getLong(2),
		                    fieldModelCursor.getString(3), fieldModelCursor.getString(4));
	            } finally {
	            	if (fieldModelCursor != null) fieldModelCursor.close();
	            }
	            fields.add(new Field(fieldId, id, currentFieldModel, fieldValue));
	        }
        } finally {
        	if (fieldsCursor != null) fieldsCursor.close();
        }
        // Read Fields
        return true;
    }

    public String getFieldValue(String fieldModelName) {
        Iterator<Field> iter = fields.iterator();
        while (iter.hasNext()) {
            Field f = iter.next();
            if (f.fieldModel.name.equals(fieldModelName)) {
                return f.value;
            }
        }
        return null;
    }
    
    public long getFieldModelId(String fieldModelName) {
        Iterator<Field> iter = fields.iterator();
        while (iter.hasNext()) {
            Field f = iter.next();
            if (f.fieldModel.name.equals(fieldModelName)) {
                return f.fieldModel.id;
            }
        }
        return 0;
    }

    public void toDb()
    {
        double now = System.currentTimeMillis() / 1000.0;

        // update facts table
        ContentValues updateValues = new ContentValues();
        updateValues.put(""modified"", now);


        //update fields table
        Iterator<Field> iter = fields.iterator();
        while (iter.hasNext()) {
            Field f = iter.next();

            updateValues = new ContentValues();
            updateValues.put(""value"", f.value);
            AnkiDb.database.update(""fields"", updateValues, ""id = ?"", new String[] {"""" + f.id});
        }
    }

    public LinkedList<Card> getUpdatedRelatedCards() {
        // TODO return instances of each card that is related to this fact
        LinkedList<Card> returnList = new LinkedList<Card>();


        Cursor cardsCursor = AnkiDb.database.rawQuery(
                ""SELECT id, factId "" +
                ""FROM cards "" +
                ""WHERE factId = "" +
                id, 
                null);

        while (cardsCursor.moveToNext())
        {
            Card newCard = new Card();
            newCard.fromDB(cardsCursor.getLong(0));
            HashMap<String,String> newQA = CardModel.formatQA(this, newCard.getCardModel());
            newCard.question = newQA.get(""question"");
            newCard.answer = newQA.get(""answer"");
            
            returnList.add(newCard);
        }
        return returnList;
    }

    public static final class FieldOrdinalComparator implements Comparator<Field> {
        public int compare(Field object1, Field object2) {
            return object1.ordinal - object2.ordinal;
        }
    }

    public class Field {

        // TODO: Javadoc.
        // Methods for reading/writing from/to DB.

        // BEGIN SQL table entries
        long id; // Primary key
        long factId; // Foreign key facts.id
        long fieldModelId; // Foreign key fieldModel.id
        int ordinal;
        String value;
        // END SQL table entries

        // BEGIN JOINed entries
        FieldModel fieldModel;
        // END JOINed entries

        // Backward reference
        Fact fact;

        // for creating instances of existing fields
        public Field(long id, long factId, FieldModel fieldModel, String value)
        {
            this.id = id;
            this.factId = factId;
            this.fieldModel = fieldModel;
            this.value = value;
            this.fieldModel = fieldModel;
            this.ordinal = fieldModel.ordinal;
        }


        // For creating new fields
        public Field(FieldModel fieldModel) {
            if (fieldModel != null) {
                this.fieldModel = fieldModel;
                this.ordinal = fieldModel.ordinal;
            }
            this.value = """";
            this.id = Utils.genID();
        }
    }




}
",False,33,27,1,1,5,10
11,com.ichi2.anki.About.java,"/***************************************************************************************
* Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.anki;

import android.app.Activity;
import android.database.SQLException;
import android.os.Bundle;
import android.webkit.WebView;

/**
 * Shows an about box, which is a small HTML page.
 */
public class About extends Activity
{

	@Override
    public void onCreate(Bundle savedInstanceState) throws SQLException
	{
		super.onCreate(savedInstanceState);
		setContentView(R.layout.about);
		WebView webview = (WebView) findViewById(R.id.about);
		webview.loadDataWithBaseURL("""", getResources().getString(R.string.about_content), ""text/html"", ""utf-8"", null);
	}
}",False,12,1,0,0,0,0
12,com.ichi2.anki.DeckTask.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.Iterator;
import java.util.LinkedList;

import android.database.CursorIndexOutOfBoundsException;
import android.database.SQLException;
import android.os.AsyncTask;
import android.util.Log;

/**
 * Loading in the background, so that AnkiDroid does not look like frozen.
 */
public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, DeckTask.TaskData>
{

	/**
	 * Tag for logging messages
	 */
	private static final String TAG = ""AnkiDroid"";

	public static final int TASK_TYPE_LOAD_DECK = 0;
	public static final int TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS = 1;
	public static final int TASK_TYPE_ANSWER_CARD = 2;
	public static final int TASK_TYPE_SUSPEND_CARD = 3;
    public static final int TASK_TYPE_UPDATE_FACT = 4;

	private static DeckTask instance;
	private static DeckTask oldInstance;

	int type;
	TaskListener listener;

	public static DeckTask launchDeckTask(int type, TaskListener listener, TaskData... params)
	{
		oldInstance = instance;
		
		instance = new DeckTask();
		instance.listener = listener;
		instance.type = type;

		return (DeckTask) instance.execute(params);
	}
	
	/**
	 * Block the current thread until the currently running DeckTask instance 
	 * (if any) has finished.
	 */
	public static void waitToFinish()
	{
		try
		{
			if ((instance != null) && (instance.getStatus() != AsyncTask.Status.FINISHED))
				instance.get();
		} catch (Exception e)
		{
			return;
		}
	}

	@Override
	protected TaskData doInBackground(TaskData... params)
	{
		// Wait for previous thread (if any) to finish before continuing
		try
		{
			if ((oldInstance != null) && (oldInstance.getStatus() != AsyncTask.Status.FINISHED))
				oldInstance.get();
		} catch (Exception e)
		{
			Log.e(TAG, ""doInBackground - Got exception while waiting for thread to finish: "" + e.getMessage());
		}
		
		switch (type)
		{
			case TASK_TYPE_LOAD_DECK:
				return doInBackgroundLoadDeck(params);
			
			case TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS:
				TaskData taskData = doInBackgroundLoadDeck(params);
				if(taskData.integer == AnkiDroid.DECK_LOADED)
				{
					taskData.deck.updateAllCards();
					taskData.card = taskData.deck.getCurrentCard();
				}
				return taskData;
				
			case TASK_TYPE_ANSWER_CARD:
				return doInBackgroundAnswerCard(params);
		
			case TASK_TYPE_SUSPEND_CARD:
				return doInBackgroundSuspendCard(params);
        
			case TASK_TYPE_UPDATE_FACT:
				return doInBackgroundUpdateFact(params);
		
			default:
				return null;
		}
	}

	@Override
	protected void onPreExecute()
	{
		listener.onPreExecute();
	}

	@Override
	protected void onProgressUpdate(TaskData... values)
	{
		listener.onProgressUpdate(values);
	}

	@Override
	protected void onPostExecute(TaskData result)
	{
		listener.onPostExecute(result);
	}

    private TaskData doInBackgroundUpdateFact(TaskData[] params) {

    	// Save the fact
        Deck deck = params[0].getDeck();
        Card editCard = params[0].getCard();
        Fact editFact = editCard.fact;
        editFact.toDb();
        LinkedList<Card> saveCards = editFact.getUpdatedRelatedCards();
        
        Iterator<Card> iter = saveCards.iterator();
        while (iter.hasNext())
        {
            Card modifyCard = iter.next();
            deck.updateCard(modifyCard);
        }
        // Find all cards based on this fact and update them with the updateCard method.

        publishProgress(new TaskData(deck.getCurrentCard()));
      
        return null;
    }

    

	private TaskData doInBackgroundAnswerCard(TaskData... params)
	{
		long start, start2;
		Deck deck = params[0].getDeck();
		Card oldCard = params[0].getCard();
		int ease = params[0].getInt();
		Card newCard;
		
		start2 = System.currentTimeMillis();
		
		AnkiDb.database.beginTransaction();
		try 
		{
			if (oldCard != null)
			{
				start = System.currentTimeMillis();
				deck.answerCard(oldCard, ease);
				Log.v(TAG, ""doInBackgroundAnswerCard - Answered card in "" + (System.currentTimeMillis() - start) + "" ms."");
			}
	
			start = System.currentTimeMillis();
			newCard = deck.getCard();
			Log.v(TAG, ""doInBackgroundAnswerCard - Loaded new card in "" + (System.currentTimeMillis() - start) + "" ms."");
			publishProgress(new TaskData(newCard));
			
			AnkiDb.database.setTransactionSuccessful();
		} finally 
		{
			AnkiDb.database.endTransaction();
		}
		
		Log.w(TAG, ""doInBackgroundAnswerCard - DB operations in "" + (System.currentTimeMillis() - start2) + "" ms."");

		return null;
	}

	private TaskData doInBackgroundLoadDeck(TaskData... params)
	{
		String deckFilename = params[0].getString();
		Log.i(TAG, ""doInBackgroundLoadDeck - deckFilename = "" + deckFilename);

		Log.i(TAG, ""loadDeck - SD card mounted and existent file -> Loading deck..."");
		try
		{
			// Open the right deck.
			Deck deck = Deck.openDeck(deckFilename);
			// Start by getting the first card and displaying it.
			Card card = deck.getCard();
			Log.i(TAG, ""Deck loaded!"");

			return new TaskData(AnkiDroid.DECK_LOADED, deck, card);
		} catch (SQLException e)
		{
			Log.i(TAG, ""The database "" + deckFilename + "" could not be opened = "" + e.getMessage());
			return new TaskData(AnkiDroid.DECK_NOT_LOADED);
		} catch (CursorIndexOutOfBoundsException e)
		{
			Log.i(TAG, ""The deck has no cards = "" + e.getMessage());;
			return new TaskData(AnkiDroid.DECK_EMPTY);
		}
	}
	
	private TaskData doInBackgroundSuspendCard(TaskData... params)
	{
		long start, stop;
		Deck deck = params[0].getDeck();
		Card oldCard = params[0].getCard();
		Card newCard;

		AnkiDb.database.beginTransaction();
		try 
		{
			if (oldCard != null)
			{
				start = System.currentTimeMillis();
				deck.suspendCard(oldCard.id);
				stop = System.currentTimeMillis();
				Log.v(TAG, ""doInBackgroundSuspendCard - Suspended card in "" + (stop - start) + "" ms."");
			}
	
			start = System.currentTimeMillis();
			newCard = deck.getCard();
			stop = System.currentTimeMillis();
			Log.v(TAG, ""doInBackgroundSuspendCard - Loaded new card in "" + (stop - start) + "" ms."");
			publishProgress(new TaskData(newCard));
			AnkiDb.database.setTransactionSuccessful();
		} finally 
		{
			AnkiDb.database.endTransaction();
		}
		
		return null;
	}

	public static interface TaskListener
	{
		public void onPreExecute();

		public void onPostExecute(TaskData result);

		public void onProgressUpdate(TaskData... values);
	}

	public static class TaskData
	{
		private Deck deck;
		private Card card;
		private int integer;
		private String msg;

		public TaskData(int value, Deck deck, Card card)
		{
			this(value);
			this.deck = deck;
			this.card = card;
		}

		public TaskData(Card card)
		{
			this.card = card;
		}

		public TaskData(int value)
		{
			this.integer = value;
		}

		public TaskData(String msg)
		{
			this.msg = msg;
		}

		public Deck getDeck()
		{
			return deck;
		}

		public Card getCard()
		{
			return card;
		}

		public int getInt()
		{
			return integer;
		}

		public String getString()
		{
			return msg;
		}

	}

}
",True,38,26,0,0,4,14
13,com.ichi2.anki.AnkiDroidWidget.java,"package com.ichi2.anki;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Collections;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.IBinder;
import android.util.Log;
import android.widget.RemoteViews;

import com.tomgibara.android.veecheck.util.PrefSettings;

public class AnkiDroidWidget extends AppWidgetProvider {
	private static final String TAG = ""AnkiDroidWidget"";
	
	@Override
	public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
		Log.i(TAG, ""onUpdate"");
		
		context.startService(new Intent(context, UpdateService.class));
	}
	
	public static class UpdateService extends Service {
		private static final String TAG = ""AnkiDroidWidgetUpdateService"";

		//Simple class to hold the deck information for the widget
		public class DeckInformation {
			private String deckName;
			private int newCards;
			private int dueCards;
			
			public String getDeckName() { return deckName; }
			public int getNewCards() { return newCards; }
			public int getDueCards() { return dueCards; }
			
			public DeckInformation(String deckName, int newCards, int dueCards) {
				this.deckName = deckName;
				this.newCards = newCards;
				this.dueCards = dueCards;
			}
			
			public String toString() {
				if(getDeckName().length()>13)
					return String.format(""%s %d %d"", getDeckName().substring(0, 13), getNewCards(), getDueCards());
				else 
					return String.format(""%s %d %d"", getDeckName(), getNewCards(), getDueCards());
			}
		}
		
		@Override
		public void onStart(Intent intent, int startId) {
			Log.i(TAG, ""OnStart"");
			
			RemoteViews updateViews = buildUpdate(this);

			ComponentName thisWidget = new ComponentName(this, AnkiDroidWidget.class);
            AppWidgetManager manager = AppWidgetManager.getInstance(this);
            manager.updateAppWidget(thisWidget, updateViews);
		}

		private RemoteViews buildUpdate(Context context) {
			Log.i(TAG, ""buildUpdate"");

			//Resources res = context.getResources();
			RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.ankidroid_widget_view);
            Deck currentDeck = AnkiDroidApp.getDeck();
            
			//Fetch the deck information, sorted by due cards
			ArrayList<DeckInformation> decks = fetchDeckInformation();
			//ArrayList<DeckInformation> decks = mockFetchDeckInformation(); // TODO use real instead of mock
			StringBuilder sb = new StringBuilder();
			
			int totalDue = 0;
			
			//If there are less than 3 decks display all, otherwise only the first 3
			for(int i=0; i<decks.size() && i<3; i++) {
				DeckInformation deck = decks.get(i);
				sb.append(String.format(""%s\n"", deck.toString()));
				
				totalDue += deck.getDueCards();
			}
			
			if(sb.length()>1) { //Get rid of the trailing \n
				sb.substring(0, sb.length()-1);
			}
			
			updateViews.setTextViewText(R.id.anki_droid_text, sb);
						
			if(currentDeck!=null) {
				AnkiDroidApp.setDeck(currentDeck);
				Deck.openDeck(currentDeck.getDeckPath());
			}
			
			if(totalDue>30) { //Raise a notification
				String ns = Context.NOTIFICATION_SERVICE;
				NotificationManager mNotificationManager = (NotificationManager) getSystemService(ns);
				
				int icon = R.drawable.anki;
				CharSequence tickerText = String.format(""%d AnkiDroid cards due"", totalDue);
				long when = System.currentTimeMillis();

				Notification notification = new Notification(icon, tickerText, when);
				notification.defaults |= Notification.DEFAULT_VIBRATE;
				notification.defaults |= Notification.DEFAULT_LIGHTS;
				
				Context appContext = getApplicationContext();
				CharSequence contentTitle = ""Cards Due"";
				String contentText = sb.toString();
				Intent notificationIntent = new Intent(this, AnkiDroid.class);
				PendingIntent contentIntent = PendingIntent.getActivity(this, 0, notificationIntent, 0);

				notification.setLatestEventInfo(appContext, contentTitle, contentText, contentIntent);
				
				final int WIDGET_NOTIFY_ID = 1;
				mNotificationManager.notify(WIDGET_NOTIFY_ID, notification);
			}
			
			return updateViews;
		}

		@SuppressWarnings(""unused"")
		private ArrayList<DeckInformation> mockFetchDeckInformation() {
			final int maxDecks = 10;
			ArrayList<DeckInformation> information = new ArrayList<DeckInformation>(maxDecks);
			
			for(int i=0; i<maxDecks; i++) {
				String deckName = String.format(""my anki deck number %d"", i);
				information.add(new DeckInformation(deckName, i*20, i*25));
			}
			
			Collections.sort(information, new ByDueComparator());
			Collections.reverse(information);
			
			return information;
		}

		private ArrayList<DeckInformation> fetchDeckInformation() {
			Log.i(TAG, ""fetchDeckInformation"");
			
			SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
			String deckPath = preferences.getString(""deckPath"", ""/sdcard"");
			
			File dir = new File(deckPath);
			
			if(dir==null) //Directory doesn't exist
				return new ArrayList<DeckInformation>();
			
			File[] fileList = dir.listFiles(new AnkiFileFilter());
			
			if(fileList==null || fileList.length==0) //No files or some other error
				return new ArrayList<DeckInformation>();
			
			//For the deck information
			ArrayList<DeckInformation> information = new ArrayList<DeckInformation>(fileList.length);
			
			for(File file : fileList) {
				try { //Run through the decks and get the information
					String absPath = file.getAbsolutePath();
					String deckName = file.getName().replaceAll("".anki"", """");
					
					Deck deck = Deck.openDeck(absPath);
					int dueCards = deck.failedSoonCount + deck.revCount;
					int newCards = deck.newCountToday;
					deck.closeDeck();
					
					//Add the information about the deck
					information.add(new DeckInformation(deckName, newCards, dueCards));
				}
				catch(Exception e) {
					Log.i(TAG, ""Could not open deck"");
					Log.e(TAG, e.toString());
				}
			}
			
			if(!information.isEmpty() && information.size()>1) { //Sort and reverse the list if there are decks
				Log.i(TAG, ""Sorting deck"");
				
				Collections.sort(information, new ByDueComparator());
				Collections.reverse(information);
			}
			
			return information;
		}
		
		//Sorter for the decks based on number due
		public class ByDueComparator implements java.util.Comparator<DeckInformation>
		{
			public int compare(DeckInformation deck1, DeckInformation deck2) {
				
				if(deck2.dueCards == deck2.dueCards)
					return 0;
				
				if(deck1.dueCards > deck2.dueCards)
					return 1;
				
				return -1;
			}
		}
		
		private static final class AnkiFileFilter implements FileFilter
		{
			public boolean accept(File pathname)
			{
				return pathname.isFile() && pathname.getName().endsWith("".anki"");
			}
		}
			
		@Override
		public IBinder onBind(Intent arg0) {
			Log.i(TAG, ""onBind"");
			// TODO Auto-generated method stub
			return null;
		}
	}
}
",True,31,27,0,0,4,11
14,com.ichi2.anki.CardHistoryEntry.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;

/**
 * Review history of a card.
 */
public class CardHistoryEntry {

	// BEGIN: SQL table columns
	long cardId;
	double time;
	double lastInterval;
	double nextInterval;
	int ease;
	double delay;
	double lastFactor;
	double nextFactor;
	double reps;
	double thinkingTime;
	double yesCount;
	double noCount;
	// END: SQL table columns

	/**
	 * Constructor
	 */
	public CardHistoryEntry(Card card, int ease, double delay)
	{
		if (card == null)
			return;

		cardId = card.id;
		lastInterval = card.lastInterval;
		nextInterval = card.interval;
		lastFactor = card.lastFactor;
		nextFactor = card.factor;
		reps = card.reps;
		yesCount = card.yesCount;
		noCount = card.noCount;
		this.ease = ease;
		this.delay = delay;
		thinkingTime = card.thinkingTime();
	}

	/**
	 * Write review history to the database.
	 */
	public void writeSQL()
	{
	ContentValues values = new ContentValues();
	values.put(""cardId"", cardId);
	values.put(""lastInterval"", lastInterval);
	values.put(""nextInterval"", nextInterval);
	values.put(""ease"", ease);
	values.put(""delay"", delay);
	values.put(""lastFactor"", lastFactor);
	values.put(""nextFactor"", nextFactor);
	values.put(""reps"", reps);
	values.put(""thinkingTime"", thinkingTime);
	values.put(""yesCount"", yesCount);
	values.put(""noCount"", noCount);
	values.put(""time"", System.currentTimeMillis() / 1000.0);

	AnkiDb.database.insert(""reviewHistory"", null, values);
	}
}
",False,48,26,0,0,6,10
15,com.ichi2.anki.SharedDeck.java,"package com.ichi2.anki;

import java.util.HashMap;

import android.util.Log;

@SuppressWarnings(""serial"")
public class SharedDeck extends HashMap<String, Object>{

	private static final String TAG = ""AnkidroidSharedDecks"";
	private int id;
	private String username;
	private String title;
	private String description;
	private String tags;
	private int version;
	private int facts;
	private int size;
	private int count;
	private double modified;
	private String fileName;

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getTitle() {
		return title;
	}

	public void setTitle(String title) {
		this.title = title;
		put(""title"", this.title);
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getTags() {
		return tags;
	}

	public void setTags(String tags) {
		this.tags = tags;
	}

	public int getVersion() {
		return version;
	}

	public void setVersion(int version) {
		this.version = version;
	}

	public int getFacts() {
		return facts;
	}

	public void setFacts(int facts) {
		this.facts = facts;
		if(facts == 1)
		{
			put(""facts"", this.facts + "" "" + AnkiDroidApp.getAppResources().getString(R.string.fact));
		}
		else
		{
			put(""facts"", this.facts + "" "" + AnkiDroidApp.getAppResources().getString(R.string.facts));
		}
	}

	public int getSize() {
		return size;
	}

	public void setSize(int size) {
		this.size = size;
	}

	public int getCount() {
		return count;
	}

	public void setCount(int count) {
		this.count = count;
	}

	public double getModified() {
		return modified;
	}

	public void setModified(double modified) {
		this.modified = modified;
	}

	public String getFileName() {
		return fileName;
	}

	public void setFileName(String fileName) {
		this.fileName = fileName;
	}
	
	public void prettyLog()
	{
		Log.i(TAG, ""SHARED DECK:"");
		Log.i(TAG, ""		username = "" + this.username);
		Log.i(TAG, ""		title = "" + this.title);
		Log.i(TAG, ""		description = "" + this.description);
		Log.i(TAG, ""		tags = "" + this.tags);
		Log.i(TAG, ""		version = "" + this.version);
		Log.i(TAG, ""		facts = "" + this.facts);
		Log.i(TAG, ""		size = "" + this.size);
		Log.i(TAG, ""		count = "" + this.count);
		Log.i(TAG, ""		modified = "" + this.modified);
		Log.i(TAG, ""		fileName = "" + this.fileName);
	}
}
",False,46,27,1,1,5,9
16,com.ichi2.anki.SharedDeckPicker.java,"package com.ichi2.anki;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ListView;
import android.widget.SimpleAdapter;

import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.tomgibara.android.veecheck.util.PrefSettings;

public class SharedDeckPicker extends Activity {

	private ProgressDialog progressDialog;
	
	private AlertDialog noConnectionAlert;
	
	private AlertDialog connectionFailedAlert;
	
	List<SharedDeck> mSharedDecks;
	ListView mSharedDecksListView;
	SimpleAdapter mSharedDecksAdapter;
	
	SharedDeck downloadedDeck;
	
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		
		initAlertDialogs();
		
		mSharedDecks = new ArrayList<SharedDeck>();
		mSharedDecksAdapter = new SimpleAdapter(this, mSharedDecks, R.layout.shared_deck_item, new String[] {""title"", ""facts""}, new int[] {R.id.SharedDeckTitle, R.id.SharedDeckFacts});
		mSharedDecksListView = (ListView)findViewById(R.id.files);
		mSharedDecksListView.setAdapter(mSharedDecksAdapter);
		mSharedDecksListView.setOnItemClickListener(new OnItemClickListener() {

			//@Override
			public void onItemClick(AdapterView<?> parent, View view, int position, long id) 
			{
				downloadedDeck = mSharedDecks.get(position);
				SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
				String deckPath = preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
				Connection.downloadSharedDeck(downloadSharedDeckListener, new Connection.Payload(new Object[] {downloadedDeck, deckPath}));
			}
			
		});
		Connection.getSharedDecks(getSharedDecksListener, new Connection.Payload(new Object[] {}));
	}

	/**
	 * Create AlertDialogs used on all the activity
	 */
	private void initAlertDialogs()
	{
		Resources res = getResources();
		
		AlertDialog.Builder builder = new AlertDialog.Builder(this);
		
		builder.setMessage(res.getString(R.string.connection_needed));
		builder.setPositiveButton(res.getString(R.string.ok), null);
		noConnectionAlert = builder.create();
		
	    builder.setMessage(res.getString(R.string.connection_unsuccessful));
	    connectionFailedAlert = builder.create();
	}
	
	/**
	 * Listeners
	 */
	Connection.TaskListener getSharedDecksListener = new Connection.TaskListener() {

//		@Override
		public void onDisconnected() {
			noConnectionAlert.show();
		}

		@SuppressWarnings(""unchecked"")
//		@Override
		public void onPostExecute(Payload data) {
			//progressDialog.dismiss();
			if(data.success)
			{
				mSharedDecks.clear();
				mSharedDecks.addAll((List<SharedDeck>)data.result);
				mSharedDecksAdapter.notifyDataSetChanged();
			}
			else
			{
				connectionFailedAlert.show();
			}
		}

//		@Override
		public void onPreExecute() {
			//Pass
		}

//		@Override
		public void onProgressUpdate(Object... values) {
			//Pass
		}
		
	};
	
	Connection.TaskListener downloadSharedDeckListener = new Connection.TaskListener() {

//		@Override
		public void onDisconnected() {
			noConnectionAlert.show();
		}

//		@Override
		public void onPostExecute(Payload data) {
			progressDialog.dismiss();
			if(data.success)
			{
				Intent intent = SharedDeckPicker.this.getIntent();
				// Return the name of the downloaded deck
				intent.putExtra(AnkiDroid.OPT_DB, (String)data.result);
				setResult(RESULT_OK, intent);

				finish();
			}
			else
			{
				connectionFailedAlert.show();
			}
		}

//		@Override
		public void onPreExecute() {
			progressDialog = ProgressDialog.show(SharedDeckPicker.this, """", getResources().getString(R.string.downloading_shared_deck));
		}

//		@Override
		public void onProgressUpdate(Object... values) {
			//Pass
		}
		
	};
}
",True,30,27,0,0,3,14
17,com.ichi2.anki.DeckPicker.java,"/****************************************************************************************
* Copyright (c) 2009 Andrew Dubya <andrewdubya@gmail.com>                              *
* Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.anki;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.TreeSet;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.database.SQLException;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.preference.PreferenceManager;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.SimpleAdapter;

import com.tomgibara.android.veecheck.util.PrefSettings;

/**
 * Allows the user to choose a deck from the filesystem.
 */
public class DeckPicker extends Activity implements Runnable
{

	private static final String TAG = ""AnkiDroid"";

	/**
	 * Dialogs
	 */
	private static final int DIALOG_NO_SDCARD = 0;

	private DeckPicker mSelf;

	private SimpleAdapter mDeckListAdapter;

	private ArrayList<HashMap<String, String>> mDeckList;

	private ListView mDeckListView;

	private File[] mFileList;

	private ReentrantLock mLock = new ReentrantLock();

	private Condition mCondFinished = mLock.newCondition();

	private boolean mIsFinished = true;

	private boolean mDeckIsSelected = false;

	private BroadcastReceiver mUnmountReceiver = null;

	AdapterView.OnItemClickListener mDeckSelHandler = new AdapterView.OnItemClickListener()
	{
		public void onItemClick(AdapterView<?> parent, View v, int p, long id)
		{
			mSelf.handleDeckSelection(p);
		}
	};

	/** Called when the activity is first created. */
	@Override
	public void onCreate(Bundle savedInstanceState) throws SQLException
	{
		Log.i(TAG, ""DeckPicker - onCreate"");
		super.onCreate(savedInstanceState);

		registerExternalStorageListener();

		mSelf = this;
		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
		String deckPath = preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
		setContentView(R.layout.main);

		mDeckList = new ArrayList<HashMap<String, String>>();
		mDeckListView = (ListView) findViewById(R.id.files);
		mDeckListAdapter = new SimpleAdapter(this, mDeckList, R.layout.deck_picker_list, new String[]
		{ ""name"", ""due"", ""new"", ""showProgress"" }, new int[]
		{ R.id.DeckPickerName, R.id.DeckPickerDue, R.id.DeckPickerNew, R.id.DeckPickerProgress });

		mDeckListAdapter.setViewBinder(new SimpleAdapter.ViewBinder()
		{
			public boolean setViewValue(View view, Object data, String text)
			{
				if (view instanceof ProgressBar)
				{
					if (text.equals(""true""))
						view.setVisibility(View.VISIBLE);
					else
						view.setVisibility(View.GONE);
					return true;
				}
				return false;
			}
		});
		mDeckListView.setOnItemClickListener(mDeckSelHandler);
		mDeckListView.setAdapter(mDeckListAdapter);

		populateDeckList(deckPath);
	}

	@Override
    public void onPause()
	{
		Log.i(TAG, ""DeckPicker - onPause"");

		super.onPause();
		waitForDeckLoaderThread();
	}

	@Override
    protected Dialog onCreateDialog(int id)
	{
		Dialog dialog;
		switch(id)
		{
		case DIALOG_NO_SDCARD:
			AlertDialog.Builder builder = new AlertDialog.Builder(this);
			builder.setMessage(""The SD card could not be read. Please, turn off USB storage."");
			builder.setPositiveButton(""OK"", null);
			dialog = builder.create();
			break;

		default:
			dialog = null;
		}

		return dialog;
	}

	private void populateDeckList(String location)
	{
		Log.i(TAG, ""DeckPicker - populateDeckList"");

		Resources res = getResources();
		int len = 0;
		File[] fileList;
		TreeSet<HashMap<String, String>> tree = new TreeSet<HashMap<String, String>>(new HashMapCompare());

		File dir = new File(location);
		fileList = dir.listFiles(new AnkiFilter());

		if (dir.exists() && dir.isDirectory() && fileList != null)
		{
			len = fileList.length;
		}
		mFileList = fileList;
		if (len > 0 && fileList != null)
		{
			Log.i(TAG, ""DeckPicker - populateDeckList, number of anki files = "" + len);
			for (int i = 0; i < len; i++)
			{
				String absPath = fileList[i].getAbsolutePath();

				Log.i(TAG, ""DeckPicker - populateDeckList, file "" + i + "" :"" + fileList[i].getName());
				
				try
				{
					HashMap<String, String> data = new HashMap<String, String>();
					data.put(""name"", fileList[i].getName().replaceAll("".anki"", """"));
					data.put(""due"", res.getString(R.string.deckpicker_loaddeck));
					data.put(""new"", """");
					data.put(""mod"", String.format(""%f"", Deck.getLastModified(absPath)));
					data.put(""filepath"", absPath);
					data.put(""showProgress"", ""true"");

					tree.add(data);

				} catch (SQLException e)
				{
					Log.w(TAG, ""DeckPicker - populateDeckList, File "" + fileList[i].getName() + "" is not a real anki file"");
				}
			}

			Thread thread = new Thread(this);
			thread.start();
		} else
		{
			Log.i(TAG, ""populateDeckList - No decks found."");
			//There is no sd card attached (wrap this code in a function called something like isSdMounted()
			//and place it in a utils class
			if(!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()))
			{
				Log.i(TAG, ""populateDeckList - No sd card."");
				setTitle(R.string.deckpicker_title_nosdcard);
				showDialog(DIALOG_NO_SDCARD);
			}

			HashMap<String, String> data = new HashMap<String, String>();
			data.put(""name"", res.getString(R.string.deckpicker_nodeck));
			data.put(""new"", """");
			data.put(""due"", """");
			data.put(""mod"", ""1"");
			data.put(""showProgress"", ""false"");

			tree.add(data);
		}
		mDeckList.clear();
		mDeckList.addAll(tree);
		mDeckListView.clearChoices();
		mDeckListAdapter.notifyDataSetChanged();
		Log.i(TAG, ""DeckPicker - populateDeckList, Ending"");
	}

	private static final class AnkiFilter implements FileFilter
	{
		public boolean accept(File pathname)
		{
			if (pathname.isFile() && pathname.getName().endsWith("".anki""))
				return true;
			return false;
		}

	}

	private static final class HashMapCompare implements Comparator<HashMap<String, String>>
	{
		public int compare(HashMap<String, String> object1, HashMap<String, String> object2)
		{
			//Order by last modification date (last deck modified first)
			if(object2.get(""mod"").compareToIgnoreCase(object1.get(""mod"")) != 0)
				return object2.get(""mod"").compareToIgnoreCase(object1.get(""mod""));
			//But if there are two decks with the same date of modification, order them in alphabetical order
			else
				return object1.get(""filepath"").compareToIgnoreCase(object2.get(""filepath""));
		}
	}

	private void handleDeckSelection(int id)
	{
		String deckFilename = null;

		waitForDeckLoaderThread();

		@SuppressWarnings(""unchecked"")
		HashMap<String, String> data = (HashMap<String, String>) mDeckListAdapter.getItem(id);
		deckFilename = data.get(""filepath"");

		if (deckFilename != null)
		{
			Log.i(TAG, ""Selected "" + deckFilename);
			Intent intent = this.getIntent();
			intent.putExtra(AnkiDroid.OPT_DB, deckFilename);
			setResult(RESULT_OK, intent);

			finish();
		}
	}

	private void waitForDeckLoaderThread()
	{
		mDeckIsSelected = true;
		Log.i(TAG, ""DeckPicker - waitForDeckLoaderThread(), mDeckIsSelected set to true"");
		mLock.lock();
		try
		{
			while (!mIsFinished)
				mCondFinished.await();
		} catch (InterruptedException e)
		{
			e.printStackTrace();
		} finally
		{
			mLock.unlock();
		}
	}

	public void run()
	{
		Log.i(TAG, ""Thread run - Beginning"");
		int len = 0;
		if (mFileList != null)
			len = mFileList.length;

		if (len > 0 && mFileList != null)
		{
			mLock.lock();
			try
			{
				Log.i(TAG, ""Thread run - Inside lock"");

				mIsFinished = false;
				for (int i = 0; i < len; i++)
				{

					// Don't load any more decks if one has already been
					// selected.
					Log.i(TAG, ""Thread run - Before break mDeckIsSelected = "" + mDeckIsSelected);
					if (mDeckIsSelected)
						break;


					String path = mFileList[i].getAbsolutePath();
					Deck deck;

					try
					{
						deck = Deck.openDeck(path);
					} catch (SQLException e)
					{
						Log.w(TAG, ""Could not open database "" + path);
						continue;
					}
					int dueCards = deck.failedSoonCount + deck.revCount;
					int totalCards = deck.cardCount;
					int newCards = deck.newCountToday;
					deck.closeDeck();

					Bundle data = new Bundle();
					data.putString(""absPath"", path);
					data.putInt(""due"", dueCards);
					data.putInt(""total"", totalCards);
					data.putInt(""new"", newCards);
					Message msg = Message.obtain();
					msg.setData(data);

					handler.sendMessage(msg);

				}
				mIsFinished = true;
				mCondFinished.signal();
			} finally
			{
				mLock.unlock();
			}
		}
	}

	private Handler handler = new Handler()
	{
		@Override
        public void handleMessage(Message msg)
		{
			Bundle data = msg.getData();
			Resources res = mSelf.getResources();

			String path = data.getString(""absPath"");
			String dueString = String.format(res.getString(R.string.deckpicker_due), data.getInt(""due""), data
			        .getInt(""total""));
			String newString = String.format(res.getString(R.string.deckpicker_new), data.getInt(""new""));

			int count = mDeckListAdapter.getCount();
			for (int i = 0; i < count; i++)
			{
				@SuppressWarnings(""unchecked"")
				HashMap<String, String> map = (HashMap<String, String>) mDeckListAdapter.getItem(i);
				if (map.get(""filepath"").equals(path))
				{
					map.put(""due"", dueString);
					map.put(""new"", newString);
					map.put(""showProgress"", ""false"");
				}
			}

			mDeckListAdapter.notifyDataSetChanged();
			Log.i(TAG, ""DeckPicker - mDeckList notified of changes"");
		}
	};


    /**
     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications.
     * The intent will call closeExternalStorageFiles() if the external media
     * is going to be ejected, so applications can clean up any files they have open.
     */
    public void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String action = intent.getAction();
                    if (action.equals(Intent.ACTION_MEDIA_UNMOUNTED)) {
                    	Log.i(TAG, ""DeckPicker - mUnmountReceiver, Action = Media Unmounted"");
                		SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(getBaseContext());
                		String deckPath = preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
                    	populateDeckList(deckPath);
                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                    	Log.i(TAG, ""DeckPicker - mUnmountReceiver, Action = Media Mounted"");
                		SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(getBaseContext());
                		String deckPath = preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
                		mDeckIsSelected = false;
                		setTitle(R.string.deckpicker_title);
                    	populateDeckList(deckPath);
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
            iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
            iFilter.addDataScheme(""file"");
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }

    @Override
    public void onStop()
    {
    	super.onStop();
    	Log.i(TAG, ""DeckPicker - onStop()"");
    	if(mUnmountReceiver != null)
    		unregisterReceiver(mUnmountReceiver);
    }

	/*private void logTree(TreeSet<HashMap<String, String>> tree)
	{
		Iterator<HashMap<String, String>> it = tree.iterator();
		while(it.hasNext())
		{
			HashMap<String, String> map = it.next();
			Log.i(TAG, ""logTree - "" + map.get(""name"") + "", due = "" + map.get(""due"") + "", new = "" + map.get(""new"") + "", showProgress = "" + map.get(""showProgress"") + "", filepath = "" + map.get(""filepath"") + "", last modified = "" + map.get(""mod""));
		}
	}*/

}
",True,43,27,0,0,4,17
18,com.ichi2.anki.Image.java,"/***************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import android.util.Log;

/**
 * Class used to display and handle correctly images
 */
public class Image {
	
	/**
	 * Tag for logging messages
	 */
	private static final String TAG = ""AnkiDroid"";
	
	/**
	 * 
	 * @param deckFilename Deck's filename whose images are going to be load
	 * @param content HTML content of a card's side (question or answer)
	 * @return content Modified content in order to display correctly the images
	 */
	public static String loadImages(String deckFilename, String content)
	{
		Log.i(TAG, ""Image - loadImages, filename = "" + deckFilename);
		String imagePath = deckFilename.replaceAll("".anki"", "".media/"");
		return content.replaceAll(""<img src=\"""", ""<img src=\"""" + ""content://com.ichi2.anki"" + imagePath);
	}
}
",False,18,20,6,5,0,0
19,com.ichi2.anki.Whiteboard.java,"/****************************************************************************************
* Copyright (c) 2009 Andrew <andrewdubya@gmail.com>                                    *
* Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.anki;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Path;
import android.util.AttributeSet;
import android.view.Display;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;

/**
 * Whiteboard allowing the user to draw the card's answer on the touchscreen.
 * TODO Javadoc
 */
public class Whiteboard extends View
{
	private Context mContext;
	
	private Paint mPaint;

	private Bitmap mBitmap;

	private Canvas mCanvas;

	private Path mPath;

	private Paint mBitmapPaint;

	public int mBackgroundColor, mForegroundColor, mExtraHeight;

	private boolean mLocked;

	private boolean mRecreateBitmap = false;

	public Whiteboard(Context context, AttributeSet attrs)
	{
		super(context, attrs);

		mContext = context;
		
		mBackgroundColor = context.getResources().getColor(R.color.wb_bg_color);
		mForegroundColor = context.getResources().getColor(R.color.wb_fg_color);

		mPaint = new Paint();
		mPaint.setAntiAlias(true);
		mPaint.setDither(true);
		mPaint.setColor(mForegroundColor);
		mPaint.setStyle(Paint.Style.STROKE);
		mPaint.setStrokeJoin(Paint.Join.ROUND);
		mPaint.setStrokeCap(Paint.Cap.ROUND);
		mPaint.setStrokeWidth(8);

		createBitmap();
		
		mPath = new Path();
		mBitmapPaint = new Paint(Paint.DITHER_FLAG);
	}

	protected void createBitmap(int w, int h, Bitmap.Config conf)
	{
		mBitmap = Bitmap.createBitmap(w, h, conf);
		mCanvas = new Canvas(mBitmap);
		clear();
	}

	public void createBitmap()
	{
		Display display = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay(); 
		int width = display.getWidth();
		int height = display.getHeight();
		
		createBitmap(width, height, Bitmap.Config.ARGB_8888);
	}
	
	@Override
	public void onSizeChanged(int w, int h, int oldw, int oldh)
	{
		// We want to create the bitmap again only when the screen has been rotated, not when the size changes in the transition
		// between the front and the back of a card (that would made the Whiteboard to disappear)
		if(mRecreateBitmap)
		{
			createBitmap();
			super.onSizeChanged(w, h, oldw, oldh);
			mRecreateBitmap = false;
		}
	}

	public void rotate()
	{
		mRecreateBitmap = true;
	}

	public void clear()
	{
		mBitmap.eraseColor(mBackgroundColor);
		unlock();
	}

	@Override
	protected void onDraw(Canvas canvas)
	{
		super.onDraw(canvas);
		canvas.drawColor(mBackgroundColor);
		canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);
		canvas.drawPath(mPath, mPaint);
	}

	private float mX, mY;

	private static final float TOUCH_TOLERANCE = 4;

	private void touch_start(float x, float y)
	{
		mPath.reset();
		mPath.moveTo(x, y);
		mX = x;
		mY = y;
	}

	private void touch_move(float x, float y)
	{
		float dx = Math.abs(x - mX);
		float dy = Math.abs(y - mY);
		if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE)
		{
			mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
			mX = x;
			mY = y;
		}
	}

	private void touch_up()
	{
		mPath.lineTo(mX, mY);
		// commit the path to our offscreen
		mCanvas.drawPath(mPath, mPaint);
		// kill this so we don't double draw
		mPath.reset();
	}

	@Override
	public boolean onTouchEvent(MotionEvent event)
	{
		if (!mLocked)
		{
			float x = event.getX();
			float y = event.getY();

			switch (event.getAction())
			{
			case MotionEvent.ACTION_DOWN:
				touch_start(x, y);
				invalidate();
				break;
			case MotionEvent.ACTION_MOVE:
				touch_move(x, y);
				invalidate();
				break;
			case MotionEvent.ACTION_UP:
				touch_up();
				invalidate();
				break;
			}
		}

		return true;
	}

	public void unlock()
	{
		mLocked = false;
	}

	public void lock()
	{
		mLocked = true;
	}
}",False,45,20,6,5,0,0
20,com.ichi2.anki.Card.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.lang.reflect.Field;
import java.util.Random;

import android.content.ContentValues;
import android.database.Cursor;
import android.util.Log;

/**
 * 
 * A card is a presentation of a fact, and has two sides: a question and an answer.
 * Any number of fields can appear on each side.
 * When you add a fact to Anki, cards which show that fact are generated.
 * Some models generate one card, others generate more than one.
 * 
 * @see http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Cards
 */
public class Card {

    // TODO: Javadoc.

    // BEGIN SQL table entries
    long id; // Primary key
    long factId; // Foreign key facts.id
    long cardModelId; // Foreign key cardModels.id
    double created = System.currentTimeMillis() / 1000.0;
    double modified = System.currentTimeMillis() / 1000.0;
    String tags = """";
    int ordinal;
    // Cached - changed on fact update
    String question = """";
    String answer = """";
    // Default to 'normal' priority
    // This is indexed in deck.java as we need to create a reverse index
    int priority = 2;
    double interval = 0;
    double lastInterval = 0;
    double due = System.currentTimeMillis() / 1000.0;
    double lastDue = 0;
    double factor = 2.5;
    double lastFactor = 2.5;
    double firstAnswered = 0;
    // Stats
    int reps = 0;
    int successive = 0;
    double averageTime = 0;
    double reviewTime = 0;
    int youngEase0 = 0;
    int youngEase1 = 0;
    int youngEase2 = 0;
    int youngEase3 = 0;
    int youngEase4 = 0;
    int matureEase0 = 0;
    int matureEase1 = 0;
    int matureEase2 = 0;
    int matureEase3 = 0;
    int matureEase4 = 0;
    // This duplicates the above data, because there's no way to map imported
    // data to the above
    int yesCount = 0;
    int noCount = 0;
    double spaceUntil = 0;
    double relativeDelay = 0;
    int isDue = 0;
    int type = 2;
    double combinedDue = 0;
    // END SQL table entries

    // BEGIN JOINed variables
    @SuppressWarnings(""unused"")
	private CardModel cardModel;
    Fact fact;
    // END JOINed variables

    double timerStarted;
    double timerStopped;
    double fuzz;

    public Card(Fact fact, CardModel cardModel, double created) {
        tags = """";
        id = Utils.genID();
        // New cards start as new & due
        type = 2;
        isDue = 1;
        timerStarted = Double.NaN;
        timerStopped = Double.NaN;
        modified = System.currentTimeMillis() / 1000.0;
        if (created != Double.NaN) {
            this.created = created;
            this.due = created;
        }
        else
            due = modified;
        combinedDue = due;
        this.fact = fact;
        this.cardModel = cardModel;
        if (cardModel != null) {
            cardModelId = cardModel.id;
            ordinal = cardModel.ordinal;
            /* FIXME: what is the code below used for? It is never persisted
             * Additionally, cardModel has no accessor.
            HashMap<String, HashMap<Long, String>> d = new HashMap<String, HashMap<Long, String>>();
            Iterator<FieldModel> iter = fact.model.fieldModels.iterator();
            while (iter.hasNext()) {
                FieldModel fm = iter.next();
                HashMap<Long, String> field = new HashMap<Long, String>();
                field.put(fm.id, fact.getFieldValue(fm.name));
                d.put(fm.name, field);
            }
            */
            //			HashMap<String, String> qa = CardModel.formatQA(id, fact.modelId, d, splitTags(), cardModel);
            //			question = qa.get(""question"");
            //			answer = qa.get(""answer"");
        }
    }

    public Card(){
        this(null, null, Double.NaN);
    }

    public Fact getFact() 
    {
        if (fact != null)
        {
            return fact;
        } 
        else
        {
            fact = new Fact(factId);
            return fact;
        }
    }

    public void setModified() {
        modified = System.currentTimeMillis() / 1000.0;
    }

    public void startTimer() {
        timerStarted = System.currentTimeMillis() / 1000.0;
    }

    public void stopTimer() {
        timerStopped = System.currentTimeMillis() / 1000.0;
    }

    public double thinkingTime() {
        if (Double.isNaN(timerStopped))
            return (System.currentTimeMillis() / 1000.0) - timerStarted;
        else
            return timerStopped - timerStarted;
    }

    public double totalTime() {
        return (System.currentTimeMillis() / 1000.0) - timerStarted;
    }

    public void genFuzz() {
        Random rand = new Random();
        fuzz = 0.95 + (0.1 * rand.nextDouble());
    }

    public String htmlQuestion(String type, boolean align) {
        return null;
    }

    public String htmlAnswer(boolean align) {
        return htmlQuestion(""answer"", align);
    }

    public void updateStats(int ease, String state) {
        reps += 1;
        if (ease > 1)
            successive += 1;
        else
            successive = 0;

        double delay = totalTime();
        // Ignore any times over 60 seconds
        if (delay < 60) {
            reviewTime += delay;
            if (averageTime != 0)
                averageTime = (averageTime + delay) / 2.0;
            else
                averageTime = delay;
        }
        // We don't track first answer for cards
        if (state == ""new"")
            state = ""young"";
        // Update ease and yes/no count
        String attr = state + String.format(""Ease%d"", ease);
        try {
            Field f = this.getClass().getDeclaredField(attr);
            f.setInt(this, f.getInt(this) + 1);
        } catch (Exception e) {
            e.printStackTrace();
        }

        if (ease < 2)
            noCount += 1;
        else
            yesCount += 1;
        if (firstAnswered == 0)
            firstAnswered = System.currentTimeMillis() / 1000.0;
        setModified();
    }

    public String[] splitTags() {
        return null;
    }

    public String allTags() {
        return null;
    }

    public boolean hasTag(String tag) {
        return true;
    }
    
    //FIXME: Should be removed. Calling code should directly interact with Model
	public CardModel getCardModel() {
		Model myModel = Model.getModel(cardModelId, false);
		return myModel.getCardModel(cardModelId);
	}

    public boolean fromDB(long id) {
    	Cursor cursor = null;
    	
    	try {
	        cursor = AnkiDb.database.rawQuery(
	                ""SELECT id, factId, cardModelId, created, modified, tags, "" +
	                ""ordinal, question, answer, priority, interval, lastInterval, "" +
	                ""due, lastDue, factor, lastFactor, firstAnswered, reps, "" +
	                ""successive, averageTime, reviewTime, youngEase0, youngEase1, "" +
	                ""youngEase2, youngEase3, youngEase4, matureEase0, matureEase1, "" +
	                ""matureEase2, matureEase3, matureEase4, yesCount, noCount, "" +
	                ""spaceUntil, isDue, type, combinedDue "" +
	                ""FROM cards "" +
	                ""WHERE id = "" +
	                id,
	                null);
	        if (!cursor.moveToFirst()) {
	            Log.w(""anki"", ""Card.java (fromDB(id)): No result from query."");
	            return false;
	        }
	
	        this.id = cursor.getLong(0);
	        this.factId = cursor.getLong(1);
	        this.cardModelId = cursor.getLong(2);
	        this.created = cursor.getDouble(3);
	        this.modified = cursor.getDouble(4);
	        this.tags = cursor.getString(5);
	        this.ordinal = cursor.getInt(6);
	        this.question = cursor.getString(7);
	        this.answer = cursor.getString(8);
	        this.priority = cursor.getInt(9);
	        this.interval = cursor.getDouble(10);
	        this.lastInterval = cursor.getDouble(11);
	        this.due = cursor.getDouble(12);
	        this.lastDue = cursor.getDouble(13);
	        this.factor = cursor.getDouble(14);
	        this.lastFactor = cursor.getDouble(15);
	        this.firstAnswered = cursor.getDouble(16);
	        this.reps = cursor.getInt(17);
	        this.successive = cursor.getInt(18);
	        this.averageTime = cursor.getDouble(19);
	        this.reviewTime = cursor.getDouble(20);
	        this.youngEase0 = cursor.getInt(21);
	        this.youngEase1 = cursor.getInt(22);
	        this.youngEase2 = cursor.getInt(23);
	        this.youngEase3 = cursor.getInt(24);
	        this.youngEase4 = cursor.getInt(25);
	        this.matureEase0 = cursor.getInt(26);
	        this.matureEase1 = cursor.getInt(27);
	        this.matureEase2 = cursor.getInt(28);
	        this.matureEase3 = cursor.getInt(29);
	        this.matureEase4 = cursor.getInt(30);
	        this.yesCount = cursor.getInt(31);
	        this.noCount = cursor.getInt(32);
	        this.spaceUntil = cursor.getDouble(33);
	        this.isDue = cursor.getInt(34);
	        this.type = cursor.getInt(35);
	        this.combinedDue = cursor.getDouble(36);
    	} finally {
    		if (cursor != null) cursor.close();
    	}

        // TODO: Should also read JOINed entries CardModel and Fact.

        return true;
    }

    public void toDB() {
        if (reps == 0)
            type = 2;
        else if (successive != 0)
            type = 1;
        else
            type = 0;

        ContentValues values = new ContentValues();
        values.put(""factId"", factId);
        values.put(""cardModelId"", cardModelId);
        values.put(""created"", created);
        values.put(""modified"", modified);
        values.put(""tags"", tags);
        values.put(""ordinal"", ordinal);
        values.put(""question"", question);
        values.put(""answer"", answer);
        values.put(""priority"", priority);
        values.put(""interval"", interval);
        values.put(""lastInterval"", lastInterval);
        values.put(""due"", due);
        values.put(""lastDue"", lastDue);
        values.put(""factor"", factor);
        values.put(""lastFactor"", lastFactor);
        values.put(""firstAnswered"", firstAnswered);
        values.put(""reps"", reps);
        values.put(""successive"", successive);
        values.put(""averageTime"", averageTime);
        values.put(""reviewTime"", reviewTime);
        values.put(""youngEase0"", youngEase0);
        values.put(""youngEase1"", youngEase1);
        values.put(""youngEase2"", youngEase2);
        values.put(""youngEase3"", youngEase3);
        values.put(""youngEase4"", youngEase4);
        values.put(""matureEase0"", matureEase0);
        values.put(""matureEase1"", matureEase1);
        values.put(""matureEase2"", matureEase2);
        values.put(""matureEase3"", matureEase3);
        values.put(""matureEase4"", matureEase4);
        values.put(""yesCount"", yesCount);
        values.put(""noCount"", noCount);
        values.put(""spaceUntil"", spaceUntil);
        values.put(""isDue"", isDue);
        values.put(""type"", type);
        values.put(""combinedDue"", Math.max(spaceUntil, due));
        values.put(""relativeDelay"", 0.0);
        AnkiDb.database.update(""cards"", values, ""id = "" + id, null);

        // TODO: Should also write JOINED entries: CardModel and Fact.
    }

}
",True,27,27,1,1,5,10
21,com.ichi2.anki.AnkiDroidProxy.java,"/***************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;
import org.json.JSONArray;
import org.json.JSONException;

import android.util.Log;

import com.ichi2.utils.StringUtils;

public class AnkiDroidProxy {

	private static final String TAG = ""AnkidroidSharedDecks"";

	private static final int R_ID = 0;
	private static final int R_USERNAME = 1;
	private static final int R_TITLE = 2;
	private static final int R_DESCRIPTION = 3;
	private static final int R_TAGS = 4;
	private static final int R_VERSION = 5;
	private static final int R_FACTS = 6;
	private static final int R_SIZE = 7;
	private static final int R_COUNT = 8;
	private static final int R_MODIFIED = 9;
	private static final int R_FNAME = 10;
	
	private static final int CHUNK_SIZE = 32768;
	
	private static List<SharedDeck> sharedDecks;
	
	public static List<SharedDeck> getSharedDecks() throws Exception {
		
		try {
			if(sharedDecks == null)
			{
				sharedDecks = new ArrayList<SharedDeck>();
				
				HttpGet httpGet = new HttpGet(""http://anki.ichi2.net/file/search"");
		    	httpGet.setHeader(""Accept-Encoding"", ""identity"");
		    	httpGet.setHeader(""Host"", ""anki.ichi2.net"");
		    	DefaultHttpClient defaultHttpClient = new DefaultHttpClient();
	
		    	HttpResponse httpResponse = defaultHttpClient.execute(httpGet);
				String response = StringUtils.convertStreamToString(httpResponse.getEntity().getContent());
				//Log.i(TAG, ""Content = "" + response);
				sharedDecks.addAll(handleResult(response));
			}
		} catch (Exception e)
		{
			sharedDecks = null;
			throw new Exception();
		}
		
		return sharedDecks;
	}
	
    private static List<SharedDeck> handleResult(String result) throws JSONException
    {
    	List<SharedDeck> sharedDecks = new ArrayList<SharedDeck>();
    	
		JSONArray jsonSharedDecks = new JSONArray(result);
		
		if(jsonSharedDecks != null)
		{
			//Log.i(TAG, ""Number of shared decks = "" + jsonSharedDecks.length());
			
			for(int i = 0; i < jsonSharedDecks.length(); i++)
			{
				JSONArray jsonSharedDeck = jsonSharedDecks.getJSONArray(i);
				
				SharedDeck sharedDeck = new SharedDeck();
				sharedDeck.setId(jsonSharedDeck.getInt(R_ID));
				sharedDeck.setUsername(jsonSharedDeck.getString(R_USERNAME));
				sharedDeck.setTitle(jsonSharedDeck.getString(R_TITLE));
				sharedDeck.setDescription(jsonSharedDeck.getString(R_DESCRIPTION));
				sharedDeck.setTags(jsonSharedDeck.getString(R_TAGS));
				sharedDeck.setVersion(jsonSharedDeck.getInt(R_VERSION));
				sharedDeck.setFacts(jsonSharedDeck.getInt(R_FACTS));
				sharedDeck.setSize(jsonSharedDeck.getInt(R_SIZE));
				sharedDeck.setCount(jsonSharedDeck.getInt(R_COUNT));
				sharedDeck.setModified(jsonSharedDeck.getDouble(R_MODIFIED));
				sharedDeck.setFileName(jsonSharedDeck.getString(R_FNAME));
				
				//sharedDeck.prettyLog();
				
				sharedDecks.add(sharedDeck);
			}
		}
		
		return sharedDecks;
    }

	public static String downloadSharedDeck(SharedDeck sharedDeck, String deckPath) throws ClientProtocolException, IOException {
    	Log.i(TAG, ""Downloading deck "" + sharedDeck.getId());
    	
		HttpGet httpGet = new HttpGet(""http://anki.ichi2.net/file/get?id="" + sharedDeck.getId());
		httpGet.setHeader(""Accept-Encoding"", ""identity"");
		httpGet.setHeader(""Host"", ""anki.ichi2.net"");
		httpGet.setHeader(""Connection"", ""close"");
		DefaultHttpClient httpClient = new DefaultHttpClient();
		HttpResponse httpResponse = httpClient.execute(httpGet);
		Log.i(TAG, ""Connection finished!"");
		InputStream is = httpResponse.getEntity().getContent();
		String deckFilename = handleFile(is, sharedDeck, deckPath);
		is.close();
		
		return deckFilename;
	}
	
	private static String handleFile(InputStream source, SharedDeck sharedDeck, String deckPath) throws IOException
	{
		String deckFilename = """";
		
		ZipInputStream zipInputStream = null;
		if(sharedDeck.getFileName().endsWith("".zip""))
		{
			zipInputStream = new ZipInputStream(source);
			
			String title = sharedDeck.getTitle();
			title = title.replace(""^"", """");
			title = title.substring(0, java.lang.Math.min(title.length(), 40));
			
			if(new File(deckPath + ""/"" + title + "".anki"").exists())
				title += System.currentTimeMillis();
			
			String partialDeckPath = deckPath + ""/"" + title;
			deckFilename = partialDeckPath + "".anki"";
			
			ZipEntry zipEntry = null;
			while((zipEntry = zipInputStream.getNextEntry()) != null)
			{
				//Log.i(TAG, ""zipEntry = "" + zipEntry.getName());
				
				if(""shared.anki"".equalsIgnoreCase(zipEntry.getName()))
				{
					writeToFile(zipInputStream, deckFilename);
				}
				else if(zipEntry.getName().startsWith(""shared.media/"", 0))
				{
					//Log.i(TAG, ""Folder created = "" + new File(AnkiDroidApp.getStorageDirectory() + title + "".media/"").mkdir());
					//Log.i(TAG, ""Destination = "" + AnkiDroidApp.getStorageDirectory() + ""/"" + title + "".media/"" + zipEntry.getName().replace(""shared.media/"", """"));
					writeToFile(zipInputStream, partialDeckPath + "".media/"" + zipEntry.getName().replace(""shared.media/"", """"));
				}
			}
			zipInputStream.close();
		}
		
		return deckFilename;
	}
	
	/**
	 * Utility method to write to a file.
	 */
	private static boolean writeToFile(InputStream source, String destination)
	{
		//Log.i(TAG, ""writeToFile = "" + destination);
		try
		{
			//Log.i(TAG, ""createNewFile"");
			new File(destination).createNewFile();
			//Log.i(TAG, ""New file created"");
	
			OutputStream output = new FileOutputStream(destination);
			
			// Transfer bytes, from source to destination.
			byte[] buf = new byte[CHUNK_SIZE];
			int len;
			if(source == null) Log.i(TAG, ""source is null!"");
			while ((len = source.read(buf)) > 0)
			{
				//Log.i(TAG, ""Writing to file..."");
				output.write(buf, 0, len);
			}
			
			//source.close();
			output.close();
			//Log.i(TAG, ""Write finished!"");

		} catch (Exception e) {
			// Most probably the SD card is not mounted on the Android.
			// Tell the user to turn off USB storage, which will automatically
			// mount it on Android.
			//Log.i(TAG, ""IOException e = "" + e.getMessage());
			return false;
		}
		return true;
	}
}
",True,49,26,0,0,6,8
22,com.ichi2.anki.Stats.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.anki;

import java.lang.reflect.Field;
import java.sql.Date;

import android.content.ContentValues;
import android.database.Cursor;
import android.util.Log;

/**
 * Deck statistics.
 */
public class Stats
{

	/**
	 * Tag for logging messages
	 */
	private static String TAG = ""AnkiDroid"";

	private static final int STATS_LIFE = 0;

	private static final int STATS_DAY = 1;

	// BEGIN: SQL table columns
	long id;

	int type;

	Date day;

	int reps;

	double averageTime;

	double reviewTime;

	// Next two columns no longer used
	double distractedTime;

	int distractedReps;

	int newEase0;

	int newEase1;

	int newEase2;

	int newEase3;

	int newEase4;

	int youngEase0;

	int youngEase1;

	int youngEase2;

	int youngEase3;

	int youngEase4;

	int matureEase0;

	int matureEase1;

	int matureEase2;

	int matureEase3;

	int matureEase4;

	// END: SQL table columns

	public Stats()
	{
		day = null;
		reps = 0;
		averageTime = 0;
		reviewTime = 0;
		distractedTime = 0;
		distractedReps = 0;
		newEase0 = 0;
		newEase1 = 0;
		newEase2 = 0;
		newEase3 = 0;
		newEase4 = 0;
		youngEase0 = 0;
		youngEase1 = 0;
		youngEase2 = 0;
		youngEase3 = 0;
		matureEase0 = 0;
		matureEase1 = 0;
		matureEase2 = 0;
		matureEase3 = 0;
		matureEase4 = 0;
	}

	private void fromDB(long id) {
		Cursor cursor = null;
		
		try {
			Log.i(TAG, ""Reading stats from DB..."");
			cursor = AnkiDb.database.rawQuery(
					""SELECT * "" +
					""FROM stats "" +
					""WHERE id = "" +
					String.valueOf(id),
					null);
			
			if (!cursor.moveToFirst())
				return;
	
			this.id = cursor.getLong(0);
			type = cursor.getInt(1);
			day = Date.valueOf(cursor.getString(2));
			reps = cursor.getInt(3);
			averageTime = cursor.getDouble(4);
			reviewTime = cursor.getDouble(5);
			distractedTime = cursor.getDouble(6);
			distractedReps = cursor.getInt(7);
			newEase0 = cursor.getInt(8);
			newEase1 = cursor.getInt(9);
			newEase2 = cursor.getInt(10);
			newEase3 = cursor.getInt(11);
			newEase4 = cursor.getInt(12);
			youngEase0 = cursor.getInt(13);
			youngEase1 = cursor.getInt(14);
			youngEase2 = cursor.getInt(15);
			youngEase3 = cursor.getInt(16);
			youngEase4 = cursor.getInt(17);
			matureEase0 = cursor.getInt(18);
			matureEase1 = cursor.getInt(19);
			matureEase2 = cursor.getInt(20);
			matureEase3 = cursor.getInt(21);
			matureEase4 = cursor.getInt(22);
		} finally {
			if (cursor != null) cursor.close();
		}
	}

	private void create(int type, Date day)
	{
		Log.i(TAG, ""Creating new stats for "" + day.toString() + ""..."");
		this.type = type;
		this.day = day;

		ContentValues values = new ContentValues();
		values.put(""type"", type);
		values.put(""day"", day.toString());
		values.put(""reps"", 0);
		values.put(""averageTime"", 0);
		values.put(""reviewTime"", 0);
		values.put(""distractedTime"", 0);
		values.put(""distractedReps"", 0);
		values.put(""newEase0"", 0);
		values.put(""newEase1"", 0);
		values.put(""newEase2"", 0);
		values.put(""newEase3"", 0);
		values.put(""newEase4"", 0);
		values.put(""youngEase0"", 0);
		values.put(""youngEase1"", 0);
		values.put(""youngEase2"", 0);
		values.put(""youngEase3"", 0);
		values.put(""youngEase4"", 0);
		values.put(""matureEase0"", 0);
		values.put(""matureEase1"", 0);
		values.put(""matureEase2"", 0);
		values.put(""matureEase3"", 0);
		values.put(""matureEase4"", 0);
		id = AnkiDb.database.insert(""stats"", null, values);
	}

	public void toDB()
	{
		ContentValues values = new ContentValues();
		values.put(""type"", type);
		values.put(""day"", day.toString());
		values.put(""reps"", reps);
		values.put(""averageTime"", averageTime);
		values.put(""reviewTime"", reviewTime);
		values.put(""newEase0"", newEase0);
		values.put(""newEase1"", newEase1);
		values.put(""newEase2"", newEase2);
		values.put(""newEase3"", newEase3);
		values.put(""newEase4"", newEase4);
		values.put(""youngEase0"", youngEase0);
		values.put(""youngEase1"", youngEase1);
		values.put(""youngEase2"", youngEase2);
		values.put(""youngEase3"", youngEase3);
		values.put(""youngEase4"", youngEase4);
		values.put(""matureEase0"", matureEase0);
		values.put(""matureEase1"", matureEase1);
		values.put(""matureEase2"", matureEase2);
		values.put(""matureEase3"", matureEase3);
		values.put(""matureEase4"", matureEase4);

		AnkiDb.database.update(""stats"", values, ""id = "" + id, null);
	}

	public static Date genToday(Deck deck)
	{
		return new Date((long) (System.currentTimeMillis() - deck.utcOffset * 1000));
	}

	public static void updateAllStats(Stats global, Stats daily, Card card, int ease, String oldState)
	{
		updateStats(global, card, ease, oldState);
		updateStats(daily, card, ease, oldState);
	}

	public static void updateStats(Stats stats, Card card, int ease, String oldState)
	{
		stats.reps += 1;
	    double delay = card.totalTime();
	    if (delay >= 60)
	        stats.reviewTime += 60;
	    else
	    {
	        stats.reviewTime += delay;
	        stats.averageTime = (stats.reviewTime / (double) stats.reps);
	    }
	    // update eases
	    String attr = oldState + String.format(""Ease%d"", ease);
		try {
			Field f = stats.getClass().getDeclaredField(attr);
			f.setInt(stats, f.getInt(stats) + 1);
		} catch (Exception e) {
			e.printStackTrace();
		}

	    stats.toDB();
	}

	public static Stats globalStats(Deck deck) 
	{
		Log.i(TAG, ""Getting global stats..."");
		int type = STATS_LIFE;
		Date today = genToday(deck);
		Cursor cursor = null;
		Stats stats = null;

		try {
			cursor = AnkiDb.database.rawQuery(""SELECT id "" + ""FROM stats "" + ""WHERE type = "" + String.valueOf(type),
			        null);
	
			if (cursor.moveToFirst())
			{
				stats = new Stats();
				stats.fromDB(cursor.getLong(0));
				return stats;
			}
		} finally {
			if (cursor != null) cursor.close();
		}
		stats = new Stats();
		stats.create(type, today);
		stats.type = type;
		return stats;
	}

	public static Stats dailyStats(Deck deck)
	{
		Log.i(TAG, ""Getting daily stats..."");
		int type = STATS_DAY;
		Date today = genToday(deck);
		Stats stats = null;
		Cursor cursor = null;

		try {
			Log.i(TAG, ""Trying to get stats for "" + today.toString());
			cursor = AnkiDb.database.rawQuery(""SELECT id "" + ""FROM stats "" + ""WHERE type = "" + String.valueOf(type)
			        + "" and day = \"""" + today.toString() + ""\"""", null);
	
			if (cursor.moveToFirst())
			{
				stats = new Stats();
				stats.fromDB(cursor.getLong(0));
				return stats;
			}
		} finally {
			if (cursor != null) cursor.close();
		}
		stats = new Stats();
		stats.create(type, today);
		stats.type = type;
		return stats;
	}
}
",True,29,26,0,0,6,8
23,com.ichi2.anki.DeckPreferences.java,"/****************************************************************************************
* Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import android.content.ContentValues;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.util.Log;

/**
 * Preferences for the current deck.
 */
public class DeckPreferences extends PreferenceActivity implements OnSharedPreferenceChangeListener
{

    static final String TAG = ""AnkiDroid"";

    public class DeckPreferenceHack implements SharedPreferences
    {

        protected Map<String, String> values = new HashMap<String, String>();

        public DeckPreferenceHack()
        {
            this.cacheValues();

        }

        protected void cacheValues()
        {
        	Log.i(TAG, ""DeckPreferences - CacheValues"");
            values.put( ""newCardsPDay"", String.valueOf( AnkiDroidApp.getDeck().getNewCardsPerDay() ) );
            values.put( ""sessionQLimit"", String.valueOf( AnkiDroidApp.getDeck().getSessionRepLimit() ) );
            values.put( ""sessionTLimit"", String.valueOf( AnkiDroidApp.getDeck().getSessionTimeLimit()/60 ) );
            values.put( ""newCardOrder"", String.valueOf( AnkiDroidApp.getDeck().getNewCardOrder() ) );
            values.put( ""newCardSpacing"", String.valueOf( AnkiDroidApp.getDeck().getNewCardSpacing() ) );
            values.put( ""revCardOrder"", String.valueOf( AnkiDroidApp.getDeck().getRevCardOrder() ) );
        }

        public class Editor implements SharedPreferences.Editor
        {

            public ContentValues update = new ContentValues();

            public SharedPreferences.Editor clear()
            {
                Log.d( TAG, ""clear()"" );
                update = new ContentValues();
                return this;
            }

            public boolean commit()
            {
                Log.d( TAG, ""DeckPreferences - commit() changes back to database"" );

                // make sure we refresh the parent cached values
                // cacheValues();

                for ( Entry<String, Object> entry : update.valueSet() )
                {
                    if ( entry.getKey().equals( ""newCardsPDay"" ) )
                    {
                        AnkiDroidApp.getDeck().setNewCardsPerDay( Integer.parseInt( entry.getValue().toString() ) );
                    }
                    else if ( entry.getKey().equals( ""sessionQLimit"" ) )
                    {
                        AnkiDroidApp.getDeck().setSessionRepLimit( Long.parseLong( entry.getValue().toString() ) );
                    }
                    else if ( entry.getKey().equals( ""sessionTLimit"" ) )
                    {
                        AnkiDroidApp.getDeck().setSessionTimeLimit( 60 * Long.parseLong( entry.getValue().toString() ) );
                    }
                    else if( entry.getKey().equals( ""newCardOrder"" ))
                    {
                        AnkiDroidApp.getDeck().setNewCardOrder( Integer.parseInt( entry.getValue().toString() ) );
                    }
                    else if( entry.getKey().equals( ""newCardSpacing"" ))
                    {
                        AnkiDroidApp.getDeck().setNewCardSpacing( Integer.parseInt( entry.getValue().toString() ) );
                    }
                    else if( entry.getKey().equals( ""revCardOrder"" ))
                    {
                        AnkiDroidApp.getDeck().setRevCardOrder( Integer.parseInt( entry.getValue().toString() ) );
                    }
                }
                // make sure we refresh the parent cached values
                cacheValues();

                // and update any listeners
                for ( OnSharedPreferenceChangeListener listener : listeners )
                {
                    listener.onSharedPreferenceChanged( DeckPreferenceHack.this, null );
                }

                return true;
            }

            public android.content.SharedPreferences.Editor putBoolean( String key, boolean value )
            {
                return this.putString( key, Boolean.toString( value ) );
            }

            public android.content.SharedPreferences.Editor putFloat( String key, float value )
            {
                return this.putString( key, Float.toString( value ) );
            }

            public android.content.SharedPreferences.Editor putInt( String key, int value )
            {
                return this.putString( key, Integer.toString( value ) );
            }

            public android.content.SharedPreferences.Editor putLong( String key, long value )
            {
                return this.putString( key, Long.toString( value ) );
            }

            public android.content.SharedPreferences.Editor putString( String key, String value )
            {
                Log.d( this.getClass().toString(), String.format(""Editor.putString(key=%s, value=%s)"", key, value ) );
                update.put( key, value );
                return this;
            }

            public android.content.SharedPreferences.Editor remove( String key )
            {
                Log.d( this.getClass().toString(), String.format( ""Editor.remove(key=%s)"", key ) );
                update.remove( key );
                return this;
            }

        }

        public boolean contains( String key )
        {
            return values.containsKey(key);
        }

        public Editor edit()
        {
            return new Editor();
        }

        public Map<String, ?> getAll()
        {
            return values;
        }

        public boolean getBoolean( String key, boolean defValue )
        {
            return Boolean.valueOf( this.getString( key, Boolean.toString( defValue ) ) );
        }

        public float getFloat( String key, float defValue )
        {
            return Float.valueOf( this.getString( key, Float.toString( defValue ) ) );
        }

        public int getInt( String key, int defValue )
        {
            return Integer.valueOf( this.getString( key, Integer.toString( defValue ) ) );
        }

        public long getLong( String key, long defValue )
        {
            return Long.valueOf( this.getString( key, Long.toString( defValue ) ) );
        }

        public String getString( String key, String defValue )
        {
            Log.d( this.getClass().toString(), String.format( ""getString(key=%s, defValue=%s)"", key, defValue ) );

            if ( !values.containsKey( key ) )
                return defValue;
            return values.get( key );
        }

        public List<OnSharedPreferenceChangeListener> listeners = new LinkedList<OnSharedPreferenceChangeListener>();

        public void registerOnSharedPreferenceChangeListener(
                OnSharedPreferenceChangeListener listener )
        {
            listeners.add( listener );
        }

        public void unregisterOnSharedPreferenceChangeListener(
                OnSharedPreferenceChangeListener listener )
        {
            listeners.remove( listener );
        }

    }

    protected DeckPreferenceHack pref;

    @Override
    public SharedPreferences getSharedPreferences( String name, int mode )
    {
        Log.d( this.getClass().toString(), String.format( ""getSharedPreferences(name=%s)"", name ) );
        return this.pref;
    }

    @Override
    public void onCreate( Bundle icicle )
    {
        super.onCreate( icicle );

        if ( AnkiDroidApp.getDeck() == null )
        {
            Log.i( TAG, ""DeckPreferences - Selected Deck is NULL"" );
            finish();
        } 
        else
        {
            this.pref = new DeckPreferenceHack();
            this.pref.registerOnSharedPreferenceChangeListener( this );

            this.addPreferencesFromResource( R.layout.deck_preferences );
//            this.updateSummaries();
        }
    }

    public void onSharedPreferenceChanged( SharedPreferences sharedPreferences, String key )
    {
        // update values on changed preference
//        this.updateSummaries();
    }

    protected void updateSummaries()
    {
        // for all text preferences, set summary as current database value
        for ( String key : this.pref.values.keySet() )
        {
            Preference pref = this.findPreference( key );
            if ( pref == null )
                continue;
            if ( pref instanceof CheckBoxPreference )
                continue;
            pref.setSummary( this.pref.getString( key, """" ) );
        }
    }
}
",False,13,27,0,0,4,11
24,com.ichi2.anki.CardEditor.java,"package com.ichi2.anki;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.TreeSet;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.ichi2.anki.Fact.Field;

/**
 * Allows the user to edit a fact, for instance if there is a typo.
 * 
 * A card is a presentation of a fact, and has two sides: a question and an answer.
 * Any number of fields can appear on each side.
 * When you add a fact to Anki, cards which show that fact are generated.
 * Some models generate one card, others generate more than one.
 * 
 * @see http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Cards
 */
public class CardEditor extends Activity {

    private LinearLayout fieldsLayoutContainer;
    
    private Button mSave;
    private Button mCancel;
    
    private Card editorCard;
    
    LinkedList<FieldEditText> editFields;

    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);
        setContentView(R.layout.card_editor);
        
        fieldsLayoutContainer = (LinearLayout) findViewById(R.id.CardEditorEditFieldsLayout);
        
        mSave = (Button) findViewById(R.id.CardEditorSaveButton);
        mCancel = (Button) findViewById(R.id.CardEditorCancelButton);

        editorCard = AnkiDroid.getEditorCard();

        // Card -> FactID -> FieldIDs -> FieldModels
        
        Fact cardFact = editorCard.getFact();
        TreeSet<Field> fields = cardFact.getFields();
        
        editFields = new LinkedList<FieldEditText>();
        
        Iterator<Field> iter = fields.iterator();
        while (iter.hasNext()) {
            FieldEditText newTextbox = new FieldEditText(this, iter.next());
            TextView label = newTextbox.getLabel();
            editFields.add(newTextbox);
            
            fieldsLayoutContainer.addView(label);
            fieldsLayoutContainer.addView(newTextbox);
            // Generate a new EditText for each field
            
        }

        mSave.setOnClickListener(new View.OnClickListener() 
        {

            public void onClick(View v) {
                
                Iterator<FieldEditText> iter = editFields.iterator();
                while (iter.hasNext())
                {
                    FieldEditText current = iter.next();
                    current.updateField();
                }
                setResult(RESULT_OK);
                finish();
            }
            
        });
        
        mCancel.setOnClickListener(new View.OnClickListener() 
        {
            
            public void onClick(View v) {
                
                setResult(RESULT_CANCELED);
                finish();
                
            }
            
        });
    }

    private class FieldEditText extends EditText
    {

        Field pairField;
        
        public FieldEditText(Context context, Field pairField) {
            super(context);
            this.pairField = pairField;
            this.setText(pairField.value);
            // TODO Auto-generated constructor stub
        }
        
        public TextView getLabel() 
        {
            TextView label = new TextView(this.getContext());
            label.setText(pairField.fieldModel.name);
            return label;
        }
        
        public void updateField()
        {
            pairField.value = this.getText().toString();
        }
    }
}
",False,34,27,0,0,4,14
25,com.ichi2.anki.AnkiDroid.java,"/****************************************************************************************
* Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
* Copyright (c) 2009 Andrew <andrewdubya@gmail.com>                                    *
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
* Copyright (c) 2009 Jordi Chacon <jordi.chacon@gmail.com>                             *
* Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.anki;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.database.SQLException;
import android.os.Bundle;
import android.os.Environment;
import android.os.SystemClock;
import android.os.Vibrator;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.webkit.WebView;
import android.widget.Button;
import android.widget.Chronometer;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;
import android.widget.ToggleButton;

import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.utils.DiffEngine;
import com.ichi2.utils.RubyParser;
import com.tomgibara.android.veecheck.util.PrefSettings;

/**
 * Main activity for AnkiDroid. Shows a card and controls to answer it.
 */
public class AnkiDroid extends Activity
{

	/**
	 * Default database
	 */
	public static final String OPT_DB = ""com.ichi2.anki.deckFilename"";

	/**
	 * Tag for logging messages
	 */
	private static final String TAG = ""AnkiDroid"";

	/** Max size of the font for dynamic calculation of font size */
	protected static final int MAX_DYNAMIC_FONT_SIZE = 14;

	/** Min size of the font for dynamic calculation of font size */
	protected static final int MIN_DYNAMIC_FONT_SIZE = 3;
	
	/** The percentage of the absolute font size specified in the deck. */
	private int displayFontSize = 100;

	/** Regex pattern used in removing tags from text before diff */
	private static final Pattern spanPattern = Pattern.compile(""</?span[^>]*>"");
	private static final Pattern brPattern = Pattern.compile(""<br\\s?/?>"");

	/**
	 * Menus
	 */
	public static final int MENU_OPEN = 0;

    private static final int MENU_GET_SHARED_DECKS = 1;

	public static final int MENU_PREFERENCES = 2;

	public static final int MENU_DECKOPTS = 3;

    private static final int MENU_EDIT = 4;
    
	public static final int MENU_SUSPEND = 5;

	public static final int MENU_ABOUT = 6;

	/**
	 * Possible outputs trying to load a deck
	 */
	public static final int DECK_LOADED = 0;

	public static final int DECK_NOT_LOADED = 1;

	public static final int DECK_EMPTY = 2;

	/**
	 * Available options returning from another activity
	 */
	public static final int PICK_DECK_REQUEST = 0;

	public static final int PREFERENCES_UPDATE = 1;

    public static final int EDIT_CURRENT_CARD = 2;
    
    public static final int GET_SHARED_DECK = 3;
    
    public static final int REPORT_ERROR = 4;

	/**
	 * Variables to hold the state
	 */
	private ProgressDialog progressDialog;

	private AlertDialog updateAlert;
	
	private AlertDialog noConnectionAlert;
	
	private AlertDialog connectionFailedAlert;

	private BroadcastReceiver mUnmountReceiver = null;

	/**
	 * Name of the last deck loaded
	 */
	private String deckFilename;
	
    /**
     * Indicates if a deck is trying to be load. onResume() won't try to load a deck if deckSelected is true.
     * We don't have to worry to set deckSelected to true, it's done automatically in displayProgressDialogAndLoadDeck().
     * We have to set deckSelected to false only on these situations a deck has to be reload and when we know for sure no other thread is trying to load a deck (for example, when sd card is mounted again)
     */
	private boolean deckSelected;

	private boolean deckLoaded;
	
	private boolean cardsToReview;

	private boolean sdCardAvailable = isSdCardMounted();
	
	private boolean inDeckPicker;

	private boolean corporalPunishments;

	private boolean timerAndWhiteboard;

	private boolean writeAnswers;
	
	/** Preference: parse for ruby annotations */
	private boolean useRubySupport;
	
	/** Preference: hide the question when showing the answer */
	private int hideQuestionInAnswer;
	
//	private static final int HQIA_DO_HIDE = 0;
	
	private static final int HQIA_DO_SHOW = 1; // HQIA = Hide Question In Answer
	
	private static final int HQIA_CARD_MODEL = 2;

	@SuppressWarnings(""unused"")
	private boolean updateNotifications; // TODO use Veecheck only if this is true

	public String cardTemplate;

	private Card currentCard;
	
	/**
	 * To be assigned as the currentCard or a new card to be sent to and from the editor
	 */
    private static Card editorCard;

	/**
	 * Variables to hold layout objects that we need to update or handle events for
	 */
	private WebView mCard;

	private ToggleButton mToggleWhiteboard, mFlipCard;

	private EditText mAnswerField;

	private Button mButtonReviewEarly, mButtonSwitchDeck, mEase0, mEase1, mEase2, mEase3;

	private Chronometer mCardTimer;
	
	private LinearLayout mChronoButtonsLayout;
	
	//private WebView mCounts;

	/**
	 * Time (in ms) at which the session will be over.
	 */
	private long mSessionTimeLimit;

	private int mSessionCurrReps = 0;

	private Whiteboard mWhiteboard;

	/**
	 * Handler for the flip toogle button, between the question and the answer of a card.
	 */
	CompoundButton.OnCheckedChangeListener mFlipCardHandler = new CompoundButton.OnCheckedChangeListener()
	{
		//@Override
		public void onCheckedChanged(CompoundButton buttonView, boolean showAnswer)
		{
			Log.i(TAG, ""Flip card changed:"");
			if (showAnswer)
				displayCardAnswer();
			else
				displayCardQuestion();
		}
	};

	/**
	 * Handler for the Whiteboard toggle button.
	 */
	CompoundButton.OnCheckedChangeListener mToggleOverlayHandler = new CompoundButton.OnCheckedChangeListener()
	{
		public void onCheckedChanged(CompoundButton btn, boolean state)
		{
			setOverlayState(state);
		}
	};

	View.OnClickListener mSelectEaseHandler = new View.OnClickListener()
	{
		public void onClick(View view)
		{
			int ease;
			switch (view.getId())
			{
			case R.id.ease1:
				ease = 1;
				if (corporalPunishments)
				{
					Vibrator v = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
					v.vibrate(500);
				}
				break;
			case R.id.ease2:
				ease = 2;
				break;
			case R.id.ease3:
				ease = 3;
				break;
			case R.id.ease4:
				ease = 4;
				break;
			default:
				ease = 0;
				return;
			}

			DeckTask.launchDeckTask(
					DeckTask.TASK_TYPE_ANSWER_CARD,
					mAnswerCardHandler,
					new DeckTask.TaskData(ease, AnkiDroidApp.getDeck(), currentCard));
		}
	};

	View.OnClickListener mButtonReviewEarlyHandler = new View.OnClickListener()
	{
		public void onClick(View view)
		{
			Log.i(TAG, ""mButtonReviewEarlyHandler"");
			mButtonReviewEarly.setVisibility(View.GONE);
			mButtonSwitchDeck.setVisibility(View.GONE);
			Deck d = AnkiDroidApp.getDeck();
			d.setReviewEarly(true);
			currentCard = d.getCard();
			if (currentCard != null){
				showControls(true);
				deckLoaded = true;
				cardsToReview = true;
				mFlipCard.setChecked(false);
				displayCardQuestion();

				mWhiteboard.clear();
				mCardTimer.setBase(SystemClock.elapsedRealtime());
				mCardTimer.start();
				long timelimit = AnkiDroidApp.getDeck().getSessionTimeLimit() * 1000;
				Log.i(TAG, ""SessionTimeLimit: "" + timelimit + "" ms."");
				mSessionTimeLimit = System.currentTimeMillis() + timelimit;
				mSessionCurrReps = 0;
			}
		}
	};

	View.OnClickListener mButtonSwitchDeckHandler = new View.OnClickListener()
	{
		public void onClick(View view)
		{
			Log.i(TAG, ""mButtonSwitchDeckHandler"");
			mButtonReviewEarly.setVisibility(View.GONE);
			mButtonSwitchDeck.setVisibility(View.GONE);
			openDeckPicker();
		}
	};

    public static Card getEditorCard () {
        return editorCard;
    }

    private boolean hasErrorFiles() {
    	for(String file : this.fileList()) {
    		if(file.endsWith("".stacktrace""))
    			return true;
    	}
    	
    	return false;
    }
    
	@Override
	public void onCreate(Bundle savedInstanceState) throws SQLException
	{
		super.onCreate(savedInstanceState);
		
		Log.i(TAG, ""onCreate - savedInstanceState: "" + savedInstanceState);

		boolean hasErrors = hasErrorFiles();
		
		if(hasErrors) {
			Intent i = new Intent(this, ErrorReporter.class);
			startActivityForResult(i, REPORT_ERROR);
		}
		
		Bundle extras = getIntent().getExtras();
		SharedPreferences preferences = restorePreferences();
		initAlertDialogs();
		initLayout(R.layout.flashcard_portrait);

		registerExternalStorageListener();
		initResourceValues();

		if (extras != null && extras.getString(OPT_DB) != null)
		{
			// A deck has just been selected in the decks browser.
			deckFilename = extras.getString(OPT_DB);
			Log.i(TAG, ""onCreate - deckFilename from extras: "" + deckFilename);
		} else if (savedInstanceState != null)
		{
			// Use the same deck as last time AnkiDroid was used.
			deckFilename = savedInstanceState.getString(""deckFilename"");
			Log.i(TAG, ""onCreate - deckFilename from savedInstanceState: "" + deckFilename);
		} else
		{
			Log.i(TAG, ""onCreate - "" + preferences.getAll().toString());
			deckFilename = preferences.getString(""deckFilename"", null);
			Log.i(TAG, ""onCreate - deckFilename from preferences: "" + deckFilename);
		}

		if (deckFilename == null || !new File(deckFilename).exists())
		{
			// No previously selected deck.
			Log.i(TAG, ""onCreate - No previously selected deck or the previously selected deck is not available at the moment"");
			if(isSdCardMounted())
			{
				boolean generateSampleDeck = preferences.getBoolean(""generateSampleDeck"", true);
				if (generateSampleDeck)
				{
					Log.i(TAG, ""onCreate - Generating sample deck..."");
					// Load sample deck.
					// This sample deck is for people who downloaded the app but
					// don't know Anki.
					// These people will understand how it works and will get to
					// love it!
					// TODO Where should we put this sample deck?
					String SAMPLE_DECK_FILENAME = AnkiDroidApp.getStorageDirectory() + ""/country-capitals.anki"";
					if (!new File(/*
								 * deckFilename triggers NPE bug in
								 * java.io.File.java
								 */AnkiDroidApp.getStorageDirectory(), ""country-capitals.anki"").exists())
					{
						try
						{
							// Copy the sample deck from the assets to the SD card.
							InputStream stream = getResources().getAssets().open(""country-capitals.anki"");
							boolean written = writeToFile(stream, SAMPLE_DECK_FILENAME);
							if (!written)
							{
								openDeckPicker();
								Log.i(TAG, ""onCreate - The copy of country-capitals.anki to the sd card failed."");
								return;
							}
							Log.i(TAG, ""onCreate - The copy of country-capitals.anki to the sd card was sucessful."");
						} catch (IOException e)
						{
							e.printStackTrace();
						}
					}
					// Load sample deck.
					deckFilename = SAMPLE_DECK_FILENAME;
				} else
				{
					// Show the deck picker.
					openDeckPicker();
				}
			}

		}
	}


	/**
	 * Retrieve resource values.
	 */
	public void initResourceValues()
	{
		Resources r = getResources();
		cardTemplate = r.getString(R.string.card_template);
	}

	/**
	 * Create AlertDialogs used on all the activity
	 */
	private void initAlertDialogs()
	{
		Resources res = getResources();
		
		AlertDialog.Builder builder = new AlertDialog.Builder(this);
		
		builder.setMessage(res.getString(R.string.connection_needed));
		builder.setPositiveButton(res.getString(R.string.ok), null);
		noConnectionAlert = builder.create();
		
	    builder.setMessage(res.getString(R.string.connection_unsuccessful));
	    connectionFailedAlert = builder.create();
	}
	
	/**
	 * Set the content view to the one provided and initialize accessors.
	 */
	public void initLayout(Integer layout)
	{
		Log.i(TAG, ""initLayout - Beginning"");
		setContentView(layout);

		mCard = (WebView) findViewById(R.id.flashcard);
		mCard.setScrollBarStyle(WebView.SCROLLBARS_OUTSIDE_OVERLAY);
		mButtonReviewEarly = (Button) findViewById(R.id.review_early);
		mButtonSwitchDeck = (Button) findViewById(R.id.switch_deck);
		mEase0 = (Button) findViewById(R.id.ease1);
		mEase1 = (Button) findViewById(R.id.ease2);
		mEase2 = (Button) findViewById(R.id.ease3);
		mEase3 = (Button) findViewById(R.id.ease4);
		mCardTimer = (Chronometer) findViewById(R.id.card_time);
		//mCounts = (WebView) findViewById(R.id.counts);
		mFlipCard = (ToggleButton) findViewById(R.id.flip_card);
		mToggleWhiteboard = (ToggleButton) findViewById(R.id.toggle_overlay);
		mWhiteboard = (Whiteboard) findViewById(R.id.whiteboard);
		mAnswerField = (EditText) findViewById(R.id.answer_field);
		mChronoButtonsLayout = (LinearLayout) findViewById(R.id.chrono_buttons_layout);
		
		showControls(false);

		mButtonReviewEarly.setOnClickListener(mButtonReviewEarlyHandler);
		mButtonSwitchDeck.setOnClickListener(mButtonSwitchDeckHandler);
		mEase0.setOnClickListener(mSelectEaseHandler);
		mEase1.setOnClickListener(mSelectEaseHandler);
		mEase2.setOnClickListener(mSelectEaseHandler);
		mEase3.setOnClickListener(mSelectEaseHandler);
		mFlipCard.setChecked(true); // Fix for mFlipCardHandler not being called on first deck load.
		mFlipCard.setOnCheckedChangeListener(mFlipCardHandler);
		mToggleWhiteboard.setOnCheckedChangeListener(mToggleOverlayHandler);

		mCard.setFocusable(false);

		Log.i(TAG, ""initLayout - Ending"");

	}

	/** 
	 * Creates the menu items
	 */
	@Override
    public boolean onCreateOptionsMenu(Menu menu)
	{
		menu.add(Menu.NONE, MENU_OPEN, MENU_OPEN, getString(R.string.switch_another_deck));
        menu.add(Menu.NONE, MENU_GET_SHARED_DECKS, MENU_GET_SHARED_DECKS, getString(R.string.get_shared_deck));
		menu.add(Menu.NONE, MENU_PREFERENCES, MENU_PREFERENCES, getString(R.string.preferences));
		menu.add(Menu.NONE, MENU_DECKOPTS, MENU_DECKOPTS, getString(R.string.study_options));
        menu.add(Menu.NONE, MENU_EDIT, MENU_EDIT, getString(R.string.edit_card));
		menu.add(Menu.NONE, MENU_SUSPEND, MENU_SUSPEND, getString(R.string.suspend));
		menu.add(Menu.NONE, MENU_ABOUT, MENU_ABOUT, getString(R.string.about));
		return true;
	}

	public boolean onPrepareOptionsMenu(Menu menu)
	{
		Log.i(TAG, ""sdCardAvailable = "" + sdCardAvailable + "", deckLoaded = "" + deckLoaded);
		menu.findItem(MENU_DECKOPTS).setEnabled(sdCardAvailable && deckLoaded);
		menu.findItem(MENU_SUSPEND).setEnabled(currentCard != null);
		menu.findItem(MENU_SUSPEND).setVisible(currentCard != null);
		menu.findItem(MENU_EDIT).setEnabled(currentCard != null);
		menu.findItem(MENU_EDIT).setVisible(currentCard != null);
		return true;
	}
	
	/**
	 * Handles item selections
	 */
	@Override
	public boolean onOptionsItemSelected(MenuItem item)
	{
		switch (item.getItemId())
		{
		case MENU_OPEN:
			openDeckPicker();
			return true;
        case MENU_GET_SHARED_DECKS:
        	Connection.getSharedDecks(getSharedDecksListener, new Connection.Payload(new Object[] {}));
        	return true;
		case MENU_PREFERENCES:
			Intent preferences = new Intent(this, Preferences.class);
			startActivityForResult(preferences, PREFERENCES_UPDATE);
			return true;
		case MENU_DECKOPTS:
		    Intent opts = new Intent(this, DeckPreferences.class);
		    startActivity( opts );
		    return true;
        case MENU_EDIT:
            editorCard = currentCard;
            Intent editCard = new Intent(this, CardEditor.class);
            startActivityForResult(editCard, EDIT_CURRENT_CARD);
            return true;
		case MENU_SUSPEND:
			mFlipCard.setChecked(true);
			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, 
					mAnswerCardHandler,
					new DeckTask.TaskData(0, AnkiDroidApp.getDeck(), currentCard));
		    return true;
		case MENU_ABOUT:
			Intent about = new Intent(this, About.class);
			startActivity(about);
			return true;
		}
		return false;
	}

	public void openDeckPicker()
	{
    	Log.i(TAG, ""openDeckPicker - deckSelected = "" + deckSelected);
    	
    	if(AnkiDroidApp.getDeck() != null && sdCardAvailable)
    		AnkiDroidApp.getDeck().closeDeck();
    	deckLoaded = false;
		Intent decksPicker = new Intent(this, DeckPicker.class);
		inDeckPicker = true;
		startActivityForResult(decksPicker, PICK_DECK_REQUEST);
		Log.i(TAG, ""openDeckPicker - Ending"");
	}

	public void openSharedDeckPicker()
	{
    	if(AnkiDroidApp.getDeck() != null && sdCardAvailable)
    		AnkiDroidApp.getDeck().closeDeck();
    	deckLoaded = false;
		Intent intent = new Intent(AnkiDroid.this, SharedDeckPicker.class);
		startActivityForResult(intent, GET_SHARED_DECK);
	}
	
	@Override
	public void onSaveInstanceState(Bundle outState)
	{
		Log.i(TAG, ""onSaveInstanceState: "" + deckFilename);
		// Remember current deck's filename.
		if (deckFilename != null)
		{
			outState.putString(""deckFilename"", deckFilename);
		}
		Log.i(TAG, ""onSaveInstanceState - Ending"");
	}

	@Override
	public void onStop()
	{
		Log.i(TAG, ""onStop() - "" + System.currentTimeMillis());
		super.onStop();
		if (deckFilename != null)
		{
			savePreferences();
		}
	}

	@Override
	public void onResume()
	{
		Log.i(TAG, ""onResume() - deckFilename = "" + deckFilename + "", deckSelected = "" + deckSelected);
		super.onResume();

		//registerExternalStorageListener();
		
		if (!deckSelected)
		{
			Log.i(TAG, ""onResume() - No deck selected before"");
			displayProgressDialogAndLoadDeck();
		}

		Log.i(TAG, ""onResume() - Ending"");
	}
	
	
	@Override
	protected void onDestroy() {
		Log.i(TAG, ""onDestroy()"");
		super.onDestroy();
    	unregisterReceiver(mUnmountReceiver);
	}

	private void displayProgressDialogAndLoadDeck()
	{
		displayProgressDialogAndLoadDeck(false);
	}

	private void displayProgressDialogAndLoadDeck(boolean updateAllCards)
	{
		Log.i(TAG, ""displayProgressDialogAndLoadDeck - Loading deck "" + deckFilename + "", update all cards = "" + updateAllCards);

		// Don't open database again in onResume() until we know for sure this attempt to load the deck is finished
		deckSelected = true;

		if(isSdCardMounted())
		{
			if (deckFilename != null && new File(deckFilename).exists())
			{
				showControls(false);
				if(updateAllCards)
				{
					DeckTask.launchDeckTask(
							DeckTask.TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS,
							mLoadDeckHandler,
							new DeckTask.TaskData(deckFilename));
				}
				else
				{
					DeckTask.launchDeckTask(
							DeckTask.TASK_TYPE_LOAD_DECK,
							mLoadDeckHandler,
							new DeckTask.TaskData(deckFilename));
				}
			}
			else
			{
				if(deckFilename == null){
					Log.i(TAG, ""displayProgressDialogAndLoadDeck - SD card unmounted."");
				}
				else if(!new File(deckFilename).exists()){
					Log.i(TAG, ""displayProgressDialogAndLoadDeck - The deck "" + deckFilename + ""does not exist."");
				}

				//Show message informing that no deck has been loaded
				displayDeckNotLoaded();
			}
		} else
		{
			Log.i(TAG, ""displayProgressDialogAndLoadDeck - SD card unmounted."");
			deckSelected = false;
        	Log.i(TAG, ""displayProgressDialogAndLoadDeck - deckSelected = "" + deckSelected);
			displaySdError();
		}

	}
	
	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent intent)
	{
		super.onActivityResult(requestCode, resultCode, intent);
		if (requestCode == PICK_DECK_REQUEST)
		{
			//Clean the previous card before showing the first of the new loaded deck (so the transition is not so abrupt)
			updateCard("""");
			hideSdError();
			hideDeckErrors();
			inDeckPicker = false;
			
			if (resultCode != RESULT_OK)
			{
				Log.e(TAG, ""onActivityResult - Deck browser returned with error"");
				//Make sure we open the database again in onResume() if user pressed ""back""
				deckSelected = false;
				return;
			}
			if (intent == null)
			{
				Log.e(TAG, ""onActivityResult - Deck browser returned null intent"");
				//Make sure we open the database again in onResume()
				deckSelected = false;
				return;
			}
			// A deck was picked. Save it in preferences and use it.
			Log.i(TAG, ""onActivityResult = OK"");
			deckFilename = intent.getExtras().getString(OPT_DB);
			savePreferences();

        	Log.i(TAG, ""onActivityResult - deckSelected = "" + deckSelected);
			displayProgressDialogAndLoadDeck();
		} else if (requestCode == PREFERENCES_UPDATE)
		{
			restorePreferences();
			//If there is no deck loaded the controls have not to be shown
			if(deckLoaded && cardsToReview)
			{
				showOrHideControls();
				showOrHideAnswerField();
			}
		} else if (requestCode == EDIT_CURRENT_CARD) {
			if (RESULT_OK == resultCode) {
				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_FACT,
						mUpdateCardHandler, new DeckTask.TaskData(0, AnkiDroidApp
								.getDeck(), currentCard));
            mFlipCard.setChecked(true);
            displayCardQuestion();
			}
		} else if(requestCode == GET_SHARED_DECK)
		{
			//Clean the previous card before showing the first of the new loaded deck (so the transition is not so abrupt)
			updateCard("""");
			hideSdError();
			hideDeckErrors();
			
			if (resultCode != RESULT_OK)
			{
				Log.e(TAG, ""onActivityResult - Deck browser returned with error"");
				//Make sure we open the database again in onResume() if user pressed ""back""
				deckSelected = false;
				return;
			}
			if (intent == null)
			{
				Log.e(TAG, ""onActivityResult - Deck browser returned null intent"");
				//Make sure we open the database again in onResume()
				deckSelected = false;
				return;
			}
			// A deck was picked. Save it in preferences and use it.
			Log.i(TAG, ""onActivityResult = OK"");
			deckFilename = intent.getExtras().getString(OPT_DB);
			savePreferences();

        	Log.i(TAG, ""onActivityResult - deckSelected = "" + deckSelected);
        	// Load deck and update all cards, because if that is not done both the answer and question will be empty
			displayProgressDialogAndLoadDeck(true);
		} else if(requestCode == REPORT_ERROR) {
			Log.i(TAG, ""onActivityResult - reporting done"");
			return;
		}
	}

	@Override
	public void onConfigurationChanged(Configuration newConfig) {
	  super.onConfigurationChanged(newConfig);

	  Log.i(TAG, ""onConfigurationChanged"");

	  LinearLayout sdLayout = (LinearLayout) findViewById(R.id.sd_layout);
	  if(newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE)
		  sdLayout.setPadding(0, 50, 0, 0);
	  else if(newConfig.orientation == Configuration.ORIENTATION_PORTRAIT)
		  sdLayout.setPadding(0, 100, 0, 0);

	  mWhiteboard.rotate();
	}


	private void showControls(boolean show)
	{
		if (show)
		{
			mCard.setVisibility(View.VISIBLE);
			mEase0.setVisibility(View.VISIBLE);
			mEase1.setVisibility(View.VISIBLE);
			mEase2.setVisibility(View.VISIBLE);
			mEase3.setVisibility(View.VISIBLE);
			mFlipCard.setVisibility(View.VISIBLE);
			showOrHideControls();
			showOrHideAnswerField();
			hideDeckErrors();
		} else
		{
			mCard.setVisibility(View.GONE);
			mButtonReviewEarly.setVisibility(View.GONE);
			mButtonSwitchDeck.setVisibility(View.GONE);
			mEase0.setVisibility(View.GONE);
			mEase1.setVisibility(View.GONE);
			mEase2.setVisibility(View.GONE);
			mEase3.setVisibility(View.GONE);
			mFlipCard.setVisibility(View.GONE);
			mCardTimer.setVisibility(View.GONE);
			//mCounts.setVisibility(View.GONE);
			mToggleWhiteboard.setVisibility(View.GONE);
			mWhiteboard.setVisibility(View.GONE);
			mAnswerField.setVisibility(View.GONE);
		}
	}

	/**
	 * Depending on preferences, show or hide the timer and whiteboard.
	 */
	private void showOrHideControls()
	{
		Log.i(TAG, ""showOrHideControls - timerAndWhiteboard: "" + timerAndWhiteboard);
		if (!timerAndWhiteboard)
		{
			mCardTimer.setVisibility(View.GONE);
			//mCounts.setVisibility(View.GONE);
			mToggleWhiteboard.setVisibility(View.GONE);
			mWhiteboard.setVisibility(View.GONE);
		} else
		{
			mCardTimer.setVisibility(View.VISIBLE);
			//mCounts.setVisibility(View.VISIBLE);
			mToggleWhiteboard.setVisibility(View.VISIBLE);
			if (mToggleWhiteboard.isChecked())
			{
				mWhiteboard.setVisibility(View.VISIBLE);
			}
		}
	}

	/**
	 * Depending on preferences, show or hide the answer field.
	 */
	private void showOrHideAnswerField()
	{
		Log.i(TAG, ""showOrHideAnswerField - writeAnswers: "" + writeAnswers);
		if (!writeAnswers)
		{
			mAnswerField.setVisibility(View.GONE);
		} else
		{
			mAnswerField.setVisibility(View.VISIBLE);
		}
	}

	public void setOverlayState(boolean enabled)
	{
		mWhiteboard.setVisibility((enabled) ? View.VISIBLE : View.GONE);
	}

	/**
	 * Set up the display for the current card.
	 */
	private void displayCardQuestion()
	{
		Log.i(TAG, ""displayCardQuestion"");

		if (currentCard == null)
		{
			// Either the deck does not contain any card, or all reviews have been done for the time being
			// TODO a button leading to the deck picker would be nice.
			updateCard(getString(R.string.congratulations_finished_for_now));
			mButtonReviewEarly.setVisibility(View.VISIBLE);
			mButtonSwitchDeck.setVisibility(View.VISIBLE);
			mEase0.setVisibility(View.GONE);
			mEase1.setVisibility(View.GONE);
			mEase2.setVisibility(View.GONE);
			mEase3.setVisibility(View.GONE);
			mFlipCard.setVisibility(View.GONE);
			mCardTimer.setVisibility(View.GONE);
			mToggleWhiteboard.setVisibility(View.GONE);
			mWhiteboard.setVisibility(View.GONE);
			mAnswerField.setVisibility(View.GONE);
			
			cardsToReview = false;
		} else
		{
			Log.i(TAG, ""displayCardQuestion - Hiding Ease buttons..."");

			mEase0.setVisibility(View.GONE);
			mEase1.setVisibility(View.GONE);
			mEase2.setVisibility(View.GONE);
			mEase3.setVisibility(View.GONE);

			// If the user wants to write the answer
			if(writeAnswers)
			{
				mAnswerField.setVisibility(View.VISIBLE);
			}

			mChronoButtonsLayout.setVisibility(View.VISIBLE);
			mFlipCard.setVisibility(View.VISIBLE);
			mFlipCard.requestFocus();

			String displayString = enrichWithQASpan(currentCard.question, false);
			//Depending on preferences do or do not show the question
			if (calculateShowQuestion()) {
				displayString = displayString + ""<hr/>"";
			}
			updateCard(displayString);
			//mCounts.loadDataWithBaseURL("""", AnkiDroidApp.getDeck().reportCounts(), ""text/html"", ""utf-8"", null);
		}
	}
	
	/**
	 * Display the card answer.
	 */
	private void displayCardAnswer()
	{
		Log.i(TAG, ""displayCardAnswer"");

		mCardTimer.stop();
		mWhiteboard.lock();

		mEase0.setVisibility(View.VISIBLE);
		mEase1.setVisibility(View.VISIBLE);
		mEase2.setVisibility(View.VISIBLE);
		mEase3.setVisibility(View.VISIBLE);

		mAnswerField.setVisibility(View.GONE);

		mEase2.requestFocus();
		
		String displayString = """";

		// If the user wrote an answer
		if(writeAnswers)
		{
			if(currentCard != null)
			{
				// Obtain the user answer and the correct answer
				String userAnswer = mAnswerField.getText().toString();
				Matcher spanMatcher = spanPattern.matcher(currentCard.answer);
				String correctAnswer = spanMatcher.replaceAll("""");
				Matcher brMatcher = brPattern.matcher(correctAnswer);
				correctAnswer = brMatcher.replaceAll(""\n"");

				// Obtain the diff and send it to updateCard
				DiffEngine diff = new DiffEngine();
				
				displayString = enrichWithQASpan(diff.diff_prettyHtml(
						diff.diff_main(userAnswer, correctAnswer)) +
						""<br/>"" + currentCard.answer, true);
			}
			else
			{
				displayString = """";
			}
		}
		else
		{
			displayString = enrichWithQASpan(currentCard.answer, true);
		}
		//Depending on preferences do or do not show the question
		if (calculateShowQuestion()) {
				StringBuffer sb = new StringBuffer();
				sb.append(enrichWithQASpan(currentCard.question, false));
				sb.append(""<hr/>"");
			sb.append(displayString);
			displayString = sb.toString();
			mFlipCard.setVisibility(View.INVISIBLE);
			if(!timerAndWhiteboard)
			{
				mChronoButtonsLayout.setVisibility(View.GONE);
			}
			
		}
		updateCard(displayString);
		}
	
	private final boolean calculateShowQuestion() {
		if (HQIA_DO_SHOW == hideQuestionInAnswer) {
			return true;
		}
		if (HQIA_CARD_MODEL == hideQuestionInAnswer && 0 == Model.getModel(currentCard.cardModelId, false).getCardModel(currentCard.cardModelId).questionInAnswer) {
			return true;
		}
		return false;
	}
	
	/**
	 * Updates the main screen for learning with the actual contents (question/answer or something else).
	 * the contents is enriched based on preferences with Ruby and font size.
	 * @param content
	 */
	private void updateCard(String content)
	{
		Log.i(TAG, ""updateCard"");

		content = Sound.extractSounds(deckFilename, content);
		content = Image.loadImages(deckFilename, content);
		
		// In order to display the bold style correctly, we have to change font-weight to 700
		content = content.replaceAll(""font-weight:600;"", ""font-weight:700;"");

		// If ruby annotation support is activated, then parse and add markup
		if (useRubySupport) {
			content = RubyParser.ankiRubyToMarkup(content);
		}
		
		// Add CSS for font colour and font size
		if (null != currentCard) {
			Model myModel = Model.getModel(currentCard.cardModelId, false);
			content = myModel.getCSSForFontColorSize(currentCard.cardModelId, displayFontSize) + content;
		} else { 
			mCard.getSettings().setDefaultFontSize(calculateDynamicFontSize(content));
		}

		Log.i(TAG, ""content card = \n"" + content);
		String card = cardTemplate.replace(""::content::"", content);
		mCard.loadDataWithBaseURL("""", card, ""text/html"", ""utf-8"", null);
		Sound.playSounds();
	}
	
	/** Constant for class attribute signaling answer */
	protected final static String ANSWER_CLASS = ""answer"";
	
	/** Constant for class attribute signaling question */
	protected final static String QUESTION_CLASS = ""question"";
	
	/**
	 * Adds a span html tag around the contents to have an indication, where answer/question is displayed
	 * @param content
	 * @param isAnswer if true then the class attribute is set to ""answer"", ""question"" otherwise.
	 * @return
	 */
	private final static String enrichWithQASpan(String content, boolean isAnswer) {
		StringBuffer sb = new StringBuffer();
		sb.append(""<p class=\"""");
		if (isAnswer) {
			sb.append(ANSWER_CLASS);
		} else {
			sb.append(QUESTION_CLASS);
		}
		sb.append(""\"">"");
		sb.append(content);
		sb.append(""</p>"");
		return sb.toString();
	}

	/**
	* Calculates a dynamic font size depending on the length of the contents
	* taking into account that the input string contains html-tags, which will not
	* be displayed and therefore should not be taken into account.
	* @param htmlContents
	* @return font size respecting MIN_DYNAMIC_FONT_SIZE and MAX_DYNAMIC_FONT_SIZE
	*/
	protected final static int calculateDynamicFontSize(String htmlContent) {
		// Replace each <br> with 15 spaces, each <hr> with 30 spaces, then remove all html tags and spaces
		String realContent = htmlContent.replaceAll(""\\<br.*?\\>"", "" "");
		realContent = realContent.replaceAll(""\\<hr.*?\\>"", "" "");
		realContent = realContent.replaceAll(""\\<.*?\\>"", """");
		realContent = realContent.replaceAll(""&nbsp;"", "" "");
		return Math.max(MIN_DYNAMIC_FONT_SIZE, MAX_DYNAMIC_FONT_SIZE - (int)(realContent.length()/5));
	}


	/**
	 * Utility method to write to a file.
	 */
	private boolean writeToFile(InputStream source, String destination) throws IOException
	{
		try
		{
			new File(destination).createNewFile();
		} catch (IOException e)
		{
			// Most probably the SD card is not mounted on the Android.
			// Tell the user to turn off USB storage, which will automatically
			// mount it on Android.
			return false;
		}
		OutputStream output = new FileOutputStream(destination);

		// Transfer bytes, from source to destination.
		byte[] buf = new byte[1024];
		int len;
		while ((len = source.read(buf)) > 0)
		{
			output.write(buf, 0, len);
		}
		source.close();
		output.close();
		return true;
	}

	private SharedPreferences restorePreferences() {
		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
		corporalPunishments = preferences.getBoolean(""corporalPunishments"", false);
		timerAndWhiteboard = preferences.getBoolean(""timerAndWhiteboard"", true);
		Log.i(TAG, ""restorePreferences - timerAndWhiteboard: "" + timerAndWhiteboard);
		writeAnswers = preferences.getBoolean(""writeAnswers"", false);
		useRubySupport = preferences.getBoolean(""useRubySupport"", false);
		displayFontSize = Integer.parseInt(preferences.getString(""displayFontSize"", ""100""));
		hideQuestionInAnswer = Integer.parseInt(preferences.getString(""hideQuestionInAnswer"", Integer.toString(HQIA_DO_SHOW)));
		updateNotifications = preferences.getBoolean(""enabled"", true);
		
		//redraw screen with new preferences
		if (null != mFlipCard) {
			if (mFlipCard.isChecked()) {
				displayCardAnswer();
			} else {
				displayCardQuestion();
			}
		}

		return preferences;
	}

	private void savePreferences()
	{
		SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
		Editor editor = preferences.edit();
		editor.putString(""deckFilename"", deckFilename);
		editor.commit();
	}

	private boolean isSdCardMounted() {
		return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
	}

    /**
     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications.
     * The intent will call closeExternalStorageFiles() if the external media
     * is going to be ejected, so applications can clean up any files they have open.
     */
    public void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String action = intent.getAction();
                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
                    	Log.i(TAG, ""mUnmountReceiver - Action = Media Eject"");
                    	sdCardAvailable = false;
                    	closeExternalStorageFiles();
                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                    	Log.i(TAG, ""mUnmountReceiver - Action = Media Mounted"");
                    	hideSdError();
                    	deckSelected = false;
                    	sdCardAvailable = true;
                    	Log.i(TAG, ""mUnmountReceiver - deckSelected = "" + deckSelected);
                    	if(!inDeckPicker)
                    		onResume();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
            iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
            iFilter.addDataScheme(""file"");
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }

    private void closeExternalStorageFiles()
    {
    	if(AnkiDroidApp.getDeck() != null)
    		AnkiDroidApp.getDeck().closeDeck();
    	deckLoaded = false;
    	displaySdError();
    }

    private void displaySdError()
    {
    	showControls(false);
    	hideDeckErrors();
    	showSdCardElements(true);
    }

    private void hideSdError()
    {
    	showSdCardElements(false);
    }

    private void showSdCardElements(boolean show)
    {
    	Log.i(TAG, ""showSdCardElements"");

    	LinearLayout layout = (LinearLayout) findViewById(R.id.sd_layout);
    	TextView tv = (TextView) findViewById(R.id.sd_message);
    	ImageView image = (ImageView) findViewById(R.id.sd_icon);
    	if(show)
    	{
    		layout.setVisibility(View.VISIBLE);
    		tv.setVisibility(View.VISIBLE);
    		image.setVisibility(View.VISIBLE);
    	} else
    	{
    		layout.setVisibility(View.GONE);
    		tv.setVisibility(View.GONE);
    		image.setVisibility(View.GONE);
    	}
    }

    private void displayDeckNotLoaded()
    {
    	Log.i(TAG, ""displayDeckNotLoaded"");

    	LinearLayout layout = (LinearLayout) findViewById(R.id.deck_error_layout);
    	TextView message = (TextView) findViewById(R.id.deck_message);
    	TextView detail = (TextView) findViewById(R.id.deck_message_detail);

		message.setText(R.string.deck_not_loaded);
		detail.setText(R.string.deck_not_loaded_detail);
		layout.setVisibility(View.VISIBLE);
		message.setVisibility(View.VISIBLE);
		detail.setVisibility(View.VISIBLE);
    }

    private void hideDeckErrors()
    {
    	Log.i(TAG, ""hideDeckErrors"");

    	LinearLayout layout = (LinearLayout) findViewById(R.id.deck_error_layout);
    	TextView message = (TextView) findViewById(R.id.deck_message);
    	TextView detail = (TextView) findViewById(R.id.deck_message_detail);

		layout.setVisibility(View.GONE);
		message.setVisibility(View.GONE);
		detail.setVisibility(View.GONE);
    }

	private void displayNoCardsInDeck()
	{
    	Log.i(TAG, ""displayNoCardsInDeck"");

    	LinearLayout layout = (LinearLayout) findViewById(R.id.deck_error_layout);
    	TextView message = (TextView) findViewById(R.id.deck_message);
    	TextView detail = (TextView) findViewById(R.id.deck_message_detail);

		message.setText(R.string.deck_empty);
		layout.setVisibility(View.VISIBLE);
		message.setVisibility(View.VISIBLE);
		detail.setVisibility(View.GONE);
	}
	  
	/**
	 * Listeners
	 */
    DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener()
    {
        public void onPreExecute() {
            progressDialog = ProgressDialog.show(AnkiDroid.this, """", getString(R.string.saving_changes), true);
        }

        public void onPostExecute(DeckTask.TaskData result) {

            // Set the correct value for the flip card button - That triggers the
            // listener which displays the question of the card
            mFlipCard.setChecked(false);
            mWhiteboard.clear();
            mCardTimer.setBase(SystemClock.elapsedRealtime());
            mCardTimer.start();

            progressDialog.dismiss();
        }

        public void onProgressUpdate(DeckTask.TaskData... values) 
        {
            currentCard = values[0].getCard();
        }
    };


	DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener()
	{
	    boolean sessioncomplete = false;
	    long start;

		public void onPreExecute() {
			start = System.currentTimeMillis();
			progressDialog = ProgressDialog.show(AnkiDroid.this, """", getString(R.string.loading_new_card), true);
		}

		public void onPostExecute(DeckTask.TaskData result) {
		    // TODO show summary screen?
			if( sessioncomplete )
			    openDeckPicker();
		}

		public void onProgressUpdate(DeckTask.TaskData... values) {
		    mSessionCurrReps++; // increment number reps counter

		    // Check to see if session rep or time limit has been reached
		    Deck deck = AnkiDroidApp.getDeck();
		    long sessionRepLimit = deck.getSessionRepLimit();
		    long sessionTime = deck.getSessionTimeLimit();
		    Toast sessionMessage = null;

		    if( (sessionRepLimit > 0) && (mSessionCurrReps >= sessionRepLimit) )
		    {
		    	sessioncomplete = true;
		    	sessionMessage = Toast.makeText(AnkiDroid.this, getString(R.string.session_question_limit_reached), Toast.LENGTH_SHORT);
		    } else if( (sessionTime > 0) && (System.currentTimeMillis() >= mSessionTimeLimit) ) //Check to see if the session time limit has been reached
		    {
		        // session time limit reached, flag for halt once async task has completed.
		        sessioncomplete = true;
		        sessionMessage = Toast.makeText(AnkiDroid.this, getString(R.string.session_time_limit_reached), Toast.LENGTH_SHORT);

		    } else {
		        // session limits not reached, show next card
		    	sessioncomplete = false;
		        Card newCard = values[0].getCard();

		        currentCard = newCard;

		        // Set the correct value for the flip card button - That triggers the
		        // listener which displays the question of the card
		        mFlipCard.setChecked(false);
		        mWhiteboard.clear();
		        mCardTimer.setBase(SystemClock.elapsedRealtime());
		        mCardTimer.start();
		    }

		    progressDialog.dismiss();

			// Show a message to user if a session limit has been reached.
			if (sessionMessage != null)
				sessionMessage.show();
			
			Log.w(TAG, ""onProgressUpdate - New card received in "" + (System.currentTimeMillis() - start) + "" ms."");
		}

	};

	DeckTask.TaskListener mLoadDeckHandler = new DeckTask.TaskListener()
	{

		public void onPreExecute() {
			if(updateAlert == null || !updateAlert.isShowing())
			{
				progressDialog = ProgressDialog.show(AnkiDroid.this, """", getString(R.string.loading_deck), true);
			}
		}

		public void onPostExecute(DeckTask.TaskData result) {
			// This verification would not be necessary if onConfigurationChanged it's executed correctly (which seems that emulator does not do)
			if(progressDialog.isShowing())
			{
				try
				{
					progressDialog.dismiss();
				} catch(Exception e)
				{
					Log.e(TAG, ""handleMessage - Dialog dismiss Exception = "" + e.getMessage());
				}
			}

			switch(result.getInt())
			{
				case DECK_LOADED:
					// Set the deck in the application instance, so other activities
					// can access the loaded deck.
					AnkiDroidApp.setDeck( result.getDeck() );
					currentCard = result.getCard();
					showControls(true);
					deckLoaded = true;
					cardsToReview = true;
					mFlipCard.setChecked(false);
					displayCardQuestion();

					mWhiteboard.clear();
					mCardTimer.setBase(SystemClock.elapsedRealtime());
					mCardTimer.start();
					long timelimit = AnkiDroidApp.getDeck().getSessionTimeLimit() * 1000;
					Log.i(TAG, ""SessionTimeLimit: "" + timelimit + "" ms."");
					mSessionTimeLimit = System.currentTimeMillis() + timelimit;
					mSessionCurrReps = 0;
					break;

				case DECK_NOT_LOADED:
					displayDeckNotLoaded();
					break;

				case DECK_EMPTY:
					displayNoCardsInDeck();
					break;
			}
		}

		public void onProgressUpdate(DeckTask.TaskData... values) {
			// Pass
		}

	};

	Connection.TaskListener getSharedDecksListener = new Connection.TaskListener() {

//		@Override
		public void onDisconnected() {
			noConnectionAlert.show();
		}

//		@Override
		public void onPostExecute(Payload data) {
			progressDialog.dismiss();
			if(data.success)
			{
				openSharedDeckPicker();
			}
			else
			{
				connectionFailedAlert.show();
			}
		}

//		@Override
		public void onPreExecute() {
			progressDialog = ProgressDialog.show(AnkiDroid.this, """", getResources().getString(R.string.loading_shared_decks));
		}

//		@Override
		public void onProgressUpdate(Object... values) {
			//Pass
		}
		
	};

}
",True,10,29,1,3,3,13
26,com.ichi2.anki.Deck.java,"/****************************************************************************************
* Copyright (c) 2009 Daniel Sv√§rd <daniel.svard@gmail.com>                             *
* Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.anki;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Set;
import java.util.Stack;
import java.util.Map.Entry;

import android.content.ContentValues;
import android.database.Cursor;
import android.database.SQLException;
import android.util.Log;

/**
 * A deck stores all of the cards and scheduling information.
 * It is saved in a file with a name ending in .anki
 * 
 * @see http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Deck
 */
public class Deck
{

	/**
	 * Tag for logging messages
	 */
	private static String TAG = ""AnkiDroid"";

	/** Priorities
	 * Auto priorities
	 *   - High = 4
	 *   - Medium = 3
	 *   - Normal = 2
	 *   - Low = 1
	 *   - None = 0
	 * Manual priorities
	 *   - Review early = -1
	 *   - Buried = -2
	 *   - Suspended = -3
	**/

	// Rest
	private static final int MATURE_THRESHOLD = 21;

	private static final int NEW_CARDS_DISTRIBUTE = 0;

	private static final int NEW_CARDS_LAST = 1;

	private static final int NEW_CARDS_FIRST = 2;

	private static final int NEW_CARDS_RANDOM = 0;

	private static final int NEW_CARDS_OLD_FIRST = 1;

	private static final int NEW_CARDS_NEW_FIRST = 2;

	private static final int REV_CARDS_OLD_FIRST = 0;

	private static final int REV_CARDS_NEW_FIRST = 1;

	private static final int REV_CARDS_DUE_FIRST = 2;

	private static final int REV_CARDS_RANDOM = 3;

	private static final double factorFour = 1.3;
	private static final double initialFactor = 2.5;
	private static final double minimumAverage = 1.7;
	private static final double maxScheduleTime = 36500.0;

	//Used to format doubles with English's decimal separator system 
	private static final Locale ENGLISH_LOCALE = new Locale(""en_US"");
	
	// BEGIN: SQL table columns
	long id;

	double created;

	double modified;

	String description;

	int version;

	long currentModelId;

	String syncName;

	double lastSync;

	// Scheduling
	// Initial intervals
	double hardIntervalMin;

	double hardIntervalMax;

	double midIntervalMin;

	double midIntervalMax;

	double easyIntervalMin;

	double easyIntervalMax;

	// Delays on failure
	double delay0;

	double delay1;

	double delay2;

	// Collapsing future cards
	double collapseTime;

	// Priorities and postponing
	String highPriority;

	String medPriority;

	String lowPriority;

	String suspended;

	// 0 is random, 1 is by input date
	private int newCardOrder;

	// When to show new cards
	private int newCardSpacing;

	// Limit the number of failed cards in play
	int failedCardMax;

	// Number of new cards to show per day
	private int newCardsPerDay;

	// Currently unused
	private long sessionRepLimit;

	private long sessionTimeLimit;

	// Stats offset
	double utcOffset;

	// Count cache
	int cardCount;

	int factCount;

	int failedNowCount;

	int failedSoonCount;

	int revCount;

	int newCount;

	// Review order
	private int revCardOrder;

	// END: SQL table columns

	// BEGIN JOINed variables
	//Model currentModel; // Deck.currentModelId = Model.id
	//ArrayList<Model> models; // Deck.id = Model.deckId
	// END JOINed variables

	double averageFactor;

	int newCardModulus;

	int newCountToday;

	double lastLoaded;

	boolean newEarly;

	boolean reviewEarly;

	private Stats globalStats;

	private Stats dailyStats;
	
	private Card currentCard;
	
	private String deckPath;
	
	public String getDeckPath() {
		return deckPath;
	}
	
	public void setDeckPath(String path) {
		deckPath = path;
	}

	/**
	 * Undo/Redo variables.
	 */
	Stack<UndoRow> undoStack;
	
	Stack<UndoRow> redoStack;
	
	boolean undoEnabled = false;
	
	private void initVars()
	{
		// tmpMediaDir = null;
		// forceMediaDir = null;
		// lastTags = """";
		lastLoaded = (double) System.currentTimeMillis() / 1000.0;
//		undoEnabled = false;
//		sessionStartReps = 0;
//		sessionStartTime = 0;
//		lastSessionStart = 0;
		newEarly = false;
		reviewEarly = false;
	}

	public static Deck openDeck(String path) throws SQLException
	{
		Deck deck = null;
		Cursor cursor = null;
		Log.i(TAG, ""openDeck - Opening database "" + path);
		AnkiDb.openDatabase(path);

		try {
			// Read in deck table columns
			cursor = AnkiDb.database.rawQuery(""SELECT *"" + "" FROM decks"" + "" LIMIT 1"", null);
	
			if (!cursor.moveToFirst())
				return null;
			
			deck = new Deck();
			deck.setDeckPath(path);
			
			deck.id 			 = cursor.getLong(0);
			deck.created		 = cursor.getDouble(1);
			deck.modified 		 = cursor.getDouble(2);
			deck.description	 = cursor.getString(3);
			deck.version		 = cursor.getInt(4);
			deck.currentModelId	 = cursor.getLong(5);
			deck.syncName		 = cursor.getString(6);
			deck.lastSync		 = cursor.getDouble(7);
			deck.hardIntervalMin = cursor.getDouble(8);
			deck.hardIntervalMax = cursor.getDouble(9);
			deck.midIntervalMin  = cursor.getDouble(10);
			deck.midIntervalMax  = cursor.getDouble(11);
			deck.easyIntervalMin = cursor.getDouble(12);
			deck.easyIntervalMax = cursor.getDouble(13);
			deck.delay0 		 = cursor.getDouble(14);
			deck.delay1 		 = cursor.getDouble(15);
			deck.delay2 		 = cursor.getDouble(16);
			deck.collapseTime 	 = cursor.getDouble(17);
			deck.highPriority 	 = cursor.getString(18);
			deck.medPriority 	 = cursor.getString(19);
			deck.lowPriority 	 = cursor.getString(20);
			deck.suspended 	 	 = cursor.getString(21);
			deck.newCardOrder 	 = cursor.getInt(22);
			deck.newCardSpacing  = cursor.getInt(23);
			deck.failedCardMax 	 = cursor.getInt(24);
			deck.newCardsPerDay  = cursor.getInt(25);
			deck.sessionRepLimit = cursor.getInt(26);
			deck.sessionTimeLimit= cursor.getInt(27);
			deck.utcOffset		 = cursor.getDouble(28);
			deck.cardCount 		 = cursor.getInt(29);
			deck.factCount 		 = cursor.getInt(30);
			deck.failedNowCount  = cursor.getInt(31);
			deck.failedSoonCount = cursor.getInt(32);
			deck.revCount 		 = cursor.getInt(33);
			deck.newCount 		 = cursor.getInt(34);
			deck.revCardOrder 	 = cursor.getInt(35);
	
			Log.i(TAG, ""openDeck - Read "" + cursor.getColumnCount() + "" columns from decks table."");
		} finally {
			if (cursor != null) cursor.close();
		}
		Log.i(TAG, String.format(ENGLISH_LOCALE, ""openDeck - modified: %f currentTime: %f"", deck.modified, System.currentTimeMillis()/1000.0));

		deck.initVars();

		// Ensure necessary indices are available
		deck.updateDynamicIndices();
		// Save counts to determine if we should save deck after check
		int oldCount = deck.failedSoonCount + deck.revCount + deck.newCount;
		// Update counts
		deck.rebuildQueue();
		
		try {
			// Unsuspend reviewed early & buried
			cursor = AnkiDb.database.rawQuery(
					""SELECT id "" +
					""FROM cards "" +
					""WHERE type in (0,1,2) and "" +
					""isDue = 0 and "" +
					""priority in (-1,-2)"",
					null);
	
			if (cursor.moveToFirst())
			{
				int count = cursor.getCount();
				long[] ids = new long[count];
				for (int i = 0; i < count; i++) {
					ids[i] = cursor.getLong(0);
					cursor.moveToNext();
				}
				deck.updatePriorities(ids);
				deck.checkDue();
			}
		} finally {
			if (cursor != null) cursor.close();
		}

		// Save deck to database if it has been modified
		if ((oldCount != (deck.failedSoonCount + deck.revCount + deck.newCount)) || deck.modifiedSinceSave())
			deck.commitToDB();
		
		// Create a temporary view for random new cards. Randomizing the cards by themselves
		// as is done in desktop Anki in Deck.randomizeNewCards() takes too long.
		AnkiDb.database.execSQL(""CREATE TEMPORARY VIEW acqCardsRandom AS "" +
				""SELECT * FROM cards "" +
				""WHERE type = 2 AND isDue = 1 "" +
				""ORDER BY RANDOM()"");

		return deck;
	}

	public void closeDeck()
	{
		DeckTask.waitToFinish(); // Wait for any thread working on the deck to finish.
		if (modifiedSinceSave())
			commitToDB();
		AnkiDb.closeDatabase();
	}

	private boolean modifiedSinceSave()
	{
		return modified > lastLoaded;
	}

	private void setModified() {
		modified = System.currentTimeMillis() / 1000.0;
	}

	private void flushMod() {
		setModified();
		commitToDB();
	}

	private void commitToDB() {
		Log.i(TAG, ""commitToDB - Saving deck to DB..."");
		ContentValues values = new ContentValues();
		values.put(""created"", created);
		values.put(""modified"", modified);
		values.put(""description"", description);
		values.put(""version"", version);
		values.put(""currentModelId"", currentModelId);
		values.put(""syncName"", syncName);
		values.put(""lastSync"", lastSync);
		values.put(""hardIntervalMin"", hardIntervalMin);
		values.put(""hardIntervalMax"", hardIntervalMax);
		values.put(""midIntervalMin"", midIntervalMin);
		values.put(""midIntervalMax"", midIntervalMax);
		values.put(""easyIntervalMin"", easyIntervalMin);
		values.put(""easyIntervalMax"", easyIntervalMax);
		values.put(""delay0"", delay0);
		values.put(""delay1"", delay1);
		values.put(""delay2"", delay2);
		values.put(""collapseTime"", collapseTime);
		values.put(""highPriority"", highPriority);
		values.put(""medPriority"", medPriority);
		values.put(""lowPriority"", lowPriority);
		values.put(""suspended"", suspended);
		values.put(""newCardOrder"", newCardOrder);
		values.put(""newCardSpacing"", newCardSpacing);
		values.put(""failedCardMax"", failedCardMax);
		values.put(""newCardsPerDay"", newCardsPerDay);
		values.put(""sessionRepLimit"", sessionRepLimit);
		values.put(""sessionTimeLimit"", sessionTimeLimit);
		values.put(""utcOffset"", utcOffset);
		values.put(""cardCount"", cardCount);
		values.put(""factCount"", factCount);
		values.put(""failedNowCount"", failedNowCount);
		values.put(""failedSoonCount"", failedSoonCount);
		values.put(""revCount"", revCount);
		values.put(""newCount"", newCount);
		values.put(""revCardOrder"", revCardOrder);

		AnkiDb.database.update(""decks"", values, ""id = "" + this.id, null);
	}

	public static double getLastModified(String deckPath)
	{
		double value;
		Cursor cursor = null;
		//Log.i(TAG, ""Deck - getLastModified from deck = "" + deckPath);
		AnkiDb.openDatabase(deckPath);
		
		try {
			cursor = AnkiDb.database.rawQuery(""SELECT modified"" + "" FROM decks"" + "" LIMIT 1"", null);
	
			if (!cursor.moveToFirst())
				value = -1;
			else
				value = cursor.getDouble(0);
		} finally {
			if (cursor != null) cursor.close();
		}
		
		AnkiDb.closeDatabase();
		return value;
	}

	/* Getters and Setters for deck properties
	 * NOTE: The setters flushMod()
	 ***********************************************************/

	public int getRevCardOrder()
	{
	    return revCardOrder;
	}
	public void setRevCardOrder( int num )
	{
	    if( num >= 0 )
	    {
	        revCardOrder = num;
	        flushMod();
	    }
	}

	public int getNewCardSpacing()
	{
	    return newCardSpacing;
	}
	public void setNewCardSpacing( int num )
	{
	    if( num >= 0 )
	    {
	        newCardSpacing = num;
	        flushMod();
	    }
	}

	public int getNewCardOrder()
	{
	    return newCardOrder;
	}
	public void setNewCardOrder( int num )
	{
	    if( num >= 0 )
	    {
	        newCardOrder = num;
	        flushMod();
	    }
	}

	public int getNewCardsPerDay()
	{
	    return newCardsPerDay;
	}

	public void setNewCardsPerDay( int num )
	{
	    if( num >= 0 )
	    {
	        newCardsPerDay = num;
	        flushMod();
	    }
	}

	public long getSessionRepLimit()
	{
	    return sessionRepLimit;
	}
	public void setSessionRepLimit( long num )
    {
        if( num >= 0 )
        {
            sessionRepLimit = num;
            flushMod();
        }
    }

	public long getSessionTimeLimit()
	{
	    return sessionTimeLimit;
	}

	public void setSessionTimeLimit( long num )
    {
        if( num >= 0 ) {
            sessionTimeLimit = num;
            flushMod();
        }
    }

	/* Getting the next card
	 ***********************************************************/


	/**
	 * Return the next card object.
	 * @return The next due card or null if nothing is due.
	 */
	public Card getCard() {
		checkDue();
		long id = getCardId();
		currentCard = cardFromId(id);
		return currentCard;
	}
	
	
	// Refreshes the current card and returns it (used when editing cards)
	// TODO find a less lame way to do this.
	public Card getCurrentCard()
	{
	    return cardFromId(currentCard.id);
	}

	private long getCardId() {
		long id;
		// Failed card due?
		if ((delay0 != 0) && (failedNowCount != 0))
			return AnkiDb.queryScalar(""SELECT id FROM failedCards LIMIT 1"");
		// Failed card queue too big?
		if ((failedCardMax != 0) && (failedSoonCount >= failedCardMax))
			return AnkiDb.queryScalar(""SELECT id FROM failedCards LIMIT 1"");
		// Distribute new cards?
		if (timeForNewCard()) {
			id = maybeGetNewCard();
			if (id != 0)
				return id;
		}
		// Card due for review?
		if (revCount != 0)
			return getRevCard();
		// New cards left?
		id = maybeGetNewCard();
		if (id != 0)
			return id;
		// Review ahead?
		if (reviewEarly) {
			id = getCardIdAhead();
			if (id != 0)
				return id;
			else {
				resetAfterReviewEarly();
				checkDue();
			}
		}
		// Display failed cards early/last
		if (showFailedLast()) {
			try {
			id = AnkiDb.queryScalar(""SELECT id FROM failedCards LIMIT 1"");
			} catch (Exception e) {
				return 0;
			}
			return id;
		}
		return 0;
	}

	private long getCardIdAhead() {
		long id=0;
		try {
		id = AnkiDb.queryScalar(
				""SELECT id "" +
				""FROM cards "" +
				""WHERE type = 1 and "" +
				""isDue = 0 and "" +
				""priority in (1,2,3,4) "" +
				""ORDER BY combinedDue "" +
				""LIMIT 1"");
		} catch (SQLException e) {
			return 0;
		}
		return id;
	}

	/* Get card: helper functions
	 ***********************************************************/

	private boolean timeForNewCard() {
		if (newCardSpacing == NEW_CARDS_LAST)
			return false;
		if (newCardSpacing == NEW_CARDS_FIRST)
			return true;
		// Force old if there are very high priority cards
		try {
			AnkiDb.queryScalar(
					""SELECT 1 "" +
					""FROM cards "" +
					""WHERE type = 1 and "" +
					""isDue = 1 and "" +
					""priority = 4 "" +
					""LIMIT 1"");
		} catch (Exception e) { // No result from query.
			if (newCardModulus == 0)
				return false;
			else
				return (dailyStats.reps % newCardModulus) == 0;
		}
		return false;
	}

	private long maybeGetNewCard() {
		if ((newCountToday == 0) && (!newEarly))
			return 0;
		return getNewCard();
	}

	private String newCardTable() {
		return (new String[]{
				""acqCardsRandom "",
				""acqCardsOld "",
				""acqCardsNew ""})[newCardOrder];
	}

	private String revCardTable() {
		return (new String[]{
				""revCardsOld "",
				""revCardsNew "",
				""revCardsDue "",
				""revCardsRandom ""})[revCardOrder];
	}

	private long getNewCard() {
		long id;
		try {
			id = AnkiDb.queryScalar(
					""SELECT id "" +
					""FROM "" +
					newCardTable() +
					""LIMIT 1"");
		} catch (Exception e) {
			return 0;
		}
		return id;
	}

	private long getRevCard() {
		long id;
		try {
			id = AnkiDb.queryScalar(
					""SELECT id "" +
					""FROM "" +
					revCardTable() +
					""LIMIT 1"");
		} catch (Exception e) {
			return 0;
		}
		return id;
	}

	private boolean showFailedLast() {
		return (collapseTime != 0) || (delay0 == 0);
	}

	private Card cardFromId(long id) {
		if (id == 0)
			return null;
		Card card = new Card();
		boolean result = card.fromDB(id);

		if (!result)
			return null;
		card.genFuzz();
		card.startTimer();
		return card;
	}

	
	/**
	 * Saves an updated card to the database.
	 * @param card The modified version of a card from this deck to be saved.
	 */
	public void updateCard(Card card) 
	{
	    double now = System.currentTimeMillis() / 1000.0;
	    ContentValues updateValues = new ContentValues();
	    updateValues.put(""question"", card.question);
	    updateValues.put(""answer"", card.answer);
	    updateValues.put(""modified"", now);
	    AnkiDb.database.update(""cards"", updateValues, ""id = ?"", new String[] {"""" + card.id});
//        AnkiDb.database.execSQL(String.format(NULL_LOCALE, 
//                ""UPDATE cards "" +
//                ""SET question = %s, "" +
//                ""answer = %s, "" +
//                ""modified = %f, "" +
//                ""WHERE id != %d and factId = %d"",
//                card.question, card.answer, now, card.id, card.factId));
//        
        Log.v(TAG, ""Update question and answer in card id# "" + card.id);
        
	}
	
	// TODO: The real methods to update cards on Anki should be implemented instead of this
	public void updateAllCards()
	{
        Cursor cursor = AnkiDb.database.rawQuery(
                ""SELECT id, factId "" +
                ""FROM cards"", 
                null);

        while (cursor.moveToNext())
        {
        	// Get card
            Card card = new Card();
            card.fromDB(cursor.getLong(0));
            Log.i(TAG, ""Card id = "" + card.id);
            
            // Get the related fact
            Fact fact = card.getFact();
            //Log.i(TAG, ""Fact id = "" + fact.id);
            
            // Generate the question and answer for this card and update it
            HashMap<String,String> newQA = CardModel.formatQA(fact, card.getCardModel());
            card.question = newQA.get(""question"");
            Log.i(TAG, ""Question = "" + card.question);
            card.answer = newQA.get(""answer"");
            Log.i(TAG, ""Answer = "" + card.answer);
            card.modified = System.currentTimeMillis() / 1000.0;
            
            card.toDB();
        }
	}
	
	/* Answering a card
	 ***********************************************************/

	public void answerCard(Card card, int ease)
	{
		Cursor cursor = null;
		String undoName = ""Answer Card"";
		setUndoStart(undoName);
		double now = System.currentTimeMillis() / 1000.0;

		// Old state
		String oldState = cardState(card);
		double lastDelaySecs = System.currentTimeMillis() / 1000.0 - card.combinedDue;
        double lastDelay = lastDelaySecs / 86400.0;
        int oldSuc = card.successive;

        // update card details
        double last = card.interval;
        card.interval = nextInterval(card, ease);
        if (lastDelay >= 0)
            card.lastInterval = last; // keep last interval if reviewing early
        if (card.reps != 0)
            card.lastDue = card.due; // only update if card was not new
        card.due = nextDue(card, ease, oldState);
        card.isDue = 0;
        card.lastFactor = card.factor;
        if (lastDelay >= 0)
            updateFactor(card, ease); // don't update factor if learning ahead

        // spacing
        double space, spaceFactor, minSpacing, minOfOtherCards;
        try {
	        cursor = AnkiDb.database.rawQuery(
	        		""SELECT models.initialSpacing, models.spacing "" +
	        		""FROM facts, models "" +
	        		""WHERE facts.modelId = models.id and "" +
	        		""facts.id = "" +
	        		card.factId,
	        		null);
	        if (!cursor.moveToFirst())
	        {
	        	minSpacing = 0;
	        	spaceFactor = 0;
	        }
	        else
	        {
		        minSpacing = cursor.getDouble(0);
		        spaceFactor = cursor.getDouble(1);
	        }
        } finally {
        	if (cursor != null) cursor.close();
        }

        try {
	        cursor = AnkiDb.database.rawQuery(
	        		""SELECT min(interval) "" +
	        		""FROM cards "" +
	        		""WHERE factId = "" +
	        		card.factId +
	        		"" and id != "" +
	        		card.id,
	        		null);
			if (!cursor.moveToFirst())
				minOfOtherCards = 0;
			else
				minOfOtherCards = cursor.getDouble(0);
        } finally {
        	if (cursor != null) cursor.close();
        }
        if (minOfOtherCards != 0)
            space = Math.min(minOfOtherCards, card.interval);
        else
            space = 0;
        space = space * spaceFactor * 86400.0;
        space = Math.max(minSpacing, space);
        space += System.currentTimeMillis() / 1000.0;
        card.combinedDue = Math.max(card.due, space);

        // check what other cards we've spaced
        String extra;
        if (this.reviewEarly)
            extra = """";
        else
        {
            // if not reviewing early, make sure the current card is counted
            // even if it was not due yet (it's a failed card)
            extra = ""or id = "" + card.id;
        }

        try {
	        cursor = AnkiDb.database.rawQuery(
	        		""SELECT type, count(type) "" +
	        		""FROM cards "" +
	        		""WHERE factId = "" +
	        		card.factId + "" and "" +
	        		""(isDue = 1 "" + extra + "") "" +
	        		""GROUP BY type"", null);
	    	while (cursor.moveToNext())
	    	{
	    		if (cursor.getInt(0) == 0)
	    			failedSoonCount -= cursor.getInt(1);
	    		else if (cursor.getInt(0) == 1)
	    			revCount -= cursor.getInt(1);
	    		else
	    			newCount -= cursor.getInt(1);
	    	}
        } finally {
        	if (cursor != null) cursor.close();
        }
        
        // space other cards
        AnkiDb.database.execSQL(String.format(ENGLISH_LOCALE, 
        		""UPDATE cards "" +
        		""SET spaceUntil = %f, "" +
        		""combinedDue = max(%f, due), "" +
        		""modified = %f, "" +
        		""isDue = 0 "" +
        		""WHERE id != %d and factId = %d"",
        		space, space, now, card.id, card.factId));
        card.spaceUntil = 0;

        // temp suspend if learning ahead
        if (reviewEarly && lastDelay < 0)
            if (oldSuc != 0 || lastDelaySecs > delay0 || !showFailedLast())
                card.priority = -1;
        // card stats
        card.updateStats(ease, oldState);

        card.toDB();
        
        // global/daily stats
        Stats.updateAllStats(this.globalStats, this.dailyStats, card, ease, oldState);
        
        // review history
        CardHistoryEntry entry = new CardHistoryEntry(card, ease, lastDelay);
        entry.writeSQL();
        modified = now;
//        // TODO: Fix leech handling
//        if (isLeech(card))
//            card = handleLeech(card);
        setUndoEnd(undoName);
	}

//	private boolean isLeech(Card card)
//	{
//		int no = card.noCount;
//        int fmax = getInt(""leechFails"");
//        if (fmax == 0)
//            return false;
//        return (
//            // failed
//            (card.successive == 0) &&
//            // greater than fail threshold
//            (no >= fmax) &&
//            // at least threshold/2 reps since last time
//            (fmax - no) % (Math.max(fmax/2, 1)) == 0);
//	}
//
//	// TODO: not sure how this is supposed to affect the DB.
//	private Card handleLeech(Card card)
//	{
//		this.refresh();
//        Card scard = cardFromId(card.id, true);
//        tags = scard.fact.tags;
//        tags = addTags(""Leech"", tags);
//        scard.fact.tags = canonifyTags(tags);
//        scard.fact.setModified(textChanged=True);
//        self.updateFactTags(scard.fact.id);
//        self.s.flush();
//        self.s.expunge(scard);
//        if (getBool(""suspendLeeches""))
//            suspendCards(card.id);
//        this.refresh();
//	}

	/* Interval management
	 ***********************************************************/

	private double nextInterval(Card card, int ease)
	{
		double delay = adjustedDelay(card, ease);
		return nextInterval(card, delay, ease);
	}

	private double nextInterval(Card card, double delay, int ease)
	{
		double interval = card.interval;
        double factor = card.factor;

        // if shown early and not failed
        if ((delay < 0) && (card.successive != 0))
        {
            interval = Math.max(card.lastInterval, card.interval + delay);
            if (interval < midIntervalMin)
                interval = 0;
            delay = 0;
        }

        // if interval is less than mid interval, use presets
        if (ease == 1)
        {
            interval *= delay2;
            if (interval < hardIntervalMin)
                interval = 0;
        }
        else if (interval == 0)
        {
            if (ease == 2)
            	interval = hardIntervalMin + ((double) Math.random())*(hardIntervalMax - hardIntervalMin);
            else if (ease == 3)
            	interval = midIntervalMin + ((double) Math.random())*(midIntervalMax - midIntervalMin);
            else if (ease == 4)
            	interval = easyIntervalMin + ((double) Math.random())*(easyIntervalMax - easyIntervalMin);
        }
        else
        {
            // if not cramming, boost initial 2
            if ((interval < hardIntervalMax) && (interval > 0.166))
            {
                double mid = (midIntervalMin + midIntervalMax) / 2.0;
                interval = mid / factor;
            }
            // multiply last interval by factor
            if (ease == 2)
                interval = (interval + delay/4.0) * 1.2;
            else if (ease == 3)
                interval = (interval + delay/2.0) * factor;
            else if (ease == 4)
                interval = (interval + delay) * factor * factorFour;
            double fuzz = 0.95 + ((double) Math.random())*(1.05 - 0.95);
            interval *= fuzz;
        }
        if (maxScheduleTime != 0)
            interval = Math.min(interval, maxScheduleTime);
        return interval;
	}

	private double nextDue(Card card, int ease, String oldState)
	{
		double due;
		if (ease == 1)
			if (oldState.equals(""mature""))
				due = delay1;
			else
				due = delay0;
		else
			due = card.interval * 86400.0;
		return due + (System.currentTimeMillis() / 1000.0);
	}

	private void updateFactor(Card card, int ease)
	{
		card.lastFactor = card.factor;
		if (card.reps == 0)
			card.factor = averageFactor; // card is new, inherit beginning factor
		if (card.successive != 0 && !cardIsBeingLearnt(card))
			if (ease == 1)
				card.factor -= 0.20;
			else if (ease == 2)
				card.factor -= 0.15;
		if (ease == 4)
			card.factor += 0.10;
		card.factor = Math.max(1.3, card.factor);
	}

	private double adjustedDelay(Card card, int ease)
	{
		double now = System.currentTimeMillis() / 1000.0;
		if (cardIsNew(card))
			return 0;
		if (card.combinedDue <= now)
			return (now - card.due) / 86400.0;
		else
			return (now - card.combinedDue) / 86400.0;
	}

	/* Queue/cache management
	 ***********************************************************/

	private void rebuildCounts(boolean full) {
		Log.i(TAG, ""rebuildCounts - Rebuilding global and due counts..."");
		// Need to check due first, so new due cards are not added later
		checkDue();
		// Global counts
		if (full) {
			cardCount = (int) AnkiDb.queryScalar(""SELECT count(id) FROM cards"");
			factCount = (int) AnkiDb.queryScalar(""SELECT count(id) FROM facts"");
		}

		// Due counts
		failedSoonCount = (int) AnkiDb.queryScalar(""SELECT count(id) FROM failedCards"");
		failedNowCount = (int) AnkiDb.queryScalar(
				""SELECT count(id) "" +
				""FROM cards "" +
				""WHERE type = 0 and "" +
				""isDue = 1 and "" +
				""combinedDue <= "" +
				String.format(ENGLISH_LOCALE, ""%f"", (double) (System.currentTimeMillis() / 1000.0)));
		revCount = (int) AnkiDb.queryScalar(
				""SELECT count(id) "" +
				""FROM cards "" +
				""WHERE type = 1 and "" +
				""priority in (1,2,3,4) and "" +
				""isDue = 1"");
		newCount = (int) AnkiDb.queryScalar(
				""SELECT count(id) "" +
				""FROM cards "" +
				""WHERE type = 2 and "" +
				""priority in (1,2,3,4) and "" +
				""isDue = 1"");
	}
	/*
	 * Report real counts for miscounting debugging
	 */
//	public String reportCounts() {
//		Cursor cursor = null;
//		int myfailedSoonCount = 0;
//		int myrevCount = 0;
//		int mynewCount = 0;
//		int myfailedNowCount = (int) AnkiDb.queryScalar(
//				""SELECT count(id) "" +
//				""FROM cards "" +
//				""WHERE type = 0 and "" +
//				""isDue = 1 and "" +
//				""combinedDue <= "" +
//				String.format(ENGLISH_LOCALE, ""%f"", (double) (System.currentTimeMillis() / 1000.0)));
//		try {
//			cursor = AnkiDb.database.rawQuery(
//					""SELECT type, count(id) "" +
//					""FROM cards "" +
//					""WHERE priority in (1,2,3,4) and "" +
//					""isDue = 1 "" +
//					""GROUP BY type"", null);
//			while (cursor.moveToNext()) {
//				switch (cursor.getInt(0)) {
//					case 0: myfailedSoonCount = cursor.getInt(1); break;
//					case 1: myrevCount = cursor.getInt(1); break;
//					case 2: mynewCount = cursor.getInt(1); break;
//				}
//			}
//		} finally {
//			if (cursor != null) cursor.close();
//		}
//
//		return myfailedSoonCount + ""-"" + myfailedNowCount + ""-"" + myrevCount + ""-"" + mynewCount + ""<br/>"" +
//				failedSoonCount + ""-"" + failedNowCount + ""-"" + revCount + ""-"" + newCount;
//	}

	/**
	 * Mark expired cards due and update counts.
	 */
	private void checkDue()
	{
		Log.i(TAG, ""Checking due cards..."");
		checkDailyStats();

		ContentValues val = new ContentValues(1);
		val.put(""isDue"", 1);
		AnkiDb.database.update(
				""cards"",
				val,
				""priority in (1,2,3,4) and "" +
				""type in (0,1,2) and "" +
				""isDue = 0 and "" +
				String.format(ENGLISH_LOCALE, ""combinedDue <= %f"",
						(double) ((System.currentTimeMillis() / 1000.0) + delay0)),
				null);

		failedNowCount = (int) AnkiDb.queryScalar(
				""SELECT count(id) "" +
				""FROM cards "" +
				""WHERE type = 0 and "" +
				""isDue = 1 and "" +
				String.format(ENGLISH_LOCALE, ""combinedDue <= %f"",
						(double) (System.currentTimeMillis() / 1000.0)));

		Cursor cursor = null;
		try {
			cursor = AnkiDb.database.rawQuery(
					""SELECT type, count(id) "" +
					""FROM cards "" +
					""WHERE priority in (1,2,3,4) and "" +
					""isDue = 1 "" +
					""GROUP BY type"", null);
			while (cursor.moveToNext()) {
				switch (cursor.getInt(0)) {
					case 0: failedSoonCount = cursor.getInt(1); break;
					case 1: revCount = cursor.getInt(1); break;
					case 2: newCount = cursor.getInt(1); break;
				}
			}
		} finally {
			if (cursor != null) cursor.close();
		}

		newCountToday = Math.max(Math.min(newCount, newCardsPerDay - newCardsToday()), 0);
	}

	/**
	 * Update relative delays based on current time.
	 */
	private void rebuildQueue()
	{
		Cursor cursor = null;
		Log.i(TAG, ""rebuildQueue - Rebuilding query..."");
		// Setup global/daily stats
		globalStats = Stats.globalStats(this);
		dailyStats = Stats.dailyStats(this);

		// Mark due cards and update counts
		checkDue();

		// Invalid card count
		// Determine new card distribution
		if (newCardSpacing == NEW_CARDS_DISTRIBUTE)
		{
			if (newCountToday > 0)
			{
				newCardModulus = (newCountToday + revCount) / newCountToday;
				// If there are cards to review, ensure modulo >= 2
				if (revCount > 0)
					newCardModulus = Math.max(2, newCardModulus);
			} else
			{
				newCardModulus = 0;
			}
		} else
			newCardModulus = 0;
		Log.i(TAG, ""newCardModulus set to "" + newCardModulus);

		try {
			cursor = AnkiDb.database.rawQuery(""SELECT avg(factor) "" + ""FROM cards "" + ""WHERE type = 1"", null);
			if (!cursor.moveToFirst())
				averageFactor = Deck.initialFactor;
			else
				averageFactor = cursor.getDouble(0);
		} finally {
			if (cursor != null) cursor.close();
		}
		averageFactor = Math.max(averageFactor, minimumAverage);

		// Recache CSS
		// rebuildCSS();
	}

	/**
	 * Checks if the day has rolled over.
	 */
	private void checkDailyStats()
	{
		if (!Stats.genToday(this).toString().equals(dailyStats.day.toString()))
			dailyStats = Stats.dailyStats(this);
	}

	private void resetAfterReviewEarly() {
		Cursor cursor = null;
		long[] ids = null;
		try {
			cursor = AnkiDb.database.rawQuery(
					""SELECT id "" +
					""FROM cards "" +
					""WHERE priority = -1"",
					null);
			if (cursor.moveToFirst()) {
				int count = cursor.getCount();
				ids = new long[count];
				for (int i = 0; i < count; i++) {
					ids[i] = cursor.getLong(0);
					cursor.moveToNext();
				}
			}
		} finally {
			if (cursor != null) cursor.close();
		}

		if (ids != null) {
			updatePriorities(ids);
			flushMod();
		}
		if (reviewEarly || newEarly) {
			reviewEarly = false;
			newEarly = false;
			checkDue();
		}
	}

	/* Priorities
	 ***********************************************************/
	public void suspendCard(long cardId)
	{
		long[] ids = new long[1];
		ids[0] = cardId;
		suspendCards(ids);
	}
	
	public void suspendCards(long[] ids)
	{
		AnkiDb.database.execSQL(
				""UPDATE cards SET "" + 
				""isDue = 0, "" +
				""priority = -3, "" +
				""modified = "" + String.format(ENGLISH_LOCALE, ""%f"", (double) (System.currentTimeMillis() / 1000.0)) +
				"" WHERE id IN "" + ids2str(ids));
		rebuildCounts(false);
		flushMod();
	}
	
	public void unsuspendCard(long cardId)
	{
		long[] ids = new long[1];
		ids[0] = cardId;
		unsuspendCards(ids);
	}
	
	public void unsuspendCards(long[] ids)
	{
		AnkiDb.database.execSQL(
				""UPDATE cards SET "" +
				""priority = 0, "" +
				""modified = "" + String.format(ENGLISH_LOCALE, ""%f"", (double) (System.currentTimeMillis() / 1000.0)) +
				"" WHERE id IN "" + ids2str(ids));
		updatePriorities(ids);
		rebuildCounts(false);
		flushMod();
	}
	
	private void updatePriorities(long[] cardIds) {
		updatePriorities(cardIds, null, true);
	}

	private void updatePriorities(long[] cardIds, String[] suspend, boolean dirty) {
		Cursor cursor = null;
		Log.i(TAG, ""updatePriorities - Updating priorities..."");
		// Any tags to suspend
		if (suspend != null) {
			long[] ids = tagIds(suspend);
			AnkiDb.database.execSQL(
					""UPDATE tags "" +
					""SET priority = 0 "" +
					""WHERE id in "" +
					ids2str(ids));
		}

		String limit = """";
		if (cardIds.length <= 1000)
			limit = ""and cardTags.cardId in "" + ids2str(cardIds);
		String query = ""SELECT cardTags.cardId, "" +
				""CASE "" + 
				""WHEN min(tags.priority) = 0 THEN 0 "" + 
				""WHEN max(tags.priority) > 2 THEN max(tags.priority) "" + 
				""WHEN min(tags.priority) = 1 THEN 1 "" + 
				""ELSE 2 END "" + 
				""FROM cardTags,tags "" + 
				""WHERE cardTags.tagId = tags.id "" + limit + "" "" + 
				""GROUP BY cardTags.cardId"";
		try {
			cursor = AnkiDb.database.rawQuery(query, null);
			if (cursor.moveToFirst()) {
				int len = cursor.getCount();
				long[][] cards = new long[len][2];
				for (int i = 0; i < len; i++) {
					cards[i][0] = cursor.getLong(0);
					cards[i][1] = cursor.getInt(1);
				}
	
				String extra = """";
				if (dirty)
					extra = "", modified = "" + String.format(ENGLISH_LOCALE, ""%f"", (double) (System.currentTimeMillis() / 1000.0));
				for (int pri = 0; pri < 5; pri++)
				{
					int count = 0;
					for (int i = 0; i < len; i++)
					{
						if (cards[i][1] == pri)
							count++;
					}
					long[] cs = new long[count];
					int j = 0;
					for (int i = 0; i < len; i++)
					{
						if (cards[i][1] == pri)
						{
							cs[j] = cards[i][0];
							j++;
						}
					}
					// Catch review early & buried but not suspended cards
					AnkiDb.database.execSQL(""UPDATE cards "" + 
							""SET priority = "" + pri + 
							extra + 
							"" WHERE id in "" + ids2str(cs) + "" and "" + 
							""priority != "" + pri + "" and "" + 
							""priority >= -2"");
				}
			}
		} finally {
			if (cursor != null) cursor.close();
		}
		
		ContentValues val = new ContentValues(1);
		val.put(""isDue"", 0);
		int cnt = AnkiDb.database.update(""cards"", 
				val, 
				""type in (0,1,2) and "" + 
				""priority = 0 and "" + 
				""isDue = 1"", 
				null);
		if (cnt > 0)
			rebuildCounts(false);
	}

	/*
	 * Counts related to due cards
	 * *********************************************************
	 */

	private int newCardsToday()
	{
		return (dailyStats.newEase0 + dailyStats.newEase1 + dailyStats.newEase2 + dailyStats.newEase3 + dailyStats.newEase4);
	}

	/* Card Predicates
	 ***********************************************************/

	private String cardState(Card card)
	{
		if (cardIsNew(card))
            return ""new"";
		else if (card.interval > MATURE_THRESHOLD)
            return ""mature"";
        return ""young"";
	}

	/**
	 * Check if a card is a new card.
	 * @param card The card to check.
	 * @return True if a card has never been seen before.
	 */
	private boolean cardIsNew(Card card)
	{
		return card.reps == 0;
	}

	/**
	 * Check if a card is a new card.
	 * @param card The card to check.
	 * @return True if card should use present intervals.
	 */
	private boolean cardIsBeingLearnt(Card card)
	{
		return card.lastInterval < 7;
	}

	/* Undo/Redo
	 ***********************************************************/
	private class UndoRow {
		String name;
		Long start;
		Long end;
		
		UndoRow(String name, Long start, Long end)
		{
			this.name = name;
			this.start = start;
			this.end = end;
		}
	}
	
	// FIXME: Where should this be called from?
	@SuppressWarnings(""unused"")
	private void initUndo()
	{
		undoStack = new Stack<UndoRow>();
		redoStack = new Stack<UndoRow>();
		undoEnabled = true;
		
		AnkiDb.database.execSQL(""CREATE TEMPORARY TABLE undoLog (seq INTEGER PRIMARY KEY NOT NULL, sql TEXT)"");
		
		ArrayList<String> tables = AnkiDb.queryColumn(
				String.class, 
				""SELECT name FROM sqlite_master WHERE type = 'table'"", 
				0);
		Iterator<String> iter = tables.iterator();
		while (iter.hasNext()) {
			String table = iter.next();
			if ( table.equals(""undoLog"") || table.equals(""sqlite_stat1"") )
				continue;
			ArrayList<String> columns = AnkiDb.queryColumn(
					String.class, 
					""PRAGMA TABLE_INFO("" + table + "")"", 
					1);
			// Insert trigger
			String sql = ""CREATE TEMP TRIGGER _undo_%s_it "" +
					""AFTER INSERT ON %s BEGIN "" +
					""INSERT INTO undoLog VALUES "" +
					""(null, 'DELETE FROM %s WHERE rowid = ' || new.rowid); END"";
			AnkiDb.database.execSQL(String.format(ENGLISH_LOCALE, sql, table, table, table));
			// Update trigger
			sql = String.format(ENGLISH_LOCALE, ""CREATE TEMP TRIGGER _undo_%s_ut "" +
					""AFTER UPDATE ON %s BEGIN "" +
					""INSERT INTO undoLog VALUES "" +
					""(null, 'UPDATE %s "",
					table, table, table);
			String sep = ""SET "";
			Iterator<String> columnIter = columns.iterator();
			while (columnIter.hasNext())
			{
				String column = columnIter.next();
				if (column.equals(""unique""))
					continue;
				sql += String.format(ENGLISH_LOCALE, ""%s%s=' || quote(old.%s) || '"", sep, column, column);
				sep = "","";
			}
			sql += ""WHERE rowid = ' || old.rowid); END"";
			AnkiDb.database.execSQL(sql);
			// Delete trigger
			sql = String.format(ENGLISH_LOCALE, ""CREATE TEMP TRIGGER _undo_%s_dt "" +
					""BEFORE DELETE ON %s BEGIN "" +
					""INSERT INTO undoLog VALUES "" +
					""(null, 'INSERT INTO %s (rowid"",
					table, table, table);
			columnIter = columns.iterator();
			while (columnIter.hasNext())
			{
				String column = columnIter.next();
				sql += String.format(ENGLISH_LOCALE, "",\""%s\"""", column);
			}
			sql += "") VALUES (' || old.rowid ||'"";
			columnIter = columns.iterator();
			while (columnIter.hasNext())
			{
				String column = columnIter.next();
				if (column.equals(""unique"")) {
					sql += "",1"";
					continue;
				}
				sql += String.format(ENGLISH_LOCALE, "", ' || quote(old.%s) ||'"", column);
			}
			sql += "")'); END"";
			AnkiDb.database.execSQL(sql);
		}
	}
	
	public void setUndoBarrier()
	{
		if (undoStack.isEmpty() || undoStack.peek() != null)
			undoStack.push(null);
	}
	
	public void setUndoStart(String name)
	{
		setUndoStart(name, false);
	}
	


	
	/**
	 * @param reviewEarly set to true for early review
	 */
	public void setReviewEarly(boolean reviewEarly) {
		this.reviewEarly = reviewEarly;
	}

	public void setUndoStart(String name, boolean merge)
	{
		if (!undoEnabled)
			return;
		commitToDB();
		if (merge && !undoStack.isEmpty())
			if ((undoStack.peek() != null) && (undoStack.peek().name.equals(name)))
				return;
		undoStack.push(new UndoRow(name, latestUndoRow(), null));
	}
	
	public void setUndoEnd(String name)
	{
		if (!undoEnabled)
			return;
		commitToDB();
		long end = latestUndoRow();
		while (undoStack.peek() == null)
			undoStack.pop(); // Strip off barrier
		UndoRow row = undoStack.peek();
		row.end = end;
		if (row.start == row.end)
			undoStack.pop();
		else
			redoStack.clear();
	}
	
	private long latestUndoRow()
	{
		long result;
		try {
			result = AnkiDb.queryScalar(""SELECT MAX(rowid) FROM undoLog"");
		} catch (SQLException e) {
			result = 0;
		}
		return result;
	}
	
	private void undoredo(Stack<UndoRow> src, Stack<UndoRow> dst)
	{
		UndoRow row;
		commitToDB();
		while (true)
		{
			row = src.pop();
			if (row != null)
				break;
		}
		Long start = row.start;
		Long end = row.end;
		if (end == null)
			end = latestUndoRow();
		ArrayList<String> sql = AnkiDb.queryColumn(
				String.class, 
				String.format(ENGLISH_LOCALE, ""SELECT sql FROM undoLog "" +
						""WHERE seq > %d and seq <= %d "" +
						""ORDER BY seq DESC"", start, end), 
				0);
		Long newstart = latestUndoRow();
		Iterator<String> iter = sql.iterator();
		while (iter.hasNext())
			AnkiDb.database.execSQL(iter.next());
		Long newend = latestUndoRow();
		dst.push(new UndoRow(row.name, newstart, newend));
	}
	
	public void undo()
	{
		undoredo(undoStack, redoStack);
		commitToDB();
		rebuildCounts(true);
	}
	
	public void redo()
	{
		undoredo(redoStack, undoStack);
		commitToDB();
		rebuildCounts(true);
	}
	
	/* Dynamic indices
	 ***********************************************************/

	private void updateDynamicIndices() {
		Log.i(TAG, ""updateDynamicIndices - Updating indices..."");
		HashMap<String,String> indices = new HashMap<String,String>();
		indices.put(""intervalDesc"", ""(type, isDue, priority desc, interval desc)"");
		indices.put(""intervalAsc"", ""(type, isDue, priority desc, interval)"");
		indices.put(""randomOrder"", ""(type, isDue, priority desc, factId, ordinal)"");
		indices.put(""dueAsc"", ""(type, isDue, priority desc, due)"");
		indices.put(""dueDesc"", ""(type, isDue, priority desc, due desc)"");

		ArrayList<String> required = new ArrayList<String>();
		if (revCardOrder == REV_CARDS_OLD_FIRST)
			required.add(""intervalDesc"");
		if (revCardOrder == REV_CARDS_NEW_FIRST)
			required.add(""intervalAsc"");
		if (revCardOrder == REV_CARDS_RANDOM)
			required.add(""randomOrder"");
		if (revCardOrder == REV_CARDS_DUE_FIRST || newCardOrder == NEW_CARDS_OLD_FIRST
		        || newCardOrder == NEW_CARDS_RANDOM)
			required.add(""dueAsc"");
		if (newCardOrder == NEW_CARDS_NEW_FIRST)
			required.add(""dueDesc"");

		Set<Entry<String, String>> entries = indices.entrySet();
		Iterator<Entry<String, String>> iter = entries.iterator();
		while (iter.hasNext())
		{
			Entry<String, String> entry = iter.next();
			if (required.contains(entry.getKey()))
				AnkiDb.database.execSQL(""CREATE INDEX IF NOT EXISTS "" + ""ix_cards_"" + entry.getKey() + "" ON cards ""
				        + entry.getValue());
			else
				AnkiDb.database.execSQL(""DROP INDEX IF EXISTS "" + ""ix_cards_"" + entry.getKey());
		}
	}

	/*
	 * Utility functions (might be better in a separate class)
	 * *********************************************************
	 */

	/**
	 * Returns a SQL string from an array of integers.
	 *
	 * @param ids
	 *            The array of integers to include in the list.
	 * @return An SQL compatible string in the format (ids[0],ids[1],..).
	 */
	private static String ids2str(long[] ids)
	{
		String str = ""("";
		int len = ids.length;
		for (int i = 0; i < len; i++)
		{
			if (i == (len - 1))
				str += ids[i];
			else
				str += ids[i] + "","";
		}
		str += "")"";
		return str;
	}

	/**
	 * Gets the IDs of the specified tags.
	 *
	 * @param tags
	 *            An array of the tags to get IDs for.
	 * @return An array of IDs of the tags.
	 */
	private static long[] tagIds(String[] tags)
	{
		// TODO: Finish porting this method from tags.py.
		return null;
	}
}
",True,9,29,1,3,5,8
27,com.ichi2.anki.CustomExceptionHandler.java,"package com.ichi2.anki;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Environment;
import android.os.StatFs;
import android.util.Log;

public class CustomExceptionHandler implements Thread.UncaughtExceptionHandler {
	private Thread.UncaughtExceptionHandler PreviousHandler;
	private static CustomExceptionHandler instance;
	private Context curContext;
	private final static String TAG = ""CustomExceptionHandler"";
//	private Random randomGenerator = new Random();
	
	private HashMap<String, String> information = new HashMap<String, String>(
			20);

	static CustomExceptionHandler getInstance() {
		if (instance == null) {
			instance = new CustomExceptionHandler();
			Log.i(TAG, ""New instance of custom exception handler"");
		}

		return instance;
	}

	public void Init(Context context) {
		PreviousHandler = Thread.getDefaultUncaughtExceptionHandler();
		Thread.setDefaultUncaughtExceptionHandler(this);
		curContext = context;
	}

	private long getAvailableInternalMemorySize() {
		File path = Environment.getDataDirectory();
		StatFs stat = new StatFs(path.getPath());
		long blockSize = stat.getBlockSize();
		long availableBlocks = stat.getAvailableBlocks();
		return availableBlocks * blockSize;
	}

	private long getTotalInternalMemorySize() {
		File path = Environment.getDataDirectory();
		StatFs stat = new StatFs(path.getPath());
		long blockSize = stat.getBlockSize();
		long totalBlocks = stat.getBlockCount();
		return totalBlocks * blockSize;
	}

	private void collectInformation() {
		Log.i(TAG, ""collectInformation"");

		if (curContext == null)
			return;

		try {
			Log.i(TAG, ""collecting information"");

			PackageManager pm = curContext.getPackageManager();
			PackageInfo pi = pm.getPackageInfo(curContext.getPackageName(), 0);

			information.put(""VersionName"", pi.versionName); // Version
			information.put(""PackageName"", pi.packageName);// Package name
			information.put(""PhoneModel"", android.os.Build.MODEL); // Device
																	// model
			information.put(""AndroidVersion"", android.os.Build.VERSION.RELEASE);// Android
																				// version
			information.put(""Board"", android.os.Build.BOARD);
			information.put(""Brand"", android.os.Build.BRAND);
			information.put(""Device"", android.os.Build.DEVICE);
			information.put(""Display"", android.os.Build.DISPLAY);
			information.put(""FingerPrint"", android.os.Build.FINGERPRINT);
			information.put(""Host"", android.os.Build.HOST);
			information.put(""ID"", android.os.Build.ID);
			information.put(""Model"", android.os.Build.MODEL);
			information.put(""Product"", android.os.Build.PRODUCT);
			information.put(""Tags"", android.os.Build.TAGS);
			information.put(""Time"", Long.toString(android.os.Build.TIME));
			information.put(""Type"", android.os.Build.TYPE);
			information.put(""User"", android.os.Build.USER);
			information.put(""TotalInternalMemory"", Long
					.toString(getTotalInternalMemorySize()));
			information.put(""AvailableInternalMemory"", Long
					.toString(getAvailableInternalMemorySize()));

			Log.i(TAG, ""Information collected"");
		} catch (Exception e) {
			Log.i(TAG, e.toString());
		}
	}

	public void uncaughtException(Thread t, Throwable e) {
		Log.i(TAG, ""uncaughtException"");

		collectInformation();
		Date currentDate = new Date();

		StringBuilder reportInformation = new StringBuilder(10000);
		reportInformation.append(String.format(
				""Report Generated: %s\nBegin Collected Information\n\n"",
				currentDate.toString()));

		for (String key : information.keySet()) {
			String value = information.get(key);

			reportInformation.append(String.format(""%s = %s\n"", key, value));
		}

		reportInformation.append(String
				.format(""End Collected Information\n\nBegin Stacktrace\n\n""));

		// Stack trace
		final Writer result = new StringWriter();
		final PrintWriter printWriter = new PrintWriter(result);
		e.printStackTrace(printWriter);
		reportInformation.append(String.format(""%s\n"", result.toString()));

		reportInformation.append(String
				.format(""End Stacktrace\n\nBegin Inner exceptions\n\n""));

		// Cause, inner exceptions
		Throwable cause = e.getCause();
		while (cause != null) {
			cause.printStackTrace(printWriter);
			reportInformation.append(String.format(""%s\n"", result.toString()));
			cause = cause.getCause();
		}

		reportInformation.append(String.format(""End Inner exceptions""));

		printWriter.close();

		Log.i(TAG, ""report infomation string created"");
		saveReportToFile(reportInformation.toString());
		
		PreviousHandler.uncaughtException(t, e);
	}

	private void saveReportToFile(String reportInformation) {
		try {
			Log.i(TAG, ""saveReportFile"");

			Date currentDate = new Date();
			SimpleDateFormat formatter = new SimpleDateFormat(""yyyyMMddHHmmss"");
			String filename = String.format(""ad-%s.stacktrace"", formatter.format(currentDate));
			
			Log.i(TAG, ""No external storage available"");
			FileOutputStream trace = curContext.openFileOutput(filename, Context.MODE_PRIVATE);
			trace.write(reportInformation.getBytes());
			trace.close();

			Log.i(TAG, ""report saved"");
		} catch (Exception e) {
			Log.i(TAG, e.toString());
		}
	}
}
",True,36,20,5,6,0,0
28,com.ichi2.utils.StringUtils.java,"/***************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.utils;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;

public class StringUtils {

	/**
	 * Converts an InputStream to a String
	 * 
	 * @param is
	 *            InputStream to convert
	 * @return String version of the InputStream
	 */
	public static String convertStreamToString(InputStream is)
	{
		String contentOfMyInputStream = """";
		try
		{
			BufferedReader rd = new BufferedReader(new InputStreamReader(is), 4096);
			String line;
			StringBuilder sb = new StringBuilder();
			while ((line = rd.readLine()) != null)
			{
				sb.append(line);
			}
			rd.close();
			contentOfMyInputStream = sb.toString();
		} catch (Exception e)
		{
			e.printStackTrace();
		}

		return contentOfMyInputStream;
	}
}
",True,14,20,6,7,0,0
29,com.ichi2.utils.RubyParser.java,"/****************************************************************************************
* Copyright (c) 2009 Brennan D'Aguilar <brennan.daguilar@gmail.com>                    *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/
package com.ichi2.utils;

/**
 * Parses text input from Anki cards to display ruby text correctly in AnkiDroid.
 * Anki's Japanese language support handles ruby text as:
 * <code>basetext[rubytext]</code> 
 * where the base text begins after the first spacer proceeding the ruby text, 
 * or the beginning of the string of text if no spacers exist before the start of the base text.
 * This is converted to basic ruby markup:
 * <code><ruby><rb>baseText</rb><rt>rubyText</rt></ruby></code>
 *   While webkit on android devices does not support ruby markup yet, 
 *   the text can be adjusted adequately using css.
 */
public class RubyParser {

    private static final  char RUBY_SPACER_JAP_SPACE = ' ';
    private static final  char RUBY_SPACER_JAP_COMMA = '\u3001';
    private static final  char RUBY_TEXT_START = '[';
    private static final  char RUBY_TEXT_END = ']';
    private static final  char HTML_TAG_START = '<';
    private static final  char HTML_TAG_END = '>';

    /**
     * Converts ruby text from the format used by Anki's Japanese support plugin
     * to html ruby markup.
     * @param sourceText the japanese text containing ruby text
     * @return html ruby markup equivalent of the input text.
     */
    public static String ankiRubyToMarkup(String sourceText)
    {
        int cursorIndex = 0;

        int nextRubyTextStart;     // The first '[' after the cursorIndex
        int nextSpacer;                      // The first spacer (' ', or '„ÄÅ') after the cursorIndex
        int nextRubyTextEnd;      // The first ']' after the cursorIndex
        int nextHtmlTagStart;      // The first '<' after the cursorIndex

        StringBuilder builder = new StringBuilder();

        // Loop until the entire string is parsed
        while (cursorIndex < sourceText.length() - 1)
        {
            //Find the location of the beginning of the next ruby text
            nextRubyTextStart = sourceText.indexOf(RUBY_TEXT_START, cursorIndex);
            
            //Find the location of the next spacing character (only -1 if neither possible
            // spacing character remains.
            nextSpacer = sourceText.indexOf(RUBY_SPACER_JAP_SPACE, cursorIndex);
            if (nextSpacer == -1)
            {
                nextSpacer =  Math.max(nextSpacer, sourceText.indexOf(RUBY_SPACER_JAP_COMMA, cursorIndex));
            }
            
            
            //Check for html tags that come before any ruby text.  If found, pass the full tag
            // without parsing.
            nextHtmlTagStart = sourceText.indexOf(HTML_TAG_START, cursorIndex);

            if (nextHtmlTagStart != -1 &&
                    (nextSpacer == -1 || nextHtmlTagStart < nextSpacer ) &&
                    (nextRubyTextStart == -1 || nextHtmlTagStart < nextRubyTextStart))
            {
                int nextHtmlTagEnd = sourceText.indexOf(HTML_TAG_END, nextHtmlTagStart);
                builder.append(sourceText.substring(cursorIndex, nextHtmlTagEnd + 1));
                cursorIndex = nextHtmlTagEnd + 1;
            }
            else //If no html tag is passed through on this cycle, check for ruby text.
            {
                // If any unparsed ruby text remains
                if  (nextRubyTextStart != -1) 
                {
                    //If there is any text before the next ruby tag that is part of the ruby base text,
                    // pass it through unparsed.
                    if (nextSpacer < nextRubyTextStart && nextSpacer != -1)
                    {
                        // Remove spaces from the text
                        if (sourceText.charAt(nextSpacer) == RUBY_SPACER_JAP_SPACE)
                        {
                            builder.append(sourceText.substring(cursorIndex, nextSpacer));
                        }
                        else //If spacing character is not a space (eg. a comma), pass it through as well.
                        {
                            builder.append(sourceText.substring(cursorIndex, nextSpacer + 1));
                        }
                        cursorIndex = nextSpacer + 1;
                    } 
                    else 
                    {
                        // Find the end of the ruby text, and parse it into html tags.
                        nextRubyTextEnd = sourceText.indexOf(RUBY_TEXT_END, cursorIndex);
                        builder.append(newRubyPair(sourceText.substring(cursorIndex, nextRubyTextStart), sourceText.substring(nextRubyTextStart + 1, nextRubyTextEnd)));
                        cursorIndex = nextRubyTextEnd + 1;
                    }
                }
                else 
                {
                    // If no ruby text remains to be parsed, pass any remaining text through and finish.
                    builder.append(sourceText.substring(cursorIndex));
                    cursorIndex = sourceText.length();
                }
            }
        }

        return builder.toString();

    }

    private static String newRubyPair(String baseText, String rubyText) {
        return ""<ruby><rb>"" + baseText + ""</rb><rt>"" + rubyText + ""</rt></ruby>"";
    }
}
",False,22,20,6,5,0,0
30,com.ichi2.utils.DiffEngine.java,"/*
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ichi2.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Pattern;


/**
 * Functions for diff, match and patch.
 * Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 *
 * @author fraser@google.com (Neil Fraser)
 *
 * Class containing the diff, match and patch methods.
 * Also contains the behaviour settings.
 * TODO if possible, remove the merging code, unneeded.
 */
public class DiffEngine {

  // Defaults.
  // Set these on your diff_match_patch instance to override the defaults.

  /**
   * Number of seconds to map a diff before giving up (0 for infinity).
   */
  public float Diff_Timeout = 1.0f;
  /**
   * Cost of an empty edit operation in terms of edit characters.
   */
  public short Diff_EditCost = 4;
  /**
   * The size beyond which the double-ended diff activates.
   * Double-ending is twice as fast, but less accurate.
   */
  public short Diff_DualThreshold = 32;

  /**
   * Colors for right and wrong answer
   */
  private static final String RIGHT_COLOR = ""#c0ffc0"";
  private static final String WRONG_COLOR = ""#ffc0c0"";

  /**
   * Internal class for returning results from diff_linesToChars().
   * Other less paranoid languages just use a three-element array.
   */
  protected static class LinesToCharsResult {
    protected String chars1;
    protected String chars2;
    protected List<String> lineArray;

    protected LinesToCharsResult(String chars1, String chars2,
        List<String> lineArray) {
      this.chars1 = chars1;
      this.chars2 = chars2;
      this.lineArray = lineArray;
    }
  }


  //  DIFF FUNCTIONS


  /**
   * The data structure representing a diff is a Linked list of Diff objects:
   * {Diff(Operation.DELETE, ""Hello""), Diff(Operation.INSERT, ""Goodbye""),
   *  Diff(Operation.EQUAL, "" world."")}
   * which means: delete ""Hello"", add ""Goodbye"" and keep "" world.""
   */
  public enum Operation {
    DELETE, INSERT, EQUAL
  }


  /**
   * Find the differences between two texts.
   * Run a faster slightly less optimal diff
   * This method allows the 'checklines' of diff_main() to be optional.
   * Most of the time checklines is wanted, so default to true.
   * @param text1 Old string to be diffed.
   * @param text2 New string to be diffed.
   * @return Linked List of Diff objects.
   */
  public LinkedList<DiffAction> diff_main(String text1, String text2) {
    return diff_main(text1, text2, true);
  }

  /**
   * Find the differences between two texts.  Simplifies the problem by
   * stripping any common prefix or suffix off the texts before diffing.
   * @param text1 Old string to be diffed.
   * @param text2 New string to be diffed.
   * @param checklines Speedup flag.  If false, then don't run a
   *     line-level diff first to identify the changed areas.
   *     If true, then run a faster slightly less optimal diff
   * @return Linked List of Diff objects.
   */
  public LinkedList<DiffAction> diff_main(String text1, String text2,
                                    boolean checklines) {
    // Check for equality (speedup)
    LinkedList<DiffAction> diffs;
    if (text1.equals(text2)) {
      diffs = new LinkedList<DiffAction>();
      diffs.add(new DiffAction(Operation.EQUAL, text1));
      return diffs;
    }

    // Trim off common prefix (speedup)
    int commonlength = diff_commonPrefix(text1, text2);
    String commonprefix = text1.substring(0, commonlength);
    text1 = text1.substring(commonlength);
    text2 = text2.substring(commonlength);

    // Trim off common suffix (speedup)
    commonlength = diff_commonSuffix(text1, text2);
    String commonsuffix = text1.substring(text1.length() - commonlength);
    text1 = text1.substring(0, text1.length() - commonlength);
    text2 = text2.substring(0, text2.length() - commonlength);

    // Compute the diff on the middle block
    diffs = diff_compute(text1, text2, checklines);

    // Restore the prefix and suffix
    if (commonprefix.length() > 0) {
      diffs.addFirst(new DiffAction(Operation.EQUAL, commonprefix));
    }
    if (commonsuffix.length() > 0) {
      diffs.addLast(new DiffAction(Operation.EQUAL, commonsuffix));
    }

    diff_cleanupMerge(diffs);
    return diffs;
  }


  /**
   * Find the differences between two texts.  Assumes that the texts do not
   * have any common prefix or suffix.
   * @param text1 Old string to be diffed.
   * @param text2 New string to be diffed.
   * @param checklines Speedup flag.  If false, then don't run a
   *     line-level diff first to identify the changed areas.
   *     If true, then run a faster slightly less optimal diff
   * @return Linked List of Diff objects.
   */
  protected LinkedList<DiffAction> diff_compute(String text1, String text2,
                                          boolean checklines) {
    LinkedList<DiffAction> diffs = new LinkedList<DiffAction>();

    if (text1.length() == 0) {
      // Just add some text (speedup)
      diffs.add(new DiffAction(Operation.INSERT, text2));
      return diffs;
    }

    if (text2.length() == 0) {
      // Just delete some text (speedup)
      diffs.add(new DiffAction(Operation.DELETE, text1));
      return diffs;
    }

    String longtext = text1.length() > text2.length() ? text1 : text2;
    String shorttext = text1.length() > text2.length() ? text2 : text1;
    int i = longtext.indexOf(shorttext);
    if (i != -1) {
      // Shorter text is inside the longer text (speedup)
      Operation op = (text1.length() > text2.length()) ?
                     Operation.DELETE : Operation.INSERT;
      diffs.add(new DiffAction(op, longtext.substring(0, i)));
      diffs.add(new DiffAction(Operation.EQUAL, shorttext));
      diffs.add(new DiffAction(op, longtext.substring(i + shorttext.length())));
      return diffs;
    }
    longtext = shorttext = null;  // Garbage collect

    // Check to see if the problem can be split in two.
    String[] hm = diff_halfMatch(text1, text2);
    if (hm != null) {
      // A half-match was found, sort out the return data.
      String text1_a = hm[0];
      String text1_b = hm[1];
      String text2_a = hm[2];
      String text2_b = hm[3];
      String mid_common = hm[4];
      // Send both pairs off for separate processing.
      LinkedList<DiffAction> diffs_a = diff_main(text1_a, text2_a, checklines);
      LinkedList<DiffAction> diffs_b = diff_main(text1_b, text2_b, checklines);
      // Merge the results.
      diffs = diffs_a;
      diffs.add(new DiffAction(Operation.EQUAL, mid_common));
      diffs.addAll(diffs_b);
      return diffs;
    }

    // Perform a real diff.
    if (checklines && (text1.length() < 100 || text2.length() < 100)) {
      checklines = false;  // Too trivial for the overhead.
    }
    List<String> linearray = null;
    if (checklines) {
      // Scan the text on a line-by-line basis first.
      LinesToCharsResult b = diff_linesToChars(text1, text2);
      text1 = b.chars1;
      text2 = b.chars2;
      linearray = b.lineArray;
    }

    diffs = diff_map(text1, text2);
    if (diffs == null) {
      // No acceptable result.
      diffs = new LinkedList<DiffAction>();
      diffs.add(new DiffAction(Operation.DELETE, text1));
      diffs.add(new DiffAction(Operation.INSERT, text2));
    }

    if (checklines) {
      // Convert the diff back to original text.
      diff_charsToLines(diffs, linearray);
      // Eliminate freak matches (e.g. blank lines)
      diff_cleanupSemantic(diffs);

      // Rediff any replacement blocks, this time character-by-character.
      // Add a dummy entry at the end.
      diffs.add(new DiffAction(Operation.EQUAL, """"));
      int count_delete = 0;
      int count_insert = 0;
      String text_delete = """";
      String text_insert = """";
      ListIterator<DiffAction> pointer = diffs.listIterator();
      DiffAction thisDiff = pointer.next();
      while (thisDiff != null) {
        switch (thisDiff.operation) {
        case INSERT:
          count_insert++;
          text_insert += thisDiff.text;
          break;
        case DELETE:
          count_delete++;
          text_delete += thisDiff.text;
          break;
        case EQUAL:
          // Upon reaching an equality, check for prior redundancies.
          if (count_delete >= 1 && count_insert >= 1) {
            // Delete the offending records and add the merged ones.
            pointer.previous();
            for (int j = 0; j < count_delete + count_insert; j++) {
              pointer.previous();
              pointer.remove();
            }
            for (DiffAction newDiff : diff_main(text_delete, text_insert, false)) {
              pointer.add(newDiff);
            }
          }
          count_insert = 0;
          count_delete = 0;
          text_delete = """";
          text_insert = """";
          break;
        }
        thisDiff = pointer.hasNext() ? pointer.next() : null;
      }
      diffs.removeLast();  // Remove the dummy entry at the end.
    }
    return diffs;
  }


  /**
   * Split two texts into a list of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * @param text1 First string.
   * @param text2 Second string.
   * @return An object containing the encoded text1, the encoded text2 and
   *     the List of unique strings.  The zeroth element of the List of
   *     unique strings is intentionally blank.
   */
  protected LinesToCharsResult diff_linesToChars(String text1, String text2) {
    List<String> lineArray = new ArrayList<String>();
    Map<String, Integer> lineHash = new HashMap<String, Integer>();
    // e.g. linearray[4] == ""Hello\n""
    // e.g. linehash.get(""Hello\n"") == 4

    // ""\x00"" is a valid character, but various debuggers don't like it.
    // So we'll insert a junk entry to avoid generating a null character.
    lineArray.add("""");

    String chars1 = diff_linesToCharsMunge(text1, lineArray, lineHash);
    String chars2 = diff_linesToCharsMunge(text2, lineArray, lineHash);
    return new LinesToCharsResult(chars1, chars2, lineArray);
  }


  /**
   * Split a text into a list of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * @param text String to encode.
   * @param lineArray List of unique strings.
   * @param lineHash Map of strings to indices.
   * @return Encoded string.
   */
  private String diff_linesToCharsMunge(String text, List<String> lineArray,
                                        Map<String, Integer> lineHash) {
    int lineStart = 0;
    int lineEnd = -1;
    String line;
    StringBuilder chars = new StringBuilder();
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    while (lineEnd < text.length() - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length() - 1;
      }
      line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.containsKey(line)) {
        chars.append(String.valueOf((char) (int) lineHash.get(line)));
      } else {
        lineArray.add(line);
        lineHash.put(line, lineArray.size() - 1);
        chars.append(String.valueOf((char) (lineArray.size() - 1)));
      }
    }
    return chars.toString();
  }


  /**
   * Rehydrate the text in a diff from a string of line hashes to real lines of
   * text.
   * @param diffs LinkedList of Diff objects.
   * @param lineArray List of unique strings.
   */
  protected void diff_charsToLines(LinkedList<DiffAction> diffs,
                                  List<String> lineArray) {
    StringBuilder text;
    for (DiffAction diff : diffs) {
      text = new StringBuilder();
      for (int y = 0; y < diff.text.length(); y++) {
        text.append(lineArray.get(diff.text.charAt(y)));
      }
      diff.text = text.toString();
    }
  }


  /**
   * Explore the intersection points between the two texts.
   * @param text1 Old string to be diffed.
   * @param text2 New string to be diffed.
   * @return LinkedList of Diff objects or null if no diff available.
   */
  protected LinkedList<DiffAction> diff_map(String text1, String text2) {
    long ms_end = System.currentTimeMillis() + (long) (Diff_Timeout * 1000);
    // Cache the text lengths to prevent multiple calls.
    int text1_length = text1.length();
    int text2_length = text2.length();
    int max_d = text1_length + text2_length - 1;
    boolean doubleEnd = Diff_DualThreshold * 2 < max_d;
    List<Set<Long>> v_map1 = new ArrayList<Set<Long>>();
    List<Set<Long>> v_map2 = new ArrayList<Set<Long>>();
    Map<Integer, Integer> v1 = new HashMap<Integer, Integer>();
    Map<Integer, Integer> v2 = new HashMap<Integer, Integer>();
    v1.put(1, 0);
    v2.put(1, 0);
    int x, y;
    Long footstep = 0L;  // Used to track overlapping paths.
    Map<Long, Integer> footsteps = new HashMap<Long, Integer>();
    boolean done = false;
    // If the total number of characters is odd, then the front path will
    // collide with the reverse path.
    boolean front = ((text1_length + text2_length) % 2 == 1);
    for (int d = 0; d < max_d; d++) {
      // Bail out if timeout reached.
      if (Diff_Timeout > 0 && System.currentTimeMillis() > ms_end) {
        return null;
      }

      // Walk the front path one step.
      v_map1.add(new HashSet<Long>());  // Adds at index 'd'.
      for (int k = -d; k <= d; k += 2) {
        if (k == -d || k != d && v1.get(k - 1) < v1.get(k + 1)) {
          x = v1.get(k + 1);
        } else {
          x = v1.get(k - 1) + 1;
        }
        y = x - k;
        if (doubleEnd) {
          footstep = diff_footprint(x, y);
          if (front && (footsteps.containsKey(footstep))) {
            done = true;
          }
          if (!front) {
            footsteps.put(footstep, d);
          }
        }
        while (!done && x < text1_length && y < text2_length
               && text1.charAt(x) == text2.charAt(y)) {
          x++;
          y++;
          if (doubleEnd) {
            footstep = diff_footprint(x, y);
            if (front && (footsteps.containsKey(footstep))) {
              done = true;
            }
            if (!front) {
              footsteps.put(footstep, d);
            }
          }
        }
        v1.put(k, x);
        v_map1.get(d).add(diff_footprint(x, y));
        if (x == text1_length && y == text2_length) {
          // Reached the end in single-path mode.
          return diff_path1(v_map1, text1, text2);
        } else if (done) {
          // Front path ran over reverse path.
          v_map2 = v_map2.subList(0, footsteps.get(footstep) + 1);
          LinkedList<DiffAction> a = diff_path1(v_map1, text1.substring(0, x),
                                          text2.substring(0, y));
          a.addAll(diff_path2(v_map2, text1.substring(x), text2.substring(y)));
          return a;
        }
      }

      if (doubleEnd) {
        // Walk the reverse path one step.
        v_map2.add(new HashSet<Long>());  // Adds at index 'd'.
        for (int k = -d; k <= d; k += 2) {
          if (k == -d || k != d && v2.get(k - 1) < v2.get(k + 1)) {
            x = v2.get(k + 1);
          } else {
            x = v2.get(k - 1) + 1;
          }
          y = x - k;
          footstep = diff_footprint(text1_length - x, text2_length - y);
          if (!front && (footsteps.containsKey(footstep))) {
            done = true;
          }
          if (front) {
            footsteps.put(footstep, d);
          }
          while (!done && x < text1_length && y < text2_length
                 && text1.charAt(text1_length - x - 1)
                 == text2.charAt(text2_length - y - 1)) {
            x++;
            y++;
            footstep = diff_footprint(text1_length - x, text2_length - y);
            if (!front && (footsteps.containsKey(footstep))) {
              done = true;
            }
            if (front) {
              footsteps.put(footstep, d);
            }
          }
          v2.put(k, x);
          v_map2.get(d).add(diff_footprint(x, y));
          if (done) {
            // Reverse path ran over front path.
            v_map1 = v_map1.subList(0, footsteps.get(footstep) + 1);
            LinkedList<DiffAction> a
                = diff_path1(v_map1, text1.substring(0, text1_length - x),
                             text2.substring(0, text2_length - y));
            a.addAll(diff_path2(v_map2, text1.substring(text1_length - x),
                                text2.substring(text2_length - y)));
            return a;
          }
        }
      }
    }
    // Number of diffs equals number of characters, no commonality at all.
    return null;
  }


  /**
   * Work from the middle back to the start to determine the path.
   * @param v_map List of path sets.
   * @param text1 Old string fragment to be diffed.
   * @param text2 New string fragment to be diffed.
   * @return LinkedList of Diff objects.
   */
  protected LinkedList<DiffAction> diff_path1(List<Set<Long>> v_map,
                                        String text1, String text2) {
    LinkedList<DiffAction> path = new LinkedList<DiffAction>();
    int x = text1.length();
    int y = text2.length();
    Operation last_op = null;
    for (int d = v_map.size() - 2; d >= 0; d--) {
      while (true) {
        if (v_map.get(d).contains(diff_footprint(x - 1, y))) {
          x--;
          if (last_op == Operation.DELETE) {
            path.getFirst().text = text1.charAt(x) + path.getFirst().text;
          } else {
            path.addFirst(new DiffAction(Operation.DELETE,
                                   text1.substring(x, x + 1)));
          }
          last_op = Operation.DELETE;
          break;
        } else if (v_map.get(d).contains(diff_footprint(x, y - 1))) {
          y--;
          if (last_op == Operation.INSERT) {
            path.getFirst().text = text2.charAt(y) + path.getFirst().text;
          } else {
            path.addFirst(new DiffAction(Operation.INSERT,
                                   text2.substring(y, y + 1)));
          }
          last_op = Operation.INSERT;
          break;
        } else {
          x--;
          y--;
          assert (text1.charAt(x) == text2.charAt(y))
                 : ""No diagonal.  Can't happen. (diff_path1)"";
          if (last_op == Operation.EQUAL) {
            path.getFirst().text = text1.charAt(x) + path.getFirst().text;
          } else {
            path.addFirst(new DiffAction(Operation.EQUAL, text1.substring(x, x + 1)));
          }
          last_op = Operation.EQUAL;
        }
      }
    }
    return path;
  }


  /**
   * Work from the middle back to the end to determine the path.
   * @param v_map List of path sets.
   * @param text1 Old string fragment to be diffed.
   * @param text2 New string fragment to be diffed.
   * @return LinkedList of Diff objects.
   */
  protected LinkedList<DiffAction> diff_path2(List<Set<Long>> v_map,
                                        String text1, String text2) {
    LinkedList<DiffAction> path = new LinkedList<DiffAction>();
    int x = text1.length();
    int y = text2.length();
    Operation last_op = null;
    for (int d = v_map.size() - 2; d >= 0; d--) {
      while (true) {
        if (v_map.get(d).contains(diff_footprint(x - 1, y))) {
          x--;
          if (last_op == Operation.DELETE) {
            path.getLast().text += text1.charAt(text1.length() - x - 1);
          } else {
            path.addLast(new DiffAction(Operation.DELETE,
                text1.substring(text1.length() - x - 1, text1.length() - x)));
          }
          last_op = Operation.DELETE;
          break;
        } else if (v_map.get(d).contains(diff_footprint(x, y - 1))) {
          y--;
          if (last_op == Operation.INSERT) {
            path.getLast().text += text2.charAt(text2.length() - y - 1);
          } else {
            path.addLast(new DiffAction(Operation.INSERT,
                text2.substring(text2.length() - y - 1, text2.length() - y)));
          }
          last_op = Operation.INSERT;
          break;
        } else {
          x--;
          y--;
          assert (text1.charAt(text1.length() - x - 1)
                  == text2.charAt(text2.length() - y - 1))
                 : ""No diagonal.  Can't happen. (diff_path2)"";
          if (last_op == Operation.EQUAL) {
            path.getLast().text += text1.charAt(text1.length() - x - 1);
          } else {
            path.addLast(new DiffAction(Operation.EQUAL,
                text1.substring(text1.length() - x - 1, text1.length() - x)));
          }
          last_op = Operation.EQUAL;
        }
      }
    }
    return path;
  }


  /**
   * Compute a good hash of two integers.
   * @param x First int.
   * @param y Second int.
   * @return A long made up of both ints.
   */
  protected long diff_footprint(int x, int y) {
    // The maximum size for a long is 9,223,372,036,854,775,807
    // The maximum size for an int is 2,147,483,647
    // Two ints fit nicely in one long.
    long result = x;
    result = result << 32;
    result += y;
    return result;
  }


  /**
   * Determine the common prefix of two strings
   * @param text1 First string.
   * @param text2 Second string.
   * @return The number of characters common to the start of each string.
   */
  public int diff_commonPrefix(String text1, String text2) {
    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    int n = Math.min(text1.length(), text2.length());
    for (int i = 0; i < n; i++) {
      if (text1.charAt(i) != text2.charAt(i)) {
        return i;
      }
    }
    return n;
  }


  /**
   * Determine the common suffix of two strings
   * @param text1 First string.
   * @param text2 Second string.
   * @return The number of characters common to the end of each string.
   */
  public int diff_commonSuffix(String text1, String text2) {
    // Performance analysis: http://neil.fraser.name/news/2007/10/09/
    int text1_length = text1.length();
    int text2_length = text2.length();
    int n = Math.min(text1_length, text2_length);
    for (int i = 1; i <= n; i++) {
      if (text1.charAt(text1_length - i) != text2.charAt(text2_length - i)) {
        return i - 1;
      }
    }
    return n;
  }


  /**
   * Do the two texts share a substring which is at least half the length of
   * the longer text?
   * @param text1 First string.
   * @param text2 Second string.
   * @return Five element String array, containing the prefix of text1, the
   *     suffix of text1, the prefix of text2, the suffix of text2 and the
   *     common middle.  Or null if there was no match.
   */
  protected String[] diff_halfMatch(String text1, String text2) {
    String longtext = text1.length() > text2.length() ? text1 : text2;
    String shorttext = text1.length() > text2.length() ? text2 : text1;
    if (longtext.length() < 10 || shorttext.length() < 1) {
      return null;  // Pointless.
    }

    // First check if the second quarter is the seed for a half-match.
    String[] hm1 = diff_halfMatchI(longtext, shorttext,
                                   (longtext.length() + 3) / 4);
    // Check again based on the third quarter.
    String[] hm2 = diff_halfMatchI(longtext, shorttext,
                                   (longtext.length() + 1) / 2);
    String[] hm;
    if (hm1 == null && hm2 == null) {
      return null;
    } else if (hm2 == null) {
      hm = hm1;
    } else if (hm1 == null) {
      hm = hm2;
    } else {
      // Both matched.  Select the longest.
      hm = hm1[4].length() > hm2[4].length() ? hm1 : hm2;
    }

    // A half-match was found, sort out the return data.
    if (text1.length() > text2.length()) {
      return hm;
      //return new String[]{hm[0], hm[1], hm[2], hm[3], hm[4]};
    } else {
      return new String[]{hm[2], hm[3], hm[0], hm[1], hm[4]};
    }
  }


  /**
   * Does a substring of shorttext exist within longtext such that the
   * substring is at least half the length of longtext?
   * @param longtext Longer string.
   * @param shorttext Shorter string.
   * @param i Start index of quarter length substring within longtext.
   * @return Five element String array, containing the prefix of longtext, the
   *     suffix of longtext, the prefix of shorttext, the suffix of shorttext
   *     and the common middle.  Or null if there was no match.
   */
  private String[] diff_halfMatchI(String longtext, String shorttext, int i) {
    // Start with a 1/4 length substring at position i as a seed.
    String seed = longtext.substring(i, i + longtext.length() / 4);
    int j = -1;
    String best_common = """";
    String best_longtext_a = """", best_longtext_b = """";
    String best_shorttext_a = """", best_shorttext_b = """";
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      int prefixLength = diff_commonPrefix(longtext.substring(i),
                                           shorttext.substring(j));
      int suffixLength = diff_commonSuffix(longtext.substring(0, i),
                                           shorttext.substring(0, j));
      if (best_common.length() < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j)
            + shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length() >= longtext.length() / 2) {
      return new String[]{best_longtext_a, best_longtext_b,
                          best_shorttext_a, best_shorttext_b, best_common};
    } else {
      return null;
    }
  }


  /**
   * Reduce the number of edits by eliminating semantically trivial equalities.
   * @param diffs LinkedList of Diff objects.
   */
  public void diff_cleanupSemantic(LinkedList<DiffAction> diffs) {
    if (diffs.isEmpty()) {
      return;
    }
    boolean changes = false;
    Stack<DiffAction> equalities = new Stack<DiffAction>();  // Stack of qualities.
    String lastequality = null; // Always equal to equalities.lastElement().text
    ListIterator<DiffAction> pointer = diffs.listIterator();
    // Number of characters that changed prior to the equality.
    int length_changes1 = 0;
    // Number of characters that changed after the equality.
    int length_changes2 = 0;
    DiffAction thisDiff = pointer.next();
    while (thisDiff != null) {
      if (thisDiff.operation == Operation.EQUAL) {
        // equality found
        equalities.push(thisDiff);
        length_changes1 = length_changes2;
        length_changes2 = 0;
        lastequality = thisDiff.text;
      } else {
        // an insertion or deletion
        length_changes2 += thisDiff.text.length();
        if (lastequality != null && (lastequality.length() <= length_changes1)
            && (lastequality.length() <= length_changes2)) {
          //System.out.println(""Splitting: '"" + lastequality + ""'"");
          // Walk back to offending equality.
          while (thisDiff != equalities.lastElement()) {
            thisDiff = pointer.previous();
          }
          pointer.next();

          // Replace equality with a delete.
          pointer.set(new DiffAction(Operation.DELETE, lastequality));
          // Insert a corresponding an insert.
          pointer.add(new DiffAction(Operation.INSERT, lastequality));

          equalities.pop();  // Throw away the equality we just deleted.
          if (!equalities.empty()) {
            // Throw away the previous equality (it needs to be reevaluated).
            equalities.pop();
          }
          if (equalities.empty()) {
            // There are no previous equalities, walk back to the start.
            while (pointer.hasPrevious()) {
              pointer.previous();
            }
          } else {
            // There is a safe equality we can fall back to.
            thisDiff = equalities.lastElement();
            while (thisDiff != pointer.previous()) {
              // Intentionally empty loop.
            }
          }

          length_changes1 = 0;  // Reset the counters.
          length_changes2 = 0;
          lastequality = null;
          changes = true;
        }
      }
      thisDiff = pointer.hasNext() ? pointer.next() : null;
    }

    if (changes) {
      diff_cleanupMerge(diffs);
    }
    diff_cleanupSemanticLossless(diffs);
  }


  /**
   * Look for single edits surrounded on both sides by equalities
   * which can be shifted sideways to align the edit to a word boundary.
   * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
   * @param diffs LinkedList of Diff objects.
   */
  public void diff_cleanupSemanticLossless(LinkedList<DiffAction> diffs) {
    String equality1, edit, equality2;
    String commonString;
    int commonOffset;
    int score, bestScore;
    String bestEquality1, bestEdit, bestEquality2;
    // Create a new iterator at the start.
    ListIterator<DiffAction> pointer = diffs.listIterator();
    DiffAction prevDiff = pointer.hasNext() ? pointer.next() : null;
    DiffAction thisDiff = pointer.hasNext() ? pointer.next() : null;
    DiffAction nextDiff = pointer.hasNext() ? pointer.next() : null;
    // Intentionally ignore the first and last element (don't need checking).
    while (nextDiff != null) {
      if (prevDiff.operation == Operation.EQUAL &&
          nextDiff.operation == Operation.EQUAL) {
        // This is a single edit surrounded by equalities.
        equality1 = prevDiff.text;
        edit = thisDiff.text;
        equality2 = nextDiff.text;

        // First, shift the edit as far left as possible.
        commonOffset = diff_commonSuffix(equality1, edit);
        if (commonOffset != 0) {
          commonString = edit.substring(edit.length() - commonOffset);
          equality1 = equality1.substring(0, equality1.length() - commonOffset);
          edit = commonString + edit.substring(0, edit.length() - commonOffset);
          equality2 = commonString + equality2;
        }

        // Second, step character by character right, looking for the best fit.
        bestEquality1 = equality1;
        bestEdit = edit;
        bestEquality2 = equality2;
        bestScore = diff_cleanupSemanticScore(equality1, edit)
            + diff_cleanupSemanticScore(edit, equality2);
        while (edit.length() > 0 && equality2.length() > 0
            && edit.charAt(0) == equality2.charAt(0)) {
          equality1 += edit.charAt(0);
          edit = edit.substring(1) + equality2.charAt(0);
          equality2 = equality2.substring(1);
          score = diff_cleanupSemanticScore(equality1, edit)
              + diff_cleanupSemanticScore(edit, equality2);
          // The >= encourages trailing rather than leading whitespace on edits.
          if (score >= bestScore) {
            bestScore = score;
            bestEquality1 = equality1;
            bestEdit = edit;
            bestEquality2 = equality2;
          }
        }

        if (!prevDiff.text.equals(bestEquality1)) {
          // We have an improvement, save it back to the diff.
          if (bestEquality1.length() > 0) {
            prevDiff.text = bestEquality1;
          } else {
            pointer.previous(); // Walk past nextDiff.
            pointer.previous(); // Walk past thisDiff.
            pointer.previous(); // Walk past prevDiff.
            pointer.remove(); // Delete prevDiff.
            pointer.next(); // Walk past thisDiff.
            pointer.next(); // Walk past nextDiff.
          }
          thisDiff.text = bestEdit;
          if (bestEquality2.length() > 0) {
            nextDiff.text = bestEquality2;
          } else {
            pointer.remove(); // Delete nextDiff.
            nextDiff = thisDiff;
            thisDiff = prevDiff;
          }
        }
      }
      prevDiff = thisDiff;
      thisDiff = nextDiff;
      nextDiff = pointer.hasNext() ? pointer.next() : null;
    }
  }


  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 5 (best) to 0 (worst).
   * @param one First string.
   * @param two Second string.
   * @return The score.
   */
  private int diff_cleanupSemanticScore(String one, String two) {
    if (one.length() == 0 || two.length() == 0) {
      // Edges are the best.
      return 5;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    int score = 0;
    // One point for non-alphanumeric.
    if (!Character.isLetterOrDigit(one.charAt(one.length() - 1))
        || !Character.isLetterOrDigit(two.charAt(0))) {
      score++;
      // Two points for whitespace.
      if (Character.isWhitespace(one.charAt(one.length() - 1))
          || Character.isWhitespace(two.charAt(0))) {
        score++;
        // Three points for line breaks.
        if (Character.getType(one.charAt(one.length() - 1)) == Character.CONTROL
            || Character.getType(two.charAt(0)) == Character.CONTROL) {
          score++;
          // Four points for blank lines.
          if (BLANKLINEEND.matcher(one).find()
              || BLANKLINESTART.matcher(two).find()) {
            score++;
          }
        }
      }
    }
    return score;
  }


  private Pattern BLANKLINEEND
      = Pattern.compile(""\\n\\r?\\n\\Z"", Pattern.DOTALL);
  private Pattern BLANKLINESTART
      = Pattern.compile(""\\A\\r?\\n\\r?\\n"", Pattern.DOTALL);


  /**
   * Reorder and merge like edit sections.  Merge equalities.
   * Any edit section can move as long as it doesn't cross an equality.
   * @param diffs LinkedList of Diff objects.
   */
  public void diff_cleanupMerge(LinkedList<DiffAction> diffs) {
    diffs.add(new DiffAction(Operation.EQUAL, """"));  // Add a dummy entry at the end.
    ListIterator<DiffAction> pointer = diffs.listIterator();
    int count_delete = 0;
    int count_insert = 0;
    String text_delete = """";
    String text_insert = """";
    DiffAction thisDiff = pointer.next();
    DiffAction prevEqual = null;
    int commonlength;
    while (thisDiff != null) {
      switch (thisDiff.operation) {
      case INSERT:
        count_insert++;
        text_insert += thisDiff.text;
        prevEqual = null;
        break;
      case DELETE:
        count_delete++;
        text_delete += thisDiff.text;
        prevEqual = null;
        break;
      case EQUAL:
        if (count_delete != 0 || count_insert != 0) {
          // Delete the offending records.
          pointer.previous();  // Reverse direction.
          while (count_delete-- > 0) {
            pointer.previous();
            pointer.remove();
          }
          while (count_insert-- > 0) {
            pointer.previous();
            pointer.remove();
          }
          if (count_delete != 0 && count_insert != 0) {
            // Factor out any common prefixies.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength != 0) {
              if (pointer.hasPrevious()) {
                thisDiff = pointer.previous();
                assert thisDiff.operation == Operation.EQUAL
                       : ""Previous diff should have been an equality."";
                thisDiff.text += text_insert.substring(0, commonlength);
                pointer.next();
              } else {
                pointer.add(new DiffAction(Operation.EQUAL,
                    text_insert.substring(0, commonlength)));
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength != 0) {
              thisDiff = pointer.next();
              thisDiff.text = text_insert.substring(text_insert.length()
                  - commonlength) + thisDiff.text;
              text_insert = text_insert.substring(0, text_insert.length()
                  - commonlength);
              text_delete = text_delete.substring(0, text_delete.length()
                  - commonlength);
              pointer.previous();
            }
          }
          // Insert the merged records.
          if (text_delete.length() > 0) {
            pointer.add(new DiffAction(Operation.DELETE, text_delete));
          }
          if (text_insert.length() > 0) {
            pointer.add(new DiffAction(Operation.INSERT, text_insert));
          }
          // Step forward to the equality.
          thisDiff = pointer.hasNext() ? pointer.next() : null;
        } else if (prevEqual != null) {
          // Merge this equality with the previous one.
          prevEqual.text += thisDiff.text;
          pointer.remove();
          thisDiff = pointer.previous();
          pointer.next();  // Forward direction
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = """";
        text_insert = """";
        prevEqual = thisDiff;
        break;
      }
      thisDiff = pointer.hasNext() ? pointer.next() : null;
    }
    // System.out.println(diff);
    if (diffs.getLast().text.length() == 0) {
      diffs.removeLast();  // Remove the dummy entry at the end.
    }

    /*
     * Second pass: look for single edits surrounded on both sides by equalities
     * which can be shifted sideways to eliminate an equality.
     * e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
     */
    boolean changes = false;
    // Create a new iterator at the start.
    // (As opposed to walking the current one back.)
    pointer = diffs.listIterator();
    DiffAction prevDiff = pointer.hasNext() ? pointer.next() : null;
    thisDiff = pointer.hasNext() ? pointer.next() : null;
    DiffAction nextDiff = pointer.hasNext() ? pointer.next() : null;
    // Intentionally ignore the first and last element (don't need checking).
    while (nextDiff != null) {
      if (prevDiff.operation == Operation.EQUAL &&
          nextDiff.operation == Operation.EQUAL) {
        // This is a single edit surrounded by equalities.
        if (thisDiff.text.endsWith(prevDiff.text)) {
          // Shift the edit over the previous equality.
          thisDiff.text = prevDiff.text
              + thisDiff.text.substring(0, thisDiff.text.length()
                                           - prevDiff.text.length());
          nextDiff.text = prevDiff.text + nextDiff.text;
          pointer.previous(); // Walk past nextDiff.
          pointer.previous(); // Walk past thisDiff.
          pointer.previous(); // Walk past prevDiff.
          pointer.remove(); // Delete prevDiff.
          pointer.next(); // Walk past thisDiff.
          thisDiff = pointer.next(); // Walk past nextDiff.
          nextDiff = pointer.hasNext() ? pointer.next() : null;
          changes = true;
        } else if (thisDiff.text.startsWith(nextDiff.text)) {
          // Shift the edit over the next equality.
          prevDiff.text += nextDiff.text;
          thisDiff.text = thisDiff.text.substring(nextDiff.text.length())
              + nextDiff.text;
          pointer.remove(); // Delete nextDiff.
          nextDiff = pointer.hasNext() ? pointer.next() : null;
          changes = true;
        }
      }
      prevDiff = thisDiff;
      thisDiff = nextDiff;
      nextDiff = pointer.hasNext() ? pointer.next() : null;
    }
    // If shifts were made, the diff needs reordering and another shift sweep.
    if (changes) {
      diff_cleanupMerge(diffs);
    }
  }


  /**
   * Convert a Diff list into a pretty HTML report.
   * @param diffs LinkedList of Diff objects.
   * @return HTML representation.
   */
  public String diff_prettyHtml(LinkedList<DiffAction> diffs) {
    StringBuilder html = new StringBuilder();
    int i = 0;
    for (DiffAction aDiff : diffs) {
      String text = aDiff.text.replace(""&"", ""&amp;"").replace(""<"", ""&lt;"")
          .replace("">"", ""&gt;"").replace(""\n"", ""<br>"");
      switch (aDiff.operation) {
      case INSERT:
    	  String spaces = """";
    	  int l = text.length();
    	  for(int j = 0; j < l; j++) spaces += ""&nbsp;"";
        html.append(""<span style=\""background:"" + WRONG_COLOR + "";\"">"").
        	append(spaces).append(""</span>"");
        break;
      case DELETE:
        html.append(""<span style=\""background:"" + WRONG_COLOR + "";\"">"").
        	append(text).append(""</span>"");
        break;
      case EQUAL:
        html.append(""<span style=\""background:"" + RIGHT_COLOR + "";\"">"").
        	append(text).append(""</span>"");
        break;
      }
      if (aDiff.operation != Operation.DELETE) {
        i += aDiff.text.length();
      }
    }
    return html.toString();
  }


  /**
   * Class representing one diff operation.
   */
  public static class DiffAction {
    /**
     * One of: INSERT, DELETE or EQUAL.
     */
    public Operation operation;
    /**
     * The text associated with this diff operation.
     */
    public String text;

    /**
     * Constructor.  Initializes the diff with the provided values.
     * @param operation One of INSERT, DELETE or EQUAL.
     * @param text The text being applied.
     */
    public DiffAction(Operation operation, String text) {
      // Construct a diff with the specified operation and text.
      this.operation = operation;
      this.text = text;
    }


    /**
     * Display a human-readable version of this Diff.
     * @return text version.
     */
    @Override
    public String toString() {
      String prettyText = this.text.replace('\n', '\u00b6');
      return ""Diff("" + this.operation + "",\"""" + prettyText + ""\"")"";
    }


    /**
     * Is this Diff equivalent to another Diff?
     * @param d Another Diff to compare against.
     * @return true or false.
     */
    @Override
    public boolean equals(Object d) {
      try {
        return (((DiffAction) d).operation == this.operation)
               && (((DiffAction) d).text.equals(this.text));
      } catch (ClassCastException e) {
        return false;
      }
    }
  }
}
",True,4,20,6,5,0,0
31,com.ichi2.veecheck.CheckService.java,"/****************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.veecheck;

import android.content.Intent;
import android.content.IntentFilter;

import com.ichi2.anki.R;
import com.tomgibara.android.veecheck.VeecheckNotifier;
import com.tomgibara.android.veecheck.VeecheckService;
import com.tomgibara.android.veecheck.VeecheckState;
import com.tomgibara.android.veecheck.util.DefaultNotifier;
import com.tomgibara.android.veecheck.util.PrefState;

public class CheckService extends VeecheckService {

	public static final int NOTIFICATION_ID = 1;

	@Override
	protected VeecheckNotifier createNotifier() {
		IntentFilter[] filters = new IntentFilter[1];

		IntentFilter filter = new IntentFilter(Intent.ACTION_VIEW);
		filter.addDataScheme(""http"");
		filters[0] = filter;

		return new DefaultNotifier(this, NOTIFICATION_ID, filters,
					new Intent(this, Notification.class),
					R.drawable.anki,
					R.string.notify_ticker,
					R.string.notify_title,
					R.string.notify_message);
	}

	@Override
	protected VeecheckState createState() {
		return new PrefState(this);
	}

}
",False,47,12,0,0,3,5
32,com.ichi2.veecheck.Notification.java,"/****************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.veecheck;

import android.os.Bundle;
import android.view.View;
import android.widget.Checkable;

import com.ichi2.anki.R;
import com.tomgibara.android.veecheck.VeecheckActivity;
import com.tomgibara.android.veecheck.VeecheckState;
import com.tomgibara.android.veecheck.util.PrefState;

public class Notification extends VeecheckActivity {

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.notification);
	}

	@Override
	protected VeecheckState createState() {
		return new PrefState(this);
	}

	@Override
	protected View getNoButton() {
		return findViewById(R.id.no);
	}

	@Override
	protected View getYesButton() {
		return findViewById(R.id.yes);
	}

	@Override
	protected Checkable getStopCheckBox() {
		return (Checkable) findViewById(R.id.stop);
	}
}
",False,11,4,0,0,1,3
33,com.ichi2.veecheck.CheckReceiver.java,"/****************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.veecheck;

import android.content.Context;

import com.tomgibara.android.veecheck.VeecheckReceiver;
import com.tomgibara.android.veecheck.VeecheckSettings;
import com.tomgibara.android.veecheck.VeecheckState;
import com.tomgibara.android.veecheck.util.PrefSettings;
import com.tomgibara.android.veecheck.util.PrefState;

public class CheckReceiver extends VeecheckReceiver {

	@Override
	protected VeecheckSettings createSettings(Context context) {
		return new PrefSettings(context);
	}

	@Override
	protected VeecheckState createState(Context context) {
		return new PrefState(context);
	}

}
",False,28,7,0,0,2,5
34,com.ichi2.async.Connection.java,"/***************************************************************************************
* Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
*                                                                                      *
* This program is free software; you can redistribute it and/or modify it under        *
* the terms of the GNU General Public License as published by the Free Software        *
* Foundation; either version 3 of the License, or (at your option) any later           *
* version.                                                                             *
*                                                                                      *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
* PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
*                                                                                      *
* You should have received a copy of the GNU General Public License along with         *
* this program.  If not, see <http://www.gnu.org/licenses/>.                           *
****************************************************************************************/

package com.ichi2.async;

import android.content.Context;
import android.net.ConnectivityManager;
import android.os.AsyncTask;
import android.util.Log;

import com.ichi2.anki.AnkiDroidProxy;
import com.ichi2.anki.SharedDeck;

public class Connection extends AsyncTask<Connection.Payload, Object, Connection.Payload>
{
    public static final String TAG = ""Connection"";
    public static Context context;
    
    public static final int TASK_TYPE_GET_SHARED_DECKS = 0;
    public static final int TASK_TYPE_DOWNLOAD_SHARED_DECK = 1;

	private static Connection instance;
	private TaskListener listener;
	
	private static Connection launchConnectionTask(TaskListener listener, Payload data)
	{
		if(!isOnline())
		{
			data.success = false;
			listener.onDisconnected();
			return null;
		}
		try
		{
			if ((instance != null) && (instance.getStatus() != AsyncTask.Status.FINISHED))
				instance.get();
		} catch (Exception e)
		{
			e.printStackTrace();
		}

		instance = new Connection();
		instance.listener = listener;

		return (Connection)instance.execute(data);
	}
	
	   /*
     * Runs on GUI thread
     */
    protected void onPreExecute() 
    {
    	listener.onPreExecute();
    }

    /*
     * Runs on GUI thread
     */
    public void onPostExecute(Payload data)
    {
    	listener.onPostExecute(data);
    }

    /*
     * Runs on GUI thread
     */
    public void onProgressUpdate(Object... values)
    {
    	listener.onProgressUpdate(values);
    }
    
	public static Connection getSharedDecks(TaskListener listener, Payload data)
	{
		data.taskType = TASK_TYPE_GET_SHARED_DECKS;
		return launchConnectionTask(listener, data);
	}
	
	public static Connection downloadSharedDeck(TaskListener listener, Payload data)
	{
		data.taskType = TASK_TYPE_DOWNLOAD_SHARED_DECK;
		return launchConnectionTask(listener, data);
	}
	
	@Override
	protected Payload doInBackground(Payload... params) {
		Payload data = params[0];
		
		switch(data.taskType)
		{
			case TASK_TYPE_GET_SHARED_DECKS:
				return doInBackgroundGetSharedDecks(data);

			case TASK_TYPE_DOWNLOAD_SHARED_DECK:
				return doInBackgroundDownloadSharedDeck(data);
				
			default:
				return null;
		}
	}

	private Payload doInBackgroundGetSharedDecks(Payload data)
	{
		try {
			data.result = AnkiDroidProxy.getSharedDecks();
		} catch (Exception e) {
			data.success = false;
			data.exception = e;
			Log.e(TAG, ""Error getting shared decks = "" + e.getMessage());
			e.printStackTrace();
		}
		return data;
	}

	private Payload doInBackgroundDownloadSharedDeck(Payload data)
	{
		try {
			data.result = AnkiDroidProxy.downloadSharedDeck((SharedDeck)data.data[0], (String)data.data[1]);
		} catch (Exception e) {
			data.success = false;
			data.exception = e;
			Log.e(TAG, ""Error downloading shared deck = "" + e.getMessage());
			e.printStackTrace();
		}
		return data;
	}
	
	public static boolean isOnline() 
	{
		 ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
		 
		 if(cm.getActiveNetworkInfo() != null)
			 return cm.getActiveNetworkInfo().isConnectedOrConnecting();
		 else return false;
	}

	public static void setContext(Context applicationContext)
	{
		context = applicationContext;
	}
	
	public static interface TaskListener
	{
		public void onPreExecute();

		public void onProgressUpdate(Object... values);
		
		public void onPostExecute(Payload data);
		
		public void onDisconnected();
	}
	
    public static class Payload
    {
        public int taskType;
        public Object[] data;
        public Object result;
        public boolean success;
        public int errorType;
        public Exception exception;

        public Payload(Object[] data) {
        	this.data = data;
        	this.success = true;
        }
        
        public Payload(int taskType, Object[] data) {
            this.taskType = taskType;
            this.data = data;
            this.success = true;
        }
    }
}

",True,26,27,1,1,6,8
