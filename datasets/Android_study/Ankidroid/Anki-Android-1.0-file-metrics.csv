,file_path,source_code,is_vulnerable,id, size, upperDepth, upperWidth, lowerDepth, lowerWidth
0,com.ichi2.themes.StyledDialog.java,"/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * based on custom Dialog windows by antoine vianey                                     *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.themes;

import android.app.Dialog;
import android.content.Context;
import android.content.DialogInterface;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup.LayoutParams;
import android.view.WindowManager.BadTokenException;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
 

public class StyledDialog extends Dialog {

	private Context mContext;
	private List<String> mItemList;
	private boolean[] mCheckedItems;
	private ArrayAdapter<String> mListAdapter;
	private OnClickListener mListener;
	private ListView mListView;
	private boolean mDoNotShow = false;
	private static Method mSetScrollbarBarFading;
	private static boolean mSetScrollBarFading = true;


    public StyledDialog(Context context) {
        super(context, R.style.StyledDialog);
        mContext = context;
    }


    @Override
    public void show() {
    	try {
    		super.show();
    	} catch (BadTokenException e) {
    		Log.e(AnkiDroidApp.TAG, ""Could not show dialog: "" + e);
    	}
    }


    // @Override  On Android 1.5 this is not Override
    public void onAttachedToWindow() {
    	if (mDoNotShow) {
        	this.dismiss();
    	}
    }


    public void setMessage(CharSequence message) {
    	View main = super.getWindow().getDecorView();
    	((TextView) main.findViewById(R.id.message)).setText(message);
        ((View) main.findViewById(R.id.contentPanel)).setVisibility(View.VISIBLE);
    }


    public void setTitle(String message) {
    	View main = super.getWindow().getDecorView();
    	((TextView) main.findViewById(R.id.alertTitle)).setText(message);
    }


    public void setMessage(String message) {
    	View main = super.getWindow().getDecorView();
    	((TextView) main.findViewById(R.id.message)).setText(message);
        ((View) main.findViewById(R.id.contentPanel)).setVisibility(View.VISIBLE);
    }


    public void setEnabled(boolean enabled) {
    	mDoNotShow = !enabled;
    }


    public void setItems(int type, ListView listview, String[] values, int checkedItem, boolean[] checked, DialogInterface.OnClickListener listener) {
    	mListView = listview;
	if (mSetScrollBarFading) {
            try {
		mSetScrollbarBarFading = ListView.class.getMethod(""setScrollbarFadingEnabled"", boolean.class);
            	mSetScrollbarBarFading.invoke(mListView, false);
            } catch (Throwable e) {
            	// Log.i(AnkiDroidApp.TAG, ""setScrollbarFadingEnabled could not be set due to a too low Android version (< 2.1)"");
		mSetScrollBarFading = false;
            }
	}
    	mItemList = new ArrayList<String>();
        for (String titel : values) {
        	mItemList.add(titel);
        }
        mListener = listener;
    	if (type == 3) {
	        mListView.setOnItemClickListener(new OnItemClickListener() {
    				@Override    
    				public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
    						mListener.onClick(StyledDialog.this, position);
    			    	}
			    });
    	} else {
	        mListView.setOnItemClickListener(new OnItemClickListener() {
    				@Override    
    				public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
    						mListener.onClick(StyledDialog.this, position);
						StyledDialog.this.dismiss();
    			    	}
			    });
    	}
    	switch (type) {
    	case 1:
    		mListAdapter = new ArrayAdapter<String>(mContext, R.layout.select_dialog_nochoice, 0, mItemList);
    		mListView.setAdapter(mListAdapter);
    		mListView.setChoiceMode(ListView.CHOICE_MODE_NONE);
	    	break;
    	case 2:
    		mListAdapter = new ArrayAdapter<String>(mContext, R.layout.select_dialog_singlechoice, 0, mItemList);
    		mListView.setAdapter(mListAdapter);
    		mListView.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
    		mListView.setItemChecked(checkedItem, true);
        	break;
    	case 3:
    		mListAdapter = new ArrayAdapter<String>(mContext, R.layout.select_dialog_multichoice, 0, mItemList);
    		mListView.setAdapter(mListAdapter);
    		mListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);
	    	for (int i = 0; i < checked.length; i++) {
	    		listview.setItemChecked(i, checked[i]);
	    	}
	    	break;
    	}
    }


    public Button getButton(int which) {
    	switch (which) {
    	case Dialog.BUTTON_POSITIVE:
    		return (Button) super.getWindow().getDecorView().findViewById(R.id.button1);
    	case Dialog.BUTTON_NEGATIVE:
    		return (Button) super.getWindow().getDecorView().findViewById(R.id.button2);
    	case Dialog.BUTTON_NEUTRAL:
    		return (Button) super.getWindow().getDecorView().findViewById(R.id.button3);
		default:
    		return null;
    	}
    }


    public void addMultiChoiceItems(String value, boolean checked) {
    	mItemList.add(0, value);
    	mListView.setItemChecked(0, checked);
    	boolean[] newChecked = new boolean[mItemList.size()];
    	newChecked[0] = checked;
    	for (int i = 1; i < mItemList.size(); i++) {
    		boolean c = mCheckedItems[i-1];
    		mListView.setItemChecked(i, c);
    		newChecked[i] = c;
    	}
    	mCheckedItems = newChecked;
    	mListAdapter.notifyDataSetChanged();
    }


    public void setMultiChoiceItems(String[] values, boolean[] checked, DialogInterface.OnClickListener listener) {
    	View main = super.getWindow().getDecorView();
    	mCheckedItems = checked;
        ((View) main.findViewById(R.id.listViewPanel)).setVisibility(View.VISIBLE);
    	setItems(3, (ListView) super.getWindow().getDecorView().findViewById(R.id.listview), values, 0, mCheckedItems, listener);
	}


    public void changeListItem(int position, String text) {
    	mItemList.remove(position);
    	mItemList.add(position, text);
    	mListAdapter.notifyDataSetChanged();
    }


    public static class Builder {
 
        private Context context;
        private String title;
        private String message;
        private String positiveButtonText;
        private String negativeButtonText;
        private String neutralButtonText;
        private View contentView;
        private int bottomMargin = 0;
        private boolean brightViewBackground = false;
        private int icon = 0;
 
        private DialogInterface.OnClickListener positiveButtonClickListener;
        private DialogInterface.OnClickListener negativeButtonClickListener;
        private DialogInterface.OnClickListener neutralButtonClickListener;
        private DialogInterface.OnCancelListener cancelListener;
        private DialogInterface.OnDismissListener dismissListener;
        private boolean cancelable = true;

        private String[] itemTitels;
        private int checkedItem;
        private boolean[] multipleCheckedItems;
        private int listStyle = 0;
        private DialogInterface.OnClickListener itemClickListener;
 

        public Builder(Context context) {
            this.context = context;
        }


        /**
         * Set the Dialog message from String
         * @param title
         * @return
         */
        public Builder setMessage(String message) {
            this.message = message;
            return this;
        }


        /**
         * Set the Dialog message from resource
         * @param title
         * @return
         */
        public Builder setMessage(int message) {
            this.message = (String) context.getText(message);
            return this;
        }
 

        public Builder setIcon(int icon) {
            this.icon = icon;
            return this;
        }


        /**
         * Set the Dialog title from resource
         * @param title
         * @return
         */
        public Builder setTitle(int title) {
            this.title = (String) context.getText(title);
            return this;
        }


        /**
         * Set the Dialog title from String
         * @param title
         * @return
         */
        public Builder setTitle(String title) {
            this.title = title;
            return this;
        }


        /**
         * Set a custom content view for the Dialog.
         * If a message is set, the contentView is not
         * added to the Dialog...
         * @param v
         * @return
         */
        public Builder setContentView(View v) {
            this.contentView = v;
            return this;
        }
 

        public Builder setView(View v) {
        	return setView(v, false);
        }
        public Builder setView(View v, boolean isSingleView) {
        	return setView(v, isSingleView, false);
        }
        public Builder setView(View v, boolean isSingleView, boolean bright) {
            this.contentView = v;
        	this.bottomMargin = isSingleView ? 5 : 0;
            this.brightViewBackground = bright;
            return this;
        }


        /**
         * Set the positive button resource and it's listener
         * @param positiveButtonText
         * @param listener
         * @return
         */
        public Builder setPositiveButton(int positiveButtonText,
                DialogInterface.OnClickListener listener) {
            this.positiveButtonText = (String) context
                    .getText(positiveButtonText);
            this.positiveButtonClickListener = listener;
            return this;
        }


        /**
         * Set the positive button text and it's listener
         * @param positiveButtonText
         * @param listener
         * @return
         */
        public Builder setPositiveButton(String positiveButtonText,
                DialogInterface.OnClickListener listener) {
            this.positiveButtonText = positiveButtonText;
            this.positiveButtonClickListener = listener;
            return this;
        }


        /**
         * Set the negative button resource and it's listener
         * @param negativeButtonText
         * @param listener
         * @return
         */
        public Builder setNegativeButton(int negativeButtonText,
                DialogInterface.OnClickListener listener) {
            this.negativeButtonText = (String) context
                    .getText(negativeButtonText);
            this.negativeButtonClickListener = listener;
            return this;
        }


        /**
         * Set the negative button text and it's listener
         * @param negativeButtonText
         * @param listener
         * @return
         */
        public Builder setNegativeButton(String negativeButtonText,
                DialogInterface.OnClickListener listener) {
            this.negativeButtonText = negativeButtonText;
            this.negativeButtonClickListener = listener;
            return this;
        }


        /**
         * Set the neutral button resource and it's listener
         * @param neutralButtonText
         * @param listener
         * @return
         */
        public Builder setNeutralButton(int neutralButtonText,
                DialogInterface.OnClickListener listener) {
            this.neutralButtonText = (String) context
                    .getText(neutralButtonText);
            this.neutralButtonClickListener = listener;
            return this;
        }


        /**
         * Set the neutral button text and it's listener
         * @param neutralButtonText
         * @param listener
         * @return
         */
        public Builder setNeutralButton(String neutralButtonText,
                DialogInterface.OnClickListener listener) {
            this.neutralButtonText = neutralButtonText;
            this.neutralButtonClickListener = listener;
            return this;
        }


        public Builder setOnCancelListener(DialogInterface.OnCancelListener listener) {
            this.cancelListener = listener;
            return this;
        }


        public Builder setOnDismissListener(DialogInterface.OnDismissListener listener) {
            this.dismissListener = listener;
            return this;
        }


        public Builder setCancelable(boolean cancelable) {
            this.cancelable = cancelable;
            return this;
        }


        public Builder setItems(String[] values, DialogInterface.OnClickListener listener) {
        	this.itemTitels = values;
        	this.itemClickListener = listener;
        	this.listStyle = 1;
        	return this;
        }


        public Builder setSingleChoiceItems(String[] values, int checked, DialogInterface.OnClickListener listener) {
        	this.itemTitels = values;
        	this.checkedItem = checked;
        	this.itemClickListener = listener;
        	this.listStyle = 2;
        	return this;
        }


        public Builder setMultiChoiceItems(String[] values, boolean[] checked, DialogInterface.OnClickListener listener) {
        	this.itemTitels = values;
        	this.multipleCheckedItems = checked;
        	this.itemClickListener = listener;
        	this.listStyle = 3;
        	return this;
        }


        /**
         * Create the styled dialog
         */
        public StyledDialog create() {
            final StyledDialog dialog = new StyledDialog(context);
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

            View layout = inflater.inflate(R.layout.styled_dialog, null);
            dialog.addContentView(layout, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT));

            // set title
            if (title != null && title.length() > 0) {
                ((TextView) layout.findViewById(R.id.alertTitle)).setText(title);            	
                if (icon != 0) {
                    ((ImageView) layout.findViewById(R.id.icon)).setImageResource(icon);            	
                } else {
                	layout.findViewById(R.id.icon).setVisibility(View.GONE);
                }
            } else {
            	layout.findViewById(R.id.topPanel).setVisibility(View.GONE);
            }

            // set buttons
            int numberOfButtons = 0;
            if (positiveButtonText != null) {
                Button button1 = (Button) layout.findViewById(R.id.button1);
                button1.setText(positiveButtonText);
                button1.setOnClickListener(
                        new OnClickForwarder(dialog, DialogInterface.BUTTON_POSITIVE, positiveButtonClickListener));
                numberOfButtons++;
            } else {
                layout.findViewById(R.id.button1).setVisibility(View.GONE);
            }
            if (negativeButtonText != null) {
                Button button2 = (Button) layout.findViewById(R.id.button2);
                button2.setText(negativeButtonText);
                button2.setOnClickListener(
                        new OnClickForwarder(dialog, DialogInterface.BUTTON_NEGATIVE, negativeButtonClickListener));
                numberOfButtons++;
            } else {
                layout.findViewById(R.id.button2).setVisibility(View.GONE);
            }
            if (neutralButtonText != null) {
                Button button3 = (Button) layout.findViewById(R.id.button3);
                button3.setText(neutralButtonText);
                button3.setOnClickListener(
                        new OnClickForwarder(dialog, DialogInterface.BUTTON_NEUTRAL, neutralButtonClickListener));
                numberOfButtons++;
            } else {
                layout.findViewById(R.id.button3).setVisibility(View.GONE);
            }
            if (numberOfButtons == 0) {
            	layout.findViewById(R.id.buttonPanel).setVisibility(View.GONE);
            }

            dialog.setCancelable(cancelable);
            dialog.setOnCancelListener(cancelListener);
            
            dialog.setOnDismissListener(dismissListener);

            // set the message
            if (message != null) {
                ((TextView) layout.findViewById(R.id.message)).setText(message);
            } else {
            	((LinearLayout) layout.findViewById(R.id.contentPanel)).setVisibility(View.GONE);
            }

            // set single and multiple choice listview
            if (itemTitels != null) {
            	dialog.setItems(listStyle, (ListView) layout.findViewById(R.id.listview), itemTitels, checkedItem, multipleCheckedItems, itemClickListener);
                // ((View) layout.findViewById(R.id.titleDivider)).setVisibility(View.GONE);
            } else {
            	((View) layout.findViewById(R.id.listViewPanel)).setVisibility(View.GONE);
            }

            // set a custom view
            if (contentView != null) {
            	FrameLayout frame = (FrameLayout) layout.findViewById(R.id.custom);
            	float factor = context.getResources().getDisplayMetrics().density;
        		frame.setPadding((int)(2 * factor), (int)((5  - bottomMargin) * factor), (int)(2 * factor), (int)(bottomMargin * factor));
            	frame.removeAllViews();
            	frame.addView(contentView);
            } else {
            	((View) layout.findViewById(R.id.customPanel)).setVisibility(View.GONE);
            }

            // set background
            try {
            	Themes.setStyledDialogBackgrounds(layout, numberOfButtons, brightViewBackground);
            } catch (OutOfMemoryError e) {
            	Log.e(AnkiDroidApp.TAG, ""StyledDialog - Dialog could not be created: "" + e);
            	Themes.showThemedToast(context, context.getResources().getString(R.string.error_insufficient_memory), false);
            	return null;
            }

            dialog.setContentView(layout);
            return dialog;
        }
 

        public void show() {
        	create().show();
        }

    }


    private static class OnClickForwarder implements View.OnClickListener {

        private final DialogInterface mDialog;
        private final int mWhich;
        private final DialogInterface.OnClickListener mListener;


        public OnClickForwarder(DialogInterface dialog, int which, DialogInterface.OnClickListener listener) {
            mDialog = dialog;
            mWhich = which;
            mListener = listener;
        }


        @Override
        public void onClick(View view) {
            if (mListener != null) {
                mListener.onClick(mDialog, mWhich);
            }
            mDialog.dismiss();
        }
    }
}
",True,29,66,1,3,5,26
1,com.ichi2.themes.Themes.java,"/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.themes;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.tomgibara.android.veecheck.util.PrefSettings;

import android.content.Context;
import android.content.SharedPreferences;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.graphics.Color;
import android.util.Log;
import android.view.View;
import android.webkit.WebView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

public class Themes {

	public final static int THEME_ANDROID_DARK = 0;
	public final static int THEME_ANDROID_LIGHT = 1;
	public final static int THEME_BLUE = 2;

	public final static int CALLER_STUDYOPTIONS = 1;
	public final static int CALLER_DECKPICKER_DECK = 3;
	public final static int CALLER_REVIEWER= 4;
	public final static int CALLER_FEEDBACK= 5;
	public final static int CALLER_DOWNLOAD_DECK= 6;
	public final static int CALLER_DECKPICKER = 7;
	public final static int CALLER_CARDBROWSER = 8;

	private static int mCurrentTheme = -1;
	private static int mProgressbarsBackgroundColor;
	private static int mProgressbarsFrameColor;
	private static int mProgressbarsMatureColor;
	private static int mProgressbarsYoungColor;
	private static int mProgressbarsDeckpickerYoungColor;
	private static int mReviewerBackground = 0;
	private static int mReviewerProgressbar = 0;
	private static int mFlashcardBorder = 0;
	private static int mDeckpickerItemBorder = 0;
	private static int mTitleStyle = 0;
	private static int mTextViewStyle= 0;
	private static int mWallpaper = 0;
	private static int mBackgroundColor;
	private static int mBackgroundDarkColor = 0;
	private static int mDialogBackgroundColor = 0;
	private static int mToastBackground = 0;
	private static int[] mCardbrowserItemBorder;
	private static int[] mChartColors;
	private static int mPopupTopDark;
	private static int mPopupTopMedium;
	private static int mPopupTopBright;
	private static int mPopupCenterDark;
	private static int mPopupCenterBright;
	private static int mPopupCenterMedium;
	private static int mPopupBottomDark;
	private static int mPopupBottomBright;
	private static int mPopupBottomMedium;
	private static int mPopupFullDark;
	private static int mPopupFullMedium;
	private static int mPopupFullBright;
	private static int mDividerHorizontalBright;

	private static Context mContext;

	public static void applyTheme(Context context) {
		mContext = context;
		if (mCurrentTheme == -1) {
			loadTheme();
		}
		switch (mCurrentTheme) {
		case THEME_ANDROID_DARK:
			context.setTheme(R.style.Theme_Black);
			// Log.i(AnkiDroidApp.TAG, ""Set theme: dark"");
			break;
		case THEME_ANDROID_LIGHT:
			context.setTheme(R.style.Theme_Light);
			// Log.i(AnkiDroidApp.TAG, ""Set theme: light"");
			break;
		case THEME_BLUE:
			context.setTheme(R.style.Theme_Blue);
			// Log.i(AnkiDroidApp.TAG, ""Set theme: blue"");
			break;
		}
	}


	public static void setContentStyle(View view, int caller) {
		if (mCurrentTheme == THEME_ANDROID_DARK) {
			return;
		}
		switch (caller) {
		case CALLER_STUDYOPTIONS:
			((View) view.findViewById(R.id.studyoptions_progressbar1_border)).setBackgroundResource(mProgressbarsFrameColor);
			((View) view.findViewById(R.id.studyoptions_progressbar2_border)).setBackgroundResource(mProgressbarsFrameColor);
			((View) view.findViewById(R.id.studyoptions_global_limit_bars)).setBackgroundResource(mProgressbarsFrameColor);
			((View) view.findViewById(R.id.studyoptions_progressbar4_border)).setBackgroundResource(mProgressbarsFrameColor);

			((View) view.findViewById(R.id.studyoptions_bars_max)).setBackgroundResource(mProgressbarsBackgroundColor);
			((View) view.findViewById(R.id.studyoptions_progressbar2_content)).setBackgroundResource(mProgressbarsBackgroundColor);
			((View) view.findViewById(R.id.studyoptions_global_limit_bars_content)).setBackgroundResource(mProgressbarsBackgroundColor);
			((View) view.findViewById(R.id.studyoptions_progressbar4_content)).setBackgroundResource(mProgressbarsBackgroundColor);

			((View) view.findViewById(R.id.studyoptions_global_mat_limit_bar)).setBackgroundResource(mProgressbarsMatureColor);
			((View) view.findViewById(R.id.studyoptions_global_mat_bar)).setBackgroundResource(mProgressbarsMatureColor);

			((View) view.findViewById(R.id.studyoptions_global_limit_bar)).setBackgroundResource(mProgressbarsYoungColor);
			((View) view.findViewById(R.id.studyoptions_global_bar)).setBackgroundResource(mProgressbarsYoungColor);
			break;
		case CALLER_DECKPICKER:
			if (mCurrentTheme == THEME_BLUE) {
				ListView lv = (ListView) view.findViewById(R.id.files);
				lv.setSelector(R.drawable.blue_deckpicker_list_selector);
				lv.setDividerHeight(0);
			}
			break;
		case CALLER_CARDBROWSER:
			if (mCurrentTheme == THEME_BLUE) {
				ListView lv = (ListView) view.findViewById(R.id.card_browser_list);
				lv.setSelector(R.drawable.blue_cardbrowser_list_selector);
				lv.setDividerHeight(0);
			}
			break;
		case CALLER_DECKPICKER_DECK:
			if (view.getId() == R.id.DeckPickerCompletionMat) {
				view.setBackgroundResource(mProgressbarsFrameColor);
			} else if (view.getId() == R.id.DeckPickerCompletionAll) {
				view.setBackgroundResource(mProgressbarsDeckpickerYoungColor);
			} else if (view.getId() == R.id.deckpicker_deck) {
				view.setBackgroundResource(mDeckpickerItemBorder);
			}
			break;
		case CALLER_REVIEWER:
	        ((View)view.findViewById(R.id.main_layout)).setBackgroundResource(mReviewerBackground);
	        ((View)view.findViewById(R.id.flashcard_border)).setBackgroundResource(mFlashcardBorder);
	        ((View)view.findViewById(R.id.flashcard_frame)).setBackgroundResource(PrefSettings.getSharedPrefs(mContext).getBoolean(""invertedColors"", false) ? (mCurrentTheme == THEME_BLUE ? R.color.reviewer_night_card_background : R.color.black): R.color.white);
	        ((View)view.findViewById(R.id.session_progress)).setBackgroundResource(mReviewerProgressbar);
			break;
		case CALLER_FEEDBACK:
			((TextView)view).setTextColor(mProgressbarsFrameColor);
			break;
		case CALLER_DOWNLOAD_DECK:
			view.setBackgroundResource(mDeckpickerItemBorder);
			break;
		}
	}


	public static void loadTheme(){
			SharedPreferences preferences = PrefSettings.getSharedPrefs(mContext);
			mCurrentTheme = Integer.parseInt(preferences.getString(""theme"", ""2""));
			switch (mCurrentTheme) {
			case THEME_ANDROID_DARK:
				mDialogBackgroundColor = R.color.card_browser_background;
				mProgressbarsBackgroundColor = 0;
				mProgressbarsFrameColor = 0;
				mProgressbarsMatureColor = 0;
				mProgressbarsYoungColor = 0;
				mProgressbarsDeckpickerYoungColor = 0;
				mReviewerBackground = 0;
				mFlashcardBorder = 0;
				mDeckpickerItemBorder = 0;
				mTitleStyle = 0;
				mTextViewStyle = 0;
				mWallpaper = 0;
				mToastBackground = 0;
				mBackgroundDarkColor = 0;
				mReviewerProgressbar = 0;
				mCardbrowserItemBorder = new int[] {0, R.color.card_browser_marked, R.color.card_browser_suspended, R.color.card_browser_marked};
				mChartColors = new int[] {Color.WHITE, Color.BLACK};
				mPopupTopBright = R.drawable.popup_top_bright;
				mPopupTopMedium = R.drawable.popup_top_bright;
				mPopupTopDark = R.drawable.popup_top_dark;
				mPopupCenterDark = R.drawable.popup_center_dark;
				mPopupCenterBright = R.drawable.popup_center_bright;
				mPopupCenterMedium = R.drawable.popup_center_medium;
				mPopupBottomDark = R.drawable.popup_bottom_dark;
				mPopupBottomBright = R.drawable.popup_bottom_bright;
				mPopupBottomMedium = R.drawable.popup_bottom_medium;
				mPopupFullBright = R.drawable.popup_full_bright;
				mPopupFullDark = R.drawable.popup_full_dark;
				mPopupFullMedium = R.drawable.popup_full_bright;
				mDividerHorizontalBright = R.drawable.blue_divider_horizontal_bright;
				mBackgroundColor = R.color.white;
				break;
			case THEME_ANDROID_LIGHT:
				mProgressbarsBackgroundColor = R.color.studyoptions_progressbar_background_light;
				mProgressbarsFrameColor = R.color.studyoptions_progressbar_frame_light;
				mProgressbarsMatureColor = R.color.studyoptions_progressbar_mature_light;
				mProgressbarsYoungColor = R.color.studyoptions_progressbar_young_light;
				mProgressbarsDeckpickerYoungColor = R.color.deckpicker_progressbar_young_light;
				mReviewerBackground = 0;
				mFlashcardBorder = 0;
				mDeckpickerItemBorder = 0;
				mTitleStyle = 0;
				mTextViewStyle = 0;
				mWallpaper = 0;
				mToastBackground = 0;
				mBackgroundDarkColor = 0;
				mDialogBackgroundColor = R.color.card_browser_background;
				mCardbrowserItemBorder = new int[] {0, R.color.card_browser_marked, R.color.card_browser_suspended, R.color.card_browser_marked};
				mReviewerProgressbar = mProgressbarsYoungColor;
				mChartColors = new int[] {Color.BLACK, Color.WHITE};
				mPopupTopDark = R.drawable.popup_top_dark;
				mPopupTopBright = R.drawable.popup_top_bright;
				mPopupTopMedium = R.drawable.popup_top_bright;
				mPopupCenterDark = R.drawable.popup_center_dark;
				mPopupCenterBright = R.drawable.popup_center_bright;
				mPopupCenterMedium = R.drawable.popup_center_medium;
				mPopupBottomDark = R.drawable.popup_bottom_dark;
				mPopupBottomBright = R.drawable.popup_bottom_bright;
				mPopupBottomMedium = R.drawable.popup_bottom_medium;
				mPopupFullBright = R.drawable.popup_full_bright;
				mPopupFullMedium = R.drawable.popup_full_bright;
				mPopupFullDark = R.drawable.popup_full_dark;
				mDividerHorizontalBright = R.drawable.blue_divider_horizontal_bright;
				mBackgroundColor = R.color.white;
				break;				
			case THEME_BLUE:
				mProgressbarsBackgroundColor = R.color.studyoptions_progressbar_background_blue;
				mProgressbarsFrameColor = R.color.studyoptions_progressbar_frame_light;
				mProgressbarsMatureColor = R.color.studyoptions_progressbar_mature_light;
				mProgressbarsYoungColor = R.color.studyoptions_progressbar_young_blue;
				mProgressbarsDeckpickerYoungColor = R.color.deckpicker_progressbar_young_light;
				mReviewerBackground = R.color.reviewer_background;
				mFlashcardBorder = R.drawable.blue_bg_webview;
				mDeckpickerItemBorder = R.drawable.blue_bg_deckpicker;
				mTitleStyle = R.drawable.blue_title;
				mTextViewStyle = R.drawable.blue_textview;
				mWallpaper = R.drawable.blue_background;
				mBackgroundColor = R.color.background_blue;
				mToastBackground = R.drawable.blue_toast_frame;
				mDialogBackgroundColor = R.color.background_dialog_blue;
				mBackgroundDarkColor = R.color.background_dark_blue;
				mReviewerProgressbar = R.color.reviewer_progressbar_session_blue;
				mCardbrowserItemBorder = new int[] {R.drawable.blue_bg_cardbrowser, R.drawable.blue_bg_cardbrowser_marked, R.drawable.blue_bg_cardbrowser_suspended, R.drawable.blue_bg_cardbrowser_marked_suspended};
				mChartColors = new int[] {Color.BLACK, Color.WHITE};
				mPopupTopDark = R.drawable.blue_popup_top_dark;
				mPopupTopBright = R.drawable.blue_popup_top_bright;
				mPopupTopMedium = R.drawable.blue_popup_top_medium;
				mPopupCenterDark = R.drawable.blue_popup_center_dark;
				mPopupCenterBright = R.drawable.blue_popup_center_bright;
				mPopupCenterMedium = R.drawable.blue_popup_center_medium;
				mPopupBottomDark = R.drawable.blue_popup_bottom_dark;
				mPopupBottomBright = R.drawable.blue_popup_bottom_bright;
				mPopupBottomMedium = R.drawable.blue_popup_bottom_medium;
				mPopupFullBright = R.drawable.blue_popup_full_bright;
				mPopupFullMedium = R.drawable.blue_popup_full_medium;
				mPopupFullDark = R.drawable.blue_popup_full_dark;
				mDividerHorizontalBright = R.drawable.blue_divider_horizontal_bright;
				break;
			}
	}


	public static void setWallpaper(View view) {
		setWallpaper(view, false);
	}
	public static void setWallpaper(View view, boolean solid) {
		if (solid) {
			view.setBackgroundResource(mBackgroundDarkColor);
		} else {
			try {
				view.setBackgroundResource(mWallpaper);
			} catch (OutOfMemoryError e) {
				mWallpaper = mBackgroundColor;
				view.setBackgroundResource(mWallpaper);
				Log.e(AnkiDroidApp.TAG, ""Themes: setWallpaper: OutOfMemoryError = "" + e);
			}
		}
	}


	public static void setTextViewStyle(View view) {
		view.setBackgroundResource(mTextViewStyle);
	}


	public static void setTitleStyle(View view) {
		view.setBackgroundResource(mTitleStyle);
	}


	public static int getForegroundColor() {
		return mProgressbarsFrameColor;
	}


	public static int getBackgroundColor() {
		return mBackgroundColor;
	}


	public static int getDialogBackgroundColor() {
		return mDialogBackgroundColor;
	}


	public static int getTheme() {
		return mCurrentTheme;
	}


	public static int[] getCardBrowserBackground() {
		return mCardbrowserItemBorder;
	}


	public static void showThemedToast(Context context, String text, boolean shortLength) {
		Toast result = Toast.makeText(context, text, shortLength ? Toast.LENGTH_SHORT : Toast.LENGTH_LONG);
		try {
			if (mCurrentTheme >= THEME_BLUE) {
				result.getView().setBackgroundResource(mToastBackground);
			}
	        	result.show();
		} catch (OutOfMemoryError e) {
			Log.e(AnkiDroidApp.TAG, ""showThemedToast - OutOfMemoryError occured: "" + e);
			result.getView().setBackgroundResource(R.color.black);
			result.show();
		}
	}


	public static StyledDialog htmlOkDialog(Context context, String title, String text) {
		return htmlOkDialog(context, title, text, null, null);
	}
	public static StyledDialog htmlOkDialog(Context context, String title, String text, OnClickListener okListener, OnCancelListener cancelListener) {
		return htmlOkDialog(context, title, text, null, null, false);		
	}
	public static StyledDialog htmlOkDialog(Context context, String title, String text, OnClickListener okListener, OnCancelListener cancelListener, boolean includeBody) {
		StyledDialog.Builder builder = new StyledDialog.Builder(context);
        builder.setTitle(title);
        WebView view = new WebView(context);
        view.setBackgroundColor(context.getResources().getColor(mDialogBackgroundColor));
        if (includeBody) {
        	text = ""<html><body text=\""#FFFFFF\"" link=\""#E37068\"" alink=\""#E37068\"" vlink=\""#E37068\"">"" + text + ""</body></html>"";
        }
        view.loadDataWithBaseURL("""", text, ""text/html"", ""UTF-8"", """");
        builder.setView(view, true);
        builder.setPositiveButton(context.getResources().getString(R.string.ok), okListener);
        builder.setCancelable(true);
        builder.setOnCancelListener(cancelListener);
        return builder.create();
	}


	public static void setStyledDialogBackgrounds(View main, int buttonNumbers) {
		setStyledDialogBackgrounds(main, buttonNumbers, false);
	}
	public static void setStyledDialogBackgrounds(View main, int buttonNumbers, boolean brightCustomPanelBackground) {
		// order of styled dialog elements:
		// 1. top panel (title)
		// 2. content panel
		// 3. listview panel
		// 4. custom view panel
		// 5. button panel
		View topPanel = ((View) main.findViewById(R.id.topPanel));
		boolean[] visibility = new boolean[5];

		if (topPanel.getVisibility() == View.VISIBLE) {
			try {
				topPanel.setBackgroundResource(mPopupTopDark);
			} catch (OutOfMemoryError e) {
				Log.e(AnkiDroidApp.TAG, ""setStyledDialogBackgrounds - OutOfMemoryError occured: "" + e);
				topPanel.setBackgroundResource(R.color.black);
			}
			((View) main.findViewById(R.id.titleDivider)).setBackgroundResource(mDividerHorizontalBright);
			visibility[0] = true;
		}
		View contentPanel = ((View) main.findViewById(R.id.contentPanel));
		if (contentPanel.getVisibility() == View.VISIBLE) {
			visibility[1] = true;
		}
		View listViewPanel = ((View) main.findViewById(R.id.listViewPanel));
		if (listViewPanel.getVisibility() == View.VISIBLE) {
			visibility[2] = true;
		}
		View customPanel = ((View) main.findViewById(R.id.customPanel));
		if (customPanel.getVisibility() == View.VISIBLE) {
			visibility[3] = true;
		}
		if (buttonNumbers > 0) {
        	LinearLayout buttonPanel = (LinearLayout) main.findViewById(R.id.buttonPanel);
			try {
	        	buttonPanel.setBackgroundResource(mPopupBottomMedium);
			} catch (OutOfMemoryError e) {
				Log.e(AnkiDroidApp.TAG, ""setStyledDialogBackgrounds - OutOfMemoryError occured: "" + e);
				buttonPanel.setBackgroundResource(R.color.white);
			}
    		if (buttonNumbers > 1) {
    			main.findViewById(R.id.rightSpacer).setVisibility(View.GONE);
    			main.findViewById(R.id.leftSpacer).setVisibility(View.GONE);
    		}
			visibility[4] = true;
        }

		int first = -1;
		int last = -1;
		for (int i = 0; i < 5; i++) {
			if (first == -1 && visibility[i]) {
				first = i;
			}
			if (visibility[i]) {
				last = i;
			}
		}

		int res = mPopupCenterDark;
		if (first == 1) {
			res = mPopupTopDark;
		}
		if (last == 1) {
			res = mPopupBottomDark;
			if (first == 1) {
				res = mPopupFullDark;
			}
		}
		try {
			contentPanel.setBackgroundResource(res);
		} catch (OutOfMemoryError e) {
			Log.e(AnkiDroidApp.TAG, ""setStyledDialogBackgrounds - OutOfMemoryError occured: "" + e);
			contentPanel.setBackgroundResource(R.color.black);
		}

		res = mPopupCenterBright;
		if (first == 2) {
			res = mPopupTopBright;
		}
		if (last == 2) {
			res = mPopupBottomBright;
			if (first == 2) {
				res = mPopupFullBright;
			}
		}
		try {
			listViewPanel.setBackgroundResource(res);
		} catch (OutOfMemoryError e) {
			Log.e(AnkiDroidApp.TAG, ""setStyledDialogBackgrounds - OutOfMemoryError occured: "" + e);
			listViewPanel.setBackgroundResource(R.color.white);
		}

		res = brightCustomPanelBackground ? mPopupCenterMedium : mPopupCenterDark;
		if (first == 3) {
			res = brightCustomPanelBackground ? mPopupTopMedium : mPopupTopDark;;
		}
		if (last == 3) {
			res = brightCustomPanelBackground ? mPopupBottomMedium : mPopupBottomDark;;
			if (first == 3) {
				res = brightCustomPanelBackground ? mPopupFullMedium : mPopupFullDark;;
			}
		}
		try {
			customPanel.setBackgroundResource(res);
		} catch (OutOfMemoryError e) {
			Log.e(AnkiDroidApp.TAG, ""setStyledDialogBackgrounds - OutOfMemoryError occured: "" + e);
			customPanel.setBackgroundResource(brightCustomPanelBackground ? R.color.white : R.color.black);
		}
	}


	public static int[] getChartColors() {
		return mChartColors;
	}


	public static int getNightModeCardBackground(Context context) {
		switch (mCurrentTheme) {
		case THEME_BLUE:
			return context.getResources().getColor(R.color.reviewer_night_card_background);
		default:
			return Color.BLACK;
		}
	}
}
",False,58,68,1,5,5,26
2,com.ichi2.compat.Compat.java,"/****************************************************************************************
 * Copyright (c) 2011 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.compat;

import android.app.Activity;

/**
 * This interface defines a set of functions that are not available on all platforms.
 * <p>
 * A set of implementations for the supported platforms are available.
 * <p>
 * Each implementation ends with a {@code V<n>} prefix, identifying the minimum API version on which this implementation
 * can be used. For example, see {@link CompatV11}.
 */
public interface Compat {
    public void invalidateOptionsMenu(Activity activity);
}
",False,32,58,5,21,0,0
3,com.ichi2.compat.CompatV11.java,"/****************************************************************************************
 * Copyright (c) 2011 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.compat;

import android.app.Activity;

/**
 * Implementation of {@link Compat} for Honeycomb and later.
 */
public class CompatV11 implements Compat {
    @Override
    public void invalidateOptionsMenu(Activity activity) {
        activity.invalidateOptionsMenu();
    }
}
",False,3,57,5,21,1,1
4,com.ichi2.compat.CompatV3.java,"/****************************************************************************************
 * Copyright (c) 2011 Flavio Lerda <flerda@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.compat;

import android.app.Activity;

/**
 * Implementation of {@link Compat} for Cupcake and later.
 */
public class CompatV3 implements Compat {
    @Override
    public void invalidateOptionsMenu(Activity activity) {
        // There is no way (or need) to invalidate the options menu before Honeycomb.
    }
}
",False,21,57,5,21,1,1
5,com.ichi2.anki.AnkiDroidApp.java,"/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Application;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.os.Environment;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;

import com.ichi2.async.Connection;
import com.tomgibara.android.veecheck.util.PrefSettings;

import java.io.File;
import java.io.IOException;

import com.zeemote.zc.Controller;

/**
 * Application class. This file mainly contains Veecheck stuff.
 */
public class AnkiDroidApp extends Application {
	
	public static final String LIBANKI_VERSION = ""1.2.5"";
	public static final String DROPBOX_PUBLIC_DIR = ""/dropbox/Public/Anki"";

    /**
     * Tag for logging messages.
     */
    public static final String TAG = ""AnkiDroid"";

    /**
     * Singleton instance of this class.
     */
    private static AnkiDroidApp sInstance;

    /**
     * Currently loaded Anki deck.
     */
    private Deck mLoadedDeck;
    
    private Controller mZeemoteController;

    /**
     * On application creation.
     */
    @Override
    public void onCreate() {
        super.onCreate();
        sInstance = this;

        Connection.setContext(getApplicationContext());

        // Error Reporter
        CustomExceptionHandler customExceptionHandler = CustomExceptionHandler.getInstance();
        customExceptionHandler.init(sInstance.getApplicationContext());
        Thread.setDefaultUncaughtExceptionHandler(customExceptionHandler);

        SharedPreferences preferences = PrefSettings.getSharedPrefs(this);
        // Assign some default settings if necessary
        if (preferences.getString(PrefSettings.KEY_CHECK_URI, null) == null) {
            Editor editor = preferences.edit();
            // Test Update Notifications
            // Some ridiculously fast polling, just to demonstrate it working...
            /*
             * editor.putBoolean(PrefSettings.KEY_ENABLED, true); editor.putLong(PrefSettings.KEY_PERIOD, 30 * 1000L);
             * editor.putLong(PrefSettings.KEY_CHECK_INTERVAL, 60 * 1000L); editor.putString(PrefSettings.KEY_CHECK_URI,
             * ""http://ankidroid.googlecode.com/files/test_notifications.xml"");
             */
            editor.putString(PrefSettings.KEY_CHECK_URI, ""http://ankidroid.googlecode.com/files/last_release.xml"");

            // Create the folder ""AnkiDroid"", if not exists, where the decks
            // will be stored by default
            String deckPath = getStorageDirectory() + ""/AnkiDroid"";
            createDecksDirectoryIfMissing(new File(deckPath));

            // Put the base path in preferences pointing to the default
            // ""AnkiDroid"" folder
            editor.putString(""deckPath"", deckPath);

            // Using commit instead of apply even though we don't need a return value.
            // Reason: apply() not available on Android 1.5
            editor.commit();
        }

        // Reschedule the checks - we need to do this if the settings have
        // changed (as above)
        // It may also necessary in the case where an application has been
        // updated
        // Here for simplicity, we do it every time the application is launched
        // Intent intent = new Intent(Veecheck.getRescheduleAction(this));
        // sendBroadcast(intent);
    }


    public static AnkiDroidApp getInstance() {
        return sInstance;
    }


    public static String getStorageDirectory() {
        return Environment.getExternalStorageDirectory().getAbsolutePath();
    }


    public static void createDecksDirectoryIfMissing(File decksDirectory) {
    	if (!decksDirectory.isDirectory()) {
    		decksDirectory.mkdirs();
        }
    	try {
			new File(decksDirectory.getAbsolutePath() + ""/.nomedia"").createNewFile();
		} catch (IOException e) {
			Log.e(AnkiDroidApp.TAG, ""Nomedia file could not be created"");
		}
		createNoMediaFileIfMissing(decksDirectory);
    }


    public static void createNoMediaFileIfMissing(File decksDirectory) {
    	File mediaFile = new File(decksDirectory.getAbsolutePath() + ""/.nomedia"");
    	if (!mediaFile.exists()) {
        	try {
        		mediaFile.createNewFile();
    		} catch (IOException e) {
    			Log.e(AnkiDroidApp.TAG, ""Nomedia file could not be created in path "" + decksDirectory.getAbsolutePath());
    		}    		
    	}
    }


    public static Resources getAppResources() {
        return sInstance.getResources();
    }


    public static Deck deck() {
        return sInstance.mLoadedDeck;
    }

    public static Controller zeemoteController() {
    	return sInstance.mZeemoteController;
    }
    
    public static void setZeemoteController(Controller controller) {
    	sInstance.mZeemoteController = controller;
    }
    
    public static void setDeck(Deck deck) {
        sInstance.mLoadedDeck = deck;
    }


    public static boolean isSdCardMounted() {
        return Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState());
    }


    public static boolean isUserLoggedIn() {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(sInstance);
        String username = preferences.getString(""username"", """");
        String password = preferences.getString(""password"", """");

        if (!username.equalsIgnoreCase("""") && !password.equalsIgnoreCase("""")) {
            return true;
        }

        return false;
    }


    public static int getDisplayHeight() {
        Display display = ((WindowManager) sInstance.getApplicationContext().getSystemService(Context.WINDOW_SERVICE))
                .getDefaultDisplay();
        return display.getHeight();
    }


    public static int getDisplayWidth() {
        Display display = ((WindowManager) sInstance.getApplicationContext().getSystemService(Context.WINDOW_SERVICE))
                .getDefaultDisplay();
        return display.getWidth();
    }


    /**
     * Get package name as defined in the manifest.
     * @return the package name.
     */
    public static String getPkgName() {
        String pkgName = TAG;
        Context context = sInstance.getApplicationContext();

        try {
            PackageInfo pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
            pkgName = context.getString(pInfo.applicationInfo.labelRes);
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, ""Couldn't find package named "" + context.getPackageName(), e);
        }

        return pkgName;
    }


    /**
     * Get the package version as defined in the manifest.
     * @return the package version.
     */
    public static String getPkgVersion() {
        String pkgVersion = ""?"";
        Context context = sInstance.getApplicationContext();

        try {
            PackageInfo pInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
            pkgVersion = pInfo.versionName;
        } catch (PackageManager.NameNotFoundException e) {
            Log.e(TAG, ""Couldn't find package named "" + context.getPackageName(), e);
        }

        return pkgVersion;
    }
    
    /**
     * Get the DropBox folder
     * @return the absolute path to the DropBox public folder, or null if it is not found
     */
    public static String getDropboxDir() {
        File f = new File(AnkiDroidApp.getStorageDirectory() + DROPBOX_PUBLIC_DIR);
        if (f.exists() && f.isDirectory()) {
            return f.getAbsolutePath();
        }
        return null;
    }


    public static void saveExceptionReportFile(Throwable e, String origin) {
    	CustomExceptionHandler.getInstance().uncaughtException(null, e, origin);
    }
}
",True,75,72,1,9,4,28
6,com.ichi2.anki.CardModel.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.database.Cursor;
import android.util.Log;

import com.samskivert.mustache.Mustache;
import com.samskivert.mustache.Template;

import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Card model. Card models are used to make question/answer pairs for the information you add to facts. You can display
 * any number of fields on the question side and answer side.
 * 
 * @see http://ichi2.net/anki/wiki/ModelProperties#Card_Templates
 */
public class CardModel implements Comparator<CardModel> {

    // TODO: Javadoc.
    // TODO: Methods for reading/writing from/to DB.

    public static final int DEFAULT_FONT_SIZE = 20;
    public static final int DEFAULT_FONT_SIZE_RATIO = 100;
    public static final String DEFAULT_FONT_FAMILY = ""Arial"";
    public static final String DEFAULT_FONT_COLOR = ""#000000"";
    public static final String DEFAULT_BACKGROUND_COLOR = ""#FFFFFF"";

    /** Regex pattern used in removing tags from text before diff */
//    private static final Pattern sFactPattern = Pattern.compile(""%\\([tT]ags\\)s"");
//    private static final Pattern sModelPattern = Pattern.compile(""%\\(modelTags\\)s"");
//    private static final Pattern sTemplPattern = Pattern.compile(""%\\(cardModel\\)s"");

    // Regex pattern for converting old style template to new
    private static final Pattern sOldStylePattern = Pattern.compile(""%\\((.+?)\\)s"");

    // BEGIN SQL table columns
    private long mId; // Primary key
    private int mOrdinal;
    private long mModelId; // Foreign key models.id
    private String mName;
    private String mDescription = """";
    private int mActive = 1;
    // Formats: question/answer/last (not used)
    private String mQformat;
    private String mAformat;
//    private String mLformat;
    // Question/answer editor format (not used yet)
//    private String mQedformat;
//    private String mAedformat;
    private int mQuestionInAnswer = 0;
    // Unused
    private String mQuestionFontFamily = DEFAULT_FONT_FAMILY;
    private int mQuestionFontSize = DEFAULT_FONT_SIZE;
    private String mQuestionFontColour = DEFAULT_FONT_COLOR;
    // Used for both question & answer
    private int mQuestionAlign = 0;
    // Unused
    private String mAnswerFontFamily = DEFAULT_FONT_FAMILY;
    private int mAnswerFontSize = DEFAULT_FONT_SIZE;
    private String mAnswerFontColour = DEFAULT_FONT_COLOR;
    private int mAnswerAlign = 0;
//    private String mLastFontFamily = DEFAULT_FONT_FAMILY;
//    private int mLastFontSize = DEFAULT_FONT_SIZE;
    // Used as background colour
    private String mLastFontColour = DEFAULT_BACKGROUND_COLOR;
//    private String mEditQuestionFontFamily = """";
//    private int mEditQuestionFontSize = 0;
//    private String mEditAnswerFontFamily = """";
//    private int mEditAnswerFontSize = 0;
    // Empty answer
//    private int mAllowEmptyAnswer = 1;
    private String mTypeAnswer = """";
    // END SQL table entries

	// Compiled mustache templates
    private Template mQTemplate = null;
    private Template mATemplate = null;

    /**
     * Backward reference
     */
//    private Model mModel;


    /**
     * Constructor.
     */
    public CardModel(String name, String qformat, String aformat, boolean active) {
        mName = name;
        mQformat = qformat;
        mAformat = aformat;
        mActive = active ? 1 : 0;
        mId = Utils.genID();
    }


    /**
     * Constructor.
     */
    public CardModel() {
        this("""", ""q"", ""a"", true);
    }

    /** SELECT string with only those fields, which are used in AnkiDroid */
    private static final String SELECT_STRING = ""SELECT id, ordinal, modelId, name, description, active, qformat, ""
            + ""aformat, questionInAnswer, questionFontFamily, questionFontSize, questionFontColour, questionAlign, ""
            + ""answerFontFamily, answerFontSize, answerFontColour, answerAlign, lastFontColour, typeAnswer"" + "" FROM cardModels"";


    /**
     * @param modelId
     * @param models will be changed by adding all found CardModels into it
     * @return unordered CardModels which are related to a given Model and eventually active put into the parameter
     *         ""models""
     */
    protected static final void fromDb(Deck deck, long modelId, LinkedHashMap<Long, CardModel> models) {
        Cursor cursor = null;
        CardModel myCardModel = null;
        try {
            StringBuffer query = new StringBuffer(SELECT_STRING);
            query.append("" WHERE modelId = "");
            query.append(modelId);
            query.append("" ORDER BY ordinal"");

            cursor = AnkiDatabaseManager.getDatabase(deck.getDeckPath()).getDatabase().rawQuery(query.toString(), null);

            if (cursor.moveToFirst()) {
                do {
                    myCardModel = new CardModel();

                    myCardModel.mId = cursor.getLong(0);
                    myCardModel.mOrdinal = cursor.getInt(1);
                    myCardModel.mModelId = cursor.getLong(2);
                    myCardModel.mName = cursor.getString(3);
                    myCardModel.mDescription = cursor.getString(4);
                    myCardModel.mActive = cursor.getInt(5);
                    myCardModel.mQformat = cursor.getString(6);
                    myCardModel.mAformat = cursor.getString(7);
                    myCardModel.mQuestionInAnswer = cursor.getInt(8);
                    myCardModel.mQuestionFontFamily = cursor.getString(9);
                    myCardModel.mQuestionFontSize = cursor.getInt(10);
                    myCardModel.mQuestionFontColour = cursor.getString(11);
                    myCardModel.mQuestionAlign = cursor.getInt(12);
                    myCardModel.mAnswerFontFamily = cursor.getString(13);
                    myCardModel.mAnswerFontSize = cursor.getInt(14);
                    myCardModel.mAnswerFontColour = cursor.getString(15);
                    myCardModel.mAnswerAlign = cursor.getInt(16);
                    myCardModel.mLastFontColour = cursor.getString(17);
                    myCardModel.mTypeAnswer = cursor.getString(18);
                    myCardModel.refreshTemplates();
                    models.put(myCardModel.mId, myCardModel);
                } while (cursor.moveToNext());
            }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
    }
    
    protected void toDB(Deck deck) {
        ContentValues values = new ContentValues();
        values.put(""id"", mId);
        values.put(""ordinal"", mOrdinal);
        values.put(""modelId"", mModelId);
        values.put(""name"", mName);
        values.put(""description"", mDescription);
        values.put(""active"", mActive);
        values.put(""qformat"", mQformat);
        values.put(""aformat"", mAformat);
        values.put(""questionInAnswer"", mQuestionInAnswer);
        values.put(""questionFontFamily"", mQuestionFontFamily);
        values.put(""questionFontSize"", mQuestionFontSize);
        values.put(""questionFontColour"", mQuestionFontColour);
        values.put(""questionAlign"", mQuestionAlign);
        values.put(""answerFontFamily"", mAnswerFontFamily);
        values.put(""answerFontSize"", mAnswerFontSize);
        values.put(""answerFontColour"", mAnswerFontColour);
        values.put(""answerAlign"", mAnswerAlign);
        values.put(""lastFontColour"", mLastFontColour);
        deck.getDB().update(deck, ""cardModels"", values, ""id = "" + mId, null);
    }


    public boolean isActive() {
        return (mActive != 0);
    }


    /**
     * This function recompiles the templates for question and answer. It should be called everytime we change mQformat
     * or mAformat, so if in the future we create set(Q|A)Format setters, we should include a call to this.
     */
    private void refreshTemplates() {
        // Question template
        StringBuffer sb = new StringBuffer();
        Matcher m = sOldStylePattern.matcher(mQformat);
        while (m.find()) {
            // Convert old style
            m.appendReplacement(sb, ""{{"" + m.group(1) + ""}}"");
        }
        m.appendTail(sb);
        // Log.i(AnkiDroidApp.TAG, ""Compiling question template \"""" + sb.toString() + ""\"""");
        mQTemplate = Mustache.compiler().compile(sb.toString());

        // Answer template
        sb = new StringBuffer();
        m = sOldStylePattern.matcher(mAformat);
        while (m.find()) {
            // Convert old style
            m.appendReplacement(sb, ""{{"" + m.group(1) + ""}}"");
        }
        m.appendTail(sb);
        // Log.i(AnkiDroidApp.TAG, ""Compiling answer template \"""" + sb.toString() + ""\"""");
        mATemplate = Mustache.compiler().compile(sb.toString());
    }


    /**
     * @param cardModelId
     * @return the modelId for a given cardModel or 0, if it cannot be found
     */
    protected static final long modelIdFromDB(Deck deck, long cardModelId) {
        Cursor cursor = null;
        long modelId = -1;
        try {
            String query = ""SELECT modelId FROM cardModels WHERE id = "" + cardModelId;
            cursor = AnkiDatabaseManager.getDatabase(deck.getDeckPath()).getDatabase().rawQuery(query, null);
            if (cursor.moveToFirst()) {
	            modelId = cursor.getLong(0);
	    }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        return modelId;
    }


    // XXX Unused
    // /**
    // * Return a copy of this object.
    // */
    // public CardModel copy() {
    // CardModel cardModel = new CardModel(mName, mQformat, mAformat, (mActive == 1) ? true : false);
    // cardModel.mOrdinal = mOrdinal;
    // cardModel.mModelId = mModelId;
    // cardModel.mDescription = mDescription;
    // cardModel.mLformat = mLformat;
    // cardModel.mQedformat = mQedformat;
    // cardModel.mAedformat = mAedformat;
    // cardModel.mQuestionInAnswer = mQuestionInAnswer;
    // cardModel.mQuestionFontFamily = mQuestionFontFamily;
    // cardModel.mQuestionFontSize = mQuestionFontSize;
    // cardModel.mQuestionFontColour = mQuestionFontColour;
    // cardModel.mQuestionAlign = mQuestionAlign;
    // cardModel.mAnswerFontFamily = mAnswerFontFamily;
    // cardModel.mAnswerFontSize = mAnswerFontSize;
    // cardModel.mAnswerFontColour = mAnswerFontColour;
    // cardModel.mAnswerAlign = mAnswerAlign;
    // cardModel.mLastFontFamily = mLastFontFamily;
    // cardModel.mLastFontSize = mLastFontSize;
    // cardModel.mLastFontColour = mLastFontColour;
    // cardModel.mEditQuestionFontFamily = mEditQuestionFontFamily;
    // cardModel.mEditQuestionFontSize = mEditQuestionFontSize;
    // cardModel.mEditAnswerFontFamily = mEditAnswerFontFamily;
    // cardModel.mEditAnswerFontSize = mEditAnswerFontSize;
    // cardModel.mAllowEmptyAnswer = mAllowEmptyAnswer;
    // cardModel.mTypeAnswer = mTypeAnswer;
    // cardModel.mModel = null;
    //
    // return cardModel;
    // }

    public static HashMap<String, String> formatQA(Fact fact, CardModel cm, String[] tags) {

        Map<String, String> fields = new HashMap<String, String>();
        for (Fact.Field f : fact.getFields()) {
            fields.put(""text:"" + f.getFieldModel().getName(), Utils.stripHTML(f.getValue()));
            if (!f.getValue().equals("""")) {
                fields.put(f.getFieldModel().getName(), String.format(""<span class=\""fm%s\"">%s</span>"", Utils
                        .hexifyID(f.getFieldModelId()), f.getValue()));
            } else {
                fields.put(f.getFieldModel().getName(), """");
            }
        }
        fields.put(""tags"", tags[Card.TAGS_FACT]);
        fields.put(""Tags"", tags[Card.TAGS_FACT]);
        fields.put(""modelTags"", tags[Card.TAGS_MODEL]);
        fields.put(""cardModel"", tags[Card.TAGS_TEMPL]);

        HashMap<String, String> d = new HashMap<String, String>();
        d.put(""question"", cm.mQTemplate.execute(fields));
        d.put(""answer"", cm.mATemplate.execute(fields));

        return d;
    }


    /*
    private static String replaceField(String replaceFrom, Fact fact, int replaceAt, boolean isQuestion) {
        int endIndex = replaceFrom.indexOf("")"", replaceAt);
        String fieldName = replaceFrom.substring(replaceAt + 2, endIndex);
        char fieldType = replaceFrom.charAt(endIndex + 1);
        if (isQuestion) {
            String replace = ""%("" + fieldName + "")"" + fieldType;
            String with = ""<span class=\""fm"" + Long.toHexString(fact.getFieldModelId(fieldName)) + ""\"">""
                    + fact.getFieldValue(fieldName) + ""</span>"";
            replaceFrom = replaceFrom.replace(replace, with);
        } else {
            replaceFrom.replace(""%("" + fieldName + "")"" + fieldType, ""<span class=\""fma""
                    + Long.toHexString(fact.getFieldModelId(fieldName)) + ""\"">"" + fact.getFieldValue(fieldName)
                    + ""</span"");
        }
        return replaceFrom;
    }


    private static String replaceHtmlField(String replaceFrom, Fact fact, int replaceAt) {
        int endIndex = replaceFrom.indexOf("")"", replaceAt);
        String fieldName = replaceFrom.substring(replaceAt + 7, endIndex);
        char fieldType = replaceFrom.charAt(endIndex + 1);
        String replace = ""%(text:"" + fieldName + "")"" + fieldType;
        String with = fact.getFieldValue(fieldName);
        replaceFrom = replaceFrom.replace(replace, with);
        return replaceFrom;
    }
    */


    /**
     * Implements Comparator by comparing the field ""ordinal"".
     * 
     * @param object1
     * @param object2
     * @return
     */
    @Override
    public int compare(CardModel object1, CardModel object2) {
        return object1.mOrdinal - object2.mOrdinal;
    }


    /**
     * @return the id
     */
    public long getId() {
        return mId;
    }


    /**
     * @return the ordinal
     */
    public int getOrdinal() {
        return mOrdinal;
    }


    /**
     * @return the questionInAnswer
     */
    public boolean isQuestionInAnswer() {
        // FIXME hmmm, is that correct?
        return (mQuestionInAnswer == 0);
    }


    /**
     * @return the lastFontColour
     */
    public String getLastFontColour() {
        return mLastFontColour;
    }


    /**
     * @return the questionFontFamily
     */
    public String getQuestionFontFamily() {
        return mQuestionFontFamily;
    }


    /**
     * @return the questionFontSize
     */
    public int getQuestionFontSize() {
        return mQuestionFontSize;
    }


    /**
     * @return the questionFontColour
     */
    public String getQuestionFontColour() {
        return mQuestionFontColour;
    }


    /**
     * @return the questionAlign
     */
    public int getQuestionAlign() {
        return mQuestionAlign;
    }


    /**
     * @return the answerFontFamily
     */
    public String getAnswerFontFamily() {
        return mAnswerFontFamily;
    }


    /**
     * @return the answerFontSize
     */
    public int getAnswerFontSize() {
        return mAnswerFontSize;
    }


    /**
     * @return the answerFontColour
     */
    public String getAnswerFontColour() {
        return mAnswerFontColour;
    }


    /**
     * @return the answerAlign
     */
    public int getAnswerAlign() {
        return mAnswerAlign;
    }


    /**
     * @return the name
     */
    public String getName() {
        return mName;
    }
    
    /**
     * Getter for question Format
     * @return the question format
     */
    public String getQFormat() {
        return mQformat;
    }
    
    /**
     * Setter for question Format
     * @param the new question format
     */
    public void setQFormat(String qFormat) {
        mQformat = qFormat;
    }
    
    /**
     * Getter for answer Format
     * @return the answer format
     */
    public String getAFormat() {
        return mAformat;
    }
    
    /**
     * Setter for answer Format
     * @param the new answer format
     */
    public void setAFormat(String aFormat) {
        mAformat = aFormat;
    }

    
    public long getModelId() {
		return mModelId;
	}


	public String getTypeAnswer() {
		return mTypeAnswer;
	}
}
",False,79,63,0,0,5,22
7,com.ichi2.anki.Field.java,"package com.ichi2.anki;

import android.database.Cursor;

public class Field {
    /**
     * FIXME: nothing is done in case of db error or no returned row
     * 
     * @param factId
     * @param fieldModelId
     * @return the value of a field corresponding to the 2 search parameters - or an empty string if not found
     */
    protected final static String fieldValuefromDb(Deck deck, long factId, long fieldModelId) {
        Cursor cursor = null;
        String value = """";
        try {
            StringBuffer query = new StringBuffer();
            query.append(""SELECT value"");
            query.append("" FROM fields"");
            query.append("" WHERE factId = "").append(factId).append("" AND fieldModelId = "").append(fieldModelId);
            cursor = AnkiDatabaseManager.getDatabase(deck.getDeckPath()).getDatabase().rawQuery(query.toString(), null);

            cursor.moveToFirst();
            value = cursor.getString(0); // Primary key
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return value;
    }
}
",False,65,63,0,0,5,29
8,com.ichi2.anki.Preferences.java,"/***************************************************************************************
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.io.File;
import java.util.Arrays;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.DialogInterface.OnClickListener;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.ListPreference;
import android.preference.PreferenceActivity;
import android.preference.PreferenceManager;
import android.util.Log;
import android.view.WindowManager.BadTokenException;

import com.hlidskialf.android.preference.SeekBarPreference;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

/**
 * Preferences dialog.
 */
public class Preferences extends PreferenceActivity implements OnSharedPreferenceChangeListener {

	private static final int DIALOG_WAL = 0;
	private static final int DIALOG_ASYNC = 1;
	private static final int DIALOG_BACKUP = 2;
	private static final int DIALOG_WRITE_ANSWERS = 4;

//    private boolean mVeecheckStatus;
    private PreferenceManager mPrefMan;
    private CheckBoxPreference zoomCheckboxPreference;
    private CheckBoxPreference keepScreenOnCheckBoxPreference;
    private CheckBoxPreference showAnswerCheckBoxPreference;
    private CheckBoxPreference swipeCheckboxPreference;
    private CheckBoxPreference animationsCheckboxPreference;
    private CheckBoxPreference walModePreference;
    private CheckBoxPreference useBackupPreference;
    private CheckBoxPreference asyncModePreference;
    private ListPreference mLanguageSelection;
    private CharSequence[] mLanguageDialogLabels;
    private CharSequence[] mLanguageDialogValues;
    private static String[] mAppLanguages = {""ar"", ""ca"", ""cs"", ""de"", ""el"", ""es_ES"", ""fi"", ""fr"", ""hu"", ""id"", ""it"", ""ja"", ""ko"", ""nl"", ""no"", ""pl"", ""pt_PT"", ""ro"", ""ru"", ""sr"", ""sv-SE"", ""th"", ""tr"", ""vi"", ""zh-CN"", ""zh-TW"", ""en""};
    private static String[] mShowValueInSummList = {""language"", ""startup_mode"", ""hideQuestionInAnswer"", ""dictionary"", ""reportErrorMode"", ""minimumCardsDueForNotification"", ""deckOrder"", ""gestureShake"", ""gestureSwipeUp"", ""gestureSwipeDown"", ""gestureSwipeLeft"", ""gestureSwipeRight"", ""gestureDoubleTap"", ""gestureTapTop"", ""gestureTapBottom"", ""gestureTapRight"", ""gestureTapLeft"", ""theme""};
    private static String[] mShowValueInSummSeek = {""relativeDisplayFontSize"", ""relativeCardBrowserFontSize"", ""answerButtonSize"", ""whiteBoardStrokeWidth"", ""minShakeIntensity"", ""swipeSensibility"", ""timeoutAnswerSeconds"", ""timeoutQuestionSeconds"", ""animationDuration"", ""backupMax""};
    private TreeMap<String, String> mListsToUpdate = new TreeMap<String, String>();
    private ProgressDialog mProgressDialog;
    private boolean lockCheckAction = false;
    private boolean walModeInitiallySet = false;
    private String dialogMessage;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
//    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);

        mPrefMan = getPreferenceManager();
        mPrefMan.setSharedPreferencesName(PrefSettings.SHARED_PREFS_NAME);

        addPreferencesFromResource(R.xml.preferences);
//        mVeecheckStatus = mPrefMan.getSharedPreferences().getBoolean(PrefSettings.KEY_ENABLED, PrefSettings.DEFAULT_ENABLED);
        
        getPreferenceScreen().getSharedPreferences().registerOnSharedPreferenceChangeListener(this);
        swipeCheckboxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""swipe"");
        zoomCheckboxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""zoom"");
        keepScreenOnCheckBoxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""keepScreenOn"");
        showAnswerCheckBoxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""timeoutAnswer"");
        animationsCheckboxPreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""themeAnimations"");
        walModePreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""walMode"");
        useBackupPreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""useBackup"");
        asyncModePreference = (CheckBoxPreference) getPreferenceScreen().findPreference(""asyncMode"");
        walModeInitiallySet = mPrefMan.getSharedPreferences().getBoolean(""walMode"", false);
        ListPreference listpref = (ListPreference) getPreferenceScreen().findPreference(""theme"");
        animationsCheckboxPreference.setEnabled(listpref.getValue().equals(""2""));
        zoomCheckboxPreference.setEnabled(!swipeCheckboxPreference.isChecked());
        initializeLanguageDialog();
        initializeCustomFontsDialog();
        for (String key : mShowValueInSummList) {
            updateListPreference(key);
        }
        for (String key : mShowValueInSummSeek) {
            updateSeekBarPreference(key);
        }
        enableWalSupport();
    }


    private void updateListPreference(String key) {
        ListPreference listpref = (ListPreference) getPreferenceScreen().findPreference(key);
        String entry;
        try {
            entry = listpref.getEntry().toString();            
        } catch (NullPointerException e) {
            Log.e(AnkiDroidApp.TAG, ""Error getting set preference value of "" + key + "": "" + e);
            entry = ""?"";
        }
        if (mListsToUpdate.containsKey(key)) {
            listpref.setSummary(replaceString(mListsToUpdate.get(key), entry));
        } else {
            String oldsum = (String) listpref.getSummary();
            if (oldsum.contains(""XXX"")) {
                mListsToUpdate.put(key, oldsum);
                listpref.setSummary(replaceString(oldsum, entry));
            } else {
                listpref.setSummary(entry);
            }
        }
    }


    private void updateSeekBarPreference(String key) {
        SeekBarPreference seekpref = (SeekBarPreference) getPreferenceScreen().findPreference(key);
        try {
            if (mListsToUpdate.containsKey(key)) {
                seekpref.setSummary(replaceString(mListsToUpdate.get(key), Integer.toString(seekpref.getValue())));
            } else {
                String oldsum = (String) seekpref.getSummary();
                if (oldsum.contains(""XXX"")) {
                    mListsToUpdate.put(key, oldsum);
                    seekpref.setSummary(replaceString(oldsum, Integer.toString(seekpref.getValue())));
                } else {
                    seekpref.setSummary(Integer.toString(seekpref.getValue()));
                }
            }        	
        } catch (NullPointerException e) {
        	Log.e(AnkiDroidApp.TAG, ""Exception when updating seekbar preference: "" + e);
        }
    }


    private void enableWalSupport() {
    	Cursor cursor = null;
    	String sqliteVersion = """";
    	SQLiteDatabase database = null;
        try {
        	database = SQLiteDatabase.openOrCreateDatabase("":memory:"", null);
        	cursor = database.rawQuery(""select sqlite_version() AS sqlite_version"", null);
        	while(cursor.moveToNext()){
        	   sqliteVersion = cursor.getString(0);
        	}
        } finally {
        	database.close();
            if (cursor != null) {
            	cursor.close();
            }
        }
        if (sqliteVersion.length() >= 3 && Double.parseDouble(sqliteVersion.subSequence(0, 3).toString()) >= 3.7) {
        	walModePreference.setEnabled(true);
        } else {
        	Log.e(AnkiDroidApp.TAG, ""WAL mode not available due to a SQLite version lower than 3.7.0"");
        	walModePreference.setChecked(false);
        }
    }


    private String replaceString(String str, String value) {
        if (str.contains(""XXX"")) {
            return str.replace(""XXX"", value);
        } else {
            return str;
        }
    }


    private void initializeLanguageDialog() {
    	TreeMap<String, String> items = new TreeMap<String, String>();
        for (String localeCode : mAppLanguages) {
			Locale loc;
			if (localeCode.length() > 2) {
				loc = new Locale(localeCode.substring(0,2), localeCode.substring(3,5));				
			} else {
				loc = new Locale(localeCode);				
			}
	    	items.put(loc.getDisplayName(), loc.toString());
		}
		mLanguageDialogLabels = new CharSequence[items.size() + 1];
		mLanguageDialogValues = new CharSequence[items.size() + 1];
		mLanguageDialogLabels[0] = getResources().getString(R.string.language_system);
		mLanguageDialogValues[0] = """"; 
		int i = 1;
		for (Map.Entry<String, String> e : items.entrySet()) {
			mLanguageDialogLabels[i] = e.getKey();
			mLanguageDialogValues[i] = e.getValue();
			i++;
		}
        mLanguageSelection = (ListPreference) getPreferenceScreen().findPreference(""language"");
        mLanguageSelection.setEntries(mLanguageDialogLabels);
        mLanguageSelection.setEntryValues(mLanguageDialogValues);
    }


    /** Initializes the list of custom fonts shown in the preferences. */
    private void initializeCustomFontsDialog() {
        ListPreference customFontsPreference =
            (ListPreference) getPreferenceScreen().findPreference(""defaultFont"");
        customFontsPreference.setEntries(getCustomFonts(""System default""));
        customFontsPreference.setEntryValues(getCustomFonts(""""));
    }


    @Override
    protected void onPause() {
        super.onPause();
        // Reschedule the checking in case the user has changed the veecheck switch
//        if (mVeecheckStatus ^ mPrefMan.getSharedPreferences().getBoolean(PrefSettings.KEY_ENABLED, mVeecheckStatus)) {
//            sendBroadcast(new Intent(Veecheck.getRescheduleAction(this)));
//        }
    }

    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
    	try {
            if (key.equals(""swipe"")) {
            	zoomCheckboxPreference.setChecked(false);
            	zoomCheckboxPreference.setEnabled(!swipeCheckboxPreference.isChecked());
            } else if (key.equals(""timeoutAnswer"")) {
            	keepScreenOnCheckBoxPreference.setChecked(showAnswerCheckBoxPreference.isChecked());
            } else if (key.equals(""language"")) {
    			Intent intent = this.getIntent();
    			setResult(StudyOptions.RESULT_RESTART, intent);
    			finish();
            } else if (key.equals(""startup_mode"")) {
    			Intent intent = this.getIntent();
    			setResult(StudyOptions.RESULT_RESTART, intent);
    			finish();
            } else if (key.equals(""theme"")) {
            	if (!sharedPreferences.getString(""theme"", ""0"").equals(""2"")) {
            		animationsCheckboxPreference.setChecked(false);
            		animationsCheckboxPreference.setEnabled(false);
            	} else {
            		animationsCheckboxPreference.setEnabled(true);
            	}
            	Themes.loadTheme();
    			Intent intent = this.getIntent();
    			setResult(StudyOptions.RESULT_RESTART, intent);
    			finish();
            } else if (Arrays.asList(mShowValueInSummList).contains(key)) {
                updateListPreference(key);
            } else if (Arrays.asList(mShowValueInSummSeek).contains(key)) {
                updateSeekBarPreference(key);
            } else if (key.equals(""writeAnswers"") && sharedPreferences.getBoolean(""writeAnswers"", false)) {
                showDialog(DIALOG_WRITE_ANSWERS);
            } else if (key.equals(""walMode"") && !lockCheckAction) {
            	lockCheckAction = true;
            	if (sharedPreferences.getBoolean(""walMode"", false)) {
            		showDialog(DIALOG_WAL);
            	} else if (walModeInitiallySet) {
            		walModeInitiallySet = false;
            		dialogMessage = getResources().getString(R.string.wal_mode_set_message);
                	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SET_ALL_DECKS_JOURNAL_MODE, mDeckOperationHandler, new DeckTask.TaskData(AnkiDroidApp.deck(), PrefSettings.getSharedPrefs(getBaseContext()).getString(""deckPath"", AnkiDroidApp.getStorageDirectory())));
            	} else {
            		lockCheckAction = false;        		
            	}
            } else if (key.equals(""useBackup"")) {
            	if (lockCheckAction)  {
            		lockCheckAction = false;
            	} else if (!useBackupPreference.isChecked()) {
            		lockCheckAction = true;
            		useBackupPreference.setChecked(true);
        			showDialog(DIALOG_BACKUP);
            	} else {
            		setReloadDeck();
            	}
            } else if (key.equals(""asyncMode"")) {
            	if (lockCheckAction)  {
            		lockCheckAction = false;
            	} else if (asyncModePreference.isChecked()) {
            		lockCheckAction = true;
            		asyncModePreference.setChecked(false);
        			showDialog(DIALOG_ASYNC);
            	} else {
            		setReloadDeck();
            	}
            } else if (key.equals(""deckPath"")) {
            	File decksDirectory = new File(sharedPreferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory()));
            	if (decksDirectory.exists()) {
            		AnkiDroidApp.createNoMediaFileIfMissing(decksDirectory);
            	}
            }
        } catch (BadTokenException e) {
        	Log.e(AnkiDroidApp.TAG, ""Preferences: BadTokenException on showDialog: "" + e);
        }
   }


    /** Returns a list of the names of the installed custom fonts. */
    private String[] getCustomFonts(String defaultValue) {
        File[] files = Utils.getCustomFonts(this);
        int count = files.length;
        // Log.d(AnkiDroidApp.TAG, ""There are "" + count + "" custom fonts"");
        String[] names = new String[count + 1];
        for (int index = 0; index < count; ++index) {
            names[index] = Utils.removeExtension(files[index].getName());
            // Log.d(AnkiDroidApp.TAG, ""Adding custom font: "" + names[index]);
        }
        names[count] = defaultValue;
        return names;
    }


    private void setReloadDeck() {
    	dialogMessage = getResources().getString(R.string.close_deck);
    	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, mDeckOperationHandler, new DeckTask.TaskData(0, AnkiDroidApp.deck(), 0l, false));
		setResult(StudyOptions.RESULT_RELOAD_DECK, getIntent());
    }


    @Override
    protected Dialog onCreateDialog(int id) {
		Resources res = getResources();
        AlertDialog.Builder builder = new AlertDialog.Builder(this);
        switch (id) {
        case DIALOG_WAL:
    		builder.setTitle(res.getString(R.string.wal_mode));
    		builder.setCancelable(false);
    		builder.setMessage(res.getString(R.string.wal_mode_message));
    		builder.setPositiveButton(res.getString(R.string.yes), new OnClickListener() {

    			@Override
    			public void onClick(DialogInterface arg0, int arg1) {
    				walModePreference.setChecked(true);
    	        	lockCheckAction = false;
    				setReloadDeck();
    			}
    		});
    		builder.setNegativeButton(res.getString(R.string.no), new OnClickListener() {

    			@Override
    			public void onClick(DialogInterface arg0, int arg1) {
    				walModePreference.setChecked(false);
    				lockCheckAction = false;
    			}
    		});
    		break;
        case DIALOG_BACKUP:
    		builder.setTitle(res.getString(R.string.backup_manager_title));
    		builder.setCancelable(false);
    		builder.setMessage(res.getString(R.string.pref_backup_warning));
    		builder.setPositiveButton(res.getString(R.string.yes), new OnClickListener() {

    			@Override
    			public void onClick(DialogInterface arg0, int arg1) {
    				lockCheckAction = true;
    				useBackupPreference.setChecked(false);
    				dialogMessage = getResources().getString(R.string.backup_delete);
    				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_BACKUPS, mDeckOperationHandler, (DeckTask.TaskData[]) null);
    			}
    		});
    		builder.setNegativeButton(res.getString(R.string.no), null);
    		break;
        case DIALOG_ASYNC:
    		builder.setTitle(res.getString(R.string.async_mode));
    		builder.setCancelable(false);
    		builder.setMessage(res.getString(R.string.async_mode_message));
    		builder.setPositiveButton(res.getString(R.string.yes), new OnClickListener() {

    			@Override
    			public void onClick(DialogInterface arg0, int arg1) {
    				lockCheckAction = true;
    				asyncModePreference.setChecked(true);
    				setReloadDeck();
    			}
    		});
    		builder.setNegativeButton(res.getString(R.string.no), null);
    		break;
        case DIALOG_WRITE_ANSWERS:
    		builder.setTitle(res.getString(R.string.write_answers));
    		builder.setCancelable(false);
    		builder.setMessage(res.getString(R.string.write_answers_message));
    		builder.setNegativeButton(res.getString(R.string.ok), null);
    		break;
        }
		return builder.create();    	
    }


    private DeckTask.TaskListener mDeckOperationHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
        	mProgressDialog = ProgressDialog.show(Preferences.this, """", dialogMessage, true);
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
        		mProgressDialog.dismiss();
        	}
        	lockCheckAction = false;
        }
    };

}
",True,39,65,0,0,4,29
9,com.ichi2.anki.SharedDeckDownload.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.os.Parcel;
import android.os.Parcelable;

public class SharedDeckDownload extends Download implements Parcelable {

    public static final int STATUS_UPDATING = 5;

    private static final long serialVersionUID = 1L;

    private int mId;
    private String mFilename;
    private int mNumUpdatedCards;
    private int mNumTotalCards;
    private double mEstTimeToCompletion;


    public SharedDeckDownload(String title) {
        super(title);
    }


    public SharedDeckDownload(int id, String title) {
        super(title);
        mId = id;
    }


    public int getId() {
        return mId;
    }


    public void setNumTotalCards(int numTotalCards) {
        mNumTotalCards = numTotalCards;
    }


    public int getNumUpdatedCards() {
        return mNumUpdatedCards;
    }


    public void setNumUpdatedCards(int numUpdatedCards) {
        mNumUpdatedCards = numUpdatedCards;
    }


    // ETA: estimated time for completion in seconds
    @Override
    public String getEstTimeToCompletion() {

        if (mEstTimeToCompletion < 0.1) {
            return """";
        }

        long estTime = (long) mEstTimeToCompletion;
        long hours = estTime / 3600;
        estTime %= 3600;
        long minutes = estTime / 60;
        long seconds = estTime % 60;

        if (hours > 0) {
            if (minutes > 0) {
                return String.format(""~ %dh %dm"", hours, minutes);
            } else {
                return String.format(""~ %dh"", hours);
            }
        } else if (minutes > 10) {
            return String.format(""~ %dm"", minutes);
        } else if (minutes > 0) {
            if (seconds > 0) {
                return String.format(""~ %dm %ds"", minutes, seconds);
            } else {
                return String.format(""~ %dm"", minutes);
            }
        } else {
            return String.format(""~ %ds"", seconds);
        }
    }


    @Override
    public void setEstTimeToCompletion(double estTime) {
        mEstTimeToCompletion = estTime;
    }


    @Override
    public int getProgress() {
        if (mStatus == STATUS_UPDATING || mStatus == STATUS_PAUSED) {
            if (mNumTotalCards > 0) {
                return (int) (((float) mNumUpdatedCards / mNumTotalCards) * 100);
            } else {
                return 0;
            }
        } else {
            return super.getProgress();
        }
    }


    /********************************************************************
     * Parcel methods *
     ********************************************************************/

    public SharedDeckDownload(Parcel in) {
        super(in);
        readFromParcel(in);
    }


    @Override
    public int describeContents() {
        return 0;
    }


    @Override
    public void writeToParcel(Parcel dest, int flags) {
        super.writeToParcel(dest, flags);
        dest.writeInt(mId);
        dest.writeString(mFilename);
        dest.writeInt(mNumUpdatedCards);
    }


    @Override
    protected void readFromParcel(Parcel in) {
        super.readFromParcel(in);
        mId = in.readInt();
        mFilename = in.readString();
        mNumUpdatedCards = in.readInt();
    }

    public static final Parcelable.Creator<SharedDeckDownload> CREATOR = new Parcelable.Creator<SharedDeckDownload>() {

        @Override
        public SharedDeckDownload createFromParcel(Parcel in) {
            return new SharedDeckDownload(in);
        }


        @Override
        public SharedDeckDownload[] newArray(int size) {
            return new SharedDeckDownload[size];
        }
    };
}
",False,9,5,2,2,1,1
10,com.ichi2.anki.Sound.java,"/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.io.File;
import java.net.URI;

import android.media.AudioManager;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnCompletionListener;
import android.net.Uri;
import android.util.Log;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to parse, load and play sound files on AnkiDroid.
 */
public class Sound {

    /**
     * Pattern used to identify the markers for sound files
     */
    public static Pattern sSoundPattern = Pattern.compile(""\\[sound\\:([^\\[\\]]*)\\]"");

    /**
     * Media player used to play the sounds
     */
    private static MediaPlayer sMediaPlayer;

    /**
     * ArrayList to store the current sound paths
     */
    private static ArrayList<String> sSoundPaths;

    /**
     * Counter of the number of sounds played out of the total number of sounds in soundPaths
     */
    private static int sNumSoundsPlayed;

    /* Prevent class from being instantiated */
    private Sound() { }


    public static String parseSounds(String soundDir, String content, boolean ttsEnabled, int qa) {
    	boolean soundAvailable = false;
        StringBuilder stringBuilder = new StringBuilder();
        String contentLeft = content;

        // Log.i(AnkiDroidApp.TAG, ""parseSounds"");
        sSoundPaths = new ArrayList<String>();
        Matcher matcher = sSoundPattern.matcher(content);
        // While there is matches of the pattern for sound markers
        while (matcher.find()) {
        	soundAvailable = true;
            // Get the sound file name
            String sound = matcher.group(1);

            // Construct the sound path and store it
            String soundPath = soundDir + Uri.encode(sound);
            sSoundPaths.add(soundPath);

            // Construct the new content, appending the substring from the beginning of the content left until the
            // beginning of the sound marker
            // and then appending the html code to add the play button
            String soundMarker = matcher.group();
            int markerStart = contentLeft.indexOf(soundMarker);
            stringBuilder.append(contentLeft.substring(0, markerStart));        
            stringBuilder
                .append(""<a onclick=\""window.interface.playSound(this.title);\"" title=\""""
                        + soundPath
                        + ""\""><span style=\""padding:5px;display:inline-block;vertical-align:middle\""><img src=\""file:///android_asset/media_playback_start2.png\"" /></span></a>"");
            contentLeft = contentLeft.substring(markerStart + soundMarker.length());
            // Log.i(AnkiDroidApp.TAG, ""Content left = "" + contentLeft);
        }
        if (!soundAvailable && ttsEnabled && !ReadText.getLanguage(qa).equals(ReadText.NO_TTS)) {
            stringBuilder.append(content.substring(0, content.length() - 9));        
            stringBuilder
                .append(""<a onclick=\""window.interface.playSound(this.title);\"" title=\""tts"" + Integer.toString(qa)
                		+ Utils.stripHTML(content)
                        + ""\""><span style=\""padding:5px;display:inline-block;vertical-align:middle\""><img src=\""file:///android_asset/media_playback_start2.png\"" /></span></a>"");
            contentLeft = ""</p>"";
        }

        stringBuilder.append(contentLeft);

        return stringBuilder.toString();
    }


    /**
     * Plays the sounds stored on the paths indicated by mSoundPaths.
     */
    public static void playSounds(String text, int qa) {
        // If there are sounds to play for the current card, play the first one
    	if (sSoundPaths != null && sSoundPaths.size() > 0) {
            sNumSoundsPlayed = 0;
            playSound(sNumSoundsPlayed);
        } else if (text != null && Integer.valueOf(android.os.Build.VERSION.SDK) > 3) {
        	ReadText.textToSpeech(text, qa);
        }
    }


    /**
     * Play the sound indicated by the path stored on the position soundToPlayIndex of the mSoundPaths array.
     *
     * @param soundToPlayIndex
     */
    private static void playSound(int soundToPlayIndex) {
        playSound(sSoundPaths.get(soundToPlayIndex), true);
    }

    public static void playSound(String soundPath, boolean playAll) {
        if (soundPath.substring(0, 3).equals(""tts"")) {
        	ReadText.textToSpeech(soundPath.substring(4, soundPath.length()), Integer.parseInt(soundPath.substring(3, 4)));
        } else if (sSoundPaths.contains(soundPath)) {
    	    sMediaPlayer = new MediaPlayer();
    	    try {
    	        // soundPath is usually an URI, but Media player requires a path not url encoded
                URI soundURI = new URI(soundPath);
                soundPath = new File(soundURI).getAbsolutePath();
                sMediaPlayer.setDataSource(soundPath);
                sMediaPlayer.setVolume(AudioManager.STREAM_MUSIC, AudioManager.STREAM_MUSIC);
                sMediaPlayer.prepare();
                if (playAll) {
                    sMediaPlayer.setOnCompletionListener(new OnCompletionListener() {

                        @Override
                        public void onCompletion(MediaPlayer mp) {
                            releaseSound();
                            sNumSoundsPlayed++;

                            // If there is still more sounds to play for the current card, play the next one
                            if (sNumSoundsPlayed < sSoundPaths.size()) {
                                playSound(sNumSoundsPlayed);
                            }
                        }
                    });
                }
                sMediaPlayer.start();
            } catch (Exception e) {
                Log.e(AnkiDroidApp.TAG, ""playSounds - Error reproducing sound "" + soundPath + "" = "" + e.getMessage());
                releaseSound();
            }
        }
    }


    /**
     * Releases the sound.
     */
    private static void releaseSound() {
        if (sMediaPlayer != null) {
            sMediaPlayer.release();
            sMediaPlayer = null;
        }
    }


    /**
     * Stops the playing sounds.
     */
    public static void stopSounds() {
        if (sMediaPlayer != null) {
            sMediaPlayer.stop();
            releaseSound();
        }
        if (Integer.valueOf(android.os.Build.VERSION.SDK) > 3) {
        	ReadText.stopTts();
        }
    }
}
",True,5,63,0,0,5,29
11,com.ichi2.anki.FieldModel.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.database.Cursor;

import java.util.Comparator;
import java.util.TreeMap;

/**
 * Fields are the different pieces of data which make up a fact.
 *
 * @see http://ichi2.net/anki/wiki/ModelProperties#Fields
 */
public class FieldModel implements Comparator<FieldModel> {

    // BEGIN SQL table entries
    private long mId;
    private int mOrdinal;
    private long mModelId;
    private String mName = """";
    private String mDescription = """";
    // Reused as RTL marker
//    private String mFeatures = """";
//    private int mRequired = 1;
//    private int mUnique = 1;
//    private int mNumeric = 0;
    // Display
    private String mQuizFontFamily = CardModel.DEFAULT_FONT_FAMILY;
    private int mQuizFontSize = CardModel.DEFAULT_FONT_SIZE;
    private String mQuizFontColour;
//    private String mEditFontFamily = ""1""; // reused as <pre> toggle
    private int mEditFontSize = CardModel.DEFAULT_FONT_SIZE;
    // END SQL table entries

    /**
     * Backward reference
     */
//    private Model mModel;


    public FieldModel(long id, int ordinal, long modelId, String name, String description) {
        mId = id;
        mOrdinal = ordinal;
        mModelId = modelId;
        mName = name;
        mDescription = description;
    }


    public FieldModel(String name, boolean required, boolean unique) {
        mName = name;
//        mRequired = required ? 1 : 0;
//        mUnique = unique ? 1 : 0;
        mId = Utils.genID();
    }


    public FieldModel() {
        this("""", true, true);
    }

    /** SELECT string with only those fields, which are used in AnkiDroid */
    private static final String SELECT_STRING = ""SELECT id, ordinal, modelId, name, description""
            + "", quizFontFamily, quizFontSize, quizFontColour""
            + "" FROM fieldModels"";


    /**
     * Return all field models.
     * @param modelId
     * @param models will be changed by adding all found FieldModels into it
     * @return unordered FieldModels which are related to a given Model put into the parameter ""models""
     */
    protected static final void fromDb(Deck deck, long modelId, TreeMap<Long, FieldModel> models) {
        Cursor cursor = null;
        FieldModel myFieldModel = null;
        try {
            StringBuffer query = new StringBuffer(SELECT_STRING);
            query.append("" WHERE modelId = "");
            query.append(modelId);

            cursor = AnkiDatabaseManager.getDatabase(deck.getDeckPath()).getDatabase().rawQuery(query.toString(), null);

            if (cursor.moveToFirst()) {
                do {
                    myFieldModel = new FieldModel();

                    myFieldModel.mId = cursor.getLong(0);
                    myFieldModel.mOrdinal = cursor.getInt(1);
                    myFieldModel.mModelId = cursor.getLong(2);
                    myFieldModel.mName = cursor.getString(3);
                    myFieldModel.mDescription = cursor.getString(4);
                    myFieldModel.mQuizFontFamily = cursor.getString(5);
                    myFieldModel.mQuizFontSize = cursor.getInt(6);
                    myFieldModel.mQuizFontColour = cursor.getString(7);
                    models.put(myFieldModel.mId, myFieldModel);
                } while (cursor.moveToNext());
            }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
    }

    protected void toDB(Deck deck) {
        ContentValues values = new ContentValues();
        values.put(""id"", mId);
        values.put(""ordinal"", mOrdinal);
        values.put(""modelId"", mModelId);
        values.put(""name"", mName);
        values.put(""description"", mDescription);
        values.put(""quizFontFamily"", mQuizFontFamily);
        values.put(""quizFontSize"", mQuizFontSize);
        values.put(""quizFontColour"", mQuizFontColour);
        deck.getDB().update(deck, ""fieldModels"", values, ""id = "" + mId, null);
    }


    // XXX Unused
//    public FieldModel copy() {
//        FieldModel fieldModel = new FieldModel(mName, (mRequired == 1) ? true : false, (mUnique == 1) ? true : false);
//        fieldModel.mOrdinal = mOrdinal;
//        fieldModel.mModelId = mModelId;
//        fieldModel.mDescription = mDescription;
//        fieldModel.mFeatures = mFeatures;
//        fieldModel.mNumeric = mNumeric;
//        fieldModel.mQuizFontFamily = mQuizFontFamily;
//        fieldModel.mQuizFontSize = mQuizFontSize;
//        fieldModel.mQuizFontColour = mQuizFontColour;
//        fieldModel.mEditFontFamily = mEditFontFamily;
//        fieldModel.mEditFontSize = mEditFontSize;
//        fieldModel.mModel = null;
//
//        return fieldModel;
//    }


    /**
     * Implements Comparator by comparing the field ""ordinal"".
     * @param object1
     * @param object2
     * @return
     */
    public int compare(FieldModel object1, FieldModel object2) {
        return object1.mOrdinal - object2.mOrdinal;
    }


    /**
     * @return the name
     */
    public String getName() {
        return mName;
    }


    /**
     * @return the id
     */
    public long getId() {
        return mId;
    }


    /**
     * @return the ordinal
     */
    public int getOrdinal() {
        return mOrdinal;
    }


    /**
     * @return the quizFontFamily
     */
    public String getQuizFontFamily() {
        return mQuizFontFamily;
    }
    public void setQuizFontFamily(String quizFontFamily) {
        mQuizFontFamily = quizFontFamily;
    }


    /**
     * @return the quizFontSize
     */
    public int getQuizFontSize() {
        return mQuizFontSize;
    }
    public void setQuizFontSize(int quizFontSize) {
        mQuizFontSize = quizFontSize;
    }


    /**
     * @return the quizFontColour
     */
    public String getQuizFontColour() {
        return mQuizFontColour;
    }
    public void setQuizFontColour(String quizFontColour) {
        mQuizFontColour = quizFontColour;
    }

    public int getEditFontSize() {
        return mEditFontSize;
    }
    public void setEditFontSize(int editFontSize) {
        mEditFontSize = editFontSize;
    }
    
    /**
     * 
     * @param aModelId
     * @param aName
     * @return 0 if the search parameters do not match, the mId else
     */
    public long match(long aModelId, String aName) {
    	if (mName.equalsIgnoreCase(aName) && mModelId == aModelId) {
    		return mId;
    	}
    	return 0l;
    }
}
",False,38,63,0,0,5,24
12,com.ichi2.anki.Model.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2010 Rick Gruber-Riemer <rick@vanosten.net>                            *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.database.Cursor;
import android.graphics.Color;

import com.mindprod.common11.StringTools;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * Anki model. A model describes the type of information you want to input, and the type of cards which should be
 * generated. See http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Models There can be several models in a Deck. A Model
 * is related to a Deck via attribute deckId. A CardModel is related to a Model via CardModel's modelId. A FieldModel is
 * related to a Model via FieldModel's modelId A Card has a link to CardModel via Card's cardModelId A Card has a link
 * to a Fact via Card's factId A Field has a link to a Fact via Field's factId A Field has a link to a FieldModel via
 * Field's fieldModelId => In order to get the CardModel and all FieldModels for a given Card: % the CardModel can
 * directly be retrieved from the DB using the Card's cardModelId % then from the retrieved CardModel we can get the
 * modelId % using the modelId we can get all FieldModels from the DB % (alternatively in the CardModel the qformat and
 * aformat fields could be parsed for relevant field names and then this used to only get the necessary fields. But this
 * adds a lot overhead vs. using a bit more memory)
 */
public class Model {

    /** Singleton */
    // private static Model currentModel;

    /** Text align constants */
    private static final String[] align_text = { ""center"", ""left"", ""right"" };

    /**
     * A Map of the currently loaded Models. The Models are loaded from the database as soon as they are needed for the
     * first time. This is a compromise between RAM need, speed and the probability with which more than one Model is
     * needed. If only one model is needed, then RAM consumption is basically the same as having a static ""currentModel""
     * variable. If more than one Model is needed, then more RAM is needed, but on the other hand side Model and its
     * related CardModel and FieldModel are not reloaded again and again. This Map uses the Model.id field as key
     */
    private static HashMap<Long, Model> sModels = new HashMap<Long, Model>();

    /**
     * As above but mapping from CardModel to related Model (because when one has a Card, then you need to jump from
     * CardModel to Model.
     */
    private static HashMap<Long, Model> sCardModelToModelMap = new HashMap<Long, Model>();

    // BEGIN SQL table entries
    private long mId; // Primary key
    private long mDeckId; // Foreign key
    private double mCreated = Utils.now();
    private double mModified = Utils.now();
    private String mTags = """";
    private String mName;
    private String mDescription = """";
    private String mFeatures = """"; // used as the media url
    private double mSpacing = 0.1; // obsolete as of libanki 1.1.4
    private double mInitialSpacing = 60; // obsolete as of libanki 1.1.4
    private int mSource = 0;
    // BEGIN SQL table entries

    private Deck mDeck;

    /** Map for convenience and speed which contains CardModels from current model */
    private LinkedHashMap<Long, CardModel> mCardModelsMap = new LinkedHashMap<Long, CardModel>();

    /** Map for convenience and speed which contains FieldModels from current model */
    private TreeMap<Long, FieldModel> mFieldModelsMap = new TreeMap<Long, FieldModel>();

    /** Map for convenience and speed which contains the CSS code related to a CardModel */
    private HashMap<Long, String> mCssCardModelMap = new HashMap<Long, String>();

    private HashMap<Long, String> mColorCardModelMap = new HashMap<Long, String>();

    /**
     * The percentage chosen in preferences for font sizing at the time when the css for the CardModels related to this
     * Model was calculated in prepareCSSForCardModels.
     */
    private transient int mDisplayPercentage = 0;

    private boolean mInvertedColor = false;

    private Model(Deck deck, String name) {
        mDeck = deck;
        mName = name;
        mId = Utils.genID();
    }


    private Model(Deck deck) {
        this(deck, """");
    }


    // XXX: Unused
    // public void setModified() {
    // mModified = Utils.now();
    // }

    /**
     * FIXME: this should be called whenever the deck is changed. Otherwise unnecessary space will be used. XXX: Unused
     */
    protected static final void reset() {
        sModels = new HashMap<Long, Model>();
        sCardModelToModelMap = new HashMap<Long, Model>();
    }


    /**
     * Returns a Model based on the submitted identifier. If a model id is submitted (isModelId = true), then the Model
     * data and all related CardModel and FieldModel data are loaded, unless the id is the same as one of the
     * currentModel. If a cardModel id is submitted, then the related Model data and all related CardModel and
     * FieldModel data are loaded unless the cardModel id is already in the cardModel map. FIXME: nothing is done to
     * treat db failure or non-existing identifiers
     * 
     * @param deck The deck we are working with
     * @param identifier a cardModel id or a model id
     * @param isModelId if true then the submitted identifier is a model id; otherwise the identifier is a cardModel id
     * @return
     */
    protected static Model getModel(Deck deck, long identifier, boolean isModelId) {
        if (!isModelId) {
            // check whether the identifier is in the cardModelToModelMap
            if (!sCardModelToModelMap.containsKey(identifier)) {
                // get the modelId
                long myModelId = CardModel.modelIdFromDB(deck, identifier);
                // get the model
                loadFromDBPlusRelatedModels(deck, myModelId);
            }
            return sCardModelToModelMap.get(identifier);
        }
        // else it is a modelId
        if (!sModels.containsKey(identifier)) {
            // get the model
            loadFromDBPlusRelatedModels(deck, identifier);
        }
        return sModels.get(identifier);
    }


    public static HashMap<Long, Model> getModels(Deck deck) {
        Model mModel;
        HashMap<Long, Model> mModels = new HashMap<Long, Model>();

        Cursor mCursor = null;
        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
        try {
            mCursor = ankiDB.getDatabase().rawQuery(""SELECT id FROM models"", null);
            if (!mCursor.moveToFirst()) {
                return mModels;
            }
            do {
                Long id = mCursor.getLong(0);
                mModel = getModel(deck, id, true);
                mModels.put(id, mModel);

            } while (mCursor.moveToNext());

        } finally {
            if (mCursor != null) {
                mCursor.close();
            }
        }
        return mModels;
    }


    public TreeMap<Long, FieldModel> getFieldModels() {
        TreeMap<Long, FieldModel> mFieldModels = new TreeMap<Long, FieldModel>();
        FieldModel.fromDb(mDeck, mId, mFieldModels);
        return mFieldModels;

    }


    public List<CardModel> getCardModels() {
        return new ArrayList<CardModel>(mCardModelsMap.values());
    }


    protected final CardModel getCardModel(long identifier) {
        return mCardModelsMap.get(identifier);
    }


    /**
     * Loads the Model from the database. then loads the related CardModels and FieldModels from the database.
     *
     * @param deck
     * @param modelId
     */
    private static void loadFromDBPlusRelatedModels(Deck deck, long modelId) {
        Model currentModel = fromDb(deck, modelId);

        // load related card models
        CardModel.fromDb(deck, currentModel.mId, currentModel.mCardModelsMap);

        // load related field models
        FieldModel.fromDb(deck, modelId, currentModel.mFieldModelsMap);

        // make relations to maps
        sModels.put(currentModel.mId, currentModel);
        CardModel myCardModel = null;
        for (Map.Entry<Long, CardModel> entry : currentModel.mCardModelsMap.entrySet()) {
            myCardModel = entry.getValue();
            sCardModelToModelMap.put(myCardModel.getId(), currentModel);
        }
    }


    protected void saveToDBPlusRelatedModels(Deck deck) {
        for (CardModel cm : mCardModelsMap.values()) {
            cm.toDB(deck);
        }
        for (FieldModel fm : mFieldModelsMap.values()) {
            fm.toDB(deck);
        }
        toDB(deck);
    }


    protected void toDB(Deck deck) {
        ContentValues values = new ContentValues();
        values.put(""id"", mId);
        values.put(""deckid"", mDeckId);
        values.put(""created"", mCreated);
        values.put(""modified"", mModified);
        values.put(""tags"", mTags);
        values.put(""name"", mName);
        values.put(""description"", mDescription);
        values.put(""features"", mFeatures);
        values.put(""spacing"", mSpacing);
        values.put(""initialSpacing"", mInitialSpacing);
        values.put(""source"", mSource);
        deck.getDB().update(deck, ""models"", values, ""id = "" + mId, null);

    }


    /**
     * Loads a model from the database based on the id. FIXME: nothing is done in case of db error or no returned row
     * 
     * @param deck
     * @param id
     * @return
     */
    private static Model fromDb(Deck deck, long id) {
        Cursor cursor = null;
        Model model = null;
        try {
            StringBuffer query = new StringBuffer();
            query.append(""SELECT id, deckId, created, modified, tags, name, description"");
            query.append("", features, spacing, initialSpacing, source"");
            query.append("" FROM models"");
            query.append("" WHERE id = "").append(id);
            cursor = AnkiDatabaseManager.getDatabase(deck.getDeckPath()).getDatabase().rawQuery(query.toString(), null);

            if (cursor.moveToFirst()) {
	            model = new Model(deck);
	    }

            model.mId = cursor.getLong(0); // Primary key
            model.mDeckId = cursor.getLong(1); // Foreign key
            model.mCreated = cursor.getDouble(2);
            model.mModified = cursor.getDouble(3);
            model.mTags = cursor.getString(4);
            model.mName = cursor.getString(5);
            model.mDescription = cursor.getString(6);
            model.mFeatures = cursor.getString(7);
            model.mSpacing = cursor.getDouble(8);
            model.mInitialSpacing = cursor.getDouble(9);
            model.mSource = cursor.getInt(10);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return model;
    }


    /**
     * @return the ID
     */
    public long getId() {
        return mId;
    }


    /**
     * Prepares the CSS for all CardModels in this Model
     */
    private void prepareCSSForCardModels(boolean invertedColors, int nightModeBackground) {
        CardModel myCardModel = null;
        String cssString = null;
        for (Map.Entry<Long, CardModel> entry : mCardModelsMap.entrySet()) {
            myCardModel = entry.getValue();
            cssString = createCSSForFontColorSize(myCardModel.getId(), mDisplayPercentage, invertedColors, nightModeBackground);
            mCssCardModelMap.put(myCardModel.getId(), cssString);
        }
    }


    /**
     * Prepares the Background Colors for all CardModels in this Model
     */
    private void prepareColorForCardModels(boolean invertedColors, int nightModeBackground) {
        CardModel myCardModel = null;
        String color = null;
        mColorCardModelMap.clear();
        for (Map.Entry<Long, CardModel> entry : mCardModelsMap.entrySet()) {
            myCardModel = entry.getValue();
            color = invertColor(myCardModel.getLastFontColour(), invertedColors);
        	if (nightModeBackground != Color.BLACK && Color.parseColor(color) == Color.BLACK) {
        		color = String.format(""#%X"", nightModeBackground);
        	}
            mColorCardModelMap.put(myCardModel.getId(), color);
        }
    }


    /**
     * Returns a cached CSS for the font color and font size of a given CardModel taking into account the included
     * fields
     *
     * @param myCardModelId
     * @param percentage the preference factor to use for calculating the display font size from the cardmodel and
     *            fontmodel font size
     * @return the html contents surrounded by a css style which contains class styles for answer/question and fields
     */
    protected final String getCSSForFontColorSize(long myCardModelId, int percentage, boolean invertedColors, int nightModeBackground) {
        // If the percentage or night mode has changed, prepare for them.
        if (mDisplayPercentage != percentage || mInvertedColor != invertedColors) {
            mDisplayPercentage = percentage;
            mInvertedColor = invertedColors;
            prepareColorForCardModels(invertedColors, nightModeBackground);
            prepareCSSForCardModels(invertedColors, nightModeBackground);
        }
        return mCssCardModelMap.get(myCardModelId);
    }


    protected final int getBackgroundColor(long myCardModelId) {
		String color = mColorCardModelMap.get(myCardModelId);
		if (color != null) {
			return Color.parseColor(color);
		} else {
			return Color.WHITE;
        }
    }


    /**
     * @param myCardModelId
     * @param percentage the factor to apply to the font size in card model to the display size (in %)
     * @return the html contents surrounded by a css style which contains class styles for answer/question and fields
     */
    private String createCSSForFontColorSize(long myCardModelId, int percentage, boolean invertedColors, int nightModeBackground) {
        StringBuffer sb = new StringBuffer();
        sb.append(""<!-- "").append(percentage).append("" % display font size-->"");
        sb.append(""<style type=\""text/css\"">\n"");
        CardModel myCardModel = mCardModelsMap.get(myCardModelId);

        // body background
        if (null != myCardModel.getLastFontColour() && 0 < myCardModel.getLastFontColour().trim().length()) {
        	String color = invertColor(myCardModel.getLastFontColour(), invertedColors);
        	if (nightModeBackground != Color.BLACK && Color.parseColor(color) == Color.BLACK) {
        		color = String.format(""#%X"", nightModeBackground);
        	}
            sb.append(""body {background-color:"").append(color).append("";}\n"");
        }
        // question
        sb.append(""."").append(Reviewer.QUESTION_CLASS).append("" {\n"");
        sb.append(calculateDisplay(percentage, myCardModel.getQuestionFontFamily(), myCardModel.getQuestionFontSize(),
                myCardModel.getQuestionFontColour(), myCardModel.getQuestionAlign(), false, invertedColors));
        sb.append(""}\n"");
        // answer (alignment is stored in question as alignment is shared in question and answer)
        sb.append(""."").append(Reviewer.ANSWER_CLASS).append("" {\n"");
        sb.append(calculateDisplay(percentage, myCardModel.getAnswerFontFamily(), myCardModel.getAnswerFontSize(),
                myCardModel.getAnswerFontColour(), myCardModel.getQuestionAlign(), false, invertedColors));
        sb.append(""}\n"");
        // css for fields. Gets css for all fields no matter whether they actually are used in a given card model
        FieldModel myFieldModel = null;
        String hexId = null; // a FieldModel id in unsigned hexa code for the class attribute
        for (Map.Entry<Long, FieldModel> entry : mFieldModelsMap.entrySet()) {
            myFieldModel = entry.getValue();
            hexId = ""fm"" + Long.toHexString(myFieldModel.getId());
            sb.append(""."").append(hexId).append("" {\n"");
            sb.append(calculateDisplay(percentage, myFieldModel.getQuizFontFamily(), myFieldModel.getQuizFontSize(),
                    myFieldModel.getQuizFontColour(), 0, true, invertedColors));
            sb.append(""}\n"");
        }

        // finish
        sb.append(""</style>"");
        return sb.toString();
    }


    /**
     * Returns a string where all colors have been inverted.
     * It applies to anything that is in a tag and looks like #FFFFFF
     * 
     * Example: Here only #000000 will be replaced (#777777 is content)
     * <span style=""color: #000000;"">Code #777777 is the grey color</span>
     * 
     * This is done with a state machine with 2 states:
     *  - 0: within content
     *  - 1: within a tag
     */
    public static String invertColors(String text, boolean invert) {
        if (invert) {
            int state = 0;
            StringBuffer inverted = new StringBuffer(text.length());
            for(int i=0; i<text.length(); i++) {
                char character = text.charAt(i);
                if (state == 1 && character == '#') {
                    inverted.append(invertColor(text.substring(i+1, i+7), true));
                }
                else {
                    if (character == '<') {
                        state = 1;
                    }
                    if (character == '>') {
                        state = 0;
                    }
                    inverted.append(character);
                }
            }
            return inverted.toString();
        }
        else {
            return text;
        }
    }
    

    private static String invertColor(String color, boolean invert) {
    	if (invert) {
    	    if (color != null) {
    	        color = StringTools.toUpperCase(color);
    	    }
            final char[] items = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
            final char[] tmpItems = {'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v'};
            for (int i = 0; i < 16; i++) {
                color = color.replace(items[i], tmpItems[15-i]);
            }
            for (int i = 0; i < 16; i++) {
                color = color.replace(tmpItems[i], items[i]);
            }
		}
		return color;		
    }


    private static String calculateDisplay(int percentage, String fontFamily, int fontSize, String fontColour,
            int align, boolean isField, boolean invertedColors) {
        StringBuffer sb = new StringBuffer();
        if (null != fontFamily && 0 < fontFamily.trim().length()) {
            sb.append(""font-family:\"""").append(fontFamily).append(""\"";\n"");
        }
        if (null != fontColour && 0 < fontColour.trim().length()) {
            sb.append(""color:"").append(invertColor(fontColour, invertedColors)).append("";\n"");
        }
        if (0 < fontSize) {
            sb.append(""font-size:"");
            sb.append((percentage * fontSize) / 100);
            sb.append(""px;\n"");
        }

        if (!isField) {
            sb.append(""text-align:"");
            sb.append(align_text[align]);
            sb.append("";\n"");
            sb.append(""padding-left:5px;\n"");
            sb.append(""padding-right:5px;\n"");
        }

        return sb.toString();
    }


    /**
     * @return the name
     */
    public String getName() {
        return mName;
    }


    /**
     * @return the tags
     */
    public String getTags() {
        return mTags;
    }


    public String getFeatures() {
        return mFeatures;
    }

    public Boolean hasTag(String tag) {
    	if(mTags==null || mTags.equals(""""))
    		return false;
    		
		if(mTags.equals(tag))
			return true;
		
    	return Arrays.asList(mTags.split("" "")).contains(tag);
    }
}
",True,50,63,0,0,4,30
13,com.ichi2.anki.LaTeX.java,"/***************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.text.Html;
import android.util.Log;

import java.lang.StringBuilder;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to display and handle correctly LaTeX.
 */
public class LaTeX {

    /**
     * Patterns used to identify LaTeX tags
     */
    public static Pattern sStandardPattern = Pattern
            .compile(""\\[latex\\](.+?)\\[/latex\\]"");
    public static Pattern sExpressionPattern = Pattern
            .compile(""\\[\\$\\](.+?)\\[/\\$\\]"");
    public static Pattern sMathPattern = Pattern
            .compile(""\\[\\$\\$\\](.+?)\\[/\\$\\$\\]""); 

    ///Use this to replace <br> tags
    private static Pattern sBRPattern = Pattern
            .compile(""<br( /)?>"");

    /* Prevent class from being instantiated */
    private LaTeX() { }

    /**
     * Parses the content (belonging to deck), replacing LaTeX with img tags
     *
     * @TODO should check to see if the image exists or not? Or can we assume that
     * the user is bright enough to compile stuff if they are using LaTeX?
     * @param deck Deck whose content is being parsed
     * @param content HTML content of a card
     * @return content Content with the onload events for the img tags
     */
    public static String parseLaTeX(Deck deck, String content) {

        StringBuilder stringBuilder = new StringBuilder();
        String contentLeft = content;
        String latex;

        //First pass, grab everything that the standard pattern gets
        // Log.i(AnkiDroidApp.TAG, ""parseLaTeX"");
        Matcher matcher = sStandardPattern.matcher(contentLeft);
        while (matcher.find()) {
            latex = matcher.group(1);
            String img = mungeLatex(deck, latex);
            img = ""latex-"" + Utils.checksum(img) + "".png"";

            String imgTag = matcher.group();
            int markerStart = contentLeft.indexOf(imgTag);
            stringBuilder.append(contentLeft.substring(0, markerStart));
            stringBuilder.append(""<img src=\"""" + img + ""\"" alt=\"""" + latex + ""\"">"");

            contentLeft = contentLeft.substring(markerStart + imgTag.length());
        }
        stringBuilder.append(contentLeft);

        //Second pass, grab everything that the expression pattern gets
        contentLeft = stringBuilder.toString();
        stringBuilder = new StringBuilder();
        matcher = sExpressionPattern.matcher(contentLeft);
        while (matcher.find()) {
            latex = matcher.group(1);
            String img = ""$"" + mungeLatex(deck, latex) + ""$"";
            img = ""latex-"" + Utils.checksum(img) + "".png"";

            String imgTag = matcher.group();
            int markerStart = contentLeft.indexOf(imgTag);
            stringBuilder.append(contentLeft.substring(0, markerStart));
            stringBuilder.append(""<img src=\"""" + img + ""\"" alt=\"""" + latex + ""\"">"");

            contentLeft = contentLeft.substring(markerStart + imgTag.length());
        }
        stringBuilder.append(contentLeft);

        //Thid pass, grab everything that the math pattern gets
        contentLeft = stringBuilder.toString();
        stringBuilder = new StringBuilder();
        matcher = sMathPattern.matcher(contentLeft);
        while (matcher.find()) {
            latex = matcher.group(1);
            String img = ""\\begin{displaymath}"" + mungeLatex(deck, latex) + ""\\end{displaymath}"";
            img = ""latex-"" + Utils.checksum(img) + "".png"";

            String imgTag = matcher.group();
            int markerStart = contentLeft.indexOf(imgTag);
            stringBuilder.append(contentLeft.substring(0, markerStart));
            stringBuilder.append(""<img src=\"""" + img + ""\"" alt=\"""" + latex + ""\"">"");

            contentLeft = contentLeft.substring(markerStart + imgTag.length());
        }
        stringBuilder.append(contentLeft);

        return stringBuilder.toString();
    }

    private static final Pattern htmlNamedEntityPattern = Pattern.compile(""(?i)&[a-z]+;"");

    /**
     * Convert entities, fix newlines, convert to utf8, and wrap pre/postamble.
     *
     * @param deck The deck, needed to get the latex pre/post-ambles
     * @param latex The latex trsing to be munged
     * @return the latex string transformed as described above
     */
    private static String mungeLatex(Deck deck, String latex) {
        // Deal with HTML named entities
        StringBuilder sb = new StringBuilder(latex);
        Matcher namedEntity = htmlNamedEntityPattern.matcher(sb);
        while (namedEntity.find()) {
            sb.replace(namedEntity.start(), namedEntity.end(), Html.fromHtml(namedEntity.group()).toString());
            namedEntity = htmlNamedEntityPattern.matcher(sb);
        }
        latex = sb.toString();

        // Fix endlines
        latex = sBRPattern.matcher(latex).replaceAll(""\n"");
     
        // Add pre/post-ambles
        latex = deck.getVar(""latexPre"") + ""\n"" + latex + ""\n"" + deck.getVar(""latexPost"");

        // TODO: Do we need to convert to UTF-8?

        return latex;
    }
}
",True,11,63,0,0,5,25
14,com.ichi2.anki.BackupManager.java,"/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.UnknownFormatConversionException;

import com.tomgibara.android.veecheck.util.PrefSettings;

import android.content.SharedPreferences;
import android.os.StatFs;
import android.util.Log;

public class BackupManager {

	static String mBackupDirectoryPath;
	static String mBrokenDirectoryPath;
	static int mMaxBackups;
	static File mLastCreatedBackup;
	static File[] mLastDeckBackups;

	public final static int RETURN_BACKUP_CREATED = 0;
	public final static int RETURN_ERROR = 1;
	public final static int RETURN_TODAY_ALREADY_BACKUP_DONE = 2;
	public final static int RETURN_NOT_ENOUGH_SPACE = 3;
	public final static int RETURN_DECK_NOT_CHANGED = 4;
	public final static int RETURN_DECK_RESTORED = 5;
	public final static int RETURN_NULL = 6;
	public final static int RETURN_LOW_SYSTEM_SPACE = 7;
	public final static int RETURN_BACKUP_NEEDED = 8;

	public final static String BACKUP_SUFFIX = ""/backup"";
	public final static String BROKEN_DECKS_SUFFIX = ""/broken"";

	private static ArrayList<String> mDeckPickerDecks;
	private static boolean mUseBackups = true;

 	/** Number of day, after which a backup is done on first non-studyoptions-opening (for safety reasons) */
	public static final int SAFETY_BACKUP_THRESHOLD = 3;

	
    /* Prevent class from being instantiated */
	private BackupManager() {
	}


	public static void initBackup() {
		mUseBackups = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getBoolean(""useBackup"", true);
		mDeckPickerDecks = new ArrayList<String>();
	}


	public static boolean isActivated() {
		return mUseBackups;
	}


	private static File getBackupDirectory() {
        if (mBackupDirectoryPath == null) {
        	SharedPreferences prefs = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
    		mBackupDirectoryPath = prefs.getString(""deckPath"", AnkiDroidApp.getStorageDirectory()) + BACKUP_SUFFIX;
        	mMaxBackups = prefs.getInt(""backupMax"", 3);
        }
        File directory = new File(mBackupDirectoryPath);
        if (!directory.isDirectory()) {
        	directory.mkdirs();
        }
        return directory;
	}


	private static File getBrokenDirectory() {
        if (mBrokenDirectoryPath == null) {
        	SharedPreferences prefs = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
        	mBrokenDirectoryPath = prefs.getString(""deckPath"", AnkiDroidApp.getStorageDirectory()) + BROKEN_DECKS_SUFFIX;
        }
        File directory = new File(mBrokenDirectoryPath);
        if (!directory.isDirectory()) {
        	directory.mkdirs();
        }
        return directory;
	}


	/** If deck has not been opened for a long time, we perform a backup here because Android deleted sometimes corrupted decks */
	public static boolean safetyBackupNeeded(String deckpath, int days) {
		if (mDeckPickerDecks == null) {
			initBackup();
		}
		if (!mUseBackups || mDeckPickerDecks.contains(deckpath)) {
			return false;
		}
	        File[] deckBackups = getDeckBackups(new File(deckpath));
	        int len = deckBackups.length;
		if (len == 0) {
			// no backup available
			return true;
		}
		String backupDateString = deckBackups[len - 1].getName().replaceAll(""^.*-(\\d{4}-\\d{2}-\\d{2}).anki$"", ""$1"");
		Date backupDate;
		try {
			backupDate = new SimpleDateFormat(""yyyy-MM-dd"").parse(backupDateString);
		} catch (ParseException e) {
			Log.e(AnkiDroidApp.TAG, ""BackupManager - safetyBackupNeeded - Error on parsing backups: "" + e);
			return true;
		}
        Date target = Utils.genToday(Utils.utcOffset() + (days * 86400));
		if (backupDate.before(target)) {
			return true;
		} else {
			mDeckPickerDecks.add(deckpath);
			return false;
		}
	}


	/** Restores the current deck from backup if Android deleted it */
	public static void restoreDeckIfMissing(String deckpath) {
		if (mUseBackups && !(new File(deckpath)).exists()) {
			Log.e(AnkiDroidApp.TAG, ""BackupManager: Deck "" + deckpath + "" has been deleted by Android. Restoring it:"");
			File[] fl = BackupManager.getDeckBackups(new File(deckpath));
			if (fl.length > 0) {
				Log.e(AnkiDroidApp.TAG, ""BackupManager: Deck "" + deckpath + "" successfully restored"");
				BackupManager.restoreDeckBackup(deckpath, fl[fl.length - 1].getAbsolutePath());					
			} else {
				Log.e(AnkiDroidApp.TAG, ""BackupManager: Deck "" + deckpath + "" could not be restored"");
			}
		}
	}


	public static int backupDeck(String deckpath) {
		if (mDeckPickerDecks == null) {
			initBackup();
		}
		mDeckPickerDecks.add(deckpath);
		mLastCreatedBackup = null;
		mLastDeckBackups = null;
        File deckFile = new File(deckpath);
        File[] deckBackups = getDeckBackups(deckFile);
        int len = deckBackups.length;
        if (len > 0 && deckBackups[len - 1].lastModified() == deckFile.lastModified()) {
    		deleteDeckBackups(deckBackups, mMaxBackups);
        	return RETURN_DECK_NOT_CHANGED;
        }
        Date value = Utils.genToday(Utils.utcOffset());

        String backupFilename;
        try {
        	backupFilename = String.format(Utils.ENGLISH_LOCALE, deckFile.getName().replace("".anki"", """") + ""-%tF.anki"", value);        	
        } catch (UnknownFormatConversionException e) {
        	Log.e(AnkiDroidApp.TAG, ""backupDeck: error on creating backup filename: "" + e);
        	return RETURN_ERROR;
        }

        File backupFile = new File(getBackupDirectory().getPath(), backupFilename);
        if (backupFile.exists()) {
            // Log.i(AnkiDroidApp.TAG, ""No new backup of "" + deckFile.getName() + "" created. Already made one today"");
    		deleteDeckBackups(deckBackups, mMaxBackups);
            return RETURN_TODAY_ALREADY_BACKUP_DONE;
        }

        if (getFreeDiscSpace(deckFile) < deckFile.length() + (StudyOptions.MIN_FREE_SPACE * 1024 * 1024)) {
            Log.e(AnkiDroidApp.TAG, ""Not enough space on sd card to backup "" + deckFile.getName() + ""."");
        	return RETURN_NOT_ENOUGH_SPACE;
        }

        try {
            InputStream stream = new FileInputStream(deckFile);
            Utils.writeToFile(stream, backupFile.getAbsolutePath());
            stream.close();

            // set timestamp of file in order to avoid creating a new backup unless its changed
            backupFile.setLastModified(deckFile.lastModified());
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            Log.e(AnkiDroidApp.TAG, ""Backup file "" + deckFile.getName() + "" - Copying of file failed."");
            return RETURN_ERROR;
        }

        mLastCreatedBackup = backupFile;
        mLastDeckBackups = deckBackups;
        return RETURN_BACKUP_CREATED;
	}


	public static long getFreeDiscSpace(String path) {
		return getFreeDiscSpace(new File(path));
	}
	public static long getFreeDiscSpace(File file) {
		try {
			StatFs stat = new StatFs(file.getParentFile().getPath());
	    	long blocks = stat.getAvailableBlocks();
	    	long blocksize = stat.getBlockSize();
	    	return blocks * blocksize;
		} catch (IllegalArgumentException e) {
			Log.e(AnkiDroidApp.TAG, ""Free space could not be retrieved: "" + e);
			return StudyOptions.MIN_FREE_SPACE * 1024 * 1024;
		}	
	}


	public static boolean cleanUpAfterBackupCreation(boolean deckLoaded) {
		if (deckLoaded) {
			return deleteDeckBackups(mLastDeckBackups, mMaxBackups - 1);
		} else if (mLastCreatedBackup != null) {
			return mLastCreatedBackup.delete();
		}
		return false;
	}


	public static int restoreDeckBackup(String deckpath, String backupPath) {
        // rename old file and move it to subdirectory
    	if ((new File(deckpath)).exists() && !moveDeckToBrokenFolder(deckpath)) {
    		return RETURN_ERROR;
    	}

    	// copy backup to new position and rename it
    	File backupFile = new File(backupPath);
    	File deckFile = new File(deckpath);
        if (getFreeDiscSpace(deckFile) < deckFile.length() + (StudyOptions.MIN_FREE_SPACE * 1024 * 1024)) {
            Log.e(AnkiDroidApp.TAG, ""Not enough space on sd card to restore "" + deckFile.getName() + ""."");
        	return RETURN_NOT_ENOUGH_SPACE;
        }
        try {
            InputStream stream = new FileInputStream(backupFile);
            Utils.writeToFile(stream, deckFile.getAbsolutePath());
            stream.close();

            // set timestamp of file in order to avoid creating a new backup unless its changed
            deckFile.setLastModified(backupFile.lastModified());
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            Log.e(AnkiDroidApp.TAG, ""Restore of file "" + deckFile.getName() + "" failed."");
            return RETURN_ERROR;
        }
		return RETURN_DECK_RESTORED;
	}


	public static boolean repairDeck(String deckPath) {
		File deckFile = new File(deckPath);
		AnkiDatabaseManager.closeDatabase(deckPath);

    	// repair file
    	String execString = ""sqlite3 "" + deckPath + "" .dump | sqlite3 "" + deckPath + "".tmp"";
    	// Log.i(AnkiDroidApp.TAG, ""repairDeck - Execute: "" + execString);
    	try {
    		String[] cmd = {""/system/bin/sh"", ""-c"", execString };
    	    Process process = Runtime.getRuntime().exec(cmd);
    	    process.waitFor();

    		// move deck to broken folder
    		String brokenDirectory = getBrokenDirectory().getPath();
    		Date value = Utils.genToday(Utils.utcOffset());
            String movedFilename = String.format(Utils.ENGLISH_LOCALE, deckFile.getName().replace("".anki"", """") + ""-corrupt-%tF.anki"", value);
            File movedFile = new File(brokenDirectory, movedFilename);
            int i = 1;
            while (movedFile.exists()) {
            	movedFile = new File(brokenDirectory, movedFilename.replace("".anki"", ""-"" + Integer.toString(i) + "".anki""));
            	i++;
            }
            movedFilename = movedFile.getName();
        	if (!deckFile.renameTo(movedFile)) {
        		return false;
        	}
        	// Log.i(AnkiDroidApp.TAG, ""repairDeck - moved corrupt file to "" + movedFile.getAbsolutePath());
        	File repairedFile = new File(deckPath + "".tmp"");
        	if (!repairedFile.renameTo(deckFile)) {
        		return false;
        	}
        	return true;
    	} catch (IOException e) {
    		Log.e(""AnkiDroidApp.TAG"", ""repairDeck - error: "" + e);
    	} catch (InterruptedException e) {
    		Log.e(""AnkiDroidApp.TAG"", ""repairDeck - error: "" + e);
    	}
    	return false;
	}


	public static boolean moveDeckToBrokenFolder(String deckPath) {
		File deckFile = new File(deckPath);
		AnkiDatabaseManager.closeDatabase(deckPath);
        Date value = Utils.genToday(Utils.utcOffset());
        String movedFilename = String.format(Utils.ENGLISH_LOCALE, deckFile.getName().replace("".anki"", """") + ""-corrupt-%tF.anki"", value);
        File movedFile = new File(getBrokenDirectory().getPath(), movedFilename);
        int i = 1;
        while (movedFile.exists()) {
        	movedFile = new File(getBrokenDirectory().getPath(), movedFilename.replace("".anki"", ""-"" + Integer.toString(i) + "".anki""));
        	i++;
        }
        movedFilename = movedFile.getName();
    	if (!deckFile.renameTo(movedFile)) {
    		return false;
    	}
    	
    	// move all connected files (like journals, directories...) too
    	String deckName = deckFile.getName();
    	File directory = new File(deckFile.getParent());
    	for (File f : directory.listFiles()) {
    		if (f.getName().startsWith(deckName)) {
    			if (!f.renameTo(new File(getBrokenDirectory().getPath(), f.getName().replace(deckName, movedFilename)))) {
    				return false;
    			}
    		}
    	}
    	return true;
	}


	public static File[] getDeckBackups(File deckFile) {
		File[] files = getBackupDirectory().listFiles();
		ArrayList<File> deckBackups = new ArrayList<File>();
		for (File aktFile : files){
			if (aktFile.getName().replaceAll(""^(.*)-\\d{4}-\\d{2}-\\d{2}.anki$"", ""$1.anki"").equals(deckFile.getName())) {
				deckBackups.add(aktFile);
			}
		}
		Collections.sort(deckBackups);
		File[] fileList = new File[deckBackups.size()];
		deckBackups.toArray(fileList);
		return fileList;
	}


	public static boolean removeDeck(File deckFile) {
    	String deckName = deckFile.getName();
    	File directory = new File(deckFile.getParent());
    	for (File f : directory.listFiles()) {
    		if (f.getName().startsWith(deckName)) {
    			if (!removeDir(f)) {
    				return false;
    			}
    		}
    	}
    	return true;
	}


	public static boolean deleteDeckBackups(String deckpath, int keepNumber) {
		return deleteDeckBackups(getDeckBackups(new File(deckpath)), keepNumber);
	}
	public static boolean deleteDeckBackups(File deckFile, int keepNumber) {
		return deleteDeckBackups(getDeckBackups(deckFile), keepNumber);
	}
	public static boolean deleteDeckBackups(File[] deckBackups, int keepNumber) {
    	if (deckBackups == null) {
    		return false;
    	}
		for (int i = 0; i < deckBackups.length - keepNumber; i++) {
    		deckBackups[i].delete();
    	}
		return true;
	}


	public static boolean deleteAllBackups() {
		return removeDir(getBackupDirectory());
	}


	public static boolean removeDir(File dir){
		if (dir.isDirectory()){
			File[] files = dir.listFiles();
			for (File aktFile: files){
				removeDir(aktFile);
			}
		}
		return dir.delete();
	}
}
",True,86,63,0,0,5,28
15,com.ichi2.anki.Utils.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.Uri;
import android.text.Html;
import android.util.Log;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.widget.FrameLayout;
import android.widget.LinearLayout;

import com.mindprod.common11.BigDate;
import com.tomgibara.android.veecheck.util.PrefSettings;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Date;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;
import java.util.TreeSet;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.Deflater;

/**
 * TODO comments
 */
public class Utils {
    enum SqlCommandType { SQL_INS, SQL_UPD, SQL_DEL };

    // Used to format doubles with English's decimal separator system
    public static final Locale ENGLISH_LOCALE = new Locale(""en_US"");

    public static final int CHUNK_SIZE = 32768;

    private static final int DAYS_BEFORE_1970 = 719163;

    private static NumberFormat mCurrentNumberFormat;
    private static NumberFormat mCurrentPercentageFormat;

    private static TreeSet<Long> sIdTree;
    private static long sIdTime;

    private static final int TIME_SECONDS = 0;
    private static final int TIME_MINUTES = 1;
    private static final int TIME_HOURS = 2;
    private static final int TIME_DAYS = 3;
    private static final int TIME_MONTHS = 4;
    private static final int TIME_YEARS = 5;

    public static final int TIME_FORMAT_DEFAULT = 0;
    public static final int TIME_FORMAT_IN = 1;
    public static final int TIME_FORMAT_BEFORE = 2;

    /* Prevent class from being instantiated */
    private Utils() { }

    // Regex pattern used in removing tags from text before diff
    private static final Pattern imgPattern = Pattern.compile(""<img src=[\""']?([^\""'>]+)[\""']? ?/?>"");
    private static final Pattern stylePattern = Pattern.compile(""(?s)<style.*?>.*?</style>"");
    private static final Pattern scriptPattern = Pattern.compile(""(?s)<script.*?>.*?</script>"");
    private static final Pattern tagPattern = Pattern.compile(""<.*?>"");
    private static final Pattern htmlEntitiesPattern = Pattern.compile(""&#?\\w+;"");


    /**
     * Return a string representing a time span (eg '2 days').
     * @param inFormat: if true, return eg 'in 2 days'
     */
    public static String fmtTimeSpan(double time, int format) {
    	return fmtTimeSpan(time, format, false);
    }
    public static String fmtTimeSpan(double time, int format, boolean boldNumber) {
    	int type;
    	int unit = 99;
    	int point = 0;
    	if (Math.abs(time) < 60 || unit < 1) {
    		type = TIME_SECONDS;
    	} else if (Math.abs(time) < 3599 || unit < 2) {
    		type = TIME_MINUTES;
    	} else if (Math.abs(time) < 60 * 60 * 24 || unit < 3) {
    		type = TIME_HOURS;
    	} else if (Math.abs(time) < 60 * 60 * 24 * 29.5 || unit < 4) {
    		type = TIME_DAYS;
    	} else if (Math.abs(time) < 60 * 60 * 24 * 30 * 11.95 || unit < 5) {
    		type = TIME_MONTHS;
    		point = 1;
    	} else {
    		type = TIME_YEARS;
    		point = 1;
    	}
    	time = convertSecondsTo(time, type);

    	int formatId;
    	switch (format) {
    	case TIME_FORMAT_IN:
    		if (Math.round(time * 10) == 10) {
    			formatId = R.array.next_review_in_s;
    		} else {
    			formatId = R.array.next_review_in_p;    			
    		}
    		break;
    	case TIME_FORMAT_BEFORE:
    		if (Math.round(time * 10) == 10) {
    			formatId = R.array.next_review_before_s;
    		} else {
    			formatId = R.array.next_review_before_p;    			
    		}
    		break;
    	case TIME_FORMAT_DEFAULT:
    	default:
    		if (Math.round(time * 10) == 10) {
    			formatId = R.array.next_review_s;
    		} else {
    			formatId = R.array.next_review_p;    			
    		}
    		break;
    	}

    	String timeString = String.format(AnkiDroidApp.getAppResources().getStringArray(formatId)[type], boldNumber ? ""<b>"" + fmtDouble(time, point) + ""</b>"" : fmtDouble(time, point));
		if (boldNumber && time == 1) {
			timeString = timeString.replace(""1"", ""<b>1</b>"");
		}
		return timeString;
    }


    private static double convertSecondsTo(double seconds, int type) {
    	switch (type) {
    	case TIME_SECONDS:
    		return seconds;
    	case TIME_MINUTES:
    		return seconds / 60.0;
    	case TIME_HOURS:
    		return seconds / 3600.0;    		
    	case TIME_DAYS:
    		return seconds / 86400.0;    		
    	case TIME_MONTHS:
    		return seconds / 2592000.0;    		
    	case TIME_YEARS:
    		return seconds / 31536000.0;
		default:
    		return 0;
    	}
    }


    /**
     * Locale
     * ***********************************************************************************************
     */

    /**
     * @return double with percentage sign
     */
    public static String fmtPercentage(Double value) {
	return fmtPercentage(value, 0);
    }
    public static String fmtPercentage(Double value, int point) {
    	// only retrieve the percentage format the first time
    	if (mCurrentPercentageFormat == null) {
    		mCurrentPercentageFormat = NumberFormat.getPercentInstance(Locale.getDefault());
    	}
    	mCurrentNumberFormat.setMaximumFractionDigits(point);
    	return mCurrentPercentageFormat.format(value);
    }


    /**
     * @return double with percentage sign
     */
    public static boolean isNewDay(long millies) {
		Calendar cal = Calendar.getInstance();
		if (cal.get(Calendar.HOUR_OF_DAY) < StudyOptions.mNewDayStartsAt) {
            cal.add(Calendar.HOUR_OF_DAY, -cal.get(Calendar.HOUR_OF_DAY) - 24 + StudyOptions.mNewDayStartsAt);
		} else {
            cal.add(Calendar.HOUR_OF_DAY, -cal.get(Calendar.HOUR_OF_DAY) + StudyOptions.mNewDayStartsAt);
		}
        cal.add(Calendar.MINUTE, -cal.get(Calendar.MINUTE));
        cal.add(Calendar.SECOND, -cal.get(Calendar.SECOND));
        if (cal.getTimeInMillis() > millies) {
        	return true;
        } else {
        	return false;
        }
	

    }


    /**
     * @return a string with decimal separator according to current locale
     */
    public static String fmtDouble(Double value) {
    	return fmtDouble(value, 1);
    }
    public static String fmtDouble(Double value, int point) {
    	// only retrieve the number format the first time
    	if (mCurrentNumberFormat == null) {
    		mCurrentNumberFormat = NumberFormat.getInstance(Locale.getDefault());
    	}
    	mCurrentNumberFormat.setMaximumFractionDigits(point);
    	return mCurrentNumberFormat.format(value);
    }


    public static long genID() {
        long time = System.currentTimeMillis();
        long id;
        long rand;

        if (sIdTree == null) {
            sIdTree = new TreeSet<Long>();
            sIdTime = time;
        } else if (sIdTime != time) {
            sIdTime = time;
            sIdTree.clear();
        }

        while (true) {
            rand = UUID.randomUUID().getMostSignificantBits();
            if (!sIdTree.contains(new Long(rand))) {
                sIdTree.add(new Long(rand));
                break;
            }
        }
        id = rand << 41 | time;
        return id;
    }

    private static final BigInteger shiftID = new BigInteger(""18446744073709551616"");
    private static final BigInteger maxID = new BigInteger(""9223372036854775808"");
    public static String hexifyID(long id) {
        if (id < 0) {
            BigInteger bid = BigInteger.valueOf(id);
            return bid.add(shiftID).toString(16);
        }
        return Long.toHexString(id);
    }
    
    public static long dehexifyID(String id) {
        BigInteger bid = new BigInteger(id, 16);
        if (bid.compareTo(maxID) >= 0) {
            bid.subtract(shiftID);
        }
        return bid.longValue();
    }

    /**
     * Returns a SQL string from an array of integers.
     * @param ids The array of integers to include in the list.
     * @return An SQL compatible string in the format (ids[0],ids[1],..).
     */
    public static String ids2str(long[] ids) {
        String str = ""()"";
        if (ids != null) {
            str = Arrays.toString(ids);
            str = ""("" + str.substring(1, str.length()-1) + "")"";
        }
        return str;
    }


    /**
     * Returns a SQL string from an array of integers.
     * @param ids The array of integers to include in the list.
     * @return An SQL compatible string in the format (ids[0],ids[1],..).
     */
    public static String ids2str(JSONArray ids) {
        StringBuilder str = new StringBuilder(512);
        str.append(""("");
        if (ids != null) {
            int len = ids.length();
            for (int i = 0; i < len; i++) {
                try {
                    if (i == (len - 1)) {
                        str.append(ids.get(i));
                    } else {
                        str.append(ids.get(i)).append("","");
                    }
                } catch (JSONException e) {
                    Log.e(AnkiDroidApp.TAG, ""JSONException = "" + e.getMessage());
                }
            }
        }
        str.append("")"");
        return str.toString();
    }


    /**
     * Returns a SQL string from an array of integers.
     * @param ids The array of integers to include in the list.
     * @return An SQL compatible string in the format (ids[0],ids[1],..).
     */
    public static String ids2str(List<String> ids) {
        StringBuilder str = new StringBuilder(512);
        str.append(""("");
        if (ids != null) {
            int len = ids.size();
            for (int i = 0; i < len; i++) {
                if (i == (len - 1)) {
                    str.append(ids.get(i));
                } else {
                    str.append(ids.get(i)).append("","");
                }
            }
        }
        str.append("")"");
        return str.toString();
    }


    public static JSONArray listToJSONArray(List<Object> list) {
        JSONArray jsonArray = new JSONArray();

        for (Object o : list) {
            jsonArray.put(o);
        }

        return jsonArray;
    }


    public static List<String> jsonArrayToListString(JSONArray jsonArray) throws JSONException {
        ArrayList<String> list = new ArrayList<String>();

        int len = jsonArray.length();
        for (int i = 0; i < len; i++) {
            list.add(jsonArray.getString(i));
        }

        return list;
    }

    /**
     * Strip HTML but keep media filenames
     */
    public static String stripHTMLMedia(String s) {
        Matcher imgMatcher = imgPattern.matcher(s);
        return stripHTML(imgMatcher.replaceAll("" $1 ""));
    }
    public static String stripHTML(String s) {
        Matcher styleMatcher = stylePattern.matcher(s);
        s = styleMatcher.replaceAll("""");
        Matcher scriptMatcher = scriptPattern.matcher(s);
        s = scriptMatcher.replaceAll("""");
        Matcher tagMatcher = tagPattern.matcher(s);
        s = tagMatcher.replaceAll("""");
        return entsToTxt(s);
    }
    private static String entsToTxt(String s) {
        Matcher htmlEntities = htmlEntitiesPattern.matcher(s);
        StringBuilder s2 = new StringBuilder(s);
        while (htmlEntities.find()) {
            String text = htmlEntities.group();
            text = Html.fromHtml(text).toString();
            // TODO: inefficiency below, can get rid of multiple regex searches
            s2.replace(htmlEntities.start(), htmlEntities.end(), text);
            htmlEntities = htmlEntitiesPattern.matcher(s2);
        }
        return s2.toString();
    }



    /**
     * Converts an InputStream to a String.
     * @param is InputStream to convert
     * @return String version of the InputStream
     */
    public static String convertStreamToString(InputStream is) {
        String contentOfMyInputStream = """";
        try {
            BufferedReader rd = new BufferedReader(new InputStreamReader(is), 4096);
            String line;
            StringBuilder sb = new StringBuilder();
            while ((line = rd.readLine()) != null) {
                sb.append(line);
            }
            rd.close();
            contentOfMyInputStream = sb.toString();
        } catch (Exception e) {
            e.printStackTrace();
        }

        return contentOfMyInputStream;
    }


    /**
     * Compress data.
     * @param bytesToCompress is the byte array to compress.
     * @return a compressed byte array.
     * @throws java.io.IOException
     */
    public static byte[] compress(byte[] bytesToCompress) throws IOException {
        // Compressor with highest level of compression.
        Deflater compressor = new Deflater(Deflater.BEST_COMPRESSION);
        // Give the compressor the data to compress.
        compressor.setInput(bytesToCompress);
        compressor.finish();

        // Create an expandable byte array to hold the compressed data.
        // It is not necessary that the compressed data will be smaller than
        // the uncompressed data.
        ByteArrayOutputStream bos = new ByteArrayOutputStream(bytesToCompress.length);

        // Compress the data
        byte[] buf = new byte[bytesToCompress.length + 100];
        while (!compressor.finished()) {
            bos.write(buf, 0, compressor.deflate(buf));
        }

        bos.close();

        // Get the compressed data
        return bos.toByteArray();
    }


    /**
     * Utility method to write to a file.
     * Throws the exception, so we can report it in syncing log
     * @throws IOException 
     */
    public static void writeToFile(InputStream source, String destination) throws IOException {
        // Log.i(AnkiDroidApp.TAG, ""Creating new file... = "" + destination);
        new File(destination).createNewFile();

        long startTimeMillis = System.currentTimeMillis();
        OutputStream output = new BufferedOutputStream(new FileOutputStream(destination));

        // Transfer bytes, from source to destination.
        byte[] buf = new byte[CHUNK_SIZE];
        long sizeBytes = 0;
        int len;
        if (source == null) {
            // Log.i(AnkiDroidApp.TAG, ""source is null!"");
        }
        while ((len = source.read(buf)) > 0) {
            output.write(buf, 0, len);
            sizeBytes += len;
            // // Log.i(AnkiDroidApp.TAG, ""Write..."");
        }
        long endTimeMillis = System.currentTimeMillis();

        // Log.i(AnkiDroidApp.TAG, ""Finished writing!"");
        long durationSeconds = (endTimeMillis - startTimeMillis) / 1000;
        long sizeKb = sizeBytes / 1024;
        long speedKbSec = 0;
        if (endTimeMillis != startTimeMillis) {
            speedKbSec = sizeKb * 1000 / (endTimeMillis - startTimeMillis);
        }
        // Log.d(AnkiDroidApp.TAG, ""Utils.writeToFile: "" + ""Size: "" + sizeKb + ""Kb, "" + ""Duration: "" + durationSeconds + ""s, "" + ""Speed: "" + speedKbSec + ""Kb/s"");
        output.close();
    }


    // Print methods
    public static void printJSONObject(JSONObject jsonObject) {
        printJSONObject(jsonObject, ""-"", null);
    }


    public static void printJSONObject(JSONObject jsonObject, boolean writeToFile) {
        BufferedWriter buff;
        try {
            buff = writeToFile ?  
                    new BufferedWriter(new FileWriter(""/sdcard/payloadAndroid.txt""), 8192) : null;
            try {
                printJSONObject(jsonObject, ""-"", buff);
            } finally {
                if (buff != null)
                    buff.close();
            }
        } catch (IOException ioe) {
            Log.e(AnkiDroidApp.TAG, ""IOException = "" + ioe.getMessage());
        }
    }


    private static void printJSONObject(JSONObject jsonObject, String indentation, BufferedWriter buff) {
        try {
            @SuppressWarnings(""unchecked"") Iterator<String> keys = (Iterator<String>) jsonObject.keys();
            TreeSet<String> orderedKeysSet = new TreeSet<String>();
            while (keys.hasNext()) {
                orderedKeysSet.add(keys.next());
            }

            Iterator<String> orderedKeys = orderedKeysSet.iterator();
            while (orderedKeys.hasNext()) {
                String key = orderedKeys.next();

                try {
                    Object value = jsonObject.get(key);
                    if (value instanceof JSONObject) {
                        if (buff != null) {
                            buff.write(indentation + "" "" + key + "" : "");
                            buff.newLine();
                        }
                        // Log.i(AnkiDroidApp.TAG, ""	"" + indentation + key + "" : "");
                        printJSONObject((JSONObject) value, indentation + ""-"", buff);
                    } else {
                        if (buff != null) {
                            buff.write(indentation + "" "" + key + "" = "" + jsonObject.get(key).toString());
                            buff.newLine();
                        }
                        // Log.i(AnkiDroidApp.TAG, ""	"" + indentation + key + "" = "" + jsonObject.get(key).toString());
                    }
                } catch (JSONException e) {
                    Log.e(AnkiDroidApp.TAG, ""JSONException = "" + e.getMessage());
                }
            }
        } catch (IOException e1) {
            Log.e(AnkiDroidApp.TAG, ""IOException = "" + e1.getMessage());
        }
    }


    /*
    public static void saveJSONObject(JSONObject jsonObject) throws IOException {
        // Log.i(AnkiDroidApp.TAG, ""saveJSONObject"");
        BufferedWriter buff = new BufferedWriter(new FileWriter(""/sdcard/jsonObjectAndroid.txt"", true));
        buff.write(jsonObject.toString());
        buff.close();
    }
    */


    /**
     * Returns 1 if true, 0 if false
     *
     * @param b The boolean to convert to integer
     * @return 1 if b is true, 0 otherwise
     */
    public static int booleanToInt(boolean b) {
        return (b) ? 1 : 0;
    }


    /**
     * Get the current time in seconds since January 1, 1970 UTC.
     * @return the local system time in seconds
     */
    public static double now() {
        return (System.currentTimeMillis() / 1000.0);
    }


    /**
     *  Returns the effective date of the present moment.
     *  If the time is prior the cut-off time (9:00am by default as of 11/02/10) return yesterday,
     *  otherwise today
     *  Note that the Date class is java.sql.Date whose constructor sets hours, minutes etc to zero
     *
     * @param utcOffset The UTC offset in seconds we are going to use to determine today or yesterday.
     * @return The date (with time set to 00:00:00) that corresponds to today in Anki terms
     */
    public static Date genToday(double utcOffset) {
        // The result is not adjusted for timezone anymore, following libanki model
        // Timezone adjustment happens explicitly in Deck.updateCutoff(), but not in Deck.checkDailyStats()
        SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd"");
        df.setTimeZone(TimeZone.getTimeZone(""GMT""));
        Calendar cal = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
        cal.setTimeInMillis(System.currentTimeMillis() - (long) utcOffset * 1000l);
        Date today = Date.valueOf(df.format(cal.getTime()));
        return today;
    }


    public static void printDate(String name, double date) {
    	SimpleDateFormat df = new SimpleDateFormat(""yyyy-MM-dd HH-mm-ss"");
    	df.setTimeZone(TimeZone.getTimeZone(""GMT""));
    	Calendar cal = new GregorianCalendar(TimeZone.getTimeZone(""GMT""));
    	cal.setTimeInMillis((long)date * 1000);
    	// Log.d(AnkiDroidApp.TAG, ""Value of "" + name + "": "" + cal.getTime().toGMTString());
	}


    public static String doubleToTime(double value) {
    	int time = (int) Math.round(value);
    	int seconds = time % 60;
    	int minutes = (time - seconds) / 60;
    	String formattedTime;
    	if (seconds < 10) {
    		formattedTime = Integer.toString(minutes) + "":0"" + Integer.toString(seconds);
    	} else {
    		formattedTime = Integer.toString(minutes) + "":"" + Integer.toString(seconds);
    	}
    	return formattedTime;
    }


    /**
     * Returns the proleptic Gregorian ordinal of the date, where January 1 of year 1 has ordinal 1.
     * @param date Date to convert to ordinal, since 01/01/01
     * @return The ordinal representing the date
     */
    public static int dateToOrdinal(Date date) {
        // BigDate.toOrdinal returns the ordinal since 1970, so we add up the days from 01/01/01 to 1970
        return BigDate.toOrdinal(date.getYear() + 1900, date.getMonth() + 1, date.getDate()) + DAYS_BEFORE_1970;
    }


    /**
     * Return the date corresponding to the proleptic Gregorian ordinal, where January 1 of year 1 has ordinal 1.
     * @param ordinal representing the days since 01/01/01
     * @return Date converted from the ordinal
     */
    public static Date ordinalToDate(int ordinal) {
        return new Date((new BigDate(ordinal - DAYS_BEFORE_1970)).getLocalDate().getTime());
    }


    /**
     * Indicates whether the specified action can be used as an intent. This method queries the package manager for
     * installed packages that can respond to an intent with the specified action. If no suitable package is found, this
     * method returns false.
     * @param context The application's environment.
     * @param action The Intent action to check for availability.
     * @return True if an Intent with the specified action can be sent and responded to, false otherwise.
     */
    public static boolean isIntentAvailable(Context context, String action) {
        return isIntentAvailable(context, action, null);
    }

    public static boolean isIntentAvailable(Context context, String action, ComponentName componentName) {
        final PackageManager packageManager = context.getPackageManager();
        final Intent intent = new Intent(action);
        intent.setComponent(componentName);
        List<ResolveInfo> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
        return list.size() > 0;
    }

    
    public static String getBaseUrl(String mediaDir, Model model, Deck deck) {
        String base = null;// = model.getFeatures().trim();
//        if (deck.getBool(""remoteImages"") && base.length() != 0 && !base.equalsIgnoreCase(""null"")) {
  //          return base;
    //    } else {
            // Anki desktop calls deck.mediaDir() here, but for efficiency reasons we only call it once in
            // Reviewer.onCreate() and use the value from there            
            if (mediaDir != null) {                              
                base = urlEncodeMediaDir(mediaDir);
            }
      //  }
        return base;
    }


    /**
     * @param mediaDir media directory path on SD card
     * @return path converted to file URL, properly UTF-8 URL encoded
     */
    public static String urlEncodeMediaDir(String mediaDir) {
        String base;
        // Use android.net.Uri class to ensure whole path is properly encoded
        // File.toURL() does not work here, and URLEncoder class is not directly usable
        // with existing slashes
        Uri mediaDirUri = Uri.fromFile(new File(mediaDir));

        // Build complete URL
        base = mediaDirUri.toString() +""/"";

        return base;
    }


    /**
     * Take an array of Long and return an array of long
     * 
     * @param array The input with type Long[]
     * @return The output with type long[]
     */
    public static long[] toPrimitive(Long[] array) {
        long[] results = new long[array.length];
        if (array != null) {
            for (int i = 0; i < array.length; i++) {
                results[i] = array[i].longValue();
            }
        }
        return results;
    }
    public static long[] toPrimitive(Collection<Long> array) {
        long[] results = new long[array.size()];
        if (array != null) {
            int i = 0;
            for (Long item : array) {
                results[i++] = item.longValue();
            }
        }
        return results;
    }
    
    
    /*
     * Tags
     **************************************/
    
    /**
     * Parse a string and return a list of tags.
     * 
     * @param tags A string containing tags separated by space or comma (optionally followed by space)
     * @return An array of Strings containing the individual tags 
     */
    public static String[] parseTags(String tags) {
        if (tags != null && tags.length() != 0) {
            return tags.trim().split("" +|, *"");
        } else {
            return new String[] {};
        }
    }
    
    /**
     * Join a list of tags to a string, using spaces as separators
     * 
     * @param tags The list of tags to join
     * @return The joined tags in a single string 
     */
    public static String joinTags(Collection<String> tags) {
        StringBuilder result = new StringBuilder(128);
        for (String tag : tags) {
            result.append(tag).append("" "");
        }
        return result.toString().trim();
    }
    
    /**
     * Strip leading/trailing/superfluous spaces/commas from a tags string. Remove duplicates and sort.
     * 
     * @param tags The string containing the tags, separated by spaces or commas
     * @return The canonified string, as described above
     */
    public static String canonifyTags(String tags) {
        List<String> taglist = Arrays.asList(parseTags(tags));
        for (int i = 0; i < taglist.size(); i++) {
            String t = taglist.get(i);
            if (t.startsWith("":"")) {
                taglist.set(i, t.replace(""^:+"", """"));
            }
        }
        return joinTags(new TreeSet<String>(taglist));
    }

    /**
     * Find if tag exists in a set of tags. The search is not case-sensitive
     * 
     * @param tag The tag to look for
     * @param tags The set of tags
     * @return True is the tag is found in the set, false otherwise
     */
    public static boolean findTag(String tag, List<String> tags) {
        String lowercase = tag.toLowerCase();
        for (String t : tags) {
            if (t.toLowerCase().compareTo(lowercase) == 0) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Add tags if they don't exist.
     * Both parameters are in string format, the tags being separated by space or comma, as in parseTags
     * 
     * @param tagStr The new tag(s) that are to be added
     * @param tags The set of tags where the new ones will be added
     * @return A string containing the union of tags of the input parameters
     */
    public static String addTags(String tagStr, String tags) {
        ArrayList<String> currentTags = new ArrayList<String>(Arrays.asList(parseTags(tags)));
        for (String tag : parseTags(tagStr)) {
            if (!findTag(tag, currentTags)) {
                currentTags.add(tag);
            }
        }
        return joinTags(currentTags);
    }

    // Misc
    // *************

    /**
     * MD5 checksum.
     * Equivalent to python md5.hexdigest()
     *
     * @param data the string to generate hash from
     * @return A string of length 32 containing the hexadecimal representation of the MD5 checksum of data.
     */
    public static String checksum(String data) {
        String result = """";
        if (data != null) {
            MessageDigest md = null;
            byte[] digest = null;
            try {
                md = MessageDigest.getInstance(""MD5"");
                digest = md.digest(data.getBytes(""UTF-8""));
            } catch (NoSuchAlgorithmException e) {
                Log.e(AnkiDroidApp.TAG, ""Utils.checksum: No such algorithm. "" + e.getMessage());
                throw new RuntimeException(e);
            } catch (UnsupportedEncodingException e) {
                Log.e(AnkiDroidApp.TAG, ""Utils.checksum: "" + e.getMessage());
                e.printStackTrace();
            }
            BigInteger biginteger = new BigInteger(1, digest);
            result = biginteger.toString(16);
            // pad with zeros to length of 32
            if (result.length() < 32) {
                result = ""00000000000000000000000000000000"".substring(0, 32 - result.length()) + result;
            }
        }
        return result;
    }


    public static void updateProgressBars(Context context, View view, double progress, int maxX, int y, boolean singleBar) {
    	updateProgressBars(context, view, progress, maxX, y, singleBar, true);
    }
	public static void updateProgressBars(Context context, View view, double progress, int maxX, int y, boolean singleBar, boolean changeColor) {
        if (view == null) {
            return;
        }
        if (singleBar) {
        	if (changeColor) {
                if (progress < 0.5) {
                    view.setBackgroundColor(context.getResources().getColor(R.color.progressbar_1));
                } else if (progress < 0.65) {
                    view.setBackgroundColor(context.getResources().getColor(R.color.progressbar_2));
                } else if (progress < 0.75) {
                    view.setBackgroundColor(context.getResources().getColor(R.color.progressbar_3));
                } else {
                    view.setBackgroundColor(context.getResources().getColor(R.color.progressbar_4));            
                }        		
        	}
            FrameLayout.LayoutParams lparam = new FrameLayout.LayoutParams(0, 0);            
            lparam.height = y;
            lparam.width = (int) (maxX * progress);
            view.setLayoutParams(lparam);
        } else {
            LinearLayout.LayoutParams lparam = new LinearLayout.LayoutParams(0, 0);            
            lparam.height = y;
            lparam.width = (int) (maxX * progress);
            view.setLayoutParams(lparam);
        }
    }  


    /**
     * MD5 sum of file.
     * Equivalent to checksum(open(os.path.join(mdir, file), ""rb"").read()))
     *
     * @param path The full path to the file
     * @return A string of length 32 containing the hexadecimal representation of the MD5 checksum of the contents
     * of the file
     */
    public static String fileChecksum(String path) {
        byte[] bytes = null;
        try {
            File file = new File(path);
            if (file != null && file.isFile()) {
                bytes = new byte[(int)file.length()];
                FileInputStream fin = new FileInputStream(file);
                fin.read(bytes);
            }
        } catch (FileNotFoundException e) {
            Log.e(AnkiDroidApp.TAG, ""Can't find file "" + path + "" to calculate its checksum"");
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, ""Can't read file "" + path + "" to calculate its checksum"");
        }
        if (bytes == null) {
            Log.w(AnkiDroidApp.TAG, ""File "" + path + "" appears to be empty"");
            return """";
        }
        MessageDigest md = null;
        byte[] digest = null;
        try {
            md = MessageDigest.getInstance(""MD5"");
            digest = md.digest(bytes);
        } catch (NoSuchAlgorithmException e) {
            Log.e(AnkiDroidApp.TAG, ""Utils.checksum: No such algorithm. "" + e.getMessage());
            throw new RuntimeException(e);
        }
        BigInteger biginteger = new BigInteger(1, digest);
        String result = biginteger.toString(16);
        // pad with zeros to length of 32
        if (result.length() < 32) {
            result = ""00000000000000000000000000000000"".substring(0, 32 - result.length()) + result;
        }
        return result;
    }
    
    
    /**
     * Calculate the UTC offset
     */
    public static double utcOffset() {
        Calendar cal = Calendar.getInstance();
        // 4am
        return 4 * 60 * 60 - (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / 1000;
    }

    /**
     * Adds a menu item to the given menu.
     */
    public static MenuItem addMenuItem(Menu menu, int groupId, int itemId, int order, int titleRes,
            int iconRes) {
        MenuItem item = menu.add(groupId, itemId, order, titleRes);
        item.setIcon(iconRes);
        return item;
    }

    /**
     * Adds a menu item to the given menu and marks it as a candidate to be in the action bar.
     */
    public static MenuItem addMenuItemInActionBar(Menu menu, int groupId, int itemId, int order,
            int titleRes, int iconRes) {
        MenuItem item = addMenuItem(menu, groupId, itemId, order, titleRes, iconRes);
        setShowAsActionIfRoom(item);
        return item;
    }

    /**
     * Sets the menu item to appear in the action bar via reflection.
     * <p>
     * This method uses reflection so that it works on all platforms. It any error occurs, assume
     * the action bar is not available and just proceed.
     */
    private static void setShowAsActionIfRoom(MenuItem item) {
        try {
            Field showAsActionIfRoom = item.getClass().getField(""SHOW_AS_ACTION_IF_ROOM"");
            Method setShowAsAction = item.getClass().getMethod(""setShowAsAction"", int.class);
            setShowAsAction.invoke(item, showAsActionIfRoom.get(null));
        } catch (SecurityException e) {
        } catch (NoSuchMethodException e) {
        } catch (NoSuchFieldException e) {
        } catch (IllegalArgumentException e) {
        } catch (IllegalAccessException e) {
        } catch (InvocationTargetException e) {
        } catch (NullPointerException e) {
        }
    }

    /** Returns the filename without the extension. */
    public static String removeExtension(String filename) {
      int dotPosition = filename.lastIndexOf('.');
      if (dotPosition == -1) {
        return filename;
      }
      return filename.substring(0, dotPosition);
    }

    /** Returns a list of files for the installed custom fonts. */
    public static File[] getCustomFonts(Context context) {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
        String deckPath = preferences.getString(""deckPath"",
                AnkiDroidApp.getStorageDirectory() + ""/AnkiDroid"");
        String fontsPath = deckPath + ""/fonts/"";
        File fontsDir = new File(fontsPath);
        if (!fontsDir.exists() || !fontsDir.isDirectory()) {
          return new File[0];
        }
        return fontsDir.listFiles();
    }
}
",True,13,67,2,2,4,31
16,com.ichi2.anki.AnkiDb.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>                                    *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Map.Entry;

import com.tomgibara.android.veecheck.util.PrefSettings;
import com.ichi2.anki.Utils.SqlCommandType;
import static com.ichi2.anki.Utils.SqlCommandType.*;

/**
 * Database layer for AnkiDroid. Can read the native Anki format through Android's SQLite driver.
 */
public class AnkiDb {

    /**
     * The deck, which is actually an SQLite database.
     */
    private SQLiteDatabase mDatabase;

    /**
     * Open a database connection to an "".anki"" SQLite file.
     */
    public AnkiDb(String ankiFilename, boolean forceDeleteJournalMode) {
        mDatabase = SQLiteDatabase.openDatabase(ankiFilename, null, SQLiteDatabase.OPEN_READWRITE
                | SQLiteDatabase.NO_LOCALIZED_COLLATORS);
        if (mDatabase != null) {
            Cursor cur = null;
            try {
                String mode;
            	SharedPreferences prefs = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
            	if (prefs.getBoolean(""walMode"", false) && !forceDeleteJournalMode) {
            		mode = ""WAL"";
            	} else {
            		mode = ""DELETE"";
            	}
                cur = mDatabase.rawQuery(""PRAGMA journal_mode"", null);
                if (cur.moveToFirst()) {
                	String journalModeOld = cur.getString(0);
                	cur.close();
                	Log.w(AnkiDroidApp.TAG, ""Current Journal mode: "" + journalModeOld);                    		
                	if (!journalModeOld.equalsIgnoreCase(mode)) {
                    	cur = mDatabase.rawQuery(""PRAGMA journal_mode = "" + mode, null);
                    	if (cur.moveToFirst()) {
                        	String journalModeNew = cur.getString(0);
                        	cur.close();
                        	Log.w(AnkiDroidApp.TAG, ""Old journal mode was: "" + journalModeOld + "". Trying to set journal mode to "" + mode + "". Result: "" + journalModeNew);                    		
                        	if (journalModeNew.equalsIgnoreCase(""wal"") && mode.equals(""DELETE"")) {
                        		Log.e(AnkiDroidApp.TAG, ""Journal could not be changed to DELETE. Deck will probably be unreadable on sqlite < 3.7"");
                        	}
                    	}
                	}
                }
                if (prefs.getBoolean(""asyncMode"", false)) {
                    cur = mDatabase.rawQuery(""PRAGMA synchronous = 0"", null);
                } else {
                    cur = mDatabase.rawQuery(""PRAGMA synchronous = 2"", null);
                }
                cur.close();
                cur = mDatabase.rawQuery(""PRAGMA synchronous"", null);
                if (cur.moveToFirst()) {
                	String syncMode = cur.getString(0);
                	Log.w(AnkiDroidApp.TAG, ""Current synchronous setting: "" + syncMode);                    		
                }
                cur.close();
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
        }
    }


    /**
     * Closes a previously opened database connection.
     */
    public void closeDatabase() {
        if (mDatabase != null) {
            mDatabase.close();
            // Log.i(AnkiDroidApp.TAG, ""AnkiDb - closeDatabase, database "" + mDatabase.getPath() + "" closed = "" + !mDatabase.isOpen());
            mDatabase = null;
        }
    }


    public SQLiteDatabase getDatabase() {
        return mDatabase;
    }


    /**
     * Convenience method for querying the database for a single integer result.
     * 
     * @param query The raw SQL query to use.
     * @return The integer result of the query.
     */
    public long queryScalar(String query) throws SQLException {
        Cursor cursor = null;
        long scalar;
        try {
            cursor = mDatabase.rawQuery(query, null);
            if (!cursor.moveToNext()) {
                throw new SQLException(""No result for query: "" + query);
            }

            scalar = cursor.getLong(0);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        return scalar;
    }


    /**
     * Convenience method for querying the database for an entire column. The column will be returned as an ArrayList of
     * the specified class. See Deck.initUndo() for a usage example.
     *
     * @param type The class of the column's data type. Example: int.class, String.class.
     * @param query The SQL query statement.
     * @param column The column id in the result set to return.
     * @return An ArrayList with the contents of the specified column.
     */
    public <T> ArrayList<T> queryColumn(Class<T> type, String query, int column) {
        ArrayList<T> results = new ArrayList<T>();
        Cursor cursor = null;

        try {
            cursor = mDatabase.rawQuery(query, null);
            String methodName = getCursorMethodName(type.getSimpleName());
            while (cursor.moveToNext()) {
                // The magical line. Almost as illegible as python code ;)
                results.add(type.cast(Cursor.class.getMethod(methodName, int.class).invoke(cursor, column)));
            }
        } catch (NoSuchMethodException e) {
            // This is really coding error, so it should be revealed if it ever happens
            throw new RuntimeException(e);
        } catch (IllegalArgumentException e) {
            // This is really coding error, so it should be revealed if it ever happens
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            // This is really coding error, so it should be revealed if it ever happens
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        return results;
    }


    /**
     * Method for executing db commands with simultaneous storing of undo information. This should only be called from undo method.
     */
    public void execSQL(Deck deck, SqlCommandType command, String table, ContentValues values, String whereClause) {
    	if (command == SQL_INS) {
			insert(deck, table, null, values);
    	} else if (command == SQL_UPD) {
			update(deck, table, values, whereClause, null);
    	} else if (command == SQL_DEL) {
    		delete(deck, table, whereClause, null);
    	} else {
    		// Log.i(AnkiDroidApp.TAG, ""wrong command. no action performed"");
    	}
    }


    /**
     * Method for inserting rows into the db with simultaneous storing of undo information.
     * 
     * @return The id of the inserted row.
     */
    public long insert(Deck deck, String table, String nullColumnHack, ContentValues values) {
    	long rowid = mDatabase.insert(table, nullColumnHack, values);
    	if (rowid != -1 && deck.recordUndoInformation()) {
        	deck.addUndoCommand(SQL_DEL, table, null, ""rowid = "" + rowid);
    	}
    	return rowid;
    }


    /**
     * Method for updating rows of the database with simultaneous storing of undo information.
     * 
     * @param values A map from column names to new column values. Values must not contain sql code/variables. Otherwise use update(Deck deck, String table, ContentValues values, String whereClause, String[] whereArgs, boolean onlyFixedValues) with 'onlyFixedValues' = false.
     * @param whereClause The optional WHERE clause to apply when updating. Passing null will update all rows.
     * @param whereArgs Arguments which will replace all '?'s of the whereClause.
     */
    public void update(Deck deck, String table, ContentValues values, String whereClause, String[] whereArgs) {
    	update(deck, table, values, whereClause, whereArgs, true);
    }
    /**
     * Method for updating rows of the database with simultaneous storing of undo information.
     * 
     * @param values A map from column names to new column values. null is a valid value that will be translated to NULL.
     * @param whereClause The optional WHERE clause to apply when updating. Passing null will update all rows.
     * @param whereArgs Arguments which will replace all '?'s of the whereClause.
     * @param onlyFixedValues Set this to true, if 'values' contains only fixed values (no sql code). Otherwise, it must be set to false and fixed string values have to be extra quoted (""\'example-value\'"").
     */
    public void update(Deck deck, String table, ContentValues values, String whereClause, String[] whereArgs, boolean onlyFixedValues) {
        update(deck, table, values, whereClause, whereArgs, onlyFixedValues, null, null);
    }
    public void update(Deck deck, String table, ContentValues values, String whereClause, String[] whereArgs, boolean onlyFixedValues, ContentValues[] oldValuesArray, String[] whereClauseArray) {
    	if (deck.recordUndoInformation()) {
        	if (oldValuesArray != null) {
                for (int i = 0; i < oldValuesArray.length; i++) {
                    deck.addUndoCommand(SQL_UPD, table, oldValuesArray[i], whereClauseArray[i]);
                }
        	} else {
        		ArrayList<String> ar = new ArrayList<String>();
                for (Entry<String, Object> entry : values.valueSet()) {
                	ar.add(entry.getKey());
                }
                int len = ar.size();
                String[] columns = new String[len + 1];
                ar.toArray(columns);
                columns[len] = ""rowid"";

                Cursor cursor = null;
                try {
                    cursor = mDatabase.query(table, columns, whereClause, whereArgs, null, null, null);
                    while (cursor.moveToNext()) {
                        ContentValues oldvalues = new ContentValues();
                        for (int i = 0; i < len; i++) {
//                        	String typeName;
//                        	if (values.get(columns[i]) != null) {
//                        		typeName = values.get(columns[i]).getClass().getSimpleName();
//                        	} else {
//                        		typeName = ""String"";
//                        	}
//                    		if (typeName.equals(""String"")) {
//                    			oldvalues.put(columns[i], cursor.getString(i));
//                            } else if (typeName.equals(""Long"")) {
//                            	oldvalues.put(columns[i], cursor.getLong(i));
//                            } else if (typeName.equals(""Double"")) {
//                            	oldvalues.put(columns[i], cursor.getDouble(i));
//                            } else if (typeName.equals(""Integer"")) {
//                            	oldvalues.put(columns[i], cursor.getInt(i));
//                            } else if (typeName.equals(""Float"")) {
//                            	oldvalues.put(columns[i], cursor.getFloat(i));
//                            } else {
                            	oldvalues.put(columns[i], cursor.getString(i));
//                            }
                        }
                        deck.addUndoCommand(SQL_UPD, table, oldvalues, ""rowid = "" + cursor.getString(len));
                    }
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
        	}    		
    	}
    	if (onlyFixedValues) {
    		mDatabase.update(table, values, whereClause, whereArgs);
    	} else {
    		StringBuilder sb = new StringBuilder();
    		sb.append(""UPDATE "").append(table).append("" SET "");
    		for (Entry<String, Object> entry : values.valueSet()) {
				sb.append(entry.getKey()).append("" = "").append(entry.getValue()).append("", "");
    		}
    		sb.deleteCharAt(sb.length() - 2);
    		if (whereArgs != null) {
        		for (int i = 0; i < whereArgs.length; i++) {
        			whereClause = whereClause.replaceFirst(""?"", whereArgs[i]);
        		}    			
    		}
    		sb.append(""WHERE "").append(whereClause);
		    mDatabase.execSQL(sb.toString());
		}
    }


    /**
     * Method for deleting rows of the database with simultaneous storing of undo information.
     */
    public void delete(Deck deck, String table, String whereClause, String[] whereArgs) {
        if (deck.recordUndoInformation()) {
        	ArrayList<String> columnsNames = new ArrayList<String>();
//        	ArrayList<String> columnTypes = new ArrayList<String>();
            Cursor cursor = null;

            try {
                cursor = mDatabase.rawQuery(""PRAGMA TABLE_INFO("" + table + "")"", null);
                while (cursor.moveToNext()) {
                	columnsNames.add(cursor.getString(1));
//                	String t = cursor.getString(2).toLowerCase();
//                    String typeName = """";
//                    if (t.subSequence(0, 3).equals(""int"")) {
//                    	typeName = ""Long"";
//                    } else if (t.equals(""float"")) {
//                    	typeName = ""Double"";
//                    } else {
//                    	typeName = ""String"";
//                    }
//                    columnTypes.add(typeName);
                }
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
            
        	int len = columnsNames.size();
        	String[] columns = new String[len];
        	columnsNames.toArray(columns);

            try {
                cursor = mDatabase.query(table, columns, whereClause, whereArgs, null, null, null);
                while (cursor.moveToNext()) {
                    ContentValues oldvalues = new ContentValues();
                    for (int i = 0; i < len; i++) {
//                    	String typeName = columnTypes.get(i);
//                		if (typeName.equals(""String"")) {
//                			oldvalues.put(columns[i], cursor.getString(i));
//                        } else if (typeName.equals(""Long"")) {
//                        	oldvalues.put(columns[i], cursor.getLong(i));
//                        } else if (typeName.equals(""Double"")) {
//                        	oldvalues.put(columns[i], cursor.getDouble(i));
//                        } else if (typeName.equals(""Integer"")) {
//                        	oldvalues.put(columns[i], cursor.getInt(i));
//                        } else if (typeName.equals(""Float"")) {
//                        	oldvalues.put(columns[i], cursor.getFloat(i));
//                        } else {
                        	oldvalues.put(columns[i], cursor.getString(i));
//                        }
                    }
                    deck.addUndoCommand(SQL_INS, table, oldvalues, null);
                }
			} finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
    	}
    	mDatabase.delete(table, whereClause, whereArgs);
    }


    /**
     * Mapping of Java type names to the corresponding Cursor.get method.
     *
     * @param typeName The simple name of the type's class. Example: String.class.getSimpleName().
     * @return The name of the Cursor method to be called.
     */
    private static String getCursorMethodName(String typeName) {
        if (typeName.equals(""String"")) {
            return ""getString"";
        } else if (typeName.equals(""Long"")) {
            return ""getLong"";
        } else if (typeName.equals(""Integer"")) {
            return ""getInt"";
        } else if (typeName.equals(""Float"")) {
            return ""getFloat"";
        } else if (typeName.equals(""Double"")) {
            return ""getDouble"";
        } else {
            return null;
        }
    }
}
",False,10,63,0,0,5,23
17,com.ichi2.anki.DeckCreator.java,"/***************************************************************************************
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

/**
 * Create a new deck, with zero cards.
 * Just a basic question/answer model, no choice for now.
 * We just copy empty.anki to the decks directory under the specified name.
 */

public class DeckCreator extends Activity {

    public final static String EMPTY_DECK_NAME = ""empty.anki"";
    
    private String mPrefDeckPath;
    
    private Button mCreate;
    private Button mCancel;
    private EditText mFilename;
    
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);
    	Resources res = getResources();

        setTitle(res.getString(R.string.menu_create_deck));

        // Get decks path
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
        mPrefDeckPath = preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
        
        View mainView = getLayoutInflater().inflate(R.layout.deck_creator, null);
        setContentView(mainView);
        Themes.setWallpaper(mainView);
        
        mCreate = (Button) findViewById(R.id.DeckCreatorOKButton);
        mCancel = (Button) findViewById(R.id.DeckCreatorCancelButton);
        mFilename = (EditText) findViewById(R.id.DeckCreatorFilename);

        // When ""OK"" is clicked.
        mCreate.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String filename = mFilename.getText().toString();
                if (!filename.equals("""")) {
                    if (createDeck(filename) == true) {
                        setResult(RESULT_OK);
                    }
                }
                closeDeckCreator();
            }
        });
        
        // When ""Cancel"" is clicked.
        mCancel.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                setResult(RESULT_CANCELED);
                closeDeckCreator();
            }
        });
    }


    /**
     * Create a new deck with given name
     * @param filename for instance ""my Japanese words"";
     * @return success or not
     */
    private boolean createDeck(String filename) {
        // Log.d(AnkiDroidApp.TAG, ""Creating deck: "" + filename);

        filename = filename + "".anki"";

        // If decks directory does not exist, create it.
        File decksDirectory = new File(mPrefDeckPath);
        AnkiDroidApp.createDecksDirectoryIfMissing(decksDirectory);

        File destinationFile = new File(mPrefDeckPath, filename);
        if (destinationFile.exists()) {
            return false;
        }
        
        try {
            // Copy the empty deck from the assets to the SD card.
            InputStream stream = getResources().getAssets().open(EMPTY_DECK_NAME);
            Utils.writeToFile(stream, destinationFile.getAbsolutePath());
            stream.close();
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            Log.e(AnkiDroidApp.TAG, ""onCreate - The copy of empty.anki to the SD card failed."");
            return false;
        }

        Deck.initializeEmptyDeck(mPrefDeckPath + ""/"" + filename);

        return true;
    }
    
    
    private void closeDeckCreator() {
        finish();
        if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
            ActivityTransitionAnimation.slide(DeckCreator.this, ActivityTransitionAnimation.LEFT);
        }    
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)  {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            // Log.i(AnkiDroidApp.TAG, ""DeckCreator - onBackPressed()"");
            closeDeckCreator();
            MetaDB.closeDB();
        }

        return super.onKeyDown(keyCode, event);
    }
}
",False,28,63,0,0,5,19
18,com.ichi2.anki.SyncClient.java,"/***************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.FileEntity;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedOutputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URLEncoder;
import java.sql.Date;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import java.util.zip.InflaterInputStream;

public class SyncClient {

    private enum Keys {
        models, facts, cards, media
    };

    /**
     * Constants used on the multipart message
     */
    private static final String MIME_BOUNDARY = ""Anki-sync-boundary"";
    private static final String END = ""\r\n"";
    private static final String TWO_HYPHENS = ""--"";

    private Deck mDeck;
    private AnkiDroidProxy mServer;
    private double mLocalTime;
    private double mRemoteTime;


    public SyncClient(Deck deck) {
        mDeck = deck;
        mServer = null;
        mLocalTime = 0;
        mRemoteTime = 0;
    }


    public AnkiDroidProxy getServer() {
        return mServer;
    }


    public void setServer(AnkiDroidProxy server) {
        mServer = server;
    }

    public double getRemoteTime() {
        return mRemoteTime;
    }

    public void setRemoteTime(double time) {
        mRemoteTime = time;
    }

    public double getLocalTime() {
        return mLocalTime;
    }

    public void setLocalTime(double time) {
        mLocalTime = time;
    }

    public void setDeck(Deck deck) {
        mDeck = deck;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, prepareSync
     *
     * @return
     */
    public boolean prepareSync(double timediff) {
        // Log.i(AnkiDroidApp.TAG, ""prepareSync = "" + String.format(Utils.ENGLISH_LOCALE, ""%f"", mDeck.getLastSync()));

        mLocalTime = mDeck.getModified();
        mRemoteTime = mServer.modified();

        // Log.i(AnkiDroidApp.TAG, ""localTime = "" + mLocalTime);
        // Log.i(AnkiDroidApp.TAG, ""remoteTime = "" + mRemoteTime);

        if (mLocalTime == mRemoteTime) {
            return false;
        }

        double l = mDeck.getLastSync();
        // Log.i(AnkiDroidApp.TAG, ""lastSync local = "" + l);
        double r = mServer.lastSync();
        // Log.i(AnkiDroidApp.TAG, ""lastSync remote = "" + r);

        // Set lastSync to the lower of the two sides, and account for slow clocks & assume it took up to 10 seconds
        // for the reply to arrive
        mDeck.setLastSync(Math.min(l, r) - timediff - 10);

        return true;
    }


    public JSONArray summaries() throws JSONException {

        JSONArray summaries = new JSONArray();
        JSONObject sum = summary(mDeck.getLastSync());
        if (sum == null) {
            return null;
        }
        summaries.put(sum);
        sum = mServer.summary(mDeck.getLastSync());
        summaries.put(sum);
        if (sum == null) {
            return null;
        }

        return summaries;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - summary
     *
     * @param lastSync
     * @throws JSONException
     */
    public JSONObject summary(double lastSync) throws JSONException {
        // Log.i(AnkiDroidApp.TAG, ""Summary Local"");
        mDeck.setLastSync(lastSync);
        mDeck.commitToDB();

        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath());

        String lastSyncString = String.format(Utils.ENGLISH_LOCALE, ""%f"", lastSync);
        // Cards
        JSONArray cards = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT id, modified FROM cards WHERE modified > "" + lastSyncString, null));
        // Cards - delcards
        JSONArray delcards = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT cardId, deletedTime FROM cardsDeleted WHERE deletedTime > "" + lastSyncString, null));

        // Facts
        JSONArray facts = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT id, modified FROM facts WHERE modified > "" + lastSyncString, null));
        // Facts - delfacts
        JSONArray delfacts = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT factId, deletedTime FROM factsDeleted WHERE deletedTime > "" + lastSyncString, null));

        // Models
        JSONArray models = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT id, modified FROM models WHERE modified > "" + lastSyncString, null));
        // Models - delmodels
        JSONArray delmodels = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT modelId, deletedTime FROM modelsDeleted WHERE deletedTime > "" + lastSyncString, null));

        // Media
        JSONArray media = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT id, created FROM media WHERE created > "" + lastSyncString, null));
        // Media - delmedia
        JSONArray delmedia = cursorToJSONArray(ankiDB.getDatabase().rawQuery(
                ""SELECT mediaId, deletedTime FROM mediaDeleted WHERE deletedTime > "" + lastSyncString, null));

        JSONObject summary = new JSONObject();
        try {
            summary.put(""cards"", cards);
            summary.put(""delcards"", delcards);
            summary.put(""facts"", facts);
            summary.put(""delfacts"", delfacts);
            summary.put(""models"", models);
            summary.put(""delmodels"", delmodels);
            summary.put(""media"", media);
            summary.put(""delmedia"", delmedia);
        } catch (JSONException e) {
            Log.e(AnkiDroidApp.TAG, ""SyncClient.summary - JSONException = "" + e.getMessage());
            return null;
        }

        // Log.i(AnkiDroidApp.TAG, ""Summary Local = "");
        Utils.printJSONObject(summary, false);

        return summary;
    }


    private JSONArray cursorToJSONArray(Cursor cursor) throws JSONException {
        JSONArray jsonArray = new JSONArray();
        while (cursor.moveToNext()) {
            JSONArray element = new JSONArray();

            element.put(cursor.getLong(0));
            element.put(cursor.getDouble(1));
            jsonArray.put(element);
        }

        cursor.close();

        return jsonArray;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - genPayload
     * @throws JSONException
     */
    public JSONObject genPayload(JSONArray summaries) throws JSONException {
        // // Log.i(AnkiDroidApp.TAG, ""genPayload"");
        // Ensure global stats are available (queue may not be built)
        preSyncRefresh();

        JSONObject payload = new JSONObject();

        Keys[] keys = Keys.values();

        for (int i = 0; i < keys.length; i++) {
            // // Log.i(AnkiDroidApp.TAG, ""Key "" + keys[i].name());
            String key = keys[i].name();
            // Handle models, facts, cards and media
            JSONArray diff = diffSummary((JSONObject) summaries.get(0), (JSONObject) summaries.get(1), key);
            payload.put(""added-"" + key, getObjsFromKey((JSONArray) diff.get(0), key));
            payload.put(""deleted-"" + key, diff.get(1));
            payload.put(""missing-"" + key, diff.get(2));
            deleteObjsFromKey((JSONArray) diff.get(3), key);
        }

        // If the last modified deck was the local one, handle the remainder
        if (mLocalTime > mRemoteTime) {

            payload.put(""stats"", bundleStats());
            payload.put(""history"", bundleHistory());
            payload.put(""sources"", bundleSources());
            // Finally, set new lastSync and bundle the deck info
            payload.put(""deck"", bundleDeck());
        }

        // Log.i(AnkiDroidApp.TAG, ""Payload ="");
        Utils.printJSONObject(payload, true); //XXX: Why writeToFile = true?

        return payload;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - payloadChanges
     * @throws JSONException
     */
    private Object[] payloadChanges(JSONObject payload) throws JSONException {
        Object[] h = new Object[8];

        h[0] = payload.getJSONObject(""added-facts"").getJSONArray(""facts"").length();
        h[1] = payload.getJSONArray(""missing-facts"").length();
        h[2] = payload.getJSONArray(""added-cards"").length();
        h[3] = payload.getJSONArray(""missing-cards"").length();
        h[4] = payload.getJSONArray(""added-models"").length();
        h[5] = payload.getJSONArray(""missing-models"").length();

        if (mLocalTime > mRemoteTime) {
            h[6] = ""all"";
            h[7] = 0;
        } else {
            h[6] = 0;
            h[7] = ""all"";
        }
        return h;
    }


    public String payloadChangeReport(JSONObject payload) throws JSONException {
        return AnkiDroidApp.getAppResources().getString(R.string.change_report_format, payloadChanges(payload));
    }


    public void applyPayloadReply(JSONObject payloadReply) throws JSONException {
        // Log.i(AnkiDroidApp.TAG, ""applyPayloadReply"");
        Keys[] keys = Keys.values();

        for (int i = 0; i < keys.length; i++) {
            String key = keys[i].name();
            updateObjsFromKey(payloadReply, key);
        }

        if (!payloadReply.isNull(""deck"")) {
            updateDeck(payloadReply.getJSONObject(""deck""));
            updateStats(payloadReply.getJSONObject(""stats""));
            updateHistory(payloadReply.getJSONArray(""history""));
            if (!payloadReply.isNull(""sources"")) {
                updateSources(payloadReply.getJSONArray(""sources""));
            }
            mDeck.commitToDB();
        }

        mDeck.commitToDB();

        // Rebuild priorities on client

        // Get card ids
        JSONArray cards = payloadReply.getJSONArray(""added-cards"");
        int len = cards.length();
        long[] cardIds = new long[len];
        for (int i = 0; i < len; i++) {
            cardIds[i] = cards.getJSONArray(i).getLong(0);
        }
        mDeck.updateCardTags(cardIds);
        rebuildPriorities(cardIds);

        long missingFacts = missingFacts();
        if (missingFacts != 0l) {
            Log.e(AnkiDroidApp.TAG, ""Facts missing after sync ("" + missingFacts + "" facts)!"");
        }
        assert missingFacts == 0l;

    }

    private long missingFacts() {
        try {
            return mDeck.getDB().queryScalar(""SELECT count() FROM cards WHERE factId NOT IN (SELECT id FROM facts)"");
        } catch (Exception e) {
            return 0;
        }
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - preSyncRefresh
     */
    private void preSyncRefresh() {
        Stats.globalStats(mDeck);
    }


    private void rebuildPriorities(long[] cardIds) {
        rebuildPriorities(cardIds, null);
    }
    private void rebuildPriorities(long[] cardIds, String[] suspend) {
        //try {
            mDeck.updateAllPriorities(true, false);
            mDeck.updatePriorities(cardIds, suspend, false);
        //} catch (SQLException e) {
        //    Log.e(TAG, ""SQLException e = "" + e.getMessage());
        //}
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - diffSummary
     * @throws JSONException
     */
    private JSONArray diffSummary(JSONObject summaryLocal, JSONObject summaryServer, String key) throws JSONException {
        JSONArray locallyEdited = new JSONArray();
        JSONArray locallyDeleted = new JSONArray();
        JSONArray remotelyEdited = new JSONArray();
        JSONArray remotelyDeleted = new JSONArray();

        // Log.i(AnkiDroidApp.TAG, ""\ndiffSummary - Key = "" + key);
        // Log.i(AnkiDroidApp.TAG, ""\nSummary local = "");
        Utils.printJSONObject(summaryLocal, false);
        // Log.i(AnkiDroidApp.TAG, ""\nSummary server = "");
        Utils.printJSONObject(summaryServer, false);

        // Hash of all modified ids
        HashSet<Long> ids = new HashSet<Long>();

        // Build a hash (id item key, modification time) of the modifications on server (null -> deleted)
        HashMap<Long, Double> remoteMod = new HashMap<Long, Double>();
        putExistingItems(ids, remoteMod, summaryServer.getJSONArray(key));
        HashMap<Long, Double> rdeletedIds = putDeletedItems(ids, remoteMod, summaryServer.getJSONArray(""del"" + key));

        // Build a hash (id item, modification time) of the modifications on client (null -> deleted)
        HashMap<Long, Double> localMod = new HashMap<Long, Double>();
        putExistingItems(ids, localMod, summaryLocal.getJSONArray(key));
        HashMap<Long, Double> ldeletedIds = putDeletedItems(ids, localMod, summaryLocal.getJSONArray(""del"" + key));

        Iterator<Long> idsIterator = ids.iterator();
        while (idsIterator.hasNext()) {
            Long id = idsIterator.next();
            Double localModTime = localMod.get(id);
            Double remoteModTime = remoteMod.get(id);

            // Log.i(AnkiDroidApp.TAG, ""\nid = "" + id + "", localModTime = "" + localModTime + "", remoteModTime = "" + remoteModTime);
            // Changed/Existing on both sides
            if (localModTime != null && remoteModTime != null) {
                // Log.i(AnkiDroidApp.TAG, ""localModTime not null AND remoteModTime not null"");
                if (localModTime < remoteModTime) {
                    // Log.i(AnkiDroidApp.TAG, ""Remotely edited"");
                    remotelyEdited.put(id);
                } else if (localModTime > remoteModTime) {
                    // Log.i(AnkiDroidApp.TAG, ""Locally edited"");
                    locallyEdited.put(id);
                }
            }
            // If it's missing on server or newer here, sync
            else if (localModTime != null && remoteModTime == null) {
                // Log.i(AnkiDroidApp.TAG, ""localModTime not null AND remoteModTime null"");
                if (!rdeletedIds.containsKey(id) || rdeletedIds.get(id) < localModTime) {
                    // Log.i(AnkiDroidApp.TAG, ""Locally edited"");
                    locallyEdited.put(id);
                } else {
                    // Log.i(AnkiDroidApp.TAG, ""Remotely deleted"");
                    remotelyDeleted.put(id);
                }
            }
            // If it's missing locally or newer there, sync
            else if (remoteModTime != null && localModTime == null) {
                // Log.i(AnkiDroidApp.TAG, ""remoteModTime not null AND localModTime null"");
                if (!ldeletedIds.containsKey(id) || ldeletedIds.get(id) < remoteModTime) {
                    // Log.i(AnkiDroidApp.TAG, ""Remotely edited"");
                    remotelyEdited.put(id);
                } else {
                    // Log.i(AnkiDroidApp.TAG, ""Locally deleted"");
                    locallyDeleted.put(id);
                }
            }
            // Deleted or not modified in both sides
            else {
                // Log.i(AnkiDroidApp.TAG, ""localModTime null AND remoteModTime null"");
                if (ldeletedIds.containsKey(id) && !rdeletedIds.containsKey(id)) {
                    // Log.i(AnkiDroidApp.TAG, ""Locally deleted"");
                    locallyDeleted.put(id);
                } else if (rdeletedIds.containsKey(id) && !ldeletedIds.containsKey(id)) {
                    // Log.i(AnkiDroidApp.TAG, ""Remotely deleted"");
                    remotelyDeleted.put(id);
                }
            }
        }

        JSONArray diff = new JSONArray();
        diff.put(locallyEdited);
        diff.put(locallyDeleted);
        diff.put(remotelyEdited);
        diff.put(remotelyDeleted);

        return diff;
    }


    private void putExistingItems(HashSet<Long> ids, HashMap<Long, Double> dictExistingItems, JSONArray existingItems) throws JSONException {
        int nbItems = existingItems.length();
        for (int i = 0; i < nbItems; i++) {
            JSONArray itemModified = existingItems.getJSONArray(i);
            Long idItem = itemModified.getLong(0);
            Double modTimeItem = itemModified.getDouble(1);
            dictExistingItems.put(idItem, modTimeItem);
            ids.add(idItem);
        }
    }


    private HashMap<Long, Double> putDeletedItems(HashSet<Long> ids, HashMap<Long, Double> dictDeletedItems,
            JSONArray deletedItems) throws JSONException {
        HashMap<Long, Double> deletedIds = new HashMap<Long, Double>();
        int nbItems = deletedItems.length();
        for (int i = 0; i < nbItems; i++) {
            JSONArray itemModified = deletedItems.getJSONArray(i);
            Long idItem = itemModified.getLong(0);
            Double modTimeItem = itemModified.getDouble(1);
            dictDeletedItems.put(idItem, null);
            deletedIds.put(idItem, modTimeItem);
            ids.add(idItem);
        }

        return deletedIds;
    }


    private Object getObjsFromKey(JSONArray ids, String key) throws JSONException {
        if (""models"".equalsIgnoreCase(key)) {
            return getModels(ids);
        } else if (""facts"".equalsIgnoreCase(key)) {
            return getFacts(ids);
        } else if (""cards"".equalsIgnoreCase(key)) {
            return getCards(ids);
        } else if (""media"".equalsIgnoreCase(key)) {
            return getMedia(ids);
        }

        return null;
    }


    private void deleteObjsFromKey(JSONArray ids, String key) throws JSONException {
        if (""models"".equalsIgnoreCase(key)) {
            deleteModels(ids);
        } else if (""facts"".equalsIgnoreCase(key)) {
            mDeck.deleteFacts(Utils.jsonArrayToListString(ids));
        } else if (""cards"".equalsIgnoreCase(key)) {
            mDeck.deleteCards(Utils.jsonArrayToListString(ids));
        } else if (""media"".equalsIgnoreCase(key)) {
            deleteMedia(ids);
        }
    }


    private void updateObjsFromKey(JSONObject payloadReply, String key) throws JSONException {
        if (""models"".equalsIgnoreCase(key)) {
            // Log.i(AnkiDroidApp.TAG, ""updateModels"");
            updateModels(payloadReply.getJSONArray(""added-models""));
        } else if (""facts"".equalsIgnoreCase(key)) {
            // Log.i(AnkiDroidApp.TAG, ""updateFacts"");
            updateFacts(payloadReply.getJSONObject(""added-facts""));
        } else if (""cards"".equalsIgnoreCase(key)) {
            // Log.i(AnkiDroidApp.TAG, ""updateCards"");
            updateCards(payloadReply.getJSONArray(""added-cards""));
        } else if (""media"".equalsIgnoreCase(key)) {
            // Log.i(AnkiDroidApp.TAG, ""updateMedia"");
            updateMedia(payloadReply.getJSONArray(""added-media""));
        }
    }


    /**
     * Models
     */

    // TODO: Include the case with updateModified
    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - getModels
     *
     * @param ids
     * @return
     * @throws JSONException
     */
    private JSONArray getModels(JSONArray ids) throws JSONException// , boolean updateModified)
    {
        JSONArray models = new JSONArray();

        int nbIds = ids.length();
        for (int i = 0; i < nbIds; i++) {
            models.put(bundleModel(ids.getLong(i)));
        }

        return models;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - bundleModel
     *
     * @param id
     * @return
     * @throws JSONException
     */
    private JSONObject bundleModel(Long id) throws JSONException// , boolean updateModified
    {
        JSONObject model = new JSONObject();
        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT * FROM models WHERE id = "" + id, null);
        if (cursor.moveToFirst()) {
            model.put(""id"", cursor.getLong(0));
            model.put(""deckId"", cursor.getInt(1));
            model.put(""created"", cursor.getDouble(2));
            model.put(""modified"", cursor.getDouble(3));
            model.put(""tags"", cursor.getString(4));
            model.put(""name"", cursor.getString(5));
            model.put(""description"", cursor.getString(6));
            model.put(""features"", cursor.getDouble(7));
            model.put(""spacing"", cursor.getDouble(8));
            model.put(""initialSpacing"", cursor.getDouble(9));
            model.put(""source"", cursor.getInt(10));
            model.put(""fieldModels"", bundleFieldModels(id));
            model.put(""cardModels"", bundleCardModels(id));
        }
        cursor.close();

        // Log.i(AnkiDroidApp.TAG, ""Model = "");
        Utils.printJSONObject(model, false);

        return model;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - bundleFieldModel
     *
     * @param id
     * @return
     * @throws JSONException
     */
    private JSONArray bundleFieldModels(Long id) throws JSONException {
        JSONArray fieldModels = new JSONArray();

        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT * FROM fieldModels WHERE modelId = "" + id, null);
        while (cursor.moveToNext()) {
            JSONObject fieldModel = new JSONObject();

            fieldModel.put(""id"", cursor.getLong(0));
            fieldModel.put(""ordinal"", cursor.getInt(1));
            fieldModel.put(""modelId"", cursor.getLong(2));
            fieldModel.put(""name"", cursor.getString(3));
            fieldModel.put(""description"", cursor.getString(4));
            fieldModel.put(""features"", cursor.getString(5));
            fieldModel.put(""required"", cursor.getString(6));
            fieldModel.put(""unique"", cursor.getString(7));
            fieldModel.put(""numeric"", cursor.getString(8));
            fieldModel.put(""quizFontFamily"", cursor.getString(9));
            fieldModel.put(""quizFontSize"", cursor.getInt(10));
            fieldModel.put(""quizFontColour"", cursor.getString(11));
            fieldModel.put(""editFontFamily"", cursor.getString(12));
            fieldModel.put(""editFontSize"", cursor.getInt(13));

            fieldModels.put(fieldModel);
        }
        cursor.close();

        return fieldModels;
    }


    private JSONArray bundleCardModels(Long id) throws JSONException {
        JSONArray cardModels = new JSONArray();

        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT * FROM cardModels WHERE modelId = "" + id, null);
        while (cursor.moveToNext()) {
            JSONObject cardModel = new JSONObject();

            cardModel.put(""id"", cursor.getLong(0));
            cardModel.put(""ordinal"", cursor.getInt(1));
            cardModel.put(""modelId"", cursor.getLong(2));
            cardModel.put(""name"", cursor.getString(3));
            cardModel.put(""description"", cursor.getString(4));
            cardModel.put(""active"", cursor.getString(5));
            cardModel.put(""qformat"", cursor.getString(6));
            cardModel.put(""aformat"", cursor.getString(7));
            cardModel.put(""lformat"", cursor.getString(8));
            cardModel.put(""qedformat"", cursor.getString(9));
            cardModel.put(""aedformat"", cursor.getString(10));
            cardModel.put(""questionInAnswer"", cursor.getString(11));
            cardModel.put(""questionFontFamily"", cursor.getString(12));
            cardModel.put(""questionFontSize "", cursor.getInt(13));
            cardModel.put(""questionFontColour"", cursor.getString(14));
            cardModel.put(""questionAlign"", cursor.getInt(15));
            cardModel.put(""answerFontFamily"", cursor.getString(16));
            cardModel.put(""answerFontSize"", cursor.getInt(17));
            cardModel.put(""answerFontColour"", cursor.getString(18));
            cardModel.put(""answerAlign"", cursor.getInt(19));
            cardModel.put(""lastFontFamily"", cursor.getString(20));
            cardModel.put(""lastFontSize"", cursor.getInt(21));
            cardModel.put(""lastFontColour"", cursor.getString(22));
            cardModel.put(""editQuestionFontFamily"", cursor.getString(23));
            cardModel.put(""editQuestionFontSize"", cursor.getInt(24));
            cardModel.put(""editAnswerFontFamily"", cursor.getString(25));
            cardModel.put(""editAnswerFontSize"", cursor.getInt(26));
            cardModel.put(""allowEmptyAnswer"", cursor.getString(27));
            cardModel.put(""typeAnswer"", cursor.getString(28));

            cardModels.put(cardModel);
        }
        cursor.close();

        return cardModels;
    }


    private void deleteModels(JSONArray ids) throws JSONException {
        // Log.i(AnkiDroidApp.TAG, ""deleteModels"");
        int len = ids.length();
        for (int i = 0; i < len; i++) {
            mDeck.deleteModel(ids.getString(i));
        }
    }


    private void updateModels(JSONArray models) throws JSONException {
        ArrayList<String> insertedModelsIds = new ArrayList<String>();
        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath());

        String sql = ""INSERT OR REPLACE INTO models""
                    + "" (id, deckId, created, modified, tags, name, description, features, spacing, initialSpacing, source)""
                    + "" VALUES(?,?,?,?,?,?,?,?,?,?,?)"";
        SQLiteStatement statement = ankiDB.getDatabase().compileStatement(sql);
        int len = models.length();
        for (int i = 0; i < len; i++) {
            JSONObject model = models.getJSONObject(i);

            // id
            String id = model.getString(""id"");
            statement.bindString(1, id);
            // deckId
            statement.bindLong(2, model.getLong(""deckId""));
            // created
            statement.bindDouble(3, model.getDouble(""created""));
            // modified
            statement.bindDouble(4, model.getDouble(""modified""));
            // tags
            statement.bindString(5, model.getString(""tags""));
            // name
            statement.bindString(6, model.getString(""name""));
            // description
            statement.bindString(7, model.getString(""name""));
            // features
            statement.bindString(8, model.getString(""features""));
            // spacing
            statement.bindDouble(9, model.getDouble(""spacing""));
            // initialSpacing
            statement.bindDouble(10, model.getDouble(""initialSpacing""));
            // source
            statement.bindLong(11, model.getLong(""source""));

            statement.execute();

            insertedModelsIds.add(id);

            mergeFieldModels(id, model.getJSONArray(""fieldModels""));
            mergeCardModels(id, model.getJSONArray(""cardModels""));
        }
        statement.close();

        // Delete inserted models from modelsDeleted
        ankiDB.getDatabase().execSQL(""DELETE FROM modelsDeleted WHERE modelId IN "" + Utils.ids2str(insertedModelsIds));
    }


    private void mergeFieldModels(String modelId, JSONArray fieldModels) throws JSONException {
        ArrayList<String> ids = new ArrayList<String>();

        String sql = ""INSERT OR REPLACE INTO fieldModels VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?)"";
        SQLiteStatement statement = mDeck.getDB().getDatabase().compileStatement(sql);
        int len = fieldModels.length();
        for (int i = 0; i < len; i++) {
            JSONObject fieldModel = fieldModels.getJSONObject(i);

            // id
            String id = fieldModel.getString(""id"");
            statement.bindString(1, id);
            // ordinal
            statement.bindString(2, fieldModel.getString(""ordinal""));
            // modelId
            statement.bindLong(3, fieldModel.getLong(""modelId""));
            // name
            statement.bindString(4, fieldModel.getString(""name""));
            // description
            statement.bindString(5, fieldModel.getString(""description""));
            // features
            statement.bindString(6, fieldModel.getString(""features""));
            // required
            statement.bindLong(7, Utils.booleanToInt(fieldModel.getBoolean(""required"")));
            // unique
            statement.bindLong(8, Utils.booleanToInt(fieldModel.getBoolean(""unique"")));
            // numeric
            statement.bindLong(9, Utils.booleanToInt(fieldModel.getBoolean(""numeric"")));
            // quizFontFamily
            if (fieldModel.isNull(""quizFontFamily"")) {
                statement.bindNull(10);
            } else {
                statement.bindString(10, fieldModel.getString(""quizFontFamily""));
            }
            // quizFontSize
            if (fieldModel.isNull(""quizFontSize"")) {
                statement.bindNull(11);
            } else {
                statement.bindString(11, fieldModel.getString(""quizFontSize""));
            }
            // quizFontColour
            if (fieldModel.isNull(""quizFontColour"")) {
                statement.bindNull(12);
            } else {
                statement.bindString(12, fieldModel.getString(""quizFontColour""));
            }
            // editFontFamily
            if (fieldModel.isNull(""editFontFamily"")) {
                statement.bindNull(13);
            } else {
                statement.bindString(13, fieldModel.getString(""editFontFamily""));
            }
            // editFontSize
            statement.bindString(14, fieldModel.getString(""editFontSize""));

            statement.execute();

            ids.add(id);
        }
        statement.close();

        // Delete field models that were not returned by the server
        ArrayList<String> fieldModelsIds = mDeck.getDB().queryColumn(String.class,
                ""SELECT id FROM fieldModels WHERE modelId = "" + modelId, 0);
        if (fieldModelsIds != null) {
            for (String fieldModelId : fieldModelsIds) {
                if (!ids.contains(fieldModelId)) {
                    mDeck.deleteFieldModel(modelId, fieldModelId);
                }
            }
        }
    }


    private void mergeCardModels(String modelId, JSONArray cardModels) throws JSONException {
        ArrayList<String> ids = new ArrayList<String>();

        String sql = ""INSERT OR REPLACE INTO cardModels (id, ordinal, modelId, name, description, active, qformat, ""
                + ""aformat, lformat, qedformat, aedformat, questionInAnswer, questionFontFamily, questionFontSize, ""
                + ""questionFontColour, questionAlign, answerFontFamily, answerFontSize, answerFontColour, answerAlign, ""
                + ""lastFontFamily, lastFontSize, lastFontColour, editQuestionFontFamily, editQuestionFontSize, ""
                + ""editAnswerFontFamily, editAnswerFontSize, allowEmptyAnswer, typeAnswer) ""
                + ""VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"";
        SQLiteStatement statement = mDeck.getDB().getDatabase().compileStatement(sql);
        int len = cardModels.length();
        for (int i = 0; i < len; i++) {
            JSONObject cardModel = cardModels.getJSONObject(i);

            // id
            String id = cardModel.getString(""id"");
            statement.bindString(1, id);
            // ordinal
            statement.bindString(2, cardModel.getString(""ordinal""));
            // modelId
            statement.bindLong(3, cardModel.getLong(""modelId""));
            // name
            statement.bindString(4, cardModel.getString(""name""));
            // description
            statement.bindString(5, cardModel.getString(""description""));
            // active
            statement.bindLong(6, Utils.booleanToInt(cardModel.getBoolean(""active"")));
            // qformat
            statement.bindString(7, cardModel.getString(""qformat""));
            // aformat
            statement.bindString(8, cardModel.getString(""aformat""));
            // lformat
            if (cardModel.isNull(""lformat"")) {
                statement.bindNull(9);
            } else {
                statement.bindString(9, cardModel.getString(""lformat""));
            }
            // qedformat
            if (cardModel.isNull(""qedformat"")) {
                statement.bindNull(10);
            } else {
                statement.bindString(10, cardModel.getString(""qedformat""));
            }
            // aedformat
            if (cardModel.isNull(""aedformat"")) {
                statement.bindNull(11);
            } else {
                statement.bindString(11, cardModel.getString(""aedformat""));
            }
            // questionInAnswer
            statement.bindLong(12, Utils.booleanToInt(cardModel.getBoolean(""questionInAnswer"")));
            // questionFontFamily
            statement.bindString(13, cardModel.getString(""questionFontFamily""));
            // questionFontSize
            statement.bindString(14, cardModel.getString(""questionFontSize""));
            // questionFontColour
            statement.bindString(15, cardModel.getString(""questionFontColour""));
            // questionAlign
            statement.bindString(16, cardModel.getString(""questionAlign""));
            // answerFontFamily
            statement.bindString(17, cardModel.getString(""answerFontFamily""));
            // answerFontSize
            statement.bindString(18, cardModel.getString(""answerFontSize""));
            // answerFontColour
            statement.bindString(19, cardModel.getString(""answerFontColour""));
            // answerAlign
            statement.bindString(20, cardModel.getString(""answerAlign""));
            // lastFontFamily
            statement.bindString(21, cardModel.getString(""lastFontFamily""));
            // lastFontSize
            statement.bindString(22, cardModel.getString(""lastFontSize""));
            // lastFontColour
            statement.bindString(23, cardModel.getString(""lastFontColour""));
            // editQuestionFontFamily
            if (cardModel.isNull(""editQuestionFontFamily"")) {
                statement.bindNull(24);
            } else {
                statement.bindString(24, cardModel.getString(""editQuestionFontFamily""));
            }
            // editQuestionFontSize
            if (cardModel.isNull(""editQuestionFontSize"")) {
                statement.bindNull(25);
            } else {
                statement.bindString(25, cardModel.getString(""editQuestionFontSize""));
            }
            // editAnswerFontFamily
            if (cardModel.isNull(""editAnswerFontFamily"")) {
                statement.bindNull(26);
            } else {
                statement.bindString(26, cardModel.getString(""editAnswerFontFamily""));
            }
            // editAnswerFontSize
            if (cardModel.isNull(""editAnswerFontSize"")) {
                statement.bindNull(27);
            } else {
                statement.bindString(27, cardModel.getString(""editAnswerFontSize""));
            }
            // allowEmptyAnswer
            if (cardModel.isNull(""allowEmptyAnswer"")) {
                cardModel.put(""allowEmptyAnswer"", true);
            }
            statement.bindLong(28, Utils.booleanToInt(cardModel.getBoolean(""allowEmptyAnswer"")));
            // typeAnswer
            statement.bindString(29, cardModel.getString(""typeAnswer""));

            statement.execute();

            ids.add(id);
        }
        statement.close();

        // Delete card models that were not returned by the server
        ArrayList<String> cardModelsIds = mDeck.getDB().queryColumn(String.class, ""SELECT id FROM cardModels WHERE modelId = ""
                + modelId, 0);
        if (cardModelsIds != null) {
            for (String cardModelId : cardModelsIds) {
                if (!ids.contains(cardModelId)) {
                    mDeck.deleteCardModel(modelId, cardModelId);
                }
            }
        }
    }


    /**
     * Facts
     */

    // TODO: Take into account the updateModified boolean (modified = time.time() or modified = ""modified""... what does
    // exactly do that?)
    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - getFacts
     * @throws JSONException
     */
    private JSONObject getFacts(JSONArray ids) throws JSONException// , boolean updateModified)
    {
        // Log.i(AnkiDroidApp.TAG, ""getFacts"");

        JSONObject facts = new JSONObject();

        JSONArray factsArray = new JSONArray();
        JSONArray fieldsArray = new JSONArray();

        int len = ids.length();
        for (int i = 0; i < len; i++) {
            Long id = ids.getLong(i);
            factsArray.put(getFact(id));
            putFields(fieldsArray, id);
        }

        facts.put(""facts"", factsArray);
        facts.put(""fields"", fieldsArray);

        // Log.i(AnkiDroidApp.TAG, ""facts = "");
        Utils.printJSONObject(facts, false);

        return facts;
    }


    private JSONArray getFact(Long id) throws JSONException {
        JSONArray fact = new JSONArray();

        // TODO: Take into account the updateModified boolean (modified = time.time() or modified = ""modified""... what
        // does exactly do that?)
        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase()
                .rawQuery(""SELECT id, modelId, created, modified, tags, spaceUntil, lastCardId FROM facts WHERE id = ""
                        + id, null);
        if (cursor.moveToFirst()) {
            fact.put(cursor.getLong(0));
            fact.put(cursor.getLong(1));
            fact.put(cursor.getDouble(2));
            fact.put(cursor.getDouble(3));
            fact.put(cursor.getString(4));
            fact.put(cursor.getDouble(5));
            fact.put(cursor.getLong(6));
        }
        cursor.close();

        return fact;
    }


    private void putFields(JSONArray fields, Long id) {
        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT * FROM fields WHERE factId = "" + id, null);
        while (cursor.moveToNext()) {
            JSONArray field = new JSONArray();

            field.put(cursor.getLong(0));
            field.put(cursor.getLong(1));
            field.put(cursor.getLong(2));
            field.put(cursor.getInt(3));
            field.put(cursor.getString(4));

            fields.put(field);
        }
        cursor.close();
    }


    private void updateFacts(JSONObject factsDict) throws JSONException {
        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath());
        JSONArray facts = factsDict.getJSONArray(""facts"");
        int lenFacts = facts.length();

        if (lenFacts > 0) {
            JSONArray fields = factsDict.getJSONArray(""fields"");
            int lenFields = fields.length();

            // Grab fact ids
            // They will be used later to recalculate the count of facts and to delete them from DB
            ArrayList<String> factIds = new ArrayList<String>();
            for (int i = 0; i < lenFacts; i++) {
                factIds.add(facts.getJSONArray(i).getString(0));
            }
            String factIdsString = Utils.ids2str(factIds);

            // Update facts
            String sqlFact = ""INSERT OR REPLACE INTO facts (id, modelId, created, modified, tags, spaceUntil, lastCardId)""
                            + "" VALUES(?,?,?,?,?,?,?)"";
            SQLiteStatement statement = ankiDB.getDatabase().compileStatement(sqlFact);
            for (int i = 0; i < lenFacts; i++) {
                JSONArray fact = facts.getJSONArray(i);

                // id
                statement.bindLong(1, fact.getLong(0));
                // modelId
                statement.bindLong(2, fact.getLong(1));
                // created
                statement.bindDouble(3, fact.getDouble(2));
                // modified
                statement.bindDouble(4, fact.getDouble(3));
                // tags
                statement.bindString(5, fact.getString(4));
                // spaceUntil
                if (fact.getString(5) == null) {
                    statement.bindString(6, """");
                } else {
                    statement.bindString(6, fact.getString(5));
                }
                // lastCardId
                if (!fact.isNull(6)) {
                    statement.bindLong(7, fact.getLong(6));
                } else {
                    statement.bindNull(7);
                }

                statement.execute();

            }
            statement.close();

            // Update fields (and delete first the local ones, since ids may have changed)
            ankiDB.getDatabase().execSQL(""DELETE FROM fields WHERE factId IN "" + factIdsString);

            String sqlFields = ""INSERT INTO fields (id, factId, fieldModelId, ordinal, value) VALUES(?,?,?,?,?)"";
            statement = ankiDB.getDatabase().compileStatement(sqlFields);
            for (int i = 0; i < lenFields; i++) {
                JSONArray field = fields.getJSONArray(i);

                // id
                statement.bindLong(1, field.getLong(0));
                // factId
                statement.bindLong(2, field.getLong(1));
                // fieldModelId
                statement.bindLong(3, field.getLong(2));
                // ordinal
                statement.bindString(4, field.getString(3));
                // value
                statement.bindString(5, field.getString(4));

                statement.execute();
            }
            statement.close();

            // Delete inserted facts from deleted
            ankiDB.getDatabase().execSQL(""DELETE FROM factsDeleted WHERE factId IN "" + factIdsString);
        }
    }


    /**
     * Cards
     */

    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - getCards
     * @throws JSONException
     */
    private JSONArray getCards(JSONArray ids) throws JSONException {
        JSONArray cards = new JSONArray();

        // SELECT id, factId, cardModelId, created, modified, tags, ordinal, priority, interval, lastInterval, due,
        // lastDue, factor,
        // firstAnswered, reps, successive, averageTime, reviewTime, youngEase0, youngEase1, youngEase2, youngEase3,
        // youngEase4,
        // matureEase0, matureEase1, matureEase2, matureEase3, matureEase4, yesCount, noCount, question, answer,
        // lastFactor, spaceUntil, relativeDelay,
        // type, combinedDue FROM cards WHERE id IN "" + ids2str(ids)
        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT * FROM cards WHERE id IN "" + Utils.ids2str(ids), null);
        while (cursor.moveToNext()) {
            JSONArray card = new JSONArray();

            // id
            card.put(cursor.getLong(0));
            // factId
            card.put(cursor.getLong(1));
            // cardModelId
            card.put(cursor.getLong(2));
            // created
            card.put(cursor.getDouble(3));
            // modified
            card.put(cursor.getDouble(4));
            // tags
            card.put(cursor.getString(5));
            // ordinal
            card.put(cursor.getInt(6));
            // priority
            card.put(cursor.getInt(9));
            // interval
            card.put(cursor.getDouble(10));
            // lastInterval
            card.put(cursor.getDouble(11));
            // due
            card.put(cursor.getDouble(12));
            // lastDue
            card.put(cursor.getDouble(13));
            // factor
            card.put(cursor.getDouble(14));
            // firstAnswered
            card.put(cursor.getDouble(16));
            // reps
            card.put(cursor.getString(17));
            // successive
            card.put(cursor.getInt(18));
            // averageTime
            card.put(cursor.getDouble(19));
            // reviewTime
            card.put(cursor.getDouble(20));
            // youngEase0
            card.put(cursor.getInt(21));
            // youngEase1
            card.put(cursor.getInt(22));
            // youngEase2
            card.put(cursor.getInt(23));
            // youngEase3
            card.put(cursor.getInt(24));
            // youngEase4
            card.put(cursor.getInt(25));
            // matureEase0
            card.put(cursor.getInt(26));
            // matureEase1
            card.put(cursor.getInt(27));
            // matureEase2
            card.put(cursor.getInt(28));
            // matureEase3
            card.put(cursor.getInt(29));
            // matureEase4
            card.put(cursor.getInt(30));
            // yesCount
            card.put(cursor.getInt(31));
            // noCount
            card.put(cursor.getInt(32));
            // question
            card.put(cursor.getString(7));
            // answer
            card.put(cursor.getString(8));
            // lastFactor
            card.put(cursor.getDouble(15));
            // spaceUntil
            card.put(cursor.getDouble(33));
            // type
            card.put(cursor.getInt(36));
            // combinedDue
            card.put(cursor.getDouble(37));
            // relativeDelay
            card.put(cursor.getInt(34));

            cards.put(card);
        }
        cursor.close();

        return cards;
    }


    private void updateCards(JSONArray cards) throws JSONException {
        int len = cards.length();
        if (len > 0) {
            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath());
            ArrayList<String> ids = new ArrayList<String>();
            for (int i = 0; i < len; i++) {
                ids.add(cards.getJSONArray(i).getString(0));
            }
            String idsString = Utils.ids2str(ids);

            String sql = ""INSERT OR REPLACE INTO cards (id, factId, cardModelId, created, modified, tags, ordinal, ""
                    + ""priority, interval, lastInterval, due, lastDue, factor, firstAnswered, reps, successive, ""
                    + ""averageTime, reviewTime, youngEase0, youngEase1, youngEase2, youngEase3, youngEase4, ""
                    + ""matureEase0, matureEase1, matureEase2, matureEase3, matureEase4, yesCount, noCount, question, ""
                    + ""answer, lastFactor, spaceUntil, type, combinedDue, relativeDelay, isDue) ""
                    + ""VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?, 0)"";
            SQLiteStatement statement = ankiDB.getDatabase().compileStatement(sql);
            for (int i = 0; i < len; i++) {
                JSONArray card = cards.getJSONArray(i);

                // id
                statement.bindLong(1, card.getLong(0));
                // factId
                statement.bindLong(2, card.getLong(1));
                // cardModelId
                statement.bindLong(3, card.getLong(2));
                // created
                statement.bindDouble(4, card.getDouble(3));
                // modified
                statement.bindDouble(5, card.getDouble(4));
                // tags
                statement.bindString(6, card.getString(5));
                // ordinal
                statement.bindLong(7, card.getInt(6));
                // priority
                statement.bindLong(8, card.getInt(7));
                // interval
                statement.bindDouble(9, card.getDouble(8));
                // lastInterval
                statement.bindDouble(10, card.getDouble(9));
                // due
                statement.bindDouble(11, card.getDouble(10));
                // lastDue
                statement.bindDouble(12, card.getDouble(11));
                // factor
                statement.bindDouble(13, card.getDouble(12));
                // firstAnswered
                statement.bindDouble(14, card.getDouble(13));
                // reps
                statement.bindLong(15, card.getInt(14));
                // successive
                statement.bindLong(16, card.getInt(15));
                // averageTime
                statement.bindDouble(17, card.getDouble(16));
                // reviewTime
                statement.bindDouble(18, card.getDouble(17));
                // youngEase0
                statement.bindLong(19, card.getInt(18));
                // youngEase1
                statement.bindLong(20, card.getInt(19));
                // youngEase2
                statement.bindLong(21, card.getInt(20));
                // youngEase3
                statement.bindLong(22, card.getInt(21));
                // youngEase4
                statement.bindLong(23, card.getInt(22));
                // matureEase0
                statement.bindLong(24, card.getInt(23));
                // matureEase1
                statement.bindLong(25, card.getInt(24));
                // matureEase2
                statement.bindLong(26, card.getInt(25));
                // matureEase3
                statement.bindLong(27, card.getInt(26));
                // matureEase4
                statement.bindLong(28, card.getInt(27));
                // yesCount
                statement.bindLong(29, card.getInt(28));
                // noCount
                statement.bindLong(30, card.getInt(29));
                // question
                statement.bindString(31, card.getString(30));
                // answer
                statement.bindString(32, card.getString(31));
                // lastFactor
                statement.bindDouble(33, card.getDouble(32));
                // spaceUntil
                statement.bindDouble(34, card.getDouble(33));
                // type
                statement.bindLong(35, card.getInt(34));
                // combinedDue
                statement.bindDouble(36, card.getDouble(35));
                // relativeDelay
                statement.bindString(37, genType(card));

                statement.execute();
            }
            statement.close();

            ankiDB.getDatabase().execSQL(""DELETE FROM cardsDeleted WHERE cardId IN "" + idsString);
        }
    }
    private String genType(JSONArray row) throws JSONException {
        if (row.length() >= 37) {
            return row.getString(36);
        }
        if (row.getInt(15) != 0) {
            return ""1"";
        } else if (row.getInt(14) != 0) {
            return ""0"";
        }
        return ""2"";
    }


    /**
     * Media
     */

    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - getMedia
     * @throws JSONException
     */
    private JSONArray getMedia(JSONArray ids) throws JSONException {
        JSONArray media = new JSONArray();

        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT id, filename, size, created, originalPath, description FROM media WHERE id IN ""
                        + Utils.ids2str(ids), null);
        while (cursor.moveToNext()) {
            JSONArray m = new JSONArray();

            // id
            m.put(cursor.getLong(0));
            // filename
            m.put(cursor.getString(1));
            // size
            m.put(cursor.getInt(2));
            // created
            m.put(cursor.getDouble(3));
            // originalPath
            m.put(cursor.getString(4));
            // description
            m.put(cursor.getString(5));

            media.put(m);
        }
        cursor.close();

        return media;
    }


    private void deleteMedia(JSONArray ids) throws JSONException {
        // Log.i(AnkiDroidApp.TAG, ""deleteMedia"");

        String idsString = Utils.ids2str(ids);

        // Get filenames
        // files below is never used, so it's commented out
        // ArrayList<String> files = mDeck.getDB().queryColumn(String.class, ""SELECT filename FROM media WHERE id IN ""
        //         + idsString, 0);

        // Note the media to delete (Insert the media to delete into mediaDeleted)
        double now = Utils.now();
        String sqlInsert = ""INSERT INTO mediaDeleted SELECT id, "" + String.format(Utils.ENGLISH_LOCALE, ""%f"", now)
                + "" FROM media WHERE media.id = ?"";
        SQLiteStatement statement = mDeck.getDB().getDatabase().compileStatement(sqlInsert);
        int len = ids.length();
        for (int i = 0; i < len; i++) {
            // Log.i(AnkiDroidApp.TAG, ""Inserting media "" + ids.getLong(i) + "" into mediaDeleted"");
            statement.bindLong(1, ids.getLong(i));
            statement.executeInsert();
        }
        statement.close();

        // Delete media
        // Log.i(AnkiDroidApp.TAG, ""Deleting media in = "" + idsString);
        mDeck.getDB().getDatabase().execSQL(""DELETE FROM media WHERE id IN "" + idsString);
    }


    void updateMedia(JSONArray media) throws JSONException {
        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath());
        ArrayList<String> mediaIds = new ArrayList<String>();

        String sql = ""INSERT OR REPLACE INTO media (id, filename, size, created, originalPath, description) ""
                    + ""VALUES(?,?,?,?,?,?)"";
        SQLiteStatement statement = ankiDB.getDatabase().compileStatement(sql);
        int len = media.length();
        String filename = null;
        String sum = null;
        for (int i = 0; i < len; i++) {
            JSONArray m = media.getJSONArray(i);

            // Grab media ids, to delete them later
            String id = m.getString(0);
            mediaIds.add(id);

            // id
            statement.bindString(1, id);
            // filename
            filename = m.getString(1);
            statement.bindString(2, filename);
            // size
            statement.bindString(3, m.getString(2));
            // created
            statement.bindDouble(4, m.getDouble(3));
            // originalPath
            sum = m.getString(4);
            statement.bindString(5, sum);
            // description
            statement.bindString(6, m.getString(5));

            statement.execute();

        }
        statement.close();

        ankiDB.getDatabase().execSQL(""DELETE FROM mediaDeleted WHERE mediaId IN "" + Utils.ids2str(mediaIds));

    }


    /**
     * Deck/Stats/History/Sources
     * @throws JSONException
     */

    private JSONObject bundleDeck() throws JSONException {
        JSONObject bundledDeck = new JSONObject();

        // Ensure modified is not greater than server time
        if ((mServer != null) && (mServer.getTimestamp() != 0.0)) {
            mDeck.setModified(Math.min(mDeck.getModified(), mServer.getTimestamp()));
            // Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""Modified: %f"", mDeck.getModified()));
        }
        // And ensure lastSync is greater than modified
        mDeck.setLastSync(Math.max(Utils.now(), mDeck.getModified() + 1));
        // Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""LastSync: %f"", mDeck.getLastSync()));

        bundledDeck = mDeck.bundleJson(bundledDeck);

        // AnkiDroid Deck.java does not have:
        // css, forceMediaDir, lastSessionStart, lastTags, needLock,
        // progressHandlerCalled,
        // progressHandlerEnabled, revCardOrder, sessionStartReps, sessionStartTime,
        // tmpMediaDir

        // XXX: this implies that they are not synched toward the server, I guess (tested on 0.7).
        // However, the ones left are not persisted by libanki on the DB, so it's a libanki bug that they are sync'ed at all.

        // Our bundleDeck also doesn't need all those fields that store the scheduler Methods

        // Add meta information of the deck (deckVars table)
        JSONArray meta = new JSONArray();
        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT * FROM deckVars"", null);
        while (cursor.moveToNext()) {
            JSONArray deckVar = new JSONArray();
            deckVar.put(cursor.getString(0));
            deckVar.put(cursor.getString(1));
            meta.put(deckVar);
        }
        cursor.close();
        bundledDeck.put(""meta"", meta);

        // Log.i(AnkiDroidApp.TAG, ""Deck ="");
        Utils.printJSONObject(bundledDeck, false);

        return bundledDeck;
    }


    private void updateDeck(JSONObject deckPayload) throws JSONException {
        JSONArray meta = deckPayload.getJSONArray(""meta"");

        // Update meta information
        String sqlMeta = ""INSERT OR REPLACE INTO deckVars (key, value) VALUES(?,?)"";
        SQLiteStatement statement = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase()
                .compileStatement(sqlMeta);
        int lenMeta = meta.length();
        for (int i = 0; i < lenMeta; i++) {
            JSONArray deckVar = meta.getJSONArray(i);

            // key
            statement.bindString(1, deckVar.getString(0));
            // value
            statement.bindString(2, deckVar.getString(1));

            statement.execute();
        }
        statement.close();

        // Update deck
        mDeck.updateFromJson(deckPayload);
    }


    private JSONObject bundleStats() throws JSONException {
        // Log.i(AnkiDroidApp.TAG, ""bundleStats"");

        JSONObject bundledStats = new JSONObject();

        // Get daily stats since the last day the deck was synchronized
        Date lastDay = new Date(java.lang.Math.max(0, (long) (mDeck.getLastSync() - 60 * 60 * 24) * 1000));
        // Log.i(AnkiDroidApp.TAG, ""lastDay = "" + lastDay.toString());
        ArrayList<Long> ids = mDeck.getDB().queryColumn(Long.class,
                ""SELECT id FROM stats WHERE type = 1 and day >= \"""" + lastDay.toString() + ""\"""", 0);

        Stats stat = new Stats(mDeck);
        // Put global stats
        bundledStats.put(""global"", Stats.globalStats(mDeck).bundleJson());
        // Put daily stats
        JSONArray dailyStats = new JSONArray();
        if (ids != null) {
            for (Long id : ids) {
                // Update stat with the values of the stat with id ids.get(i)
                stat.fromDB(id);
                // Bundle this stat and add it to dailyStats
                dailyStats.put(stat.bundleJson());
            }
        }
        bundledStats.put(""daily"", dailyStats);

        // Log.i(AnkiDroidApp.TAG, ""Stats ="");
        Utils.printJSONObject(bundledStats, false);

        return bundledStats;
    }


    private void updateStats(JSONObject stats) throws JSONException {
        // Update global stats
        Stats globalStats = Stats.globalStats(mDeck);
        globalStats.updateFromJson(stats.getJSONObject(""global""));

        // Update daily stats
        Stats stat = new Stats(mDeck);
        JSONArray remoteDailyStats = stats.getJSONArray(""daily"");
        int len = remoteDailyStats.length();
        for (int i = 0; i < len; i++) {
            // Get a specific daily stat
            JSONObject remoteStat = remoteDailyStats.getJSONObject(i);
            Date dailyStatDate = Utils.ordinalToDate(remoteStat.getInt(""day""));

            // If exists a statistic for this day, get it
            try {
                Long id = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).queryScalar(
                        ""SELECT id FROM stats WHERE type = 1 AND day = \"""" + dailyStatDate.toString() + ""\"""");
                stat.fromDB(id);
            } catch (SQLException e) {
                // If it does not exist, create a statistic for this day
                stat.create(Stats.STATS_DAY, dailyStatDate);
            }

            // Update daily stat
            stat.updateFromJson(remoteStat);
        }
    }


    private JSONArray bundleHistory() throws JSONException {
        double delay = 0.0;
        JSONArray bundledHistory = new JSONArray();
        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                        ""SELECT cardId, time, lastInterval, nextInterval, ease, delay, lastFactor, nextFactor, reps, ""
                        + ""thinkingTime, yesCount, noCount FROM reviewHistory ""
                        + ""WHERE time > "" + String.format(Utils.ENGLISH_LOCALE, ""%f"", mDeck.getLastSync()), null);
        while (cursor.moveToNext()) {
            JSONArray review = new JSONArray();

            // cardId
            review.put(0, (long)cursor.getLong(0));
            // time
            review.put(1, (double)cursor.getDouble(1));
            // lastInterval
            review.put(2, (double)cursor.getDouble(2));
            // nextInterval
            review.put(3, (double)cursor.getDouble(3));
            // ease
            review.put(4, (int)cursor.getInt(4));
            // delay
            delay = cursor.getDouble(5);
            Number num = Double.valueOf(delay);
            // Log.d(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""issue 372 2: %.18f %s %s"", delay, num.toString(), review.toString()));
            review.put(5, delay);
            // Log.d(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""issue 372 3: %.18f %s %s"", review.getDouble(5), num.toString(), review.toString()));
            // lastFactor
            review.put(6, (double)cursor.getDouble(6));
            // Log.d(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""issue 372 4: %.18f %s %s"", review.getDouble(5), num.toString(), review.toString()));
            // nextFactor
            review.put(7, (double)cursor.getDouble(7));
            // reps
            review.put(8, (double)cursor.getDouble(8));
            // thinkingTime
            review.put(9, (double)cursor.getDouble(9));
            // yesCount
            review.put(10, (double)cursor.getDouble(10));
            // noCount
            review.put(11, (double)cursor.getDouble(11));

            // Log.d(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""issue 372 complete row: %.18f %.18f %s"", delay, review.getDouble(5), review.toString()));
            bundledHistory.put(review);
        }
        cursor.close();

        // Log.i(AnkiDroidApp.TAG, ""Last sync = "" + String.format(Utils.ENGLISH_LOCALE, ""%f"", mDeck.getLastSync()));
        // Log.i(AnkiDroidApp.TAG, ""Bundled history = "" + bundledHistory.toString());
        return bundledHistory;
    }


    private void updateHistory(JSONArray history) throws JSONException {
        String sql = ""INSERT OR IGNORE INTO reviewHistory (cardId, time, lastInterval, nextInterval, ease, delay, ""
                    + ""lastFactor, nextFactor, reps, thinkingTime, yesCount, noCount) VALUES(?,?,?,?,?,?,?,?,?,?,?,?)"";
        SQLiteStatement statement = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().compileStatement(sql);
        int len = history.length();
        for (int i = 0; i < len; i++) {
            JSONArray h = history.getJSONArray(i);

            // cardId
            statement.bindLong(1, h.getLong(0));
            // time
            statement.bindDouble(2, h.getDouble(1));
            // lastInterval
            statement.bindDouble(3, h.getDouble(2));
            // nextInterval
            statement.bindDouble(4, h.getDouble(3));
            // ease
            statement.bindString(5, h.getString(4));
            // delay
            statement.bindDouble(6, h.getDouble(5));
            // lastFactor
            statement.bindDouble(7, h.getDouble(6));
            // nextFactor
            statement.bindDouble(8, h.getDouble(7));
            // reps
            statement.bindDouble(9, h.getDouble(8));
            // thinkingTime
            statement.bindDouble(10, h.getDouble(9));
            // yesCount
            statement.bindDouble(11, h.getDouble(10));
            // noCount
            statement.bindDouble(12, h.getDouble(11));

            statement.execute();
        }
        statement.close();
    }


    private JSONArray bundleSources() throws JSONException {
        JSONArray bundledSources = new JSONArray();

        Cursor cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT * FROM sources"", null);
        while (cursor.moveToNext()) {
            JSONArray source = new JSONArray();

            // id
            source.put(cursor.getLong(0));
            // name
            source.put(cursor.getString(1));
            // created
            source.put(cursor.getDouble(2));
            // lastSync
            source.put(cursor.getDouble(3));
            // syncPeriod
            source.put(cursor.getInt(4));

            bundledSources.put(source);
        }
        cursor.close();

        // Log.i(AnkiDroidApp.TAG, ""Bundled sources = "" + bundledSources);
        return bundledSources;
    }


    private void updateSources(JSONArray sources) throws JSONException {
        String sql = ""INSERT OR REPLACE INTO sources VALUES(?,?,?,?,?)"";
        SQLiteStatement statement = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().compileStatement(sql);
        int len = sources.length();
        for (int i = 0; i < len; i++) {
            JSONArray source = sources.getJSONArray(i);
            statement.bindLong(1, source.getLong(0));
            statement.bindString(2, source.getString(1));
            statement.bindDouble(3, source.getDouble(2));
            statement.bindDouble(4, source.getDouble(3));
            statement.bindString(5, source.getString(4));
            statement.execute();
        }
        statement.close();
    }


    /**
     * Full sync
     */

    /**
     * Anki Desktop -> libanki/anki/sync.py, SyncTools - needFullSync
     *
     * @param sums
     * @return
     * @throws JSONException
     */
    public boolean needFullSync(JSONArray sums) throws JSONException {
        // Log.i(AnkiDroidApp.TAG, ""needFullSync - lastSync = "" + mDeck.getLastSync());

        if (mDeck.getLastSync() <= 0) {
            // Log.i(AnkiDroidApp.TAG, ""deck.lastSync <= 0"");
            return true;
        }

        int len = sums.length();
        for (int i = 0; i < len; i++) {

            JSONObject summary = sums.getJSONObject(i);
            @SuppressWarnings(""unchecked"") Iterator<String> keys = (Iterator<String>) summary.keys();
            while (keys.hasNext()) {
                String key = keys.next();
                JSONArray l = (JSONArray) summary.get(key);
                // Log.i(AnkiDroidApp.TAG, ""Key "" + key + "", length = "" + l.length());
                if (l.length() > 500) {
                    // Log.i(AnkiDroidApp.TAG, ""Length of key > 500"");
                    return true;
                }
            }
        }

        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath());

        if (ankiDB.queryScalar(""SELECT count() FROM reviewHistory WHERE time > "" + mDeck.getLastSync()) > 500) {
            // Log.i(AnkiDroidApp.TAG, ""reviewHistory since lastSync > 500"");
            return true;
        }
        Date lastDay = new Date(java.lang.Math.max(0, (long) (mDeck.getLastSync() - 60 * 60 * 24) * 1000));

        // Log.i(AnkiDroidApp.TAG, ""lastDay = "" + lastDay.toString() + "", lastDayInMillis = "" + lastDay.getTime());

        // Log.i(AnkiDroidApp.TAG, ""Count stats = "" + ankiDB.queryScalar(""SELECT count() FROM stats WHERE day >= \"""" + lastDay.toString() + ""\""""));
        if (ankiDB.queryScalar(""SELECT count() FROM stats WHERE day >= \"""" + lastDay.toString() + ""\"""") > 100) {
            // Log.i(AnkiDroidApp.TAG, ""stats since lastDay > 100"");
            return true;
        }

        return false;
    }


    public String prepareFullSync() {
        // Ensure modified is not greater than server time
        mDeck.setModified(Math.min(mDeck.getModified(), mServer.getTimestamp()));
        mDeck.commitToDB();
        // The deck is closed after the full sync is completed
        // mDeck.closeDeck();

        if (mLocalTime > mRemoteTime) {
            return ""fromLocal"";
        } else {
            return ""fromServer"";
        }
    }


    public static HashMap<String, String> fullSyncFromLocal(String password, String username, Deck deck, String deckName) {
        HashMap<String, String> result = new HashMap<String, String>();
        Throwable exc = null;
        try {
            // Log.i(AnkiDroidApp.TAG, ""Fullup"");
            // We need to write the output to a temporary file, so that FileEntity knows the length
            String tmpPath = (new File(deck.getDeckPath())).getParent();
            File tmpFile = new File(tmpPath + ""/fulluploadPayload.tmp"");
            if (tmpFile.exists()) {
                tmpFile.delete();
            }
            // Log.i(AnkiDroidApp.TAG, ""Writing temporary payload file..."");
            tmpFile.createNewFile();
            DataOutputStream tmp = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(tmpFile)));
            tmp.writeBytes(TWO_HYPHENS + MIME_BOUNDARY + END);
            tmp.writeBytes(""Content-Disposition: form-data; name=\""p\"""" + END + END + password + END);
            tmp.writeBytes(TWO_HYPHENS + MIME_BOUNDARY + END);
            tmp.writeBytes(""Content-Disposition: form-data; name=\""u\"""" + END + END + username + END);
            tmp.writeBytes(TWO_HYPHENS + MIME_BOUNDARY + END);
            tmp.writeBytes(""Content-Disposition: form-data; name=\""d\"""" + END + END);
            tmp.write(deckName.getBytes(""UTF-8""));
            tmp.writeBytes(END);
            tmp.writeBytes(TWO_HYPHENS + MIME_BOUNDARY + END);
            tmp.writeBytes(""Content-Disposition: form-data; name=\""deck\""; filename=\""deck\"""" + END);
            tmp.writeBytes(""Content-Type: application/octet-stream"" + END);
            tmp.writeBytes(END);

            String deckPath = deck.getDeckPath();
            FileInputStream fStream = new FileInputStream(deckPath);
            byte[] buffer = new byte[Utils.CHUNK_SIZE];
            int length = -1;
            Deflater deflater = new Deflater(Deflater.BEST_SPEED);
            DeflaterOutputStream dos = new DeflaterOutputStream(tmp, deflater);
            while ((length = fStream.read(buffer)) != -1) {
                dos.write(buffer, 0, length);
                // Log.i(AnkiDroidApp.TAG, ""Length = "" + length);
            }
            dos.finish();
            fStream.close();

            tmp.writeBytes(END);
            tmp.writeBytes(TWO_HYPHENS + MIME_BOUNDARY + TWO_HYPHENS + END + END);
            tmp.flush();
            tmp.close();
            // Log.i(AnkiDroidApp.TAG, ""Payload file ready, size: "" + tmpFile.length());

            HttpPost httpPost = new HttpPost(AnkiDroidProxy.SYNC_URL + ""fullup?v="" +
                    URLEncoder.encode(AnkiDroidProxy.SYNC_VERSION, ""UTF-8""));
            httpPost.setHeader(""Content-type"", ""multipart/form-data; boundary="" + MIME_BOUNDARY);
            httpPost.addHeader(""Host"", AnkiDroidProxy.SYNC_HOST);
            httpPost.setEntity(new FileEntity(tmpFile, ""application/octet-stream""));
            DefaultHttpClient httpClient = new DefaultHttpClient();
            HttpResponse resp = httpClient.execute(httpPost);

            // Ensure we got the HTTP 200 response code
            String response = Utils.convertStreamToString(resp.getEntity().getContent());
            int responseCode = resp.getStatusLine().getStatusCode();
            // Log.i(AnkiDroidApp.TAG, ""Response code = "" + responseCode);
            // Read the response
			if (response.substring(0,2).equals(""OK"")) {
				// Update lastSync
			    deck.setLastSync(Double.parseDouble(response.substring(3, response.length()-3)));
			    deck.commitToDB();
			    // Make sure we don't set modified later than lastSync when we do closeDeck later:
			    deck.setLastLoaded(deck.getModified());
			    // Remove temp file
			    tmpFile.delete();
			}
            // Log.i(AnkiDroidApp.TAG, ""Finished!"");
            result.put(""code"", String.valueOf(responseCode));
            result.put(""message"", response);
        } catch (ClientProtocolException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.put(""code"", ""ClientProtocolException"");
            exc = e;
        } catch (UnsupportedEncodingException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.put(""code"", ""UnsupportedEncodingException"");
            exc = e;
        } catch (MalformedURLException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.put(""code"", ""MalformedURLException"");
            exc = e;
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.put(""code"", ""IOException"");
            exc = e;
        }

        if (exc != null) {
            // Sometimes the exception has null message and we have to get it from its cause
            while (exc.getMessage() == null && exc.getCause() != null) {
                exc = exc.getCause();
            }
            result.put(""message"", exc.getMessage());
        }
        return result;
    }


    public static HashMap<String, String> fullSyncFromServer(String password, String username, String deckName, String deckPath) {
        HashMap<String, String> result = new HashMap<String, String>();
        Throwable exc = null;
        try {
            String data = ""p="" + URLEncoder.encode(password, ""UTF-8"") + ""&u="" + URLEncoder.encode(username, ""UTF-8"")
                    + ""&d="" + URLEncoder.encode(deckName, ""UTF-8"");

            // // Log.i(AnkiDroidApp.TAG, ""Data json = "" + data);
            HttpPost httpPost = new HttpPost(AnkiDroidProxy.SYNC_URL + ""fulldown"");
            StringEntity entity = new StringEntity(data);
            httpPost.setEntity(entity);
            httpPost.setHeader(""Content-type"", ""application/x-www-form-urlencoded"");
            DefaultHttpClient httpClient = new DefaultHttpClient();
            HttpResponse response = httpClient.execute(httpPost);
            HttpEntity entityResponse = response.getEntity();
            InputStream content = entityResponse.getContent();
            int responseCode = response.getStatusLine().getStatusCode();
            String tempDeckPath = deckPath + "".tmp"";
            if (responseCode == 200) {
                Utils.writeToFile(new InflaterInputStream(content), tempDeckPath);
                File newFile = new File(tempDeckPath);
                //File oldFile = new File(deckPath);
                if (newFile.renameTo(new File(deckPath))) {
                    result.put(""code"", ""200"");
                } else {
                    result.put(""code"", ""PermissionError"");
                    result.put(""message"", ""Can't overwrite old deck with downloaded from server"");
                }
            } else {
                result.put(""code"", String.valueOf(responseCode));
                result.put(""message"", Utils.convertStreamToString(content));
            }
        } catch (UnsupportedEncodingException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.put(""code"", ""UnsupportedEncodingException"");
            exc = e;
        } catch (ClientProtocolException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.put(""code"", ""ClientProtocolException"");
            exc = e;
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.put(""code"", ""IOException"");
            exc = e;
        }

        if (exc != null) {
            // Sometimes the exception has null message and we have to get it from its cause
            while (exc.getMessage() == null && exc.getCause() != null) {
                exc = exc.getCause();
            }
            result.put(""message"", exc.getMessage());
        }
        return result;
    }

}
",True,84,63,0,0,5,22
19,com.ichi2.anki.Download.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.os.Parcel;
import android.os.Parcelable;

import java.util.HashMap;

public class Download extends HashMap<String, Object> implements Parcelable {

    // Status codes
    public static final int STATUS_STARTED = -1;
    public static final int STATUS_DOWNLOADING = 0;
    public static final int STATUS_PAUSED = 1;
    public static final int STATUS_COMPLETE = 2;
    public static final int STATUS_CANCELLED = 3;
    public static final int STATUS_ERROR = 4;

    private static final long serialVersionUID = 1L;

    // Download's title
    private String mTitle;
    // Download's filename
    private String mFilename;
    // Download URL
    private String mUrl;
    // Size of download in bytes
    private long mSize;
    // Number of bytes downloaded
    private long mDownloaded;
    // Current status of download
    protected int mStatus;


    public Download(String title) {
        mTitle = title;
        this.put(title, true);
        mSize = -1;
        mDownloaded = 0;
        mStatus = STATUS_STARTED;
        // The deck file name should match the deck title. The only characters that we cannot
        // absolutely allow to appear in the filename are the ones reserved in some file system.
        // Currently these include \, /, and :, in order to cover Linux, OSX, and Windows.
        mFilename = mTitle.replaceAll(""[:/\\\\]"", """");
//        if (mFilename.length() > 40) {
//            mFilename = mFilename.substring(0, 40);
//        }
    }


    public long getSize() {
        return mSize;
    }


    public void setSize(long size) {
        mSize = size;
    }


    public long getDownloaded() {
        return mDownloaded;
    }


    public void setDownloaded(long downloaded) {
        mDownloaded = downloaded;
    }


    public String getEstTimeToCompletion() {
        return """";
    }


    public void setEstTimeToCompletion(double estTime) {
        // pass
    }


    public int getProgress() {
        return (int) (((float) mDownloaded / mSize) * 100);
    }


    public int getStatus() {
        return mStatus;
    }


    public void setStatus(int status) {
        mStatus = status;
    }


    public String getTitle() {
        return mTitle;
    }


    public void setTitle(String title) {
        this.remove(mTitle);
        this.put(title, true);
        mTitle = title;
        mFilename = title;
    }


    public String getFilename() {
        return mFilename;
    }


    /********************************************************************
     * Parcel methods *
     ********************************************************************/

    public Download(Parcel in) {
        readFromParcel(in);
    }


    @Override
    public int describeContents() {
        return 0;
    }


    @Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeString(mUrl);
        dest.writeLong(mSize);
        dest.writeLong(mDownloaded);
        dest.writeInt(mStatus);
        dest.writeString(mTitle);
    }


    protected void readFromParcel(Parcel in) {
        mUrl = in.readString();
        mSize = in.readLong();
        mDownloaded = in.readLong();
        mStatus = in.readInt();
        mTitle = in.readString();
    }

    public static final Parcelable.Creator<Download> CREATOR = new Parcelable.Creator<Download>() {

        @Override
        public Download createFromParcel(Parcel in) {
            return new Download(in);
        }


        @Override
        public Download[] newArray(int size) {
            return new Download[size];
        }
    };
}
",False,2,5,1,4,0,0
20,com.ichi2.anki.Fact.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.database.Cursor;
import android.util.Log;

import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * Anki fact.
 * A fact is a single piece of information, made up of a number of fields.
 * See http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Facts
 */
public class Fact {

    // TODO: Javadoc.
    // TODO: Finish porting from facts.py.
    // TODO: Methods to read/write from/to DB.

    private long mId;
    private long mModelId;
//    private double mCreated;
//    private double mModified;
    private String mTags;
    private String mSpaceUntil; // Once obsolete, under libanki1.1 spaceUntil is reused as a html-stripped cache of the fields

//    private Model mModel;
    private TreeSet<Field> mFields;
    private Deck mDeck;


    // Generate fact object from its ID
    public Fact(Deck deck, long id) {
        mDeck = deck;
        fromDb(id);
        // TODO: load fields associated with this fact.
    }


    public Fact(Deck deck, Model model) {
        mDeck = deck;
//        mModel = model;
        mId = Utils.genID();
        if (model == null) {
            mModelId = deck.getCurrentModelId();
        } else {
            mModelId = model.getId();
        }
        TreeMap<Long, FieldModel> mFieldModels = new TreeMap<Long, FieldModel>();
        FieldModel.fromDb(deck, mModelId, mFieldModels);
        mFields = new TreeSet<Field>(new FieldOrdinalComparator());
        for (Entry<Long, FieldModel> entry : mFieldModels.entrySet()) {
            mFields.add(new Field(mId, entry.getValue()));
        }
    }


    /**
     * @return the mId
     */
    public long getId() {
        return mId;
    }


    /**
     * @return the mTags
     */
    public String getTags() {
        return mTags;
    }


    /**
     * @param tags the tags to set
     */
    public void setTags(String tags) {
        mTags = tags;
    }


    /**
     * @return the mModelId
     */
    public long getModelId() {
        return mModelId;
    }


    /**
     * @return the fields
     */
    public TreeSet<Field> getFields() {
        return mFields;
    }


    private boolean fromDb(long id) {
        mId = id;
        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath());
        Cursor cursor = null;

        try {
            cursor = ankiDB.getDatabase().rawQuery(""SELECT id, modelId, created, modified, tags, spaceUntil ""
                    + ""FROM facts "" + ""WHERE id = "" + id, null);
            if (!cursor.moveToFirst()) {
                Log.w(AnkiDroidApp.TAG, ""Fact.java (constructor): No result from query."");
                return false;
            }

            mId = cursor.getLong(0);
            mModelId = cursor.getLong(1);
//            mCreated = cursor.getDouble(2);
//            mModified = cursor.getDouble(3);
            mTags = cursor.getString(4);
            mSpaceUntil = cursor.getString(5);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        Cursor fieldsCursor = null;
        try {
            fieldsCursor = ankiDB.getDatabase().rawQuery(""SELECT id, factId, fieldModelId, value "" + ""FROM fields ""
                    + ""WHERE factId = "" + id, null);

            mFields = new TreeSet<Field>(new FieldOrdinalComparator());
            while (fieldsCursor.moveToNext()) {
                long fieldId = fieldsCursor.getLong(0);
                long fieldModelId = fieldsCursor.getLong(2);
                String fieldValue = fieldsCursor.getString(3);

                Cursor fieldModelCursor = null;
                FieldModel currentFieldModel = null;
                try {
                    // Get the field model for this field
                    fieldModelCursor = ankiDB.getDatabase().rawQuery(""SELECT id, ordinal, modelId, name, description ""
                            + ""FROM fieldModels "" + ""WHERE id = "" + fieldModelId, null);

                    fieldModelCursor.moveToFirst();
                    currentFieldModel = new FieldModel(fieldModelCursor.getLong(0), fieldModelCursor.getInt(1),
                            fieldModelCursor.getLong(2), fieldModelCursor.getString(3), fieldModelCursor.getString(4));
                } finally {
                    if (fieldModelCursor != null) {
                        fieldModelCursor.close();
                    }
                }
                mFields.add(new Field(fieldId, id, currentFieldModel, fieldValue));
            }
        } finally {
            if (fieldsCursor != null) {
                fieldsCursor.close();
            }
        }
        // Read Fields
        return true;
    }


    public void toDb() {
        double now = Utils.now();

        // update facts table
        ContentValues updateValues = new ContentValues();
        updateValues.put(""modified"", now);
        updateValues.put(""tags"", mTags);
        updateValues.put(""spaceUntil"", mSpaceUntil);
        AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).update(mDeck, ""facts"", updateValues, ""id = ?"",
                new String[] { """" + mId });

        // update fields table
        for (Field f : mFields) {
            updateValues = new ContentValues();
            updateValues.put(""value"", f.mValue);
            AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).update(mDeck, ""fields"", updateValues, ""id = ?"",
                    new String[] { """" + f.mFieldId });
        }
    }


    public String getFieldValue(String fieldModelName) {
        for (Field f : mFields) {
            if (f.mFieldModel.getName().equals(fieldModelName)) {
                return f.mValue;
            }
        }
        return null;
    }


    public long getFieldModelId(String fieldModelName) {
        for (Field f : mFields) {
            if (f.mFieldModel.getName().equals(fieldModelName)) {
                return f.mFieldModel.getId();
            }
        }
        return 0;
    }


    public LinkedList<Card> getUpdatedRelatedCards() {
        // TODO return instances of each card that is related to this fact
        LinkedList<Card> returnList = new LinkedList<Card>();

        Cursor cardsCursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                ""SELECT id, factId FROM cards "" + ""WHERE factId = "" + mId, null);

        while (cardsCursor.moveToNext()) {
            Card newCard = new Card(mDeck);
            newCard.fromDB(cardsCursor.getLong(0));
            newCard.loadTags();
            HashMap<String, String> newQA = CardModel.formatQA(this, newCard.getCardModel(), newCard.splitTags());
            newCard.setQuestion(newQA.get(""question""));
            newCard.setAnswer(newQA.get(""answer""));

            returnList.add(newCard);
        }
        if (cardsCursor != null) {
            cardsCursor.close();
        }

        return returnList;
    }


    public void setModified() {
        setModified(false, null, true);
    }
    public void setModified(boolean textChanged) {
        setModified(textChanged, null, true);
    }
    public void setModified(boolean textChanged, Deck deck) {
        setModified(textChanged, deck, true);
    }
    public void setModified(boolean textChanged, Deck deck, boolean media) {
//        mModified = Utils.now();
        if (textChanged) {
            assert (deck != null);
            mSpaceUntil = """";
            StringBuilder str = new StringBuilder(1024);
            for (Field f : getFields()) {
                str.append(f.getValue()).append("" "");
            }
            mSpaceUntil = str.toString();
            mSpaceUntil.substring(0, mSpaceUntil.length() - 1);
            mSpaceUntil = Utils.stripHTMLMedia(mSpaceUntil);
            // Log.d(AnkiDroidApp.TAG, ""spaceUntil = "" + mSpaceUntil);
            for (Card card : getUpdatedRelatedCards()) {
                card.setModified();
                card.toDB();
                // card.rebuildQA(deck);
            }
        }
    }


    public static final class FieldOrdinalComparator implements Comparator<Field> {
        @Override
        public int compare(Field object1, Field object2) {
            return object1.mOrdinal - object2.mOrdinal;
        }
    }

    public class Field {

        // TODO: Javadoc.
        // Methods for reading/writing from/to DB.

        // BEGIN SQL table entries
        private long mFieldId; // Primary key id, but named fieldId to no hide Fact.id
        private long mFactId; // Foreign key facts.id
        private long mFieldModelId; // Foreign key fieldModel.id
        private int mOrdinal;
        private String mValue;
        // END SQL table entries

        // BEGIN JOINed entries
        private FieldModel mFieldModel;
        // END JOINed entries

        // Backward reference
//        private Fact mFact;


        // for creating instances of existing fields
        public Field(long id, long factId, FieldModel fieldModel, String value) {
            mFieldId = id;
            mFactId = factId;
            mFieldModelId = fieldModel.getId();
            mValue = value;
            mFieldModel = fieldModel;
            mOrdinal = fieldModel.getOrdinal();
        }


        // For creating new fields
        public Field(long factId, FieldModel fieldModel) {
            if (fieldModel != null) {
                mFieldModel = fieldModel;
                mOrdinal = fieldModel.getOrdinal();
            }
            mFactId = factId;
            mFieldModelId = fieldModel.getId();
            mValue = """";
            mFieldId = Utils.genID();
        }


        /**
         * @return the FactId
         */
        public long getFactId() {
            return mFactId;
        }


        /**
         * @return the FieldModelId
         */
        public long getFieldModelId() {
            return mFieldModelId;
        }


        /**
         * @return the Ordinal
         */
        public int getOrdinal() {
            return mOrdinal;
        }


        /**
         * @param value the value to set
         */
        public void setValue(String value) {
            mValue = value;
        }


        /**
         * @return the value
         */
        public String getValue() {
            return mValue;
        }


        /**
         * @return the Field's Id
         */
        public long getId() {
            return mFieldId;
        }


        /**
         * @return the fieldModel
         */
        public FieldModel getFieldModel() {
            return mFieldModel;
        }
    }
}
",True,63,63,0,0,4,30
21,com.ichi2.anki.About.java,"/***************************************************************************************
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import com.ichi2.themes.Themes;

import android.app.Activity;
import android.content.res.Resources;
import android.os.Bundle;
import android.webkit.WebView;

/**
 * Shows an about box, which is a small HTML page.
 */

public class About extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);
    	Resources res = getResources();

        setTitle(getAboutTitle());

        setContentView(R.layout.about);

        WebView webview = (WebView) findViewById(R.id.about);
        webview.setBackgroundColor(res.getColor(Themes.getBackgroundColor()));        	

	String[] content = res.getStringArray(R.array.about_content);
	StringBuilder sb = new StringBuilder();
	sb.append(""<html><body>"");
	sb.append(String.format(content[0], res.getString(R.string.app_name), res.getString(R.string.link_anki))).append(""<br/><br/>"");
	sb.append(String.format(content[1], res.getString(R.string.link_issue_tracker), res.getString(R.string.link_wiki), res.getString(R.string.link_forum))).append(""<br/><br/>"");
	sb.append(String.format(content[2], res.getString(R.string.link_wikipedia_open_source), res.getString(R.string.link_contribution), res.getString(R.string.link_contribution_contributors))).append("" "");
	sb.append(String.format(content[3], res.getString(R.string.link_translation), res.getString(R.string.link_donation))).append(""<br/><br/>"");
	sb.append(String.format(content[4], res.getString(R.string.licence_wiki), res.getString(R.string.link_source))).append(""<br/><br/>"");
	sb.append(""</body></html>"");
        webview.loadDataWithBaseURL("""", sb.toString(), ""text/html"", ""utf-8"", null);
    }


    private String getAboutTitle() {
        StringBuilder appName = new StringBuilder();

        appName.append(""About "");
        appName.append(AnkiDroidApp.getPkgName());
        appName.append("" v"");
        appName.append(AnkiDroidApp.getPkgVersion());
        return appName.toString();
    }
}
",False,22,64,0,0,5,26
22,com.ichi2.anki.Lookup.java,"package com.ichi2.anki;

import com.ichi2.themes.StyledDialog;
import com.tomgibara.android.veecheck.util.PrefSettings;

import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.net.Uri;
import android.util.Log;

public class Lookup {

	/**
     * Searches
     */
    private static final int DICTIONARY_AEDICT = 0;
    private static final int DICTIONARY_EIJIRO_WEB = 1; // japanese web dictionary
    private static final int DICTIONARY_LEO_WEB = 2;    // German web dictionary for English, French, Spanish, Italian, Chinese, Russian
    private static final int DICTIONARY_LEO_APP = 3;    // German web dictionary for English, French, Spanish, Italian, Chinese, Russian
    private static final int DICTIONARY_COLORDICT = 4;
    private static final int DICTIONARY_FORA = 5;
    private static final int DICTIONARY_NCIKU_WEB = 6;  // chinese web dictionary

    private static Context mContext;
    private static boolean mIsDictionaryAvailable;
    private static String mDictionaryAction;
    private static int mDictionary;
    private static String mLookupText;
    private static String mDeckFilename;
    private static Card mCurrentCard;


	public static boolean initialize(Context context, String deckFilename) {
		mContext = context;
		mDeckFilename = deckFilename;
        int customDictionary = MetaDB.getLookupDictionary(context, mDeckFilename);
        if (customDictionary != -1) {
        	mDictionary = customDictionary;
        } else {
        	SharedPreferences preferences = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext());
            mDictionary = Integer.parseInt( preferences.getString(""dictionary"", Integer.toString(DICTIONARY_COLORDICT)));
        }
        switch (mDictionary) {
        	case DICTIONARY_AEDICT:
        		mDictionaryAction = ""sk.baka.aedict.action.ACTION_SEARCH_EDICT"";
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
        		break;
            case DICTIONARY_LEO_WEB:
            case DICTIONARY_NCIKU_WEB:
            case DICTIONARY_EIJIRO_WEB:
                mDictionaryAction = ""android.intent.action.VIEW"";
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
                break;
            case DICTIONARY_LEO_APP:
                mDictionaryAction = ""android.intent.action.SEND"";                   
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction, new ComponentName(""org.leo.android.dict"", ""org.leo.android.dict.LeoDict""));
                break;
            case DICTIONARY_COLORDICT:
                mDictionaryAction = ""colordict.intent.action.SEARCH"";                   
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
                break;
            case DICTIONARY_FORA:
                mDictionaryAction = ""com.ngc.fora.action.LOOKUP"";                   
                mIsDictionaryAvailable = Utils.isIntentAvailable(mContext, mDictionaryAction);
                break;
            default:
                mIsDictionaryAvailable = false;
                break;
        }
        // Log.i(AnkiDroidApp.TAG, ""Is intent available = "" + mIsDictionaryAvailable);
        return mIsDictionaryAvailable;
	}


	public static boolean lookUp(String text, Card card) {
		mCurrentCard = card;
		// clear text from leading and closing dots, commas, brackets etc.
		text = text.trim().replaceAll(""[,;:\\s\\(\\[\\)\\]\\.]*$"", """").replaceAll(""^[,;:\\s\\(\\[\\)\\]\\.]*"", """");
		switch (mDictionary) {
    	case DICTIONARY_AEDICT:
    		Intent aedictSearchIntent = new Intent(mDictionaryAction);
    		aedictSearchIntent.putExtra(""kanjis"", text);
    		mContext.startActivity(aedictSearchIntent);
            return true;
    	case DICTIONARY_LEO_WEB:
        case DICTIONARY_LEO_APP:
        	mLookupText = text;
    		// localisation is needless here since leo.org translates only into or out of German 
    		final CharSequence[] itemValues = {""en"", ""fr"", ""es"", ""it"", ""ch"", ""ru""};
                    String language = getLanguage(MetaDB.LANGUAGES_QA_UNDEFINED);
    		if (language.length() > 0) {
        		for (int i = 0; i < itemValues.length; i++) {
            		if (language.equals(itemValues[i])) {
            			lookupLeo(language, mLookupText);
            			mLookupText = """";
            			return true;
            		}
        		}
    		}
    		final String[] items = {""Englisch"", ""Französisch"", ""Spanisch"", ""Italienisch"", ""Chinesisch"", ""Russisch""};
    		StyledDialog.Builder builder = new StyledDialog.Builder(mContext);
    		builder.setTitle(""\"""" + mLookupText + ""\"" nachschlagen"");
    		builder.setItems(items, new DialogInterface.OnClickListener() {
    			public void onClick(DialogInterface dialog, int item) {
    				String language = itemValues[item].toString();
                    storeLanguage(language, MetaDB.LANGUAGES_QA_UNDEFINED);
        			lookupLeo(language, mLookupText);
        			mLookupText = """";
    			}
    		});
    		StyledDialog alert = builder.create();
    		alert.show();
            return true;
    	case DICTIONARY_COLORDICT:
    		Intent colordictSearchIntent = new Intent(mDictionaryAction);
    		colordictSearchIntent.putExtra(""EXTRA_QUERY"", text);
    		mContext.startActivity(colordictSearchIntent);
            return true;
    	case DICTIONARY_FORA:
    		Intent foraSearchIntent = new Intent(mDictionaryAction);
    		foraSearchIntent.putExtra(""HEADWORD"", text.trim());
    		mContext.startActivity(foraSearchIntent);
            return true;
    	case DICTIONARY_NCIKU_WEB:
            Intent ncikuWebIntent = new Intent(mDictionaryAction, Uri.parse(""http://m.nciku.com/en/entry/?query="" + text));
            mContext.startActivity(ncikuWebIntent);
            return true;
    	case DICTIONARY_EIJIRO_WEB:
            Intent eijiroWebIntent = new Intent(mDictionaryAction, Uri.parse(""http://eow.alc.co.jp/"" + text));
            mContext.startActivity(eijiroWebIntent);
            return true;
		}
		return false;
	}


	private static void lookupLeo(String language, CharSequence text) {
		switch(mDictionary) {
		case DICTIONARY_LEO_WEB:
			Intent leoSearchIntent = new Intent(mDictionaryAction, Uri.parse(""http://pda.leo.org/?lp="" + language
				+ ""de&search="" + text));
			mContext.startActivity(leoSearchIntent);
			break;
		case DICTIONARY_LEO_APP:
			Intent leoAppSearchIntent = new Intent(mDictionaryAction);
			leoAppSearchIntent.putExtra(""org.leo.android.dict.DICTIONARY"", language + ""de"");
			leoAppSearchIntent.putExtra(Intent.EXTRA_TEXT, text);
			leoAppSearchIntent.setComponent(new ComponentName(""org.leo.android.dict"", ""org.leo.android.dict.LeoDict""));
			mContext.startActivity(leoAppSearchIntent);
			break;
		default:
		}
	}


	public static String getSearchStringTitle() {
		return String.format(mContext.getString(R.string.menu_search), mContext.getResources().getStringArray(R.array.dictionary_labels)[mDictionary]);
	}


	public static boolean isAvailable() {
		return mIsDictionaryAvailable;
	}


    private static String getLanguage(int questionAnswer) {
    	if (mCurrentCard == null) {
    		return """";
    	} else {
        	return MetaDB.getLanguage(mContext, mDeckFilename, Model.getModel(AnkiDroidApp.deck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer);    		
    	}
    }
    
    private static void storeLanguage(String language, int questionAnswer) {
    	if (mCurrentCard != null) {
        	MetaDB.storeLanguage(mContext, mDeckFilename,  Model.getModel(AnkiDroidApp.deck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId(), questionAnswer, language);    		
    	}
    }

}
",False,30,63,0,0,4,28
23,com.ichi2.anki.BroadcastMessages.java,"package com.ichi2.anki;

import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

import android.app.Activity;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Resources;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;
import android.view.WindowManager.BadTokenException;
import android.webkit.WebView;

public class BroadcastMessages {

	public static final String FILE_URL = ""https://ankidroid.googlecode.com/files/broadcastMessages.xml"";

	public static final String NUM = ""Num"";
	public static final String MIN_VERSION = ""MinVer"";
	public static final String MAX_VERSION = ""MaxVer"";
	public static final String TITLE = ""Title"";
	public static final String TEXT = ""Text"";
	public static final String URL = ""Url"";

	private static StyledDialog mDialog;

	private static final int TIMEOUT = 30000;


	public static void init(Context context, long lastTimeOpened) {
		// Log.d(AnkiDroidApp.TAG, ""BroadcastMessages: init"");
		// retrieve messages on first start of the day
		if (Utils.isNewDay(lastTimeOpened)) {
			PrefSettings.getSharedPrefs(context).edit().putBoolean(""showBroadcastMessageToday"", true).commit();
		}
	}


	public static void checkForNewMessages(Activity activity) {
		// Log.d(AnkiDroidApp.TAG, ""BroadcastMessages: checkForNewMessages"");
		SharedPreferences prefs = PrefSettings.getSharedPrefs(activity);
		// don't retrieve messages, if option in preferences is not set
		if (!prefs.getBoolean(""showBroadcastMessages"", true)) {
			return;
		}
		// don't proceed if messages were already shown today
		if (!prefs.getBoolean(""showBroadcastMessageToday"", true)) {
			// Log.d(AnkiDroidApp.TAG, ""BroadcastMessages: already shown today"");
			return;
		}
        AsyncTask<Activity,Void,Context> checkForNewMessage = new DownloadBroadcastMessage();
        checkForNewMessage.execute(activity);
	}


	private static int compareVersions(String ver1, String ver2) {
		// 1.0alpha4 --> 1.0.alpha.4
		String[] version1 = ver1.split(""\\."");
		String[] version2 = ver2.split(""\\."");
		for (int i = 0; i < Math.min(version1.length, version2.length); i++) {
			int com = 0;
			try {
				com = Integer.valueOf(version1[i]).compareTo(Integer.valueOf(version2[i]));
			} catch (NumberFormatException e) {
				String[] subVersion1 = version1[i].replaceAll(""([:alpha:])([:digit:])"", ""$1.$2"").replaceAll(""([:digit:])([:alpha:])"", ""$1.$2"").split(""\\."");
				String[] subVersion2 = version2[i].replaceAll(""([:alpha:])([:digit:])"", ""$1.$2"").replaceAll(""([:digit:])([:alpha:])"", ""$1.$2"").split(""\\."");
				for (int j = 0; j < Math.min(subVersion1.length, subVersion2.length); j++) {
					try {
						com = Integer.valueOf(subVersion1[j]).compareTo(Integer.valueOf(subVersion2[j]));
					} catch (NumberFormatException f) {
						com = subVersion1[j].compareToIgnoreCase(subVersion2[j]);
					}
					if (com != 0) {
						return com;
					}
				}
				if (subVersion1.length > subVersion2.length) {
					return -1;
				} else if (subVersion1.length < subVersion2.length) {
					return 1;
				}
			}
			if (com != 0) {
				return com;
			}
		}
		return 0;
	}


	public static void showDialog() {
		if (mDialog != null && mDialog.isShowing()) {
			// workaround for the dialog content not showing when starting AnkiDroid with Deckpicker and open then Studyoptions
			try {
				mDialog.dismiss();
				mDialog.show();
			} catch (BadTokenException e) {
				Log.e(AnkiDroidApp.TAG, ""Error on dismissing and showing new messages dialog: "" + e);
			} catch (IllegalArgumentException e) {
				Log.e(AnkiDroidApp.TAG, ""Error on dismissing and showing new messages dialog: "" + e);
			} catch (NullPointerException e) {
				Log.e(AnkiDroidApp.TAG, ""Error on dismissing and showing new messages dialog: "" + e);
			}
		}
	}


    private static class DownloadBroadcastMessage extends AsyncTask<Activity, Void, Context> {

    	private static int mNum;
    	private static String mMinVersion;
    	private static String mMaxVersion;
    	private static String mTitle;
    	private static String mText;
    	private static String mUrl;

    	private static Activity mActivity;

    	private static boolean mShowDialog = false;

        @Override
        protected Context doInBackground(Activity... params) {
            // Log.d(AnkiDroidApp.TAG, ""BroadcastMessage.DownloadBroadcastMessage.doInBackground()"");

            Activity activity = params[0];
            mActivity = activity;

    		SharedPreferences prefs = PrefSettings.getSharedPrefs(activity);
    		int lastNum = prefs.getInt(""lastMessageNum"", -1);
		if (lastNum == -1) {
			// first start of AnkiDroid ever (or at least of a version which supports broadcast messages).
			// do nothing yet but retrieve message the next time, AD is started
			prefs.edit().putInt(""lastMessageNum"", 0).commit();
			return activity;
		}
    		try {
        		// Log.i(AnkiDroidApp.TAG, ""BroadcastMessage: download file "" + FILE_URL);
    			URL fileUrl;
    			fileUrl = new URL(FILE_URL);
    			URLConnection conn = fileUrl.openConnection();
    			conn.setConnectTimeout(TIMEOUT);
    			conn.setReadTimeout(TIMEOUT);
    			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
    			DocumentBuilder db = dbf.newDocumentBuilder();
    			Document dom = db.parse(conn.getInputStream());
    			Element docEle = dom.getDocumentElement();
    			NodeList nl = docEle.getElementsByTagName(""Message"");
    			String currentVersion = AnkiDroidApp.getPkgVersion();
    			if(nl != null && nl.getLength() > 0) {
    				for(int i = 0 ; i < nl.getLength();i++) {
    					Element el = (Element)nl.item(i);

    					// get message number
    					mNum = Integer.parseInt(getXmlValue(el, NUM));
    					if (mNum <= lastNum) {
    			            		// Log.d(AnkiDroidApp.TAG, ""BroadcastMessage - message "" + mNum + "" already shown"");
    						continue;
    					}

    					// get message version info
    					mMinVersion = getXmlValue(el, MIN_VERSION);
    					if (mMinVersion != null && mMinVersion.length() > 0 && compareVersions(mMinVersion, currentVersion) > 0) {
        			            // Log.d(AnkiDroidApp.TAG, ""BroadcastMessage - too low AnkiDroid version ("" + currentVersion + ""), message "" + mNum + "" only for >= "" + mMinVersion);
        			            continue;
    					}
    					mMaxVersion = getXmlValue(el, MAX_VERSION);
    					if (mMaxVersion != null && mMaxVersion.length() > 0 && compareVersions(mMaxVersion, currentVersion) < 0) {
        			            // Log.d(AnkiDroidApp.TAG, ""BroadcastMessage - too high AnkiDroid version ("" + currentVersion + ""), message "" + mNum + "" only for <= "" + mMaxVersion);
        			            continue;
    					}

    					// get Title, Text, Url
    					mTitle = getXmlValue(el, TITLE);
    					mText = getXmlValue(el, TEXT);
    					mUrl = getXmlValue(el, URL);
    					if (mText != null && mText.length() > 0) {
        	    				mShowDialog = true;
        	    				return activity;
    					}
    				}
    				// no valid message left
    				// Log.d(AnkiDroidApp.TAG, ""BroadcastMessages: disable messaging system for today"");
    				prefs.edit().putBoolean(""showBroadcastMessageToday"", false).commit();
    				mShowDialog = false;
    			}
    		} catch (IOException e) {
            	Log.e(AnkiDroidApp.TAG, ""DownloadBroadcastMessage: IOException on reading file "" + FILE_URL + "": "" + e);
				return activity;
        	} catch (NumberFormatException e) {
            	Log.e(AnkiDroidApp.TAG, ""DownloadBroadcastMessage: Number of file "" + FILE_URL + "" could not be read: "" + e);
				return activity;
        	}catch(ParserConfigurationException e) {
            	Log.e(AnkiDroidApp.TAG, ""DownloadBroadcastMessage: ParserConfigurationException: "" + e);
				return activity;
    		}catch(SAXException e) {
            	Log.e(AnkiDroidApp.TAG, ""DownloadBroadcastMessage: SAXException: "" + e);
				return activity;
        	}
            return activity;
        }


        @Override
        protected void onPostExecute(Context context) {
            // Log.d(AnkiDroidApp.TAG, ""BroadcastMessage.DownloadBroadcastMessage.onPostExecute()"");
            if (!mShowDialog) {
            	return;
            }
	    	StyledDialog.Builder builder = new StyledDialog.Builder(context);
	    	Resources res = context.getResources();
	    	if (mText != null && mText.length() > 0) {
		        WebView view = new WebView(context);
		        view.setBackgroundColor(res.getColor(Themes.getDialogBackgroundColor()));
		        view.loadDataWithBaseURL("""", ""<html><body text=\""#FFFFFF\"" link=\""#E37068\"" alink=\""#E37068\"" vlink=\""#E37068\"">"" + mText + ""<br></body></html>"", ""text/html"", ""UTF-8"", """");
		        builder.setView(view, true);
	    		builder.setCancelable(true);
	    		builder.setNegativeButton(res.getString(R.string.close),  new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
	    					setMessageRead(mActivity, mNum);
	    			        BroadcastMessages.checkForNewMessages(mActivity);
						}
					});
	    	} else {
				return;
	    	}
    		if (mTitle != null && mTitle.length() > 0) {
    			builder.setTitle(mTitle);
    		}
    		if (mUrl != null && mUrl.length() > 0) {
    			builder.setPositiveButton(mUrl.substring(mUrl.length() - 4).equals("".apk"") ? res.getString(R.string.download) : res.getString(R.string.visit), new DialogInterface.OnClickListener() {
    				@Override
    				public void onClick(DialogInterface dialog, int which) {
    					setMessageRead(mActivity, mNum);
    					String action = ""android.intent.action.VIEW"";
    					if (Utils.isIntentAvailable(mActivity, action)) {
    						Intent i = new Intent(action, Uri.parse(mUrl));
    						mActivity.startActivity(i);
    					}
    				}
    			});
    			builder.setNeutralButton(res.getString(R.string.later), null);
    		}
    		try {
    			mDialog = builder.create();
    			// Log.d(AnkiDroidApp.TAG, ""BroadcastMessages: show dialog"");
    			mDialog.setOwnerActivity(mActivity);
    			mDialog.show();
    		} catch (BadTokenException e) {
                Log.e(AnkiDroidApp.TAG, ""BroadcastMessage - BadTokenException on showing dialog: "" + e);
    		}
        }
    }


    private static void setMessageRead(Context context, int num) {
		Editor editor = PrefSettings.getSharedPrefs(context).edit();
		// Log.d(AnkiDroidApp.TAG, ""BroadcastMessages: set message "" + num + "" as read"");
		editor.putInt(""lastMessageNum"", num);
		editor.commit();
    }


    private static String getXmlValue(Element e, String tag) {
    	String text = null;
    	NodeList list = e.getElementsByTagName(tag);
    	if (list != null && list.getLength() > 0) {
    		Element element = (Element) list.item(0);
    		text = element.getFirstChild().getNodeValue();
    	}
    	return text;
    }
}

",True,47,63,0,0,5,26
24,com.ichi2.anki.DeckTask.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;

import com.ichi2.anki.DeckPicker.AnkiFilter;
import com.tomgibara.android.veecheck.util.PrefSettings;

import android.content.Context;
import android.content.res.Resources;
import android.database.CursorIndexOutOfBoundsException;
import android.database.SQLException;
import android.database.sqlite.SQLiteDiskIOException;
import android.database.sqlite.SQLiteException;
import android.os.AsyncTask;
import android.util.Log;

/**
 * Loading in the background, so that AnkiDroid does not look like frozen.
 */
public class DeckTask extends AsyncTask<DeckTask.TaskData, DeckTask.TaskData, DeckTask.TaskData> {

    public static final int TASK_TYPE_LOAD_DECK = 0;
    public static final int TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS = 1;
    public static final int TASK_TYPE_SAVE_DECK = 2;
    public static final int TASK_TYPE_ANSWER_CARD = 3;
    public static final int TASK_TYPE_SUSPEND_CARD = 4;
    public static final int TASK_TYPE_MARK_CARD = 5;
    public static final int TASK_TYPE_ADD_FACT = 6;
    public static final int TASK_TYPE_UPDATE_FACT = 7;
    public static final int TASK_TYPE_UNDO = 8;
    public static final int TASK_TYPE_REDO = 9;
    public static final int TASK_TYPE_LOAD_CARDS = 10;
    public static final int TASK_TYPE_BURY_CARD = 11;
    public static final int TASK_TYPE_DELETE_CARD = 12;
    public static final int TASK_TYPE_LOAD_STATISTICS = 13;
    public static final int TASK_TYPE_OPTIMIZE_DECK = 14;
    public static final int TASK_TYPE_SET_ALL_DECKS_JOURNAL_MODE = 15;
    public static final int TASK_TYPE_CLOSE_DECK = 16;
    public static final int TASK_TYPE_DELETE_BACKUPS = 17;
    public static final int TASK_TYPE_RESTORE_DECK = 18;
    public static final int TASK_TYPE_SORT_CARDS = 19;
    public static final int TASK_TYPE_LOAD_TUTORIAL = 20;
    public static final int TASK_TYPE_REPAIR_DECK = 21;


    /**
     * Possible outputs trying to load a deck.
     */
    public static final int DECK_LOADED = 0;
    public static final int DECK_NOT_LOADED = 1;
    public static final int DECK_EMPTY = 2;
    public static final int TUTORIAL_NOT_CREATED = 3;

    private static DeckTask sInstance;
    private static DeckTask sOldInstance;

    private int mType;
    private TaskListener mListener;


    
    public static DeckTask launchDeckTask(int type, TaskListener listener, TaskData... params) {
        sOldInstance = sInstance;

        sInstance = new DeckTask();
        sInstance.mListener = listener;
        sInstance.mType = type;

        sInstance.execute(params);
        return sInstance;
    }


    /**
     * Block the current thread until the currently running DeckTask instance (if any) has finished.
     */
    public static void waitToFinish() {
        try {
            if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                sInstance.get();
            }
        } catch (Exception e) {
            return;
        }
    }


    public static void cancelTask() {
        try {
            if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                sInstance.cancel(true);
            }
        } catch (Exception e) {
            return;
        }
    }


    public static boolean taskIsRunning() {
        try {
            if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                return true;
            }
        } catch (Exception e) {
            return true;
        }
        return false;
    }


    @Override
    protected TaskData doInBackground(TaskData... params) {
        // Wait for previous thread (if any) to finish before continuing
        try {
            if (mType == TASK_TYPE_LOAD_DECK) {
	   			publishProgress(new TaskData(AnkiDroidApp.getInstance().getBaseContext().getResources().getString(R.string.finish_operation)));
            }
            if ((sOldInstance != null) && (sOldInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                sOldInstance.get();
            }
        } catch (Exception e) {
            Log.e(AnkiDroidApp.TAG,
                    ""doInBackground - Got exception while waiting for thread to finish: "" + e.getMessage());
        }

        switch (mType) {
            case TASK_TYPE_LOAD_DECK:
                return doInBackgroundLoadDeck(params);

            case TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS:
                TaskData taskData = doInBackgroundLoadDeck(params);
                if (taskData.mInteger == DECK_LOADED) {
                    taskData.mDeck.updateAllCards();
                    taskData.mCard = taskData.mDeck.getCurrentCard();
                }
                return taskData;

            case TASK_TYPE_SAVE_DECK:
                return doInBackgroundSaveDeck(params);

            case TASK_TYPE_ANSWER_CARD:
                return doInBackgroundAnswerCard(params);

            case TASK_TYPE_SUSPEND_CARD:
                return doInBackgroundSuspendCard(params);

            case TASK_TYPE_MARK_CARD:
                return doInBackgroundMarkCard(params);

            case TASK_TYPE_ADD_FACT:
                return doInBackgroundAddFact(params);

            case TASK_TYPE_UPDATE_FACT:
                return doInBackgroundUpdateFact(params);
                
            case TASK_TYPE_UNDO:
                return doInBackgroundUndo(params);                

            case TASK_TYPE_REDO:
                return doInBackgroundRedo(params);
                
            case TASK_TYPE_LOAD_CARDS:
                return doInBackgroundLoadCards(params);

            case TASK_TYPE_BURY_CARD:
                return doInBackgroundBuryCard(params);

            case TASK_TYPE_DELETE_CARD:
                return doInBackgroundDeleteCard(params);

            case TASK_TYPE_LOAD_STATISTICS:
                return doInBackgroundLoadStatistics(params);

            case TASK_TYPE_OPTIMIZE_DECK:
                return doInBackgroundOptimizeDeck(params);

            case TASK_TYPE_SET_ALL_DECKS_JOURNAL_MODE:
                return doInBackgroundSetJournalMode(params);
                
            case TASK_TYPE_CLOSE_DECK:
                return doInBackgroundCloseDeck(params);
                
            case TASK_TYPE_DELETE_BACKUPS:
                return doInBackgroundDeleteBackups();
                
            case TASK_TYPE_RESTORE_DECK:
                return doInBackgroundRestoreDeck(params);

            case TASK_TYPE_SORT_CARDS:
                return doInBackgroundSortCards(params);

            case TASK_TYPE_LOAD_TUTORIAL:
                return doInBackgroundLoadTutorial(params);

            case TASK_TYPE_REPAIR_DECK:
                return doInBackgroundRepairDeck(params);

            default:
                return null;
        }
    }


    @Override
    protected void onPreExecute() {
        mListener.onPreExecute();
    }


    @Override
    protected void onProgressUpdate(TaskData... values) {
        mListener.onProgressUpdate(values);
    }


    @Override
    protected void onPostExecute(TaskData result) {
        mListener.onPostExecute(result);
    }


    private TaskData doInBackgroundAddFact(TaskData[] params) {
        // Save the fact
        Deck deck = params[0].getDeck();
        Fact editFact = params[0].getFact();
        LinkedHashMap<Long, CardModel> cardModels = params[0].getCardModels();

        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
        ankiDB.getDatabase().beginTransaction();
        try {
        	publishProgress(new TaskData(deck.addFact(editFact, cardModels, false) != null));
            ankiDB.getDatabase().setTransactionSuccessful();
        } finally {
            ankiDB.getDatabase().endTransaction();
        }
        return null;
    }


    private TaskData doInBackgroundUpdateFact(TaskData[] params) {
        // Save the fact
        Deck deck = params[0].getDeck();
        Card editCard = params[0].getCard();
        Fact editFact = editCard.getFact();
        int showQuestion = params[0].getInt();

        try {
	        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
	        ankiDB.getDatabase().beginTransaction();
	        try {
	            // Start undo routine
	            String undoName = Deck.UNDO_TYPE_EDIT_CARD;
	            deck.setUndoStart(undoName, editCard.getId());

	            // Set modified also updates the text of cards and their modified flags
	            editFact.setModified(true, deck, false);
	            editFact.toDb();

	            deck.flushMod();

	            // Find all cards based on this fact and update them with the updateCard method.
	            // for (Card modifyCard : editFact.getUpdatedRelatedCards()) {
	            //     modifyCard.updateQAfields();
	            // }

	            // deck.reset();
	            deck.setUndoEnd(undoName);
	            if (showQuestion == Reviewer.UPDATE_CARD_NEW_CARD) {
	                publishProgress(new TaskData(showQuestion, null, deck.getCard()));
	            } else {
	                publishProgress(new TaskData(showQuestion, null, deck.cardFromId(editCard.getId())));        	
	            }

	        	ankiDB.getDatabase().setTransactionSuccessful();
	        } finally {
	            ankiDB.getDatabase().endTransaction();
	        }
		} catch (RuntimeException e) {
			Log.e(AnkiDroidApp.TAG, ""doInBackgroundUpdateFact - RuntimeException on updating fact: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundUpdateFact"");
			return new TaskData(false);
		}
        return new TaskData(true);
    }


    private TaskData doInBackgroundAnswerCard(TaskData... params) {
        Deck deck = params[0].getDeck();
        Card oldCard = params[0].getCard();
        int ease = params[0].getInt();
        Card newCard;
        try {
	        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
	        ankiDB.getDatabase().beginTransaction();
	        try {
	            if (oldCard != null) {
	                deck.answerCard(oldCard, ease);
	                // Log.i(AnkiDroidApp.TAG, ""leech flag: "" + oldCard.getLeechFlag());
	            }
	            newCard = deck.getCard();
	            if (oldCard != null) {
	                publishProgress(new TaskData(newCard, oldCard.getLeechFlag(), oldCard.getSuspendedFlag()));
	            } else {
	                publishProgress(new TaskData(newCard));
	            }
	            ankiDB.getDatabase().setTransactionSuccessful();
	        } finally {
	            ankiDB.getDatabase().endTransaction();
	        }
		} catch (RuntimeException e) {
			Log.e(AnkiDroidApp.TAG, ""doInBackgroundAnswerCard - RuntimeException on answering card: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundAnswerCard"");
			return new TaskData(false);
		}
        return new TaskData(true);
    }


    private TaskData doInBackgroundLoadDeck(TaskData... params) {
        String deckFilename = params[0].getString();
        Deck oldDeck = params[0].getDeck();

        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();
        if (oldDeck != null) {
        	publishProgress(new TaskData(res.getString(R.string.close_previous_deck)));
        	oldDeck.closeDeck(false);
        }
        int backupResult = BackupManager.RETURN_NULL;
        if (PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).getBoolean(""useBackup"", true)) {
        	publishProgress(new TaskData(res.getString(R.string.backup_deck)));
        	backupResult = BackupManager.backupDeck(deckFilename);
        }
        if (BackupManager.getFreeDiscSpace(deckFilename) < (StudyOptions.MIN_FREE_SPACE * 1024 * 1024)) {
        	backupResult = BackupManager.RETURN_LOW_SYSTEM_SPACE;
        }
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundLoadDeck - deckFilename = "" + deckFilename);

        // Log.i(AnkiDroidApp.TAG, ""loadDeck - SD card mounted and existent file -> Loading deck..."");
        try {
            // Open the right deck.
            Deck deck = Deck.openDeck(deckFilename);
            // Start by getting the first card and displaying it.
            // Card card = deck.getCard();
            // Log.i(AnkiDroidApp.TAG, ""Deck loaded!"");
            if (deck == null) {
                BackupManager.cleanUpAfterBackupCreation(false);
                return new TaskData(DECK_NOT_LOADED);
            }
            BackupManager.cleanUpAfterBackupCreation(true);
            if (deck.hasFinishScheduler()) {
            	deck.finishScheduler();
            }
            publishProgress(new TaskData(backupResult));
            return new TaskData(DECK_LOADED, deck, null);
		} catch (SQLException e) {
            // Log.i(AnkiDroidApp.TAG, ""The database "" + deckFilename + "" could not be opened = "" + e.getMessage());
                BackupManager.cleanUpAfterBackupCreation(false);
            return new TaskData(DECK_NOT_LOADED);
        } catch (CursorIndexOutOfBoundsException e) {
            // XXX: Where is this exception thrown?
            // Log.i(AnkiDroidApp.TAG, ""The deck has no cards = "" + e.getMessage());
            return new TaskData(DECK_EMPTY);
		} catch (RuntimeException e) {
            // Log.i(AnkiDroidApp.TAG, ""The database "" + deckFilename + "" could not be opened = "" + e.getMessage());
            return new TaskData(DECK_NOT_LOADED);
        }
    }


    private TaskData doInBackgroundSaveDeck(TaskData... params) {
    	Deck deck = params[0].getDeck();
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundSaveAndResetDeck"");
        if (deck != null) {
            try {
            	deck.commitToDB();
            	deck.updateCutoff();
            	if (deck.hasFinishScheduler()) {
            		deck.finishScheduler();
            	}
            	deck.reset();
            } catch (SQLiteDiskIOException e) {
            	Log.e(AnkiDroidApp.TAG, ""Error on saving deck in background: "" + e);
            }
        }
        return null;
    }


    private TaskData doInBackgroundSuspendCard(TaskData... params) {
        Deck deck = params[0].getDeck();
        Card oldCard = params[0].getCard();
        Card newCard = null;

        try {
            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
            ankiDB.getDatabase().beginTransaction();
            try {
                if (oldCard != null) {
                    String undoName = Deck.UNDO_TYPE_SUSPEND_CARD;
                    deck.setUndoStart(undoName, oldCard.getId());
                    if (oldCard.getSuspendedState()) {
                        oldCard.unsuspend();
                        newCard = oldCard;
                    } else {
                        oldCard.suspend();
                        newCard = deck.getCard();
                    }
                    deck.setUndoEnd(undoName);
                }
                
                publishProgress(new TaskData(newCard));
                ankiDB.getDatabase().setTransactionSuccessful();
            } finally {
                ankiDB.getDatabase().endTransaction();
            }
    	} catch (RuntimeException e) {
    		Log.e(AnkiDroidApp.TAG, ""doInBackgroundSuspendCard - RuntimeException on suspending card: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundSuspendCard"");
    		return new TaskData(false);
    	}
        return new TaskData(true);
    }
        	


    private TaskData doInBackgroundMarkCard(TaskData... params) {
        Deck deck = params[0].getDeck();
        Card currentCard = params[0].getCard();

        try {
            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
            ankiDB.getDatabase().beginTransaction();
            try {
                if (currentCard != null) {
                    String undoName = Deck.UNDO_TYPE_MARK_CARD;
                    deck.setUndoStart(undoName, currentCard.getId());
                	if (currentCard.isMarked()) {
                        deck.deleteTag(currentCard.getFactId(), Deck.TAG_MARKED);
                    } else {
                        deck.addTag(currentCard.getFactId(), Deck.TAG_MARKED);
                    }
                	deck.resetMarkedTagId();
                	deck.setUndoEnd(undoName);
                }

                publishProgress(new TaskData(currentCard));
                ankiDB.getDatabase().setTransactionSuccessful();
            } finally {
                ankiDB.getDatabase().endTransaction();
            }
    	} catch (RuntimeException e) {
    		Log.e(AnkiDroidApp.TAG, ""doInBackgroundMarkCard - RuntimeException on marking card: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundMarkCard"");
    		return new TaskData(false);
        }
		return new TaskData(true);
    }


    private TaskData doInBackgroundUndo(TaskData... params) {
        Deck deck = params[0].getDeck();
        Card newCard;
        long currentCardId = params[0].getLong();
        boolean inReview = params[0].getBoolean();
        long oldCardId = 0;
        String undoType = null;
        
        try {
            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
            ankiDB.getDatabase().beginTransaction();
            try {
            	oldCardId = deck.undo(currentCardId, inReview);
            	undoType = deck.getUndoType();
            	if (undoType == Deck.UNDO_TYPE_SUSPEND_CARD) {
            		oldCardId = currentCardId;
            	}
                newCard = deck.getCard();
                if (oldCardId != 0 && newCard != null && oldCardId != newCard.getId()) {
                	newCard = deck.cardFromId(oldCardId);
                }
                publishProgress(new TaskData(newCard));
                ankiDB.getDatabase().setTransactionSuccessful();
            } finally {
                ankiDB.getDatabase().endTransaction();
            }
    	} catch (RuntimeException e) {
    		Log.e(AnkiDroidApp.TAG, ""doInBackgroundUndo - RuntimeException on undoing: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundUndo"");
            return new TaskData(undoType, oldCardId, false);
        }
        return new TaskData(undoType, oldCardId, true);
    }


    private TaskData doInBackgroundRedo(TaskData... params) {
        Deck deck = params[0].getDeck();
        Card newCard;
        long currentCardId = params[0].getLong();
        boolean inReview = params[0].getBoolean();
        long oldCardId = 0;
        String undoType = null;

        try {
            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
            ankiDB.getDatabase().beginTransaction();
            try {
            	oldCardId = deck.redo(currentCardId, inReview);
                newCard = deck.getCard();
                if (oldCardId != 0 && newCard != null && oldCardId != newCard.getId()) {
                	newCard = deck.cardFromId(oldCardId);
                }
                publishProgress(new TaskData(newCard));
                ankiDB.getDatabase().setTransactionSuccessful();
            } finally {
                ankiDB.getDatabase().endTransaction();
            }
            undoType = deck.getUndoType();
            if (undoType == Deck.UNDO_TYPE_SUSPEND_CARD) {
            	undoType = ""redo suspend"";
            }
    	} catch (RuntimeException e) {
    		Log.e(AnkiDroidApp.TAG, ""doInBackgroundRedo - RuntimeException on redoing: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundRedo"");
            return new TaskData(undoType, oldCardId, false);
        }
        return new TaskData(undoType, oldCardId, true);
    }


    private TaskData doInBackgroundLoadCards(TaskData... params) {
        Deck deck = params[0].getDeck();
        int chunk = params[0].getInt();
    	// Log.i(AnkiDroidApp.TAG, ""doInBackgroundLoadCards"");
    	String startId = """";
    	while (true) {
    		ArrayList<HashMap<String, String>> cards = deck.getCards(chunk, startId);
    		if (cards.size() == 0) {
    			return null;	
    		} else {
               	publishProgress(new TaskData(cards));
               	startId = cards.get(cards.size() - 1).get(""id"");    			
    		}
    	}
    }


    private TaskData doInBackgroundDeleteCard(TaskData... params) {
        Deck deck = params[0].getDeck();
        Card card = params[0].getCard();
        Card newCard = null;
        Long id = 0l;
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundDeleteCard"");

        try {
            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
            ankiDB.getDatabase().beginTransaction();
            try {
                id = card.getId();
                card.delete();
                deck.reset();
                newCard = deck.getCard();
                publishProgress(new TaskData(newCard));
                ankiDB.getDatabase().setTransactionSuccessful();
            } finally {
                ankiDB.getDatabase().endTransaction();
            }
    	} catch (RuntimeException e) {
    		Log.e(AnkiDroidApp.TAG, ""doInBackgroundDeleteCard - RuntimeException on deleting card: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundDeleteCard"");
            return new TaskData(String.valueOf(id), 0, false);
    	}
        return new TaskData(String.valueOf(id), 0, true);
    }


    private TaskData doInBackgroundBuryCard(TaskData... params) {
        Deck deck = params[0].getDeck();
        Card card = params[0].getCard();
        Card newCard = null;
        Long id = 0l;
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundBuryCard"");

        try {
            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
            ankiDB.getDatabase().beginTransaction();
            try {
                id = card.getId();
                deck.buryFact(card.getFactId(), id);
                deck.reset();
                newCard = deck.getCard();
                publishProgress(new TaskData(newCard));
                ankiDB.getDatabase().setTransactionSuccessful();
            } finally {
                ankiDB.getDatabase().endTransaction();
            }
    	} catch (RuntimeException e) {
    		Log.e(AnkiDroidApp.TAG, ""doInBackgroundSuspendCard - RuntimeException on suspending card: "" + e);
			AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundBuryCard"");
            return new TaskData(String.valueOf(id), 0, false);
    	}
        return new TaskData(String.valueOf(id), 0, true);
    }


    private TaskData doInBackgroundLoadStatistics(TaskData... params) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundLoadStatistics"");
        int type = params[0].getType();
        int period = params[0].getInt();
        Context context = params[0].getContext();
        String[] deckList = params[0].getDeckList();;
        boolean result = false;

        Resources res = context.getResources();
        if (deckList.length == 1 && deckList[0].equals("""") && AnkiDroidApp.deck() != null) {
        	result = Statistics.refreshDeckStatistics(context, AnkiDroidApp.deck(), type, Integer.parseInt(res.getStringArray(R.array.statistics_period_values)[period]), res.getStringArray(R.array.statistics_type_labels)[type]);        	
        } else {
        	result = Statistics.refreshAllDeckStatistics(context, deckList, type, Integer.parseInt(res.getStringArray(R.array.statistics_period_values)[period]), res.getStringArray(R.array.statistics_type_labels)[type] + "" "" + res.getString(R.string.statistics_all_decks));        	
        }
       	publishProgress(new TaskData(result));
        return new TaskData(result);
    }


    private TaskData doInBackgroundOptimizeDeck(TaskData... params) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundOptimizeDeck"");
    	Deck deck = params[0].getDeck();
        long result = 0;
    	result = deck.optimizeDeck();
        return new TaskData(deck, result);
    }


    private TaskData doInBackgroundRepairDeck(TaskData... params) {
    	// Log.i(AnkiDroidApp.TAG, ""doInBackgroundRepairDeck"");
    	String deckPath = params[0].getString();
    	Deck currentDeck = AnkiDroidApp.deck();
    	if (currentDeck != null && currentDeck.getDeckPath().equals(deckPath)) {
    		doInBackgroundCloseDeck(new TaskData(currentDeck, 0));
    	}
    	return new TaskData(BackupManager.repairDeck(deckPath));
    }


    private TaskData doInBackgroundSetJournalMode(TaskData... params) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundSetJournalMode"");
        String path = params[0].getString();
        Deck currentDeck = params[0].getDeck();
        if (currentDeck != null) {
        	currentDeck.closeDeck(false);
        }

        int len = 0;
		File[] fileList;

		File dir = new File(path);
		fileList = dir.listFiles(new AnkiFilter());

		if (dir.exists() && dir.isDirectory() && fileList != null) {
			len = fileList.length;
		} else {
			return null;
		}

		if (len > 0 && fileList != null) {
			// Log.i(AnkiDroidApp.TAG, ""Set journal mode: number of anki files = "" + len);
			for (File file : fileList) {
				// on deck open, journal mode will be automatically set
				String filePath = file.getAbsolutePath();
				Deck deck = Deck.openDeck(filePath, false);
				if (deck != null) {
					// Log.i(AnkiDroidApp.TAG, ""Journal mode of file "" + filePath + "" set"");
					deck.closeDeck(false);					
				}
			}
		}
        return null;
    }

    
    private TaskData doInBackgroundCloseDeck(TaskData... params) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundCloseDeck"");
    	Deck deck = params[0].getDeck();

    	// wait for widget updating before closing db
    	WidgetStatus.waitToFinish();

    	if (deck != null) {
    		try {
    			deck.closeDeck(false);
    			// Log.i(AnkiDroidApp.TAG, ""doInBackgroundCloseDeck - Deck closed"");
    		} catch (SQLiteException e) {
    			Log.e(AnkiDroidApp.TAG, ""Error on closing deck: "" + e);
    		}
    	}
    	return null;
    }


    private TaskData doInBackgroundDeleteBackups() {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundDeleteBackups"");
    	return new TaskData(BackupManager.deleteAllBackups());
    }


    private TaskData doInBackgroundRestoreDeck(TaskData... params) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundRestoreDeck"");
        String[] paths = params[0].getDeckList();
    	return new TaskData(BackupManager.restoreDeckBackup(paths[0], paths[1]));
    }


    private TaskData doInBackgroundSortCards(TaskData... params) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundSortCards"");
		Collections.sort(params[0].getCards(), params[0].getComparator());
		return null;
    }


    private TaskData doInBackgroundLoadTutorial(TaskData... params) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundLoadTutorial"");
        Resources res = AnkiDroidApp.getInstance().getBaseContext().getResources();
        File sampleDeckFile = new File(params[0].getString());
    	publishProgress(new TaskData(res.getString(R.string.tutorial_load)));
    	AnkiDb ankiDB = null;
    	try{
    		// close open deck
    		Deck openDeck = AnkiDroidApp.deck();
    		if (openDeck != null) {
    			openDeck.closeDeck(false);
    			AnkiDroidApp.setDeck(null);
    		}
    		// delete any existing tutorial file
            if (!sampleDeckFile.exists()) {
            	sampleDeckFile.delete();
            }
    		// copy the empty deck from the assets to the SD card.
    		InputStream stream = res.getAssets().open(DeckCreator.EMPTY_DECK_NAME);
    		Utils.writeToFile(stream, sampleDeckFile.getAbsolutePath());
    		stream.close();
        	Deck.initializeEmptyDeck(sampleDeckFile.getAbsolutePath());
    		String[] questions = res.getStringArray(R.array.tutorial_questions);
    		String[] answers = res.getStringArray(R.array.tutorial_answers);
    		String[] sampleQuestions = res.getStringArray(R.array.tutorial_capitals_questions);
    		String[] sampleAnswers = res.getStringArray(R.array.tutorial_capitals_answers);
    		Deck deck = Deck.openDeck(sampleDeckFile.getAbsolutePath());
            ankiDB = AnkiDatabaseManager.getDatabase(deck.getDeckPath());
            ankiDB.getDatabase().beginTransaction();
            try {
            	CardModel cardModel = null;
            	int len = Math.min(questions.length, answers.length);
            	for (int i = 0; i < len + Math.min(sampleQuestions.length, sampleAnswers.length); i++) {
            		Fact fact = deck.newFact();
            		if (cardModel == null) {
            			cardModel = deck.activeCardModels(fact).entrySet().iterator().next().getValue();
            		}
            		int fidx = 0;
            		for (Fact.Field f : fact.getFields()) {
            			if (fidx == 0) {
            				f.setValue((i < len) ? questions[i] : sampleQuestions[i - len]);
            			} else if (fidx == 1) {
            				f.setValue((i < len) ? answers[i] : sampleAnswers[i - len]);
            			}
            			fidx++;
            		}
            		if (!deck.importFact(fact, cardModel)) {
            			sampleDeckFile.delete();
            			return new TaskData(TUTORIAL_NOT_CREATED);
            		}
            	}
            	deck.setSessionTimeLimit(0);
            	deck.flushMod();
            	deck.reset();
            	ankiDB.getDatabase().setTransactionSuccessful();
            } finally {
        		ankiDB.getDatabase().endTransaction();
        	}
        	AnkiDroidApp.setDeck(deck);
        	return new TaskData(DECK_LOADED, deck, null);
        } catch (IOException e) {
        	Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        	Log.e(AnkiDroidApp.TAG, ""Empty deck could not be copied to the sd card."");
        	sampleDeckFile.delete();
        	return new TaskData(TUTORIAL_NOT_CREATED);
    	} catch (RuntimeException e) {
        	Log.e(AnkiDroidApp.TAG, ""Error on creating tutorial deck: "" + e);
        	sampleDeckFile.delete();
        	return new TaskData(TUTORIAL_NOT_CREATED);
    	}
    }


    public static interface TaskListener {
        public void onPreExecute();


        public void onPostExecute(TaskData result);


        public void onProgressUpdate(TaskData... values);
    }

    public static class TaskData {
        private Deck mDeck;
        private Card mCard;
        private Fact mFact;
        private int mInteger;
        private String mMsg;
        private boolean previousCardLeech;     // answer card resulted in card marked as leech
        private boolean previousCardSuspended; // answer card resulted in card marked as leech and suspended
        private boolean mBool = false;
        private ArrayList<HashMap<String, String>> mCards;
        private long mLong;
        private Context mContext;
        private int mType;
        private String[] mDeckList;
        private LinkedHashMap<Long, CardModel> mCardModels;
        private Comparator<? super HashMap<String, String>> mComparator;


        public TaskData(int value, Deck deck, Card card) {
            this(value);
            mDeck = deck;
            mCard = card;
        }


        public TaskData(int value, Deck deck, long cardId, boolean bool) {
            this(value);
            mDeck = deck;
            mLong = cardId;
            mBool = bool;
        }


        public TaskData(Card card) {
            mCard = card;
            previousCardLeech = false;
            previousCardSuspended = false;
        }


        public TaskData(Context context, String[] deckList, int type, int period) {
            mContext = context;
            mDeckList = deckList;
            mType = type;
        	mInteger = period;
        }


        public TaskData(Deck deck, Fact fact, LinkedHashMap<Long, CardModel> cardModels) {
        	mDeck = deck;
        	mFact = fact;
        	mCardModels = cardModels;
        }


        public TaskData(ArrayList<HashMap<String, String>> cards) {
        	mCards = cards;
        }


        public TaskData(ArrayList<HashMap<String, String>> cards, Comparator<? super HashMap<String, String>> comparator) {
        	mCards = cards;
        	mComparator = comparator;
        }


        public TaskData(Card card, boolean markedLeech, boolean suspendedLeech) {
            mCard = card;
            previousCardLeech = markedLeech;
            previousCardSuspended = suspendedLeech;
        }


        public TaskData(Deck deck, String order) {
            mDeck = deck;
            mMsg = order;
        }

 
        public TaskData(Deck deck, int chunk) {
            mDeck = deck;
            mInteger = chunk;
        }

 
        public TaskData(Deck deck, long value) {
            mDeck = deck;
            mLong = value;
        }

 
        public TaskData(boolean bool) {
            mBool = bool;
        }

 
        public TaskData(int value) {
            mInteger = value;
        }


        public TaskData(String msg) {
            mMsg = msg;
        }


        public TaskData(String msg, long cardId, boolean bool) {
            mMsg = msg;
            mLong = cardId;
            mBool = bool;
        }


        public Deck getDeck() {
            return mDeck;
        }


        public ArrayList<HashMap<String, String>> getCards() {
        	return mCards;
        }


        public Comparator<? super HashMap<String, String>> getComparator() {
        	return mComparator;
        }


        public Card getCard() {
            return mCard;
        }


        public Fact getFact() {
            return mFact;
        }


        public long getLong() {
            return mLong;
        }


        public int getInt() {
            return mInteger;
        }


        public String getString() {
            return mMsg;
        }


        public boolean isPreviousCardLeech() {
            return previousCardLeech;
        }


        public boolean isPreviousCardSuspended() {
            return previousCardSuspended;
        }


        public boolean getBoolean() {
            return mBool;
        }


        public Context getContext() {
            return mContext;
        }


        public int getType() {
            return mType;
        }


        public LinkedHashMap<Long, CardModel> getCardModels() {
            return mCardModels;
        }


        public String[] getDeckList() {
            return mDeckList;
        }
    }

}
",True,70,67,2,2,3,39
25,com.ichi2.anki.Reviewer.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.ParseException;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.DialogInterface.OnCancelListener;
import android.content.pm.ActivityInfo;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.drawable.Drawable;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.media.AudioManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.SystemClock;
import android.os.Vibrator;
import android.text.ClipboardManager;
import android.text.SpannableString;
import android.text.style.UnderlineSpan;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.SubMenu;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.view.View.OnClickListener;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.DecelerateInterpolator;
import android.view.inputmethod.InputMethodManager;
import android.webkit.JsResult;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.widget.Button;
import android.widget.Chronometer;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.FrameLayout.LayoutParams;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anim.Animation3D;
import com.ichi2.anim.ViewAnimation;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.ichi2.utils.DiffEngine;
import com.ichi2.utils.RubyParser;
import com.tomgibara.android.veecheck.util.PrefSettings;

import org.amr.arabic.ArabicUtilities;

//zeemote imports
import com.zeemote.zc.event.ButtonEvent;
import com.zeemote.zc.event.IButtonListener;
import com.zeemote.zc.util.JoystickToButtonAdapter;

public class Reviewer extends Activity implements IButtonListener{
    /**
     * Result codes that are returned when this activity finishes.
     */
    public static final int RESULT_SESSION_COMPLETED = 1;
    public static final int RESULT_NO_MORE_CARDS = 2;
    public static final int RESULT_EDIT_CARD_RESET = 3;
    public static final int RESULT_ANSWERING_ERROR = 4;

    /**
     * Possible values for update card handler
     */
    public static final int UPDATE_CARD_NEW_CARD = 0;
    public static final int UPDATE_CARD_SHOW_QUESTION = 1;
    public static final int UPDATE_CARD_SHOW_ANSWER = 2;
    
    /**
     * Available options performed by other activities.
     */
    public static final int EDIT_CURRENT_CARD = 0;

    /** Constant for class attribute signaling answer */
    static final String ANSWER_CLASS = ""answer"";

    /** Constant for class attribute signaling question */
    static final String QUESTION_CLASS = ""question"";

    /** Max size of the font for dynamic calculation of font size */
    private static final int DYNAMIC_FONT_MAX_SIZE = 14;

    /** Min size of the font for dynamic calculation of font size */
    private static final int DYNAMIC_FONT_MIN_SIZE = 3;
    private static final int DYNAMIC_FONT_FACTOR = 5;

    private static final int TOTAL_WIDTH_PADDING = 10;

    /**
     * Menus
     */
    private static final int MENU_WHITEBOARD = 0;
    private static final int MENU_CLEAR_WHITEBOARD = 1;
    private static final int MENU_EDIT = 2;
    private static final int MENU_REMOVE = 3;
    private static final int MENU_REMOVE_BURY = 31;
    private static final int MENU_REMOVE_SUSPEND = 32;
    private static final int MENU_REMOVE_DELETE = 33;
    private static final int MENU_SEARCH = 4;
    private static final int MENU_MARK = 5;
    private static final int MENU_UNDO = 6;
    private static final int MENU_REDO = 7;

    /** Zeemote messages */
    private static final int MSG_ZEEMOTE_BUTTON_A = 0x110;
    private static final int MSG_ZEEMOTE_BUTTON_B = MSG_ZEEMOTE_BUTTON_A+1;
    private static final int MSG_ZEEMOTE_BUTTON_C = MSG_ZEEMOTE_BUTTON_A+2;
    private static final int MSG_ZEEMOTE_BUTTON_D = MSG_ZEEMOTE_BUTTON_A+3;
    private static final int MSG_ZEEMOTE_STICK_UP = MSG_ZEEMOTE_BUTTON_A+4;
    private static final int MSG_ZEEMOTE_STICK_DOWN = MSG_ZEEMOTE_BUTTON_A+5;
    private static final int MSG_ZEEMOTE_STICK_LEFT = MSG_ZEEMOTE_BUTTON_A+6;
    private static final int MSG_ZEEMOTE_STICK_RIGHT = MSG_ZEEMOTE_BUTTON_A+7;
    
    /** Regex pattern used in removing tags from text before diff */
    private static final Pattern sSpanPattern = Pattern.compile(""</?span[^>]*>"");
    private static final Pattern sBrPattern = Pattern.compile(""<br\\s?/?>"");

    /** Regex patterns used in identifying and fixing Hebrew words, so we can reverse them */
    private static final Pattern sHebrewPattern = Pattern.compile(
            // Two cases caught below:
            // Either a series of characters, starting from a hebrew character...
            ""([[\\u0591-\\u05F4][\\uFB1D-\\uFB4F]]"" +
            // ...followed by hebrew characters, punctuation, parenthesis, spaces, numbers or numerical symbols...
            ""[[\\u0591-\\u05F4][\\uFB1D-\\uFB4F],.?!;:\""'\\[\\](){}+\\-*/%=0-9\\s]*"" +
            // ...and ending with hebrew character, punctuation or numerical symbol
            ""[[\\u0591-\\u05F4][\\uFB1D-\\uFB4F],.?!;:0-9%])|"" +
            // or just a single Hebrew character
            ""([[\\u0591-\\u05F4][\\uFB1D-\\uFB4F]])"");
    private static final Pattern sHebrewVowelsPattern = Pattern.compile(
            ""[[\\u0591-\\u05BD][\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7]]"");
    // private static final Pattern sBracketsPattern = Pattern.compile(""[()\\[\\]{}]"");
    // private static final Pattern sNumeralsPattern = Pattern.compile(""[0-9][0-9%]+"");

    /** Hide Question In Answer choices */
    private static final int HQIA_DO_HIDE = 0;
    private static final int HQIA_DO_SHOW = 1;
    private static final int HQIA_CARD_MODEL = 2;

    private static Card sEditorCard; // To be assigned as the currentCard or a new card to be sent to and from editor

    private static boolean sDisplayAnswer =  false; // Indicate if ""show answer"" button has been pressed

    /** The percentage of the absolute font size specified in the deck. */
    private int mDisplayFontSize = CardModel.DEFAULT_FONT_SIZE_RATIO;
    
    /** The absolute CSS measurement units inclusive semicolon for pattern search */
    private static final String[] ABSOLUTE_CSS_UNITS = {""px;"", ""pt;"", ""in;"", ""cm;"", ""mm;"", ""pc;""};
    
    /** The relative CSS measurement units inclusive semicolon for pattern search */
    private static final String[] RELATIVE_CSS_UNITS = {""%;"", ""em;""};

    /**
     * Broadcast that informs us when the sd card is about to be unmounted
     */
    private BroadcastReceiver mUnmountReceiver = null;

    /**
     * Variables to hold preferences
     */
    private boolean mPrefTimer;
    private boolean mPrefWhiteboard;
    private boolean mPrefWriteAnswers;
    private boolean mPrefTextSelection;
    private boolean mInputWorkaround;
    private boolean mLongClickWorkaround;
    private boolean mPrefFullscreenReview;
    private boolean mshowNextReviewTime;
    private boolean mZoomEnabled;    
//    private boolean mZeemoteEnabled;    
    private boolean mPrefUseRubySupport; // Parse for ruby annotations
    private String mDeckFilename;
    private int mPrefHideQuestionInAnswer; // Hide the question when showing the answer
    private int mRelativeButtonSize;
    private boolean mDoubleScrolling;
    private boolean mScrollingButtons;
    private boolean mGesturesEnabled;
    private boolean mShakeEnabled = false;
    private int mShakeIntensity;
    private boolean mShakeActionStarted = false;
    private boolean mPrefFixHebrew; // Apply manual RTL for hebrew text - bug in Android WebView
    private boolean mPrefFixArabic;
    private boolean mSpeakText;
    private boolean mPlaySoundsAtStart;
    private boolean mInvertedColors = false;
    private int mCurrentBackgroundColor;
    private boolean mBlackWhiteboard = true;
    private boolean mSwapQA = false;
    private boolean mNightMode = false;
    private boolean mIsLastCard = false;
    private boolean mShowProgressBars;
    private boolean mPrefUseTimer;
    private boolean mShowAnimations = false;
    private String mLocale;

    private boolean mIsSelecting = false;
    private boolean mTouchStarted = false;
    private boolean mIsAnswering = false;

//    @SuppressWarnings(""unused"")
//    private boolean mUpdateNotifications; // TODO use Veecheck only if this is true

    private String mCardTemplate;
    
    private String mMediaDir;

    
    /**
     * Variables to hold layout objects that we need to update or handle events for
     */
    private View mMainLayout;
    private View mLookUpIcon;
    private FrameLayout mCardContainer;
    private WebView mCard;
    private WebView mNextCard;
    private FrameLayout mCardFrame;
    private FrameLayout mTouchLayer;
    private TextView mTextBarRed;
    private TextView mTextBarBlack;
    private TextView mTextBarBlue;
    private TextView mChosenAnswer;
    private Drawable[] mDefaultButtonDrawable;
    private LinearLayout mProgressBars;
    private View mSessionYesBar;
    private View mSessionProgressBar;
    private TextView mNext1;
    private TextView mNext2;
    private TextView mNext3;
    private TextView mNext4; 
    private Button mFlipCard;
    private EditText mAnswerField;
    private Button mEase1;
    private Button mEase2;
    private Button mEase3;
    private Button mEase4;
    private Chronometer mCardTimer;
    private Whiteboard mWhiteboard;
	private ClipboardManager mClipboard;
    private ProgressDialog mProgressDialog;

    private Card mCurrentCard;
    private int mCurrentEase;
    private long mSessionTimeLimit;
    private int mSessionCurrReps;
    private float mScaleInPercent;
    private boolean mShowWhiteboard = false;
    
    private int mNextTimeTextColor;
    private int mNextTimeTextRecomColor;
    private int mForegroundColor;
    private boolean mChangeBorderStyle;
    
    private int mButtonHeight = 0;
    
    private boolean mConfigurationChanged = false;
    private int mShowChosenAnswerLength = 2000;
    
	private boolean mShowCongrats = false;

    private int mStatisticBarsMax;
    private int mStatisticBarsHeight;

    private long mSavedTimer = 0;

    private boolean mRefreshWebview = false;
    private File[] mCustomFontFiles;
    private String mCustomDefaultFontCss;

	/** 
	 * Shake Detection
	 */
	private SensorManager mSensorManager;
	private float mAccel; // acceleration apart from gravity
	private float mAccelCurrent; // current acceleration including gravity
	private float mAccelLast; // last acceleration including gravity

	/**
     * Swipe Detection
     */    
 	private GestureDetector gestureDetector;
 	View.OnTouchListener gestureListener;

	/**
     * Gesture Allocation
     */
 	private int mGestureSwipeUp;
 	private int mGestureSwipeDown;
 	private int mGestureSwipeLeft;
 	private int mGestureSwipeRight;
 	private int mGestureShake;
 	private int mGestureDoubleTap;
 	private int mGestureTapLeft;
 	private int mGestureTapRight;
 	private int mGestureTapTop;
 	private int mGestureTapBottom;

 	private static final int GESTURE_NOTHING = 0;
 	private static final int GESTURE_ANSWER_EASE1 = 1;
 	private static final int GESTURE_ANSWER_EASE2 = 2;
 	private static final int GESTURE_ANSWER_EASE3 = 3;
 	private static final int GESTURE_ANSWER_EASE4 = 4;
 	private static final int GESTURE_ANSWER_RECOMMENDED = 5;
 	private static final int GESTURE_ANSWER_BETTER_THAN_RECOMMENDED = 6;
 	private static final int GESTURE_UNDO = 7;
 	private static final int GESTURE_REDO = 8;
 	private static final int GESTURE_EDIT = 9;
 	private static final int GESTURE_MARK = 10;
 	private static final int GESTURE_LOOKUP = 11;
 	private static final int GESTURE_BURY= 12;
 	private static final int GESTURE_SUSPEND = 13;
 	private static final int GESTURE_DELETE = 14;
 	private static final int GESTURE_CLEAR_WHITEBOARD = 15;
 	private static final int GESTURE_EXIT = 16;

 	private String mCardContent;
 	private String mBaseUrl;

 	private static final int ANIMATION_NO_ANIMATION = 0;
 	private static final int ANIMATION_TURN = 1;
 	private static final int ANIMATION_NEXT_CARD_FROM_RIGHT = 2;
 	private static final int ANIMATION_NEXT_CARD_FROM_LEFT = 3;
 	private static final int ANIMATION_SLIDE_OUT_TO_LEFT = 4;
 	private static final int ANIMATION_SLIDE_OUT_TO_RIGHT = 5;
 	private static final int ANIMATION_SLIDE_IN_FROM_RIGHT = 6;
 	private static final int ANIMATION_SLIDE_IN_FROM_LEFT = 7;

 	private int mNextAnimation = 0;
    private int mAnimationDurationTurn = 500;
    private int mAnimationDurationMove = 500;

    private int mFadeDuration = 300;

	private Method mSetScrollbarBarFading = null;

 	/**
 	 * Zeemote controller
 	 */
	protected JoystickToButtonAdapter adapter;

//    private int zEase;
    
    /**
     * The answer in the compare to field for the current card if answer should be given by learner.
     * Null if the CardLayout in the deck says do not type answer. See also Card.getComparedFieldAnswer().
    */
    private String comparedFieldAnswer = null;
    
    /** The class attribute of the comparedField for formatting */
    private String comparedFieldClass = null;


    // ----------------------------------------------------------------------------
    // LISTENERS
    // ----------------------------------------------------------------------------

    /**
     * From http://stackoverflow.com/questions/2317428/android-i-want-to-shake-it
     * Thilo Koehler
     */
 	private final SensorEventListener mSensorListener = new SensorEventListener() {
 	    public void onSensorChanged(SensorEvent se) {

 	      float x = se.values[0];
 	      float y = se.values[1];
 	      float z = se.values[2] / 2;
 	      mAccelLast = mAccelCurrent;
 	      mAccelCurrent = (float) Math.sqrt((double) (x*x + y*y + z*z));
 	      float delta = mAccelCurrent - mAccelLast;
 	      mAccel = mAccel * 0.9f + delta; // perform low-cut filter
 	      if (!mShakeActionStarted && mAccel >= (mShakeIntensity / 10)) {
 	    	  mShakeActionStarted = true;
 	    	  executeCommand(mGestureShake);
 	      }
 	    }

 	    public void onAccuracyChanged(Sensor sensor, int accuracy) {
 	    }
 	  };

 	  
    private Handler mHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            Sound.stopSounds();
            Sound.playSound((String) msg.obj, false);
        }
    };


    private final Handler longClickHandler = new Handler();
    private final Runnable longClickTestRunnable = new Runnable() {
        public void run() {
    		// Log.i(AnkiDroidApp.TAG, ""onEmulatedLongClick"");
        	Vibrator vibratorManager = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
            vibratorManager.vibrate(50);
            longClickHandler.postDelayed(startSelection, 300);
        }
    };
    private final Runnable startSelection = new Runnable() {
        public void run() {
            selectAndCopyText();
        }
    };


    private View.OnClickListener mCardStatisticsListener = new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            // Log.i(AnkiDroidApp.TAG, ""Show card statistics"");
            stopTimer();
			Themes.htmlOkDialog(Reviewer.this, getResources().getString(R.string.card_browser_card_details), mCurrentCard.getCardDetails(Reviewer.this, false), new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					restartTimer();
				}
			}, new OnCancelListener() {
				@Override
				public void onCancel(DialogInterface arg0) {
					restartTimer();
				}
			}).show();
        }
    };


    // Handler for the ""show answer"" button
    private View.OnClickListener mFlipCardListener = new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            // Log.i(AnkiDroidApp.TAG, ""Flip card changed:"");
            mTimeoutHandler.removeCallbacks(mShowAnswerTask);
            displayCardAnswer();
        }
    };


    private View.OnClickListener mSelectEaseHandler = new View.OnClickListener() {
        @Override
        public void onClick(View view) {
        	mTimeoutHandler.removeCallbacks(mShowQuestionTask);
        	if (mIsAnswering) {
        		return;
        	}
            switch (view.getId()) {
                case R.id.ease1:
                    answerCard(Card.EASE_FAILED);
                    break;
                case R.id.ease2:
                	answerCard(Card.EASE_HARD);
                    break;
                case R.id.ease3:
                	answerCard(Card.EASE_MID);
                    break;
                case R.id.ease4:
                	answerCard(Card.EASE_EASY);
                    break;
                default:
                	mCurrentEase = Card.EASE_NONE;
                    return;
            }
        }
    };


    private View.OnTouchListener mGestureListener = new View.OnTouchListener() {
        @Override
        public boolean onTouch(View v, MotionEvent event) {
        	if (mIsAnswering) {
        		return true;
        	}
            if (gestureDetector.onTouchEvent(event)) {
                return true;
            }
            if (mPrefTextSelection && !mLongClickWorkaround) {
            	switch (event.getAction()) {
            	case MotionEvent.ACTION_DOWN:
            		mTouchStarted = true;
            		longClickHandler.postDelayed(longClickTestRunnable, 800);
            		break;
            	case MotionEvent.ACTION_UP:
            	case MotionEvent.ACTION_MOVE:
                    if(mTouchStarted) {
                        longClickHandler.removeCallbacks(longClickTestRunnable);
                    	mTouchStarted = false;
                    }
            		break;
            	}
            }
            try {
                if (event != null) {
    	            mCard.dispatchTouchEvent(event);
                }            	
            } catch (NullPointerException e) {
            	Log.e(AnkiDroidApp.TAG, ""Error on dispatching touch event: "" + e);
            	if (mInputWorkaround) {
                	Log.e(AnkiDroidApp.TAG, ""Error on using InputWorkaround: "" + e + "" --> disabled"");
                	PrefSettings.getSharedPrefs(getBaseContext()).edit().putBoolean(""inputWorkaround"", false).commit();            		
                	finish();
            	}
            }
            return false;
        }
    };

    
    private View.OnLongClickListener mLongClickListener = new View.OnLongClickListener() {

    	@Override
    	public boolean onLongClick(View view) {
    		if (mIsSelecting) {
    			return false;
    		}
    		// Log.i(AnkiDroidApp.TAG, ""onLongClick"");
    		Vibrator vibratorManager = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
    		vibratorManager.vibrate(50);
            longClickHandler.postDelayed(startSelection, 300);
    		return true;
    	}
    };


    private DeckTask.TaskListener mMarkCardHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
        	Resources res = getResources();
            mProgressDialog = ProgressDialog.show(Reviewer.this, """", res.getString(R.string.saving_changes), true);
        }

        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            mCurrentCard = values[0].getCard();
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (!result.getBoolean()) {
            	// RuntimeException occured on marking cards
                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
                closeReviewer(true);
            }
            mProgressDialog.dismiss();
        }
    };

    private DeckTask.TaskListener mDismissCardHandler = new DeckTask.TaskListener() {
    	boolean mSessionComplete;
    	boolean mNoMoreCards;

        @Override
        public void onPreExecute() {
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        	boolean[] results = postAnswerCard(values);
        	mSessionComplete = results[0];
        	mNoMoreCards = results[1];
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (!result.getBoolean()) {
            	// RuntimeException occured on dismissing cards
                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
                closeReviewer(true);
                return;
            }
            // Check for no more cards before session complete. If they are both true,
            // no more cards will take precedence when returning to study options.
            if (mNoMoreCards) {
                Reviewer.this.setResult(RESULT_NO_MORE_CARDS);
                mShowCongrats = true;
                closeReviewer(true);
            } else if (mSessionComplete) {
                Reviewer.this.setResult(RESULT_SESSION_COMPLETED);
                closeReviewer(true);
            }
        }
    };

    private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
        	Resources res = getResources();
		try {
	        	mProgressDialog = ProgressDialog.show(Reviewer.this, """", res.getString(R.string.saving_changes), true);
		} catch (IllegalArgumentException e) {
			Log.e(AnkiDroidApp.TAG, ""Reviewer: Error on showing progress dialog: "" + e);
		}
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            mCurrentCard = values[0].getCard();
            int showQuestion = values[0].getInt();
            if (mPrefWhiteboard) {
                mWhiteboard.clear();
            }

            if (mPrefTimer) {
                mCardTimer.setBase(SystemClock.elapsedRealtime());
                mCardTimer.start();
            }
            if (showQuestion == UPDATE_CARD_SHOW_ANSWER) {
                displayCardAnswer();            	
            } else {
                displayCardQuestion();
            }
            try {
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
			mProgressDialog.dismiss();
                }
            } catch (IllegalArgumentException e) {
                Log.e(AnkiDroidApp.TAG, ""Reviewer: Error on dismissing progress dialog: "" + e);
                mProgressDialog = null;
            }
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (!result.getBoolean()) {
            	// RuntimeException occured on update cards
                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
                closeReviewer(true);
                return;
            }
            mShakeActionStarted = false;
            String str = result.getString();
            if (str != null) {
                if (str.equals(Deck.UNDO_TYPE_SUSPEND_CARD)) {
                	Themes.showThemedToast(Reviewer.this, getResources().getString(R.string.card_unsuspended), true);
                } else if (str.equals(""redo suspend"")) {
                	Themes.showThemedToast(Reviewer.this, getResources().getString(R.string.card_suspended), true);           	
                }            	
            }
        }
    };

    private DeckTask.TaskListener mAnswerCardHandler = new DeckTask.TaskListener() {
        private boolean mSessionComplete;
        private boolean mNoMoreCards;


        @Override
        public void onPreExecute() {
            Reviewer.this.setProgressBarIndeterminateVisibility(true);
            if (mPrefTimer) {
                mCardTimer.stop();
            }
            blockControls();
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        	boolean[] results = postAnswerCard(values);
        	mSessionComplete = results[0];
        	mNoMoreCards = results[1];
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
            if (!result.getBoolean()) {
            	// RuntimeException occured on answering cards
                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
                closeReviewer(true);
                return;
            }
            // Check for no more cards before session complete. If they are both true,
            // no more cards will take precedence when returning to study options.
            if (mNoMoreCards) {
                Reviewer.this.setResult(RESULT_NO_MORE_CARDS);
                mShowCongrats = true;
                closeReviewer(true);
            } else if (mSessionComplete) {
                Reviewer.this.setResult(RESULT_SESSION_COMPLETED);
                closeReviewer(true);
            }
        }
    };


    DeckTask.TaskListener mSaveAndResetDeckHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
        		mProgressDialog.setMessage(getResources().getString(R.string.saving_changes));
        	} else {
                mProgressDialog = ProgressDialog.show(Reviewer.this, """", getResources()
                        .getString(R.string.saving_changes), true);
        	}
        }
        @Override
        public void onPostExecute(DeckTask.TaskData result) {
        	if (mProgressDialog.isShowing()) {
                try {
                    mProgressDialog.dismiss();
                } catch (Exception e) {
                    Log.e(AnkiDroidApp.TAG, ""onPostExecute - Dialog dismiss Exception = "" + e.getMessage());
                }
            }
        	finish();
        	if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
        		if (mShowCongrats) {
        			ActivityTransitionAnimation.slide(Reviewer.this, ActivityTransitionAnimation.FADE);
        		} else {
        			ActivityTransitionAnimation.slide(Reviewer.this, ActivityTransitionAnimation.RIGHT);
        		}
        	}
        }
        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
            // Pass
        }
    };


    private Handler mTimerHandler = new Handler();

    private Runnable removeChosenAnswerText=new Runnable() {
    	public void run() {
    		mChosenAnswer.setText("""");
    		setDueMessage();
    	}
    };
    
    //Zeemote handler
	Handler ZeemoteHandler = new Handler() {
		public void handleMessage(Message msg){
			switch(msg.what){
			case MSG_ZEEMOTE_STICK_UP:
				if (sDisplayAnswer) {
   						answerCard(Card.EASE_EASY);
					} 			
				break;
			case MSG_ZEEMOTE_STICK_DOWN:
				if (sDisplayAnswer) {
   						answerCard(Card.EASE_FAILED);
					} 			
				break;
			case MSG_ZEEMOTE_STICK_LEFT:
				if (sDisplayAnswer) {
   						answerCard(Card.EASE_HARD);
					} 			
				break;
			case MSG_ZEEMOTE_STICK_RIGHT:
				if (sDisplayAnswer) {
   						answerCard(Card.EASE_MID);
					} 			
				break;
			case MSG_ZEEMOTE_BUTTON_A:
				if (!sDisplayAnswer) {
					try {
	                Sound.playSounds(Utils.stripHTML(getQuestion()), MetaDB.LANGUAGES_QA_QUESTION);
					}
					catch (Exception ex){
		        		Log.e(""Zeemote"",""Error on playing question audio: ""+ex.getMessage());
		        	}
	            } else {
	            	try {
	            	Sound.playSounds(Utils.stripHTML(getAnswer()), MetaDB.LANGUAGES_QA_ANSWER);
	            	}
					catch (Exception ex){
		        		Log.e(""Zeemote"",""Error on playing answer audio: ""+ex.getMessage());
		        	}
	            }
				break;
			case MSG_ZEEMOTE_BUTTON_B:
				closeReviewer(false);
				break;
			case MSG_ZEEMOTE_BUTTON_C:
				if (AnkiDroidApp.deck().undoAvailable()){
            	setNextCardAnimation(true);
            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));
				}
				break;
			case MSG_ZEEMOTE_BUTTON_D:
				if (!sDisplayAnswer) {
						displayCardAnswer(); 
					}				
				break;
			}
			super.handleMessage(msg);
		}
	};
	private int mWaitAnswerSecond;
	private int mWaitQuestionSecond;

    
    
    // ----------------------------------------------------------------------------
    // ANDROID METHODS
    // ----------------------------------------------------------------------------

    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);
        // Log.i(AnkiDroidApp.TAG, ""Reviewer - onCreate"");

        mChangeBorderStyle = Themes.getTheme() != Themes.THEME_BLUE;

        // The hardware buttons should control the music volume while reviewing.
        setVolumeControlStream(AudioManager.STREAM_MUSIC);

        // Make sure a deck is loaded before continuing.
        Deck deck = AnkiDroidApp.deck();
        if (deck == null) {
            setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
			finish();
        } else {
            mMediaDir = setupMedia(deck);
            restorePreferences();

            deck.resetUndo();
            // Remove the status bar and title bar
            if (mPrefFullscreenReview) {
                getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
                        WindowManager.LayoutParams.FLAG_FULLSCREEN);
                // Do not hide the title bar in Honeycomb, since it contains the action bar.
                if (Integer.valueOf(android.os.Build.VERSION.SDK) < 11) {
                    requestWindowFeature(Window.FEATURE_NO_TITLE);
                }
            }

            requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

            registerExternalStorageListener();

            if (mNightMode) {
            	mCurrentBackgroundColor = Themes.getNightModeCardBackground(this);
            } else {
            	mCurrentBackgroundColor = Color.WHITE;
            }

            try {
            	mSetScrollbarBarFading = WebView.class.getMethod(""setScrollbarFadingEnabled"", boolean.class);
            } catch (Throwable e) {
            	// Log.i(AnkiDroidApp.TAG, ""setScrollbarFadingEnabled could not be found due to a too low Android version (< 2.1)"");
            }

		mRefreshWebview = getRefreshWebview();

            initLayout(R.layout.flashcard);
            if (mPrefTextSelection) {
                clipboardSetText("""");
                Lookup.initialize(this, mDeckFilename);
            }

            // Load the template for the card and set on it the available width for images
            try {
                mCardTemplate = Utils.convertStreamToString(getAssets().open(""card_template.html""));
                mCardTemplate = mCardTemplate.replaceFirst(""var availableWidth = \\d*;"", ""var availableWidth = ""
                        + getAvailableWidthInCard() + "";"");
            } catch (IOException e) {
                e.printStackTrace();
            }

            // Initialize session limits
            long timelimit = deck.getSessionTimeLimit() * 1000;
            // Log.i(AnkiDroidApp.TAG, ""SessionTimeLimit: "" + timelimit + "" ms."");
            mSessionTimeLimit = System.currentTimeMillis() + timelimit;
            mSessionCurrReps = 0;

            // Initialize text-to-speech. This is an asynchronous operation.
            if (mSpeakText && Integer.valueOf(android.os.Build.VERSION.SDK) > 3) {
            	ReadText.initializeTts(this, mDeckFilename);
            }

            // Get last whiteboard state
            if (mPrefWhiteboard && MetaDB.getWhiteboardState(this, mDeckFilename) == 1) {
            	mShowWhiteboard = true;
            	mWhiteboard.setVisibility(View.VISIBLE);
            }

            // Load the first card and start reviewing. Uses the answer card task to load a card, but since we send null
            // as the card to answer, no card will be answered.

            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
                    deck, null));
        }
    }


    // Saves deck each time Reviewer activity loses focus
    @Override
    protected void onPause() {
        super.onPause();
        // Log.i(AnkiDroidApp.TAG, ""Reviewer - onPause()"");

    	mTimeoutHandler.removeCallbacks(mShowAnswerTask);
    	mTimeoutHandler.removeCallbacks(mShowQuestionTask);
    	longClickHandler.removeCallbacks(longClickTestRunnable);
    	longClickHandler.removeCallbacks(startSelection);

        stopTimer();
        if (!isFinishing()) {
            // Save changes
            Deck deck = AnkiDroidApp.deck();
            if (deck != null) {
	            DeckTask.waitToFinish();
	            deck.commitToDB();
            }
            WidgetStatus.update(getBaseContext());
        }

        if (mShakeEnabled) {
            mSensorManager.unregisterListener(mSensorListener);    	  
        }

        Sound.stopSounds();

        if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){ 
        	// Log.d(""Zeemote"",""Removing listener in onPause"");
        	AnkiDroidApp.zeemoteController().removeButtonListener(this);
        	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
    		adapter.removeButtonListener(this);
    		adapter = null;
            getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        }
    }

    @Override
    protected void onResume() {
      super.onResume();
      if (AnkiDroidApp.deck() == null) {
    	  finish();
      }
      if (mShakeEnabled) {
          mSensorManager.registerListener(mSensorListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);    	  
      }
      restartTimer();
      if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){
    	  // Log.d(""Zeemote"",""Adding listener in onResume"");
    	  AnkiDroidApp.zeemoteController().addButtonListener(this);
      	  adapter = new JoystickToButtonAdapter();
      	  AnkiDroidApp.zeemoteController().addJoystickListener(adapter);
      	  adapter.addButtonListener(this);
      	  getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
      }
    }

    @Override
    protected void onStop() {
      if (mShakeEnabled) {
          mSensorManager.unregisterListener(mSensorListener);    	  
      }
      super.onStop();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // Log.i(AnkiDroidApp.TAG, ""Reviewer - onDestroy()"");
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
        }
        if (mSpeakText && Integer.valueOf(android.os.Build.VERSION.SDK) > 3) {
            ReadText.releaseTts();        	
        }
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)  {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
        	// Log.i(AnkiDroidApp.TAG, ""Reviewer - onBackPressed()"");
        	closeReviewer(false);
        	return true;
        }
         /** Enhancement 722: Hardware buttons for scrolling, I.Z. */
        if (keyCode == 92)  {
        	mCard.pageUp(false);
        	if (mDoubleScrolling)  {
        		mCard.pageUp(false);
        	}
        	return true;
        }
        if (keyCode == 93)  {
        	mCard.pageDown(false);
        	if (mDoubleScrolling)  {
        		mCard.pageDown(false);
        	}
        	return true;
        }
        if (mScrollingButtons && keyCode == 94)  {
        	mCard.pageUp(false);
        	if (mDoubleScrolling)  {
        		mCard.pageUp(false);
        	}
        	return true;
        }
        if (mScrollingButtons && keyCode == 95)  {
        	mCard.pageDown(false);
        	if (mDoubleScrolling)  {
        		mCard.pageDown(false);
        	}
        	return true;
        }

        return super.onKeyDown(keyCode, event);
    }


    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        setLanguage(mLocale);
        // Log.i(AnkiDroidApp.TAG, ""onConfigurationChanged"");

        mConfigurationChanged = true;

        long savedTimer = mCardTimer.getBase();
        CharSequence savedAnswerField = mAnswerField.getText();
        boolean cardVisible = mCardContainer.getVisibility() == View.VISIBLE;
        int lookupButtonVis = mLookUpIcon.getVisibility();

        // Reload layout
        initLayout(R.layout.flashcard);
        
       	if (mRelativeButtonSize != 100) {
       		mFlipCard.setHeight(mButtonHeight);
       		mEase1.setHeight(mButtonHeight);
       		mEase2.setHeight(mButtonHeight);
       		mEase3.setHeight(mButtonHeight);
       		mEase4.setHeight(mButtonHeight);        	
       	}

        // Modify the card template to indicate the new available width and refresh card
        mCardTemplate = mCardTemplate.replaceFirst(""var availableWidth = \\d*;"", ""var availableWidth = ""
                + getAvailableWidthInCard() + "";"");

        if (typeAnswer()) {
            mAnswerField.setText(savedAnswerField);
        }
        if (mPrefWhiteboard) {
            mWhiteboard.rotate();
        }
        if (mInvertedColors) {
            invertColors(true);
        }

        // If the card hasn't loaded yet, don't refresh it
        // Also skipping the counts (because we don't know which one to underline)
        // They will be updated when the card loads anyway
        if (mCurrentCard != null) {
        	if (cardVisible) {
                fillFlashcard(false);
                if (mPrefTimer) {
                    mCardTimer.setBase(savedTimer);
                    mCardTimer.start();
                }        		
        		if (sDisplayAnswer) {
        			updateForNewCard();
            	}
        	} else {
        		mCardContainer.setVisibility(View.INVISIBLE);
        		switchVisibility(mProgressBars, View.INVISIBLE);
        		switchVisibility(mCardTimer, View.INVISIBLE);
        	}
    		if (sDisplayAnswer) {
        		showEaseButtons();
        	}
        }
        mLookUpIcon.setVisibility(lookupButtonVis);
        mConfigurationChanged = false;
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuItem item;
        Resources res = getResources();
        if (mPrefWhiteboard) {
            if (mShowWhiteboard) {
                Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_WHITEBOARD, Menu.NONE,
                        R.string.hide_whiteboard, R.drawable.ic_menu_compose);
            } else {
                Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_WHITEBOARD, Menu.NONE,
                        R.string.show_whiteboard, R.drawable.ic_menu_compose);            	
            }
            Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_CLEAR_WHITEBOARD, Menu.NONE,
                    R.string.clear_whiteboard, R.drawable.ic_menu_clear_playlist);
        }
        Utils.addMenuItem(menu, Menu.NONE, MENU_EDIT, Menu.NONE, R.string.menu_edit_card,
                R.drawable.ic_menu_edit);

        SubMenu removeDeckSubMenu = menu.addSubMenu(Menu.NONE, MENU_REMOVE, Menu.NONE, R.string.menu_remove_card);
        removeDeckSubMenu.setIcon(R.drawable.ic_menu_stop);
        removeDeckSubMenu.add(Menu.NONE, MENU_REMOVE_BURY, Menu.NONE, R.string.menu_bury_card);
        removeDeckSubMenu.add(Menu.NONE, MENU_REMOVE_SUSPEND, Menu.NONE, R.string.menu_suspend_card);
        removeDeckSubMenu.add(Menu.NONE, MENU_REMOVE_DELETE, Menu.NONE, R.string.card_browser_delete_card);
        if (mPrefTextSelection) {
            item = menu.add(Menu.NONE, MENU_SEARCH, Menu.NONE, res.getString(R.string.menu_select));
            item.setIcon(R.drawable.ic_menu_search);
        }
        item = menu.add(Menu.NONE, MENU_MARK, Menu.NONE, R.string.menu_mark_card);
        Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_UNDO, Menu.NONE, R.string.undo,
                R.drawable.ic_menu_revert);
        Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_REDO, Menu.NONE, R.string.redo,
                R.drawable.ic_menu_redo);
        return true;
    }

    //These three methods use a deprecated API - they should be updated to possibly use its more modern version.
    private boolean clipboardHasText() {
        return mClipboard.hasText();
    }

    private void clipboardSetText(CharSequence text) {
        mClipboard.setText(text);
    }

    private CharSequence clipboardGetText() {
        return mClipboard.getText();
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        MenuItem item = menu.findItem(MENU_MARK);
        if (mCurrentCard == null){
        	return false;
        }
        if (mCurrentCard.isMarked()) {
            item.setTitle(R.string.menu_marked);
            item.setIcon(R.drawable.ic_menu_star_on);
        } else {
            item.setTitle(R.string.menu_mark_card);
            item.setIcon(R.drawable.ic_menu_star_off);
        }
        if (mPrefTextSelection) {
            item = menu.findItem(MENU_SEARCH);
            if (clipboardHasText()) {
            	item.setTitle(Lookup.getSearchStringTitle());
        		item.setEnabled(Lookup.isAvailable());
            } else {
            	item.setTitle(getResources().getString(R.string.menu_select));
        		item.setEnabled(true);
            }
        }
        if (mPrefFullscreenReview) {
            // Temporarily remove top bar to avoid annoying screen flickering
            mTextBarRed.setVisibility(View.GONE);
            mTextBarBlack.setVisibility(View.GONE);
            mTextBarBlue.setVisibility(View.GONE);
            mChosenAnswer.setVisibility(View.GONE);
            if (mPrefTimer) {
                mCardTimer.setVisibility(View.GONE);
            }
            if (mShowProgressBars) {
                mProgressBars.setVisibility(View.GONE);
            }

            getWindow().setFlags(0, WindowManager.LayoutParams.FLAG_FULLSCREEN);
        }
        menu.findItem(MENU_UNDO).setEnabled(AnkiDroidApp.deck().undoAvailable());
        menu.findItem(MENU_REDO).setEnabled(AnkiDroidApp.deck().redoAvailable());
        return true;
    }


    @Override
    public void onOptionsMenuClosed(Menu menu) {
        if (mPrefFullscreenReview) {
            // Restore top bar
            mTextBarRed.setVisibility(View.VISIBLE);
            mTextBarBlack.setVisibility(View.VISIBLE);
            mTextBarBlue.setVisibility(View.VISIBLE);
            mChosenAnswer.setVisibility(View.VISIBLE);
            if (mPrefTimer) {
                mCardTimer.setVisibility(View.VISIBLE);
            }
            if (mShowProgressBars) {
                mProgressBars.setVisibility(View.VISIBLE);
            }

            // Restore fullscreen preference
            getWindow().setFlags(
                    WindowManager.LayoutParams.FLAG_FULLSCREEN,
                    WindowManager.LayoutParams.FLAG_FULLSCREEN);
        }
    }


    /** Handles item selections. */
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case MENU_WHITEBOARD:
                // Toggle mShowWhiteboard value
                mShowWhiteboard = !mShowWhiteboard;
                if (mShowWhiteboard) {
                    // Show whiteboard
                    mWhiteboard.setVisibility(View.VISIBLE);
                    item.setTitle(R.string.hide_whiteboard);
                    MetaDB.storeWhiteboardState(this, mDeckFilename, 1);
                } else {
                    // Hide whiteboard
                    mWhiteboard.setVisibility(View.GONE);
                    item.setTitle(R.string.show_whiteboard);
                    MetaDB.storeWhiteboardState(this, mDeckFilename, 0);
                }
                return true;

            case MENU_CLEAR_WHITEBOARD:
                mWhiteboard.clear();
                return true;

            case MENU_EDIT:
            	return editCard();

            case MENU_REMOVE_BURY:
            	setNextCardAnimation(false);
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
                        AnkiDroidApp.deck(), mCurrentCard));
                return true;

            case MENU_REMOVE_SUSPEND:
            	setNextCardAnimation(false);
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mDismissCardHandler, new DeckTask.TaskData(0,
                        AnkiDroidApp.deck(), mCurrentCard));
                return true;

            case MENU_REMOVE_DELETE:
                showDeleteCardDialog();
                return true;

            case MENU_SEARCH:
            	lookUpOrSelectText();
                return true;

            case MENU_MARK:
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD, mMarkCardHandler, new DeckTask.TaskData(0,
                        AnkiDroidApp.deck(), mCurrentCard));
                return true;

            case MENU_UNDO:
            	setNextCardAnimation(true);
            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));
                return true;

            case MENU_REDO:
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));
                return true;
        }
        return false;
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);

        if (requestCode == EDIT_CURRENT_CARD) {
        	setInAnimation(true);
            if (resultCode == RESULT_OK || resultCode == RESULT_EDIT_CARD_RESET) {
                // Log.i(AnkiDroidApp.TAG, ""Saving card..."");
                int showQuestion = sDisplayAnswer ? UPDATE_CARD_SHOW_ANSWER : UPDATE_CARD_SHOW_QUESTION;
                if (resultCode == RESULT_EDIT_CARD_RESET) {
                	showQuestion = UPDATE_CARD_NEW_CARD;
                }
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_FACT, mUpdateCardHandler, new DeckTask.TaskData(showQuestion,
                        AnkiDroidApp.deck(), mCurrentCard));
            } else if (resultCode == StudyOptions.CONTENT_NO_EXTERNAL_STORAGE) {
                finishNoStorageAvailable();
            } else {
            	fillFlashcard(mShowAnimations);
            }
        }
        if (mPrefTextSelection) {
        	clipboardSetText("""");
        }
    }

    private boolean isCramming() {
        return (AnkiDroidApp.deck() != null) && (AnkiDroidApp.deck().name().compareTo(""cram"") == 0);
    }

    // ----------------------------------------------------------------------------
    // CUSTOM METHODS
    // ----------------------------------------------------------------------------

    /**
     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications. The intent will call
     * closeExternalStorageFiles() if the external media is going to be ejected, so applications can clean up any files
     * they have open.
     */
    private void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String action = intent.getAction();
                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
                        // Log.i(AnkiDroidApp.TAG, ""mUnmountReceiver - Action = Media Eject"");
                        finishNoStorageAvailable();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
            iFilter.addDataScheme(""file"");
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }


    private void stopTimer() {
        // Stop visible timer and card timer 
        if (mPrefTimer) {
            mSavedTimer = SystemClock.elapsedRealtime() - mCardTimer.getBase();
            mCardTimer.stop();
        }
        if (mCurrentCard != null) {
           mCurrentCard.stopTimer();
        }
    }


    private void restartTimer() {
        if (mCurrentCard != null) {
            mCurrentCard.resumeTimer();
        }
        if (mPrefTimer && mSavedTimer != 0) {
            mCardTimer.setBase(SystemClock.elapsedRealtime() - mSavedTimer);
            mCardTimer.start();
        }
    }


    private void setLanguage(String language) {
    	Locale locale;
    	if (language.equals("""")) {
        	return;
    	} else {
        	locale = new Locale(language);
    	}
        Configuration config = new Configuration();
        config.locale = locale;
        this.getResources().updateConfiguration(config, this.getResources().getDisplayMetrics());
    }


    private void finishNoStorageAvailable() {
        setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
        closeReviewer(false);
    }


    private boolean editCard() {
        if (isCramming()) {
        	Themes.showThemedToast(Reviewer.this, getResources().getString(R.string.cram_edit_warning), true);
            return false;
        } else {
            Intent editCard = new Intent(Reviewer.this, CardEditor.class);
            editCard.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.EDIT_REVIEWER_CARD);
        	sEditorCard = mCurrentCard;
        	setOutAnimation(true);
            startActivityForResult(editCard, EDIT_CURRENT_CARD);
            if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
                ActivityTransitionAnimation.slide(Reviewer.this, ActivityTransitionAnimation.LEFT);
            }
            return true;
        }
    }


    private void lookUpOrSelectText() {
        if (clipboardHasText()) {
            // Log.i(AnkiDroidApp.TAG, ""Clipboard has text = "" + clipboardHasText());
            lookUp();
    	} else {
        	selectAndCopyText();
    	}
    }


    private boolean lookUp() {
    	mLookUpIcon.setVisibility(View.GONE);
	    mIsSelecting = false;
	    if (Lookup.lookUp(clipboardGetText().toString(), mCurrentCard)) {
	        clipboardSetText("""");
	    }
	    return true;
    }


    private void showDeleteCardDialog() {
        Dialog dialog;
        Resources res = getResources();
        StyledDialog.Builder builder = new StyledDialog.Builder(this);
        builder.setTitle(res.getString(R.string.delete_card_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(String.format(res.getString(R.string.delete_card_message), Utils.stripHTML(mCurrentCard.getQuestion()), Utils.stripHTML(mCurrentCard.getAnswer())));
        builder.setPositiveButton(res.getString(R.string.yes),
                new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    	setNextCardAnimation(false);
                        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_DELETE_CARD, mDismissCardHandler, new DeckTask.TaskData(0, AnkiDroidApp.deck(), mCurrentCard));
                    }
                });
        builder.setNegativeButton(res.getString(R.string.no), null);
        dialog = builder.create();
        dialog.show();
    }


    private void answerCard(int ease) {
        mIsSelecting = false;
        mIsAnswering = true;
        if (mPrefTextSelection) {
            clipboardSetText("""");
            if (mLookUpIcon.getVisibility() == View.VISIBLE) {
                mLookUpIcon.setVisibility(View.GONE);
                mLookUpIcon.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, mFadeDuration, 0));        	
            }        	
        }
        Deck deck = AnkiDroidApp.deck();
    	switch (ease) {
    		case Card.EASE_FAILED:
    		    mChosenAnswer.setText(""\u2022"");
    		    mChosenAnswer.setTextColor(mNext1.getTextColors());
    	    	if ((deck.getDueCount() + deck.getNewCountToday()) == 1) {
    	    		mIsLastCard  = true;
                }
    			break;
    		case Card.EASE_HARD:
                mChosenAnswer.setText(""\u2022\u2022"");
                mChosenAnswer.setTextColor(mNext2.getTextColors());
    			break;
    		case Card.EASE_MID:
                mChosenAnswer.setText(""\u2022\u2022\u2022"");
                mChosenAnswer.setTextColor(mNext3.getTextColors());
    			break;
    		case Card.EASE_EASY:
                mChosenAnswer.setText(""\u2022\u2022\u2022\u2022"");
                mChosenAnswer.setTextColor(mNext4.getTextColors());
    			break;
    	}
    	mTimerHandler.removeCallbacks(removeChosenAnswerText);
    	mTimerHandler.postDelayed(removeChosenAnswerText, mShowChosenAnswerLength);
    	Sound.stopSounds();
    	mCurrentEase = ease;
        // Increment number reps counter
        mSessionCurrReps++;
        setNextCardAnimation(false);
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ANSWER_CARD, mAnswerCardHandler, new DeckTask.TaskData(
                mCurrentEase, deck, mCurrentCard));
    }

    // Set the content view to the one provided and initialize accessors.
    private void initLayout(Integer layout) {
        setContentView(layout);

        mMainLayout = findViewById(R.id.main_layout);
        Themes.setContentStyle(mMainLayout, Themes.CALLER_REVIEWER);

        mCardContainer = (FrameLayout) findViewById(R.id.flashcard_frame);
		setInAnimation(false);

        findViewById(R.id.top_bar).setOnClickListener(mCardStatisticsListener);

        mCardFrame = (FrameLayout) findViewById(R.id.flashcard);
        mTouchLayer = (FrameLayout) findViewById(R.id.touch_layer);
        mTouchLayer.setOnTouchListener(mGestureListener);
    	if (mPrefTextSelection && mLongClickWorkaround) {
            mTouchLayer.setOnLongClickListener(mLongClickListener);
    	}
        if (mPrefTextSelection) {
            mClipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
        }
        mCardFrame.removeAllViews();
        mCard = createWebView();
        mCardFrame.addView(mCard);
        if (!mChangeBorderStyle) {
            ((View)findViewById(R.id.flashcard_border)).setVisibility(View.VISIBLE);        	
        }
        
        if (mRefreshWebview) {
            mNextCard = createWebView();
            mNextCard.setVisibility(View.GONE);
            mCardFrame.addView(mNextCard, 0);        	
        }

        // hunt for input issue 720, like android issue 3341
        if (Integer.parseInt(android.os.Build.VERSION.SDK) < 8) {
            mCard.setFocusableInTouchMode(true);
        }
        
        // Initialize swipe
        gestureDetector = new GestureDetector(new MyGestureDetector());
        
        // Initialize shake detection
        if (mShakeEnabled) {
            mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
            mSensorManager.registerListener(mSensorListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);
            mAccel = 0.00f;
            mAccelCurrent = SensorManager.GRAVITY_EARTH;
            mAccelLast = SensorManager.GRAVITY_EARTH;	
        }

        mEase1 = (Button) findViewById(R.id.ease1);
        mEase1.setOnClickListener(mSelectEaseHandler);

        mEase2 = (Button) findViewById(R.id.ease2);
        mEase2.setOnClickListener(mSelectEaseHandler);

        mEase3 = (Button) findViewById(R.id.ease3);
        mEase3.setOnClickListener(mSelectEaseHandler);

        mEase4 = (Button) findViewById(R.id.ease4);
        mEase4.setOnClickListener(mSelectEaseHandler);

        mNext1 = (TextView) findViewById(R.id.nextTime1);
        mNext2 = (TextView) findViewById(R.id.nextTime2);
        mNext3 = (TextView) findViewById(R.id.nextTime3);
        mNext4 = (TextView) findViewById(R.id.nextTime4);

        if (!mshowNextReviewTime) {
            mNext1.setVisibility(View.GONE);
            mNext2.setVisibility(View.GONE);
            mNext3.setVisibility(View.GONE);
            mNext4.setVisibility(View.GONE);
        }

        mFlipCard = (Button) findViewById(R.id.flip_card);
        mFlipCard.setOnClickListener(mFlipCardListener);
        mFlipCard.setText(getResources().getString(R.string.show_answer));
    	mDefaultButtonDrawable = new Drawable[]{mFlipCard.getBackground(), mEase1.getBackground(), mEase2.getBackground(), mEase3.getBackground(), mEase4.getBackground()};

        mTextBarRed = (TextView) findViewById(R.id.red_number);
        mTextBarBlack = (TextView) findViewById(R.id.black_number);
        mTextBarBlue = (TextView) findViewById(R.id.blue_number);

        if (mShowProgressBars) {
        	mSessionYesBar = (View) findViewById(R.id.daily_bar);
            mSessionProgressBar = (View) findViewById(R.id.session_progress);
            mProgressBars = (LinearLayout) findViewById(R.id.progress_bars);
        }

        mCardTimer = (Chronometer) findViewById(R.id.card_time);
    	if (mPrefTimer && (mConfigurationChanged)) {
    		switchVisibility(mCardTimer, View.VISIBLE);
    	}
    	if (mShowProgressBars && (mConfigurationChanged)) {
    		switchVisibility(mProgressBars, View.VISIBLE);
    	}

        mChosenAnswer = (TextView) findViewById(R.id.choosen_answer);

        if (mPrefWhiteboard) {       	
            mWhiteboard = new Whiteboard(this, mInvertedColors, mBlackWhiteboard);
            FrameLayout.LayoutParams lp2 = new FrameLayout.LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT);
            mWhiteboard.setLayoutParams(lp2);
            FrameLayout fl = (FrameLayout) findViewById(R.id.whiteboard);
            fl.addView(mWhiteboard);
            
            mWhiteboard.setOnTouchListener(new View.OnTouchListener() {
                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    if (mShowWhiteboard) {
                        return false;
                    }
                    if (gestureDetector.onTouchEvent(event)) {
                        return true;
                    }
                    return false;
                }
            });            
        }
        mAnswerField = (EditText) findViewById(R.id.answer_field);

        mNextTimeTextColor = getResources().getColor(R.color.next_time_usual_color);
        mNextTimeTextRecomColor = getResources().getColor(R.color.next_time_recommended_color);        	
        mForegroundColor = getResources().getColor(R.color.next_time_usual_color);        	
        if (mInvertedColors) {
            invertColors(true);
        }

        mLookUpIcon = findViewById(R.id.lookup_button);
        mLookUpIcon.setVisibility(View.GONE);
        mLookUpIcon.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View arg0) {
				if (clipboardHasText()) {
					lookUp();
				}
			}
        	
        });
        initControls();
    }


    private WebView createWebView() {
        WebView webView = new MyWebView(this);
        webView.setWillNotCacheDrawing(true);
        webView.setScrollBarStyle(WebView.SCROLLBARS_OUTSIDE_OVERLAY);
        if (mZoomEnabled) {
            webView.getSettings().setBuiltInZoomControls(true);
        }
        webView.getSettings().setJavaScriptEnabled(true);
        webView.setWebChromeClient(new AnkiDroidWebChromeClient());
        webView.addJavascriptInterface(new JavaScriptInterface(), ""interface"");
        if (Integer.parseInt(android.os.Build.VERSION.SDK) > 7) {
            webView.setFocusableInTouchMode(false);
        }
        // Log.i(AnkiDroidApp.TAG, ""Focusable = "" + webView.isFocusable() + "", Focusable in touch mode = "" + webView.isFocusableInTouchMode());
        if (mSetScrollbarBarFading != null) {
            try {
            	mSetScrollbarBarFading.invoke(webView, false);
            } catch (Throwable e) {
            	// Log.i(AnkiDroidApp.TAG, ""setScrollbarFadingEnabled could not be set due to a too low Android version (< 2.1)"");
            	mSetScrollbarBarFading = null;
            }
        }
        mScaleInPercent = webView.getScale();
        return webView;
    }


    private void invertColors(boolean invert) {
        Resources res = getResources();        
        int fgColor = invert ? res.getColor(R.color.foreground_color_inv) : res.getColor(R.color.black);
        mCard.setBackgroundColor(mCurrentBackgroundColor);

        if (mChangeBorderStyle) {
            mMainLayout.setBackgroundColor(mCurrentBackgroundColor);
            mFlipCard.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[0]);
            mEase1.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[1]);
            mEase2.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[2]);
            mEase3.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[3]);
            mEase4.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.btn_keyboard_key_fulltrans_normal) : mDefaultButtonDrawable[4]);
        } else {
            mMainLayout.setBackgroundResource(invert ? R.color.reviewer_background_night : R.color.reviewer_background);
        	findViewById(R.id.flashcard_border).setBackgroundResource(invert ? R.drawable.blue_bg_webview_night : R.drawable.blue_bg_webview);
            mFlipCard.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[0]);
            mEase1.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[1]);
            mEase2.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[2]);
            mEase3.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[3]);
            mEase4.setBackgroundDrawable(invert ? res.getDrawable(R.drawable.blue_btn_night) : mDefaultButtonDrawable[4]);
        }
        if (invert || mChangeBorderStyle) {
            mNextTimeTextColor = invert ? res.getColor(R.color.next_time_usual_color_inv) : res.getColor(R.color.next_time_usual_color);
            mNextTimeTextRecomColor = invert ? res.getColor(R.color.next_time_recommended_color_inv) : res.getColor(R.color.next_time_recommended_color);
            mNext4.setTextColor(mNextTimeTextColor);
            mCardTimer.setTextColor(fgColor);
            mForegroundColor = fgColor;
            mTextBarBlack.setTextColor(fgColor);
            mTextBarBlue.setTextColor(invert ? res.getColor(R.color.textbar_blue_color_inv) : res.getColor(R.color.textbar_blue_color));

            mFlipCard.setTextColor(fgColor);
            mEase1.setTextColor(fgColor);
            mEase2.setTextColor(fgColor);
            mEase3.setTextColor(fgColor);
            mEase4.setTextColor(fgColor);

            fgColor = R.color.studyoptions_progressbar_frame_light;
            int bgColor = R.color.studyoptions_progressbar_background_nightmode;
            findViewById(R.id.progress_bars_border1).setBackgroundResource(fgColor);
            findViewById(R.id.progress_bars_border2).setBackgroundResource(fgColor);
            findViewById(R.id.progress_bars_back1).setBackgroundResource(bgColor);
            findViewById(R.id.progress_bars_back2).setBackgroundResource(bgColor);
        }
    }


    private boolean[] postAnswerCard(DeckTask.TaskData... values) {
        Resources res = getResources();
        boolean sessionComplete = false;
        boolean noMoreCards = false;
        // Check to see if session rep or time limit has been reached
        Deck deck = AnkiDroidApp.deck();
        if (deck == null) {
        	return new boolean[] {false, false};
        }
        long sessionRepLimit = deck.getSessionRepLimit();
        long sessionTime = deck.getSessionTimeLimit();
        String sessionMessage = null;
        String leechMessage;
        // Log.i(AnkiDroidApp.TAG, ""reviewer leech flag: "" + values[0].isPreviousCardLeech() + "" "" + values[0].isPreviousCardSuspended());

        if (values[0].isPreviousCardLeech()) {
            if (values[0].isPreviousCardSuspended()) {
                leechMessage = res.getString(R.string.leech_suspend_notification);
            } else {
                leechMessage = res.getString(R.string.leech_notification);
            }
            Themes.showThemedToast(Reviewer.this, leechMessage, true);
        }

        if ((sessionRepLimit > 0) && (mSessionCurrReps >= sessionRepLimit)) {
        	sessionComplete = true;
            sessionMessage = res.getString(R.string.session_question_limit_reached);
        } else if ((sessionTime > 0) && (System.currentTimeMillis() >= mSessionTimeLimit)) {
            // session time limit reached, flag for halt once async task has completed.
        	sessionComplete = true;
            sessionMessage = res.getString(R.string.session_time_limit_reached);
        } else if (mIsLastCard) {
        	noMoreCards = true;
            mProgressDialog = ProgressDialog.show(Reviewer.this, """", getResources()
                    .getString(R.string.saving_changes), true);
            setOutAnimation(true);
        } else {
            // session limits not reached, show next card
            Card newCard = values[0].getCard();

            // If the card is null means that there are no more cards scheduled for review.
            if (newCard == null) {
            	noMoreCards = true;
                mProgressDialog = ProgressDialog.show(Reviewer.this, """", getResources()
                        .getString(R.string.saving_changes), true);
                setOutAnimation(false);
                return new boolean[] {sessionComplete, noMoreCards};
            }

            // Start reviewing next card
            mCurrentCard = newCard;
            if (mPrefWriteAnswers) { //only bother query deck if needed
            	String[] answer = mCurrentCard.getComparedFieldAnswer();
            	comparedFieldAnswer = answer[0];
            	comparedFieldClass = answer[1];
            } else {
            	comparedFieldAnswer = null;
            }
            Reviewer.this.setProgressBarIndeterminateVisibility(false);
            // Reviewer.this.enableControls();
            Reviewer.this.unblockControls();
            Reviewer.this.displayCardQuestion();
        }
        if (mChosenAnswer.getText().equals("""")) {
            setDueMessage();
        }
        // Show a message to user if a session limit has been reached.
        if (sessionMessage != null) {
        	Themes.showThemedToast(Reviewer.this, sessionMessage, true);
        }
        return new boolean[] {sessionComplete, noMoreCards};
    }


    private void showEaseButtons() {
        Resources res = getResources();

        // hide flipcard button
        switchVisibility(mFlipCard, View.GONE);

        // Set correct label for each button
        if (mCurrentCard.isRev()) {
            mEase1.setText(res.getString(R.string.ease1_successive));
            mEase2.setText(res.getString(R.string.ease2_successive));
            mEase3.setText(res.getString(R.string.ease3_successive));
            mEase4.setText(res.getString(R.string.ease4_successive));
        } else {
            mEase1.setText(res.getString(R.string.ease1_learning));
            mEase2.setText(res.getString(R.string.ease2_learning));
            mEase3.setText(res.getString(R.string.ease3_learning));
            mEase4.setText(res.getString(R.string.ease4_learning));
        }

        // Show buttons
        switchVisibility(mEase1, View.VISIBLE);
        switchVisibility(mEase2, View.VISIBLE);
        switchVisibility(mEase3, View.VISIBLE);
        switchVisibility(mEase4, View.VISIBLE);
        
        // Focus default button
        if (mCurrentCard.isRev()) {
            mEase3.requestFocus();
            mNext2.setTextColor(mNextTimeTextColor);
            mNext3.setTextColor(mNextTimeTextRecomColor);
        } else {
            mEase2.requestFocus();
            mNext2.setTextColor(mNextTimeTextRecomColor);
            mNext3.setTextColor(mNextTimeTextColor);
        }

        // Show next review time
        if (mshowNextReviewTime) {
        mNext1.setText(nextInterval(1));
        mNext2.setText(nextInterval(2));
        mNext3.setText(nextInterval(3));
        mNext4.setText(nextInterval(4));
        switchVisibility(mNext1, View.VISIBLE);
        switchVisibility(mNext2, View.VISIBLE);
        switchVisibility(mNext3, View.VISIBLE);
        switchVisibility(mNext4, View.VISIBLE);
        }
    }


    private void hideEaseButtons() {
    	switchVisibility(mEase1, View.GONE);
    	switchVisibility(mEase2, View.GONE);
    	switchVisibility(mEase3, View.GONE);
    	switchVisibility(mEase4, View.GONE);
    	if (mshowNextReviewTime) {
    		int visibility = typeAnswer() ? View.GONE : View.INVISIBLE;
    		switchVisibility(mNext1, visibility);
    		switchVisibility(mNext2, visibility);
    		switchVisibility(mNext3, visibility);
    		switchVisibility(mNext4, visibility);
    	}
    	if (mFlipCard.getVisibility() != View.VISIBLE) {
    		switchVisibility(mFlipCard, View.VISIBLE);
        	mFlipCard.requestFocus();
    	} else if (typeAnswer()) {
            mAnswerField.requestFocus();

            // Show soft keyboard
            InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            inputMethodManager.showSoftInput(mAnswerField, InputMethodManager.SHOW_FORCED);
    	}
    }


    private void switchVisibility(View view, int visible) {
    	switchVisibility(view, visible, mShowAnimations && !mConfigurationChanged);
    }
    private void switchVisibility(View view, int visible, boolean fade) {
    	view.setVisibility(visible);
    	if (fade) {
    		int duration = mShowAnimations ? mAnimationDurationTurn / 2 : mFadeDuration;
    		if (visible == View.VISIBLE) {
        		view.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, duration, mShowAnimations ? duration : 0));    			
    		} else {
        		view.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, duration, 0));
    		}
    	}
    }


    private void switchTopBarVisibility(int visible) {
    	if (mPrefTimer) {
    		switchVisibility(mCardTimer, visible, true);
    	}
    	if (mShowProgressBars) {
    		switchVisibility(mProgressBars, visible, true);
    	}
    	switchVisibility(mTextBarRed, visible, true);
    	switchVisibility(mTextBarBlack, visible, true);
    	switchVisibility(mTextBarBlue, visible, true);
    	switchVisibility(mChosenAnswer, visible, true);
    }


    private void initControls() {
        mCardFrame.setVisibility(View.VISIBLE);
        mTextBarRed.setVisibility(View.VISIBLE);
        mTextBarBlack.setVisibility(View.VISIBLE);
        mTextBarBlue.setVisibility(View.VISIBLE);
        mChosenAnswer.setVisibility(View.VISIBLE);
        mFlipCard.setVisibility(View.VISIBLE);
        
        if (mPrefWhiteboard) {
            mWhiteboard.setVisibility(mShowWhiteboard ? View.VISIBLE : View.GONE);            
        }
        mAnswerField.setVisibility(typeAnswer() ? View.VISIBLE : View.GONE);
    }


    private SharedPreferences restorePreferences() {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
        mPrefTimer = preferences.getBoolean(""timer"", true);
        mPrefWhiteboard = preferences.getBoolean(""whiteboard"", false);
        mPrefWriteAnswers = preferences.getBoolean(""writeAnswers"", false);
        mPrefTextSelection = preferences.getBoolean(""textSelection"", true);
        mLongClickWorkaround = preferences.getBoolean(""textSelectionLongclickWorkaround"", false);
        mDeckFilename = preferences.getString(""deckFilename"", """");
        mNightMode = preferences.getBoolean(""invertedColors"", false);
    	mInvertedColors = mNightMode;
        mBlackWhiteboard = preferences.getBoolean(""blackWhiteboard"", true);
        mSwapQA = preferences.getBoolean(""swapqa"", false);
        mPrefUseRubySupport = preferences.getBoolean(""useRubySupport"", false);
        mPrefFullscreenReview = preferences.getBoolean(""fullscreenReview"", true);
        mshowNextReviewTime = preferences.getBoolean(""showNextReviewTime"", true);
        mZoomEnabled = preferences.getBoolean(""zoom"", false);
//        mZeemoteEnabled = preferences.getBoolean(""zeemote"", false);
        mDisplayFontSize = preferences.getInt(""relativeDisplayFontSize"", CardModel.DEFAULT_FONT_SIZE_RATIO);
        mRelativeButtonSize = preferences.getInt(""answerButtonSize"", 100);
        mPrefHideQuestionInAnswer = Integer.parseInt(preferences.getString(""hideQuestionInAnswer"",
                Integer.toString(HQIA_DO_SHOW)));
        mInputWorkaround = preferences.getBoolean(""inputWorkaround"", false);
        mPrefFixHebrew = preferences.getBoolean(""fixHebrewText"", false);
        mPrefFixArabic = preferences.getBoolean(""fixArabicText"", false);
        mSpeakText = preferences.getBoolean(""tts"", false);
        mPlaySoundsAtStart = preferences.getBoolean(""playSoundsAtStart"", true);
        mShowProgressBars = preferences.getBoolean(""progressBars"", true);
        mPrefUseTimer = preferences.getBoolean(""timeoutAnswer"", false);
        mWaitAnswerSecond = preferences.getInt(""timeoutAnswerSeconds"", 20);
        mWaitQuestionSecond = preferences.getInt(""timeoutQuestionSeconds"", 60);
        mScrollingButtons = preferences.getBoolean(""scrolling_buttons"", false);
        mDoubleScrolling =  preferences.getBoolean(""double_scrolling"", false);
        mGesturesEnabled = preferences.getBoolean(""swipe"", false);
        if (mGesturesEnabled) {
         	mGestureShake = Integer.parseInt(preferences.getString(""gestureShake"", ""0""));
         	if (mGestureShake != 0) {
         		mShakeEnabled = true;
         	}
            mShakeIntensity = preferences.getInt(""minShakeIntensity"", 70);

            mGestureSwipeUp = Integer.parseInt(preferences.getString(""gestureSwipeUp"", ""0""));
         	mGestureSwipeDown = Integer.parseInt(preferences.getString(""gestureSwipeDown"", ""0""));
         	mGestureSwipeLeft = Integer.parseInt(preferences.getString(""gestureSwipeLeft"", ""13""));
         	mGestureSwipeRight = Integer.parseInt(preferences.getString(""gestureSwipeRight"", ""0""));
         	mGestureDoubleTap = Integer.parseInt(preferences.getString(""gestureDoubleTap"", ""0""));
         	mGestureTapLeft = Integer.parseInt(preferences.getString(""gestureTapLeft"", ""0""));
         	mGestureTapRight = Integer.parseInt(preferences.getString(""gestureTapRight"", ""0""));
         	mGestureTapTop = Integer.parseInt(preferences.getString(""gestureTapTop"", ""0""));
         	mGestureTapBottom = Integer.parseInt(preferences.getString(""gestureTapBottom"", ""0""));
        }
        mShowAnimations = preferences.getBoolean(""themeAnimations"", false);
        if (mShowAnimations) {
            int animationDuration = preferences.getInt(""animationDuration"", 500);
           	mAnimationDurationTurn = animationDuration;
           	mAnimationDurationMove = animationDuration;
        }
        mLocale = preferences.getString(""language"", """");

        // allow screen orientation in reviewer only when fix preference is not set
        if (preferences.getBoolean(""fixOrientation"", false)) {
            if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
            } else if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
            }
        }

        if (preferences.getBoolean(""keepScreenOn"", false)) {
        	this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        }

        return preferences;
    }


    private void setDueMessage() {
    	Deck deck = AnkiDroidApp.deck();
		if (mCurrentCard != null && deck != null && deck.getScheduler().equals(""reviewEarly"") && mCurrentCard.getType() != Card.TYPE_FAILED) {
    		mChosenAnswer.setTextColor(mForegroundColor);
    		mChosenAnswer.setText(Utils.fmtTimeSpan(mCurrentCard.getCombinedDue() - Utils.now(), Utils.TIME_FORMAT_IN));				
		}
    }


    private void updateForNewCard() {
    	updateScreenCounts();
    	if (mShowProgressBars) {
            updateStatisticBars();
    	}

        // Clean answer field
        if (typeAnswer()) {
            mAnswerField.setText("""");
        }

        if (mPrefWhiteboard && !mShowAnimations) {
            mWhiteboard.clear();
        }

        if (mPrefTimer) {
            mCardTimer.setBase(SystemClock.elapsedRealtime());
            mCardTimer.start();
        }
    }


    private void updateScreenCounts() {
    	if (mCurrentCard == null) {
    		return;
    	}
        Deck deck = AnkiDroidApp.deck();
        int eta = deck.getETA();
        if (deck.hasFinishScheduler() || eta < 1) {
            setTitle(deck.getDeckName());
        } else {
            setTitle(getResources().getQuantityString(R.plurals.reviewer_window_title, eta, deck.getDeckName(), eta));        	
        }

        int _failedSoonCount = deck.getFailedSoonCount();
        int _revCount = deck.getRevCount();
        int _newCount = deck.getNewCountToday();
        
        SpannableString failedSoonCount = new SpannableString(String.valueOf(_failedSoonCount));
        SpannableString revCount = new SpannableString(String.valueOf(_revCount));
        SpannableString newCount = new SpannableString(String.valueOf(_newCount));

        boolean isDue = true; // mCurrentCard.isDue();
        int type = mCurrentCard.getType();

        if (isDue && (type == Card.TYPE_NEW)) {
            newCount.setSpan(new UnderlineSpan(), 0, newCount.length(), 0);
        }
        if (isDue && (type == Card.TYPE_REV)) {
            revCount.setSpan(new UnderlineSpan(), 0, revCount.length(), 0);
        }
        if (isDue && (type == Card.TYPE_FAILED)) {
            failedSoonCount.setSpan(new UnderlineSpan(), 0, failedSoonCount.length(), 0);
        }

        mTextBarRed.setText(failedSoonCount);
        mTextBarBlack.setText(revCount);
        mTextBarBlue.setText(newCount);
    }


    private void updateStatisticBars() {
        if (mStatisticBarsMax == 0) {
            View view = findViewById(R.id.progress_bars_back1);
            mStatisticBarsMax = view.getWidth();
            mStatisticBarsHeight = view.getHeight();
        }
        Deck deck = AnkiDroidApp.deck();
        Utils.updateProgressBars(this, mSessionProgressBar, deck.getSessionProgress(), mStatisticBarsMax, mStatisticBarsHeight, true, false);
        Utils.updateProgressBars(this, mSessionYesBar, deck.getProgress(false), mStatisticBarsMax, mStatisticBarsHeight, true);
    }

    /* Handler for the delay in auto showing question and/or answer
     * One toggle for both question and answer, could set longer
     * delay for auto next question
     */
    private Handler mTimeoutHandler = new Handler();

    private Runnable mShowQuestionTask = new Runnable() {
        public void run() {
            //Assume hitting the ""Again"" button when auto next question
            if (mEase1.isEnabled() == true && mEase1.getVisibility() == View.VISIBLE) {
		mEase1.performClick();
            }
        }
    };

    private Runnable mShowAnswerTask = new Runnable() {
        public void run() {
            if (mPrefTimer) {
                mCardTimer.stop();
            }
            if (mFlipCard.isEnabled() == true && mFlipCard.getVisibility() == View.VISIBLE && !mIsAnswering) {
		mFlipCard.performClick();
            }
        }
    };

    private void displayCardQuestion() {
        sDisplayAnswer = false;
        mIsAnswering = false;

        if (mButtonHeight == 0 && mRelativeButtonSize != 100) {
        	mButtonHeight = mFlipCard.getHeight() * mRelativeButtonSize / 100;
        	mFlipCard.setHeight(mButtonHeight);
        	mEase1.setHeight(mButtonHeight);
        	mEase2.setHeight(mButtonHeight);
        	mEase3.setHeight(mButtonHeight);
        	mEase4.setHeight(mButtonHeight);        	
        }

        // If the user wants to write the answer
        if (typeAnswer()) {
            mAnswerField.setVisibility(View.VISIBLE);

            // Show soft keyboard
            InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            inputMethodManager.showSoftInput(mAnswerField, InputMethodManager.SHOW_FORCED);
        }

        String question = getQuestion();

        if(mPrefFixArabic) {
        	question = ArabicUtilities.reshapeSentence(question, true);
        }
        // Log.i(AnkiDroidApp.TAG, ""question: '"" + question + ""'"");

        String displayString = enrichWithQADiv(question, false);
        // Show an horizontal line as separation when question is shown in answer
        if (isQuestionDisplayed()) {
            displayString = displayString + ""<hr/>"";
        }

        if (mSpeakText && Integer.valueOf(android.os.Build.VERSION.SDK) > 3) {
            ReadText.setLanguageInformation(Model.getModel(AnkiDroidApp.deck(), mCurrentCard.getCardModelId(), false).getId(), mCurrentCard.getCardModelId());          
        }

        updateCard(displayString);
        hideEaseButtons();

        // If the user want to show answer automatically
        if (mPrefUseTimer) {
            mTimeoutHandler.removeCallbacks(mShowAnswerTask);
            mTimeoutHandler.postDelayed(mShowAnswerTask, mWaitAnswerSecond * 1000  );            
        }
    }


    private void displayCardAnswer() {
        // Log.i(AnkiDroidApp.TAG, ""displayCardAnswer"");

        // prevent answering (by e.g. gestures) before card is loaded
        if (mCurrentCard == null) {
        	return;
        }

        sDisplayAnswer = true;
        setFlipCardAnimation();
        
        Sound.stopSounds();

        String displayString = """";
        
        String answer = getAnswer(), question = getQuestion();
        if(mPrefFixArabic) {
        	// reshape
        	answer = ArabicUtilities.reshapeSentence(answer, true);
        	question = ArabicUtilities.reshapeSentence(question, true);
        }

        // If the user wrote an answer
        if (typeAnswer()) {
            mAnswerField.setVisibility(View.GONE);
            if (mCurrentCard != null) {
                // Obtain the user answer and the correct answer
                String userAnswer = mAnswerField.getText().toString();         
                Matcher matcher = sSpanPattern.matcher(Utils.stripHTMLMedia(ArabicUtilities.reshapeSentence(comparedFieldAnswer, true)));
                String correctAnswer = matcher.replaceAll("""");
                matcher = sBrPattern.matcher(correctAnswer);
                correctAnswer = matcher.replaceAll(""\n"");
                matcher = Sound.sSoundPattern.matcher(correctAnswer);
                correctAnswer = matcher.replaceAll("""");
                matcher = Image.sImagePattern.matcher(correctAnswer);
                correctAnswer = matcher.replaceAll("""");
                // Log.i(AnkiDroidApp.TAG, ""correct answer = "" + correctAnswer);

                // Obtain the diff and send it to updateCard
                DiffEngine diff = new DiffEngine();

                StringBuffer span = new StringBuffer();
                span.append(""<span class=\"""").append(comparedFieldClass).append(""\"">"");
                span.append(diff.diff_prettyHtml(diff.diff_main(userAnswer, correctAnswer)));
                span.append(""</span>"");
                span.append(""<br/>"").append(answer);
                displayString = enrichWithQADiv(span.toString(), true);
            }

            // Hide soft keyboard
            InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
            inputMethodManager.hideSoftInputFromWindow(mAnswerField.getWindowToken(), 0);
        } else {
            displayString = enrichWithQADiv(answer, true);
        }

        // Depending on preferences do or do not show the question
        if (isQuestionDisplayed()) {
            StringBuffer sb = new StringBuffer();
            sb.append(enrichWithQADiv(question, false));
            sb.append(""<a name=\""question\""></a><hr/>"");
            sb.append(displayString);
            displayString = sb.toString();
        }

        mIsSelecting = false;
        updateCard(displayString);
        showEaseButtons();

        // If the user want to show next question automatically
        if (mPrefUseTimer) {
            mTimeoutHandler.removeCallbacks(mShowQuestionTask);
            mTimeoutHandler.postDelayed(mShowQuestionTask, mWaitQuestionSecond * 1000  );            
        }
    }


    private void updateCard(String content) {
        // Log.i(AnkiDroidApp.TAG, ""updateCard"");

        mBaseUrl = """";
        Boolean isJapaneseModel = false;
        
        //Check whether there is a hard coded font-size in the content and apply the relative font size
        //Check needs to be done before CSS is applied to content;
        content = recalculateHardCodedFontSize(content, mDisplayFontSize);
        
        // Add CSS for font color and font size
        if (mCurrentCard != null) {
        	final String japaneseModelTag = ""Japanese"";
        	
            Deck currentDeck = AnkiDroidApp.deck();
            Model myModel = Model.getModel(currentDeck, mCurrentCard.getCardModelId(), false);
		if (myModel == null) {
			Log.e(AnkiDroidApp.TAG, ""updateCard - no Model could be fetched. Closing Reviewer and showing db-error dialog"");
	                Reviewer.this.setResult(RESULT_ANSWERING_ERROR);
	                closeReviewer(true);			
		}
            mBaseUrl = Utils.getBaseUrl(mMediaDir, myModel, currentDeck);
            int nightBackground = Themes.getNightModeCardBackground(this);
            content = myModel.getCSSForFontColorSize(mCurrentCard.getCardModelId(), mDisplayFontSize, mNightMode, nightBackground) + Model.invertColors(content, mNightMode);
            isJapaneseModel = myModel.hasTag(japaneseModelTag);
            mCurrentBackgroundColor = myModel.getBackgroundColor(mCurrentCard.getCardModelId());
        } else {
        	mCard.getSettings().setDefaultFontSize(calculateDynamicFontSize(content));
            mBaseUrl = Utils.urlEncodeMediaDir(mDeckFilename.replace("".anki"", "".media/""));
        }

        // // Log.i(AnkiDroidApp.TAG, ""Initial content card = \n"" + content);
        // content = Image.parseImages(deckFilename, content);
        // // Log.i(AnkiDroidApp.TAG, ""content after parsing images = \n"" + content);

        // don't play question sound again when displaying answer 
        int questionStartsAt = content.indexOf(""<a name=\""question\""></a><hr/>"");
        String question = """";
        String answer = """";
        if (isQuestionDisplayed()) {
        	if (sDisplayAnswer && (questionStartsAt != -1)) {
                question = Sound.parseSounds(mBaseUrl, content.substring(0, questionStartsAt), mSpeakText, MetaDB.LANGUAGES_QA_QUESTION);
                answer = Sound.parseSounds(mBaseUrl, content.substring(questionStartsAt, content.length()), mSpeakText, MetaDB.LANGUAGES_QA_ANSWER);
        	} else {
                question = Sound.parseSounds(mBaseUrl, content.substring(0, content.length() - 5), mSpeakText, MetaDB.LANGUAGES_QA_QUESTION) + ""<hr/>"";
        	}
        } else {
            int qa = MetaDB.LANGUAGES_QA_QUESTION;
        	if (sDisplayAnswer) {
                qa = MetaDB.LANGUAGES_QA_ANSWER;
        	}
        	answer = Sound.parseSounds(mBaseUrl, content, mSpeakText, qa);
        }

        // Parse out the LaTeX images
        question = LaTeX.parseLaTeX(AnkiDroidApp.deck(), question);
        answer = LaTeX.parseLaTeX(AnkiDroidApp.deck(), answer);

       
        // If ruby annotation support is activated, then parse and handle:
        // Strip kanji in question, add furigana in answer
        if (mPrefUseRubySupport && isJapaneseModel) {
          	content = RubyParser.ankiStripKanji(question) + RubyParser.ankiRubyToMarkup(answer);
        } else {
        	content = question + answer;
        }

        // In order to display the bold style correctly, we have to change
        // font-weight to 700
        content = content.replace(""font-weight:600;"", ""font-weight:700;"");

        // Find hebrew text
        if (isHebrewFixEnabled()) {
            content = applyFixForHebrew(content);
        }
		
        // Log.i(AnkiDroidApp.TAG, ""content card = \n"" + content);
        StringBuilder style = new StringBuilder();
        style.append(getCustomFontsStyle());
        style.append(getDefaultFontStyle());
        style.append(getDeckStyle(mCurrentCard.mDeck.getDeckPath()));
        // Log.i(AnkiDroidApp.TAG, ""::style::"" + style);
        mCardContent =
            mCardTemplate.replace(""::content::"", content).replace(""::style::"", style.toString());
        // // Log.i(AnkiDroidApp.TAG, ""card html = \n"" + card);
        // Log.i(AnkiDroidApp.TAG, ""base url = "" + mBaseUrl );

    	fillFlashcard(mShowAnimations);

        if (!mConfigurationChanged && mPlaySoundsAtStart) {
            if (!mSpeakText) {
                Sound.playSounds(null, 0);
            } else if (!sDisplayAnswer) {
                Sound.playSounds(Utils.stripHTML(getQuestion()), MetaDB.LANGUAGES_QA_QUESTION);
            } else {
                Sound.playSounds(Utils.stripHTML(getAnswer()), MetaDB.LANGUAGES_QA_ANSWER);
            }
        }
    }


    private void setFlipCardAnimation() {
    	mNextAnimation = ANIMATION_TURN;
    }
    private void setNextCardAnimation(boolean reverse) {
    	if (mCardContainer.getVisibility() == View.INVISIBLE) {
    		setInAnimation(reverse);
    	} else {
    		mNextAnimation = reverse ? ANIMATION_NEXT_CARD_FROM_LEFT : ANIMATION_NEXT_CARD_FROM_RIGHT;
    	}
    }
    private void setInAnimation(boolean reverse) {
		mNextAnimation = reverse ? ANIMATION_SLIDE_IN_FROM_LEFT : ANIMATION_SLIDE_IN_FROM_RIGHT;
    }
    private void setOutAnimation(boolean reverse) {
		mNextAnimation = reverse ? ANIMATION_SLIDE_OUT_TO_RIGHT: ANIMATION_SLIDE_OUT_TO_LEFT;
    	if (mCardContainer.getVisibility() == View.VISIBLE && mShowAnimations) {
        	fillFlashcard(true);
    	}
    }


    public void fillFlashcard(boolean flip) {
    	if (!flip) {
	        // Log.i(AnkiDroidApp.TAG, ""base url = "" + mBaseUrl);
	        if (mRefreshWebview) {
	            mNextCard.setBackgroundColor(mCurrentBackgroundColor);
	            mNextCard.loadDataWithBaseURL(mBaseUrl, mCardContent, ""text/html"", ""utf-8"", null);
	            mNextCard.setVisibility(View.VISIBLE);
	            mCardFrame.removeView(mCard);
	            mCard.destroy();
	            mCard = mNextCard;
	            mNextCard = createWebView();
	            mNextCard.setVisibility(View.GONE);
	            mCardFrame.addView(mNextCard, 0);
	            // hunt for input issue 720, like android issue 3341
	            if (Integer.parseInt(android.os.Build.VERSION.SDK) < 8) {
	            	mCard.setFocusableInTouchMode(true);
	            }
	        } else {
	            mCard.loadDataWithBaseURL(mBaseUrl, mCardContent, ""text/html"", ""utf-8"", null);
	            mCard.setBackgroundColor(mCurrentBackgroundColor);
	        }
	        if (mChangeBorderStyle) {
		        switch (mCurrentBackgroundColor) {
		        case Color.WHITE:
		        	if (mInvertedColors) {
		        		mInvertedColors = false;
		            	invertColors(false);	        		
		        	}
			        break;
		        case Color.BLACK:
			        if (!mInvertedColors) {
		            	mInvertedColors = true;
		            	invertColors(true);
			        }
			        break;
		        default:
		            if (Themes.getTheme() != Themes.THEME_BLUE) {
		                mMainLayout.setBackgroundColor(mCurrentBackgroundColor);
		            }
	            	if (mInvertedColors != mNightMode) {
	    	            mInvertedColors = mNightMode;
	    	            invertColors(mNightMode);            		
	            	}
		        }	        	
	        }
	        if (!mShowAnimations && mCardTimer.getVisibility() == View.INVISIBLE) {
    	    	switchTopBarVisibility(View.VISIBLE);
	        }
    		if (!sDisplayAnswer) {
        		updateForNewCard();
        		if (mShowWhiteboard) {
    				mWhiteboard.clear();
        		}
        		setNextCardAnimation(false);
    		}
    	} else {
    		Animation3D rotation;
    		boolean directionToLeft = true;
    		switch (mNextAnimation) {
    		case ANIMATION_TURN:
    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 9, Animation3D.ANIMATION_TURN, true, true, this);
    			rotation.setDuration(mAnimationDurationTurn);
    			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
    			break;
    		case ANIMATION_NEXT_CARD_FROM_LEFT:
    			directionToLeft = false;
    		case ANIMATION_NEXT_CARD_FROM_RIGHT:
    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_EXCHANGE_CARD, directionToLeft, true, this);
    			rotation.setDuration(mAnimationDurationMove);
    			rotation.setInterpolator(new AccelerateDecelerateInterpolator());
    			break;
    		case ANIMATION_SLIDE_OUT_TO_RIGHT:
    			directionToLeft = false;
    		case ANIMATION_SLIDE_OUT_TO_LEFT:
        		fillFlashcard(false);
    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_SLIDE_OUT_CARD, directionToLeft, true, this);
    			rotation.setDuration(mAnimationDurationMove);
    			rotation.setInterpolator(new AccelerateInterpolator());
    	    	switchTopBarVisibility(View.INVISIBLE);
    			break;
    		case ANIMATION_SLIDE_IN_FROM_LEFT:
    			directionToLeft = false;
    		case ANIMATION_SLIDE_IN_FROM_RIGHT:
        		fillFlashcard(false);
    			rotation = new Animation3D(mCard.getWidth(), mCard.getHeight(), 0, Animation3D.ANIMATION_SLIDE_IN_CARD, directionToLeft, true, this);
    			rotation.setDuration(mAnimationDurationMove);
    			rotation.setInterpolator(new DecelerateInterpolator());
    	    	switchTopBarVisibility(View.VISIBLE);
    			break;
    		case ANIMATION_NO_ANIMATION:
    		default:
    			return;
    		}

    		rotation.reset();
    		mCardContainer.setDrawingCacheEnabled(true);
    		mCardContainer.setDrawingCacheBackgroundColor(Themes.getBackgroundColor());
	    	mCardContainer.clearAnimation();
	    	mCardContainer.startAnimation(rotation);
    	}
    }


    public void showFlashcard(boolean visible) {
    	mCardContainer.setVisibility(visible ? View.VISIBLE : View.INVISIBLE); 
    }


    private String getQuestion() {
    	if (mSwapQA) {
    		return mCurrentCard.getAnswer();
    	} else {
    		return mCurrentCard.getQuestion();
    	}
    }


    private String getAnswer() {
    	if (mSwapQA) {
    		return mCurrentCard.getQuestion();
    	} else {
    		return mCurrentCard.getAnswer();
    	}
    }


    private String getDeckStyle(String deckPath) {
      File styleFile = new File(Utils.removeExtension(deckPath) + "".css"");
      if (!styleFile.exists() || !styleFile.canRead()) {
        return """";
      }
      StringBuilder style = new StringBuilder();
      try {
        BufferedReader styleReader =
          new BufferedReader(new InputStreamReader(new FileInputStream(styleFile)));
        while (true) {
          String line = styleReader.readLine();
          if (line == null) {
            break;
          }
          style.append(line);
          style.append('\n');
        }
      } catch (IOException e) {
        Log.e(AnkiDroidApp.TAG, ""Error reading style file: "" + styleFile.getAbsolutePath(), e);
        return """";
      }
      return style.toString();
    }


    /**
     * Returns the CSS used to handle custom fonts.
     * <p>
     * Custom fonts live in fonts directory in the directory used to store decks.
     * <p>
     * Each font is mapped to the font family by the same name as the name of the font fint without
     * the extension.
     */
    private String getCustomFontsStyle() {
      StringBuilder builder = new StringBuilder();
      for (File fontFile : mCustomFontFiles) {
        String fontFace = String.format(
            ""@font-face {font-family: \""%s\""; src: url(\""file://%s\"");}"",
            Utils.removeExtension(fontFile.getName()), fontFile.getAbsolutePath());
        // Log.d(AnkiDroidApp.TAG, ""adding to style: "" + fontFace);
        builder.append(fontFace);
        builder.append('\n');
      }
      return builder.toString();
    }


    /** Returns the CSS used to set the default font. */
    private String getDefaultFontStyle() {
    	if (mCustomDefaultFontCss == null) {
            SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
            String defaultFont = preferences.getString(""defaultFont"", null);
            if (defaultFont == null || """".equals(defaultFont)) {
            	mCustomDefaultFontCss = """";
            } else {
                mCustomDefaultFontCss = ""BODY .question, BODY .answer { font-family: '"" + defaultFont + ""' }\n"";            	
            }
    	}
    	return mCustomDefaultFontCss;
    }


    private boolean isQuestionDisplayed() {
        switch (mPrefHideQuestionInAnswer) {
            case HQIA_DO_HIDE:
                return false;

            case HQIA_DO_SHOW:
                return true;

            case HQIA_CARD_MODEL:
                return (Model.getModel(AnkiDroidApp.deck(), mCurrentCard.getCardModelId(), false).getCardModel(
                        mCurrentCard.getCardModelId()).isQuestionInAnswer());

            default:
                return true;
        }
    }


    public static Card getEditorCard() {
        return sEditorCard;
    }

    private boolean isHebrewFixEnabled() {
        return mPrefFixHebrew;
    }


    /**
     * Adds a div html tag around the contents to have an indication, where answer/question is displayed
     *
     * @param content
     * @param isAnswer if true then the class attribute is set to ""answer"", ""question"" otherwise.
     * @return
     */
    private static String enrichWithQADiv(String content, boolean isAnswer) {
        StringBuffer sb = new StringBuffer();
        sb.append(""<div class=\"""");
        if (isAnswer) {
            sb.append(ANSWER_CLASS);
        } else {
            sb.append(QUESTION_CLASS);
        }
        sb.append(""\"">"");
        sb.append(content);
        sb.append(""</div>"");
        return sb.toString();
    }
    
    /**
     * Parses content in question and answer to see, whether someone has hard coded
     * the font size in a card layout. If this is so, then the font size must be
     * replaced with one corrected by the relative font size.
     * If a relative CSS unit measure is used (e.g. 'em'), then only hierarchy in 'span' tag is taken into account.
     * @param content
     * @param percentage - the relative font size percentage defined in preferences
     * @return
     */
    private String recalculateHardCodedFontSize(String content, int percentage) {
    	if (null == content || 0 == content.trim().length()) {
    		return """";
    	}
    	StringBuilder sb = new StringBuilder(content);
    	
    	boolean fontSizeFound = true; //whether the previous loop found a valid font-size attribute
    	int spanTagDepth = 0; //to find out whether a relative CSS unit measure is within another one
    	int outerRelativeSpanTagDepth = 100; //the hierarchy depth of the current outer relative span
    	int start = 0;
    	int posSpan = 0;
    	int posFontSize = 0;
    	int posUnit = 0;
    	int intSize; //for absolute css measurement values
    	double doubleSize; //for relative css measurement values
    	boolean isRelativeUnit = true; //true if em or %
    	String sizeS;
    	
    	//formatter for decimal numbers
    	DecimalFormatSymbols symbols = new DecimalFormatSymbols();
		symbols.setDecimalSeparator('.');
		DecimalFormat dFormat = new DecimalFormat(""0.##"", symbols);

    	while (fontSizeFound) {
    		posFontSize = sb.indexOf(""font-size:"", start);
    		if (-1 == posFontSize) {
    			fontSizeFound = false;
    			continue;
    		} else {
    			//check whether </span> are found and decrease spanTagDepth accordingly
        		posSpan = sb.indexOf(""</span>"", start);
        		while (-1 != posSpan && posSpan < posFontSize) {
        			spanTagDepth -= 1;
        			posSpan = sb.indexOf(""</span>"", posSpan + 7);
        		}
    			start = posFontSize + 10;
    			for (int a = 0; a < ABSOLUTE_CSS_UNITS.length; a++) {
    				posUnit = sb.indexOf(ABSOLUTE_CSS_UNITS[a], start);
    				if (-1 != posUnit) {
    					isRelativeUnit = false;
    					break;
    				}
    			}
        		if (-1 == posUnit) {
        			for (int a = 0; a < RELATIVE_CSS_UNITS.length; a++) {
        				posUnit = sb.indexOf(RELATIVE_CSS_UNITS[a], start);
        				if (-1 != posUnit) {
        					isRelativeUnit = true;
        					break;
        				}
        			}
        		}
    		}
    		if (-1 == posUnit) {
    			//only absolute and relative measures are taken into account. E.g. 'xx-small', 'inherit' etc. are not taken into account
    			fontSizeFound = false;
    			continue;
    		} else if (17 < (posUnit - posFontSize)) { //assuming max 1 blank and 5 digits
    			//only take into account if font-size measurement is close, because theoretically ""font-size:"" could be part of text
    			continue; 
    		} else {
    			spanTagDepth += 1; //because we assume that font-sizes always are declared in span tags
    			start = posUnit +3; // needs to be more than posPx due to decimals
    			sizeS = sb.substring(posFontSize + 10, posUnit).trim();
    			if (isRelativeUnit) {
    				if (outerRelativeSpanTagDepth >= spanTagDepth) {
    					outerRelativeSpanTagDepth = spanTagDepth;
		    			try {
		    				doubleSize = dFormat.parse(sizeS).doubleValue();
		    			} catch (ParseException e) {
		    				continue; //ignore this one
		    			}
		    			doubleSize = doubleSize * percentage / 100;
		    			sizeS = dFormat.format(doubleSize);
    				} //else do nothing as relative sizes within relative sizes should not be changed
    			} else {
	    			try {
	    				intSize = Integer.parseInt(sizeS);
	    			} catch (NumberFormatException e) {
	    				start = posFontSize + 10;
	    				continue; //ignore this one
	    			}
	    			intSize = intSize * percentage / 100;
	    			sizeS = Integer.toString(intSize);
    			}
	    		sb.replace(posFontSize + 10, posUnit, sizeS);
    		}
    	}
    	return sb.toString();
    }
    
    /**
     * 
     * @return true if the AnkiDroid preference for writing answer is true and if the Anki Deck CardLayout specifies a field to query
     */
    private final boolean typeAnswer() {
    	if (mPrefWriteAnswers && null != comparedFieldAnswer) {
    		return true;
    	}
    	return false;
    }


    /**
     * Calculates a dynamic font size depending on the length of the contents taking into account that the input string
     * contains html-tags, which will not be displayed and therefore should not be taken into account.
     *
     * @param htmlContents
     * @return font size respecting MIN_DYNAMIC_FONT_SIZE and MAX_DYNAMIC_FONT_SIZE
     */
    private static int calculateDynamicFontSize(String htmlContent) {
        // Replace each <br> with 15 spaces, each <hr> with 30 spaces, then
        // remove all html tags and spaces
        String realContent = htmlContent.replaceAll(""\\<br.*?\\>"", "" "");
        realContent = realContent.replaceAll(""\\<hr.*?\\>"", "" "");
        realContent = realContent.replaceAll(""\\<.*?\\>"", """");
        realContent = realContent.replaceAll(""&nbsp;"", "" "");
        return Math.max(DYNAMIC_FONT_MIN_SIZE,
                DYNAMIC_FONT_MAX_SIZE - (int) (realContent.length() / DYNAMIC_FONT_FACTOR));
    }


    private void unblockControls() {
        mCardFrame.setEnabled(true);
        mFlipCard.setEnabled(true);

        switch (mCurrentEase) {
            case Card.EASE_FAILED:
                mEase1.setClickable(true);
                mEase2.setEnabled(true);
                mEase3.setEnabled(true);
                mEase4.setEnabled(true);
                break;

            case Card.EASE_HARD:
                mEase1.setEnabled(true);
                mEase2.setClickable(true);
                mEase3.setEnabled(true);
                mEase4.setEnabled(true);
                break;

            case Card.EASE_MID:
                mEase1.setEnabled(true);
                mEase2.setEnabled(true);
                mEase3.setClickable(true);
                mEase4.setEnabled(true);
                break;

            case Card.EASE_EASY:
                mEase1.setEnabled(true);
                mEase2.setEnabled(true);
                mEase3.setEnabled(true);
                mEase4.setClickable(true);
                break;

            default:
                mEase1.setEnabled(true);
                mEase2.setEnabled(true);
                mEase3.setEnabled(true);
                mEase4.setEnabled(true);
                break;
        }

        if (mPrefTimer) {
            mCardTimer.setEnabled(true);
        }

        if (mPrefWhiteboard) {
            mWhiteboard.setEnabled(true);
        }

        if (typeAnswer()) {
            mAnswerField.setEnabled(true);
        }
        mTouchLayer.setVisibility(View.VISIBLE);
    }


    private void blockControls() {
        mCardFrame.setEnabled(false);
        mFlipCard.setEnabled(false);
        mTouchLayer.setVisibility(View.INVISIBLE);

        switch (mCurrentEase) {
            case Card.EASE_FAILED:
                mEase1.setClickable(false);
                mEase2.setEnabled(false);
                mEase3.setEnabled(false);
                mEase4.setEnabled(false);
                break;

            case Card.EASE_HARD:
                mEase1.setEnabled(false);
                mEase2.setClickable(false);
                mEase3.setEnabled(false);
                mEase4.setEnabled(false);
                break;

            case Card.EASE_MID:
                mEase1.setEnabled(false);
                mEase2.setEnabled(false);
                mEase3.setClickable(false);
                mEase4.setEnabled(false);
                break;

            case Card.EASE_EASY:
                mEase1.setEnabled(false);
                mEase2.setEnabled(false);
                mEase3.setEnabled(false);
                mEase4.setClickable(false);
                break;

            default:
                mEase1.setEnabled(false);
                mEase2.setEnabled(false);
                mEase3.setEnabled(false);
                mEase4.setEnabled(false);
                break;
        }

        if (mPrefTimer) {
            mCardTimer.setEnabled(false);
        }

        if (mPrefWhiteboard) {
            mWhiteboard.setEnabled(false);
        }

        if (typeAnswer()) {
            mAnswerField.setEnabled(false);
        }
    }


    private int getAvailableWidthInCard() {
        // The width available is equals to
        // the screen's width divided by the default scale factor used by the WebView, because this scale factor will be
        // applied later
        // and minus the padding
        int availableWidth = (int) (AnkiDroidApp.getDisplayWidth() / mScaleInPercent) - TOTAL_WIDTH_PADDING;
        // Log.i(AnkiDroidApp.TAG, ""availableWidth = "" + availableWidth);
        return availableWidth;
    }


    /**
     * Select Text in the webview and automatically sends the selected text to the clipboard.
     * From http://cosmez.blogspot.com/2010/04/webview-emulateshiftheld-on-android.html
     */
    private void selectAndCopyText() {
        try {
            KeyEvent shiftPressEvent = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT, 0, 0);
            shiftPressEvent.dispatch(mCard);
            shiftPressEvent.isShiftPressed();
            mIsSelecting = true;
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }


    public boolean getRefreshWebview() {
      	  	mCustomFontFiles = Utils.getCustomFonts(getBaseContext());
		if (mCustomFontFiles.length != 0) {
			return true;
		}
		for (String s : new String[] {""nook""}) {
			if  (android.os.Build.DEVICE.indexOf(s) != -1 || android.os.Build.MODEL.indexOf(s) != -1) {
				return true;
			}
		}
		return false;
    }


    /**
     * Setup media.
     * Try to detect if we're using dropbox and set the mediaPrefix accordingly. Then set the media directory.
     * @param deck The deck that we've just opened
     */
    public static String setupMedia(Deck deck) {
        String mediaLoc = deck.getVar(""mediaLocation"");
        if (mediaLoc != null) {
            mediaLoc = mediaLoc.replace(""\\"", ""/"");
            if (mediaLoc.contains(""/Dropbox/Public/Anki"")) {
                // We're using dropbox
                deck.setMediaPrefix(AnkiDroidApp.getDropboxDir());
            }
        }
        return deck.mediaDir();
    }

    
    private String applyFixForHebrew(String text) {
        Matcher m = sHebrewPattern.matcher(text);
        StringBuffer sb = new StringBuffer();
        while (m.find()) {
            String hebrewText = m.group();
            // Some processing before we reverse the Hebrew text
            // 1. Remove all Hebrew vowels as they cannot be displayed properly
            Matcher mv = sHebrewVowelsPattern.matcher(hebrewText);
            hebrewText = mv.replaceAll("""");
            // 2. Flip open parentheses, brackets and curly brackets with closed ones and vice-versa
            // Matcher mp = sBracketsPattern.matcher(hebrewText);
            // StringBuffer sbg = new StringBuffer();
            // int bracket[] = new int[1];
            // while (mp.find()) {
            //     bracket[0] = mp.group().codePointAt(0);
            //     if ((bracket[0] & 0x28) == 0x28) {
            //         // flip open/close ( and )
            //         bracket[0] ^= 0x01;
            //     } else if (bracket[0] == 0x5B || bracket[0] == 0x5D || bracket[0] == 0x7B || bracket[0] == 0x7D) {
            //         // flip open/close [, ], { and }
            //         bracket[0] ^= 0x06;
            //     }
            //     mp.appendReplacement(sbg, new String(bracket, 0, 1));
            // }
            // mp.appendTail(sbg);
            // hebrewText = sbg.toString();
            // for (int i = 0; i < hebrewText.length(); i++) {
            //     // Log.i(AnkiDroidApp.TAG, ""flipped brackets: "" + hebrewText.codePointAt(i));
            // }
            // 3. Reverse all numerical groups (so when they get reversed again they show LTR)
            // Matcher mn = sNumeralsPattern.matcher(hebrewText);
            // sbg = new StringBuffer();
            // while (mn.find()) {
            //     StringBuffer sbn = new StringBuffer(m.group());
            //     mn.appendReplacement(sbg, sbn.reverse().toString());
            // }
            // mn.appendTail(sbg);

            // for (int i = 0; i < sbg.length(); i++) {
            //     // Log.i(AnkiDroidApp.TAG, ""LTR numerals: "" + sbg.codePointAt(i));
            // }
            // hebrewText = sbg.toString();//reverse().toString();
            m.appendReplacement(sb, hebrewText); 
        }
        m.appendTail(sb);
        return sb.toString();
    }


    private void executeCommand(int which) {
    	switch(which) {
    	case GESTURE_NOTHING:
    		break;
    	case GESTURE_ANSWER_EASE1:
			if (sDisplayAnswer) {
				answerCard(Card.EASE_FAILED);
			} else {
		        displayCardAnswer();
			}
    		break;
    	case GESTURE_ANSWER_EASE2:
			if (sDisplayAnswer) {
				answerCard(Card.EASE_HARD);
			} else {
		        displayCardAnswer();
			}    		
    		break;
    	case GESTURE_ANSWER_EASE3:
			if (sDisplayAnswer) {
				answerCard(Card.EASE_MID);
			} else {
		        displayCardAnswer();
			}
    		break;
    	case GESTURE_ANSWER_EASE4:
			if (sDisplayAnswer) {
				answerCard(Card.EASE_EASY);
			} else {
		        displayCardAnswer();
			}
    		break;
    	case GESTURE_ANSWER_RECOMMENDED:
			if (sDisplayAnswer) {
				if (mCurrentCard.isRev()) {
					answerCard(Card.EASE_MID);
				} else {
					answerCard(Card.EASE_HARD);
				}
			} else {
				displayCardAnswer();
			}
    		break;
    	case GESTURE_ANSWER_BETTER_THAN_RECOMMENDED:
			if (sDisplayAnswer) {
				if (mCurrentCard.isRev()) {
					answerCard(Card.EASE_EASY);
				} else {
					answerCard(Card.EASE_MID);
				}
			}
    		break;
    	case GESTURE_EXIT:
       	 	closeReviewer(false);
    		break;
    	case GESTURE_UNDO:
    		if (AnkiDroidApp.deck().undoAvailable()) {
    			setNextCardAnimation(true);
        		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));    			
    		}
    		break;
    	case GESTURE_REDO:
    		if (AnkiDroidApp.deck().redoAvailable()) {
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REDO, mUpdateCardHandler, new DeckTask.TaskData(UPDATE_CARD_SHOW_QUESTION,
                        AnkiDroidApp.deck(), mCurrentCard.getId(), false));    			
    		}
    		break;
    	case GESTURE_EDIT:
        	editCard();
    		break;
    	case GESTURE_MARK:
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD, mMarkCardHandler, new DeckTask.TaskData(0,
                    AnkiDroidApp.deck(), mCurrentCard));
    		break;
    	case GESTURE_LOOKUP:
    		lookUpOrSelectText();
    		break;
    	case GESTURE_BURY:
        	setNextCardAnimation(false);
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_BURY_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
                    AnkiDroidApp.deck(), mCurrentCard));
    		break;
    	case GESTURE_SUSPEND:
        	setNextCardAnimation(false);
    		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD, mAnswerCardHandler, new DeckTask.TaskData(0,
                    AnkiDroidApp.deck(), mCurrentCard));
    		break;
    	case GESTURE_DELETE:
    		showDeleteCardDialog();
    		break;
    	case GESTURE_CLEAR_WHITEBOARD:
            if (mPrefWhiteboard) {            	
        		mWhiteboard.clear();
            }
    		break;
    	}
    }

    // ----------------------------------------------------------------------------
    // INNER CLASSES
    // ----------------------------------------------------------------------------

    /**
     * Provides a hook for calling ""alert"" from javascript. Useful for debugging your javascript.
     */
    public final class AnkiDroidWebChromeClient extends WebChromeClient {
        @Override
        public boolean onJsAlert(WebView view, String url, String message, JsResult result) {
            // Log.i(AnkiDroidApp.TAG, message);
            result.confirm();
            return true;
        }
    }

    public final class JavaScriptInterface {

        JavaScriptInterface() { }


        /**
         * This is not called on the UI thread. Send a message that will be handled on the UI thread.
         */
        public void playSound(String soundPath) {
            Message msg = Message.obtain();
            msg.obj = soundPath;
            mHandler.sendMessage(msg);
        }
    }


    private String nextInterval(int ease) {
        Resources res = getResources();

        if (ease == 1){
        	return res.getString(R.string.soon);
        } else {
        	return Utils.fmtTimeSpan(mCurrentCard.nextInterval(mCurrentCard, ease) * 86400, Utils.TIME_FORMAT_DEFAULT);
        }
    }


    private void closeReviewer(boolean saveDeck) {
	mTimeoutHandler.removeCallbacks(mShowAnswerTask);
	mTimeoutHandler.removeCallbacks(mShowQuestionTask);
	mTimerHandler.removeCallbacks(removeChosenAnswerText);
	longClickHandler.removeCallbacks(longClickTestRunnable);
	longClickHandler.removeCallbacks(startSelection);

    	setOutAnimation(true);    		
    	if (saveDeck) {
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_DECK, mSaveAndResetDeckHandler, new DeckTask.TaskData(AnkiDroidApp.deck(), 0));
    	} else {
    		finish();
    	}
    }
    
    /** Fixing bug 720: <input> focus, thanks to pablomouzo on android issue 7189*/
    class MyWebView extends WebView {

    	public MyWebView(Context context) {
    		super(context);
    	}

    	@Override
    	public boolean onCheckIsTextEditor() {
    		if (mInputWorkaround) {
        		return true;
    		} else {
        		return super.onCheckIsTextEditor();    			
    		}
    	}
    }

    class MyGestureDetector extends SimpleOnGestureListener {
     	private boolean mIsXScrolling = false;
     	private boolean mIsYScrolling = false;

    	@Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            if (mGesturesEnabled) {
        		try {
        			if (e2.getY() - e1.getY() > StudyOptions.sSwipeMinDistance && Math.abs(velocityY) > StudyOptions.sSwipeThresholdVelocity && Math.abs(e1.getX() - e2.getX()) < StudyOptions.sSwipeMaxOffPath && !mIsYScrolling) {
                        // down
        				executeCommand(mGestureSwipeDown);
       		        } else if (e1.getY() - e2.getY() > StudyOptions.sSwipeMinDistance && Math.abs(velocityY) > StudyOptions.sSwipeThresholdVelocity && Math.abs(e1.getX() - e2.getX()) < StudyOptions.sSwipeMaxOffPath && !mIsYScrolling) {
                        // up
        				executeCommand(mGestureSwipeUp);
       		        } else if (e2.getX() - e1.getX() > StudyOptions.sSwipeMinDistance && Math.abs(velocityX) > StudyOptions.sSwipeThresholdVelocity && Math.abs(e1.getY() - e2.getY()) < StudyOptions.sSwipeMaxOffPath && !mIsXScrolling && !mIsSelecting) {
                      	 // right
       		        	executeCommand(mGestureSwipeRight);
                    } else if (e1.getX() - e2.getX() > StudyOptions.sSwipeMinDistance && Math.abs(velocityX) > StudyOptions.sSwipeThresholdVelocity && Math.abs(e1.getY() - e2.getY()) < StudyOptions.sSwipeMaxOffPath && !mIsXScrolling && !mIsSelecting) {
                    	// left
                    	executeCommand(mGestureSwipeLeft);
                    }
               		mIsXScrolling = false;        		
               		mIsYScrolling = false;        		
                 }
                 catch (Exception e) {
                   	Log.e(AnkiDroidApp.TAG, ""onFling Exception = "" + e.getMessage());
                 }            	
            }
            return false;
        }

    	@Override
    	public boolean onDoubleTap(MotionEvent e) {
    		if (mGesturesEnabled) {
        		executeCommand(mGestureDoubleTap);            	
			}
    		return true;
    	}

    	
    	@Override
    	public boolean onSingleTapUp(MotionEvent e) {
            if(mTouchStarted) {
                longClickHandler.removeCallbacks(longClickTestRunnable);
            	mTouchStarted = false;
            }
            return false;
    	}

    	
    	@Override
    	public boolean onSingleTapConfirmed(MotionEvent e) {
    		if (mGesturesEnabled && !mIsSelecting) {
    			int height = mCard.getHeight();
    			int width = mCard.getWidth();
    			float posX = e.getX();
    			float posY = e.getY();
    			if (posX > posY / height * width) {
    				if (posY > height * (1 - posX / width)) {
    		       		executeCommand(mGestureTapRight);
    				} else {
    		       		executeCommand(mGestureTapTop);
    				}
    			} else {
    				if (posY > height * (1 - posX / width)) {
    		       		executeCommand(mGestureTapBottom);    					
    				} else {
    		       		executeCommand(mGestureTapLeft);
    				}    				
    			}
 			}
    		mIsSelecting = false;
    		if (mPrefTextSelection && mClipboard != null) {
                if (clipboardGetText().length() != 0 && Lookup.isAvailable()) {
                	if (mLookUpIcon.getVisibility() != View.VISIBLE) {
            			mLookUpIcon.setVisibility(View.VISIBLE);
                        mLookUpIcon.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, mFadeDuration, 0));                		
                	}
                } else {
                	if (mLookUpIcon.getVisibility() == View.VISIBLE) {
                        mLookUpIcon.setVisibility(View.GONE);
                        mLookUpIcon.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, mFadeDuration, 0));                		
                	}
                }                
    		}
    		return false;
    	}
    	
        @Override
        public boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) {
        	if (mCard.getScrollY() != 0) {
        		mIsYScrolling = true;        		
        	}
        	if (mCard.getScrollX() != 0) {
        		mIsXScrolling = true;
        	}  
            return super.onScroll(e1, e2, distanceX, distanceY);
        }

    }
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (gestureDetector.onTouchEvent(event))
	        return true;
	    else
	    	return false;
    }


	@Override
	public void buttonPressed(ButtonEvent arg0) {
		// Log.d(""Zeemote"",""Button pressed, id: ""+arg0.getButtonID());
	}


	@Override
	public void buttonReleased(ButtonEvent arg0) {
		// Log.d(""Zeemote"",""Button released, id: ""+arg0.getButtonID());
		Message msg = Message.obtain();
		msg.what = MSG_ZEEMOTE_BUTTON_A + arg0.getButtonID(); //Button A = 0, Button B = 1...
		if ((msg.what >= MSG_ZEEMOTE_BUTTON_A) && (msg.what <= MSG_ZEEMOTE_BUTTON_D)) { //make sure messages from future buttons don't get throug
			this.ZeemoteHandler.sendMessage(msg);
		}
		if (arg0.getButtonID()==-1)
		{
			msg.what = MSG_ZEEMOTE_BUTTON_D+arg0.getButtonGameAction();
			if ((msg.what >= MSG_ZEEMOTE_STICK_UP) && (msg.what <= MSG_ZEEMOTE_STICK_RIGHT)) { //make sure messages from future buttons don't get throug
				this.ZeemoteHandler.sendMessage(msg);
			}
		}
	}
}
",True,19,63,0,0,3,32
26,com.ichi2.anki.Statistics.java,"/*****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.				                 *
 *									 		                                             *
 * This program is free software; you can redistribute it and/or modify it under 	     *
 * the terms of the GNU General Public License as published by the Free Software 	     *
 * Foundation; either version 3 of the License, or (at your option) any later            *
 * version.										                                         *
 *											                                             *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY       *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A       *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.              *
 * 											                                             *
 * You should have received a copy of the GNU General Public License along with          *
 * this program. If not, see <http://www.gnu.org/licenses/>.                             *
 ****************************************************************************************/

package com.ichi2.anki;

import java.util.Map.Entry;

import com.ichi2.themes.Themes;

import android.content.ContentValues;
import android.content.Context;
import android.content.res.Resources;

public class Statistics {
    public static String[] axisLabels = { """", """" };
    public static String sTitle;
    public static String[] Titles;

    public static double[] xAxisData;
    public static double[][] sSeriesList;

    private static Deck sDeck;
    private static ContentValues sDeckSummaryValues;
    public static int sType;

    public static int sZoom = 0;

    /**
	* Types
	*/    
	public static final int TYPE_DUE = 0; 
	public static final int TYPE_CUMULATIVE_DUE = 1; 
	public static final int TYPE_INTERVALS = 2; 
	public static final int TYPE_REVIEWS = 3;
	public static final int TYPE_REVIEWING_TIME = 4;
	public static final int TYPE_DECK_SUMMARY = 5;


    public static void initVariables(Context context, int type, int period, String title) {
        Resources res = context.getResources();
        if (type == TYPE_DECK_SUMMARY) {
        	sDeckSummaryValues = new ContentValues();
        	return;
        }
        sType = type;
        sTitle = title;
        axisLabels[0] = res.getString(R.string.statistics_period_x_axis);
        axisLabels[1] = res.getString(R.string.statistics_period_y_axis);
        if (type <= TYPE_CUMULATIVE_DUE) {
            Titles = new String[3];
            Titles[0] = res.getString(R.string.statistics_young_cards);
            Titles[1] = res.getString(R.string.statistics_mature_cards);
            Titles[2] = res.getString(R.string.statistics_failed_cards);
            sSeriesList = new double[3][period];
            xAxisData = xAxisData(period, false);
        } else if (type == TYPE_REVIEWS) {
        	Titles = new String[3];
            Titles[0] = res.getString(R.string.statistics_new_cards);
            Titles[1] = res.getString(R.string.statistics_young_cards);
            Titles[2] = res.getString(R.string.statistics_mature_cards);
            sSeriesList = new double[3][period];
            xAxisData = xAxisData(period, true);
        } else {
            Titles = new String[1];
            sSeriesList = new double[1][period];
            switch (type) {
            	case TYPE_INTERVALS:
                    xAxisData = xAxisData(period, false);
            		break;
            	case TYPE_REVIEWING_TIME:
                    xAxisData = xAxisData(period, true);
                    axisLabels[1] = context.getResources().getString(R.string.statistics_period_x_axis_minutes);
            		break;
            }
        }
        sZoom = 0;
    }


    public static boolean refreshDeckStatistics(Context context, Deck deck, int type, int period, String title) {
        initVariables(context, type, period, title);
        sDeck = deck;
        if (type == TYPE_DECK_SUMMARY) {
        	sDeckSummaryValues = sDeck.getDeckSummary();
        	return sDeckSummaryValues != null ? true : false;
        } else {
            sSeriesList = getSeriesList(context, type, period);
        	return sSeriesList != null ? true : false;        	
        }
    }


    public static boolean refreshAllDeckStatistics(Context context, String[] deckPaths, int type, int period, String title) {
        initVariables(context, type, period, title);
        Deck currentDeck = AnkiDroidApp.deck();
        String currentDeckPath = null;
        if (currentDeck != null) {
        	currentDeckPath = currentDeck.getDeckPath();
        }
    	for (String dp : deckPaths) {
    		if (currentDeckPath != null && dp.equals(currentDeckPath)) {
    			sDeck = currentDeck;
    		} else {
                sDeck = Deck.openDeck(dp);    			
    		}
            if (sDeck == null) {
                continue;
            }
    		if (type == TYPE_DECK_SUMMARY) {
    			sDeckSummaryValues.put(""title"", context.getResources().getString(R.string.deck_summary_all_decks));
    			ContentValues values = sDeck.getDeckSummary();
    			if (values == null) {
                    continue;
                }
    			for (Entry<String, Object> entry : values.valueSet()) {
    				if (entry.getKey().equals(""deckAge"")) {
    					if (sDeckSummaryValues.containsKey(entry.getKey())) {
    						sDeckSummaryValues.put(entry.getKey(), Math.max(sDeckSummaryValues.getAsInteger(entry.getKey()), (Integer) entry.getValue()));
    					} else {
    						sDeckSummaryValues.put(entry.getKey(), (Integer) entry.getValue());   
    					}
    				} else {
    					if (sDeckSummaryValues.containsKey(entry.getKey())) {
    						sDeckSummaryValues.put(entry.getKey(), sDeckSummaryValues.getAsInteger(entry.getKey()) + (Integer) entry.getValue());
    					} else {
    						sDeckSummaryValues.put(entry.getKey(), (Integer) entry.getValue());   
    					}    					
    				}
				}
    		} else {
                double[][] seriesList;
                seriesList = getSeriesList(context, type, period);
                sDeck.closeDeck(false);
                for (int i = 0; i < sSeriesList.length; i++) {
                    for (int j = 0; j < period; j++) {
                    	sSeriesList[i][j] += seriesList[i][j];
                    }        	
                }    			
    		}
    	}
        if (type == TYPE_DECK_SUMMARY) {
        	return sDeckSummaryValues != null ? true : false;
        } else {
        	return sSeriesList != null ? true : false;        	
        }
    }


    public static double[][] getSeriesList(Context context, int type, int period) {
    	double[][] seriesList;
        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(sDeck.getDeckPath());
        ankiDB.getDatabase().beginTransaction();
        try {
        	switch (type) {
            case TYPE_DUE:
            	seriesList = new double[3][period];
            	seriesList[0] = getCardsByDue(period, false);
            	seriesList[1] = getMatureCardsByDue(period, false);
            	seriesList[2] = getFailedCardsByDue(period, false);
            	seriesList[0][1] += seriesList[2][1];
            	seriesList[1][0] += seriesList[2][0];
            	seriesList[1][1] += seriesList[2][1];
            	break;
            case TYPE_CUMULATIVE_DUE:
            	seriesList = new double[3][period];
            	seriesList[0] = getCardsByDue(period, true);
            	seriesList[1] = getMatureCardsByDue(period, true);
            	seriesList[2] = getFailedCardsByDue(period, true);
            	seriesList[1][0] += seriesList[2][0];
                for (int i = 1; i < period; i++) {
                	seriesList[0][i] += seriesList[2][i];
                	seriesList[1][i] += seriesList[2][i];
                }
            	break;
            case TYPE_INTERVALS:
            	seriesList = new double[1][period];
            	seriesList[0] = getCardsByInterval(period);
            	break;
            case TYPE_REVIEWS:
            	seriesList = getReviews(period);
            	break;
            case TYPE_REVIEWING_TIME:
            	seriesList = new double[1][period];
                seriesList[0] = getReviewTime(period);
            	break;
            default:
            	seriesList = null;
        	}
        	ankiDB.getDatabase().setTransactionSuccessful();
        } finally {
            ankiDB.getDatabase().endTransaction();
        }
        return seriesList;
    }


    public static double[] xAxisData(int length, boolean backwards) {
        double series[] = new double[length];
        if (backwards) {
            for (int i = 0; i < length; i++) {
                series[i] = i - length + 1;
            }
        } else {
            for (int i = 0; i < length; i++) {
                series[i] = i;
            }
        }
        return series;
    }


    public static double[] getCardsByDue(int length, boolean cumulative) {
        double series[] = new double[length];
        series[0] = sDeck.getDueCount();
        for (int i = 1; i < length; i++) {
            int count = 0;
            count = sDeck.getNextDueCards(i);
            if (cumulative) {
                series[i] = count + series[i - 1];
            } else {
                series[i] = count;
            }
        }
        return series;
    }


    public static double[] getMatureCardsByDue(int length, boolean cumulative) {
        double series[] = new double[length];
        for (int i = 0; i < length; i++) {
            int count = 0;
            count = sDeck.getNextDueMatureCards(i);
            if (cumulative && i > 0) {
                series[i] = count + series[i - 1];
            } else {
                series[i] = count;
            }
        }
        return series;
    }


    public static double[] getFailedCardsByDue(int length, boolean cumulative) {
        double series[] = new double[length];
        series[0] = sDeck.getFailedSoonCount();
        series[1] = sDeck.getFailedDelayedCount();
        if (cumulative) {
            series[1] += series[0];
            for (int i = 2; i < length; i++) {
                series[i] = series[1];
            }
        }
        return series;
    }


    public static double[][] getReviews(int length) {
        double series[][] = new double[3][length];
        for (int i = 0; i < length; i++) {
        	int result[] = sDeck.getDaysReviewed(i - length + 1);
            series[0][i] = result[0];
            series[1][i] = result[1];
            series[2][i] = result[2];
        }
        return series;
    }


    public static double[] getReviewTime(int length) {
        double series[] = new double[length];
        for (int i = 0; i < length; i++) {
            series[i] = sDeck.getReviewTime(i - length + 1) / 60;
        }
        return series;
    }


    public static double[] getCardsByInterval(int length) {
        double series[] = new double[length];
        for (int i = 0; i < length; i++) {
            series[i] = sDeck.getCardsByInterval(i);
        }
        return series;
    }


    public static double getFraction(double numerator, double denominator) {
    	if (denominator == 0) {
    		return 0;
    	} else {
    		return numerator / denominator;
    	}
    }


    private static String getHtmlDeckSummary(Context context) {
    	Resources res = context.getResources();

       	int cardCount = sDeckSummaryValues.getAsInteger(""cardCount"");
       	int matureCount = sDeckSummaryValues.getAsInteger(""matureCount"");
       	int unseenCount = sDeckSummaryValues.getAsInteger(""unseenCount"");
       	int youngCount = cardCount - unseenCount - matureCount;
       	int intervalSum = sDeckSummaryValues.getAsInteger(""intervalSum"");
       	int repsMatCount = sDeckSummaryValues.getAsInteger(""repsMatCount"");
       	int repsMatNoCount = sDeckSummaryValues.getAsInteger(""repsMatNoCount"");
       	int repsYoungCount = sDeckSummaryValues.getAsInteger(""repsYoungCount"");
       	int repsYoungNoCount = sDeckSummaryValues.getAsInteger(""repsYoungNoCount"");
       	int repsFirstCount = sDeckSummaryValues.getAsInteger(""repsFirstCount"");
       	int repsFirstNoCount = sDeckSummaryValues.getAsInteger(""repsFirstNoCount"");
       	int reviewsLastWeek = sDeckSummaryValues.getAsInteger(""reviewsLastWeek"");
       	int newsLastWeek = sDeckSummaryValues.getAsInteger(""newsLastWeek"");
       	int reviewsLastMonth = sDeckSummaryValues.getAsInteger(""reviewsLastMonth"");
       	int newsLastMonth = sDeckSummaryValues.getAsInteger(""newsLastMonth"");
       	int reviewsLastYear = sDeckSummaryValues.getAsInteger(""reviewsLastYear"");
       	int newsLastYear = sDeckSummaryValues.getAsInteger(""newsLastYear"");
       	int deckAge = sDeckSummaryValues.getAsInteger(""deckAge"");
       	int revTomorrow = sDeckSummaryValues.getAsInteger(""revTomorrow"");
       	int newTomorrow = sDeckSummaryValues.getAsInteger(""newTomorrow"");
       	int timeTomorrow = sDeckSummaryValues.getAsInteger(""timeTomorrow"");

    	StringBuilder builder = new StringBuilder();
       	builder.append(""<html><body text=\""#FFFFFF\"">"");
       	builder.append(res.getString(R.string.deck_summary_deck_age, deckAge)).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_cards)).append("" <b>"").append(Integer.toString(cardCount)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_facts)).append("" <b>"").append(Integer.toString(sDeckSummaryValues.getAsInteger(""factCount""))).append(""</b><br>"");
       	builder.append(""<br><b>"").append(res.getString(R.string.deck_summary_card_age)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_cards_mature)).append("" <b>"").append(Integer.toString(matureCount)).append(""</b> ("").append(String.format(""%.1f &#37;"", 100.0d * getFraction(matureCount, cardCount))).append("")<br>"");
       	builder.append(res.getString(R.string.deck_summary_cards_young)).append("" <b>"").append(Integer.toString(youngCount)).append(""</b> ("").append(String.format(""%.1f &#37;"", 100.0d * getFraction(youngCount, cardCount))).append("")<br>"");
       	builder.append(res.getString(R.string.deck_summary_cards_unseen)).append("" <b>"").append(Integer.toString(unseenCount)).append(""</b> ("").append(String.format(""%.1f &#37;"", 100.0d * getFraction(unseenCount, cardCount))).append("")<br>"");
       	builder.append(res.getString(R.string.deck_summary_average_interval, getFraction(intervalSum, (cardCount - unseenCount)))).append(""<br>"");
       	builder.append(""<br><b>"").append(res.getString(R.string.deck_summary_answers_correct)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_answers_mature, 100.0d * getFraction(repsMatCount - repsMatNoCount, repsMatCount), ""&#37;"", repsMatCount - repsMatNoCount, repsMatCount)).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_answers_young, 100.0d * getFraction(repsYoungCount - repsYoungNoCount, repsYoungCount), ""&#37;"", repsYoungCount - repsYoungNoCount, repsYoungCount)).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_answers_firstseen, 100.0d * getFraction(repsFirstCount - repsFirstNoCount, repsFirstCount), ""&#37;"", repsFirstCount - repsFirstNoCount, repsFirstCount)).append(""<br>"");
       	builder.append(""<br><b>"").append(res.getString(R.string.deck_summary_forecast)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_tomorrow_due, revTomorrow)).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_tomorrow_new, newTomorrow)).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_tomorrow_time, timeTomorrow)).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_finished_in, (int)Math.round(getFraction(unseenCount, newTomorrow)))).append(""<br>"");
       	builder.append(""<br><b>"").append(res.getString(R.string.deck_summary_average_week)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_reviews)).append("" "").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(reviewsLastWeek, Math.min((double)deckAge, 7.0d)))).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_news)).append("" "").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(newsLastWeek, Math.min((double)deckAge, 7.0d)))).append(""<br>"");
       	builder.append(""<br><b>"").append(res.getString(R.string.deck_summary_average_month)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_reviews)).append("" "").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(reviewsLastMonth, Math.min((double)deckAge, 30.0d)))).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_news)).append("" "").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(newsLastMonth, Math.min((double)deckAge, 30.0d)))).append(""<br>"");
       	builder.append(""<br><b>"").append(res.getString(R.string.deck_summary_average_year)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_reviews)).append("" "").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(reviewsLastYear, Math.min((double)deckAge, 365.0d)))).append(""<br>"");
       	builder.append(res.getString(R.string.deck_summary_news)).append("" "").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(newsLastYear, Math.min((double)deckAge, 365.0d)))).append(""<br>"");
       	builder.append(""<br><b>"").append(res.getString(R.string.deck_summary_average_total)).append(""</b><br>"");
       	builder.append(res.getString(R.string.deck_summary_reviews)).append("" "").append(res.getString(R.string.deck_summary_cards_per_day, getFraction(repsMatCount + repsYoungCount + repsFirstCount, deckAge))).append(""<br>"");
       	builder.append(""</body></html>"");
       	return builder.toString();
    }


    public static void showDeckSummary(Context context) {
        Themes.htmlOkDialog(context, sDeckSummaryValues.containsKey(""title"") ? sDeckSummaryValues.getAsString(""title"") : sDeck.getDeckName(), getHtmlDeckSummary(context)).show();
    }
}
",True,69,63,0,0,5,26
27,com.ichi2.anki.AnkiDroidWidgetMedium.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import com.tomgibara.android.veecheck.util.PrefSettings;

import android.app.PendingIntent;
import android.app.Service;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.graphics.Color;
import android.net.Uri;
import android.os.IBinder;
import android.text.SpannableString;
import android.text.SpannableStringBuilder;
import android.text.Spanned;
import android.text.style.ForegroundColorSpan;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;

import java.util.ArrayList;
import java.util.List;

public class AnkiDroidWidgetMedium extends AppWidgetProvider {

    private static BroadcastReceiver mMountReceiver = null;
    private static boolean remounted = false;

    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        // Log.i(AnkiDroidApp.TAG, ""MediumWidget: onUpdate"");
        WidgetStatus.update(context);
    }

    @Override
    public void onEnabled(Context context) {
        super.onEnabled(context);
        // Log.i(AnkiDroidApp.TAG, ""MediumWidget: Widget enabled"");
        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
        preferences.edit().putBoolean(""widgetMediumEnabled"", true).commit();
    }

    @Override
    public void onDisabled(Context context) {
        super.onDisabled(context);
        // Log.i(AnkiDroidApp.TAG, ""MediumWidget: Widget disabled"");
        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
        preferences.edit().putBoolean(""widgetMediumEnabled"", false).commit();
    }

    public static class UpdateService extends Service {
        /** If this action is used when starting the service, it will move to the next due deck. */
        private static final String ACTION_NEXT = ""org.ichi2.anki.AnkiDroidWidget.NEXT"";

        /**
         * If this action is used when starting the service, it will move to the previous due
         * deck.
         */
        private static final String ACTION_PREV = ""org.ichi2.anki.AnkiDroidWidget.PREV"";

        /**
         * When received, this action is ignored by the service.
         * <p>
         * It is used to associate with elements that at some point need to have a pending intent
         * associated with them, but want to clear it off afterwards.
         */
        private static final String ACTION_IGNORE = ""org.ichi2.anki.AnkiDroidWidget.IGNORE"";

        /**
         * If this action is used when starting the service, it will open the current due deck.
         */
        private static final String ACTION_OPEN = ""org.ichi2.anki.AnkiDroidWidget.OPEN"";

        /**
         * Update the state of the widget.
         */
        public static final String ACTION_UPDATE = ""org.ichi2.anki.AnkiDroidWidget.UPDATE"";

        /**
         * The current due deck that is shown in the widget.
         *
         * <p>This value is kept around until as long as the service is running and it is shared
         * by all instances of the widget.
         */
        private int currentDueDeck = 0;

        /** The cached information about the decks with due cards. */
        private List<DeckStatus> dueDecks;
        /** The cached number of total due cards. */
        private int dueCardsCount;

        private CharSequence getDeckStatusString(DeckStatus deck) {
            SpannableStringBuilder sb = new SpannableStringBuilder();

            SpannableString red = new SpannableString(Integer.toString(deck.mFailedCards));
            red.setSpan(new ForegroundColorSpan(Color.RED), 0, red.length(),
                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

            SpannableString black = new SpannableString(Integer.toString(deck.mDueCards));
            black.setSpan(new ForegroundColorSpan(Color.BLACK), 0, black.length(),
                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

            SpannableString blue = new SpannableString(Integer.toString(deck.mNewCards));
            blue.setSpan(new ForegroundColorSpan(Color.BLUE), 0, blue.length(),
                    Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

            sb.append(red);
            sb.append("" "");
            sb.append(black);
            sb.append("" "");
            sb.append(blue);

            return sb;
        }


        @Override
        public void onStart(Intent intent, int startId) {
            // Log.i(AnkiDroidApp.TAG, ""MediumWidget: OnStart"");

            boolean updateDueDecksNow = true;
            if (intent != null) {
                // Bound checks will be done when updating the widget below.
                if (ACTION_NEXT.equals(intent.getAction())) {
                    currentDueDeck++;
                    // Do not update the due decks on next action.
                    // This causes latency.
                    updateDueDecksNow = false;
                } else if (ACTION_PREV.equals(intent.getAction())) {
                    currentDueDeck--;
                    // Do not update the due decks on prev action.
                    // This causes latency.
                    updateDueDecksNow = false;
                } else if (ACTION_IGNORE.equals(intent.getAction())) {
                    updateDueDecksNow = false;
                } else if (ACTION_OPEN.equals(intent.getAction())) {
                    startActivity(StudyOptions.getLoadDeckIntent(this, intent.getData().getPath()));
                    updateDueDecksNow = false;
                } else if (ACTION_UPDATE.equals(intent.getAction())) {
                    // Updating the widget is done below for all actions.
                    // Log.d(AnkiDroidApp.TAG, ""AnkiDroidWidget.UpdateService: UPDATE"");
                }
            }
            RemoteViews updateViews = buildUpdate(this, updateDueDecksNow);

            ComponentName thisWidget = new ComponentName(this, AnkiDroidWidgetMedium.class);
            AppWidgetManager manager = AppWidgetManager.getInstance(this);
            manager.updateAppWidget(thisWidget, updateViews);
        }

        private RemoteViews buildUpdate(Context context, boolean updateDueDecksNow) {
            // Log.i(AnkiDroidApp.TAG, ""buildUpdate"");

            // Resources res = context.getResources();
            RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget);

            // Add a click listener to open Anki from the icon.
            // This should be always there, whether there are due cards or not.
            Intent ankiDroidIntent = new Intent(context, StudyOptions.class);
            ankiDroidIntent.setAction(Intent.ACTION_MAIN);
            ankiDroidIntent.addCategory(Intent.CATEGORY_LAUNCHER);
            PendingIntent pendingAnkiDroidIntent =
                PendingIntent.getActivity(context, 0, ankiDroidIntent, 0);
            updateViews.setOnClickPendingIntent(R.id.anki_droid_logo,
                    pendingAnkiDroidIntent);

            if (!AnkiDroidApp.isSdCardMounted()) {
                updateViews.setTextViewText(R.id.anki_droid_title,
                    context.getText(R.string.sdcard_missing_message));
                updateViews.setTextViewText(R.id.anki_droid_name, """");
                updateViews.setTextViewText(R.id.anki_droid_status, """");
                if (mMountReceiver == null) {
                	mMountReceiver = new BroadcastReceiver() {
                        @Override
                        public void onReceive(Context context, Intent intent) {
                            String action = intent.getAction();
                        	if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                                // Log.i(AnkiDroidApp.TAG, ""mMountReceiver - Action = Media Mounted"");
                                if (remounted) {
                                    WidgetStatus.update(getBaseContext());                                	
                                	remounted = false;
                                    if (mMountReceiver != null) {
                                        unregisterReceiver(mMountReceiver);
                                    }
                                } else {
                                	remounted = true;
                                }
                            }
                        }
                    };
                    IntentFilter iFilter = new IntentFilter();
                    iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
                    iFilter.addDataScheme(""file"");
                    registerReceiver(mMountReceiver, iFilter);
                }
                return updateViews;
            }

            // If we do not have a cached version, always update.
            if (dueDecks == null || updateDueDecksNow) {
                // Build a list of decks with due cards.
                // Also compute the total number of cards due.
                updateDueDecks();
            }

            if (dueCardsCount > 0) {
                Resources resources = getResources();
                String decksText = resources.getQuantityString(
                        R.plurals.widget_decks, dueDecks.size(), dueDecks.size());
                String text = resources.getQuantityString(
                        R.plurals.widget_cards_in_decks_due, dueCardsCount, dueCardsCount, decksText);
                updateViews.setTextViewText(R.id.anki_droid_title, text);
                // If the current due deck is out of bound, go back to the first one.
                if (currentDueDeck < 0 || currentDueDeck > dueDecks.size() - 1) {
                    currentDueDeck = 0;
                }
                // Show the name and info from the current due deck.
                DeckStatus deckStatus = dueDecks.get(currentDueDeck);
                updateViews.setTextViewText(R.id.anki_droid_name, deckStatus.mDeckName);
                updateViews.setTextViewText(R.id.anki_droid_status,
                    getDeckStatusString(deckStatus));
                PendingIntent openPendingIntent = getOpenPendingIntent(context,
                    deckStatus.mDeckPath);
                updateViews.setOnClickPendingIntent(R.id.anki_droid_name, openPendingIntent);
                updateViews.setOnClickPendingIntent(R.id.anki_droid_status, openPendingIntent);
                // Enable or disable the prev and next buttons.
                if (currentDueDeck > 0) {
                    updateViews.setImageViewResource(R.id.anki_droid_prev, R.drawable.widget_left_arrow);
                    updateViews.setOnClickPendingIntent(R.id.anki_droid_prev, getPrevPendingIntent(context));
                } else {
                    updateViews.setImageViewResource(R.id.anki_droid_prev, R.drawable.widget_left_arrow_disabled);
                    updateViews.setOnClickPendingIntent(R.id.anki_droid_prev, getIgnoredPendingIntent(context));
                }
                if (currentDueDeck < dueDecks.size() - 1) {
                    updateViews.setImageViewResource(R.id.anki_droid_next, R.drawable.widget_right_arrow);
                    updateViews.setOnClickPendingIntent(R.id.anki_droid_next, getNextPendingIntent(context));
                } else {
                    updateViews.setImageViewResource(R.id.anki_droid_next, R.drawable.widget_right_arrow_disabled);
                    updateViews.setOnClickPendingIntent(R.id.anki_droid_next, getIgnoredPendingIntent(context));
                }
                updateViews.setViewVisibility(R.id.anki_droid_name, View.VISIBLE);
                updateViews.setViewVisibility(R.id.anki_droid_status, View.VISIBLE);
                updateViews.setViewVisibility(R.id.anki_droid_next, View.VISIBLE);
                updateViews.setViewVisibility(R.id.anki_droid_prev, View.VISIBLE);
            } else {
                // No card is currently due.
                updateViews.setTextViewText(R.id.anki_droid_title,
                    context.getString(R.string.widget_no_cards_due));
                updateViews.setTextViewText(R.id.anki_droid_name, """");
                updateViews.setTextViewText(R.id.anki_droid_status, """");
                updateViews.setViewVisibility(R.id.anki_droid_name, View.INVISIBLE);
                updateViews.setViewVisibility(R.id.anki_droid_status, View.INVISIBLE);
                updateViews.setViewVisibility(R.id.anki_droid_next, View.INVISIBLE);
                updateViews.setViewVisibility(R.id.anki_droid_prev, View.INVISIBLE);
            }

            return updateViews;
        }


        private void updateDueDecks() {
            // Fetch the deck information, sorted by due cards
            DeckStatus[] decks = WidgetStatus.fetch(getBaseContext());

            if (dueDecks == null) {
                dueDecks = new ArrayList<DeckStatus>();
            } else {
                dueDecks.clear();
            }
            dueCardsCount = 0;
            for (DeckStatus deck : decks) {
                if (deck.mDueCards + deck.mFailedCards + deck.mNewCards > 0) {
                  dueCardsCount += deck.mDueCards + deck.mFailedCards + deck.mNewCards;
                  dueDecks.add(deck);
                }
            }
        }

        /**
         * Returns a pending intent that updates the widget to show the next deck.
         */
        private PendingIntent getNextPendingIntent(Context context) {
            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
            ankiDroidIntent.setAction(ACTION_NEXT);
            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
        }

        /**
         * Returns a pending intent that updates the widget to show the previous deck.
         */
        private PendingIntent getPrevPendingIntent(Context context) {
            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
            ankiDroidIntent.setAction(ACTION_PREV);
            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
        }

        /**
         * Returns a pending intent that is ignored by the service.
         */
        private PendingIntent getIgnoredPendingIntent(Context context) {
            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
            ankiDroidIntent.setAction(ACTION_IGNORE);
            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
        }

        /**
         * Returns a pending intent that opens the current deck.
         */
        private PendingIntent getOpenPendingIntent(Context context, String deckPath) {
            Intent ankiDroidIntent = new Intent(context, UpdateService.class);
            ankiDroidIntent.setAction(ACTION_OPEN);
            ankiDroidIntent.setData(Uri.parse(""file://"" + deckPath));
            return PendingIntent.getService(context, 0, ankiDroidIntent, 0);
        }

        @Override
        public IBinder onBind(Intent arg0) {
            // Log.i(AnkiDroidApp.TAG, ""onBind"");
            return null;
        }
    }
}
",False,15,63,0,0,5,27
28,com.ichi2.anki.DeckStatus.java,"package com.ichi2.anki;

/**
 * Simple class to hold the current status of a deck.
 */
public class DeckStatus {
    public String mDeckPath;
    public String mDeckName;
    public int mNewCards;
    public int mDueCards;
    public int mFailedCards;
    public int mEta;
    public int mTime;

    public DeckStatus(String deckPath, String deckName, int newCards, int dueCards,
            int failedCards, int eta, int time) {
        mDeckPath = deckPath;
        mDeckName = deckName;
        mNewCards = newCards;
        mDueCards = dueCards;
        mFailedCards = failedCards;
        mEta = eta;
        mTime = time;
    }
}",False,68,56,5,17,0,0
29,com.ichi2.anki.ReadText.java,"/****************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.util.ArrayList;
import java.util.Locale;

import com.ichi2.themes.StyledDialog;

import android.speech.tts.TextToSpeech;
import android.content.Context;
import android.content.DialogInterface;
import android.content.res.Resources;
import android.util.Log;

public class ReadText {
    private static TextToSpeech mTts;
    private static ArrayList<String[]> availableTtsLocales = new ArrayList<String[]>();
    private static String mTextToSpeak;
    private static Context mReviewer;
    private static String mDeckFilename;
    private static long mModelId;
    private static long mCardModelId;
    private static int mQuestionAnswer;
    public static final String NO_TTS = ""0"";

    //private boolean mTtsReady = false;

    
    private static void speak(String loc) {
    	int result = mTts.setLanguage(new Locale(loc));
        if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
        	Log.e(AnkiDroidApp.TAG, ""Error loading locale ""+ loc.toString());
        } else {
          	mTts.speak(mTextToSpeak, TextToSpeech.QUEUE_FLUSH, null);
        }    	
    }


    public static void setLanguageInformation(long modelId, long cardModelId) {
    	mModelId = modelId;
    	mCardModelId = cardModelId;    	
    }


    public static String getLanguage(int qa) {
        return MetaDB.getLanguage(mReviewer, mDeckFilename,  mModelId, mCardModelId, qa);
    }


    public static void textToSpeech(String text, int qa) {
    	mTextToSpeak = text;
    	mQuestionAnswer = qa;

    	String language = getLanguage(mQuestionAnswer);
        if (availableTtsLocales.isEmpty()) {
	    	Locale[] systemLocales = Locale.getAvailableLocales();
			for (Locale loc : systemLocales) {
				if (mTts.isLanguageAvailable(loc) == TextToSpeech.LANG_COUNTRY_AVAILABLE) {
					availableTtsLocales.add(new String[]{loc.getISO3Language(), loc.getDisplayName()});
				}
			}			
		}

        // Check, if stored language is available
        for (int i = 0; i < availableTtsLocales.size(); i++) {
    		if (language.equals(NO_TTS)) {
    		    return;
    		} else if (language.equals(availableTtsLocales.get(i)[0])) {
    			speak(language);
    			return;
    		}
		}

        // Otherwise ask 
        Resources res = mReviewer.getResources();
        StyledDialog.Builder builder = new StyledDialog.Builder(mReviewer);
        if (availableTtsLocales.size() == 0) {
        	builder.setTitle(res.getString(R.string.no_tts_available_title));
            builder.setMessage(res.getString(R.string.no_tts_available_message));
            builder.setIcon(android.R.drawable.ic_dialog_alert);
            builder.setPositiveButton(res.getString(R.string.ok), null);
        } else {
        	ArrayList<CharSequence> dialogItems = new ArrayList<CharSequence>();
        	final ArrayList<String> dialogIds = new ArrayList<String>();
            builder.setTitle(R.string.select_locale_title);
            // Add option: ""no tts""
            dialogItems.add(res.getString(R.string.tts_no_tts));
            dialogIds.add(NO_TTS);
            for (int i = 0; i < availableTtsLocales.size(); i++) {
                dialogItems.add(availableTtsLocales.get(i)[1]);
                dialogIds.add(availableTtsLocales.get(i)[0]);
            }
            String[] items = new String[dialogItems.size()];
            dialogItems.toArray(items);

            builder.setItems(items, new DialogInterface.OnClickListener() {
    			@Override
    			public void onClick(DialogInterface dialog, int which) {
    				MetaDB.storeLanguage(mReviewer, mDeckFilename,  mModelId, mCardModelId, mQuestionAnswer, dialogIds.get(which));
    				speak(dialogIds.get(which));
    			}
            });        	
        }
        builder.create().show();
    }


    public static void initializeTts(Context context, String deckFilename) {
    	mReviewer = context;
    	mDeckFilename = deckFilename;
    	mTts = new TextToSpeech(context, new TextToSpeech.OnInitListener() {
			@Override
			public void onInit(int status) {
				// TODO: check if properly initialized (does not work yet)
				if (status != TextToSpeech.SUCCESS) {
		            int result = mTts.setLanguage(Locale.US);
		            if (result == TextToSpeech.LANG_MISSING_DATA ||
		                result == TextToSpeech.LANG_NOT_SUPPORTED) {
		            } else {
		            	Log.e(AnkiDroidApp.TAG, ""TTS initialized and set to US"" );
		            }
		        } else {
		        	Log.e(AnkiDroidApp.TAG, ""Initialization of TTS failed"" );
		        }
			}
        });            	
    }


    public static void releaseTts() {
        if (mTts != null) {
            mTts.stop();
            mTts.shutdown();
        }    	
    }


    public static void stopTts() {
        if (mTts != null) {
            mTts.stop();
        }
    }
}
",False,20,63,0,0,5,24
30,com.ichi2.anki.CardHistoryEntry.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;

/**
 * Review history of a card.
 */
public class CardHistoryEntry {

    // BEGIN: SQL table columns
    private long mCardId;
//    private double mTime;
    private double mLastInterval;
    private double mNextInterval;
    private int mEase;
    private double mDelay;
    private double mLastFactor;
    private double mNextFactor;
    private double mReps;
    private double mThinkingTime;
    private double mYesCount;
    private double mNoCount;
    // END: SQL table columns

    private Deck mDeck;


    /**
     * Constructor.
     */
    public CardHistoryEntry(Deck deck, Card card, int ease, double delay) {
        mDeck = deck;

        if (card == null) {
            return;
        }

        mCardId = card.getId();
        mLastInterval = card.getLastInterval();
        mNextInterval = card.getInterval();
        mLastFactor = card.getLastFactor();
        mNextFactor = card.getFactor();
        mReps = card.getReps();
        mYesCount = card.getYesCount();
        mNoCount = card.getNoCount();
        mEase = ease;
        mDelay = delay;
        mThinkingTime = card.thinkingTime();
    }


    /**
     * Write review history to the database.
     */
    public void writeSQL() {
        ContentValues values = new ContentValues();
        values.put(""cardId"", mCardId);
        values.put(""lastInterval"", mLastInterval);
        values.put(""nextInterval"", mNextInterval);
        values.put(""ease"", mEase);
        values.put(""delay"", mDelay);
        values.put(""lastFactor"", mLastFactor);
        values.put(""nextFactor"", mNextFactor);
        values.put(""reps"", mReps);
        values.put(""thinkingTime"", mThinkingTime);
        values.put(""yesCount"", mYesCount);
        values.put(""noCount"", mNoCount);
        values.put(""time"", Utils.now());

        AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).insert(mDeck, ""reviewHistory"", null, values);
    }
}
",False,91,63,0,0,5,24
31,com.ichi2.anki.StudyOptions.java,"/***************************************************************************************
* This program is free software; you can redistribute it and/or modify it under *
* the terms of the GNU General Public License as published by the Free Software *
* Foundation; either version 3 of the License, or (at your option) any later *
* version. *
* *
* This program is distributed in the hope that it will be useful, but WITHOUT ANY *
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A *
* PARTICULAR PURPOSE. See the GNU General Public License for more details. *
* *
* You should have received a copy of the GNU General Public License along with *
* this program. If not, see <http://www.gnu.org/licenses/>. *
****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.res.Configuration;
import android.content.res.Resources;
import android.database.sqlite.SQLiteException;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;
import android.view.GestureDetector;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewTreeObserver;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.view.inputmethod.InputMethodManager;
import android.webkit.WebView;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.ToggleButton;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anim.ViewAnimation;
import com.ichi2.anki.DeckTask.TaskData;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.compat.Compat;
import com.ichi2.compat.CompatV11;
import com.ichi2.compat.CompatV3;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;
import com.zeemote.zc.Controller;
import com.zeemote.zc.event.ButtonEvent;
import com.zeemote.zc.event.IButtonListener;
import com.zeemote.zc.ui.android.ControllerAndroidUi;
import com.zeemote.zc.util.JoystickToButtonAdapter;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;

public class StudyOptions extends Activity implements IButtonListener {
	
    /**
* Default database.
*/
    public static final String OPT_DB = ""com.ichi2.anki.deckFilename"";

    /**
* Filename of the sample deck to load
*/
    private static final String SAMPLE_DECK_NAME = ""tutorial.anki"";

    /**
* Menus
*/
    private static final int MENU_OPEN = 1;
    private static final int MENU_SYNC = 3;
    private static final int MENU_PREFERENCES = 5;
    private static final int MENU_ADD_FACT = 6;
    private static final int MENU_MORE_OPTIONS = 7;
    private static final int MENU_ROTATE = 8;
    private static final int MENU_ZEEMOTE = 9;

    /**
* Available options performed by other activities
*/
    private static final int PICK_DECK_REQUEST = 0;
    private static final int PREFERENCES_UPDATE = 1;
    private static final int REQUEST_REVIEW = 2;
    private static final int DOWNLOAD_PERSONAL_DECK = 3;
    private static final int DOWNLOAD_SHARED_DECK = 4;
    private static final int REPORT_ERROR = 5;
    private static final int ADD_FACT = 6;
    private static final int BROWSE_CARDS = 7;
    private static final int STATISTICS = 8;
    private static final int LOG_IN = 9;

    public static final int RESULT_RESTART = 100;
    public static final int RESULT_CLOSE = 101;
    public static final int RESULT_RELOAD_DECK = 102;
    public static final int RESULT_DONT_RELOAD_DECK = 103;

    /**
* Constants for selecting which content view to display
*/
    private static final int CONTENT_NO_DECK = 0;
    private static final int CONTENT_STUDY_OPTIONS = 1;
    private static final int CONTENT_CONGRATS = 2;
    private static final int CONTENT_DECK_NOT_LOADED = 3;
    private static final int CONTENT_SESSION_COMPLETE = 4;
    public static final int CONTENT_NO_EXTERNAL_STORAGE = 5;


    /** Startup Mode choices */
    public static final int SUM_STUDY_OPTIONS = 0;
    public static final int SUM_DECKPICKER = 1;
    public static final int SUM_DECKPICKER_ON_FIRST_START = 2;


    public static final String EXTRA_DECK = ""deck"";

    private static final int DIALOG_NO_CONNECTION = 0;
    private static final int DIALOG_USER_NOT_LOGGED_IN = 1;
    private static final int DIALOG_CONNECTION_ERROR = 2;
    private static final int DIALOG_SYNC_LOG = 3;
    private static final int DIALOG_NO_SPACE_LEFT = 4;
    private static final int DIALOG_BACKUP_ERROR = 5;
    private static final int DIALOG_DECK_NOT_LOADED = 6;
    private static final int DIALOG_SYNC_CONFLICT_RESOLUTION = 7;
    private static final int DIALOG_WELCOME = 8;
    private static final int DIALOG_STATISTIC_TYPE = 9;
    private static final int DIALOG_STATISTIC_PERIOD = 10;
    private static final int DIALOG_SWAP_QA = 11;
    private static final int DIALOG_MORE = 12;
    private static final int DIALOG_TAGS = 13;
    private static final int DIALOG_LIMIT_SESSION = 14;
    private static final int DIALOG_DOWNLOAD_SELECTOR = 15;
    private static final int DIALOG_CRAM = 16;
    private static final int DIALOG_BACKUP_NO_SPACE_LEFT = 17;
    private static final int DIALOG_DB_ERROR = 18;
    private static final int DIALOG_SELECT_HELP = 19;

    private String mCurrentDialogMessage;

    private StyledDialog mNewVersionAlert;
    private StyledDialog mWelcomeAlert;
    
    /** Zeemote messages */
    private static final int MSG_ZEEMOTE_BUTTON_A = 0x110;
    private static final int MSG_ZEEMOTE_BUTTON_B = MSG_ZEEMOTE_BUTTON_A+1;
    private static final int MSG_ZEEMOTE_BUTTON_C = MSG_ZEEMOTE_BUTTON_A+2;
    private static final int MSG_ZEEMOTE_BUTTON_D = MSG_ZEEMOTE_BUTTON_A+3;
    private static final int MSG_ZEEMOTE_STICK_UP = MSG_ZEEMOTE_BUTTON_A+4;
    private static final int MSG_ZEEMOTE_STICK_DOWN = MSG_ZEEMOTE_BUTTON_A+5;
    private static final int MSG_ZEEMOTE_STICK_LEFT = MSG_ZEEMOTE_BUTTON_A+6;
    private static final int MSG_ZEEMOTE_STICK_RIGHT = MSG_ZEEMOTE_BUTTON_A+7;
    

    /**
* Download Manager Service stub
*/
    // private IDownloadManagerService mService = null;

    /**
* Broadcast that informs us when the sd card is about to be unmounted
*/
    private BroadcastReceiver mUnmountReceiver = null;

    private boolean mSdCardAvailable = AnkiDroidApp.isSdCardMounted();

    /**
* Preferences
*/
    private String mPrefDeckPath;
    private boolean mPrefStudyOptions;
    // private boolean deckSelected;
    private boolean mInDeckPicker;
    private boolean mInReviewer;
    private String mDeckFilename;
    private int mStartupMode;
    private boolean mSwipeEnabled;

    private int mCurrentContentView;

    public static int mNewDayStartsAt = 4;
    private long mLastTimeOpened;
    boolean mInvertedColors = false;
    boolean mSwap = false;
    String mLocale;
    private boolean mZeemoteEnabled;

    /**
* Alerts to inform the user about different situations
*/
    private ProgressDialog mProgressDialog;

	/*
	* Limit session dialog
	*/
    private EditText mEditSessionTime;
    private EditText mEditSessionQuestions;
    private CheckBox mSessionLimitCheckBox;
    private CheckBox mLimitTagsCheckBox;
    private CheckBox mLimitTagNewActiveCheckBox;
    private CheckBox mLimitTagNewInactiveCheckBox;
    private CheckBox mLimitTagRevActiveCheckBox;
    private CheckBox mLimitTagRevInactiveCheckBox;
    private TextView mLimitSessionTv1;
    private TextView mLimitSessionTv2;
    private TextView mLimitTagTv1;
    private TextView mLimitTagTv2;
    private TextView mLimitTagTv3;
    private TextView mLimitTagTv4;
    private TextView mLimitTagTv5;
    private TextView mLimitTagTv6;
    private String mLimitNewActive;
    private String mLimitNewInactive;
    private String mLimitRevActive;
    private String mLimitRevInactive;
    private HashSet<String> mSelectedTags;
    private String[] allTags;
    private int mSelectedLimitTagText;
    private static final int LIMIT_NEW_ACTIVE = 0;
    private static final int LIMIT_NEW_INACTIVE = 1;
    private static final int LIMIT_REV_ACTIVE = 2;
    private static final int LIMIT_REV_INACTIVE = 3;

    /*
* Cram related
*/
//    private StyledDialog mCramTagsDialog;
    private String allCramTags[];
    private HashSet<String> activeCramTags;
    private String cramOrder;
    private static final String[] cramOrderList = {""type, modified"", ""created"", ""random()""};

    /**
* UI elements for ""Study Options"" view
*/
    private View mStudyOptionsView;
    private View mStudyOptionsMain;
    private Button mButtonStart;
    private ToggleButton mToggleCram;
    private ToggleButton mToggleLimit;
    private TextView mTextDeckName;
    private LinearLayout mStatisticsField;
    private TextView mTextReviewsDue;
    private TextView mTextNewToday;
    private TextView mTextETA;
    private TextView mTextNewTotal;
    private TextView mHelp;
    private CheckBox mNightMode;
    private CheckBox mSwapQA;
    private Button mCardBrowser;
    private Button mStatisticsButton;

    /**
* UI elements for ""More Options"" dialog
*/
    private Spinner mSpinnerNewCardOrder;
    private Spinner mSpinnerNewCardSchedule;
    private Spinner mSpinnerRevCardOrder;
    private Spinner mSpinnerFailCardOption;
    private EditText mEditNewPerDay;
    private EditText mEditMaxFailCard;

    private CheckBox mCheckBoxPerDay;
    private CheckBox mCheckBoxSuspendLeeches;

    /**
* UI elements for ""No Deck"" view
*/
    private View mNoDeckView;
    private TextView mTextNoDeckTitle;
    private TextView mTextNoDeckMessage;

    /**
* UI elements for ""Congrats"" view
*/
    private View mCongratsView;
    private TextView mTextCongratsMessage;
    private Button mButtonCongratsLearnMore;
    private Button mButtonCongratsReviewEarly;
    private Button mButtonCongratsSyncDeck;
    private Button mButtonCongratsOpenOtherDeck;
    private Button mButtonCongratsFinish;

    /**
* UI elements for ""No External Storage Available"" view
*/
    private View mNoExternalStorageView;

    /**
* UI elements for ""Cram Tags"" view
*/
//    private ListView mCramTagsListView;
//    private Spinner mSpinnerCramOrder;

    /**
    * Swipe Detection
    */
	private GestureDetector gestureDetector;
	View.OnTouchListener gestureListener;

	private static final int SWIPE_MIN_DISTANCE_DIP = 65;
    private static final int SWIPE_MAX_OFF_PATH_DIP = 120;
    private static final int SWIPE_THRESHOLD_VELOCITY_DIP = 120;

	public static int sSwipeMinDistance;
	public static int sSwipeMaxOffPath;
	public static int sSwipeThresholdVelocity;

    /**
	* Backup
	*/
	File[] mBackups;
	public static final int MIN_FREE_SPACE = 10;

	/**
	* Statistics
	*/
	public static int mStatisticType;
    private int mStatisticBarsMax = 0;
    private int mStatisticBarsHeight;
    private View mBarsMax;
    private View mDailyBar;
    private View mMatureBar;
    private View mGlobalLimitFrame;
    private View mGlobalLimitBar;
    private View mGlobalMatLimitBar;
    private View mGlobalBar;
    private View mGlobalMatBar;
    private double mProgressTodayYes;
    private double mProgressMatureYes;
    private double mProgressMatureLimit;
    private double mProgressAllLimit;
    private double mProgressMature;
    private double mProgressAll;

    private boolean mIsClosing = false;
    private boolean mDeckNotAvailable = false;

    /** Used to perform operation in a platform specific way. */
    private Compat mCompat;
    
    /**
 	 * Zeemote controller
 	 */
	protected JoystickToButtonAdapter adapter;
 	ControllerAndroidUi controllerUi;

	private boolean mShowRepairDialog = false;

    /**
* Callbacks for UI events
*/
    private View.OnClickListener mButtonClickListener = new View.OnClickListener() {
        @Override
        public void onClick(View v) {
            switch (v.getId()) {
                case R.id.studyoptions_start:
                    openReviewer();
                    return;
                case R.id.studyoptions_cram:
                    if (mToggleCram.isChecked()) {
                        mToggleCram.setChecked(!mToggleCram.isChecked());
                        activeCramTags.clear();
                        cramOrder = cramOrderList[0];
                        showDialog(DIALOG_CRAM);
                    } else {
                        onCramStop();
                        resetAndUpdateValuesFromDeck();
                    }
                    return;
                case R.id.studyoptions_limit:
                    mToggleLimit.setChecked(!mToggleLimit.isChecked());
        	       	showDialog(DIALOG_LIMIT_SESSION);
                    return;
                case R.id.studyoptions_congrats_learnmore:
                	startLearnMore();
                	return;
                case R.id.studyoptions_congrats_reviewearly:
                	startEarlyReview();
                    return;
                case R.id.studyoptions_congrats_syncdeck:
                	syncDeck(null);
                    return;
                case R.id.studyoptions_congrats_open_other_deck:
                    openDeckPicker();
                    return;
                case R.id.studyoptions_congrats_finish:
                	finishCongrats();
                    return;
                case R.id.studyoptions_load_sample_deck:
                    loadSampleDeck();
                    return;
                case R.id.studyoptions_load_other_deck:
                    openDeckPicker();
                    return;
                case R.id.studyoptions_download_deck:
                	showDialog(DIALOG_DOWNLOAD_SELECTOR);
                	return;
                case R.id.studyoptions_card_browser:
                    openCardBrowser();
                    return;
                case R.id.studyoptions_statistics:
                	mStatisticType = -1;
                	showDialog(DIALOG_STATISTIC_TYPE);
                	return;
                case R.id.studyoptions_congrats_message:
                	mStatisticType = 0;
                	openStatistics(0);
                	return;
                case R.id.studyoptions_nodeck_message:
                	if (!mTextNoDeckTitle.getText().equals(getResources().getString(R.string.studyoptions_welcome_title))) {
                        startActivityForResult(
                                new Intent(StudyOptions.this, Preferences.class),
                                PREFERENCES_UPDATE);
                	} else {
                    	if (Utils.isIntentAvailable(StudyOptions.this, ""android.intent.action.VIEW"")) {
                    		Intent intent = new Intent(""android.intent.action.VIEW"", Uri.parse(getResources().getString(R.string.link_help)));
                    		startActivity(intent);
                    	} else {
                    		startActivity(new Intent(StudyOptions.this, About.class));
                    	}
                	}
                	return;
                case R.id.studyoptions_help:
                	showDialog(DIALOG_SELECT_HELP);
                    return;
                case R.id.studyoptions_limit_tag_tv2:
                    if (mLimitTagNewActiveCheckBox.isChecked()) {
                        mSelectedLimitTagText = LIMIT_NEW_ACTIVE;
                        showDialog(DIALOG_TAGS);
                    }
                    return;
                case R.id.studyoptions_limit_tag_tv3:
                    if (mLimitTagNewInactiveCheckBox.isChecked()) {
                        mSelectedLimitTagText = LIMIT_NEW_INACTIVE;
                        showDialog(DIALOG_TAGS);
                    }
                    return;
                case R.id.studyoptions_limit_tag_tv5:
                    if (mLimitTagRevActiveCheckBox.isChecked()) {
                        mSelectedLimitTagText = LIMIT_REV_ACTIVE;
                        showDialog(DIALOG_TAGS);
                    }
                    return;
                case R.id.studyoptions_limit_tag_tv6:
                    if (mLimitTagRevInactiveCheckBox.isChecked()) {
                        mSelectedLimitTagText = LIMIT_REV_INACTIVE;
                        showDialog(DIALOG_TAGS);
                    }
                    return;
                default:
                    return;
            }
        }
    };

    private CompoundButton.OnCheckedChangeListener mLimitTagCheckedChangeListener = new CompoundButton.OnCheckedChangeListener(){

        @Override
        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
            switch (buttonView.getId()) {
                case R.id.studyoptions_limit_tag_new_active_check:
                    mSelectedLimitTagText = LIMIT_NEW_ACTIVE;
                    break;
                case R.id.studyoptions_limit_tag_new_inactive_check:
                    mSelectedLimitTagText = LIMIT_NEW_INACTIVE;
                    break;
                case R.id.studyoptions_limit_tag_rev_active_check:
                    mSelectedLimitTagText = LIMIT_REV_ACTIVE;
                    break;
                case R.id.studyoptions_limit_tag_rev_inactive_check:
                    mSelectedLimitTagText = LIMIT_REV_INACTIVE;
                    break;
                default:
                    return;
            }
            if (isChecked) {
                showDialog(DIALOG_TAGS);
            } else {
                updateLimitTagText(mSelectedLimitTagText, """");
            }
            return;
        }

    };

	Handler ZeemoteHandler = new Handler() {
		public void handleMessage(Message msg){
			switch(msg.what){
			case MSG_ZEEMOTE_STICK_UP:
				//sendKey(KeyEvent.KEYCODE_DPAD_UP);
				break;
			case MSG_ZEEMOTE_STICK_DOWN:
				//sendKey(KeyEvent.KEYCODE_DPAD_DOWN);
				break;
			case MSG_ZEEMOTE_STICK_LEFT:
				//sendKey(KeyEvent.KEYCODE_DPAD_LEFT);
				break;
			case MSG_ZEEMOTE_STICK_RIGHT:
				//sendKey(KeyEvent.KEYCODE_DPAD_RIGHT);
				break;				
			case MSG_ZEEMOTE_BUTTON_A:
				//sendKey(KeyEvent.KEYCODE_ENTER);
				openReviewer();
				break;
			case MSG_ZEEMOTE_BUTTON_B:
				//sendKey(KeyEvent.KEYCODE_BACK);
	            if (mCurrentContentView == CONTENT_CONGRATS) {
	            	finishCongrats();
	            } else  {
	            	openDeckPicker();
	            } 
				break;
			case MSG_ZEEMOTE_BUTTON_C:
				sendKey(KeyEvent.KEYCODE_BACK);
				break;
			case MSG_ZEEMOTE_BUTTON_D:
				break;
			}
			super.handleMessage(msg);
		}
	};
    

    private Boolean isValidInt(String test) {
        try {
            Integer.parseInt(test);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }


    protected void sendKey(int keycode) {
	    
    	this.dispatchKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN,keycode));
		this.dispatchKeyEvent(new KeyEvent(KeyEvent.ACTION_UP,keycode));
		// Log.d(""Zeemote"",""dispatched key ""+keycode);
	}


	private Boolean isValidLong(String test) {
        try {
            Long.parseLong(test);
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }


    private DialogInterface.OnClickListener mDialogSaveListener = new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            Deck deck = AnkiDroidApp.deck();
            deck.setNewCardOrder(mSpinnerNewCardOrder.getSelectedItemPosition());
            deck.setNewCardSpacing(mSpinnerNewCardSchedule.getSelectedItemPosition());
            deck.setRevCardOrder(mSpinnerRevCardOrder.getSelectedItemPosition());
            // TODO: mSpinnerFailCardOption
            // FIXME: invalid entries set to zero(unlimited) for now, better to set to default?
            String maxFailText = mEditMaxFailCard.getText().toString();
            if (!maxFailText.equals(Integer.toString(deck.getFailedCardMax()))) {
                if (maxFailText.equals("""")) {
                        deck.setFailedCardMax(0);
                } else if (isValidInt(maxFailText)) {
                        deck.setFailedCardMax(Integer.parseInt(maxFailText));
                } else {
                        mEditMaxFailCard.setText(""0"");
                }
            }
            String inputText = mEditNewPerDay.getText().toString();
            if (!inputText.equals(Integer.toString(deck.getNewCardsPerDay()))) {
            	if (inputText.equals("""")) {
            		deck.setNewCardsPerDay(0);
            	} else if (isValidInt(inputText)) {
            		deck.setNewCardsPerDay(Integer.parseInt(inputText));
            	} else {
            		mEditNewPerDay.setText(""0"");
            	}
            	updateValuesFromDeck();
            }
            boolean perDayChanged = deck.getPerDay() ^ mCheckBoxPerDay.isChecked();
          	deck.setPerDay(mCheckBoxPerDay.isChecked());
          	deck.setSuspendLeeches(mCheckBoxSuspendLeeches.isChecked());
            dialog.dismiss();
            if (perDayChanged){
                deck.updateCutoff();
                resetAndUpdateValuesFromDeck();
            }
        }
    };


    @Override
    protected void onCreate(Bundle savedInstanceState) {
		if (!isTaskRoot()) {
			// Log.i(AnkiDroidApp.TAG, ""StudyOptions - onCreate: Detected multiple instance of this activity, closing it and return to root activity"");
	        Intent reloadIntent = new Intent(StudyOptions.this, StudyOptions.class);
	        reloadIntent.setAction(Intent.ACTION_MAIN);
	        reloadIntent.addCategory(Intent.CATEGORY_LAUNCHER);
	        reloadIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
			finish();
			startActivityIfNeeded(reloadIntent, 0);
		}

        Themes.applyTheme(this);
        super.onCreate(savedInstanceState);

        // Log.i(AnkiDroidApp.TAG, ""StudyOptions - OnCreate()"");

        if (hasErrorFiles()) {
            Intent i = new Intent(this, Feedback.class);
            startActivityForResult(i, REPORT_ERROR);
        }

        SharedPreferences preferences = restorePreferences();
        BackupManager.initBackup();
        registerExternalStorageListener();

        activeCramTags = new HashSet<String>();
        mSelectedTags = new HashSet<String>();

        initAllContentViews();

        Intent intent = getIntent();
        if (Intent.ACTION_VIEW.equalsIgnoreCase(intent.getAction())
                && intent.getDataString() != null) {
            mDeckFilename = Uri.parse(intent.getDataString()).getPath();
            // Log.i(AnkiDroidApp.TAG, ""onCreate - deckFilename from VIEW intent: "" + mDeckFilename);
        } else if (Intent.ACTION_MAIN.equalsIgnoreCase(intent.getAction())
                && intent.hasExtra(EXTRA_DECK)) {
            mDeckFilename = intent.getStringExtra(EXTRA_DECK);
            // Log.i(AnkiDroidApp.TAG, ""onCreate - deckFilename from MAIN intent: "" + mDeckFilename);
        } else if (savedInstanceState != null) {
            // Use the same deck as last time Ankidroid was used.
            mDeckFilename = savedInstanceState.getString(""deckFilename"");
            // Log.i(AnkiDroidApp.TAG, ""onCreate - deckFilename from savedInstanceState: "" + mDeckFilename);
        } else {
            // // Log.i(AnkiDroidApp.TAG, ""onCreate - "" + preferences.getAll().toString());
            mDeckFilename = preferences.getString(""deckFilename"", null);
            // Log.i(AnkiDroidApp.TAG, ""onCreate - deckFilename from preferences: "" + mDeckFilename);
        }
        if (!mSdCardAvailable) {
            showContentView(CONTENT_NO_EXTERNAL_STORAGE);
        } else {
            if (mDeckFilename == null || !new File(mDeckFilename).exists()) {
                showContentView(CONTENT_NO_DECK);
            } else {
            	if ((showDeckPickerOnStartup()) && (!hasErrorFiles())) {
            		openDeckPicker();
            	} else {
            		// Load previous deck.
            		loadPreviousDeck();
            	}
            }
        }

        gestureDetector = new GestureDetector(new MyGestureDetector());
       	gestureListener = new View.OnTouchListener() {
       		public boolean onTouch(View v, MotionEvent event) {
       			if (gestureDetector.onTouchEvent(event)) {
       				return true;
       			}
       			return false;
       		}
       	};

        if (getApiLevel() >= 11) {
            mCompat = new CompatV11();
        } else {
            mCompat = new CompatV3();
        }
        //Zeemote controller initialization
         
		 if (AnkiDroidApp.zeemoteController() == null) AnkiDroidApp.setZeemoteController(new Controller(Controller.CONTROLLER_1));     
		 controllerUi = new ControllerAndroidUi(this, AnkiDroidApp.zeemoteController());
		 com.zeemote.util.Strings zstrings = com.zeemote.util.Strings.getStrings();
		 if (zstrings.isLocaleAvailable(mLocale)){
			 // Log.d(""Zeemote"",""Zeemote locale ""+mLocale+"" is available. Setting."");
			 zstrings.setLocale(mLocale);
		 } else {
			 // Log.d(""Zeemote"",""Zeemote locale ""+mLocale+"" is not available."");
		 }
		 if (mZeemoteEnabled){
		 if (!AnkiDroidApp.zeemoteController().isConnected())
		 {
    		 // Log.d(""Zeemote"",""starting connection in onCreate"");
			 controllerUi.startConnectionProcess();
		 }
		}
    }


    /** Returns the API level of this device. */
    public static int getApiLevel() {
        try {
            return Integer.parseInt(Build.VERSION.SDK);
        } catch (NumberFormatException e) {
            // If there is an error, return the minimum supported version.
            return 3;
        }
    }


    @Override
    public void onConfigurationChanged(Configuration newConfig){
    	super.onConfigurationChanged(newConfig);
       	setLanguage(mLocale);
    	hideDeckInformation(false);
        boolean cramChecked = mToggleCram.isChecked();
        boolean limitChecked = mToggleLimit.isChecked();
        boolean limitEnabled = mToggleLimit.isEnabled();
        boolean nightModeChecekd = mNightMode.isChecked();
        boolean swapQA = mSwapQA.isChecked();
        int limitBarVisibility = View.GONE;
        if (mDailyBar != null) {
            limitBarVisibility = mGlobalLimitFrame.getVisibility();
        }

    	initAllContentViews();

    	updateValuesFromDeck();
    	showContentView();
        mToggleCram.setChecked(cramChecked);
        mToggleLimit.setChecked(limitChecked);
        mToggleLimit.setEnabled(limitEnabled);
        mNightMode.setChecked(nightModeChecekd);
        mSwapQA.setChecked(swapQA);
        if (mDailyBar != null) {
            mGlobalLimitFrame.setVisibility(limitBarVisibility);
        }
        showDeckInformation(false);
    }


    /**
* Registers an intent to listen for ACTION_MEDIA_EJECT notifications. The intent will call
* closeExternalStorageFiles() if the external media is going to be ejected, so applications can clean up any files
* they have open.
*/
    public void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String action = intent.getAction();
                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
                        // Log.i(AnkiDroidApp.TAG, ""mUnmountReceiver - Action = Media Eject"");
                        if (mIsClosing) {
                        	DeckTask.waitToFinish();
                        } else {
                        	closeOpenedDeck();                        	
                        }
                        showContentView(CONTENT_NO_EXTERNAL_STORAGE);
                        mSdCardAvailable = false;
                    } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                        // Log.i(AnkiDroidApp.TAG, ""mUnmountReceiver - Action = Media Mounted"");
                        mSdCardAvailable = true;
                        if (!mInDeckPicker) {
                            loadPreviousDeck();
                        }
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
            iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
            iFilter.addDataScheme(""file"");
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }


    @Override
    protected void onDestroy() {
    	super.onDestroy();
        // Log.i(AnkiDroidApp.TAG, ""StudyOptions - onDestroy()"");
		if (!isFinishing()) {
        	closeOpenedDeck();
	        MetaDB.closeDB();
		}
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
        }
        //Disconnect Zeemote if connected
        if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){
        	try {
        		// Log.d(""Zeemote"",""trying to disconnect in onDestroy..."");
        		AnkiDroidApp.zeemoteController().disconnect();
        	}
        	catch (IOException ex){
        		Log.e(""Zeemote"",""Error on zeemote disconnection in onDestroy: ""+ex.getMessage());
        	}
        }
    }


     @Override
     protected void onPause() {
         if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){ 
         	// Log.d(""Zeemote"",""Removing listener in onPause"");
         	AnkiDroidApp.zeemoteController().removeButtonListener(this);
         	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
     		adapter.removeButtonListener(this);
     		adapter = null;
         }
    	 
         super.onPause();
         // Update the widget when pausing this activity.
         if (!mInDeckPicker && !mInReviewer) {
             WidgetStatus.update(getBaseContext());
         }
     }


    @Override
	protected void onResume() {
    	super.onResume();
	      if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){
	    	  // Log.d(""Zeemote"",""Adding listener in onResume"");
	    	  AnkiDroidApp.zeemoteController().addButtonListener(this);
	      	  adapter = new JoystickToButtonAdapter();
	      	  AnkiDroidApp.zeemoteController().addJoystickListener(adapter);
	      	  adapter.addButtonListener(this);
	      }
	      if ((mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) && (mProgressDialog == null || !mProgressDialog.isShowing())) {
	    	  if (mTextDeckName.getVisibility() != View.VISIBLE) {
			      showDeckInformation(true);
	    	  } else {
	    	      updateValuesFromDeck();
	    	  }
	      }
	      // check for new day and reset deck if yes
	      if (Utils.isNewDay(PrefSettings.getSharedPrefs(getBaseContext()).getLong(""lastTimeOpened"", 0)) && (mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE)) {
	    	  BackupManager.initBackup();
	    	  if (!DeckTask.taskIsRunning()) {
		    	  displayProgressDialogAndLoadDeck();
	    	  }
	      }
	      BroadcastMessages.showDialog();
	}


	@Override
    public boolean onKeyDown(int keyCode, KeyEvent event)  {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            // Log.i(AnkiDroidApp.TAG, ""StudyOptions - onBackPressed()"");
            if (mCurrentContentView == CONTENT_CONGRATS) {
            	finishCongrats();
            } else if (mStartupMode == SUM_DECKPICKER) {
            	openDeckPicker();
            } else {
                closeStudyOptions();            	
            }
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }


    private void closeStudyOptions() {
    	closeStudyOptions(true);
    }
    private void closeStudyOptions(boolean closeDeck) {
		mIsClosing = true;
        MetaDB.closeDB();
        if (closeDeck && AnkiDroidApp.deck() != null && mSdCardAvailable) {
        	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK, new DeckTask.TaskListener() {
		        @Override
		        public void onPreExecute() {
		        }
		        @Override
		        public void onPostExecute(DeckTask.TaskData result) {
		        	mIsClosing = false;
		        }
		        @Override
		        public void onProgressUpdate(DeckTask.TaskData... values) {
		        }
			}, new DeckTask.TaskData(AnkiDroidApp.deck(), 0));
        }
        AnkiDroidApp.setDeck(null);
        mCompat.invalidateOptionsMenu(this);
        StudyOptions.this.finish();
    }


    private void restartApp() {
    	// restarts application in order to apply new themes or localisations
    	Intent i = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());
        if (AnkiDroidApp.deck() != null && mSdCardAvailable) {
        	AnkiDroidApp.deck().closeDeck();
        }
    	AnkiDroidApp.setDeck(null);
        mCompat.invalidateOptionsMenu(this);
        MetaDB.closeDB();
        StudyOptions.this.finish();
    	startActivity(i);
    }


    private void openReviewer() {
    	if (mCurrentContentView == CONTENT_STUDY_OPTIONS || mCurrentContentView == CONTENT_SESSION_COMPLETE) {
    		mInReviewer = true;
    		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
            reviewer.putExtra(""deckFilename"", mDeckFilename);
    		startActivityForResult(reviewer, REQUEST_REVIEW);
        	if (getApiLevel() > 4) {
       			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
        	}
    	} else if (mCurrentContentView == CONTENT_CONGRATS) {
    		startEarlyReview();
    	}
    }


    private void startEarlyReview() {
		Deck deck = AnkiDroidApp.deck();
        if (deck != null) {
    		mInReviewer = true;
            deck.setupReviewEarlyScheduler();
            deck.reset();
    		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
            reviewer.putExtra(""deckFilename"", mDeckFilename);
            startActivityForResult(reviewer, REQUEST_REVIEW);
        	if (getApiLevel() > 4) {
       			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
        	}
        }
    }


    private void startLearnMore() {
		Deck deck = AnkiDroidApp.deck();
        if (deck != null) {
    		mInReviewer = true;
            deck.setupLearnMoreScheduler();
            deck.reset();
    		Intent reviewer = new Intent(StudyOptions.this, Reviewer.class);
    		reviewer.putExtra(""deckFilename"", mDeckFilename);
        	startActivityForResult(reviewer, REQUEST_REVIEW);
    		if (getApiLevel() > 4) {
    			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
    		}
        }
    }


    private void loadPreviousDeck() {
        Intent deckLoadIntent = new Intent();
        deckLoadIntent.putExtra(OPT_DB, mDeckFilename);
        onActivityResult(PICK_DECK_REQUEST, RESULT_OK, deckLoadIntent);
    }


    private void closeOpenedDeck() {
        if (!mIsClosing && AnkiDroidApp.deck() != null && mSdCardAvailable) {
            AnkiDroidApp.deck().closeDeck();
            AnkiDroidApp.setDeck(null);
            mCompat.invalidateOptionsMenu(this);
        }
    }


    private boolean hasErrorFiles() {
        for (String file : this.fileList()) {
            if (file.endsWith("".stacktrace"")) {
                return true;
            }
        }

        return false;
    }


    private void initAllContentViews() {
        // The main study options view that will be used when there are reviews left.
        mStudyOptionsView = getLayoutInflater().inflate(R.layout.studyoptions, null);
        Themes.setContentStyle(mStudyOptionsView, Themes.CALLER_STUDYOPTIONS);

        mStudyOptionsMain = (View) mStudyOptionsView.findViewById(R.id.studyoptions_main);
        Themes.setWallpaper(mStudyOptionsMain);

        mTextDeckName = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_deck_name);
        Themes.setTitleStyle(mTextDeckName);

        mStatisticsField = (LinearLayout) mStudyOptionsView.findViewById(R.id.studyoptions_statistic_field);
        Themes.setTextViewStyle(mStatisticsField);

        Themes.setTitleStyle(mStudyOptionsView.findViewById(R.id.studyoptions_bottom));

        mButtonStart = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_start);
        mToggleCram = (ToggleButton) mStudyOptionsView.findViewById(R.id.studyoptions_cram);

        mToggleLimit = (ToggleButton) mStudyOptionsView.findViewById(R.id.studyoptions_limit);

        mCardBrowser = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_card_browser);
        mStatisticsButton = (Button) mStudyOptionsView.findViewById(R.id.studyoptions_statistics);

        mDailyBar = (View) mStudyOptionsView.findViewById(R.id.studyoptions_daily_bar);
        mMatureBar = (View) mStudyOptionsView.findViewById(R.id.studyoptions_mature_bar);
        mGlobalLimitFrame = (View) mStudyOptionsView.findViewById(R.id.studyoptions_global_limit_bars);
        mGlobalLimitBar = (View) mStudyOptionsView.findViewById(R.id.studyoptions_global_limit_bar);
        mGlobalMatLimitBar = (View) mStudyOptionsView.findViewById(R.id.studyoptions_global_mat_limit_bar);
        mGlobalBar = (View) mStudyOptionsView.findViewById(R.id.studyoptions_global_bar);
        mGlobalMatBar = (View) mStudyOptionsView.findViewById(R.id.studyoptions_global_mat_bar);
        mBarsMax = (View) mStudyOptionsView.findViewById(R.id.studyoptions_bars_max);
        if (mDailyBar != null) {
            ViewTreeObserver vto = mBarsMax.getViewTreeObserver();
            vto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
                @Override
                public void onGlobalLayout() {
                    mBarsMax.getViewTreeObserver().removeGlobalOnLayoutListener(this);
                    updateStatisticBars();
                }
            });
        }

        mTextReviewsDue = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_reviews_due);
        mTextReviewsDue.setText(""    "");
        mTextNewToday = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_new_today);
        mTextETA = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_eta);
        mTextNewTotal = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_new_total);
        mNightMode = (CheckBox) mStudyOptionsView.findViewById(R.id.studyoptions_night_mode);
        mNightMode.setChecked(mInvertedColors);
        mNightMode.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
            	@Override
            	public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
            		if (mInvertedColors != isChecked) {
            			mInvertedColors = isChecked;
                    	savePreferences(""invertedColors"");
            		}
            	}
            });
        mSwapQA = (CheckBox) mStudyOptionsView.findViewById(R.id.studyoptions_swap);
        mSwapQA.setChecked(mSwap);
        mSwapQA.setOnClickListener(new View.OnClickListener() {

        	@Override
            public void onClick(View view) {
            	if (mSwapQA.isChecked()) {
            		showDialog(DIALOG_SWAP_QA);
            	} else if (mSwap){
            		mSwap = false;
            		savePreferences(""swapqa"");
            	}
        		mSwapQA.setChecked(false);				
            }
        });
        
        mHelp = (TextView) mStudyOptionsView.findViewById(R.id.studyoptions_help);
        mHelp.setOnClickListener(mButtonClickListener);

        mButtonStart.setOnClickListener(mButtonClickListener);
        mToggleCram.setOnClickListener(mButtonClickListener);
        mToggleLimit.setOnClickListener(mButtonClickListener);
        mCardBrowser.setOnClickListener(mButtonClickListener);
        mStatisticsButton.setOnClickListener(mButtonClickListener);

        // The view to use when there is no deck loaded yet.
        // TODO: Add and init view here.
        mNoDeckView = getLayoutInflater().inflate(R.layout.studyoptions_nodeck, null);
        Themes.setWallpaper(mNoDeckView);

        mTextNoDeckTitle = (TextView) mNoDeckView.findViewById(R.id.studyoptions_nodeck_title);
        Themes.setTitleStyle(mTextNoDeckTitle);
        mTextNoDeckMessage = (TextView) mNoDeckView.findViewById(R.id.studyoptions_nodeck_message);
        Themes.setTextViewStyle(mTextNoDeckMessage);
        mTextNoDeckMessage.setOnClickListener(mButtonClickListener);
        Themes.setTextViewStyle(mTextNoDeckMessage);

        mNoDeckView.findViewById(R.id.studyoptions_load_sample_deck).setOnClickListener(mButtonClickListener);
        mNoDeckView.findViewById(R.id.studyoptions_download_deck).setOnClickListener(mButtonClickListener);
        mNoDeckView.findViewById(R.id.studyoptions_load_other_deck).setOnClickListener(mButtonClickListener);

        // The view that shows the congratulations view.
        mCongratsView = getLayoutInflater().inflate(R.layout.studyoptions_congrats, null);

        Themes.setWallpaper(mCongratsView);
        Themes.setTitleStyle(mCongratsView.findViewById(R.id.studyoptions_congrats_title));

        mTextCongratsMessage = (TextView) mCongratsView.findViewById(R.id.studyoptions_congrats_message);
        Themes.setTextViewStyle(mTextCongratsMessage);

        mTextCongratsMessage.setOnClickListener(mButtonClickListener);
        mButtonCongratsLearnMore = (Button) mCongratsView.findViewById(R.id.studyoptions_congrats_learnmore);
        mButtonCongratsReviewEarly = (Button) mCongratsView.findViewById(R.id.studyoptions_congrats_reviewearly);
        mButtonCongratsSyncDeck = (Button) mCongratsView.findViewById(R.id.studyoptions_congrats_syncdeck);
        mButtonCongratsOpenOtherDeck = (Button) mCongratsView.findViewById(R.id.studyoptions_congrats_open_other_deck);
        mButtonCongratsFinish = (Button) mCongratsView.findViewById(R.id.studyoptions_congrats_finish);

        mButtonCongratsLearnMore.setOnClickListener(mButtonClickListener);
        mButtonCongratsReviewEarly.setOnClickListener(mButtonClickListener);
        mButtonCongratsSyncDeck.setOnClickListener(mButtonClickListener);
        mButtonCongratsOpenOtherDeck.setOnClickListener(mButtonClickListener);
        mButtonCongratsFinish.setOnClickListener(mButtonClickListener);

        // The view to use when there is no external storage available
        mNoExternalStorageView = getLayoutInflater().inflate(R.layout.studyoptions_nostorage, null);
        Themes.setWallpaper(mNoExternalStorageView);
        Themes.setTitleStyle(mNoExternalStorageView.findViewById(R.id.studyoptions_nostorage_title));
        Themes.setTextViewStyle(mNoExternalStorageView.findViewById(R.id.studyoptions_nostorage_message));
    }


    private OnClickListener mSyncConflictResolutionListener = new OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            switch (which) {
                case DialogInterface.BUTTON_POSITIVE:
                    syncDeck(""keepLocal"");
                    break;
                case DialogInterface.BUTTON_NEUTRAL:
                    syncDeck(""keepRemote"");
                    break;
                case DialogInterface.BUTTON_NEGATIVE:
                default:
            }
        }
    };


    private OnClickListener mStatisticListener = new OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
        	if (mStatisticType == -1) {
        		mStatisticType = which;
        		if (mStatisticType != Statistics.TYPE_DECK_SUMMARY) {
        			showDialog(DIALOG_STATISTIC_PERIOD);
        		} else {
        			openStatistics(0);
        		}
        	} else {
        		openStatistics(which);
        	}
        }
    };


	@Override
	protected Dialog onCreateDialog(int id) {
		StyledDialog dialog = null;
		Resources res = getResources();
		StyledDialog.Builder builder = new StyledDialog.Builder(this);

		switch (id) {
		case DIALOG_SYNC_LOG:
	        builder.setTitle(getResources().getString(R.string.sync_log_title));
			builder.setPositiveButton(getResources().getString(R.string.ok), null);
			dialog = builder.create();
			break;

		case DIALOG_NO_SPACE_LEFT:
	        builder.setNegativeButton(getResources().getString(R.string.dont_show_again), new OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	            	PrefSettings.getSharedPrefs(getBaseContext()).edit().putBoolean(""dontShowLowMemory"", true).commit();
	            }
	        });
		case DIALOG_BACKUP_NO_SPACE_LEFT:
	        builder.setTitle(getResources().getString(R.string.backup_manager_title));
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
	        builder.setPositiveButton(getResources().getString(R.string.ok), null);
			dialog = builder.create();
			break;

		case DIALOG_BACKUP_ERROR:
	        builder.setTitle(getResources().getString(R.string.backup_manager_title));
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
	        builder.setMessage(getResources().getString(R.string.backup_deck_error));
			builder.setPositiveButton(getResources().getString(R.string.ok), null);
			dialog = builder.create();
			break;

		case DIALOG_NO_CONNECTION:
			builder.setTitle(res.getString(R.string.connection_error_title));
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
	        builder.setMessage(res.getString(R.string.connection_needed));
	        builder.setPositiveButton(res.getString(R.string.ok), null);
			dialog = builder.create();
			break;

		case DIALOG_USER_NOT_LOGGED_IN:
	        builder.setTitle(res.getString(R.string.connection_error_title));
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
	        builder.setMessage(res.getString(R.string.no_user_password_error_message));
	        builder.setPositiveButton(res.getString(R.string.log_in), new OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                Intent myAccount = new Intent(StudyOptions.this, MyAccount.class);
	                myAccount.putExtra(""notLoggedIn"", true);
	                startActivityForResult(myAccount, LOG_IN);
			        if (getApiLevel() > 4) {
			            ActivityTransitionAnimation.slide(StudyOptions.this, ActivityTransitionAnimation.LEFT);
			        }
	            }
	        });
	        builder.setNegativeButton(res.getString(R.string.cancel), null);
	        dialog = builder.create();
	        break;

		case DIALOG_SWAP_QA:
	        builder.setTitle(getResources().getString(R.string.swap_qa_title));
	        builder.setMessage(getResources().getString(R.string.swap_qa_text));
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
	        builder.setPositiveButton(res.getString(R.string.yes), new OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	            	mSwapQA.setChecked(true);
	        		mSwap = true;
	        		savePreferences(""swapqa"");
	            }
	        });
	        builder.setNegativeButton(res.getString(R.string.cancel), null);
			dialog = builder.create();
			break;

		case DIALOG_CONNECTION_ERROR:
	        builder.setTitle(res.getString(R.string.connection_error_title));
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
	        builder.setMessage(res.getString(R.string.connection_error_message));
	        builder.setPositiveButton(res.getString(R.string.retry), new OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                syncDeck(null);
	            }
	        });
	        builder.setNegativeButton(res.getString(R.string.cancel), null);
			dialog = builder.create();
			break;

		case DIALOG_SYNC_CONFLICT_RESOLUTION:
	        builder.setTitle(res.getString(R.string.sync_conflict_title));
	        builder.setIcon(android.R.drawable.ic_input_get);
	        builder.setMessage(res.getString(R.string.sync_conflict_message));
	        builder.setPositiveButton(res.getString(R.string.sync_conflict_local), mSyncConflictResolutionListener);
	        builder.setNeutralButton(res.getString(R.string.sync_conflict_remote), mSyncConflictResolutionListener);
	        builder.setNegativeButton(res.getString(R.string.sync_conflict_cancel), mSyncConflictResolutionListener);
	        builder.setCancelable(false);
			dialog = builder.create();
			break;

		case DIALOG_STATISTIC_PERIOD:
	        builder.setTitle(res.getString(R.string.statistics_period_title));
	        builder.setIcon(android.R.drawable.ic_menu_sort_by_size);
	        builder.setSingleChoiceItems(getResources().getStringArray(R.array.statistics_period_labels), 0, mStatisticListener);
			dialog = builder.create();
			break;

		case DIALOG_STATISTIC_TYPE:
	        builder.setTitle(res.getString(R.string.statistics_type_title));
	        builder.setIcon(android.R.drawable.ic_menu_sort_by_size);
	        builder.setSingleChoiceItems(getResources().getStringArray(R.array.statistics_type_labels), Statistics.TYPE_DUE, mStatisticListener);
	        dialog = builder.create();
			break;

		case DIALOG_DECK_NOT_LOADED:
	        builder.setTitle(res.getString(R.string.backup_manager_title));
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
	        builder.setPositiveButton(res.getString(R.string.retry), new OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                displayProgressDialogAndLoadDeck();
	            }
	        });
	        builder.setNegativeButton(res.getString(R.string.backup_restore), new OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	            	Resources res = getResources();
	            	mBackups = BackupManager.getDeckBackups(new File(mDeckFilename));
	            	if (mBackups.length == 0) {
	            		StyledDialog.Builder builder = new StyledDialog.Builder(StudyOptions.this);
	            		builder.setTitle(res.getString(R.string.backup_manager_title))
	            			.setIcon(android.R.drawable.ic_dialog_alert)
	            			.setMessage(res.getString(R.string.backup_restore_no_backups))
	            			.setPositiveButton(res.getString(R.string.ok), new Dialog.OnClickListener() {

					            @Override
					            public void onClick(DialogInterface dialog, int which) {
					            	showDialog(DIALOG_DECK_NOT_LOADED);
					            }
						}).setCancelable(true).setOnCancelListener(new OnCancelListener() {

							@Override
							public void onCancel(DialogInterface arg0) {
								showDialog(DIALOG_DECK_NOT_LOADED);
							}
						}).show();
	            	} else {
	            		String[] dates = new String[mBackups.length];
	            		for (int i = 0; i < mBackups.length; i++) {
	            			dates[i] = mBackups[i].getName().replaceAll("".*-(\\d{4}-\\d{2}-\\d{2}).anki"", ""$1"");
	            		}
	            		StyledDialog.Builder builder = new StyledDialog.Builder(StudyOptions.this);
	            		builder.setTitle(res.getString(R.string.backup_restore_select_title))
	            			.setIcon(android.R.drawable.ic_input_get)
	                    	.setSingleChoiceItems(dates, dates.length, new DialogInterface.OnClickListener(){

								@Override
								public void onClick(DialogInterface dialog, int which) {
									DeckTask.launchDeckTask(DeckTask.TASK_TYPE_RESTORE_DECK, mRestoreDeckHandler, new DeckTask.TaskData(null, new String[] {mDeckFilename, mBackups[which].getPath()}, 0, 0));
									dialog.dismiss();
								}
							}).setCancelable(true).setOnCancelListener(new OnCancelListener() {

								@Override
								public void onCancel(DialogInterface arg0) {
									showDialog(DIALOG_DECK_NOT_LOADED);
								}
							}).show();
	        		}
	            }
	        });
	        builder.setNeutralButton(res.getString(R.string.backup_repair_deck), new OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mDeckFilename));
	            }
	        });
	        builder.setCancelable(true);
	        dialog = builder.create();
			break;
		case DIALOG_MORE:
	        View contentViewMore = getLayoutInflater().inflate(R.layout.studyoptions_more_dialog_contents, null);
	        mSpinnerNewCardOrder = (Spinner) contentViewMore.findViewById(R.id.studyoptions_new_card_order);
	        mSpinnerNewCardSchedule = (Spinner) contentViewMore.findViewById(R.id.studyoptions_new_card_schedule);
	        mSpinnerRevCardOrder = (Spinner) contentViewMore.findViewById(R.id.studyoptions_rev_card_order);
	        mSpinnerFailCardOption = (Spinner) contentViewMore.findViewById(R.id.studyoptions_fail_card_option);
	        mEditMaxFailCard = (EditText) contentViewMore.findViewById(R.id.studyoptions_max_fail_card);
	        mEditNewPerDay = (EditText) contentViewMore.findViewById(R.id.studyoptions_new_cards_per_day);
	        mCheckBoxPerDay = (CheckBox) contentViewMore.findViewById(R.id.studyoptions_per_day);
	        mCheckBoxSuspendLeeches = (CheckBox) contentViewMore.findViewById(R.id.studyoptions_suspend_leeches);

	        builder.setTitle(R.string.studyoptions_more_dialog_title);
	        builder.setPositiveButton(R.string.studyoptions_more_save, mDialogSaveListener);
	        builder.setView(contentViewMore, true);
	        dialog = builder.create();
	        break;

		case DIALOG_DOWNLOAD_SELECTOR:
	        builder.setTitle(res.getString(R.string.menu_download_deck));
	        String[] items;
	    	items = new String[2];
	    	items[0] = res.getString(R.string.menu_download_personal_deck);
	    	items[1] = res.getString(R.string.menu_download_shared_deck);
	        builder.setItems(items, new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int item) {
					if (item == 0) {
		            	openPersonalDeckPicker();
					} else {
		            	openSharedDeckPicker();
					}
			    }
			});
	        dialog = builder.create();
	        break;

		case DIALOG_LIMIT_SESSION:
	        // Custom view for the dialog content.
	        View contentView = getLayoutInflater().inflate(R.layout.studyoptions_limit_dialog_contents, null);
	        mEditSessionTime = (EditText) contentView.findViewById(R.id.studyoptions_session_minutes);
	        mEditSessionQuestions = (EditText) contentView.findViewById(R.id.studyoptions_session_questions);
	        mSessionLimitCheckBox = (CheckBox) contentView.findViewById(R.id.studyoptions_limit_session_check);
	        mLimitTagsCheckBox = (CheckBox) contentView.findViewById(R.id.studyoptions_limit_tag_check);
	        mLimitTagNewActiveCheckBox = (CheckBox) contentView.findViewById(R.id.studyoptions_limit_tag_new_active_check);
	        mLimitTagNewInactiveCheckBox = (CheckBox) contentView.findViewById(R.id.studyoptions_limit_tag_new_inactive_check);
	        mLimitTagRevActiveCheckBox = (CheckBox) contentView.findViewById(R.id.studyoptions_limit_tag_rev_active_check);
	        mLimitTagRevInactiveCheckBox = (CheckBox) contentView.findViewById(R.id.studyoptions_limit_tag_rev_inactive_check);
	        mLimitSessionTv1 = (TextView) contentView.findViewById(R.id.studyoptions_limit_session_tv1);
	        mLimitSessionTv2 = (TextView) contentView.findViewById(R.id.studyoptions_limit_session_tv2);
	        mLimitTagTv1 = (TextView) contentView.findViewById(R.id.studyoptions_limit_tag_tv1);
	        mLimitTagTv2 = (TextView) contentView.findViewById(R.id.studyoptions_limit_tag_tv2);
	        mLimitTagTv3 = (TextView) contentView.findViewById(R.id.studyoptions_limit_tag_tv3);
	        mLimitTagTv4 = (TextView) contentView.findViewById(R.id.studyoptions_limit_tag_tv4);
	        mLimitTagTv5 = (TextView) contentView.findViewById(R.id.studyoptions_limit_tag_tv5);
	        mLimitTagTv6 = (TextView) contentView.findViewById(R.id.studyoptions_limit_tag_tv6);
	        mLimitTagTv2.setOnClickListener(mButtonClickListener);
	        mLimitTagTv3.setOnClickListener(mButtonClickListener);
	        mLimitTagTv5.setOnClickListener(mButtonClickListener);
	        mLimitTagTv6.setOnClickListener(mButtonClickListener);

	        mSessionLimitCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
	            @Override
	            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
	                mEditSessionTime.setEnabled(isChecked);
	                mEditSessionQuestions.setEnabled(isChecked);
	                if (!isChecked) {
	                    mEditSessionTime.setText("""");
	                    mEditSessionQuestions.setText("""");
	                    mEditSessionTime.clearFocus();
	                    mEditSessionQuestions.clearFocus();
	                    ((InputMethodManager)getSystemService(Context.INPUT_METHOD_SERVICE)).hideSoftInputFromWindow(mEditSessionTime.getWindowToken(), 0);
	                }
	                int color = getResources().getColor((isChecked) ? R.color.studyoptions_foreground : R.color.studyoptions_foreground_deactivated);
	                mLimitSessionTv1.setTextColor(color);
	                mLimitSessionTv2.setTextColor(color);
	            }
	            });

	        mLimitTagsCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener(){
	            @Override
	            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
	                mLimitTagNewActiveCheckBox.setEnabled(isChecked);
	                mLimitTagNewInactiveCheckBox.setEnabled(isChecked);
	                mLimitTagRevActiveCheckBox.setEnabled(isChecked);
	                mLimitTagRevInactiveCheckBox.setEnabled(isChecked);
	                if (!isChecked) {
	                    mLimitTagNewActiveCheckBox.setChecked(false);
	                    mLimitTagNewInactiveCheckBox.setChecked(false);
	                    mLimitTagRevActiveCheckBox.setChecked(false);
	                    mLimitTagRevInactiveCheckBox.setChecked(false);
	                }
	                int color = getResources().getColor((isChecked) ? R.color.studyoptions_foreground : R.color.studyoptions_foreground_deactivated);
	                mLimitTagTv1.setTextColor(color);
	                mLimitTagTv2.setTextColor(color);
	                mLimitTagTv3.setTextColor(color);
	                mLimitTagTv4.setTextColor(color);
	                mLimitTagTv5.setTextColor(color);
	                mLimitTagTv6.setTextColor(color);
	            }
	            });

	        mLimitTagNewActiveCheckBox.setOnCheckedChangeListener(mLimitTagCheckedChangeListener);
	        mLimitTagNewInactiveCheckBox.setOnCheckedChangeListener(mLimitTagCheckedChangeListener);
	        mLimitTagRevActiveCheckBox.setOnCheckedChangeListener(mLimitTagCheckedChangeListener);
	        mLimitTagRevInactiveCheckBox.setOnCheckedChangeListener(mLimitTagCheckedChangeListener);

	        builder.setTitle(R.string.studyoptions_limit_dialog_title);
	        builder.setPositiveButton(R.string.studyoptions_more_save, new DialogInterface.OnClickListener() {

	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                Deck deck = AnkiDroidApp.deck();
	                boolean changed = false;
	                String textTime = mEditSessionTime.getText().toString();
	                if (!textTime.equals(Long.toString(deck.getSessionTimeLimit() / 60))) {
	                  if (textTime.equals("""")) {
	                      deck.setSessionTimeLimit(0);
	                  } else if (isValidLong(textTime)) {
	                      deck.setSessionTimeLimit(Long.parseLong(textTime) * 60);
	                  }
	                }
	                String textReps = mEditSessionQuestions.getText().toString();
	                if (!textReps.equals(Long.toString(deck.getSessionRepLimit()))) {
	                    if (textReps.equals("""")) {
	                        deck.setSessionRepLimit(0);
	                    } else if (isValidLong(textReps)) {
	                        deck.setSessionRepLimit(Long.parseLong(textReps));
	                    }
	                    changed = true;
	                }
	                if (!deck.getVar(""newActive"").equals(mLimitNewActive)) {
	                    deck.setVar(""newActive"", mLimitNewActive);
	                    changed = true;
	                } 
	                if (!deck.getVar(""newInactive"").equals(mLimitNewInactive)) {
	                    deck.setVar(""newInactive"", mLimitNewInactive);
	                    changed = true;
	                } 
	                if (!deck.getVar(""revActive"").equals(mLimitRevActive)) {
	                    deck.setVar(""revActive"", mLimitRevActive);
	                    changed = true;
	                } 
	                if (!deck.getVar(""revInactive"").equals(mLimitRevInactive)) {
	                    deck.setVar(""revInactive"", mLimitRevInactive);
	                    changed = true;
	                }
	                if (changed) {
	                	resetAndUpdateValuesFromDeck();
	                }
	                mToggleLimit.setChecked((mSessionLimitCheckBox.isChecked() && !(textTime.length() == 0 && textReps.length() == 0)) || (mLimitTagsCheckBox.isChecked() && (mLimitTagNewActiveCheckBox.isChecked() || mLimitTagNewInactiveCheckBox.isChecked()
	                        || mLimitTagRevActiveCheckBox.isChecked() || mLimitTagRevInactiveCheckBox.isChecked())));
	            }
	        });
	        builder.setView(contentView, true);
	        dialog = builder.create();
	        break;
	        
		case DIALOG_TAGS:
			builder.setTitle(R.string.studyoptions_limit_select_tags);
	        builder.setPositiveButton(res.getString(R.string.select), new OnClickListener() {
	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                String readableText = mSelectedTags.toString();
	                updateLimitTagText(mSelectedLimitTagText, readableText.substring(1, readableText.length()-1));
	            }
	        });
	        builder.setNegativeButton(res.getString(R.string.cancel),  new OnClickListener() {
	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                updateLimitTagText(mSelectedLimitTagText, getSelectedTags(mSelectedLimitTagText));
	            }
	        });
	        builder.setOnCancelListener(new OnCancelListener() {
	            @Override
	            public void onCancel(DialogInterface dialog) {
	                updateLimitTagText(mSelectedLimitTagText, getSelectedTags(mSelectedLimitTagText));
	            }

	        });
	        dialog = builder.create();
	        break;
		case DIALOG_CRAM:
	        builder.setTitle(R.string.studyoptions_cram_dialog_title);
	        builder.setPositiveButton(res.getString(R.string.begin_cram), new OnClickListener() {
	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                mToggleCram.setChecked(true);
	                onCram();
	            }
	        });
	        builder.setNegativeButton(res.getString(R.string.cancel), null);

	        Spinner spinner = new Spinner(this);
	        
	        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(this, R.array.cram_review_order_labels, android.R.layout.simple_spinner_item);
	        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
	        spinner.setAdapter(adapter);
	        spinner.setSelection(0);
	        spinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
	            @Override
	            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
	                cramOrder = cramOrderList[position];
	            }
	            @Override
	            public void onNothingSelected(AdapterView<?> arg0) {
	                return;
	            }
	        });

	        builder.setView(spinner, false, true);
	        dialog = builder.create();
	        break;

		case DIALOG_WELCOME:
			builder.setTitle(R.string.studyoptions_welcome_title);
	        WebView view = new WebView(this);
	        view.setBackgroundColor(res.getColor(Themes.getDialogBackgroundColor()));
	        view.loadDataWithBaseURL("""", ""<html><body text=\""#FFFFFF\"" link=\""#E37068\"" alink=\""#E37068\"" vlink=\""#E37068\"">"" + res.getString(R.string.studyoptions_welcome_dialog).replace(""\n"", ""<br>"") + ""</body></html>"", ""text/html"", ""UTF-8"", """");
	        builder.setView(view, true);
    		builder.setCancelable(true);
			builder.setPositiveButton(res.getString(R.string.yes), new OnClickListener() {
	            @Override
	            public void onClick(DialogInterface dialog, int which) {
		        	PrefSettings.getSharedPrefs(StudyOptions.this.getBaseContext()).edit().putBoolean(""firstStart"", false).commit();
		        	mNewVersionAlert = null;
		        	loadSampleDeck();
	            }
	        });
	        builder.setNegativeButton(res.getString(R.string.no),  new OnClickListener() {
	            @Override
	            public void onClick(DialogInterface dialog, int which) {
		        	PrefSettings.getSharedPrefs(StudyOptions.this.getBaseContext()).edit().putBoolean(""firstStart"", false).commit();
		        	if (mNewVersionAlert != null) {
		        		mNewVersionAlert.show();
		        	} else {
		        		BroadcastMessages.checkForNewMessages(StudyOptions.this);
		        	}
	            }
	        });
	        builder.setOnCancelListener(new OnCancelListener() {
	            @Override
	            public void onCancel(DialogInterface dialog) {
		        	if (mNewVersionAlert != null) {
		        		mNewVersionAlert.show();
		        	} else {
		        		BroadcastMessages.checkForNewMessages(StudyOptions.this);
		        	}
	            }

	        });
	        dialog = builder.create();
	        mWelcomeAlert = dialog;
			break;

		case DIALOG_DB_ERROR:
			builder.setTitle(R.string.answering_error_title);
	        builder.setIcon(android.R.drawable.ic_dialog_alert);
			builder.setMessage(R.string.answering_error_message);
	        builder.setPositiveButton(res.getString(R.string.backup_repair_deck), new OnClickListener() {
	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mDeckFilename));
	            }
	        });
	        builder.setNeutralButton(res.getString(R.string.answering_error_report), new OnClickListener() {
	            @Override
	            public void onClick(DialogInterface dialog, int which) {
	                mShowRepairDialog = true;
	                Intent i = new Intent(StudyOptions.this, Feedback.class);
			dialog.dismiss();
	                startActivityForResult(i, REPORT_ERROR);
		        if (getApiLevel() > 4) {
			    ActivityTransitionAnimation.slide(StudyOptions.this, ActivityTransitionAnimation.FADE);
		        }
	            }
	        });	        	
			builder.setNegativeButton(res.getString(R.string.close), null);
	        builder.setCancelable(true);
		    dialog = builder.create();
			break;
		case DIALOG_SELECT_HELP:
	        builder.setTitle(res.getString(R.string.help_title));
	        builder.setItems(new String[] {res.getString(R.string.help_tutorial), res.getString(R.string.help_online), res.getString(R.string.help_faq)}, new OnClickListener() {

				@Override
				public void onClick(DialogInterface arg0, int arg1) {
					if (arg1 == 0) {
						loadSampleDeck();
					} else {
			            if (Utils.isIntentAvailable(StudyOptions.this, ""android.intent.action.VIEW"")) {
			                Intent intent = new Intent(""android.intent.action.VIEW"", Uri.parse(getResources().getString(arg1 == 0 ? R.string.link_help : R.string.link_faq)));
			                startActivity(intent);
			            } else {
			                startActivity(new Intent(StudyOptions.this, About.class));
			            }						
					}
				}
	        	
	        });
			dialog = builder.create();
			break;

		default:
			dialog = null;
		}

		dialog.setOwnerActivity(StudyOptions.this);
		return dialog;
	}


	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		StyledDialog ad = (StyledDialog)dialog;

		// wait for deck loading thread (to avoid problems with resuming destroyed activities)
		DeckTask.waitToFinish();

		switch (id) {
		case DIALOG_SYNC_CONFLICT_RESOLUTION:
		case DIALOG_NO_SPACE_LEFT:
		case DIALOG_DECK_NOT_LOADED:
		case DIALOG_SYNC_LOG:
			ad.setMessage(mCurrentDialogMessage);
			break;

		case DIALOG_MORE:
	        // Update spinner selections from deck prior to showing the dialog.
	        Deck deck = AnkiDroidApp.deck();
		        mSpinnerNewCardOrder.setSelection(deck.getNewCardOrder());
		        mSpinnerNewCardSchedule.setSelection(deck.getNewCardSpacing());
		        mSpinnerRevCardOrder.setSelection(deck.getRevCardOrder());
		        mSpinnerFailCardOption.setVisibility(View.GONE); // TODO: Not implemented yet.
		        mEditMaxFailCard.setText(String.valueOf(deck.getFailedCardMax()));
		        mEditNewPerDay.setText(String.valueOf(deck.getNewCardsPerDay()));
		        mCheckBoxPerDay.setChecked(deck.getPerDay());
		        mCheckBoxSuspendLeeches.setChecked(deck.getSuspendLeeches());	        	
			break;
			
		case DIALOG_LIMIT_SESSION:
	        // Update spinner selections from deck prior to showing the dialog.
	        Deck deck2 = AnkiDroidApp.deck();
	        long timeLimit = deck2.getSessionTimeLimit() / 60;
	        long repLimit = deck2.getSessionRepLimit();
	        mSessionLimitCheckBox.setChecked(timeLimit + repLimit > 0);
	        if (timeLimit != 0) {
	            mEditSessionTime.setText(String.valueOf(timeLimit));
	        }
	        if (repLimit != 0) {
	            mEditSessionQuestions.setText(String.valueOf(repLimit));
	        }

	        updateLimitTagText(LIMIT_NEW_ACTIVE, deck2.getVar(""newActive""));
	        updateLimitTagText(LIMIT_NEW_INACTIVE, deck2.getVar(""newInactive""));
	        updateLimitTagText(LIMIT_REV_ACTIVE, deck2.getVar(""revActive""));
	        updateLimitTagText(LIMIT_REV_INACTIVE, deck2.getVar(""revInactive""));

	        mLimitTagsCheckBox.setChecked(mLimitTagNewActiveCheckBox.isChecked() || mLimitTagNewInactiveCheckBox.isChecked()
	                || mLimitTagRevActiveCheckBox.isChecked() || mLimitTagRevInactiveCheckBox.isChecked());
	        allTags = null;
	        break;

		case DIALOG_TAGS:
	        if (allTags == null) {
	            allTags = AnkiDroidApp.deck().allTags_();
	            // Log.i(AnkiDroidApp.TAG, ""all tags: "" + Arrays.toString(allTags));
		        if (allTags == null) {
		        	Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.error_insufficient_memory), false);
		        	ad.setEnabled(false);
		        	return;
		        }
	        }
	        mSelectedTags.clear();
	        List<String> selectedList = Arrays.asList(Utils.parseTags(getSelectedTags(mSelectedLimitTagText)));
	        int length = allTags.length;
	        boolean[] checked = new boolean[length];
	        for (int i = 0; i < length; i++) {
	            String tag = allTags[i];
	            if (selectedList.contains(tag)) {
	                checked[i] = true;
	                mSelectedTags.add(tag);
	            }
	        }
	        ad.setMultiChoiceItems(allTags, checked,
	                new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
				if (allTags == null) {
					dialog.dismiss();
					return;
				}
	                        String tag = allTags[which];
	                        if (mSelectedTags.contains(tag)) {
	                            // Log.i(AnkiDroidApp.TAG, ""unchecked tag: "" + tag);
	                            mSelectedTags.remove(tag);
	                        } else {
	                            // Log.i(AnkiDroidApp.TAG, ""checked tag: "" + tag);
	                            mSelectedTags.add(tag);
	                        }							
						}
	                });
	        break;

		case DIALOG_CRAM:
	        allCramTags = AnkiDroidApp.deck().allTags_();
	        if (allCramTags == null) {
	        	Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.error_insufficient_memory), false);
	        	ad.setEnabled(false);
	        	return;
	        }
	        ad.setMultiChoiceItems(allCramTags, new boolean[allCramTags.length], 
	        		new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface arg0, int which) {
					String tag = allCramTags[which];
					if (activeCramTags.contains(tag)) {
	                    // Log.i(AnkiDroidApp.TAG, ""unchecked tag: "" + tag);
	                    activeCramTags.remove(tag);						
					} else {
	                    // Log.i(AnkiDroidApp.TAG, ""checked tag: "" + tag);
	                    activeCramTags.add(tag);						
					}
				}
	        });
			break;
		case DIALOG_DB_ERROR:
			ad.getButton(Dialog.BUTTON_NEUTRAL).setEnabled(hasErrorFiles() && !PrefSettings.getSharedPrefs(StudyOptions.this).getString(""reportErrorMode"", Feedback.REPORT_ASK).equals(Feedback.REPORT_NEVER));
			break;
		}
	}


	private void showContentView(int which) {
        mCurrentContentView = which;
        showContentView();
    }


    private void showContentView() {

        switch (mCurrentContentView) {
            case CONTENT_NO_DECK:
                setTitle(R.string.app_name);
                if (PrefSettings.getSharedPrefs(getBaseContext()).getBoolean(""firstStart"", true)) {
                    mTextNoDeckTitle.setText(R.string.studyoptions_welcome_title);
                    mTextNoDeckMessage.setText(String.format(
                            getResources().getString(R.string.studyoptions_welcome_message), mPrefDeckPath));
                	showDialog(DIALOG_WELCOME);
                } else {
                    mTextNoDeckTitle.setText(R.string.studyoptions_nodeck_title);
                    mTextNoDeckMessage.setText(String.format(
                            getResources().getString(R.string.studyoptions_nodeck_message), mPrefDeckPath));
                    if (mNewVersionAlert != null) {
                    	mNewVersionAlert.show();
                    }
                }
                setContentView(mNoDeckView);
                break;
            case CONTENT_DECK_NOT_LOADED:
                setTitle(R.string.app_name);
                mTextNoDeckTitle.setText(R.string.studyoptions_deck_not_loaded_title);
                mTextNoDeckMessage.setText(R.string.studyoptions_deck_not_loaded_message);
                setContentView(mNoDeckView);
            	mCurrentDialogMessage = getResources().getString(R.string.open_deck_failed, ""\'"" + new File(mDeckFilename).getName() + ""\'"", BackupManager.BROKEN_DECKS_SUFFIX.replace(""/"", """"), getResources().getString(R.string.repair_deck));
    			showDialog(DIALOG_DECK_NOT_LOADED);
                break;
            case CONTENT_STUDY_OPTIONS:
            case CONTENT_SESSION_COMPLETE:
                // Enable timeboxing in case it was disabled from the previous deck
                if ((AnkiDroidApp.deck() != null) && (AnkiDroidApp.deck().name().equals(""cram""))) {
                    mToggleCram.setChecked(false);
                    mToggleLimit.setEnabled(true);
                }
                if (mCurrentContentView == CONTENT_STUDY_OPTIONS) {
                    mButtonStart.setText(R.string.studyoptions_start);
                } else {
                    mButtonStart.setText(R.string.studyoptions_continue);
                }
                if (updateValuesFromDeck()) {
                    setContentView(mStudyOptionsView);
                } else {
                	showContentView(CONTENT_DECK_NOT_LOADED);
                }
                break;
            case CONTENT_CONGRATS:
                setCongratsMessage();
                updateValuesFromDeck();
                setContentView(mCongratsView);
                break;
            case CONTENT_NO_EXTERNAL_STORAGE:
                setTitle(R.string.app_name);
                setContentView(mNoExternalStorageView);
                break;
        }
    }


    private void updateLimitTagText(int which, String tags) {
        Resources res = getResources();
        tags = tags.replaceAll("","", """");
        boolean checked = !tags.equals("""");
        switch (which) {
            case LIMIT_NEW_ACTIVE:
                mLimitNewActive = tags;
                mLimitTagTv2.setText(res.getString(R.string.studyoptions_limit_tags_active, tags));
                mLimitTagNewActiveCheckBox.setChecked(checked);
                return;
            case LIMIT_NEW_INACTIVE:
                mLimitNewInactive = tags;
                mLimitTagTv3.setText(res.getString(R.string.studyoptions_limit_tags_inactive, tags));
                mLimitTagNewInactiveCheckBox.setChecked(checked);
                return;
            case LIMIT_REV_ACTIVE:
                mLimitRevActive = tags;
                mLimitTagTv5.setText(res.getString(R.string.studyoptions_limit_tags_active, tags));
                mLimitTagRevActiveCheckBox.setChecked(checked);
                return;
            case LIMIT_REV_INACTIVE:
                mLimitRevInactive = tags;
                mLimitTagTv6.setText(res.getString(R.string.studyoptions_limit_tags_inactive, tags));
                mLimitTagRevInactiveCheckBox.setChecked(checked);
                return;
            default:
                return;
        }
    }


    private String getSelectedTags(int which) {
        switch (which) {
            case LIMIT_NEW_ACTIVE:
                return mLimitNewActive;
            case LIMIT_NEW_INACTIVE:
                return mLimitNewInactive;
            case LIMIT_REV_ACTIVE:
                return mLimitRevActive;
            case LIMIT_REV_INACTIVE:
                return mLimitRevInactive;
            default:
                return """";
        }
    }


    private void setCongratsMessage() {
    	Resources res = getResources();
        Deck deck = AnkiDroidApp.deck();
        if (deck != null) {
    		int failedCards = deck.getFailedDelayedCount();
            int revCards = deck.getNextDueCards(1);
            int revFailedCards = failedCards + revCards;
            int newCards = deck.getNextNewCards();
            int eta = deck.getETA(failedCards, revCards, newCards, true);
            String newCardsText = res.getQuantityString(R.plurals.studyoptions_congrats_new_cards, newCards, newCards);
            String etaText = res.getQuantityString(R.plurals.studyoptions_congrats_eta, eta, eta);
            mTextCongratsMessage.setText(res.getQuantityString(R.plurals.studyoptions_congrats_message, revFailedCards, revFailedCards, newCardsText, etaText));
        }
    }


    private void resetAndUpdateValuesFromDeck() {
        Deck deck = AnkiDroidApp.deck();
        DeckTask.waitToFinish();
        if (deck != null) {
            deck.reset();
        	updateValuesFromDeck();        	
        }
    }


    private void hideDeckInformation(boolean fade) {
    	setTitle(getResources().getString(R.string.app_name));
        mTextDeckName.setVisibility(View.INVISIBLE);
        if (fade) {
        	mTextDeckName.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, 500, 0));        	
        }
        mStatisticsField.setVisibility(View.INVISIBLE);
        if (fade) {
        	mStatisticsField.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, 500, 0));        	
        }
    }


    private void showDeckInformation(boolean fade) {
        mTextDeckName.setVisibility(View.VISIBLE);
        if (fade) {
            mTextDeckName.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));        	
        }
        mStatisticsField.setVisibility(View.VISIBLE);
        if (fade) {
        	mStatisticsField.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
        }
    }


    private boolean updateValuesFromDeck() {
        Deck deck = AnkiDroidApp.deck();
        Resources res = getResources();
        if (deck != null && !mIsClosing && !mDeckNotAvailable) {
            // TODO: updateActives() from anqiqt/ui/main.py
        	try {
            	int dueCount = deck.getDueCount();
                int newTodayCount = deck.getNewCountToday();
                int cardsCount = deck.getCardCount();
                setTitle(res.getQuantityString(R.plurals.studyoptions_window_title, dueCount + newTodayCount, deck.getDeckName(), dueCount + newTodayCount, cardsCount));

                mTextDeckName.setText(deck.getDeckName());

                mTextReviewsDue.setText(String.valueOf(dueCount));
                mTextNewToday.setText(String.valueOf(newTodayCount));
                String etastr = ""-"";
                int eta = deck.getETA();
                if (eta != -1) {
                	etastr = Integer.toString(eta);
                }
                mTextETA.setText(etastr);
                int totalNewCount = deck.getNewCount(false);
                mTextNewTotal.setText(String.valueOf(totalNewCount));

                // Progress bars are not shown on small screens
                if (mDailyBar != null) {
                    double totalCardsCount = cardsCount;
                    mProgressTodayYes = deck.getProgress(false);
                    mProgressMatureYes = deck.getProgress(true);
                    double mature = deck.getMatureCardCount(false);
                    mProgressMature = mature / totalCardsCount;
                    double allRev = deck.getTotalRevFailedCount(false);
                    mProgressAll = allRev / totalCardsCount;
                    if (deck.isLimitedByTag()) {
                    	if (mToggleCram.isChecked()) {
                    		mGlobalLimitFrame.setVisibility(View.GONE);
                    	} else {
                            mGlobalLimitFrame.setVisibility(View.VISIBLE);
                            mature = deck.getMatureCardCount(true);
                            allRev = deck.getTotalRevFailedCount(true);
                            totalCardsCount = allRev + deck.getNewCount(true);
                            mProgressMatureLimit = mature / totalCardsCount;
                            mProgressAllLimit = allRev / totalCardsCount;
                    	}
                    } else {
                        mGlobalLimitFrame.setVisibility(View.GONE);
                    }
                    updateStatisticBars();
                }
                return true;
            } catch (SQLiteException e) {
            	Log.e(AnkiDroidApp.TAG, ""updateValuesFromDeck - error on retrieving deck information: "" + e);
            	return false;
            }
        }
        return true;
    }


    private void updateStatisticBars() {
        if (mStatisticBarsMax == 0) {
            mStatisticBarsMax = mBarsMax.getWidth();
            mStatisticBarsHeight = mBarsMax.getHeight();
        }
        Utils.updateProgressBars(this, mDailyBar, mProgressTodayYes, mStatisticBarsMax, mStatisticBarsHeight, true);
        Utils.updateProgressBars(this, mMatureBar,mProgressMatureYes, mStatisticBarsMax, mStatisticBarsHeight, true);
        Utils.updateProgressBars(this, mGlobalMatLimitBar, mProgressMatureLimit, mStatisticBarsMax, mStatisticBarsHeight, false);
        Utils.updateProgressBars(this, mGlobalLimitBar, (mProgressAllLimit == 1.0) ? 1.0 : mProgressAllLimit - mProgressMatureLimit, mStatisticBarsMax, mStatisticBarsHeight, false);
        Utils.updateProgressBars(this, mGlobalMatBar, mProgressMature, mStatisticBarsMax, mStatisticBarsHeight, false);
        Utils.updateProgressBars(this, mGlobalBar, (mProgressAll == 1.0) ? 1.0 : mProgressAll - mProgressMature, mStatisticBarsMax, mStatisticBarsHeight, false);
    }


    /*
* Switch schedulers
*/

    //UNUSED and never used, introduced in commit e44130abcd84928a288ddb0f3512e984ada190e7
    /*
    private void reset() {
        reset(false);
    }
    private void reset(boolean priorities) {
        if (priorities) {
            AnkiDroidApp.deck().updateAllPriorities();
        }
        AnkiDroidApp.deck().reset();
    }
    */


    /**
* Enter cramming mode.
* Currently not supporting cramming from selection of cards, as we don't have a card list view anyway.
*/
    private void onCram() {
        AnkiDroidApp.deck().setupCramScheduler(activeCramTags.toArray(new String[activeCramTags.size()]), cramOrder);
        // Timeboxing only supported using the standard scheduler
        mToggleLimit.setEnabled(false);
        resetAndUpdateValuesFromDeck();
    }

    /**
* Exit cramming mode.
*/
    private void onCramStop() {
        AnkiDroidApp.deck().setupStandardScheduler();
        mToggleLimit.setEnabled(true);
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        // Log.i(AnkiDroidApp.TAG, ""onSaveInstanceState: "" + mDeckFilename);
        // Remember current deck's filename.
        if (mDeckFilename != null) {
            outState.putString(""deckFilename"", mDeckFilename);
        }
        // Log.i(AnkiDroidApp.TAG, ""onSaveInstanceState - Ending"");
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_OPEN, Menu.NONE, R.string.menu_open_deck,
                R.drawable.ic_menu_manage);
        Utils.addMenuItemInActionBar(menu, Menu.NONE, MENU_SYNC, Menu.NONE, R.string.menu_sync,
                R.drawable.ic_menu_refresh);        	
        Utils.addMenuItem(menu, Menu.NONE, MENU_ADD_FACT, Menu.NONE, R.string.menu_add_card,
                R.drawable.ic_menu_add);
        Utils.addMenuItem(menu, Menu.NONE, MENU_MORE_OPTIONS, Menu.NONE, R.string.studyoptions_more,
                R.drawable.ic_menu_archive);
        Utils.addMenuItem(menu, Menu.NONE, MENU_PREFERENCES, Menu.NONE, R.string.menu_preferences,
                R.drawable.ic_menu_preferences);
        Utils.addMenuItem(menu, Menu.NONE, MENU_ROTATE, Menu.NONE, R.string.menu_rotate,
                android.R.drawable.ic_menu_always_landscape_portrait);        
        Utils.addMenuItem(menu, Menu.NONE, MENU_ZEEMOTE, Menu.NONE, R.string.menu_zeemote,
                R.drawable.ic_menu_zeemote);
        return true;
    }


    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        boolean deckChangeable = (AnkiDroidApp.deck() != null) && mSdCardAvailable && !mToggleCram.isChecked();
        menu.findItem(MENU_OPEN).setEnabled(mSdCardAvailable);
        menu.findItem(MENU_ADD_FACT).setEnabled(deckChangeable);
        menu.findItem(MENU_MORE_OPTIONS).setEnabled(deckChangeable);
		menu.findItem(MENU_SYNC).setEnabled(deckChangeable);        	
        return true;
    }


    /** Handles item selections */
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case MENU_OPEN:
                openDeckPicker();
                return true;

            case MENU_SYNC:
                syncDeck(null);
                return true;

            case MENU_MORE_OPTIONS:
            	showDialog(DIALOG_MORE);
                return true;

            case MENU_PREFERENCES:
                startActivityForResult(
                        new Intent(StudyOptions.this, Preferences.class),
                        PREFERENCES_UPDATE);
                return true;

            case MENU_ADD_FACT:
            	Intent intent = new Intent(StudyOptions.this, CardEditor.class);
            	intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.ADD_CARD);
            	startActivityForResult(intent, ADD_FACT);
                if (getApiLevel() > 4) {
                    ActivityTransitionAnimation.slide(StudyOptions.this, ActivityTransitionAnimation.LEFT);
                }
                return true;

            case MENU_ROTATE:
                if (getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
                    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
                } else {
                    setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);                	
                }
                return true;
            case MENU_ZEEMOTE:
            	
            	// Log.d(""Zeemote"",""Locale: ""+mLocale);
            	if ((AnkiDroidApp.zeemoteController() != null)) {
            		controllerUi.showControllerMenu();
            	}
            	return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }


    private void openDeckPicker() {
        Intent decksPicker = new Intent(StudyOptions.this, DeckPicker.class);
        mInDeckPicker = true;
        startActivityForResult(decksPicker, PICK_DECK_REQUEST);
    	if (getApiLevel() > 4) {
    		ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
    	}
        // // Log.i(AnkiDroidApp.TAG, ""openDeckPicker - Ending"");
    }


    private void finishCongrats() {
        mStudyOptionsView.setVisibility(View.INVISIBLE);
        mCongratsView.setVisibility(View.INVISIBLE);
        mCongratsView.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_OUT, 500, 0));
        showContentView(CONTENT_SESSION_COMPLETE);
        mCongratsView.setVisibility(View.VISIBLE);
        mStudyOptionsView.setVisibility(View.VISIBLE);
        mStudyOptionsView.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0));
    }


    private void openCardBrowser() {
        Intent cardBrowser = new Intent(StudyOptions.this, CardBrowser.class);
        startActivityForResult(cardBrowser, BROWSE_CARDS);
        if (getApiLevel() > 4) {
            ActivityTransitionAnimation.slide(StudyOptions.this, ActivityTransitionAnimation.LEFT);
        }
    }


    private void openStatistics(int period) {
        if (AnkiDroidApp.deck() != null) {
            DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_STATISTICS, mLoadStatisticsHandler, new DeckTask.TaskData(this, new String[]{""""}, mStatisticType, period));
        }
    }


    public void openPersonalDeckPicker() {
        if (AnkiDroidApp.isUserLoggedIn()) {
            if (AnkiDroidApp.deck() != null)// && sdCardAvailable)
            {
                AnkiDroidApp.deck().closeDeck();
                AnkiDroidApp.setDeck(null);
                mCompat.invalidateOptionsMenu(this);
            }
            startActivityForResult(
                    new Intent(StudyOptions.this, PersonalDeckPicker.class), DOWNLOAD_PERSONAL_DECK);
        	if (getApiLevel() > 4) {
        		ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
        	}
        } else {
        	showDialog(DIALOG_USER_NOT_LOGGED_IN);
        }
    }


    public void openSharedDeckPicker() {
        if (AnkiDroidApp.deck() != null)// && sdCardAvailable)
        {
            AnkiDroidApp.deck().closeDeck();
            AnkiDroidApp.setDeck(null);
            mCompat.invalidateOptionsMenu(this);
        }
        // deckLoaded = false;
        startActivityForResult(new Intent(StudyOptions.this, SharedDeckPicker.class), DOWNLOAD_SHARED_DECK);
    	if (getApiLevel() > 4) {
    		ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
    	}
    }


    private void loadSampleDeck() {
        // If decks directory does not exist, create it.
        File decksDirectory = new File(mPrefDeckPath);
        AnkiDroidApp.createDecksDirectoryIfMissing(decksDirectory);
        mDeckFilename = mPrefDeckPath + ""/"" + SAMPLE_DECK_NAME;
        savePreferences(""deckFilename"");
        DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_TUTORIAL, mLoadDeckHandler, new DeckTask.TaskData(mDeckFilename));        	
    }


    private void syncDeckWithPrompt() {
        if (AnkiDroidApp.isUserLoggedIn()) {
            Deck deck = AnkiDroidApp.deck();
            if (deck != null) {
                // Close existing sync progress dialog
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    mProgressDialog.dismiss();
                }
                // Prompt user for conflict resolution
                mCurrentDialogMessage = String.format(getResources().getString(R.string.sync_conflict_message), deck.getDeckName());
                showDialog(DIALOG_SYNC_CONFLICT_RESOLUTION);
            }
        } else {
        	showDialog(DIALOG_USER_NOT_LOGGED_IN);
        }
    }


    private void syncDeck(String conflictResolution) {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());

        String username = preferences.getString(""username"", """");
        String password = preferences.getString(""password"", """");

        if (AnkiDroidApp.isUserLoggedIn()) {
            Deck deck = AnkiDroidApp.deck();
            if (deck != null) {
                // Log.i(AnkiDroidApp.TAG, ""Synchronizing deck "" + mDeckFilename + "", conflict resolution: "" + conflictResolution);
                // Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""Before syncing - mod: %f, last sync: %f"", deck.getModified(), deck.getLastSync()));
                Connection.syncDeck(mSyncListener, new Connection.Payload(new Object[] { username, password, deck, conflictResolution, true }));
            }
        } else {
        	showDialog(DIALOG_USER_NOT_LOGGED_IN);
        }
    }


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);

        if (resultCode == CONTENT_NO_EXTERNAL_STORAGE) {
            showContentView(CONTENT_NO_EXTERNAL_STORAGE);
        } else if (requestCode == PICK_DECK_REQUEST || requestCode == DOWNLOAD_PERSONAL_DECK
                || requestCode == DOWNLOAD_SHARED_DECK) {
            mInDeckPicker = false;
        	if (requestCode == PICK_DECK_REQUEST && resultCode == RESULT_CLOSE) {
        		closeStudyOptions(true);
        		return;
        	} else if (requestCode == PICK_DECK_REQUEST && resultCode == RESULT_RESTART) {
        		restartApp();
        	}
            // Clean the previous card before showing the first of the new loaded deck (so the transition is not so
            // abrupt)
            // updateCard("""");
            // hideSdError();
            // hideDeckErrors();

            if (requestCode == PICK_DECK_REQUEST && resultCode == RESULT_OK) {
                showContentView(CONTENT_STUDY_OPTIONS);
            } else if ((requestCode == DOWNLOAD_SHARED_DECK || requestCode == DOWNLOAD_PERSONAL_DECK) && resultCode == RESULT_OK) {
            	openDeckPicker();
            	return;
            }
            if (resultCode != RESULT_OK) {
                Log.e(AnkiDroidApp.TAG, ""onActivityResult - Deck browser returned with error"");
                // Make sure we open the database again in onResume() if user pressed ""back""
                // deckSelected = false;
                boolean fileNotDeleted = mDeckFilename != null && new File(mDeckFilename).exists();
            	if (!fileNotDeleted) {
                    AnkiDroidApp.setDeck(null);
                    mCompat.invalidateOptionsMenu(this);
                    showContentView(CONTENT_NO_DECK);
            	} else {
                	showContentView(CONTENT_STUDY_OPTIONS);
                    if (AnkiDroidApp.deck() == null || !AnkiDroidApp.deck().getDeckPath().equals(mDeckFilename)) {
                    	if (resultCode != RESULT_DONT_RELOAD_DECK) {
                            displayProgressDialogAndLoadDeck();
                        }
                    }
            	}
                return;
            }

            if (intent == null) {
                Log.e(AnkiDroidApp.TAG, ""onActivityResult - Deck browser returned null intent"");
                // Make sure we open the database again in onResume()
                // deckSelected = false;
                displayProgressDialogAndLoadDeck();
                return;
            }
            // A deck was picked. Save it in preferences and use it.
            // Log.i(AnkiDroidApp.TAG, ""onActivityResult = OK"");
            mDeckFilename = intent.getExtras().getString(OPT_DB);
            savePreferences(""deckFilename"");
            if (mDeckFilename == null || !new File(mDeckFilename).exists()) {
            	showContentView(CONTENT_NO_DECK);
            }
            // // Log.i(AnkiDroidApp.TAG, ""onActivityResult - deckSelected = "" + deckSelected);
            if (AnkiDroidApp.deck() == null || !AnkiDroidApp.deck().getDeckPath().equals(mDeckFilename)) {
                boolean updateAllCards = (requestCode == DOWNLOAD_SHARED_DECK);
                displayProgressDialogAndLoadDeck(updateAllCards);	
            }
        } else if (requestCode == PREFERENCES_UPDATE) {
            restorePreferences();
            BackupManager.initBackup();
            showContentView();
            if (resultCode == RESULT_RESTART) {
            	restartApp();
            } else if (resultCode == RESULT_RELOAD_DECK) {
            	displayProgressDialogAndLoadDeck();
            }
            // If there is no deck loaded the controls have not to be shown
            // if(deckLoaded && cardsToReview)
            // {
            // showOrHideControls();
            // showOrHideAnswerField();
            // }
        } else if (requestCode == REQUEST_REVIEW) {
            // Log.i(AnkiDroidApp.TAG, ""Result code = "" + resultCode);
            // Return to standard scheduler
    		mInReviewer = false;
            switch (resultCode) {
                case Reviewer.RESULT_SESSION_COMPLETED:
                	showContentView(CONTENT_SESSION_COMPLETE);
                    break;
                case Reviewer.RESULT_NO_MORE_CARDS:
                	showContentView(CONTENT_CONGRATS);
                    break;
                case Reviewer.RESULT_ANSWERING_ERROR:
                	showContentView(CONTENT_STUDY_OPTIONS);
                	showDialog(DIALOG_DB_ERROR);
                    break;
                default:
                    DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SAVE_DECK, mSaveAndResetDeckHandler, new DeckTask.TaskData(AnkiDroidApp.deck(), 0));
                	showContentView(CONTENT_STUDY_OPTIONS);
                    break;
            }
        } else if (requestCode == ADD_FACT && resultCode != RESULT_CANCELED) {
        	resetAndUpdateValuesFromDeck();
        } else if (requestCode == BROWSE_CARDS && resultCode == RESULT_OK) {
        	resetAndUpdateValuesFromDeck();
        } else if (requestCode == LOG_IN && resultCode == RESULT_OK) {
        	syncDeck(null);
        } else if (requestCode == STATISTICS && mCurrentContentView == CONTENT_CONGRATS) {
        	showContentView(CONTENT_STUDY_OPTIONS);
        } else if (requestCode == REPORT_ERROR) {
  	      	if (mShowRepairDialog) {
  	      		showDialog(DIALOG_DB_ERROR);
  	      		mShowRepairDialog = false;
  	      	} else if (showDeckPickerOnStartup()) {
        		openDeckPicker();
        	} else {
        		// workaround for dialog problems when returning from error reporter
        		try {
      	      		if (mWelcomeAlert != null && mWelcomeAlert.isShowing()) {
      	      			mWelcomeAlert.dismiss();
          				mWelcomeAlert.show();
      	      		} else if (mNewVersionAlert != null && mNewVersionAlert.isShowing()) {
      	      			mNewVersionAlert.dismiss();
      	      			mNewVersionAlert.show();
      	      		}
      	      	} catch (IllegalArgumentException e) {
      	      		Log.e(AnkiDroidApp.TAG, ""Error on dismissing and showing dialog: "" + e);
      	      	}
        	}
        }
    }

    private boolean showDeckPickerOnStartup() {
    	switch (mStartupMode) {
    	case SUM_STUDY_OPTIONS:
            return false;

    	case SUM_DECKPICKER:
    		return true;

    	case SUM_DECKPICKER_ON_FIRST_START:
    		return Utils.isNewDay(mLastTimeOpened);

    	default:
    		return false;
    	}
    }

    private void savePreferences(String str) {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
        Editor editor = preferences.edit();
        if (str.equals(""deckFilename"")) {
            editor.putString(""deckFilename"", mDeckFilename);
        } else if (str.equals(""invertedColors"")) {
            editor.putBoolean(""invertedColors"", mInvertedColors);
        } else if (str.equals(""swapqa"")) {
            editor.putBoolean(""swapqa"", mSwap);
        }
        editor.commit();
    }


    private SharedPreferences restorePreferences() {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
        mPrefDeckPath = preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
        mPrefStudyOptions = preferences.getBoolean(""study_options"", true);
        mStartupMode = Integer.parseInt(preferences.getString(""startup_mode"",
                Integer.toString(SUM_DECKPICKER_ON_FIRST_START)));
        mSwipeEnabled = preferences.getBoolean(""swipe"", false);

        mLastTimeOpened = preferences.getLong(""lastTimeOpened"", 0);
        BroadcastMessages.init(this, mLastTimeOpened);
       	preferences.edit().putLong(""lastTimeOpened"", System.currentTimeMillis()).commit();

        if (!preferences.getString(""lastVersion"", """").equals(getVersion())) {
           	mNewVersionAlert = Themes.htmlOkDialog(this, getResources().getString(R.string.new_version_title) + "" "" + getVersion(), getVersionMessage(), new DialogInterface.OnClickListener() {
    			@Override
    			public void onClick(DialogInterface dialog, int which) {
		        	PrefSettings.getSharedPrefs(StudyOptions.this.getBaseContext()).edit().putString(""lastVersion"", getVersion()).commit();
		        	mNewVersionAlert = null;
			        BroadcastMessages.checkForNewMessages(StudyOptions.this);
    			}
            }, new DialogInterface.OnCancelListener() {
    			@Override
    			public void onCancel(DialogInterface dialog) {
		        	mNewVersionAlert = null;
			        BroadcastMessages.checkForNewMessages(StudyOptions.this);
    			}
            }, true);
           	AnkiDroidApp.createNoMediaFileIfMissing(new File(mPrefDeckPath));
        } else if (!preferences.getBoolean(""firstStart"", true)) {
        	BroadcastMessages.checkForNewMessages(this);        		
        }

        // Convert dip to pixel, code in parts from http://code.google.com/p/k9mail/
        final float gestureScale = getResources().getDisplayMetrics().density;
        int sensibility = preferences.getInt(""swipeSensibility"", 100);
        if (sensibility != 100) {
            float sens = (200 - sensibility) / 100.0f;
            sSwipeMinDistance = (int)(SWIPE_MIN_DISTANCE_DIP * sens * gestureScale + 0.5f);
            sSwipeThresholdVelocity = (int)(SWIPE_THRESHOLD_VELOCITY_DIP * sens * gestureScale + 0.5f);
            sSwipeMaxOffPath = (int)(SWIPE_MAX_OFF_PATH_DIP * Math.sqrt(sens) * gestureScale + 0.5f);
        } else {
            sSwipeMinDistance = (int)(SWIPE_MIN_DISTANCE_DIP * gestureScale + 0.5f);
            sSwipeThresholdVelocity = (int)(SWIPE_THRESHOLD_VELOCITY_DIP * gestureScale + 0.5f);
            sSwipeMaxOffPath = (int)(SWIPE_MAX_OFF_PATH_DIP * gestureScale + 0.5f);
        }

        mInvertedColors = preferences.getBoolean(""invertedColors"", false);
        mSwap = preferences.getBoolean(""swapqa"", false);
        mLocale = preferences.getString(""language"", """");
        mZeemoteEnabled = preferences.getBoolean(""zeemote"", false);
       	setLanguage(mLocale);


        return preferences;
    }


    private String getVersion() {
    	String versionNumber;
    	try {
            String pkg = this.getPackageName();
            versionNumber = this.getPackageManager().getPackageInfo(pkg, 0).versionName;
        } catch (NameNotFoundException e) {
            versionNumber = ""?"";
        }
        return versionNumber;
    }


    private String getVersionMessage() {
    	Resources res = getResources();
        StringBuilder builder = new StringBuilder();
        builder.append(res.getString(R.string.new_version_message));
        builder.append(""<ul>"");
        String[] features = res.getStringArray(R.array.new_version_features);
        for (int i = 0; i < features.length; i++) {
        	builder.append(""<li>"");
        	builder.append(features[i]);
        	builder.append(""</li>"");
        }
        builder.append(""</ul>"");
    	return builder.toString();
    }


    private void setLanguage(String language) {
    	Locale locale;
    	if (language.equals("""")) {
        	return;
    	} else {
        	locale = new Locale(language);
    	}
        Configuration config = new Configuration();
        config.locale = locale;
        this.getResources().updateConfiguration(config, this.getResources().getDisplayMetrics());
    }


    private void displayProgressDialogAndLoadDeck() {
        displayProgressDialogAndLoadDeck(false);
    }


    private void displayProgressDialogAndLoadDeck(boolean updateAllCards) {
        // Log.i(AnkiDroidApp.TAG, ""displayProgressDialogAndLoadDeck - Loading deck "" + mDeckFilename);

        // Don't open database again in onResume() until we know for sure this attempt to load the deck is finished
        // deckSelected = true;

        // if(isSdCardMounted())
        // {
        if (mDeckFilename != null && new File(mDeckFilename).exists()) {
            // showControls(false);

        	mToggleCram.setChecked(false);
        	mToggleLimit.setEnabled(true);

            if (updateAllCards) {
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK_AND_UPDATE_CARDS, mLoadDeckHandler,
                        new DeckTask.TaskData(AnkiDroidApp.deck(), mDeckFilename));
            } else {
                DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_DECK, mLoadDeckHandler, new DeckTask.TaskData(
                		AnkiDroidApp.deck(), mDeckFilename));
            }
        } else {
            if (mDeckFilename == null) {
                // Log.i(AnkiDroidApp.TAG, ""displayProgressDialogAndLoadDeck - SD card unmounted."");
            } else if (!new File(mDeckFilename).exists()) {
                // Log.i(AnkiDroidApp.TAG, ""displayProgressDialogAndLoadDeck - The deck "" + mDeckFilename + "" does not exist."");
            }

            // Show message informing that no deck has been loaded
            // displayDeckNotLoaded();
        }
        // } else
        // {
        // // Log.i(AnkiDroidApp.TAG, ""displayProgressDialogAndLoadDeck - SD card unmounted."");
        // deckSelected = false;
        // // Log.i(AnkiDroidApp.TAG, ""displayProgressDialogAndLoadDeck - deckSelected = "" + deckSelected);
        // displaySdError();
        // }
    }


    DeckTask.TaskListener mRepairDeckHandler = new DeckTask.TaskListener() {

    	@Override
        public void onPreExecute() {
            mProgressDialog = ProgressDialog.show(StudyOptions.this, """", getResources()
                    .getString(R.string.backup_repair_deck_progress), true);
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
        	if (result.getBoolean()) {
        		displayProgressDialogAndLoadDeck();
        	} else {
        		Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.deck_repair_error), true);
        	}
        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
        		mProgressDialog.dismiss();
        	}
        }
 
		@Override
		public void onProgressUpdate(TaskData... values) {
		}

    };


    DeckTask.TaskListener mRestoreDeckHandler = new DeckTask.TaskListener() {

    	@Override
        public void onPreExecute() {
            mProgressDialog = ProgressDialog.show(StudyOptions.this, """", getResources()
                    .getString(R.string.backup_restore_deck), true);
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
			switch (result.getInt()) {
    		case BackupManager.RETURN_DECK_RESTORED:
    			displayProgressDialogAndLoadDeck();
    			return;    			
    		case BackupManager.RETURN_ERROR:
    			showDialog(DIALOG_DECK_NOT_LOADED);
        		Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.backup_restore_error), true);
    			break;
    		case BackupManager.RETURN_NOT_ENOUGH_SPACE:
    			mCurrentDialogMessage = getResources().getString(R.string.backup_deck_no_space_left);
    			showDialog(DIALOG_NO_SPACE_LEFT);
    			break;
    		}
        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
        		mProgressDialog.dismiss();
        	}
        }

		@Override
		public void onProgressUpdate(TaskData... values) {
		}

    };


    DeckTask.TaskListener mLoadDeckHandler = new DeckTask.TaskListener() {

        @Override
        public void onPreExecute() {
            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
            // if(updateDialog == null || !updateDialog.isShowing())
            // {
        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
        		mProgressDialog.setMessage(getResources().getString(R.string.loading_deck));
        	} else {
                mProgressDialog = ProgressDialog.show(StudyOptions.this, """", getResources()
                        .getString(R.string.loading_deck), true, true, new OnCancelListener() {

    						@Override
    						public void onCancel(DialogInterface dialog) {
    							mNewVersionAlert = null;
    							DeckTask.cancelTask();
    				            closeOpenedDeck();
    				            MetaDB.closeDB();
    				            finish();
    						}
                });
        	}
	    	hideDeckInformation(false);
            // }
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {

            // Close the previously opened deck.
            // if (AnkidroidApp.deck() != null)
            // {
            // AnkidroidApp.deck().closeDeck();
            // AnkidroidApp.setDeck(null);
            // mCompat.invalidateOptionsMenu(StudyOptions.this);
            // }
            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);

            allTags = null;

            switch (result.getInt()) {
                case DeckTask.DECK_LOADED:
                    // Set the deck in the application instance, so other activities
                    // can access the loaded deck.
                    AnkiDroidApp.setDeck(result.getDeck());
                    mCompat.invalidateOptionsMenu(StudyOptions.this);

                    showContentView(CONTENT_STUDY_OPTIONS);
                    showDeckInformation(true);

                    if (!mPrefStudyOptions) {
                		mInReviewer = true;
                        startActivityForResult(new Intent(StudyOptions.this, Reviewer.class), REQUEST_REVIEW);
                    }

                    break;

                case DeckTask.DECK_NOT_LOADED:
                	BackupManager.restoreDeckIfMissing(mDeckFilename);
                	showContentView(CONTENT_DECK_NOT_LOADED);
                    break;

                case DeckTask.DECK_EMPTY:
                    // displayNoCardsInDeck();
                    break;
                case DeckTask.TUTORIAL_NOT_CREATED:
                	Themes.showThemedToast(StudyOptions.this, getResources().getString(R.string.tutorial_loading_error), false);
                	break;
            }

            // This verification would not be necessary if onConfigurationChanged it's executed correctly (which seems
            // that emulator does not do)
            if (mProgressDialog.isShowing()) {
                try {
                    mProgressDialog.dismiss();
                } catch (Exception e) {
                    Log.e(AnkiDroidApp.TAG, ""onPostExecute - Dialog dismiss Exception = "" + e.getMessage());
                }
                if (mNewVersionAlert != null) {
                	try {
                        mNewVersionAlert.show();
                    } catch (Exception e) {
                        Log.e(AnkiDroidApp.TAG, ""onPostExecute - Show new version dialog exception = "" + e.getMessage());
                	}
                }
            }
            Deck deck = AnkiDroidApp.deck();
            if (deck != null) {
                mToggleLimit.setChecked(deck.isLimitedByTag() || deck.getSessionRepLimit() + deck.getSessionTimeLimit() > 0);
            }
        }


        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        	Resources res = getResources();
        	String message = values[0].getString();
        	if (message == null) {
				switch (values[0].getInt()) {
        		case BackupManager.RETURN_BACKUP_CREATED:
            		Themes.showThemedToast(StudyOptions.this, res.getString(R.string.backup_deck_success), true);
        		case BackupManager.RETURN_TODAY_ALREADY_BACKUP_DONE:
        		case BackupManager.RETURN_DECK_NOT_CHANGED:
            		if (mProgressDialog.isShowing()) {
                		mProgressDialog.setMessage(res.getString(R.string.loading_deck));
                	}
        			break;
        		case BackupManager.RETURN_ERROR:
        			showDialog(DIALOG_BACKUP_ERROR);
        			break;
        		case BackupManager.RETURN_NOT_ENOUGH_SPACE:
        			mCurrentDialogMessage = getResources().getString(R.string.backup_deck_no_space_left);
        			showDialog(DIALOG_BACKUP_NO_SPACE_LEFT);
        			break;
        		case BackupManager.RETURN_LOW_SYSTEM_SPACE:
        			if (!PrefSettings.getSharedPrefs(getBaseContext()).getBoolean(""dontShowLowMemory"", false)) {
            			mCurrentDialogMessage = getResources().getString(R.string.sd_space_warning, MIN_FREE_SPACE);
            			showDialog(DIALOG_NO_SPACE_LEFT);        				
        			}
        			break;
        		}
        	} else {
        		mProgressDialog.setMessage(message);
        	}
        }
    };


    Connection.TaskListener mSyncListener = new Connection.TaskListener() {

        @Override
        public void onDisconnected() {
        	showDialog(DIALOG_NO_CONNECTION);
        }


        @Override
        public void onPostExecute(Payload data) {
            // Log.i(AnkiDroidApp.TAG, ""onPostExecute"");
            if (mProgressDialog != null) {
                mProgressDialog.dismiss();
                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR);
            }
            if (data.success) {
            	mCurrentDialogMessage = ((HashMap<String, String>) data.result).get(""message"");
                AnkiDroidApp.deck().updateCutoff();
                resetAndUpdateValuesFromDeck();
                showDialog(DIALOG_SYNC_LOG);
            } else {
                if (data.returnType == AnkiDroidProxy.DB_ERROR) {
                	showDialog(DIALOG_DB_ERROR);
                } else if (data.returnType == AnkiDroidProxy.SYNC_CONFLICT_RESOLUTION) {
                    // Need to ask user for conflict resolution direction and re-run sync
                    syncDeckWithPrompt();
                } else {
                    String errorMessage = ((HashMap<String, String>) data.result).get(""message"");
                    if ((errorMessage != null) && (errorMessage.length() > 0)) {
                    	mCurrentDialogMessage = errorMessage;
                    }
                    showDialog(DIALOG_CONNECTION_ERROR);
                }
            }
        }


        @Override
        public void onPreExecute() {
            // Pass
        }


        @Override
        public void onProgressUpdate(Object... values) {
            if (values[0] instanceof Boolean) {
                // This is the part Download missing media of syncing
                Resources res = getResources();
                int total = ((Integer)values[1]).intValue();
                int done = ((Integer)values[2]).intValue();
                values[0] = ((String)values[3]);
                values[1] = res.getString(R.string.sync_downloading_media, done, total);
            }
            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = ProgressDialog.show(StudyOptions.this, (String) values[0], (String) values[1]);
                // Forbid orientation changes as long as progress dialog is shown
                setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_NOSENSOR);
            } else {
                mProgressDialog.setTitle((String) values[0]);
                mProgressDialog.setMessage((String) values[1]);
            }
        }

    };


    DeckTask.TaskListener mLoadStatisticsHandler = new DeckTask.TaskListener() {

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
            if (mProgressDialog.isShowing()) {
                try {
                    mProgressDialog.dismiss();
                } catch (Exception e) {
                    Log.e(AnkiDroidApp.TAG, ""onPostExecute - Dialog dismiss Exception = "" + e.getMessage());
                }
            }
            if (result.getBoolean()) {
		    	if (mStatisticType == Statistics.TYPE_DECK_SUMMARY) {
		    		Statistics.showDeckSummary(StudyOptions.this);
		    	} else {
	            	Intent intent = new Intent(StudyOptions.this, com.ichi2.charts.ChartBuilder.class);
			    	startActivityForResult(intent, STATISTICS);
			        if (getApiLevel() > 4) {
			            ActivityTransitionAnimation.slide(StudyOptions.this, ActivityTransitionAnimation.DOWN);
			        }
		    	}
			}
		}

		@Override
		public void onPreExecute() {
            mProgressDialog = ProgressDialog.show(StudyOptions.this, """", getResources()
                    .getString(R.string.calculating_statistics), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
		}

    };


    DeckTask.TaskListener mSaveAndResetDeckHandler = new DeckTask.TaskListener() {
        @Override
        public void onPreExecute() {
        	mDeckNotAvailable = true;
        }
        @Override
        public void onPostExecute(DeckTask.TaskData result) {
        	mDeckNotAvailable = false;
        	updateValuesFromDeck();
        }
        @Override
        public void onProgressUpdate(DeckTask.TaskData... values) {
        }
    };


    class MyGestureDetector extends SimpleOnGestureListener {
    	@Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            if (mSwipeEnabled) {
            	try {
    				if (e1.getX() - e2.getX() > sSwipeMinDistance && Math.abs(velocityX) > sSwipeThresholdVelocity && Math.abs(e1.getY() - e2.getY()) < sSwipeMaxOffPath) {
                        // left
                    	openReviewer();
                    } else if (e2.getX() - e1.getX() > sSwipeMinDistance && Math.abs(velocityX) > sSwipeThresholdVelocity && Math.abs(e1.getY() - e2.getY()) < sSwipeMaxOffPath) {
                        // right
    					openDeckPicker();
                    } else if (e2.getY() - e1.getY() > sSwipeMinDistance && Math.abs(velocityY) > sSwipeThresholdVelocity && Math.abs(e1.getX() - e2.getX()) < sSwipeMaxOffPath) {
                        // down
                    	mStatisticType = 0;
                    	openStatistics(0);
                    }

                }
                catch (Exception e) {
                	Log.e(AnkiDroidApp.TAG, ""onFling Exception = "" + e.getMessage());
                }
            }
            return false;
        }
    }
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (gestureDetector.onTouchEvent(event))
	        return true;
	    else
	    	return false;
    }


    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        String deck = intent.getStringExtra(EXTRA_DECK);
        // Log.d(AnkiDroidApp.TAG, ""StudyOptions.onNewIntent: "" + intent + "", deck="" + deck);
        if (deck != null && !deck.equals(mDeckFilename)) {
            mDeckFilename = deck;
            loadPreviousDeck();
        }
    }


    /**
     * Creates an intent to load a deck given the full pathname of it.
     * <p>
     * The constructed intent is equivalent (modulo the extras) to the open used by the launcher
     * shortcut, which means it will not open a new study options window but bring the existing one
     * to the front.
     */
    public static Intent getLoadDeckIntent(Context context, String deckPath) {
        Intent loadDeckIntent = new Intent(context, StudyOptions.class);
        loadDeckIntent.setAction(Intent.ACTION_MAIN);
        loadDeckIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        loadDeckIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        loadDeckIntent.putExtra(StudyOptions.EXTRA_DECK, deckPath);
        return loadDeckIntent;
    }


	@Override
	public void buttonPressed(ButtonEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void buttonReleased(ButtonEvent arg0) {
		// Log.d(""Zeemote"",""Button released, id: ""+arg0.getButtonID());
		Message msg = Message.obtain();
		msg.what = MSG_ZEEMOTE_BUTTON_A + arg0.getButtonID(); //Button A = 0, Button B = 1...
		if ((msg.what >= MSG_ZEEMOTE_BUTTON_A) && (msg.what <= MSG_ZEEMOTE_BUTTON_D)) { //make sure messages from future buttons don't get throug
			this.ZeemoteHandler.sendMessage(msg);
		}
		if (arg0.getButtonID()==-1)
		{
			msg.what = MSG_ZEEMOTE_BUTTON_D+arg0.getButtonGameAction();
			if ((msg.what >= MSG_ZEEMOTE_STICK_UP) && (msg.what <= MSG_ZEEMOTE_STICK_RIGHT)) { //make sure messages from future buttons don't get throug
				this.ZeemoteHandler.sendMessage(msg);
			}
		}
	}
}
",True,48,69,1,6,4,33
32,com.ichi2.anki.SharedDeck.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.util.Log;

import java.util.HashMap;

public class SharedDeck extends HashMap<String, Object> {

    private static final long serialVersionUID = 1L;

    private int mId;
    private String mUsername;
    private String mTitle;
    private String mDescription;
    private String mTags;
    private int mVersion;
    private int mFacts;
    private int mSize;
    private int mCount;
    private double mModified;
    private String mFileName;
    /**
     * on demand cache for filtering only
     */
    private String mLowerCaseTitle;


    public int getId() {
        return mId;
    }


    public void setId(int id) {
        mId = id;
    }


    public void setUsername(String username) {
        mUsername = username;
    }


    public String getTitle() {
        return mTitle;
    }


    public void setTitle(String title) {
        mTitle = title;
        put(""title"", mTitle);
    }


    public void setDescription(String description) {
        mDescription = description;
    }


    public void setTags(String tags) {
        mTags = tags;
    }


    public void setVersion(int version) {
        mVersion = version;
    }


    public int getFacts() {
        return mFacts;
    }


    public void setFacts(int facts) {
        mFacts = facts;
        if (facts == 1) {
            put(""facts"", mFacts + "" "" + AnkiDroidApp.getAppResources().getString(R.string.fact));
        } else {
            put(""facts"", mFacts + "" "" + AnkiDroidApp.getAppResources().getString(R.string.facts));
        }
    }


    public int getSize() {
        return mSize;
    }


    public void setSize(int size) {
        mSize = size;
    }


    public void setCount(int count) {
        mCount = count;
    }


    public void setModified(double modified) {
        mModified = modified;
    }


    public void setFileName(String fileName) {
        mFileName = fileName;
    }


    public void prettyLog() {
        // Log.i(AnkiDroidApp.TAG, ""SHARED DECK:"");
        // Log.i(AnkiDroidApp.TAG, ""        username = "" + mUsername);
        // Log.i(AnkiDroidApp.TAG, ""        title = "" + mTitle);
        // Log.i(AnkiDroidApp.TAG, ""        description = "" + mDescription);
        // Log.i(AnkiDroidApp.TAG, ""        tags = "" + mTags);
        // Log.i(AnkiDroidApp.TAG, ""        version = "" + mVersion);
        // Log.i(AnkiDroidApp.TAG, ""        facts = "" + mFacts);
        // Log.i(AnkiDroidApp.TAG, ""        size = "" + mSize);
        // Log.i(AnkiDroidApp.TAG, ""        count = "" + mCount);
        // Log.i(AnkiDroidApp.TAG, ""        modified = "" + mModified);
        // Log.i(AnkiDroidApp.TAG, ""        fileName = "" + mFileName);
    }


	public boolean matchesLowerCaseFilter(String searchText) {
		// cache our own lower case title, so the next letters in the filter string will be faster
		if (mLowerCaseTitle == null) {
			mLowerCaseTitle = getTitle().toLowerCase();
		}
		return mLowerCaseTitle.contains(searchText);
	}
}
",False,87,64,1,1,5,27
33,com.ichi2.anki.Feedback.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.Application;
import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.SimpleAdapter;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.message.BasicNameValuePair;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.TimeZone;
import java.util.UUID;

public class Feedback extends Activity {
    public static String REPORT_ASK = ""2"";
    public static String REPORT_NEVER = ""1"";
    public static String REPORT_ALWAYS = ""0"";

    public static String STATE_WAITING = ""0"";
    public static String STATE_UPLOADING = ""1"";
    public static String STATE_SUCCESSFUL = ""2"";
    public static String STATE_FAILED = ""3"";

    public static String TYPE_STACKTRACE = ""crash-stacktrace"";
    public static String TYPE_FEEDBACK = ""feedback"";
    public static String TYPE_ERROR_FEEDBACK = ""error-feedback"";
    public static String TYPE_OTHER_ERROR = ""other-error"";

    protected static SimpleDateFormat df1 = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"", Locale.US);
    protected static SimpleDateFormat df2 = new SimpleDateFormat(""Z"", Locale.US);
    protected static TimeZone localTz = TimeZone.getDefault();

	// This is used to group the batch of bugs and notes sent on the server side
	protected long mNonce;

	protected List<HashMap<String, String>> mErrorReports;
    protected SimpleAdapter mErrorAdapter;
    protected ListView mLvErrorList;
    protected EditText mEtFeedbackText;
    protected boolean mPostingFeedback;
    protected InputMethodManager mImm = null;
    protected StyledDialog mNoConnectionAlert = null;

    protected String mReportErrorMode;
    protected String mFeedbackUrl;
    protected String mErrorUrl;

    private boolean mErrorsSent = false;


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)  {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
        	deleteFiles(true, false);
	        closeFeedback();
        }
        return super.onKeyDown(keyCode, event);
    }


    /**
     * Create AlertDialogs used on all the activity
     */
    private void initAllAlertDialogs() {
        Resources res = getResources();

        StyledDialog.Builder builder = new StyledDialog.Builder(this);

        builder.setTitle(res.getString(R.string.connection_error_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.connection_needed));
        builder.setPositiveButton(res.getString(R.string.ok), new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                mPostingFeedback = false;
                refreshInterface();
            }
        });
        mNoConnectionAlert = builder.create();
    }


	private void closeFeedback() {
	        setResult(RESULT_OK);
		finish();
                if (StudyOptions.getApiLevel() > 4) {
                    ActivityTransitionAnimation.slide(Feedback.this, ActivityTransitionAnimation.FADE);
                }
	}


    private void refreshInterface() {
        if (mReportErrorMode.equals(REPORT_ASK)) {
            Resources res = getResources();
            Button btnSend = (Button) findViewById(R.id.btnFeedbackSend);
            Button btnKeepLatest = (Button) findViewById(R.id.btnFeedbackKeepLatest);
            Button btnClearAll = (Button) findViewById(R.id.btnFeedbackClearAll);
            ProgressBar pbSpinner = (ProgressBar) findViewById(R.id.pbFeedbackSpinner);
    
            int numErrors = mErrorReports.size();
            if (numErrors == 0 || mErrorsSent) {
            	if (!mErrorsSent) {
                    mLvErrorList.setVisibility(View.GONE);
            	}
                btnKeepLatest.setVisibility(View.GONE);
                btnClearAll.setVisibility(View.GONE);
                btnSend.setText(res.getString(R.string.feedback_send_feedback));
            } else {
                mLvErrorList.setVisibility(View.VISIBLE);
                btnKeepLatest.setVisibility(View.VISIBLE);
                btnClearAll.setVisibility(View.VISIBLE);
                btnSend.setText(res.getString(R.string.feedback_send_feedback_and_errors));
                refreshErrorListView();
                if (numErrors == 1) {
                    btnKeepLatest.setEnabled(false);
                } else {
                    btnKeepLatest.setEnabled(true);
                }
            }
    
            if (mPostingFeedback) {
                int buttonHeight = btnSend.getHeight();
                btnSend.setVisibility(View.GONE);
                pbSpinner.setVisibility(View.VISIBLE);
                LinearLayout topLine = (LinearLayout) findViewById(R.id.llFeedbackTopLine);
                topLine.setMinimumHeight(buttonHeight);
    
                mEtFeedbackText.setEnabled(false);
                mImm.hideSoftInputFromWindow(mEtFeedbackText.getWindowToken(), 0);
            } else {
                btnSend.setVisibility(View.VISIBLE);
                pbSpinner.setVisibility(View.GONE);
                mEtFeedbackText.setEnabled(true);
            }
        }
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);

        Resources res = getResources();

        Context context = getBaseContext();
        SharedPreferences sharedPreferences = PrefSettings.getSharedPrefs(context);
        mReportErrorMode = sharedPreferences.getString(""reportErrorMode"", REPORT_ASK);

        mNonce = UUID.randomUUID().getMostSignificantBits();
        mFeedbackUrl = res.getString(R.string.feedback_post_url);
        mErrorUrl = res.getString(R.string.error_post_url);
        mImm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);

        mPostingFeedback = false;
        initAllAlertDialogs();

        getErrorFiles();
        if (mReportErrorMode.equals(REPORT_ALWAYS)) { // Always report
            try {
                String feedback = ""Automatically sent"";
                Connection.sendFeedback(mSendListener, new Payload(new Object[] {
                        mFeedbackUrl, mErrorUrl, feedback, mErrorReports, mNonce, getApplication(), true}));
                if (mErrorReports.size() > 0) {
                    mPostingFeedback = true;
                }
                if (feedback.length() > 0) {
                    mPostingFeedback = true;
                }
            } catch (Exception e) {
                Log.e(AnkiDroidApp.TAG, e.toString());
            }
            closeFeedback();
            return;
        } else if (mReportErrorMode.equals(REPORT_NEVER)) { // Never report
            deleteFiles(false, false);
            closeFeedback();
        }

        View mainView = getLayoutInflater().inflate(R.layout.feedback, null);
        setContentView(mainView);
        Themes.setWallpaper(mainView);
        Themes.setTextViewStyle(findViewById(R.id.tvFeedbackDisclaimer));
        Themes.setTextViewStyle(findViewById(R.id.lvFeedbackErrorList));
        
        Button btnSend = (Button) findViewById(R.id.btnFeedbackSend);
        Button btnKeepLatest = (Button) findViewById(R.id.btnFeedbackKeepLatest);
        Button btnClearAll = (Button) findViewById(R.id.btnFeedbackClearAll);
        mEtFeedbackText = (EditText) findViewById(R.id.etFeedbackText);
        mLvErrorList = (ListView) findViewById(R.id.lvFeedbackErrorList);

        mErrorAdapter = new SimpleAdapter(this, mErrorReports,
                R.layout.error_item, new String[] {""name"", ""state"", ""result""}, new int[] {
                    R.id.error_item_text, R.id.error_item_progress, R.id.error_item_status});
        mErrorAdapter.setViewBinder(new SimpleAdapter.ViewBinder() {
            @Override
            public boolean setViewValue(View view, Object arg1, String text) {
                switch(view.getId()) {
                    case R.id.error_item_progress:
                        if (text.equals(STATE_UPLOADING)) {
                            view.setVisibility(View.VISIBLE);
                        } else {
                            view.setVisibility(View.GONE);
                        }
                        return true;
                    case R.id.error_item_status:
                        if (text.length() == 0) {
                            view.setVisibility(View.GONE);
                            return true;
                        } else {
                            view.setVisibility(View.VISIBLE);
                            return false;
                        }
                }
                return false;
            }
        });

        btnClearAll.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                deleteFiles(false, false);
                refreshErrorListView();
                refreshInterface();
            }
        });

        mLvErrorList.setAdapter(mErrorAdapter);

        btnSend.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                if (!mPostingFeedback) {
                    String feedback = mEtFeedbackText.getText().toString();
                    Connection.sendFeedback(mSendListener, new Payload(new Object[] {
                            mFeedbackUrl, mErrorUrl, feedback, mErrorReports, mNonce, getApplication(), false}));
                    if (mErrorReports.size() > 0) {
                        mPostingFeedback = true;
                    }
                    if (feedback.length() > 0) {
                        mPostingFeedback = true;
                    }
                    refreshInterface();
                }
            }
        });

        btnKeepLatest.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                deleteFiles(false, true);
                refreshErrorListView();
                refreshInterface();
            }
        });

        refreshInterface();

        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN |
                WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);

    }

    private void refreshErrorListView() {
        if (mReportErrorMode.equals(REPORT_ASK)) {
            mErrorAdapter.notifyDataSetChanged();
        }
    }

    private void getErrorFiles() {
        mErrorReports = new ArrayList<HashMap<String, String>>();
        String[] errors = fileList();

        for (String file : errors) {
            if (file.endsWith("".stacktrace"")) {
                HashMap<String, String> error = new HashMap<String, String>();
                error.put(""filename"", file);
                error.put(""name"", file);
                error.put(""state"", STATE_WAITING);
                error.put(""result"", """");
                mErrorReports.add(error);
            }
        }
    }

    /**
     * Delete the crash log files.
     * @param onlyProcessed only delete the log files that have been sent.
     * @param keepLatest keep the latest log file. If the file has not been sent yet, it is
     * not deleted even if this value is set to false.
     */
    private void deleteFiles(boolean onlyProcessed, boolean keepLatest) {

        for (int i = (keepLatest? 1: 0); i < mErrorReports.size(); ) {
            try {
                String errorState = mErrorReports.get(i).get(""state"");
                if (!onlyProcessed || errorState.equals(STATE_SUCCESSFUL)) {
                    deleteFile(mErrorReports.get(i).get(""filename""));
                    mErrorReports.remove(i);
                } else {
                    i++;
                }
            } catch (Exception e) {
                Log.e(AnkiDroidApp.TAG, String.format(""Could not delete file: %s"", mErrorReports.get(i)));
            }
        }
    }

    public static boolean isErrorType(String postType) {
        return !(postType.equals(TYPE_FEEDBACK) || postType.equals(TYPE_ERROR_FEEDBACK));
    }

    Connection.TaskListener mSendListener = new Connection.TaskListener() {

        @Override
        public void onDisconnected() {
            if (mNoConnectionAlert != null) {
                mNoConnectionAlert.show();
            }
        }

        @Override
        public void onPostExecute(Payload data) {
            mPostingFeedback = false;
            mErrorsSent = true;
            refreshInterface();
        }

        @Override
        public void onPreExecute() {
            // pass
        }

        @Override
        public void onProgressUpdate(Object... values) {
            Resources res = getResources();

            String postType = (String)values[0];
            int errorIndex = (Integer)values[1];
            String state = (String)values[2];

            if (isErrorType(postType) && mErrorReports.size() > errorIndex) {
                mErrorReports.get(errorIndex).put(""state"", state);
                if (!state.equals(Feedback.STATE_UPLOADING)) {
                    int returnCode = (Integer)values[3];
                    if (returnCode == 200) {
                        // The result is either: ""new"" (for first encountered bug), ""known"" (for existing bugs) or
                        // (""issue:xxx:<status>"" for known and linked)
                        String result = (String)values[4];
                        if (result.equalsIgnoreCase(""new"")) {
                            mErrorReports.get(errorIndex).put(""name"", res.getString(R.string.feedback_error_reply_new));
                        } else if (result.equalsIgnoreCase(""known"")) {
                            mErrorReports.get(errorIndex).put(""name"", res.getString(R.string.feedback_error_reply_known));
                        } else if (result.startsWith(""issue:"")) {
                            String[] resultPieces = result.split("":"");
                            int issue = Integer.parseInt(resultPieces[1]);
                            String status = """";
                            if (resultPieces.length > 1) {
                                if (resultPieces.length > 2) {
                                    status = resultPieces[2];
                                }
                                if (status.length() == 0) {
                                    mErrorReports.get(errorIndex).put(""name"",
                                            res.getString(R.string.feedback_error_reply_issue_unknown, issue));
                                } else if (status.equalsIgnoreCase(""fixed"")) {
                                    mErrorReports.get(errorIndex).put(""name"",
                                            res.getString(R.string.feedback_error_reply_issue_fixed_prod, issue));
                                } else if (status.equalsIgnoreCase(""fixedindev"")) {
                                    mErrorReports.get(errorIndex).put(""name"",
                                            res.getString(R.string.feedback_error_reply_issue_fixed_dev, issue));
                                } else {
                                    mErrorReports.get(errorIndex).put(""name"",
                                            res.getString(R.string.feedback_error_reply_issue_status, issue, status));
                                }
                            } else {
                                mErrorReports.get(errorIndex).put(""result"",
                                        res.getString(R.string.feedback_error_reply_malformed));
                            }
                        } else {
                            mErrorReports.get(errorIndex).put(""result"",
                                    res.getString(R.string.feedback_error_reply_malformed));
                        }
                    } else {
                        mErrorReports.get(errorIndex).put(""result"", res.getString(R.string.feedback_error_reply_failed));
                    }
                }
                refreshErrorListView();
            } else {
                if (mReportErrorMode.equals(REPORT_ASK)) {
                    if (state.equals(STATE_SUCCESSFUL)) {
                        mEtFeedbackText.setText("""");
                        Themes.showThemedToast(Feedback.this, res.getString(R.string.feedback_message_sent_success), false);
                    } else if (state.equals(STATE_FAILED)) {
                        int respCode = (Integer)values[3];
                        if (respCode == 0) {
                            onDisconnected();
                        } else {
                        	Themes.showThemedToast(Feedback.this, res.getString(R.string.feedback_message_sent_failure, respCode), false);
                        }
                    }
                }
            }
        }
    };


    // Run in AsyncTask

    private static void addTimestamp(List<NameValuePair> pairs) {
        Date ts = new Date();
        df1.setTimeZone(TimeZone.getTimeZone(""UTC""));

        String reportsentutc = String.format(""%s"", df1.format(ts));
        String reportsenttzoffset = String.format(""%s"", df2.format(ts));
        String reportsenttz = String.format(""%s"", localTz.getID());

        pairs.add(new BasicNameValuePair(""reportsentutc"", reportsentutc));
        pairs.add(new BasicNameValuePair(""reportsenttzoffset"", reportsenttzoffset));
        pairs.add(new BasicNameValuePair(""reportsenttz"", reportsenttz));
    }

    private static List<NameValuePair> extractPairsFromError(String type, String errorFile, String groupId, int index, Application app) {
        List<NameValuePair> pairs = new ArrayList<NameValuePair>();

        pairs.add(new BasicNameValuePair(""type"", ""crash-stacktrace""));
        pairs.add(new BasicNameValuePair(""groupid"", groupId));
        pairs.add(new BasicNameValuePair(""index"", String.valueOf(index)));
        addTimestamp(pairs);

        String singleLine = null;
        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(app.openFileInput(errorFile)));
            while((singleLine = br.readLine()) != null) {
                int indexOfEquals = singleLine.indexOf('=');

                if(indexOfEquals==-1)
                    continue;

                String key = singleLine.substring(0, indexOfEquals).toLowerCase();
                String value = singleLine.substring(indexOfEquals+1,singleLine.length());

                if(key.equals(""stacktrace"")) {
                    StringBuilder sb = new StringBuilder(value);

                    while((singleLine = br.readLine()) != null) {
                        sb.append(singleLine);
                        sb.append(""\n"");
                    }

                    value = sb.toString();
                }
                pairs.add(new BasicNameValuePair(key, value));
            }
            br.close();
        } catch (FileNotFoundException e) {
            Log.w(AnkiDroidApp.TAG, ""Couldn't open crash report "" + errorFile);
            return null;
        } catch (IOException e) {
            Log.w(AnkiDroidApp.TAG, ""Couldn't read crash report "" + errorFile);
            return null;
        }

        return pairs;
    }

    /**
     * Posting feedback or error info to the server.
     * This is called from the AsyncTask.
     * @param url The url to post the feedback to.
     * @param type The type of the info, eg Feedback.TYPE_CRASH_STACKTRACE.
     * @param feedback For feedback types this is the message. For error/crash types this is the path to the error file.
     * @param groupId A single time generated ID, so that errors/feedback send together can be grouped together.
     * @param index The index of the error in the list
     * @return A Payload file showing success, response code and response message.
     */
    public static Payload postFeedback(String url, String type, String feedback, String groupId, int index, Application app) {
        Payload result = new Payload(null);

        List<NameValuePair> pairs = null;
        if (!isErrorType(type)) {
            pairs = new ArrayList<NameValuePair>();
            pairs.add(new BasicNameValuePair(""type"", type));
            pairs.add(new BasicNameValuePair(""groupid"", groupId));
            pairs.add(new BasicNameValuePair(""index"", ""0""));
            pairs.add(new BasicNameValuePair(""message"", feedback));
            addTimestamp(pairs);
        } else {
            pairs = Feedback.extractPairsFromError(type, feedback, groupId, index, app);
            if (pairs == null) {
                result.success = false;
                result.result = null;
            }
        }

        HttpClient httpClient = new DefaultHttpClient();
        HttpPost httpPost = new HttpPost(url);
        httpPost.addHeader(""User-Agent"", ""AnkiDroid"");
        try {
            httpPost.setEntity(new UrlEncodedFormEntity(pairs));
            HttpResponse response = httpClient.execute(httpPost);
            Log.e(AnkiDroidApp.TAG, String.format(""Bug report posted to %s"", url));

            int respCode = response.getStatusLine().getStatusCode();
            switch(respCode) {
                case 200:
                    result.success = true;
                    result.returnType = respCode;
                    result.result = Utils.convertStreamToString(response.getEntity().getContent());
                    // Log.i(AnkiDroidApp.TAG, String.format(""postFeedback OK: %s"", result.result));
                    break;

                default:
                    Log.e(AnkiDroidApp.TAG, String.format(""postFeedback failure: %d - %s"",
                                response.getStatusLine().getStatusCode(),
                                response.getStatusLine().getReasonPhrase()));
                    result.success = false;
                    result.returnType = respCode;
                    result.result = response.getStatusLine().getReasonPhrase();
                    break;
            }
        } catch (ClientProtocolException ex) {
            Log.e(AnkiDroidApp.TAG, ""ClientProtocolException: "" + ex.toString());
            result.success = false;
            result.result = ex.toString();
        } catch (IOException ex) {
            Log.e(AnkiDroidApp.TAG, ""IOException: "" + ex.toString());
            result.success = false;
            result.result = ex.toString();
        }
        return result;
    }

}

",True,59,63,0,0,5,27
34,com.ichi2.anki.SharedDeckPicker.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.res.Resources;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.AdapterView.AdapterContextMenuInfo;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.services.DownloadManagerService;
import com.ichi2.anki.services.IDownloadManagerService;
import com.ichi2.anki.services.ISharedDeckServiceCallback;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;

import java.util.ArrayList;
import java.util.List;

public class SharedDeckPicker extends Activity {

    // Context menu options
    private static final int MENU_CANCEL = Menu.FIRST + 1;
    private static final int MENU_PAUSE  = Menu.FIRST + 2;
    private static final int MENU_RESUME = Menu.FIRST + 3;

    /**
     * Broadcast that informs us when the sd card is about to be unmounted
     */
    private BroadcastReceiver mUnmountReceiver = null;

    private ProgressDialog mProgressDialog;
    private StyledDialog mNoConnectionAlert;
    private StyledDialog mConnectionErrorAlert;

    private Intent mDownloadManagerServiceIntent;
    // Service interface we will use to call the service
    private IDownloadManagerService mDownloadManagerService = null;

    private List<Download> mSharedDeckDownloads;
    private List<SharedDeck> mSharedDecks;
    private List<SharedDeck> mFoundSharedDecks;
    private ListView mSharedDecksListView;
    private SharedDecksAdapter mSharedDecksAdapter;
    private EditText mSearchEditText;

    private boolean mDownloadSuccessful = false;


    /********************************************************************
     * Lifecycle methods *
     ********************************************************************/

    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);

        setContentView(R.layout.download_deck_picker);

        initDownloadManagerService();
        registerExternalStorageListener();
        initDialogs();

        mSharedDeckDownloads = new ArrayList<Download>();
        mSharedDecks = new ArrayList<SharedDeck>();
        mFoundSharedDecks = new ArrayList<SharedDeck>();

        mSharedDecksAdapter = new SharedDecksAdapter();
        mSharedDecksListView = (ListView) findViewById(R.id.list);
        mSharedDecksListView.setAdapter(mSharedDecksAdapter);
        registerForContextMenu(mSharedDecksListView);

        mSearchEditText = (EditText) findViewById(R.id.shared_deck_download_search);
        mSearchEditText.addTextChangedListener(new TextWatcher() {
        	public void afterTextChanged(Editable s) {
                findDecks();
            }
            public void beforeTextChanged(CharSequence s, int start, int count, int after){}
            public void onTextChanged(CharSequence s, int start, int before, int count){}
        });

        mSharedDecksListView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
                Resources res = getResources();
                Object obj = getSharedDeckFromList(position);
                if (obj instanceof SharedDeck) {
                    SharedDeck selectedDeck = (SharedDeck) obj;

                    for (Download d : mSharedDeckDownloads) {
                        if (d.getTitle().equals(selectedDeck.getTitle())) {
                            // Duplicate downloads not allowed, sorry.
                        	Themes.showThemedToast(SharedDeckPicker.this, res.getString(R.string.duplicate_download), true);
                            return;
                        }
                    }

                    SharedDeckDownload sharedDeckDownload = new SharedDeckDownload(selectedDeck.getId(), selectedDeck
                        .getTitle());
                    sharedDeckDownload.setSize(selectedDeck.getSize());
                    mSharedDeckDownloads.add(sharedDeckDownload);
                    refreshSharedDecksList();

                    try {
                        startService(mDownloadManagerServiceIntent);
                        mDownloadManagerService.downloadFile(sharedDeckDownload);
                    } catch (RemoteException e) {
                        // There is nothing special we need to do if the service has crashed
                        Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                        e.printStackTrace();
                    }
                }
            }
        });
        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);

        Connection.getSharedDecks(mGetSharedDecksListener, new Connection.Payload(new Object[] {}));
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)  {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            // Log.i(AnkiDroidApp.TAG, ""SharedDeckPicker - onBackPressed()"");
            closeSharedDeckPicker();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }


    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
        Resources res = getResources();
        int position = ((AdapterContextMenuInfo) menuInfo).position;
        Object obj = getSharedDeckFromList(position);
        if (obj instanceof Download) {
            Download download = (Download) obj;
            menu.setHeaderTitle(download.getTitle());
            menu.add(Menu.NONE, MENU_CANCEL, Menu.NONE, res.getString(R.string.cancel_download));
            if (download.getStatus() == SharedDeckDownload.STATUS_PAUSED) {
                menu.add(Menu.NONE, MENU_RESUME, Menu.NONE, res.getString(R.string.resume_download));
            } else if (download.getStatus() == SharedDeckDownload.STATUS_UPDATING) {
                menu.add(Menu.NONE, MENU_PAUSE, Menu.NONE, res.getString(R.string.pause_download));
            }
       }
    }


    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        Object obj = getSharedDeckFromList(info.position);

        if (obj instanceof Download) {
            Download download = (Download) obj;

            switch (item.getItemId()) {
                case MENU_CANCEL:
                    download.setStatus(SharedDeckDownload.STATUS_CANCELLED);
                    break;
                case MENU_RESUME:
                    download.setStatus(SharedDeckDownload.STATUS_UPDATING);
                    try {
                        startService(mDownloadManagerServiceIntent);
                        mDownloadManagerService.resumeDownloadUpdating(download);
                    } catch (RemoteException e) {
                        // There is nothing special we need to do if the service has crashed
                        Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                        e.printStackTrace();
                    }
                    break;
                case MENU_PAUSE:
                    download.setStatus(Download.STATUS_PAUSED);
                    break;
            }
            mSharedDecksAdapter.notifyDataSetChanged();
            return true;
        }

        return super.onOptionsItemSelected(item);
    }


    @Override
    protected void onResume() {
        // Log.i(AnkiDroidApp.TAG, ""onResume"");
        super.onResume();
        if (mDownloadManagerService != null) {
            try {

                mDownloadManagerService.registerSharedDeckCallback(mCallback);
                setSharedDeckDownloads(mDownloadManagerService.getSharedDeckDownloads());
            } catch (RemoteException e) {
                // There is nothing special we need to do if the service has crashed
                Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                e.printStackTrace();
            }
        }
    }


    @Override
    protected void onPause() {
        super.onPause();
        if (mDownloadManagerService != null) {
            try {
                mDownloadManagerService.unregisterSharedDeckCallback(mCallback);
            } catch (RemoteException e) {
                // There is nothing special we need to do if the service has crashed
                Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                e.printStackTrace();
            }
        }
    }


    @Override
    protected void onDestroy() {
        super.onDestroy();
        releaseBroadcastReceiver();
        releaseService();
        releaseDialogs();
    }


    /********************************************************************
     * Custom methods *
     ********************************************************************/

    private void initDownloadManagerService() {
        mDownloadManagerServiceIntent = new Intent(SharedDeckPicker.this, DownloadManagerService.class);
        // Needed when the incomplete downloads are resumed while entering SharedDeckPicker
        // if the Service gets shut down, we want it to be restarted automatically, so for this to happen it has to be
        // started but not stopped
        startService(mDownloadManagerServiceIntent);
        bindService(mDownloadManagerServiceIntent, mConnection, Context.BIND_AUTO_CREATE);
    }


    private void releaseService() {
        if (mConnection != null) {
            unbindService(mConnection);
            mConnection = null;
        }
    }


    /**
     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications. The intent will call
     * closeExternalStorageFiles() if the external media is going to be ejected, so applications can clean up any files
     * they have open.
     */
    private void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String action = intent.getAction();
                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
                        finishNoStorageAvailable();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
            iFilter.addDataScheme(""file"");
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }


    private void releaseBroadcastReceiver() {
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
            mUnmountReceiver = null;
        }
    }


    /**
     * Create AlertDialogs used on all the activity
     */
    private void initDialogs() {
        Resources res = getResources();

        // Init alert dialogs
        StyledDialog.Builder builder = new StyledDialog.Builder(this);

        builder.setTitle(res.getString(R.string.connection_error_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.connection_needed));
        builder.setPositiveButton(res.getString(R.string.ok), new OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                closeSharedDeckPicker();
            }

        });
        mNoConnectionAlert = builder.create();

	builder = new StyledDialog.Builder(this);
        builder.setTitle(res.getString(R.string.connection_error_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.connection_error_return_message));
        builder.setPositiveButton(res.getString(R.string.retry), new OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                Connection.getSharedDecks(mGetSharedDecksListener, new Connection.Payload(new Object[] {}));
            }
        });
        builder.setNegativeButton(res.getString(R.string.cancel), new OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                closeSharedDeckPicker();
            }

        });
        mConnectionErrorAlert = builder.create();
    }


    private void releaseDialogs() {
        // Needed in order to not try to show the alerts when the Activity does not exist anymore
        mProgressDialog = null;
        // mNoConnectionAlert = null;
        // mConnectionFailedAlert = null;
        mConnectionErrorAlert = null;
    }


    private Object getSharedDeckFromList(int position) {
        // The ""list"" consists of all mSharedDeckDownloads followed by all mFoundSharedDecks
        if ( position < mSharedDeckDownloads.size() ) {
            return mSharedDeckDownloads.get(position);
        } else {
            return mFoundSharedDecks.get(position - mSharedDeckDownloads.size());
        }
    }


    private void findDecks() {
        if (mSearchEditText.getText().length() == 0) {
            mFoundSharedDecks = mSharedDecks;
        } else {
            List<SharedDeck> foundDecks = new ArrayList<SharedDeck>();
            String searchText = mSearchEditText.getText().toString().toLowerCase();
            for (SharedDeck sharedDeck : mSharedDecks) {
				if (sharedDeck.matchesLowerCaseFilter(searchText)) {
                    foundDecks.add(sharedDeck);
                }
            }
            mFoundSharedDecks = foundDecks;
        }
        refreshSharedDecksList();
    }


    private void refreshSharedDecksList() {
        mSharedDecksAdapter.notifyDataSetChanged();
    }


    private void setSharedDeckDownloads(List<SharedDeckDownload> downloads) {
        mSharedDeckDownloads.clear();
        mSharedDeckDownloads.addAll(downloads);
        refreshSharedDecksList();
    }


    private void finishNoStorageAvailable() {
        setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
        closeSharedDeckPicker();
    }


    private void closeSharedDeckPicker() {
    	if (mDownloadSuccessful) {
    		Intent intent = SharedDeckPicker.this.getIntent();
    		setResult(RESULT_OK, intent);
    	}
        finish();
        if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
            ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
        }           
    }

    /********************************************************************
     * Service Connection *
     ********************************************************************/

    /**
     * Class for interacting with the main interface of the service.
     */
    private ServiceConnection mConnection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName className, IBinder service) {
            // This is called when the connection with the service has been
            // established, giving us the service object we can use to
            // interact with the service. We are communicating with our
            // service through an IDL interface, so get a client-side
            // representation of that from the raw service object.
            mDownloadManagerService = IDownloadManagerService.Stub.asInterface(service);

            // Log.i(AnkiDroidApp.TAG, ""onServiceConnected"");
            // We want to monitor the service for as long as we are
            // connected to it.
            try {
                mDownloadManagerService.registerSharedDeckCallback(mCallback);
            } catch (RemoteException e) {
                // In this case the service has crashed before we could even
                // do anything with it; we can count on soon being
                // disconnected (and then reconnected if it can be restarted)
                // so there is no need to do anything here.
            }
        }


        @Override
        public void onServiceDisconnected(ComponentName name) {
            mDownloadManagerService = null;
        }
    };

    /********************************************************************
     * Listeners *
     ********************************************************************/

    private Connection.TaskListener mGetSharedDecksListener = new Connection.TaskListener() {

        @Override
        public void onDisconnected() {
            // Log.i(AnkiDroidApp.TAG, ""onDisconnected"");
            if (mNoConnectionAlert != null) {
                mNoConnectionAlert.show();
            }
        }


        @SuppressWarnings(""unchecked"")
        @Override
        public void onPostExecute(Payload data) {
            if (mProgressDialog != null) {
                mProgressDialog.dismiss();
            }
            if (data.success) {
                mSharedDecks.clear();
                mSharedDecks.addAll((List<SharedDeck>) data.result);
                findDecks();
            } else {
            	if (data.returnType == Connection.RETURN_TYPE_OUT_OF_MEMORY) {
    				Themes.showThemedToast(SharedDeckPicker.this, getResources().getString(R.string.error_insufficient_memory), false);
    		    	finish();            		
            	} else if (mConnectionErrorAlert != null) {
                    mConnectionErrorAlert.show();
                }
            }
        }


        @Override
        public void onPreExecute() {
            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = ProgressDialog.show(SharedDeckPicker.this, """",
                        getResources().getString(R.string.loading_shared_decks), true, true, new DialogInterface.OnCancelListener() {
                    @Override
                    public void onCancel(DialogInterface dialog) {
                        Connection.cancelGetSharedDecks();
                        closeSharedDeckPicker();
                    }
                });
            }
        }


        @Override
        public void onProgressUpdate(Object... values) {
            // Pass
        }

    };


    /********************************************************************
     * Callbacks *
     ********************************************************************/

    /**
     * This implementation is used to receive callbacks from the remote service.
     */
    private ISharedDeckServiceCallback mCallback = new ISharedDeckServiceCallback.Stub() {
        /**
         * This is called by the remote service regularly to tell us about new values. Note that IPC calls are
         * dispatched through a thread pool running in each process, so the code executing here will NOT be running in
         * our main thread like most other things -- so, to update the UI, we need to use a Handler to hop over there.
         */
        @Override
        public void publishProgress(List<SharedDeckDownload> downloads) throws RemoteException {
            // Log.i(AnkiDroidApp.TAG, ""publishProgress"");
            setSharedDeckDownloads(downloads);
        }
    };

    /********************************************************************
     * Adapters *
     ********************************************************************/

    public class SharedDecksAdapter extends BaseAdapter {

        @Override
        public int getCount() {
            return mSharedDeckDownloads.size() + mFoundSharedDecks.size();
        }


        @Override
        public Object getItem(int position) {
            return getSharedDeckFromList(position);
        }


        @Override
        public long getItemId(int position) {
            return position;
        }


        //@Override
        //public boolean isEnabled(int position) {
        //    return !(getSharedDeckFromList(position) instanceof Download);
        //}


        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            View row = convertView;
            DownloadViewWrapper wrapper = null;
            Resources res = getResources();

            if (row == null) {
                row = getLayoutInflater().inflate(R.layout.download_deck_item, null);
                Themes.setContentStyle(row, Themes.CALLER_DOWNLOAD_DECK);
                wrapper = new DownloadViewWrapper(row);
                row.setTag(wrapper);
            } else {
                wrapper = (DownloadViewWrapper) row.getTag();
            }

            TextView headerTitle = wrapper.getHeaderTitle();
            TextView downloadingSharedDeckTitle = wrapper.getDownloadTitle();
            ProgressBar progressBar = wrapper.getProgressBar();
            TextView progressText = wrapper.getProgressBarText();
            TextView estimatedText = wrapper.getEstimatedTimeText();
            TextView sharedDeckTitle = wrapper.getDeckTitle();
            TextView sharedDeckFacts = wrapper.getDeckFacts();

            progressBar.setIndeterminate(false);
            Object obj = getSharedDeckFromList(position);
            if (obj instanceof Download) {
                Download download = (Download) obj;

                sharedDeckTitle.setVisibility(View.GONE);
                sharedDeckFacts.setVisibility(View.GONE);

                if (position == 0) {
                    headerTitle.setText(res.getString(R.string.currently_downloading));
                    headerTitle.setVisibility(View.VISIBLE);
                } else {
                    headerTitle.setVisibility(View.GONE);
                }
                downloadingSharedDeckTitle.setText(download.getTitle());
                downloadingSharedDeckTitle.setVisibility(View.VISIBLE);
                progressBar.setVisibility(View.VISIBLE);
                switch (download.getStatus()) {
                    case Download.STATUS_STARTED:
                        progressText.setText(res.getString(R.string.starting_download));
                        estimatedText.setText("""");
                        progressBar.setProgress(0);
                        break;

                    case Download.STATUS_DOWNLOADING:
                        progressText.setText(res.getString(R.string.downloading));
                        estimatedText.setText("""");
                        progressBar.setProgress(download.getProgress());
                        break;

                    case Download.STATUS_PAUSED:
                        progressText.setText(res.getString(R.string.paused));
                        estimatedText.setText("""");
                        progressBar.setProgress(download.getProgress());
                        break;

                    case Download.STATUS_COMPLETE:
                        progressText.setText(res.getString(R.string.downloaded));
                        estimatedText.setText("""");
                        progressBar.setProgress(0);
                        mDownloadSuccessful = true;
                        break;

                    case SharedDeckDownload.STATUS_UPDATING:
                        progressText.setText(res.getString(R.string.updating));
                        estimatedText.setText(download.getEstTimeToCompletion());
                        progressBar.setProgress(download.getProgress());
                        break;

                    case Download.STATUS_CANCELLED:
                        progressText.setText(res.getString(R.string.cancelling));
                        estimatedText.setText("""");
                        progressBar.setProgress(download.getProgress());
                        break;

                    default:
                        progressText.setText(res.getString(R.string.error));
                        estimatedText.setText("""");
                        break;
                }
                progressText.setVisibility(View.VISIBLE);
                estimatedText.setVisibility(View.VISIBLE);
            } else {
                SharedDeck sharedDeck = (SharedDeck) obj;
                if (position > 0 && (getSharedDeckFromList(position - 1) instanceof Download)) {
                    headerTitle.setText(res.getString(R.string.shared_decks));
                    headerTitle.setVisibility(View.VISIBLE);
                } else {
                    headerTitle.setVisibility(View.GONE);
                }
                downloadingSharedDeckTitle.setVisibility(View.GONE);
                progressBar.setVisibility(View.GONE);
                progressText.setVisibility(View.GONE);
                estimatedText.setVisibility(View.GONE);

                sharedDeckTitle.setText(sharedDeck.getTitle());
                sharedDeckTitle.setVisibility(View.VISIBLE);
                int numFacts = sharedDeck.getFacts();
                if (numFacts == 1) {
                    sharedDeckFacts.setText(numFacts + "" "" + res.getString(R.string.fact));
                } else {
                    sharedDeckFacts.setText(numFacts + "" "" + res.getString(R.string.facts));
                }
                sharedDeckFacts.setVisibility(View.VISIBLE);
            }

            return row;
        }

    }
}
",True,57,68,0,0,5,28
35,com.ichi2.anki.DeckPicker.java,"/****************************************************************************************
 * Copyright (c) 2009 Andrew Dubya <andrewdubya@gmail.com>                              *
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             * 
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.DialogInterface.OnCancelListener;
import android.content.res.Resources;
import android.database.SQLException;
import android.database.sqlite.SQLiteException;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.preference.PreferenceManager;
import android.text.SpannableStringBuilder;
import android.text.style.StyleSpan;
import android.text.style.UnderlineSpan;
import android.util.Log;
import android.view.ContextMenu;
import android.view.GestureDetector;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.View.OnClickListener;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.SimpleAdapter;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anim.ViewAnimation;
import com.ichi2.anki.DeckTask.TaskData;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.TreeSet;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

//zeemote imports
import com.zeemote.zc.event.ButtonEvent;
import com.zeemote.zc.event.IButtonListener;
import com.zeemote.zc.util.JoystickToButtonAdapter;


/**
 * Allows the user to choose a deck from the filesystem.
 */
public class DeckPicker extends Activity implements Runnable, IButtonListener {

	/**
	 * Dialogs
	 */
	private static final int DIALOG_NO_SDCARD = 0;
	private static final int DIALOG_USER_NOT_LOGGED_IN_SYNC = 1;
	private static final int DIALOG_USER_NOT_LOGGED_IN_DOWNLOAD = 2;
	private static final int DIALOG_NO_CONNECTION = 3;
	private static final int DIALOG_DELETE_DECK = 4;
	private static final int DIALOG_SELECT_STATISTICS_TYPE = 5;
	private static final int DIALOG_SELECT_STATISTICS_PERIOD = 6;	
	private static final int DIALOG_OPTIMIZE_DATABASE = 7;
	private static final int DIALOG_DELETE_BACKUPS = 8;
	private static final int DIALOG_CONTEXT_MENU = 9;
	private static final int DIALOG_REPAIR_DECK = 10;

	/**
	 * Menus
	 */
    private static final int MENU_ABOUT = 0;
    private static final int SUBMENU_DOWNLOAD = 1;
    private static final int MENU_CREATE_DECK = 2;
    private static final int MENU_DOWNLOAD_PERSONAL_DECK = 21;
    private static final int MENU_DOWNLOAD_SHARED_DECK = 22;
    private static final int MENU_PREFERENCES = 3;
    private static final int MENU_MY_ACCOUNT = 4;
    private static final int MENU_FEEDBACK = 5;

	/**
	 * Context Menus
	 */
    private static final int CONTEXT_MENU_OPTIMIZE = 0;
    private static final int CONTEXT_MENU_CUSTOM_DICTIONARY = 1;
    private static final int CONTEXT_MENU_DOWNLOAD_MEDIA = 2;
    private static final int CONTEXT_MENU_RESET_LANGUAGE = 3;
    private static final int CONTEXT_MENU_REPAIR_DECK = 4;
//    private static final int CONTEXT_MENU_RESTORE_BACKUPS = 4;
    private static final int CONTEXT_MENU_REMOVE_BACKUPS = 5;
    private static final int CONTEXT_MENU_DELETE_DECK = 6;
    
	/**
	 * Message types
	 */
	private static final int MSG_LOADING_DECK = 0;
	private static final int MSG_UPGRADE_NEEDED = 1;
	private static final int MSG_UPGRADE_SUCCESS = 2;
	private static final int MSG_UPGRADE_FAILURE = 3;
	private static final int MSG_COULD_NOT_BE_LOADED = 4;
	private static final int MSG_CREATING_BACKUP = 5;
	private static final int MSG_BACKUP_ERROR = 6;

    /** Zeemote messages */
    private static final int MSG_ZEEMOTE_BUTTON_A = 0x110;
    private static final int MSG_ZEEMOTE_BUTTON_B = MSG_ZEEMOTE_BUTTON_A+1;
    private static final int MSG_ZEEMOTE_BUTTON_C = MSG_ZEEMOTE_BUTTON_A+2;
    private static final int MSG_ZEEMOTE_BUTTON_D = MSG_ZEEMOTE_BUTTON_A+3;
    private static final int MSG_ZEEMOTE_STICK_UP = MSG_ZEEMOTE_BUTTON_A+4;
    private static final int MSG_ZEEMOTE_STICK_DOWN = MSG_ZEEMOTE_BUTTON_A+5;
    private static final int MSG_ZEEMOTE_STICK_LEFT = MSG_ZEEMOTE_BUTTON_A+6;
    private static final int MSG_ZEEMOTE_STICK_RIGHT = MSG_ZEEMOTE_BUTTON_A+7;
	

	/**
	 * Deck orders
	 */
	private static final int ORDER_BY_DATE = 0;
	private static final int ORDER_ALPHABETICAL = 1;
	private static final int ORDER_BY_DUE_CARDS = 2;
	private static final int ORDER_BY_TOTAL_CARDS = 3;
	private static final int ORDER_BY_REMAINING_NEW_CARDS = 4;

    /**
	* Available options performed by other activities
	*/
    private static final int PREFERENCES_UPDATE = 0;
    private static final int CREATE_DECK = 1;
    private static final int DOWNLOAD_PERSONAL_DECK = 2;
    private static final int DOWNLOAD_SHARED_DECK = 3;
    private static final int REPORT_FEEDBACK = 4;
    private static final int LOG_IN_FOR_DOWNLOAD = 5;
    private static final int LOG_IN_FOR_SYNC = 6;

	private DeckPicker mSelf;

	private ProgressDialog mProgressDialog;
	private StyledDialog mSyncLogAlert;
	private StyledDialog mUpgradeNotesAlert;
	private StyledDialog mMissingMediaAlert;
	private StyledDialog mDeckNotLoadedAlert;
	private StyledDialog mNoSpaceLeftAlert;
	private Button mSyncAllButton;
	private Button mStatisticsAllButton;
	private View mDeckpickerButtons;

	private File[] mBackups;
	private ArrayList<String> mBrokenDecks;
	private boolean mRestoredOrDeleted = false;
	private ArrayList<String> mAlreadyDealtWith;

	private SimpleAdapter mDeckListAdapter;
	private ArrayList<HashMap<String, String>> mDeckList;
	private ListView mDeckListView;

	private File[] mFileList;

	private ReentrantLock mLock = new ReentrantLock();
	private Condition mCondFinished = mLock.newCondition();

	private boolean mIsFinished = true;
	private boolean mDeckIsSelected = false;

	private BroadcastReceiver mUnmountReceiver = null;

	private String mPrefDeckPath = null;
	private int mPrefDeckOrder = 0;
	private boolean mPrefStartupDeckPicker = false;
	private String mCurrentDeckFilename = null;
	private String mCurrentDeckPath = null;

	private int mTotalDueCards = 0;
	private int mTotalCards = 0;
	private int mTotalTime = 0;

	int mStatisticType;

	boolean mCompletionBarRestrictToActive = false; // set this to true in order to calculate completion bar only for active cards

	private int[] mDictValues;

	private int mContextMenuPosition;

	/**
     * Swipe Detection
     */    
 	private GestureDetector gestureDetector;
 	View.OnTouchListener gestureListener;
 	private boolean mSwipeEnabled;
 	
 	/**
 	 * Zeemote controller
 	 */
	protected JoystickToButtonAdapter adapter;

	// ----------------------------------------------------------------------------
	// LISTENERS
	// ----------------------------------------------------------------------------

	private AdapterView.OnItemClickListener mDeckSelHandler = new AdapterView.OnItemClickListener() {
		@Override
		public void onItemClick(AdapterView<?> parent, View v, int p, long id) {
			mSelf.handleDeckSelection(p);
		}
	};


	private DialogInterface.OnClickListener mContextMenuListener = new DialogInterface.OnClickListener() {
		@Override
		public void onClick(DialogInterface dialog, int item) {
			waitForDeckLoaderThread();
			Resources res = getResources();

			@SuppressWarnings(""unchecked"")
			HashMap<String, String> data = (HashMap<String, String>) mDeckListAdapter.getItem(mContextMenuPosition);
			String deckPath = null;
			Deck deck = null;
			switch (item) {
			case CONTEXT_MENU_DELETE_DECK:
				mCurrentDeckPath = data.get(""filepath"");
				showDialog(DIALOG_DELETE_DECK);
				return;
			case CONTEXT_MENU_RESET_LANGUAGE:
				resetDeckLanguages(data.get(""filepath""));
				return;
			case CONTEXT_MENU_OPTIMIZE:
				deckPath = data.get(""filepath"");
				deck = getDeck(deckPath);
		    	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_OPTIMIZE_DECK, mOptimizeDeckHandler, new DeckTask.TaskData(deck, 0));
				return;
			case CONTEXT_MENU_CUSTOM_DICTIONARY:
				String[] dicts = res.getStringArray(R.array.dictionary_labels);
				String[] vals = res.getStringArray(R.array.dictionary_values);
				int currentSet = MetaDB.getLookupDictionary(DeckPicker.this, data.get(""filepath""));

				mCurrentDeckPath = data.get(""filepath"");
				String[] labels = new String[dicts.length + 1];
				mDictValues = new int[dicts.length + 1];
				int currentChoice = 0;
				labels[0] = res.getString(R.string.deckpicker_select_dictionary_default);
				mDictValues[0] = -1;
				for (int i = 1; i < labels.length; i++) {
					labels[i] = dicts[i-1];
					mDictValues[i] = Integer.parseInt(vals[i-1]);
					if (currentSet == mDictValues[i]) {
						currentChoice = i;
					}
				}
				StyledDialog.Builder builder = new StyledDialog.Builder(DeckPicker.this);
				builder.setTitle(res.getString(R.string.deckpicker_select_dictionary_title));
				builder.setSingleChoiceItems(labels, currentChoice, new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface dialog, int item) {
						MetaDB.storeLookupDictionary(DeckPicker.this, mCurrentDeckPath, mDictValues[item]);
					}
				});
				StyledDialog alert = builder.create();
				alert.show();
				return;
			case CONTEXT_MENU_DOWNLOAD_MEDIA:
			    deckPath = data.get(""filepath"");
			    deck = getDeck(deckPath);
			    Reviewer.setupMedia(deck);
			    Connection.downloadMissingMedia(mDownloadMediaListener, new Connection.Payload(new Object[] {deck}));
				return;
			case CONTEXT_MENU_REMOVE_BACKUPS:
				mCurrentDeckPath = null;
				mCurrentDeckPath = data.get(""filepath"");
				showDialog(DIALOG_DELETE_BACKUPS);
				return;
			case CONTEXT_MENU_REPAIR_DECK:
				mCurrentDeckPath = null;
				mCurrentDeckPath = data.get(""filepath"");
				showDialog(DIALOG_REPAIR_DECK);
				return;
//			case CONTEXT_MENU_RESTORE_BACKUPS:
//				BackupManager.restoreDeckBackup(DeckPicker.this, data.get(""filepath""));
//				return true;
			}
		}
	};


	private Handler mHandler = new Handler() {
		@Override
		public void handleMessage(Message msg) {
			Resources res = mSelf.getResources();
			Bundle data = msg.getData();
			String dueString = """";
			String newString = """";
			String showProgress = ""false"";
			String notes = data.getString(""notes"");
            String completionMat = Integer.toString(data.getInt(""rateOfCompletionMat""));
            String completionAll = Integer.toString(data.getInt(""rateOfCompletionAll""));

			String path = data.getString(""absPath"");
			int msgtype = data.getInt(""msgtype"");
			int due = data.getInt(""due"");
			int total = data.getInt(""total"");
			int totalNew = data.getInt(""totalNew"");
			double modified = data.getDouble(""mod"");

			switch (msgtype) {
			case DeckPicker.MSG_LOADING_DECK:
				dueString = res.getString(R.string.deckpicker_loaddeck);
				newString = """";
				showProgress = ""true"";
				break;
			case DeckPicker.MSG_UPGRADE_NEEDED:
				dueString = res.getString(R.string.deckpicker_upgrading);
				newString = """";
				showProgress = ""true"";
				break;
			case DeckPicker.MSG_UPGRADE_FAILURE:
				dueString = ""Upgrade failed!"";
				newString = """";
				showProgress = ""false"";
				break;
			case DeckPicker.MSG_UPGRADE_SUCCESS:
				dueString = res.getQuantityString(R.plurals.deckpicker_due, due, due, total);
				newString = String
						.format(res.getString(R.string.deckpicker_new), data
								.getInt(""new""));
				showProgress = ""false"";
				break;
			case DeckPicker.MSG_COULD_NOT_BE_LOADED:
				dueString = res.getString(R.string.deckpicker_loading_error);
				newString = """";
				showProgress = ""false"";
				break;
			case DeckPicker.MSG_CREATING_BACKUP:
				dueString = res.getString(R.string.deckpicker_creating_backup);
				newString = """";
				showProgress = ""true"";
				break;
			case DeckPicker.MSG_BACKUP_ERROR:
				dueString = res.getString(R.string.deckpicker_backup_error);
				newString = """";
				showProgress = ""false"";
				break;
			}

			int count = mDeckListAdapter.getCount();
			for (int i = 0; i < count; i++) {
				@SuppressWarnings(""unchecked"")
				HashMap<String, String> map = (HashMap<String, String>) mDeckListAdapter
						.getItem(i);
				if (map.get(""filepath"").equals(path)) {
					map.put(""due"", dueString);
					map.put(""new"", newString);
					map.put(""showProgress"", showProgress);
                    map.put(""notes"", notes);
                    map.put(""mod"", String.format(""%f"", modified));
                    map.put(""rateOfCompletionMat"", completionMat);                    
                    map.put(""rateOfCompletionAll"", completionAll);
                    map.put(""dueInt"", Integer.toString(due));                    
                    map.put(""total"", Integer.toString(total));                    
                    map.put(""totalNew"", Integer.toString(totalNew));                    
				}
			}

			Collections.sort(mDeckList, new HashMapCompare());
			mDeckListAdapter.notifyDataSetChanged();
			// Log.i(AnkiDroidApp.TAG, ""DeckPicker - mDeckList notified of changes"");
			setTitleText();
            if (path == null) {
                enableButtons(true);
                mRestoredOrDeleted = false;
                handleRestoreDecks(false);
            }
		}
	};

	private Connection.TaskListener mSyncAllDecksListener = new Connection.TaskListener() {

		@Override
		public void onDisconnected() {
			showDialog(DIALOG_NO_CONNECTION);
		}

		@Override
		public void onPreExecute() {
			if (mProgressDialog == null || !mProgressDialog.isShowing()) {
				mProgressDialog = ProgressDialog.show(DeckPicker.this, getResources().getString(R.string.sync_all_title), getResources().getString(R.string.sync_prepare_syncing), true);
			}
		}

		@Override
		public void onProgressUpdate(Object... values) {
            if (values[0] instanceof Boolean) {
                // This is the part Download missing media of syncing
                Resources res = getResources();
                int total = ((Integer)values[1]).intValue();
                int done = ((Integer)values[2]).intValue();
                values[0] = ((String)values[3]);
                values[1] = res.getString(R.string.sync_downloading_media, done, total);
            }
			if (mProgressDialog != null && mProgressDialog.isShowing()) {
				mProgressDialog.setTitle((String) values[0]);
				mProgressDialog.setMessage((String) values[1]);
			}
		}

		@Override
		public void onPostExecute(Payload data) {
			// Log.i(AnkiDroidApp.TAG, ""onPostExecute"");
			if (mProgressDialog != null) {
				mProgressDialog.dismiss();
			}

			mSyncLogAlert
					.setMessage(getSyncLogMessage((ArrayList<HashMap<String, String>>) data.result));
			mSyncLogAlert.show();
			mDeckIsSelected = false;
			populateDeckList(mPrefDeckPath);
            mSyncAllButton.setClickable(true);
		}
	};

   private Connection.TaskListener mDownloadMediaListener = new Connection.TaskListener() {

        @Override
        public void onDisconnected() {
            showDialog(DIALOG_NO_CONNECTION);
        }

        @Override
        public void onPreExecute() {
            // Pass
        }

        @Override
        public void onProgressUpdate(Object... values) {
            int total = ((Integer)values[1]).intValue();
            int done = ((Integer)values[2]).intValue();
            if (!((Boolean)values[0]).booleanValue()) {
                // Initializing, just get the count of missing media
                if (mProgressDialog != null && mProgressDialog.isShowing()) {
                    mProgressDialog.dismiss();
                }
                mProgressDialog.setMax(total);
                mProgressDialog.show();
            } else {
                mProgressDialog.setProgress(done);
            }
        }

        @Override
        public void onPostExecute(Payload data) {
            // Log.i(AnkiDroidApp.TAG, ""onPostExecute"");
            Resources res = getResources();
            if (mProgressDialog != null) {
                mProgressDialog.dismiss();
            }

            if (data.success) {
                int total = ((Integer)data.data[0]).intValue();
                if (total == 0) {
                    mMissingMediaAlert
                        .setMessage(res.getString(R.string.deckpicker_download_missing_none));
                } else {
                    int done = ((Integer)data.data[1]).intValue();
                    int missing = ((Integer)data.data[2]).intValue();
                    mMissingMediaAlert
                        .setMessage(res.getString(R.string.deckpicker_download_missing_success, done, missing));
                }
            } else {
                String failedFile = (String)data.data[0];
                mMissingMediaAlert
                    .setMessage(res.getString(R.string.deckpicker_download_missing_error, failedFile));
            }
            mMissingMediaAlert.show();
            
            Deck deck = (Deck) data.result;
            closeDeck(deck);
         }
    };

    //Zeemote handler
	Handler ZeemoteHandler = new Handler() {
		public void handleMessage(Message msg){
			switch(msg.what){
			case MSG_ZEEMOTE_STICK_UP:
				mDeckListView.requestFocusFromTouch();
				sendKey(KeyEvent.KEYCODE_DPAD_UP);
				break;
			case MSG_ZEEMOTE_STICK_DOWN:
				mDeckListView.requestFocusFromTouch();
				sendKey(KeyEvent.KEYCODE_DPAD_DOWN);
				break;
			case MSG_ZEEMOTE_STICK_LEFT:
				break;
			case MSG_ZEEMOTE_STICK_RIGHT:
				break;
			case MSG_ZEEMOTE_BUTTON_A:
				sendKey(KeyEvent.KEYCODE_ENTER);
				break;
			case MSG_ZEEMOTE_BUTTON_B:
				sendKey(KeyEvent.KEYCODE_BACK);
				break;
			case MSG_ZEEMOTE_BUTTON_C:
				break;
			case MSG_ZEEMOTE_BUTTON_D:
				break;
			}
			super.handleMessage(msg);
		}
	};

    
	// ----------------------------------------------------------------------------
	// ANDROID METHODS
	// ----------------------------------------------------------------------------

	/** Called when the activity is first created. */
	@Override
	protected void onCreate(Bundle savedInstanceState) throws SQLException {
		// Log.i(AnkiDroidApp.TAG, ""DeckPicker - onCreate"");
		Themes.applyTheme(this);
		super.onCreate(savedInstanceState);

		setTitleText();

		mSelf = this;

		View mainView = getLayoutInflater().inflate(R.layout.deck_picker, null);
		setContentView(mainView);
		Themes.setContentStyle(mainView, Themes.CALLER_DECKPICKER);

		registerExternalStorageListener();

		initDialogs();
		mBrokenDecks = new ArrayList<String>();
		mAlreadyDealtWith = new ArrayList<String>();

		mDeckpickerButtons = (View) findViewById(R.id.deckpicker_buttons);
		mSyncAllButton = (Button) findViewById(R.id.sync_all_button);
		mSyncAllButton.setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				syncAllDecks();
			}

		});

		mStatisticsAllButton = (Button) findViewById(R.id.statistics_all_button);
		mStatisticsAllButton.setOnClickListener(new OnClickListener() {

			@Override
			public void onClick(View v) {
				mStatisticType = -1;
				showDialog(DIALOG_SELECT_STATISTICS_TYPE);
			}
		});

		mDeckList = new ArrayList<HashMap<String, String>>();
        mDeckListView = (ListView) findViewById(R.id.files);
		mDeckListAdapter = new AlternatingAdapter(this, mDeckList,
				R.layout.deck_item, new String[] { ""name"", ""due"", ""new"",
						""showProgress"", ""notes"", ""rateOfCompletionMat"", ""rateOfCompletionAll"" }, new int[] {
						R.id.DeckPickerName, R.id.DeckPickerDue,
						R.id.DeckPickerNew, R.id.DeckPickerProgress,
						R.id.DeckPickerUpgradeNotesButton,
						R.id.DeckPickerCompletionMat, R.id.DeckPickerCompletionAll });
		mDeckListAdapter.setViewBinder(new SimpleAdapter.ViewBinder() {
			@Override
			public boolean setViewValue(View view, Object data, String text) {
				if (view instanceof ProgressBar) {
					if (text.equals(""true"")) {
						view.setVisibility(View.VISIBLE);
					} else {
						view.setVisibility(View.GONE);
					}
					return true;
				}
				if (view.getId() == R.id.DeckPickerCompletionMat || view.getId() == R.id.DeckPickerCompletionAll) {
				    if (!text.equals(""-1"")) {
	                    Utils.updateProgressBars(DeckPicker.this, view, Double.parseDouble(text) / 100.0, mDeckListView.getWidth(), 2, false); 				        
				    } else {
				    	Themes.setContentStyle(view, Themes.CALLER_DECKPICKER_DECK);
				    }
                }
				if (view.getId() == R.id.DeckPickerUpgradeNotesButton) {
					if (text.equals("""")) {
						view.setVisibility(View.GONE);
					} else {
						view.setVisibility(View.VISIBLE);
						view.setTag(text);
						view.setOnClickListener(new OnClickListener() {
							@Override
							public void onClick(View v) {
								String tag = (String) v.getTag();
								if (tag == null) {
									tag = """";
								}
								mUpgradeNotesAlert.setMessage(tag);
								mUpgradeNotesAlert.show();
							}
						});
					}
					return true;
				}
				return false;
			}
		});
		mDeckListView.setOnItemClickListener(mDeckSelHandler);
		mDeckListView.setAdapter(mDeckListAdapter);
		registerForContextMenu(mDeckListView);

		
		
		SharedPreferences preferences = PrefSettings
				.getSharedPrefs(getBaseContext());
		mPrefDeckPath = preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
		mPrefDeckOrder = Integer.parseInt(preferences.getString(""deckOrder"", Integer.toString(ORDER_ALPHABETICAL)));
		mPrefStartupDeckPicker = Integer.parseInt(preferences.getString(""startup_mode"", ""2"")) == StudyOptions.SUM_DECKPICKER;
		populateDeckList(mPrefDeckPath);

		mSwipeEnabled = preferences.getBoolean(""swipe"", false);
		gestureDetector = new GestureDetector(new MyGestureDetector());
        mDeckListView.setOnTouchListener(new View.OnTouchListener() {
        	public boolean onTouch(View v, MotionEvent event) {
        		if (gestureDetector.onTouchEvent(event)) {
        			return true;
        		}
        		return false;
        		}
        	});        
	}

	protected void sendKey(int keycode) {
		this.dispatchKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN,keycode));
		this.dispatchKeyEvent(new KeyEvent(KeyEvent.ACTION_UP,keycode));
	}

	@Override
	protected void onPause() {
		// Log.i(AnkiDroidApp.TAG, ""DeckPicker - onPause"");

        if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){ 
        	// Log.d(""Zeemote"",""Removing listener in onPause"");
        	AnkiDroidApp.zeemoteController().removeButtonListener(this);
        	AnkiDroidApp.zeemoteController().removeJoystickListener(adapter);
    		adapter.removeButtonListener(this);
    		adapter = null;
        }        
        
		super.onPause();
		waitForDeckLoaderThread();
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
		// Log.i(AnkiDroidApp.TAG, ""DeckPicker - onDestroy()"");
		if (mUnmountReceiver != null) {
			unregisterReceiver(mUnmountReceiver);
		}
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		StyledDialog dialog;
		Resources res = getResources();
		StyledDialog.Builder builder = new StyledDialog.Builder(this);

		switch (id) {
		case DIALOG_NO_SDCARD:
			builder.setMessage(""The SD card could not be read. Please, turn off USB storage."");
			builder.setPositiveButton(""OK"", null);
			dialog = builder.create();
			break;

		case DIALOG_USER_NOT_LOGGED_IN_SYNC:
		case DIALOG_USER_NOT_LOGGED_IN_DOWNLOAD:
			builder.setTitle(res.getString(R.string.connection_error_title));
			builder.setIcon(android.R.drawable.ic_dialog_alert);
			builder.setMessage(res
					.getString(R.string.no_user_password_error_message));
			if (id == DIALOG_USER_NOT_LOGGED_IN_SYNC) {
				builder.setPositiveButton(res.getString(R.string.log_in),
						new DialogInterface.OnClickListener() {

							@Override
							public void onClick(DialogInterface dialog, int which) {
								Intent myAccount = new Intent(DeckPicker.this,
										MyAccount.class);
								myAccount.putExtra(""notLoggedIn"", true);
								startActivityForResult(myAccount, LOG_IN_FOR_SYNC);
						        if (StudyOptions.getApiLevel() > 4) {
						            ActivityTransitionAnimation.slide(DeckPicker.this, ActivityTransitionAnimation.LEFT);
						        }
							}
						});
			} else {
				builder.setPositiveButton(res.getString(R.string.log_in),
						new DialogInterface.OnClickListener() {

							@Override
							public void onClick(DialogInterface dialog, int which) {
								Intent myAccount = new Intent(DeckPicker.this,
										MyAccount.class);
								myAccount.putExtra(""notLoggedIn"", true);
								startActivityForResult(myAccount, LOG_IN_FOR_DOWNLOAD);
						        if (StudyOptions.getApiLevel() > 4) {
						            ActivityTransitionAnimation.slide(DeckPicker.this, ActivityTransitionAnimation.LEFT);
						        }
							}
						});
			}
			builder.setNegativeButton(res.getString(R.string.cancel), null);
			dialog = builder.create();
			break;

		case DIALOG_NO_CONNECTION:
			builder.setTitle(res.getString(R.string.connection_error_title));
			builder.setIcon(android.R.drawable.ic_dialog_alert);
			builder.setMessage(res.getString(R.string.connection_needed));
			builder.setPositiveButton(res.getString(R.string.ok), null);
			dialog = builder.create();
			break;

		case DIALOG_DELETE_DECK:
			builder.setTitle(res.getString(R.string.delete_deck_title));
			builder.setIcon(android.R.drawable.ic_dialog_alert);
			builder.setMessage(String.format(res.getString(R.string.delete_deck_message), ""\'"" + mCurrentDeckFilename + ""\'""));
			builder.setPositiveButton(res.getString(R.string.delete_deck_confirm),
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							removeDeck(mCurrentDeckPath);
							mCurrentDeckPath = null;
							mCurrentDeckFilename = null;
						}
					});
			builder.setNegativeButton(res.getString(R.string.cancel),
				new DialogInterface.OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						mCurrentDeckPath = null;
						mCurrentDeckFilename = null;
					}
				});
			builder.setOnCancelListener(
					new DialogInterface.OnCancelListener() {

						@Override
						public void onCancel(DialogInterface dialog) {
							mCurrentDeckPath = null;
							mCurrentDeckFilename = null;
						}
					});					
			dialog = builder.create();
			break;
		case DIALOG_DELETE_BACKUPS:
			builder.setTitle(res.getString(R.string.backup_manager_title));
			builder.setIcon(android.R.drawable.ic_dialog_alert);
			builder.setMessage(String.format(res.getString(R.string.backup_delete_deck_backups_alert), ""\'"" + mCurrentDeckFilename + ""\'""));
			builder.setPositiveButton(res.getString(R.string.delete_deck_confirm),
					new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							if (BackupManager.deleteDeckBackups(mCurrentDeckPath, 0)) {
								Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.backup_delete_deck_backups, ""\'"" + mCurrentDeckFilename + ""\'""), true);
							}
							mCurrentDeckPath = null;
							mCurrentDeckFilename = null;
						}
					});
			builder.setNegativeButton(res.getString(R.string.cancel),
				new DialogInterface.OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						mCurrentDeckPath = null;
						mCurrentDeckFilename = null;
					}
				});
			builder.setOnCancelListener(
					new DialogInterface.OnCancelListener() {

						@Override
						public void onCancel(DialogInterface dialog) {
							mCurrentDeckPath = null;
							mCurrentDeckFilename = null;
						}
					});					
			dialog = builder.create();
			break;
		case DIALOG_SELECT_STATISTICS_TYPE:
	        builder.setTitle(res.getString(R.string.statistics_type_title));
	        builder.setIcon(android.R.drawable.ic_menu_sort_by_size);
	        builder.setSingleChoiceItems(getResources().getStringArray(R.array.statistics_type_labels), Statistics.TYPE_DUE, mStatisticListener);
	        dialog = builder.create();
			break;
		case DIALOG_SELECT_STATISTICS_PERIOD:
	        builder.setTitle(res.getString(R.string.statistics_period_title));
	        builder.setIcon(android.R.drawable.ic_menu_sort_by_size);
	        builder.setSingleChoiceItems(getResources().getStringArray(R.array.statistics_period_labels), 0, mStatisticListener);
	        dialog = builder.create();
			break;
		case DIALOG_OPTIMIZE_DATABASE:
    		builder.setTitle(res.getString(R.string.optimize_deck_title));
    		builder.setPositiveButton(res.getString(R.string.ok), null);
			builder.setIcon(android.R.drawable.ic_dialog_alert);
			dialog = builder.create();
			break;
		case DIALOG_CONTEXT_MENU:
			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get(""name"");
			if (mCurrentDeckFilename == null || mCurrentDeckFilename.equalsIgnoreCase(getResources().getString(R.string.deckpicker_nodeck))) {
				dialog = null;
				break;
			}
			String[] entries = new String[7];
			entries[CONTEXT_MENU_OPTIMIZE] = res.getString(R.string.contextmenu_deckpicker_optimize_deck);
			entries[CONTEXT_MENU_CUSTOM_DICTIONARY] = res.getString(R.string.contextmenu_deckpicker_set_custom_dictionary);
			entries[CONTEXT_MENU_DOWNLOAD_MEDIA] = res.getString(R.string.contextmenu_deckpicker_download_missing_media);
			entries[CONTEXT_MENU_RESET_LANGUAGE] = res.getString(R.string.contextmenu_deckpicker_reset_language_assignments);
			entries[CONTEXT_MENU_REPAIR_DECK] = res.getString(R.string.backup_repair_deck);
//			entries[CONTEXT_MENU_RESTORE_BACKUPS] = res.getString(R.string.R.string.contextmenu_deckpicker_restore_backups);
			entries[CONTEXT_MENU_REMOVE_BACKUPS] = res.getString(R.string.contextmenu_deckpicker_remove_backups);
			entries[CONTEXT_MENU_DELETE_DECK] = res.getString(R.string.contextmenu_deckpicker_delete_deck);
	        builder.setTitle(""contextmenu"");
	        builder.setIcon(R.drawable.ic_menu_manage);
	        builder.setItems(entries, mContextMenuListener);
	        dialog = builder.create();
			break;
		case DIALOG_REPAIR_DECK:
    		builder.setTitle(res.getString(R.string.backup_repair_deck));
			builder.setIcon(android.R.drawable.ic_dialog_alert);
    		builder.setPositiveButton(res.getString(R.string.yes), new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
	            	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mCurrentDeckPath));
					mCurrentDeckPath = null;
					mCurrentDeckFilename = null;
				}
    		});
    		builder.setNegativeButton(res.getString(R.string.no), new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int which) {
					mCurrentDeckPath = null;
					mCurrentDeckFilename = null;
				}
    		});
    		builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
				@Override
				public void onCancel(DialogInterface dialog) {
					mCurrentDeckPath = null;
					mCurrentDeckFilename = null;
				}
    		});
			dialog = builder.create();
			break;

		default:
			dialog = null;
		}
		dialog.setOwnerActivity(DeckPicker.this);
		return dialog;
	}


	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		Resources res = getResources();
		StyledDialog ad = (StyledDialog)dialog;
		switch (id) {
		case DIALOG_DELETE_DECK:
			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get(""name"");
			ad.setMessage(String.format(res.getString(R.string.delete_deck_message), ""\'"" + mCurrentDeckFilename + ""\'""));
			break;
		case DIALOG_DELETE_BACKUPS:
			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get(""name"");
			ad.setMessage(String.format(res.getString(R.string.backup_delete_deck_backups_alert), ""\'"" +mCurrentDeckFilename + ""\'""));
			break;
		case DIALOG_CONTEXT_MENU:
			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get(""name"");
			ad.setTitle(mCurrentDeckFilename);
			break;
		case DIALOG_REPAIR_DECK:
			mCurrentDeckFilename = mDeckList.get(mContextMenuPosition).get(""name"");
			ad.setMessage(String.format(res.getString(R.string.repair_deck_dialog), mCurrentDeckFilename, BackupManager.BROKEN_DECKS_SUFFIX.replace(""/"", """")));
			break;
		}
	}


    private DialogInterface.OnClickListener mStatisticListener = new DialogInterface.OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
			if (mStatisticType == -1 && which != Statistics.TYPE_DECK_SUMMARY) {
				mStatisticType = which;
           		showDialog(DIALOG_SELECT_STATISTICS_PERIOD);
        	} else {
		    	if (mFileList != null && mFileList.length > 0) {
					String[] deckPaths = new String[mFileList.length];
					int i = 0;
			    	for (File file : mFileList) {
			    		deckPaths[i] = file.getAbsolutePath();
			    		i++;
					}
			    	if (mStatisticType == -1) {
			    		mStatisticType = Statistics.TYPE_DECK_SUMMARY;
				    	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_STATISTICS, mLoadStatisticsHandler, new DeckTask.TaskData(DeckPicker.this, deckPaths, mStatisticType, 0));			    		
			    	} else {
				    	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_STATISTICS, mLoadStatisticsHandler, new DeckTask.TaskData(DeckPicker.this, deckPaths, mStatisticType, which));
			    	}
		    	}
        	}
        }
    };


    @Override
	public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
    	mContextMenuPosition = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
    	showDialog(DIALOG_CONTEXT_MENU);
	}


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)  {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
        	// Log.i(AnkiDroidApp.TAG, ""DeckPicker - onBackPressed()"");
        	closeDeckPicker(true);
        	return true;
        }
        return super.onKeyDown(keyCode, event);
    }

	// ----------------------------------------------------------------------------
	// CUSTOM METHODS
	// ----------------------------------------------------------------------------

	/**
	 * Registers an intent to listen for ACTION_MEDIA_EJECT notifications. The
	 * intent will call closeExternalStorageFiles() if the external media is
	 * going to be ejected, so applications can clean up any files they have
	 * open.
	 */
	private void registerExternalStorageListener() {
		if (mUnmountReceiver == null) {
			mUnmountReceiver = new BroadcastReceiver() {
				@Override
				public void onReceive(Context context, Intent intent) {
					String action = intent.getAction();
					if (action.equals(Intent.ACTION_MEDIA_UNMOUNTED)) {
						// Log.i(AnkiDroidApp.TAG, ""DeckPicker - mUnmountReceiver, Action = Media Unmounted"");
						SharedPreferences preferences = PreferenceManager
								.getDefaultSharedPreferences(getBaseContext());
						String deckPath = preferences.getString(""deckPath"",
								AnkiDroidApp.getStorageDirectory());
						populateDeckList(deckPath);
					} else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
						// Log.i(AnkiDroidApp.TAG, ""DeckPicker - mUnmountReceiver, Action = Media Mounted"");
						SharedPreferences preferences = PreferenceManager
								.getDefaultSharedPreferences(getBaseContext());
						String deckPath = preferences.getString(""deckPath"",
								AnkiDroidApp.getStorageDirectory());
						mDeckIsSelected = false;
						setTitleText();
						populateDeckList(deckPath);
					}
				}
			};
			IntentFilter iFilter = new IntentFilter();
			iFilter.addAction(Intent.ACTION_MEDIA_UNMOUNTED);
			iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
			iFilter.addDataScheme(""file"");
			registerReceiver(mUnmountReceiver, iFilter);
		}
	}


	private void closeDeckPicker() {
		closeDeckPicker(false);
	}
	private void closeDeckPicker(boolean backPressed) {
		if (mPrefStartupDeckPicker && backPressed) {
			setResult(StudyOptions.RESULT_CLOSE);
			finish();
		} else {
			finish();
			if (StudyOptions.getApiLevel() > 4) {
	    			ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
    		}
		}
	}


	private void handleRestoreDecks(boolean reloadIfEmpty) {
		if (mBrokenDecks.size() != 0) {
			while (true) {
				mCurrentDeckPath = mBrokenDecks.remove(0);
				if (!mAlreadyDealtWith.contains(mCurrentDeckPath) || mBrokenDecks.size() == 0) {
					break;
				}
			}
        	mDeckNotLoadedAlert.setMessage(getResources().getString(R.string.open_deck_failed, ""\'"" + new File(mCurrentDeckPath).getName() + ""\'"", BackupManager.BROKEN_DECKS_SUFFIX.replace(""/"", """"), getResources().getString(R.string.repair_deck)));
			mDeckNotLoadedAlert.show();
		} else if (reloadIfEmpty) {
			if (mRestoredOrDeleted) {
				mBrokenDecks = new ArrayList<String>();
				populateDeckList(mPrefDeckPath);
			}
		}
	}


	private void enableButtons(boolean enabled) {
		if (enabled) {
			mSyncAllButton.setVisibility(View.VISIBLE);
			mDeckpickerButtons.setVisibility(View.VISIBLE);
			mDeckpickerButtons.setAnimation(ViewAnimation.fade(ViewAnimation.FADE_IN, 500, 0)); 
		} else {
			mDeckpickerButtons.setVisibility(View.INVISIBLE);
		}
	}


	private void syncAllDecks() {
		if (AnkiDroidApp.isUserLoggedIn()) {
            mSyncAllButton.setClickable(false);
			SharedPreferences preferences = PrefSettings
					.getSharedPrefs(getBaseContext());
			String username = preferences.getString(""username"", """");
			String password = preferences.getString(""password"", """");
			Connection.syncAllDecks(mSyncAllDecksListener,
					new Connection.Payload(new Object[] { username,
							password, mDeckList }));
		} else {
			showDialog(DIALOG_USER_NOT_LOGGED_IN_SYNC);
		}
	}


	private void initDialogs() {
		Resources res = getResources();
		// Sync Log dialog
		StyledDialog.Builder builder = new StyledDialog.Builder(this);
		builder.setTitle(res.getString(R.string.sync_log_title));
		builder.setPositiveButton(res.getString(R.string.ok), null);
		mSyncLogAlert = builder.create();
		mSyncLogAlert.setOwnerActivity(DeckPicker.this);
		// Upgrade notes dialog
		builder = new StyledDialog.Builder(this);
		builder.setTitle(res.getString(
				R.string.deckpicker_upgrade_notes_title));
		builder.setPositiveButton(res.getString(R.string.ok), null);
		mUpgradeNotesAlert = builder.create();
		builder = new StyledDialog.Builder(this);
        builder.setTitle(res.getString(R.string.deckpicker_download_missing_title));
        builder.setPositiveButton(res.getString(R.string.ok), null);
        mMissingMediaAlert = builder.create();
        mProgressDialog = new ProgressDialog(DeckPicker.this);
        mProgressDialog.setTitle(R.string.deckpicker_download_missing_title);
        mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
        mProgressDialog.setMax(100);
        mProgressDialog.setCancelable(false);

        // backup system restore dialog
        builder.setTitle(getResources().getString(R.string.backup_manager_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(getResources().getString(R.string.backup_deck_no_space_left));
		builder.setPositiveButton(getResources().getString(R.string.ok), null);
		mNoSpaceLeftAlert = builder.create();

        builder.setTitle(res.getString(R.string.backup_manager_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setPositiveButton(res.getString(R.string.backup_restore), new Dialog.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
            	Resources res = getResources();
            	mBackups = BackupManager.getDeckBackups(new File(mCurrentDeckPath));
            	if (mBackups.length == 0) {
            		StyledDialog.Builder builder = new StyledDialog.Builder(DeckPicker.this);
            		builder.setTitle(res.getString(R.string.backup_manager_title))
            			.setIcon(android.R.drawable.ic_dialog_alert)
            			.setMessage(res.getString(R.string.backup_restore_no_backups))
            			.setPositiveButton(res.getString(R.string.ok), new Dialog.OnClickListener() {

				            @Override
				            public void onClick(DialogInterface dialog, int which) {
						mDeckNotLoadedAlert.show();
				            }
					}).setCancelable(true).setOnCancelListener(new OnCancelListener() {

						@Override
						public void onCancel(DialogInterface arg0) {
							mDeckNotLoadedAlert.show();
						}
					}).show();
            	} else {
            		String[] dates = new String[mBackups.length];
            		for (int i = 0; i < mBackups.length; i++) {
            			dates[i] = mBackups[i].getName().replaceAll("".*-(\\d{4}-\\d{2}-\\d{2}).anki"", ""$1"");
            		}
            		StyledDialog.Builder builder = new StyledDialog.Builder(DeckPicker.this);
            		builder.setTitle(res.getString(R.string.backup_restore_select_title))
            			.setIcon(android.R.drawable.ic_input_get)
                    	.setSingleChoiceItems(dates, dates.length, new DialogInterface.OnClickListener(){

							@Override
							public void onClick(DialogInterface dialog, int which) {
								DeckTask.launchDeckTask(DeckTask.TASK_TYPE_RESTORE_DECK, mRestoreDeckHandler, new DeckTask.TaskData(null, new String[] {mCurrentDeckPath, mBackups[which].getPath()}, 0, 0));
								dialog.dismiss();
							}
						}).setCancelable(true).setOnCancelListener(new OnCancelListener() {

							@Override
							public void onCancel(DialogInterface arg0) {
								mDeckNotLoadedAlert.show();
							}
						}).show();
        		}
            }
        });
        builder.setNeutralButton(res.getString(R.string.backup_repair_deck), new Dialog.OnClickListener() {

			@Override
			public void onClick(DialogInterface arg0, int arg1) {
	        	DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REPAIR_DECK, mRepairDeckHandler, new DeckTask.TaskData(mCurrentDeckPath));
			}
        });
        builder.setNegativeButton(res.getString(R.string.delete_deck_title), new Dialog.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
            	Resources res = getResources();
            	StyledDialog.Builder builder = new StyledDialog.Builder(DeckPicker.this);
            	builder.setCancelable(true).setTitle(res.getString(R.string.delete_deck_title))
            		.setIcon(android.R.drawable.ic_dialog_alert)
            		.setMessage(String.format(res.getString(R.string.delete_deck_message), ""\'"" + new File(mCurrentDeckPath).getName().replace("".anki"", """") + ""\'""))
            		.setPositiveButton(res.getString(R.string.delete_deck_confirm), new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							if (BackupManager.moveDeckToBrokenFolder(mCurrentDeckPath)) {
								Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.delete_deck_success, ""\'"" + (new File(mCurrentDeckPath).getName().replace("".anki"", """")) + ""\'"", ""\'"" + BackupManager.BROKEN_DECKS_SUFFIX.replace(""/"", """") + ""\'""), false);								
								mRestoredOrDeleted = true;
								handleRestoreDecks(true);
							}
						}
					}).setNegativeButton(res.getString(R.string.cancel), new DialogInterface.OnClickListener() {

						@Override
						public void onClick(DialogInterface dialog, int which) {
							mDeckNotLoadedAlert.show();
						}
					}).setOnCancelListener(new DialogInterface.OnCancelListener() {

						@Override
						public void onCancel(DialogInterface dialog) {
							mDeckNotLoadedAlert.show();
						}
					}).show();					
            }
        });
        builder.setCancelable(true);
        builder.setOnCancelListener(new OnCancelListener() {

			@Override
			public void onCancel(DialogInterface arg0) {
				mAlreadyDealtWith.add(mCurrentDeckPath);
				handleRestoreDecks(true);
			}
		});
        mDeckNotLoadedAlert = builder.create();
	}
	
	
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuItem item;
        SubMenu downloadDeckSubMenu = menu.addSubMenu(Menu.NONE, SUBMENU_DOWNLOAD, Menu.NONE,
                R.string.menu_download_deck);
        downloadDeckSubMenu.setIcon(R.drawable.ic_menu_download);
        downloadDeckSubMenu.add(
                Menu.NONE, MENU_DOWNLOAD_PERSONAL_DECK, Menu.NONE, R.string.menu_download_personal_deck);
        downloadDeckSubMenu.add(Menu.NONE, MENU_DOWNLOAD_SHARED_DECK, Menu.NONE, R.string.menu_download_shared_deck);
        item = menu.add(Menu.NONE, MENU_CREATE_DECK, Menu.NONE, R.string.menu_create_deck);
        item.setIcon(R.drawable.ic_menu_add);
        item = menu.add(Menu.NONE, MENU_PREFERENCES, Menu.NONE, R.string.menu_preferences);
        item.setIcon(R.drawable.ic_menu_preferences);
        item = menu.add(Menu.NONE, MENU_MY_ACCOUNT, Menu.NONE, R.string.menu_my_account);
        item.setIcon(R.drawable.ic_menu_home);
        item = menu.add(Menu.NONE, MENU_ABOUT, Menu.NONE, R.string.menu_about);
        item.setIcon(R.drawable.ic_menu_info_details);
        item = menu.add(Menu.NONE, MENU_FEEDBACK, Menu.NONE, R.string.studyoptions_feedback);
        item.setIcon(R.drawable.ic_menu_send);
        return true;
    }


    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        boolean sdCardAvailable = AnkiDroidApp.isSdCardMounted();
        menu.findItem(SUBMENU_DOWNLOAD).setEnabled(sdCardAvailable);
        menu.findItem(MENU_DOWNLOAD_PERSONAL_DECK).setVisible(sdCardAvailable);
        return true;
    }

    
    /** Handles item selections */
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case MENU_CREATE_DECK:
                startActivityForResult(new Intent(DeckPicker.this, DeckCreator.class), CREATE_DECK);
                if (StudyOptions.getApiLevel() > 4) {
                    ActivityTransitionAnimation.slide(DeckPicker.this, ActivityTransitionAnimation.RIGHT);
                }
                return true;

            case MENU_ABOUT:
                // int i = 123/0; // Intentional Exception for feedback testing purpose
                startActivity(new Intent(DeckPicker.this, About.class));
                return true;

            case MENU_DOWNLOAD_PERSONAL_DECK:
                openPersonalDeckPicker();
                return true;

            case MENU_DOWNLOAD_SHARED_DECK:
                openSharedDeckPicker();
                return true;

            case MENU_MY_ACCOUNT:
                startActivity(new Intent(DeckPicker.this, MyAccount.class));
                return true;

            case MENU_PREFERENCES:
                startActivityForResult(
                        new Intent(DeckPicker.this, Preferences.class),
                        PREFERENCES_UPDATE);
                return true;

            case MENU_FEEDBACK:
                startActivityForResult(
                        new Intent(DeckPicker.this, Feedback.class),
                        REPORT_FEEDBACK);
                return true;

            default:
                return super.onOptionsItemSelected(item);
        }
    }
    

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {
        super.onActivityResult(requestCode, resultCode, intent);

        if (requestCode == PREFERENCES_UPDATE) {
            if (resultCode == StudyOptions.RESULT_RESTART) {
            	setResult(StudyOptions.RESULT_RESTART);
            	finish();
            } else {
            	SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
				BackupManager.initBackup();
                if (!mPrefDeckPath.equals(preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory())) || mPrefDeckOrder != Integer.parseInt(preferences.getString(""deckOrder"", ""0""))) {
                	populateDeckList(preferences.getString(""deckPath"", AnkiDroidApp.getStorageDirectory()));
                }
            }
        } else if ((requestCode == CREATE_DECK || requestCode == DOWNLOAD_PERSONAL_DECK || requestCode == DOWNLOAD_SHARED_DECK) && resultCode == RESULT_OK) {
        	populateDeckList(mPrefDeckPath);
        } else if (requestCode == REPORT_FEEDBACK && resultCode == RESULT_OK) {
        } else if (requestCode == LOG_IN_FOR_DOWNLOAD && resultCode == RESULT_OK) {
        	openPersonalDeckPicker();
        } else if (requestCode == LOG_IN_FOR_SYNC && resultCode == RESULT_OK) {
        	syncAllDecks();
        }
    }


    private void populateDeckList(String location) {
		// Log.i(AnkiDroidApp.TAG, ""DeckPicker - populateDeckList"");

		if (!location.equals(mPrefDeckPath)) {
		    mPrefDeckPath = location;
		}

		mDeckIsSelected = false;
		mTotalDueCards = 0;
		mTotalCards = 0;
		setTitleText();
		
		Resources res = getResources();
		int len = 0;
		File[] fileList;

		TreeSet<HashMap<String, String>> tree = new TreeSet<HashMap<String, String>>(new HashMapCompareLoad());

		File dir = new File(mPrefDeckPath);
		fileList = dir.listFiles(new AnkiFilter());

		if (dir.exists() && dir.isDirectory() && fileList != null) {
			len = fileList.length;
			enableButtons(false);
		}

		mFileList = fileList;
		if (len > 0 && fileList != null) {
			// Log.i(AnkiDroidApp.TAG, ""DeckPicker - populateDeckList, number of anki files = "" + len);
			for (File file : fileList) {
				String absPath = file.getAbsolutePath();

				// Log.i(AnkiDroidApp.TAG, ""DeckPicker - populateDeckList, file:"" + file.getName());

				try {
					HashMap<String, String> data = new HashMap<String, String>();
					data.put(""name"", file.getName().replaceAll("".anki"", """"));
					data
							.put(""due"", res
									.getString(R.string.deckpicker_loaddeck));
					data.put(""new"", """");
					data.put(""mod"", ""0"");						
					data.put(""filepath"", absPath);
                    data.put(""showProgress"", ""true"");
                    data.put(""rateOfCompletionMat"", ""-1"");
                    data.put(""rateOfCompletionAll"", ""-1"");

					tree.add(data);

				} catch (SQLException e) {
					Log.w(AnkiDroidApp.TAG,
							""DeckPicker - populateDeckList, File ""
									+ file.getName()
									+ "" is not a real anki file"");
				}
			}
		    
			Thread thread = new Thread(this);
			thread.start();
		} else {
			// Log.i(AnkiDroidApp.TAG, ""populateDeckList - No decks found."");
			if (!AnkiDroidApp.isSdCardMounted()) {
				// Log.i(AnkiDroidApp.TAG, ""populateDeckList - No sd card."");
				setTitle(R.string.deckpicker_title_nosdcard);
				showDialog(DIALOG_NO_SDCARD);
			}

			HashMap<String, String> data = new HashMap<String, String>();
			data.put(""name"", res.getString(R.string.deckpicker_nodeck));
			data.put(""new"", """");
			data.put(""due"", """");
			data.put(""mod"", ""0"");
			data.put(""showProgress"", ""false"");
            data.put(""rateOfCompletionMat"", ""-1"");
            data.put(""rateOfCompletionAll"", ""-1"");

			tree.add(data);
		}
		mDeckList.clear();
		mDeckList.addAll(tree);
		mDeckListView.clearChoices();
		mDeckListAdapter.notifyDataSetChanged();
		// Log.i(AnkiDroidApp.TAG, ""DeckPicker - populateDeckList, Ending"");
	}

	@Override
	public void run() {
		// Log.i(AnkiDroidApp.TAG, ""Thread run - Beginning"");

		if (mFileList != null && mFileList.length > 0) {
			mLock.lock();
			try {
				// Log.i(AnkiDroidApp.TAG, ""Thread run - Inside lock"");

				mIsFinished = false;
				int i = 0;
				for (File file : mFileList) {
				    i++;
					// Don't load any more decks if one has already been
					// selected.
					// Log.i(AnkiDroidApp.TAG, ""Thread run - Before break mDeckIsSelected = "" + mDeckIsSelected);
					if (mDeckIsSelected) {
						break;
					}

					String path = file.getAbsolutePath();
					Deck deck;

					Bundle data = new Bundle();
					Message msg;

					// See if a backup is needed (only done in deckpicker, if last backup is quite old or no backup at all is available)
					// It is necessary to do it here, because retrieving deck information can already lead to a deck removal (Android bug)
					if (BackupManager.isActivated() && BackupManager.safetyBackupNeeded(path, BackupManager.SAFETY_BACKUP_THRESHOLD)) {
						// Log.i(AnkiDroidApp.TAG, ""DeckPicker - Safety backup for deck "" + path + ""needed"");
						data.putString(""absPath"", path);
						data.putInt(""msgtype"", MSG_CREATING_BACKUP);
						msg = Message.obtain();
						msg.setData(data);
						mHandler.sendMessage(msg);
						if (BackupManager.backupDeck(path) == BackupManager.RETURN_BACKUP_CREATED) {
							data.putString(""absPath"", path);
							data.putInt(""msgtype"", MSG_LOADING_DECK);
							msg = Message.obtain();
							msg.setData(data);
							mHandler.sendMessage(msg);
						} else {
							data.putString(""absPath"", path);
							data.putInt(""msgtype"", MSG_BACKUP_ERROR);
							msg = Message.obtain();
							msg.setData(data);
							mHandler.sendMessage(msg);
							continue;
						}
					}

					// See if we need to upgrade the deck
					int version = 0;
					try {
						version = Deck.getDeckVersion(path);
					} catch (Exception e) {
						Log.w(AnkiDroidApp.TAG, ""Could not open database ""
								+ path);
						addBrokenDeck(path);
						data.putString(""absPath"", path);
						data.putInt(""msgtype"", MSG_COULD_NOT_BE_LOADED);
						msg = Message.obtain();
						msg.setData(data);
						mHandler.sendMessage(msg);						
						continue;
					}

					if (version < Deck.DECK_VERSION) {
						data.putString(""absPath"", path);
						data.putInt(""msgtype"", MSG_UPGRADE_NEEDED);
						data.putInt(""version"", version);
						data.putString(""notes"", """");
						msg = Message.obtain();
						msg.setData(data);
						mHandler.sendMessage(msg);
					}
					deck = getDeck(path);
					if (deck == null) {
						addBrokenDeck(path);
						data.putString(""absPath"", path);
						data.putInt(""msgtype"", MSG_COULD_NOT_BE_LOADED);
						msg = Message.obtain();
						msg.setData(data);
						mHandler.sendMessage(msg);
						continue;
					}
					version = deck.getVersion();

					// Check if the upgrade failed
					if (version < Deck.DECK_VERSION) {
						data.putString(""absPath"", path);
						data.putInt(""msgtype"", MSG_UPGRADE_FAILURE);
						data.putInt(""version"", version);
						data.putString(""notes"", Deck.upgradeNotesToMessages(deck, getResources()));
						closeDeck(deck);
						msg = Message.obtain();
						msg.setData(data);
						mHandler.sendMessage(msg);
					} else {
						try {
							int dueCards = deck.getDueCount();
							int totalCards = deck.getCardCount();
							int newCards = deck.getNewCountToday();
							int totalNewCards = deck.getNewCount(mCompletionBarRestrictToActive);
							int matureCards = deck.getMatureCardCount(mCompletionBarRestrictToActive);
							int totalRevCards = deck.getTotalRevFailedCount(mCompletionBarRestrictToActive);
							int totalCardsCompletionBar = totalRevCards + totalNewCards;
							double modified = deck.getModified();

							String upgradeNotes = Deck.upgradeNotesToMessages(deck, getResources());
							
							closeDeck(deck);

							data.putString(""absPath"", path);
							data.putInt(""msgtype"", MSG_UPGRADE_SUCCESS);
							data.putInt(""due"", dueCards);
							data.putDouble(""mod"", modified);
							data.putInt(""total"", totalCards);
							data.putInt(""new"", newCards);
							data.putInt(""totalNew"", totalNewCards);
							data.putString(""notes"", upgradeNotes);

							int rateOfCompletionMat;
							int rateOfCompletionAll;
							if (totalCardsCompletionBar != 0) {
							    rateOfCompletionMat = (matureCards * 100) / totalCardsCompletionBar;
			                    rateOfCompletionAll = (totalRevCards * 100) / totalCardsCompletionBar; 
							} else {
							    rateOfCompletionMat = 0;
							    rateOfCompletionAll = 0;
							}
							data.putInt(""rateOfCompletionMat"", rateOfCompletionMat);
	                        data.putInt(""rateOfCompletionAll"", Math.max(0, rateOfCompletionAll - rateOfCompletionMat));
							msg = Message.obtain();
							msg.setData(data);
							
							mTotalDueCards += dueCards + newCards;
							mTotalCards += totalCards;
							mTotalTime += Math.max(deck.getETA(), 0);							
						} catch (SQLiteException e) {
							Log.e(AnkiDroidApp.TAG, ""DeckPicker - run - error on loading deck values from file "" + path + "": "" + e);
							data.putString(""absPath"", path);
							data.putInt(""msgtype"", MSG_COULD_NOT_BE_LOADED);
							msg = Message.obtain();
							msg.setData(data);
							mHandler.sendMessage(msg);
							addBrokenDeck(path);
							continue;
						}


						mHandler.sendMessage(msg);
					}
				}
				mIsFinished = true;
				mHandler.sendEmptyMessage(0);
				mCondFinished.signal();
			} catch (Exception e) {
				throw new RuntimeException(e);
			} finally {
				mLock.unlock();
			}
		}
	}
	
	
	private void setTitleText(){
		Resources res = getResources();
		String time = res.getQuantityString(R.plurals.deckpicker_title_minutes, mTotalTime, mTotalTime);
		setTitle(res.getQuantityString(R.plurals.deckpicker_title, mTotalDueCards, mTotalDueCards, mTotalCards, time));
	}


	private void resetDeckLanguages(String deckPath) {
		if (MetaDB.resetDeckLanguages(this, deckPath)) {
			Themes.showThemedToast(this, getResources().getString(R.string.contextmenu_deckpicker_reset_reset_message), true);
		}
	}


    public void openPersonalDeckPicker() {
        if (AnkiDroidApp.isUserLoggedIn()) {
            startActivityForResult(new Intent(this, PersonalDeckPicker.class), DOWNLOAD_PERSONAL_DECK);
            if (StudyOptions.getApiLevel() > 4) {
                ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
            }
        } else {
            showDialog(DIALOG_USER_NOT_LOGGED_IN_DOWNLOAD);
        }
    }


    public void openSharedDeckPicker() {
        // deckLoaded = false;
        startActivityForResult(new Intent(this, SharedDeckPicker.class), DOWNLOAD_SHARED_DECK);
        if (StudyOptions.getApiLevel() > 4) {
            ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.RIGHT);
        }
    }


	private void handleDeckSelection(int id) {
		String deckFilename = null;

		waitForDeckLoaderThread();

		@SuppressWarnings(""unchecked"")
		HashMap<String, String> data = (HashMap<String, String>) mDeckListAdapter
				.getItem(id);
		deckFilename = data.get(""filepath"");

		if (deckFilename != null) {
			// Log.i(AnkiDroidApp.TAG, ""Selected "" + deckFilename);
			Intent intent = this.getIntent();
			intent.putExtra(StudyOptions.OPT_DB, deckFilename);
			setResult(RESULT_OK, intent);

			closeDeckPicker();
		}
	}


	public Deck getDeck(String filePath) {
		Deck loadedDeck = AnkiDroidApp.deck();
		if (loadedDeck != null && loadedDeck.getDeckPath().equals(filePath)) {
			return loadedDeck;
		} else {
			Deck deck = null;
			try {
				deck = Deck.openDeck(filePath, false);
			} catch (SQLException e) {
				Log.w(AnkiDroidApp.TAG, ""Could not open database "" + filePath + "": "" + e);
				addBrokenDeck(filePath);
			} catch (RuntimeException e) {
				Log.w(AnkiDroidApp.TAG, ""Could not open database "" + filePath + "": "" + e);
				addBrokenDeck(filePath);
			}
			return deck;
		}
	}


	public void addBrokenDeck(String filePath) {
		if (!mBrokenDecks.contains(filePath)) {
			mBrokenDecks.add(filePath);
			BackupManager.restoreDeckIfMissing(filePath);
		}
	}


	public void closeDeck(Deck deck) {
		Deck loadedDeck = AnkiDroidApp.deck();
		if (!(loadedDeck != null && loadedDeck == deck)) {
			deck.closeDeck(true);				
		}
	}


	private void removeDeck(String deckFilename) {
		if (deckFilename != null) {
			AnkiDatabaseManager.closeDatabase(deckFilename);
			File file = new File(deckFilename);
			boolean deleted = BackupManager.removeDeck(file);
			if (deleted) {
				// Log.i(AnkiDroidApp.TAG, ""DeckPicker - "" + deckFilename + "" deleted"");
				mDeckIsSelected = false;
				if (AnkiDroidApp.deck() != null && AnkiDroidApp.deck().getDeckPath().equals(deckFilename)) {
					AnkiDroidApp.setDeck(null);
				}
				populateDeckList(mPrefDeckPath);
			} else {
				Log.e(AnkiDroidApp.TAG, ""Error: Could not delete ""
						+ deckFilename);
			}
		}
	}

	private void waitForDeckLoaderThread() {
		mDeckIsSelected = true;
		// Log.i(AnkiDroidApp.TAG, ""DeckPicker - waitForDeckLoaderThread(), mDeckIsSelected set to true"");
		mLock.lock();
		try {
			while (!mIsFinished) {
				mCondFinished.await();
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		} finally {
			mLock.unlock();
		}
	}

	private CharSequence getSyncLogMessage(
			ArrayList<HashMap<String, String>> decksChangelogs) {
		SpannableStringBuilder spannableStringBuilder = new SpannableStringBuilder();
		int len = decksChangelogs.size();
		for (int i = 0; i < len; i++) {
			HashMap<String, String> deckChangelog = decksChangelogs.get(i);
			String deckName = deckChangelog.get(""deckName"");

			// Append deck name
			spannableStringBuilder.append(deckName);
			// Underline deck name
			spannableStringBuilder.setSpan(new UnderlineSpan(),
					spannableStringBuilder.length() - deckName.length(),
					spannableStringBuilder.length(), 0);
			// Put deck name in bold style
			spannableStringBuilder.setSpan(new StyleSpan(
					android.graphics.Typeface.BOLD), spannableStringBuilder
					.length()
					- deckName.length(), spannableStringBuilder.length(), 0);

			// Append sync message
			spannableStringBuilder.append(""\n"" + deckChangelog.get(""message""));

			// If it is not the last element, add the proper separation
			if (i != (len - 1)) {
				spannableStringBuilder.append(""\n\n"");
			}
		}

		return spannableStringBuilder;
	}


    DeckTask.TaskListener mLoadStatisticsHandler = new DeckTask.TaskListener() {

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
            if (mProgressDialog.isShowing()) {
                try {
                    mProgressDialog.dismiss();
                } catch (Exception e) {
                    Log.e(AnkiDroidApp.TAG, ""onPostExecute - Dialog dismiss Exception = "" + e.getMessage());
                }
            }
            if (result.getBoolean()) {
		    	if (mStatisticType == Statistics.TYPE_DECK_SUMMARY) {
		    		Statistics.showDeckSummary(DeckPicker.this);
		    	} else {
			    	Intent intent = new Intent(DeckPicker.this, com.ichi2.charts.ChartBuilder.class);
			    	startActivity(intent);
			        if (StudyOptions.getApiLevel() > 4) {
			            ActivityTransitionAnimation.slide(DeckPicker.this, ActivityTransitionAnimation.DOWN);
			        }	
		    	}
			}
		}

		@Override
		public void onPreExecute() {
            mProgressDialog = ProgressDialog.show(DeckPicker.this, """", getResources()
                    .getString(R.string.calculating_statistics), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
		}
    	
    };


    DeckTask.TaskListener mRepairDeckHandler = new DeckTask.TaskListener() {

    	@Override
        public void onPreExecute() {
            mProgressDialog = ProgressDialog.show(DeckPicker.this, """", getResources()
                    .getString(R.string.backup_repair_deck_progress), true);
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
        	if (result.getBoolean()) {
        		populateDeckList(mPrefDeckPath);
        	} else {
        		Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.deck_repair_error), true);
        	}
        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
        		mProgressDialog.dismiss();
        	}
        }
 
		@Override
		public void onProgressUpdate(TaskData... values) {
		}

    };


    DeckTask.TaskListener mRestoreDeckHandler = new DeckTask.TaskListener() {

    	@Override
        public void onPreExecute() {
            mProgressDialog = ProgressDialog.show(DeckPicker.this, """", getResources()
                    .getString(R.string.backup_restore_deck), true);
        }


        @Override
        public void onPostExecute(DeckTask.TaskData result) {
			switch (result.getInt()) {
    		case BackupManager.RETURN_DECK_RESTORED:
    			mRestoredOrDeleted = true;
                handleRestoreDecks(true);
                break;    			
    		case BackupManager.RETURN_ERROR:
        		mDeckNotLoadedAlert.show();
        		Themes.showThemedToast(DeckPicker.this, getResources().getString(R.string.backup_restore_error), true);
    			break;
    		case BackupManager.RETURN_NOT_ENOUGH_SPACE:
    			mDeckNotLoadedAlert.show();
    			mNoSpaceLeftAlert.show();
    			break;
    		}        		
        	if (mProgressDialog != null && mProgressDialog.isShowing()) {
        		mProgressDialog.dismiss();
        	}
        }
 
		@Override
		public void onProgressUpdate(TaskData... values) {
		}

    };


    DeckTask.TaskListener mOptimizeDeckHandler = new DeckTask.TaskListener() {

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
            if (mProgressDialog.isShowing()) {
                try {
                    mProgressDialog.dismiss();
                } catch (Exception e) {
                    Log.e(AnkiDroidApp.TAG, ""onPostExecute - Dialog dismiss Exception = "" + e.getMessage());
                }
            }
            closeDeck(result.getDeck());
    		StyledDialog dialog = (StyledDialog) onCreateDialog(DIALOG_OPTIMIZE_DATABASE);
    		dialog.setMessage(String.format(Utils.ENGLISH_LOCALE, getResources().getString(R.string.optimize_deck_message), Math.round(result.getLong() / 1024)));
    		dialog.show();
		}

		@Override
		public void onPreExecute() {
            mProgressDialog = ProgressDialog.show(DeckPicker.this, """", getResources()
                    .getString(R.string.optimize_deck_dialog), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
		}
    	
    };


    // ----------------------------------------------------------------------------
	// INNER CLASSES
	// ----------------------------------------------------------------------------


    public class AlternatingAdapter extends SimpleAdapter {
    	    public AlternatingAdapter(Context context, ArrayList<HashMap<String, String>> items, int resource, String[] from, int[] to) {
    	        super(context, items, resource, from, to);
    	    }

    	    @Override
    	    public View getView(int position, View convertView, ViewGroup parent) {
	    	  View view = super.getView(position, convertView, parent);
	    	  Themes.setContentStyle(view, Themes.CALLER_DECKPICKER_DECK);
    	      return view;
    	    }
    }


	public static final class AnkiFilter implements FileFilter {
		@Override
		public boolean accept(File pathname) {
			if (pathname.isFile() && pathname.getName().endsWith("".anki"")) {
				return true;
			}
			return false;
		}
	}


	private class HashMapCompareLoad implements
	Comparator<HashMap<String, String>> {
		@Override
		public int compare(HashMap<String, String> object1,
				HashMap<String, String> object2) {
    		return object1.get(""filepath"").compareToIgnoreCase(object2.get(""filepath""));
		}
	}


	private class HashMapCompare implements
	Comparator<HashMap<String, String>> {
		@Override
		public int compare(HashMap<String, String> object1,
				HashMap<String, String> object2) {
		    try {
		    	if (mPrefDeckOrder == ORDER_BY_DATE) {
					// If there are two decks with the same date of modification, order them in alphabetical order
					if (object2.get(""mod"").compareToIgnoreCase(object1.get(""mod"")) != 0) {
						return object2.get(""mod"").compareToIgnoreCase(
								object1.get(""mod""));
					} else {
						return object1.get(""filepath"").compareToIgnoreCase(
								object2.get(""filepath""));
					}
		    	} else if (mPrefDeckOrder == ORDER_BY_DUE_CARDS) {
					return - Integer.valueOf(object1.get(""dueInt"")).compareTo(Integer.valueOf(object2.get(""dueInt"")));
		    	} else if (mPrefDeckOrder == ORDER_BY_TOTAL_CARDS) {
		    		return - Integer.valueOf(object1.get(""total"")).compareTo(Integer.valueOf(object2.get(""total"")));
		    	} else if (mPrefDeckOrder == ORDER_BY_REMAINING_NEW_CARDS) {
		    		return - Integer.valueOf(object1.get(""totalNew"")).compareTo(Integer.valueOf(object2.get(""totalNew"")));
				} else {
					return 0;
				}
		    }
		    catch( Exception e ) {
		        return 0;
		    }
		}
	}


	class MyGestureDetector extends SimpleOnGestureListener {	
    	@Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            if (mSwipeEnabled) {
                try {
       				if (e1.getX() - e2.getX() > StudyOptions.sSwipeMinDistance && Math.abs(velocityX) > StudyOptions.sSwipeThresholdVelocity && Math.abs(e1.getY() - e2.getY()) < StudyOptions.sSwipeMaxOffPath) {
       					closeDeckPicker(true);
                    }
       			}
                catch (Exception e) {
                  	Log.e(AnkiDroidApp.TAG, ""onFling Exception = "" + e.getMessage());
                }
            }	            	
            return false;
    	}
    }
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (gestureDetector.onTouchEvent(event))
	        return true;
	    else
	    	return false;
    }

	@Override
	public void buttonPressed(ButtonEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void buttonReleased(ButtonEvent arg0) {
		// Log.d(""Zeemote"",""Button released, id: ""+arg0.getButtonID());
		Message msg = Message.obtain();
		msg.what = MSG_ZEEMOTE_BUTTON_A + arg0.getButtonID(); //Button A = 0, Button B = 1...
		if ((msg.what >= MSG_ZEEMOTE_BUTTON_A) && (msg.what <= MSG_ZEEMOTE_BUTTON_D)) { //make sure messages from future buttons don't get throug
			this.ZeemoteHandler.sendMessage(msg);
		}
		if (arg0.getButtonID()==-1)
		{
			msg.what = MSG_ZEEMOTE_BUTTON_D+arg0.getButtonGameAction();
			if ((msg.what >= MSG_ZEEMOTE_STICK_UP) && (msg.what <= MSG_ZEEMOTE_STICK_RIGHT)) { //make sure messages from future buttons don't get throug
				this.ZeemoteHandler.sendMessage(msg);
			}
		}
	}

	@Override
	protected void onResume() {
		super.onResume();
		// workaround for hidden dialog when resuming
		if (mSyncLogAlert != null && mSyncLogAlert.isShowing()) {
			try {				
				mSyncLogAlert.dismiss();
				mSyncLogAlert.show();
			} catch (Exception e) {
			}
		}
	      if ((AnkiDroidApp.zeemoteController() != null) && (AnkiDroidApp.zeemoteController().isConnected())){
	    	  // Log.d(""Zeemote"",""Adding listener in onResume"");
	    	  AnkiDroidApp.zeemoteController().addButtonListener(this);
	      	  adapter = new JoystickToButtonAdapter();
	      	  AnkiDroidApp.zeemoteController().addJoystickListener(adapter);
	      	  adapter.addButtonListener(this);
	      }
	}
}
",True,77,63,0,0,4,33
36,com.ichi2.anki.Media.java,"/****************************************************************************************
 * Copyright (c) 2011 Kostas Spyropoulos <inigo.aldana@gmail.com>                       *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.util.Log;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

/**
 * Class with static functions related with media handling (images and sounds).
 */
public class Media {
    // TODO: Javadoc.

    private static final Pattern mMediaRegexps[] = {
        Pattern.compile(""(?i)(\\[sound:([^]]+)\\])""),
        Pattern.compile(""(?i)(<img[^>]+src=[\""']?([^\""'>]+)[\""']?[^>]*>)"")
    };
    private static final Pattern regPattern = Pattern.compile(""\\((\\d+)\\)$"");

    // File Handling
    // *************

    /**
     * Copy PATH to MEDIADIR, and return new filename.
     * If a file with the same md5sum exists in the DB, return that.
     * If a file with the same name exists, return a unique name.
     * This does not modify the media table.
     *
     * @param deck The deck whose media we are dealing with
     * @param path The path and filename of the media file we are adding
     * @return The new filename.
     */
    public static String copyToMedia(Deck deck, String path) {
        // See if have duplicate contents
        String newpath = null;
        Cursor cursor = null;
        try {
            cursor = deck.getDB().getDatabase().rawQuery(""SELECT filename FROM media WHERE originalPath = '"" +
                    Utils.fileChecksum(path) + ""'"", null);
            if (cursor.moveToNext()) {
                newpath = cursor.getString(0);
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        if (newpath == null) {
            File file = new File(path);
            String base = file.getName();
            String mdir = deck.mediaDir(true);
            newpath = uniquePath(mdir, base);
            if (!file.renameTo(new File(newpath))) {
                Log.e(AnkiDroidApp.TAG, ""Couldn't move media file "" + path + "" to "" + newpath);
            }
        }
        return newpath.substring(newpath.lastIndexOf(""/"") + 1);
    }


    /**
     * Makes sure the filename of the media is unique.
     * If the filename matches an existing file, then a counter of the form "" (x)"" is appended before the media file
     * extension, where x = 1, 2, 3... as needed so that the filename is unique.
     *
     * @param dir The path to the media file, excluding the filename
     * @param base The filename of the file without the path
     */
    private static String uniquePath(String dir, String base) {
        // Remove any dangerous characters
        base = base.replaceAll(""[][<>:/\\"", """");
        // Find a unique name
        int extensionOffset = base.lastIndexOf(""."");
        String root = base.substring(0, extensionOffset);
        String ext = base.substring(extensionOffset);
        File file = null;
        while (true) {
            file = new File(dir, root + ext);
            if (!file.exists()) {
                break;
            }
            Matcher regMatcher = regPattern.matcher(root);
            if (!regMatcher.find()) {
                root = root + "" (1)"";
            } else {
                int num = Integer.parseInt(regMatcher.group(1));
                root = root.substring(regMatcher.start()) + "" ("" + num + "")"";
            }
        }
        return dir + ""/"" + root + ext;
    }


    // DB Routines
    // ***********

    /**
     * Updates the field size of a media record.
     * The field size is used to store the count of how many times is this media referenced in question and answer
     * fields of the cards in the deck.
     *
     * @param deck The deck that contains the media we are dealing with
     * @param file The full path of the media in question
     */
    public static void updateMediaCount(Deck deck, String file) {
        updateMediaCount(deck, file, 1);
    }
    public static void updateMediaCount(Deck deck, String file, int count) {
        if (deck.getDB().queryScalar(""SELECT 1 FROM media WHERE filename = '"" + file + ""'"") == 1l) {
            deck.getDB().getDatabase().execSQL(String.format(Utils.ENGLISH_LOCALE,
                        ""UPDATE media SET size = size + %d, created = %f WHERE filename = '%s'"",
                        count, Utils.now(), file));
        } else if (count > 0) {
            String sum = Utils.fileChecksum(file);
            deck.getDB().getDatabase().execSQL(String.format(Utils.ENGLISH_LOCALE, ""INSERT INTO media "" +
                    ""(id, filename, size, created, originalPath, description) "" +
                    ""VALUES (%d, '%s', %d, %f, '%s', '')"", Utils.genID(), file, count, Utils.now(), sum));
        }
    }


    /**
     * Deletes from media table any entries that are not referenced in question or answer of any card.
     *
     * @param deck The deck that this operation will be performed on
     */
    public static void removeUnusedMedia(Deck deck) {
        ArrayList<Long> ids = deck.getDB().queryColumn(Long.class, ""SELECT id FROM media WHERE size = 0"", 0);
        for (Long id : ids) {
            deck.getDB().getDatabase().execSQL(String.format(Utils.ENGLISH_LOCALE, ""INSERT INTO mediaDeleted "" +
                        ""VALUES (%d, %f)"", id.longValue(), Utils.now()));
        }
        deck.getDB().getDatabase().execSQL(""DELETE FROM media WHERE size = 0"");
    }

    // String manipulation
    // *******************

    public static ArrayList<String> mediaFiles(String string) {
        return mediaFiles(string, false);
    }
    public static ArrayList<String> mediaFiles(String string, boolean remote) {
        boolean isLocal = false;
        ArrayList<String> l = new ArrayList<String>();
        for (Pattern reg : mMediaRegexps) {
            Matcher m = reg.matcher(string);
            while (m.find()) {
                isLocal = !m.group(2).toLowerCase().matches(""(https?|ftp)://"");
                if (!remote && isLocal) {
                    l.add(m.group(2));
                } else if (remote && !isLocal) {
                    l.add(m.group(2));
                }
            }
        }
        return l;
    }

    /**
     * Removes references of media from a string.
     *
     * @param txt The string to be cleared of any media references
     * @return The cleared string without any media references
     */
    public static String stripMedia(String txt) {
        for (Pattern reg : mMediaRegexps) {
            txt = reg.matcher(txt).replaceAll("""");
        }
        return txt;
    }

    // Rebuilding DB
    // *************

    /**
     * Rebuilds the reference counts, potentially deletes unused media files,
     *
     * @param deck The deck to perform the operation on
     * @param delete If true, then unused (unreferenced in question/answer fields) media files will be deleted
     * @param dirty If true, then the modified field of deck will be updated
     * @return Nothing, but the original python code returns a list of unreferenced media files and a list
     * of missing media files (referenced in question/answer fields, but with the actual files missing)
     */
    public static void rebuildMediaDir(Deck deck) {
        rebuildMediaDir(deck, false, true);
    }
    public static void rebuildMediaDir(Deck deck, boolean delete) {
        rebuildMediaDir(deck, delete, true);
    }
    public static void rebuildMediaDir(Deck deck, boolean delete, boolean dirty) {
        String mdir = deck.mediaDir();
        if (mdir == null) {
            return;
        }
        //Set all ref counts to 0
        deck.getDB().getDatabase().execSQL(""UPDATE media SET size = 0"");

        // Look through the cards for media references
        Cursor cursor = null;
        String txt = null;
        Map<String, Integer> refs = new HashMap<String, Integer>();
        Set<String> normrefs = new HashSet<String>();
        try {
            cursor = deck.getDB().getDatabase().rawQuery(""SELECT question, answer FROM cards"", null);
            while (cursor.moveToNext()) {
                for (int i = 0; i < 2; i++) {
                    txt = cursor.getString(i);
                    for (String f : mediaFiles(txt)) {
                        if (refs.containsKey(f)) {
                            refs.put(f, refs.get(f) + 1);
                        } else {
                            refs.put(f, 1);
                            // normrefs.add(Normalizer.normalize(f, Normalizer.Form.NFC));
                            normrefs.add(f);
                        }
                    }
                }
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        // Update ref counts
        for (Entry<String, Integer> entry : refs.entrySet()) {
            updateMediaCount(deck, entry.getKey(), entry.getValue());
        }
        String fname = null;

        //If there is no media dir, then there is nothing to find.
        if(mdir != null) {
            // Find unused media
            Set<String> unused = new HashSet<String>();
            File mdirfile = new File(mdir);
            if (mdirfile.exists()) {
                fname = null;
                for (File f : mdirfile.listFiles()) {
                    if (!f.isFile()) {
                        // Ignore directories
                        continue;
                    }
                    // fname = Normalizer.normalize(f.getName(), Normalizer.Form.NFC);
                    fname = f.getName();
                    if (!normrefs.contains(fname)) {
                        unused.add(fname);
                    }
                }
            }
            // Optionally delete
            if (delete) {
                for (String fn : unused) {
                    File file = new File(mdir + ""/"" + fn);
                    try {
                        if (!file.delete()) {
                            Log.e(AnkiDroidApp.TAG, ""Couldn't delete unused media file "" + mdir + ""/"" + fn);
                        }
                    } catch (SecurityException e) {
                        Log.e(AnkiDroidApp.TAG, ""Security exception while deleting unused media file "" + mdir + ""/"" + fn);
                    }
                }
            }
        }
        // Remove entries in db for unused media
        removeUnusedMedia(deck);

        // Check md5s are up to date
        cursor = null;
        String path = null;
        fname = null;
        String md5 = null;
        SQLiteDatabase db = deck.getDB().getDatabase();
        db.beginTransaction();
        try {
            cursor = db.query(""media"", new String[] {""filename"", ""created"", ""originalPath""}, null, null, null, null, null);
            while (cursor.moveToNext()) {
                fname = cursor.getString(0);
                md5 = cursor.getString(2);
                path = mdir + ""/"" + fname;
                File file = new File(path);
                if (!file.exists()) {
                   if (!md5.equals("""")) {
                       db.execSQL(String.format(Utils.ENGLISH_LOCALE,
                               ""UPDATE media SET originalPath = '', created = %f where filename = '%s'"",
                               Utils.now(), fname));
                   }
                } else {
                    String sum = Utils.fileChecksum(path);
                    if (!md5.equals(sum)) {
                       db.execSQL(String.format(Utils.ENGLISH_LOCALE,
                               ""UPDATE media SET originalPath = '%s', created = %f where filename = '%s'"",
                               sum, Utils.now(), fname));
                    }
                }
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        db.setTransactionSuccessful();
        db.endTransaction();

        // Update deck and get return info
        if (dirty) {
            deck.flushMod();
        }
        // In contrast to the python code we don't return anything. In the original python code, the return
        // values are used in a function (media.onCheckMediaDB()) that we don't have in AnkiDroid.
    }
}
",True,88,63,0,0,5,24
37,com.ichi2.anki.Image.java,"/***************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.util.Log;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Class used to display and handle correctly images.
 */
public class Image {

    /**
     * Pattern used to identify img tags
     */
    public static Pattern sImagePattern = Pattern
            .compile(""(?i)<img[^<>(src)]*src\\s*=\\s*(\""[^\""]*\""|'[^']*'|[^'\"">]+)[^<>]*>"");


    /* Prevent class from being instantiated */
    private Image() { }


    /**
     * Parses the content (belonging to deck deckFilename), adding an onload event to the img tags, that will be useful
     * in order to resize them.
     *
     * @param deckFilename Deck's filename whose content is being parsed
     * @param content HTML content of a card
     * @return content Content with the onload events for the img tags
     */
    public static String parseImages(String deckFilename, String content) {

        StringBuilder stringBuilder = new StringBuilder();
        String contentLeft = content;

        // Log.i(AnkiDroidApp.TAG, ""parseImages"");
        Matcher matcher = sImagePattern.matcher(content);
        while (matcher.find()) {
            String img = matcher.group(1);
            // // Log.i(AnkiDroidApp.TAG, ""Image "" + matcher.groupCount() + "": "" + img);

            String imgTag = matcher.group();
            int markerStart = contentLeft.indexOf(imgTag);
            stringBuilder.append(contentLeft.substring(0, markerStart));
            stringBuilder.append(""<img src="" + img + "" onload=\""resizeImage();\"">"");

            contentLeft = contentLeft.substring(markerStart + imgTag.length());
            // // Log.i(AnkiDroidApp.TAG, ""Content left = "" + contentLeft);
        }

        stringBuilder.append(contentLeft);

        return stringBuilder.toString();
    }
}
",True,34,56,5,27,0,0
38,com.ichi2.anki.AnkiDroidWidgetSmall.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import com.tomgibara.android.veecheck.util.PrefSettings;

import android.app.PendingIntent;
import android.app.Service;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.os.IBinder;
import android.util.Log;
import android.view.View;
import android.widget.RemoteViews;

public class AnkiDroidWidgetSmall extends AppWidgetProvider {
	
    private static BroadcastReceiver mMountReceiver = null;
    private static boolean remounted = false;

    @Override
    public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {
        // Log.i(AnkiDroidApp.TAG, ""SmallWidget: onUpdate"");
        WidgetStatus.update(context);
    }

    @Override
    public void onEnabled(Context context) {
        super.onEnabled(context);
        // Log.i(AnkiDroidApp.TAG, ""SmallWidget: Widget enabled"");
        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
        preferences.edit().putBoolean(""widgetSmallEnabled"", true).commit();
    }

    @Override
    public void onDisabled(Context context) {
        super.onDisabled(context);
        // Log.i(AnkiDroidApp.TAG, ""SmallWidget: Widget disabled"");
        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
        preferences.edit().putBoolean(""widgetSmallEnabled"", false).commit();
    }

    public static class UpdateService extends Service {

        /** The cached number of total due cards. */
        private int dueCardsCount;

        /** The cached amount of today's yes reps. */
        private int reps;

        /** The cached estimated reviewing time. */
        private int eta;

        @Override
        public void onStart(Intent intent, int startId) {
            // Log.i(AnkiDroidApp.TAG, ""SmallWidget: OnStart"");

            RemoteViews updateViews = buildUpdate(this, true);

            ComponentName thisWidget = new ComponentName(this, AnkiDroidWidgetSmall.class);
            AppWidgetManager manager = AppWidgetManager.getInstance(this);
            manager.updateAppWidget(thisWidget, updateViews);
        }


        private RemoteViews buildUpdate(Context context, boolean updateDueDecksNow) {
            // Log.i(AnkiDroidApp.TAG, ""buildUpdate"");

            // Resources res = context.getResources();
            RemoteViews updateViews = new RemoteViews(context.getPackageName(), R.layout.widget_small);

            // Add a click listener to open Anki from the icon.
            // This should be always there, whether there are due cards or not.
            Intent ankiDroidIntent = new Intent(context, StudyOptions.class);
            ankiDroidIntent.setAction(Intent.ACTION_MAIN);
            ankiDroidIntent.addCategory(Intent.CATEGORY_LAUNCHER);
            PendingIntent pendingAnkiDroidIntent = PendingIntent.getActivity(context, 0, ankiDroidIntent, PendingIntent.FLAG_UPDATE_CURRENT);
            updateViews.setOnClickPendingIntent(R.id.ankidroid_widget_small_layout, pendingAnkiDroidIntent);

            boolean mounted = AnkiDroidApp.isSdCardMounted();
            if (!mounted) {
                updateViews.setViewVisibility(R.id.widget_due, View.INVISIBLE);
                updateViews.setViewVisibility(R.id.widget_eta, View.INVISIBLE);
                updateViews.setViewVisibility(R.id.widget_progress_frame, View.INVISIBLE);
                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.GONE);

                if (mMountReceiver == null) {
                	mMountReceiver = new BroadcastReceiver() {
                        @Override
                        public void onReceive(Context context, Intent intent) {
                            String action = intent.getAction();
                        	if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {
                                // Log.i(AnkiDroidApp.TAG, ""mMountReceiver - Action = Media Mounted"");
                                if (remounted) {
                                    WidgetStatus.update(getBaseContext());                                	
                                	remounted = false;
                                    if (mMountReceiver != null) {
                                        unregisterReceiver(mMountReceiver);
                                    }
                                } else {
                                	remounted = true;
                                }
                            }
                        }
                    };
                    IntentFilter iFilter = new IntentFilter();
                    iFilter.addAction(Intent.ACTION_MEDIA_MOUNTED);
                    iFilter.addDataScheme(""file"");
                    registerReceiver(mMountReceiver, iFilter);
                }
            } else {
                // If we do not have a cached version, always update.
                if (dueCardsCount == 0 || updateDueDecksNow) {
                    // Build a list of decks with due cards.
                    // Also compute the total number of cards due.
                	int[] counts = WidgetStatus.fetchSmall(context);
                	
                	dueCardsCount = counts[0];
                	reps = counts[1];
                	eta = counts[2];
                	int totalreps = reps + dueCardsCount;
                	int progress = 0;
                	if (totalreps != 0) {
                		progress = (int) Math.round((100.0d * reps) / totalreps);
                	}
        			if (dueCardsCount <= 0) {
        				if (dueCardsCount == 0) {
    		                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.VISIBLE);        					
        				} else {
    		                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.INVISIBLE);        					
        				}
		                updateViews.setViewVisibility(R.id.widget_due, View.INVISIBLE);
		                updateViews.setViewVisibility(R.id.widget_progress_frame, View.INVISIBLE);
        			} else {
		                updateViews.setViewVisibility(R.id.ankidroid_widget_small_finish_layout, View.INVISIBLE);
		                updateViews.setViewVisibility(R.id.widget_due, View.VISIBLE);
		                updateViews.setViewVisibility(R.id.widget_progress_frame, View.VISIBLE);
	                    updateViews.setTextViewText(R.id.widget_due, Integer.toString(dueCardsCount));
	                    updateViews.setProgressBar(R.id.widget_progress, 100, progress, false);
					}
        			if (eta <= 0 || dueCardsCount <= 0) {
		                updateViews.setViewVisibility(R.id.widget_eta, View.INVISIBLE);        				
        			} else {
		                updateViews.setViewVisibility(R.id.widget_eta, View.VISIBLE);        				
	                    updateViews.setTextViewText(R.id.widget_eta, Integer.toString(eta));
        			}
                }
            }

            return updateViews;
        }

        @Override
        public IBinder onBind(Intent arg0) {
            // Log.i(AnkiDroidApp.TAG, ""onBind"");
            return null;
        }
    }
}
",False,37,63,0,0,5,30
39,com.ichi2.anki.MyAccount.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Resources;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

public class MyAccount extends Activity {

    private View mLoginToMyAccountView;
    private View mLoggedIntoMyAccountView;

    private EditText mUsername;
    private EditText mPassword;

    private TextView mUsernameLoggedIn;

    private ProgressDialog mProgressDialog;
    private StyledDialog mNoConnectionAlert;
    private StyledDialog mConnectionErrorAlert;
    private StyledDialog mInvalidUserPassAlert;


    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);

        initAllContentViews();
        initAllAlertDialogs();

        if (AnkiDroidApp.isUserLoggedIn()) {
            SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
            String username = preferences.getString(""username"", """");
            mUsernameLoggedIn.setText(username);
            setContentView(mLoggedIntoMyAccountView);
        } else {
            setContentView(mLoginToMyAccountView);
        }

    }


    // Commented awaiting the resolution of the next issue: http://code.google.com/p/anki/issues/detail?id=1932
//    private boolean isUsernameAndPasswordValid(String username, String password) {
//        return isLoginFieldValid(username) && isLoginFieldValid(password);
//    }
//
//
//    private boolean isLoginFieldValid(String loginField) {
//        boolean loginFieldValid = false;
//
//        if (loginField.length() >= 2 && loginField.matches(""[A-Za-z0-9]+"")) {
//            loginFieldValid = true;
//        }
//
//        return loginFieldValid;
//    }


    private void saveUserInformation(String username, String password) {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
        Editor editor = preferences.edit();
        editor.putString(""username"", username);
        editor.putString(""password"", password);
        editor.commit();
    }


    private void login() {
        // Hide soft keyboard
        InputMethodManager inputMethodManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
        inputMethodManager.hideSoftInputFromWindow(mUsername.getWindowToken(), 0);

        String username = mUsername.getText().toString();
        String password = mPassword.getText().toString();

        // // Log.i(AnkiDroidApp.TAG, ""Username = "" + username);
        // // Log.i(AnkiDroidApp.TAG, ""Password = "" + password);

        /*
         * Commented awaiting the resolution of the next issue: http://code.google.com/p/anki/issues/detail?id=1932
         * if(isUsernameAndPasswordValid(username, password)) { Connection.login(loginListener, new
         * Connection.Payload(new Object[] {username, password})); } else { mInvalidUserPassAlert.show(); }
         */

        if (!"""".equalsIgnoreCase(username) && !"""".equalsIgnoreCase(password)) {
            Connection.login(loginListener, new Connection.Payload(new Object[] { username, password }));
        } else {
            mInvalidUserPassAlert.show();
        }
    }


    private void logout() {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
        Editor editor = preferences.edit();
        editor.putString(""username"", """");
        editor.putString(""password"", """");
        editor.commit();

        setContentView(mLoginToMyAccountView);
    }


    private void initAllContentViews() {
        mLoginToMyAccountView = getLayoutInflater().inflate(R.layout.my_account, null);
        Themes.setWallpaper(mLoginToMyAccountView);
        Themes.setTextViewStyle(mLoginToMyAccountView.findViewById(R.id.MyAccountLayout));
        Themes.setTextViewStyle(mLoginToMyAccountView.findViewById(R.id.no_account_text));
        mUsername = (EditText) mLoginToMyAccountView.findViewById(R.id.username);
        mPassword = (EditText) mLoginToMyAccountView.findViewById(R.id.password);

        Button loginButton = (Button) mLoginToMyAccountView.findViewById(R.id.login_button);
        loginButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                login();
            }

        });

        Button signUpButton = (Button) mLoginToMyAccountView.findViewById(R.id.sign_up_button);
        signUpButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(getResources().getString(
                        R.string.ankionline_sign_up_url))));
            }

        });

        mLoggedIntoMyAccountView = getLayoutInflater().inflate(R.layout.my_account_logged_in, null);
        Themes.setWallpaper(mLoggedIntoMyAccountView);
        Themes.setTitleStyle(mLoggedIntoMyAccountView.findViewById(R.id.logged_text));
        mUsernameLoggedIn = (TextView) mLoggedIntoMyAccountView.findViewById(R.id.username_logged_in);
        Button logoutButton = (Button) mLoggedIntoMyAccountView.findViewById(R.id.logout_button);
        logoutButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                logout();
            }

        });
    }


    /**
     * Create AlertDialogs used on all the activity
     */
    private void initAllAlertDialogs() {
        Resources res = getResources();

        StyledDialog.Builder builder = new StyledDialog.Builder(this);

        builder.setTitle(res.getString(R.string.connection_error_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.connection_needed));
        builder.setPositiveButton(res.getString(R.string.ok), null);
        mNoConnectionAlert = builder.create();

	builder = new StyledDialog.Builder(this);
        builder.setTitle(res.getString(R.string.log_in));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.invalid_username_password));
        mInvalidUserPassAlert = builder.create();

	builder = new StyledDialog.Builder(this);
        builder.setTitle(res.getString(R.string.connection_error_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.connection_error_message));
        builder.setPositiveButton(res.getString(R.string.retry), new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                login();
            }
        });
        builder.setNegativeButton(res.getString(R.string.cancel), null);
        mConnectionErrorAlert = builder.create();
    }

    /**
     * Listeners
     */
    Connection.TaskListener loginListener = new Connection.TaskListener() {

        @Override
        public void onProgressUpdate(Object... values) {
            // Pass
        }


        @Override
        public void onPreExecute() {
            // Log.i(AnkiDroidApp.TAG, ""onPreExcecute"");
            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = ProgressDialog.show(MyAccount.this, """",
                        getResources().getString(R.string.alert_logging_message), true);
            }
        }


        @Override
        public void onPostExecute(Payload data) {
            // Log.i(AnkiDroidApp.TAG, ""onPostExecute, succes = "" + data.success);
            if (mProgressDialog != null) {
                mProgressDialog.dismiss();
            }

            if (data.success) {
                saveUserInformation((String) data.data[0], (String) data.data[1]);

                // Log.i(AnkiDroidApp.TAG, ""User successfully logged!"");

                Intent i = MyAccount.this.getIntent();
                if (i.hasExtra(""notLoggedIn"") && i.getExtras().getBoolean(""notLoggedIn"", false)) {
                	MyAccount.this.setResult(RESULT_OK, i);
                	finish();
			        if (StudyOptions.getApiLevel() > 4) {
			            ActivityTransitionAnimation.slide(MyAccount.this, ActivityTransitionAnimation.RIGHT);
			        }
                } else {
                    // Show logged view
                    mUsernameLoggedIn.setText((String) data.data[0]);
                    setContentView(mLoggedIntoMyAccountView);
                }
            } else {
                if (data.returnType == AnkiDroidProxy.LOGIN_INVALID_USER_PASS) {
                    if (mInvalidUserPassAlert != null) {
                        mInvalidUserPassAlert.show();
                    }
                } else {
                    if (mConnectionErrorAlert != null) {
                        mConnectionErrorAlert.show();
                    }
                }
            }
        }


        @Override
        public void onDisconnected() {
            if (mNoConnectionAlert != null) {
                mNoConnectionAlert.show();
            }
        }
    };

}
",True,17,64,0,0,5,26
40,com.ichi2.anki.PersonalDeckPicker.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.KeyEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.BaseAdapter;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.services.DownloadManagerService;
import com.ichi2.anki.services.IDownloadManagerService;
import com.ichi2.anki.services.IPersonalDeckServiceCallback;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class PersonalDeckPicker extends Activity {

    /**
     * Broadcast that informs us when the sd card is about to be unmounted
     */
    private BroadcastReceiver mUnmountReceiver = null;

    private ProgressDialog mProgressDialog;
    private StyledDialog mNoConnectionAlert;
    private StyledDialog mConnectionErrorAlert;
    private StyledDialog mDownloadOverwriteAlert;

    private Intent mDownloadManagerServiceIntent;
    // Service interface we will use to call the service
    private IDownloadManagerService mDownloadManagerService = null;

    private List<Download> mPersonalDeckDownloads;
    private List<String> mPersonalDecks;
    private List<Object> mAllPersonalDecks;
    private ListView mPersonalDecksListView;
    private PersonalDecksAdapter mPersonalDecksAdapter;
    private EditText mSearchEditText;
    private String mDestination;
    private Download mDeckToDownload;

    private boolean mDownloadSuccessful = false;

    /********************************************************************
     * Lifecycle methods *
     ********************************************************************/

    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);

        setContentView(R.layout.download_deck_picker);

        initDownloadManagerService();
        registerExternalStorageListener();
        initDialogs();

        mPersonalDeckDownloads = new ArrayList<Download>();
        mPersonalDecks = new ArrayList<String>();

        mAllPersonalDecks = new ArrayList<Object>();
        mPersonalDecksAdapter = new PersonalDecksAdapter();
        mPersonalDecksListView = (ListView) findViewById(R.id.list);
        mPersonalDecksListView.setAdapter(mPersonalDecksAdapter);     
        mPersonalDecksListView.setOnItemClickListener(new OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {

                Object deckNameObject = mAllPersonalDecks.get(position);
                // If we click twice very fast, the second click tries to download the download that was triggered
                // by the first click and causes crash
                if (!(deckNameObject instanceof String)) {
                    return;
                }
                String deckName = (String) deckNameObject;

                  for (Download d : mPersonalDeckDownloads) {
                        if (d.getTitle().equals(deckName)) {
                            // Duplicate downloads not allowed, sorry.
                        	Themes.showThemedToast(PersonalDeckPicker.this, getResources().getString(R.string.duplicate_download), true);
                            return;
                        }
                    }

                Download personalDeckDownload = new Download(deckName);
                mDestination = PrefSettings.getSharedPrefs(getBaseContext()).getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
                setDeckToDownload(personalDeckDownload);
                if (new File(mDestination + ""/"" + deckName + "".anki"").exists()) {
                    mDownloadOverwriteAlert.setMessage(getResources().getString(R.string.download_message, deckName));
                    mDownloadOverwriteAlert.show();
                    // Log.d(AnkiDroidApp.TAG, ""Download Deck already exists"");
                } else {
                    downloadPersonalDeck(personalDeckDownload);
                    // Log.d(AnkiDroidApp.TAG, ""Download Deck not exists"");
                }
            }

        });

        mSearchEditText = (EditText) findViewById(R.id.shared_deck_download_search);
        mSearchEditText.addTextChangedListener(new TextWatcher() {
        	public void afterTextChanged(Editable s) {
    			List<String> foundDecks = new ArrayList<String>();
            	foundDecks.clear();
            	for (int i = 0; i < mPersonalDecks.size(); i++) {
            		if (mPersonalDecks.get(i).toLowerCase().indexOf(mSearchEditText.getText().toString().toLowerCase()) != -1) { 
            			foundDecks.add(mPersonalDecks.get(i));
            		}
            	}
                mAllPersonalDecks.clear();
                mAllPersonalDecks.addAll(mPersonalDeckDownloads);
                mAllPersonalDecks.addAll(foundDecks);
                mPersonalDecksAdapter.notifyDataSetChanged();
            }
            public void beforeTextChanged(CharSequence s, int start, int count, int after){}
            public void onTextChanged(CharSequence s, int start, int before, int count){}
        });
        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
        
        getPersonalDecks();
    }

    private void downloadPersonalDeck(Download personalDeck) {

        mPersonalDeckDownloads.add(personalDeck);
        refreshPersonalDecksList();
        try {
            startService(mDownloadManagerServiceIntent);
            mDownloadManagerService.downloadFile(personalDeck);
        } catch (RemoteException e) {
            // There is nothing special we need to do if the service has crashed
            Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
            e.printStackTrace();
        }
    }


    @Override
    protected void onResume() {
        super.onResume();
        // Log.i(AnkiDroidApp.TAG, ""onResume"");
        if (mDownloadManagerService != null) {
            try {
                mDownloadManagerService.registerPersonalDeckCallback(mCallback);
                setPersonalDeckDownloads(mDownloadManagerService.getPersonalDeckDownloads());
            } catch (RemoteException e) {
                // There is nothing special we need to do if the service has crashed
                Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                e.printStackTrace();
            }
        }
    }


    @Override
    protected void onPause() {
        super.onPause();
        // Log.i(AnkiDroidApp.TAG, ""onpause kostas"");
        if (mDownloadManagerService != null) {
            try {
                mDownloadManagerService.unregisterPersonalDeckCallback(mCallback);
            } catch (RemoteException e) {
                // There is nothing special we need to do if the service has crashed
                Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                e.printStackTrace();
            }
        }
    }


    @Override
    protected void onDestroy() {
        // Log.i(AnkiDroidApp.TAG, ""onDestroy"");
        super.onDestroy();
        releaseService();
        releaseBroadcastReceiver();
        releaseDialogs();
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event)  {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            // Log.i(AnkiDroidApp.TAG, ""PersonalDeckPicker - onBackPressed()"");
            closePersonalDeckPicker();
        }
        return super.onKeyDown(keyCode, event);
    }


    /********************************************************************
     * Custom methods *
     ********************************************************************/

    private void initDownloadManagerService() {
        mDownloadManagerServiceIntent = new Intent(PersonalDeckPicker.this, DownloadManagerService.class);
        // Needed when the incomplete downloads are resumed while entering SharedDeckPicker
        // if the Service gets shut down, we want it to be restarted automatically, so for this to happen it has to be
        // started but not stopped
        startService(mDownloadManagerServiceIntent);
        bindService(mDownloadManagerServiceIntent, mConnection, Context.BIND_AUTO_CREATE);
    }


    private void releaseService() {
        if (mConnection != null) {
            // Log.i(AnkiDroidApp.TAG, ""Unbinding Service..."");
            unbindService(mConnection);
            mConnection = null;
        }
    }


    /**
     * Registers an intent to listen for ACTION_MEDIA_EJECT notifications. The intent will call
     * closeExternalStorageFiles() if the external media is going to be ejected, so applications can clean up any files
     * they have open.
     */
    public void registerExternalStorageListener() {
        if (mUnmountReceiver == null) {
            mUnmountReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    String action = intent.getAction();
                    if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
                        finishNoStorageAvailable();
                    }
                }
            };
            IntentFilter iFilter = new IntentFilter();
            iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
            iFilter.addDataScheme(""file"");
            registerReceiver(mUnmountReceiver, iFilter);
        }
    }


    private void releaseBroadcastReceiver() {
        if (mUnmountReceiver != null) {
            unregisterReceiver(mUnmountReceiver);
            mUnmountReceiver = null;
        }
    }


    /**
     * Create AlertDialogs used on all the activity
     */
    private void initDialogs() {
        Resources res = getResources();

        // Init alert dialogs
        StyledDialog.Builder builder = new StyledDialog.Builder(this);

        builder.setTitle(res.getString(R.string.connection_error_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.connection_needed));
        builder.setPositiveButton(res.getString(R.string.ok), new OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
            	closePersonalDeckPicker();
            }

        });
        mNoConnectionAlert = builder.create();

	builder = new StyledDialog.Builder(this);
        builder.setTitle(res.getString(R.string.connection_error_title));
        builder.setIcon(android.R.drawable.ic_dialog_alert);
        builder.setMessage(res.getString(R.string.connection_error_return_message));
        builder.setPositiveButton(res.getString(R.string.retry), new OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                getPersonalDecks();
            }
        });
        builder.setNegativeButton(res.getString(R.string.cancel), new OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
            	closePersonalDeckPicker();
            }

        });
        mConnectionErrorAlert = builder.create();

        builder = new StyledDialog.Builder(this);
        builder.setTitle(res.getString(R.string.sync_conflict_title));
        builder.setIcon(android.R.drawable.ic_input_get);
        builder.setMessage(res.getString(R.string.download_message));
        builder.setPositiveButton(res.getString(R.string.download_overwrite), mSyncDublicateAlertListener);
        builder.setNegativeButton(res.getString(R.string.download_cancel), mSyncDublicateAlertListener);
        builder.setCancelable(false);
        mDownloadOverwriteAlert = builder.create();
    }


    private void releaseDialogs() {
        // Needed in order to not try to show the alerts when the Activity does not exist anymore
        mProgressDialog = null;
        // mNoConnectionAlert = null;
        // mConnectionFailedAlert = null;
        mConnectionErrorAlert = null;
    }

    public Download getDeckToDownload() {
        return mDeckToDownload;
    }

    public void setDeckToDownload(Download deckToDownload) {
        this.mDeckToDownload = deckToDownload;
    }

    private void refreshPersonalDecksList() {
        mAllPersonalDecks.clear();
        mAllPersonalDecks.addAll(mPersonalDeckDownloads);
        mAllPersonalDecks.addAll(mPersonalDecks);
        mPersonalDecksAdapter.notifyDataSetChanged();
    }


    private void getPersonalDecks() {
        // Log.i(AnkiDroidApp.TAG, ""getPersonalDecks"");
        SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
        String username = pref.getString(""username"", """");
        String password = pref.getString(""password"", """");
        Connection.getPersonalDecks(getPersonalDecksListener, new Connection.Payload(
                new Object[] { username, password }));
    }


    private void setPersonalDeckDownloads(List<Download> downloads) {
        mPersonalDeckDownloads.clear();
        mPersonalDeckDownloads.addAll(downloads);
        refreshPersonalDecksList();
    }


    private void finishNoStorageAvailable() {
        setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
        closePersonalDeckPicker();
    }

    private void closePersonalDeckPicker() {
        if (mDownloadSuccessful) {
    		Intent intent = PersonalDeckPicker.this.getIntent();
    		setResult(RESULT_OK, intent);
    	}
        finish();
        if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
            ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.LEFT);
        }
    }

    /********************************************************************
     * Service Connection *
     ********************************************************************/

    /**
     * Class for interacting with the main interface of the service.
     */
    private ServiceConnection mConnection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName className, IBinder service) {
            // This is called when the connection with the service has been
            // established, giving us the service object we can use to
            // interact with the service. We are communicating with our
            // service through an IDL interface, so get a client-side
            // representation of that from the raw service object.
            mDownloadManagerService = IDownloadManagerService.Stub.asInterface(service);

            // Log.i(AnkiDroidApp.TAG, ""onServiceConnected"");
            // We want to monitor the service for as long as we are
            // connected to it.
            try {
                mDownloadManagerService.registerPersonalDeckCallback(mCallback);
            } catch (RemoteException e) {
                // In this case the service has crashed before we could even
                // do anything with it; we can count on soon being
                // disconnected (and then reconnected if it can be restarted)
                // so there is no need to do anything here.
            }
        }


        @Override
        public void onServiceDisconnected(ComponentName name) {
            mDownloadManagerService = null;
        }
    };

    /********************************************************************
     * Listeners *
     ********************************************************************/

    private Connection.TaskListener getPersonalDecksListener = new Connection.TaskListener() {

        @Override
        public void onDisconnected() {
            // Log.i(AnkiDroidApp.TAG, ""onDisconnected"");
            if (mNoConnectionAlert != null) {
                mNoConnectionAlert.show();
            }
        }


        @SuppressWarnings(""unchecked"")
        @Override
        public void onPostExecute(Payload data) {
            // Log.i(AnkiDroidApp.TAG, ""onPostExecute"");
            if (mProgressDialog != null) {
                mProgressDialog.dismiss();
            }

            if (data.success) {
                mPersonalDecks.clear();
                mPersonalDecks.addAll((List<String>) data.result);

                refreshPersonalDecksList();
            } else {
                if (mConnectionErrorAlert != null) {
                    if (data.result != null) {
                        // Known error
                        mConnectionErrorAlert.setMessage((String) data.result);
                    }
                    mConnectionErrorAlert.show();
                }
            }
        }


        @Override
        public void onPreExecute() {
            if (mProgressDialog == null || !mProgressDialog.isShowing()) {
                mProgressDialog = ProgressDialog.show(PersonalDeckPicker.this, """",
                        getResources().getString(R.string.loading_personal_decks), true, true, new DialogInterface.OnCancelListener() {
                	@Override
                	public void onCancel(DialogInterface dialog) {
                		closePersonalDeckPicker();
                	}
                });
            }
        }


        @Override
        public void onProgressUpdate(Object... values) {
            // Pass
        }

    };

    private OnClickListener mSyncDublicateAlertListener = new OnClickListener() {
        @Override
        public void onClick(DialogInterface dialog, int which) {
            switch (which) {
                case StyledDialog.BUTTON_POSITIVE:
                    downloadPersonalDeck(getDeckToDownload());
                    break;
                case StyledDialog.BUTTON_NEGATIVE:
                default:
            }
        }
    };

    /********************************************************************
     * Callbacks *
     ********************************************************************/

    /**
     * This implementation is used to receive callbacks from the remote service.
     */
    private IPersonalDeckServiceCallback mCallback = new IPersonalDeckServiceCallback.Stub() {
        @Override
        public void publishProgress(List<Download> downloads) throws RemoteException {
            setPersonalDeckDownloads(downloads);
        }
    };

    /********************************************************************
     * Adapters *
     ********************************************************************/

    public class PersonalDecksAdapter extends BaseAdapter {

        @Override
        public int getCount() {
            return mAllPersonalDecks.size();
        }


        @Override
        public Object getItem(int position) {
            return mAllPersonalDecks.get(position);
        }


        @Override
        public long getItemId(int position) {
            return position;
        }


        @Override
        public boolean isEnabled(int position) {
            return !(mAllPersonalDecks.get(position) instanceof Download);
        }


        @Override
        public View getView(int position, View convertView, ViewGroup parent) {
            View row = convertView;
            DownloadViewWrapper wrapper = null;
            Resources res = getResources();

            if (row == null) {
                row = getLayoutInflater().inflate(R.layout.download_deck_item, null);
                Themes.setContentStyle(row, Themes.CALLER_DOWNLOAD_DECK);
                wrapper = new DownloadViewWrapper(row);
                row.setTag(wrapper);
            } else {
                wrapper = (DownloadViewWrapper) row.getTag();
            }

            TextView headerTitle = wrapper.getHeaderTitle();
            TextView downloadingSharedDeckTitle = wrapper.getDownloadTitle();
            ProgressBar progressBar = wrapper.getProgressBar();
            TextView progressText = wrapper.getProgressBarText();
            TextView estimatedText = wrapper.getEstimatedTimeText();
            TextView sharedDeckTitle = wrapper.getDeckTitle();
            TextView sharedDeckFacts = wrapper.getDeckFacts();

            Object obj = mAllPersonalDecks.get(position);
            if (obj instanceof Download) {
                Download download = (Download) obj;

                sharedDeckTitle.setVisibility(View.GONE);
                sharedDeckFacts.setVisibility(View.GONE);

                if (position == 0) {
                    headerTitle.setText(res.getString(R.string.currently_downloading));
                    headerTitle.setVisibility(View.VISIBLE);
                } else {
                    headerTitle.setVisibility(View.GONE);
                }
                downloadingSharedDeckTitle.setText(download.getTitle());
                downloadingSharedDeckTitle.setVisibility(View.VISIBLE);

                //if (!progressBar.isIndeterminate()) {
                //    progressBar.setIndeterminate(true);
                //}
                progressBar.setVisibility(View.VISIBLE);
                long downloaded = 0l;
                switch (download.getStatus()) {
                    case Download.STATUS_STARTED:
                        progressText.setText(res.getString(R.string.starting_download));
                        break;

                    case Download.STATUS_DOWNLOADING:
                        progressText.setText(res.getString(R.string.downloading));
                        downloaded = download.getDownloaded();
                        estimatedText.setText(String.valueOf(downloaded / 1024) + "" kB"");
                        break;
                    case Download.STATUS_COMPLETE:
                        progressText.setText(res.getString(R.string.downloaded));
                        mDownloadSuccessful = true;
                        break;

                    default:
                        progressText.setText(res.getString(R.string.error));
                        break;
                }
                progressText.setVisibility(View.VISIBLE);
                estimatedText.setVisibility(View.VISIBLE);
            } else {
                String personalDeckTitle = (String) obj;
                if (position > 0 && (mAllPersonalDecks.get(position - 1) instanceof Download)) {
                    headerTitle.setText(res.getString(R.string.personal_decks));
                    headerTitle.setVisibility(View.VISIBLE);
                } else {
                    headerTitle.setVisibility(View.GONE);
                }
                downloadingSharedDeckTitle.setVisibility(View.GONE);
                progressBar.setVisibility(View.GONE);
                progressText.setVisibility(View.GONE);
                estimatedText.setVisibility(View.GONE);

                sharedDeckTitle.setText(personalDeckTitle);
                sharedDeckTitle.setVisibility(View.VISIBLE);
                sharedDeckFacts.setVisibility(View.GONE);
            }

            return row;
        }

    }

}
",True,76,68,0,0,5,28
41,com.ichi2.anki.WidgetStatus.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import com.ichi2.anki.services.NotificationService;
import com.tomgibara.android.veecheck.util.PrefSettings;

import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.database.SQLException;
import android.os.AsyncTask;
import android.util.Log;

import java.io.File;
import java.io.FileFilter;
import java.util.ArrayList;
import java.util.Collections;

/**
 * The status of the widget.
 * <p>
 * It contains the status of each of the decks.
 */
public final class WidgetStatus {

	private static boolean mediumWidget = false;
	private static boolean smallWidget = false;
	private static boolean notification = false;
	private static AsyncTask<Context,Void,Context> mUpdateDeckStatusAsyncTask;

    /** This class should not be instantiated. */
    private WidgetStatus() {}

    /** Request the widget to update its status. */
    public static void update(Context context) {
        // Only update the widget if it is enabled.
        // TODO(flerda): Split widget from notifications.
        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
        if (preferences.getBoolean(""widgetMediumEnabled"", false)) {
            mediumWidget = true;
        } else {
            mediumWidget = false;
        }
        if (preferences.getBoolean(""widgetSmallEnabled"", false)) {
            smallWidget = true;
        } else {
            smallWidget = false;
        }
        if (Integer.parseInt(preferences.getString(""minimumCardsDueForNotification"", ""25"")) < 1000000) {
        	notification = true;
        } else {
        	notification = false;
        }
        if (mediumWidget || smallWidget || notification) {
            // Log.d(AnkiDroidApp.TAG, ""WidgetStatus.update(): updating"");
            mUpdateDeckStatusAsyncTask = new UpdateDeckStatusAsyncTask();
            mUpdateDeckStatusAsyncTask.execute(context);
        } else {
            // Log.d(AnkiDroidApp.TAG, ""WidgetStatus.update(): not enabled"");
        }
    }


    /**
     * Block the current thread until the currently running UpdateDeckStatusAsyncTask instance (if any) has finished.
     */
    public static void waitToFinish() {
        try {
            if ((mUpdateDeckStatusAsyncTask != null) && (mUpdateDeckStatusAsyncTask.getStatus() != AsyncTask.Status.FINISHED)) {
            	mUpdateDeckStatusAsyncTask.get();
            }
        } catch (Exception e) {
            return;
        }
    }


    /** Returns the status of each of the decks. */
    public static DeckStatus[] fetch(Context context) {
        return MetaDB.getWidgetStatus(context);
    }

    /** Returns the status of each of the decks. */
    public static int[] fetchSmall(Context context) {
        return MetaDB.getWidgetSmallStatus(context);
    }

    public static int fetchDue(Context context) {
        return MetaDB.getNotificationStatus(context);
    }

    private static class UpdateDeckStatusAsyncTask extends AsyncTask<Context, Void, Context> {
        private static final DeckStatus[] EMPTY_DECK_STATUS = new DeckStatus[0];

        private static DeckStatus[] mDecks = EMPTY_DECK_STATUS;

        @Override
        protected Context doInBackground(Context... params) {
            // Log.d(AnkiDroidApp.TAG, ""WidgetStatus.UpdateDeckStatusAsyncTask.doInBackground()"");
            Context context = params[0];

            if (!AnkiDroidApp.isSdCardMounted()) {
            	return context;
            }

            SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
            String deckPath = preferences.getString(""deckPath"",
                    AnkiDroidApp.getStorageDirectory() + ""/AnkiDroid"");

            File dir = new File(deckPath);

            File[] fileList = dir.listFiles(new AnkiFileFilter());

            if (fileList == null || fileList.length == 0) {
                mDecks = EMPTY_DECK_STATUS;
                return context;
            }

            // For the deck information
            ArrayList<DeckStatus> decks = new ArrayList<DeckStatus>(fileList.length);

            for (File file : fileList) {
            	String absPath = null;
                try {
                    // Run through the decks and get the information
                    absPath = file.getAbsolutePath();
                    String deckName = file.getName().replaceAll("".anki"", """");

                    // Log.i(AnkiDroidApp.TAG, ""Found deck: "" + absPath);

                    Deck deck;
                    Deck currentDeck = AnkiDroidApp.deck();
                    if (currentDeck != null && currentDeck.getDeckPath().equals(absPath)) {
                    	deck = currentDeck;
                    } else {
                    	try {
                        	deck = Deck.openDeck(absPath, false);                    		
            			} catch (RuntimeException e) {
            				Log.w(AnkiDroidApp.TAG, ""Widget: Could not open database "" + absPath + "": "" + e);
            				BackupManager.restoreDeckIfMissing(absPath);
            				deck = null;
            			}
                    }
                    if (deck == null) {
                        Log.e(AnkiDroidApp.TAG, ""Widget: Skipping null deck: "" + absPath);
                        // Use the data from the last time we updated the deck, if available.
//                        for (DeckStatus deckStatus : mDecks) {
//                            if (absPath.equals(deckStatus.mDeckPath)) {
//                                // Log.d(AnkiDroidApp.TAG, ""Using previous value"");
//                                decks.add(deckStatus);
//                                break;
//                            }
//                        }
                        continue;
                    }
                    int dueCards = 0;
                    int newCards = 0;
                    int failedCards = deck.getFailedSoonCount();
                    int eta = 0;
                    int reps = deck.getSessionFinishedCards();
		    if(!deck.hasFinishScheduler()) {
        	            dueCards = deck.getRevCount();
        	            newCards = deck.getNewCountToday();
        	            eta = deck.getETA();
		    }
                    // Close the database connection, but only if this is not the current database.
                    // Probably we need to make this atomic to be sure it will not cause a failure.
                    if (currentDeck != null && currentDeck.getDB() != deck.getDB()) {
                        deck.closeDeck();
                    }

                    // Add the information about the deck
                    decks.add(new DeckStatus(absPath, deckName, newCards, dueCards, failedCards, eta, reps));
                } catch (SQLException e) {
                    // Log.i(AnkiDroidApp.TAG, ""Widget: Could not open deck"");
                    Log.e(AnkiDroidApp.TAG, e.toString());
                    if (absPath != null) {
                        BackupManager.restoreDeckIfMissing(absPath);                    	
                    }
                }
            }

            if (!decks.isEmpty() && decks.size() > 1) {
                // Sort and reverse the list if there are decks
                // Log.i(AnkiDroidApp.TAG, ""Sorting deck"");

                // Ordered by reverse due cards number
                Collections.sort(decks, new ByDueComparator());
            }

            mDecks = decks.toArray(EMPTY_DECK_STATUS);
            return context;
        }

        @Override
        protected void onPostExecute(Context context) {
            // Log.d(AnkiDroidApp.TAG, ""WidgetStatus.UpdateDeckStatusAsyncTask.onPostExecute()"");
            MetaDB.storeWidgetStatus(context, mDecks);
            if (mediumWidget) {
            	Intent intent;
                intent = new Intent(context, AnkiDroidWidgetMedium.UpdateService.class);
                intent.setAction(AnkiDroidWidgetMedium.UpdateService.ACTION_UPDATE);
                context.startService(intent);
            }
            if (smallWidget) {
            	Intent intent;
                intent = new Intent(context, AnkiDroidWidgetSmall.UpdateService.class);            	
                context.startService(intent);
            }
            if (notification) {
            	Intent intent;
                intent = new Intent(context, NotificationService.class);
                context.startService(intent);
            }
        }

        /** Comparator that sorts instances of {@link DeckStatus} based on number of due cards. */
        private static class ByDueComparator implements java.util.Comparator<DeckStatus> {
            @Override
            public int compare(DeckStatus deck1, DeckStatus deck2) {
                // Reverse due cards number order
                return deck2.mDueCards - deck1.mDueCards;
            }
        }

        /** Filter for Anki files. */
        private static final class AnkiFileFilter implements FileFilter {
            @Override
            public boolean accept(File pathname) {
                return pathname.isFile() && pathname.getName().endsWith("".anki"");
            }
        }
    }
}
",True,71,63,0,0,5,22
42,com.ichi2.anki.Whiteboard.java,"/****************************************************************************************
 * Copyright (c) 2009 Andrew <andrewdubya@gmail.com>                                    *
 * Copyright (c) 2009 Nicolas Raoul <nicolas.raoul@gmail.com>                           *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.Path;
import android.view.MotionEvent;
import android.view.View;

import com.tomgibara.android.veecheck.util.PrefSettings;

/**
 * Whiteboard allowing the user to draw the card's answer on the touchscreen.
 */
public class Whiteboard extends View {

    private static final float TOUCH_TOLERANCE = 4;

    private Paint mPaint;
    private Bitmap mBitmap;
    private Canvas mCanvas;
    private Path mPath;
    private Paint mBitmapPaint;

    private int mBackgroundColor;
    private int mForegroundColor;

    private boolean mLocked;
    private boolean mRecreateBitmap = false;

    private float mX;
    private float mY;
    
    private boolean mInvertedColors = false;
    private boolean mMonochrome = true;


    public Whiteboard(Context context, boolean inverted, boolean monochrome) {
        super(context, null);

        mInvertedColors = inverted;
        mMonochrome = monochrome;

        if (!mInvertedColors) {
        	if (mMonochrome) {
                mForegroundColor = Color.BLACK;
        	} else {
        		mForegroundColor = context.getResources().getColor(R.color.wb_fg_color);
        	}
        } else {
        	if (mMonochrome) {
                mForegroundColor = Color.WHITE;
        	} else {
        		mForegroundColor = context.getResources().getColor(R.color.wb_fg_color_inv);
        	}
    	}

        mPaint = new Paint();
        mPaint.setAntiAlias(true);
        mPaint.setDither(true);
        mPaint.setColor(mForegroundColor);
        mPaint.setStyle(Paint.Style.STROKE);
        mPaint.setStrokeJoin(Paint.Join.ROUND);
        mPaint.setStrokeCap(Paint.Cap.ROUND);
        int wbStrokeWidth = PrefSettings.getSharedPrefs(context).getInt(""whiteBoardStrokeWidth"", 6);
        mPaint.setStrokeWidth((float) wbStrokeWidth);

        createBitmap();

        mPath = new Path();
        mBitmapPaint = new Paint(Paint.DITHER_FLAG);
    }


    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.drawColor(mBackgroundColor);
        canvas.drawBitmap(mBitmap, 0, 0, mBitmapPaint);
        canvas.drawPath(mPath, mPaint);
    }


    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        // We want to create the bitmap again only when the screen has been rotated,
        // not when the size changes in the transition between the front and the back
        // of a card (that would made the Whiteboard to disappear)
        if (mRecreateBitmap) {
            createBitmap();
            super.onSizeChanged(w, h, oldw, oldh);
            mRecreateBitmap = false;
        }
    }


    /**
     * Handle touch screen motion events.
     * @param event The motion event.
     * @return True if the event was handled, false otherwise.
     */
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        boolean handled = false;

        if (!mLocked) {
            float x = event.getX();
            float y = event.getY();
            handled = true;

            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    touchStart(x, y);
                    invalidate();
                    break;
                case MotionEvent.ACTION_MOVE:
                    touchMove(x, y);
                    invalidate();
                    break;
                case MotionEvent.ACTION_UP:
                    touchUp();
                    invalidate();
                    break;
                default:
                    handled = false;
            }
        }

        return handled;
    }


    /**
     * Create a new bitmap that fits the new screen layout.
     * The content of the whiteboard does not survive screen rotation.
     */
    public void rotate() {
        mRecreateBitmap = true;
    }


    /**
     * Clear the whiteboard.
     */
    public void clear() {
        mBitmap.eraseColor(mBackgroundColor);
        invalidate();
        unlock();
    }


    private void unlock() {
        mLocked = false;
    }

    // XXX: Unused
    // If we don't need to lock the whiteboard, then we should remove mLocked too
//    public void lock() {
//        mLocked = true;
//    }


    private void createBitmap(int w, int h, Bitmap.Config conf) {
        mBitmap = Bitmap.createBitmap(w, h, conf);
        mCanvas = new Canvas(mBitmap);
        clear();
    }


    private void createBitmap() {
    	if (mMonochrome && !mInvertedColors) {
            createBitmap(AnkiDroidApp.getDisplayWidth(), AnkiDroidApp.getDisplayHeight(), Bitmap.Config.ALPHA_8);
    	} else {
            createBitmap(AnkiDroidApp.getDisplayWidth(), AnkiDroidApp.getDisplayHeight(), Bitmap.Config.ARGB_4444);
    	}
    }


    private void touchStart(float x, float y) {
        mPath.reset();
        mPath.moveTo(x, y);
        mX = x;
        mY = y;
    }


    private void touchMove(float x, float y) {
        float dx = Math.abs(x - mX);
        float dy = Math.abs(y - mY);
        if (dx >= TOUCH_TOLERANCE || dy >= TOUCH_TOLERANCE) {
            mPath.quadTo(mX, mY, (x + mX) / 2, (y + mY) / 2);
            mX = x;
            mY = y;
        }
    }


    private void touchUp() {
        mPath.lineTo(mX, mY);
        // commit the path to our offscreen
        mCanvas.drawPath(mPath, mPaint);
        // kill this so we don't double draw
        mPath.reset();
    }
}
",False,78,63,0,0,5,27
43,com.ichi2.anki.Card.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.content.Context;
import android.content.res.Resources;
import android.database.Cursor;
import android.text.format.DateFormat;
import android.util.Log;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.TreeMap;

/**
 * A card is a presentation of a fact, and has two sides: a question and an answer. Any number of fields can appear on
 * each side. When you add a fact to Anki, cards which show that fact are generated. Some models generate one card,
 * others generate more than one.
 *
 * @see http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Cards
 */
public class Card {

    // TODO: Javadoc.

    /** Card types. */
    public static final int TYPE_FAILED = 0;
    public static final int TYPE_REV = 1;
    public static final int TYPE_NEW = 2;

    /** Card states. */
    public static final String STATE_NEW = ""new"";
    public static final String STATE_YOUNG = ""young"";
    public static final String STATE_MATURE = ""mature"";

    /** Auto priorities. */
    public static final int PRIORITY_NONE = 0;
    public static final int PRIORITY_LOW = 1;
    public static final int PRIORITY_NORMAL = 2;
    public static final int PRIORITY_MEDIUM = 3;
    public static final int PRIORITY_HIGH = 4;

    /** Manual priorities. */
    public static final int PRIORITY_REVIEW_EARLY = -1;
    public static final int PRIORITY_BURIED = -2;
    public static final int PRIORITY_SUSPENDED = -3;

    /** Ease. */
    public static final int EASE_NONE = 0;
    public static final int EASE_FAILED = 1;
    public static final int EASE_HARD = 2;
    public static final int EASE_MID = 3;
    public static final int EASE_EASY = 4;

    /** Tags src constants. */
    public static final int TAGS_FACT = 0;
    public static final int TAGS_MODEL = 1;
    public static final int TAGS_TEMPL = 2;

    private static final int LEARNT_THRESHOLD = 7;
    public static final int MATURE_THRESHOLD = 21;

    private static final double MAX_TIMER = 60.0;

    // BEGIN SQL table entries
    private long mId; // Primary key
    private long mFactId; // Foreign key facts.id
    private long mCardModelId; // Foreign key cardModels.id
    private double mCreated = Utils.now();
    private double mModified = Utils.now();
    private String mTags = """";
    private int mOrdinal;
    // Cached - changed on fact update
    private String mQuestion = """";
    private String mAnswer = """";
    private int mPriority = PRIORITY_NORMAL;
    private double mInterval = 0;
    private double mLastInterval = 0;
    private double mDue = Utils.now();
    private double mLastDue = 0;
    private double mFactor = Deck.INITIAL_FACTOR;
    private double mLastFactor = Deck.INITIAL_FACTOR;
    private double mFirstAnswered = 0;
    // Stats
    private int mReps = 0;
    private int mSuccessive = 0;
    private double mAverageTime = 0;
    private double mReviewTime = 0;
    private int mYoungEase0 = 0;
    private int mYoungEase1 = 0;
    private int mYoungEase2 = 0;
    private int mYoungEase3 = 0;
    private int mYoungEase4 = 0;
    private int mMatureEase0 = 0;
    private int mMatureEase1 = 0;
    private int mMatureEase2 = 0;
    private int mMatureEase3 = 0;
    private int mMatureEase4 = 0;
    // This duplicates the above data, because there's no way to map imported
    // data to the above
    private int mYesCount = 0;
    private int mNoCount = 0;
    private double mSpaceUntil = 0;      // obsolete in libanki 1.1.4
    // relativeDelay is reused as type without scheduling (ie, it remains 0-2 even if card is suspended, etc)
    private double mRelativeDelay = 0;
    private int mIsDue = 0;              // obsolete in libanki 1.1
    private int mType = TYPE_NEW;
    private double mCombinedDue = 0;
    // END SQL table entries

    public Deck mDeck;

    // BEGIN JOINed variables
    private CardModel mCardModel;
    private Fact mFact;
    private String[] mTagsBySrc;
    // END JOINed variables

    private double mTimerStarted;
    private double mTimerStopped;
    private double mFuzz = 0;

    // Leech flags, not read from database, only set to true during the actual suspension
    private boolean isLeechMarked;
    private boolean isLeechSuspended;

    public Card(Deck deck, Fact fact, CardModel cardModel, double created) {
        mTags = """";
        mTagsBySrc = new String[TAGS_TEMPL + 1];
        mTagsBySrc[TAGS_FACT] = """";
        mTagsBySrc[TAGS_MODEL] = """";
        mTagsBySrc[TAGS_TEMPL] = """";

        mId = Utils.genID();
        // New cards start as new & due
        mType = TYPE_NEW;
        mRelativeDelay = mType;
        mTimerStarted = Double.NaN;
        mTimerStopped = Double.NaN;
        mModified = Utils.now();
        if (Double.isNaN(created)) {
            mCreated = created;
            mDue = created;
        } else {
            mDue = mModified;
        }
        isLeechSuspended = false;
        mCombinedDue = mDue;
        mDeck = deck;
        mFact = fact;
        if (fact != null) {
            mFactId = fact.getId();
        }
        mCardModel = cardModel;
        if (cardModel != null) {
            mCardModelId = cardModel.getId();
            mOrdinal = cardModel.getOrdinal();
        }
    }

	/**
	 * Format qa
	 */
	public void rebuildQA(Deck deck) {
		rebuildQA(deck, true);
	}
	
	public void rebuildQA(Deck deck, boolean media) {
        // Format qa
		if (mFact != null && mCardModel != null) {
			HashMap<String, String> qa = CardModel.formatQA(mFact, mCardModel, splitTags());

            if (media) {
                // Find old media references
                HashMap<String, Integer> files = new HashMap<String, Integer>();
                ArrayList<String> filesFromQA = Media.mediaFiles(mQuestion);
                filesFromQA.addAll(Media.mediaFiles(mAnswer));
                for (String f : filesFromQA) {
                    if (files.containsKey(f)) {
                        files.put(f, files.get(f) - 1);
                    } else {
                        files.put(f, -1);
                    }
                }
                // Update q/a
                mQuestion = qa.get(""question"");
                mAnswer = qa.get(""answer"");
                // Determine media delta
                filesFromQA = Media.mediaFiles(mQuestion);
                filesFromQA.addAll(Media.mediaFiles(mAnswer));
                for (String f : filesFromQA) {
                    if (files.containsKey(f)) {
                        files.put(f, files.get(f) + 1);
                    } else {
                        files.put(f, 1);
                    }
                }
                // Update media counts if we're attached to deck
                for (Entry<String, Integer> entry : files.entrySet()) {
                    Media.updateMediaCount(deck, entry.getKey(), entry.getValue());
                }
            } else {
                // Update q/a
                mQuestion = qa.get(""question"");
                mAnswer = qa.get(""answer"");
            }
            setModified();
		}
	}

    public Card(Deck deck) {
        this(deck, null, null, Double.NaN);
    }


    public Fact getFact() {
        if (mFact == null) {
            mFact = new Fact(mDeck, mFactId);
        }
        return mFact;
    }


    public void setModified() {
        mModified = Utils.now();
    }


    public void startTimer() {
        mTimerStarted = Utils.now();
    }


    public void stopTimer() {
        mTimerStopped = Utils.now();
    }


    public void resumeTimer() {
        if (!Double.isNaN(mTimerStarted) && !Double.isNaN(mTimerStopped)) {
            mTimerStarted += Utils.now() - mTimerStopped;
            mTimerStopped = Double.NaN;
        } else {
            // Log.i(AnkiDroidApp.TAG, ""Card Timer: nothing to resume"");
        }
    }


    public double thinkingTime() {
        if (Double.isNaN(mTimerStopped)) {
            return (Utils.now() - mTimerStarted);
        } else {
            return (mTimerStopped - mTimerStarted);
        }
    }


    public double totalTime() {
        return (Utils.now() - mTimerStarted);
    }

    public double getFuzz() {
    	if (mFuzz == 0) {
    		genFuzz();
    	}
    	return mFuzz;
    }

    public void genFuzz() {
        // Random rand = new Random();
        // mFuzz = 0.95 + (0.1 * rand.nextDouble());
        mFuzz = (double) Math.random();
    }


    // XXX Unused
//    public String htmlQuestion(String type, boolean align) {
//        return null;
//    }
//
//
//    public String htmlAnswer(boolean align) {
//        return htmlQuestion(""answer"", align);
//    }


    public void updateStats(int ease, String state) {
        char[] newState = state.toCharArray();
        mReps += 1;
        if (ease > EASE_FAILED) {
            mSuccessive += 1;
        } else {
            mSuccessive = 0;
        }

        double delay = Math.min(totalTime(), MAX_TIMER);
        // Ignore any times over 60 seconds
        mReviewTime += delay;
        if (mAverageTime != 0) {
            mAverageTime = (mAverageTime + delay) / 2.0;
        } else {
            mAverageTime = delay;
        }
        // We don't track first answer for cards
        if (STATE_NEW.equalsIgnoreCase(state)) {
            newState = STATE_YOUNG.toCharArray();
        }

        // Update ease and yes/no count
        // We want attr to be of the form mYoungEase3
        newState[0] = Character.toUpperCase(newState[0]);
        String attr = ""m"" + String.valueOf(newState) + String.format(""Ease%d"", ease);
        try {
            Field f = this.getClass().getDeclaredField(attr);
            f.setInt(this, f.getInt(this) + 1);
        } catch (Exception e) {
            Log.e(AnkiDroidApp.TAG, ""Failed to update "" + attr + "" : "" + e.getMessage());
        }

        if (ease < EASE_HARD) {
            mNoCount += 1;
        } else {
            mYesCount += 1;
        }
        if (mFirstAnswered == 0) {
            mFirstAnswered = Utils.now();
        }
        setModified();
    }


    public void updateFactor(int ease, double averageFactor) {
        mLastFactor = mFactor;
        if (isNew()) {
            mFactor = averageFactor; // card is new, inherit beginning factor
        }
        if (isRev() && !isBeingLearnt()) {
            if (ease == EASE_FAILED) {
                mFactor -= 0.20;
            } else if (ease == EASE_HARD) {
                mFactor -= 0.15;
            }
        }
        if (ease == EASE_EASY) {
            mFactor += 0.10;
        }
        mFactor = Math.max(Deck.FACTOR_FOUR, mFactor);
    }


    public double adjustedDelay(int ease) {
        double now = Utils.now();
        if (isNew()) {
            return 0;
        }
        if (mCombinedDue <= now) {
            return (now -mDue) / 86400.0;
        } else {
            return (now - mCombinedDue) / 86400.0;
        }
    }


    /**
     * Suspend this card.
     */
    public void suspend() {
        long[] ids = new long[1];
        ids[0] = mId;
        mDeck.suspendCards(ids);
        mDeck.reset();
    }


    /**
     * Unsuspend this card.
     */
    public void unsuspend() {
        long[] ids = new long[1];
        ids[0] = mId;
        mDeck.unsuspendCards(ids);
    }


    public boolean getSuspendedState() {
        return mDeck.getSuspendedState(mId);
    }

    /**
     * Delete this card.
     */
    public void delete() {
        List<String> ids = new ArrayList<String>();
        ids.add(Long.toString(mId));
        mDeck.deleteCards(ids);
    }


    public String getState() {
        if (isNew()) {
            return STATE_NEW;
        } else if (mInterval > MATURE_THRESHOLD) {
            return STATE_MATURE;
        }
        return STATE_YOUNG;
    }


    /**
     * Check if a card is a new card.
     * @return True if a card has never been seen before.
     */
    public boolean isNew() {
        return mReps == 0;
    }


    /**
     * Check if this is a revision of a successfully answered card.
     * @return True if the card was successfully answered last time.
     */
    public boolean isRev() {
        return mSuccessive != 0;
    }


    /**
     * Check if a card is being learnt.
     * @return True if card should use present intervals.
     */
    public boolean isBeingLearnt() {
        return mLastInterval < LEARNT_THRESHOLD;
    }


    public String[] splitTags() {
        String[] tags = new String[]{
            getFact().getTags(),
            Model.getModel(mDeck, getFact().getModelId(), true).getTags(),
            getCardModel().getName()
        };
        return tags;
    }


    private String allTags() {
        // Non-Canonified string of fact and model tags
        if ((mTagsBySrc[TAGS_FACT].length() > 0) && (mTagsBySrc[TAGS_MODEL].length() > 0)) {
            return mTagsBySrc[TAGS_FACT] + "","" + mTagsBySrc[TAGS_MODEL];
        } else if (mTagsBySrc[TAGS_FACT].length() > 0) {
            return mTagsBySrc[TAGS_FACT];
        } else {
            return mTagsBySrc[TAGS_MODEL];
        }
    }


    public boolean hasTag(String tag) {
        return (allTags().indexOf(tag) != -1);
    }


    public boolean isMarked() {
    	int markedId = mDeck.getMarketTagId();
    	if (markedId == -1) {
    		return false;
    	} else {
    		return (AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).queryScalar(""SELECT count(*) FROM cardTags WHERE cardId = "" + mId + "" AND tagId = "" + markedId + "" LIMIT 1"") != 0);
    	}
    }

    // FIXME: Should be removed. Calling code should directly interact with Model
    public CardModel getCardModel() {
        Model myModel = Model.getModel(mDeck, mCardModelId, false);
        return myModel.getCardModel(mCardModelId);
    }


    // Loading tags for this card. Needed when:
    // - we modify the card fields and need to update question and answer.
    // - we check is a card is marked
    public void loadTags() {
        Cursor cursor = null;

        int tagSrc = 0;

        // Flush tags
        for (int i = 0; i < mTagsBySrc.length; i++) {
            mTagsBySrc[i] = """";
        }

        try {
            cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                    ""SELECT tags.tag, cardTags.src ""
                    + ""FROM cardTags JOIN tags ON cardTags.tagId = tags.id "" + ""WHERE cardTags.cardId = "" + mId
                    + "" AND cardTags.src in ("" + TAGS_FACT + "", "" + TAGS_MODEL + "","" + TAGS_TEMPL + "") ""
                    + ""ORDER BY cardTags.id"", null);
            while (cursor.moveToNext()) {
                tagSrc = cursor.getInt(1);
                if (mTagsBySrc[tagSrc].length() > 0) {
                    mTagsBySrc[tagSrc] += "","" + cursor.getString(0);
                } else {
                    mTagsBySrc[tagSrc] += cursor.getString(0);
                }
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }


    public void resetCard() {
        // Log.i(AnkiDroidApp.TAG, ""Reset Card: "" + mId);
    	mModified = Utils.now();
    	mPriority = PRIORITY_NORMAL;
        mInterval = 0;
        mLastInterval = 0;
        mDue = Utils.now();
        mLastDue = 0;
        mFactor = Deck.INITIAL_FACTOR;
        mLastFactor = Deck.INITIAL_FACTOR;
        mFirstAnswered = 0;
        mReps = 0;
        mSuccessive = 0;
        mAverageTime = 0;
        mReviewTime = 0;
        mYoungEase0 = 0;
        mYoungEase1 = 0;
        mYoungEase2 = 0;
        mYoungEase3 = 0;
        mYoungEase4 = 0;
        mMatureEase0 = 0;
        mMatureEase1 = 0;
        mMatureEase2 = 0;
        mMatureEase3 = 0;
        mMatureEase4 = 0;
        mYesCount = 0;
        mNoCount = 0;
        mRelativeDelay = 0;
        mType = TYPE_NEW;
        mCombinedDue = 0;
        toDB();
    }


    public boolean fromDB(long id) {
        Cursor cursor = null;

        try {
            cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                    ""SELECT id, factId, cardModelId, created, modified, tags, ""
                            + ""ordinal, question, answer, priority, interval, lastInterval, ""
                            + ""due, lastDue, factor, lastFactor, firstAnswered, reps, ""
                            + ""successive, averageTime, reviewTime, youngEase0, youngEase1, ""
                            + ""youngEase2, youngEase3, youngEase4, matureEase0, matureEase1, ""
                            + ""matureEase2, matureEase3, matureEase4, yesCount, noCount, ""
                            + ""spaceUntil, isDue, type, combinedDue, relativeDelay "" + ""FROM cards "" + ""WHERE id = "" + id, null);
            if (!cursor.moveToFirst()) {
                Log.w(AnkiDroidApp.TAG, ""Card.java (fromDB(id)): No result from query."");
                return false;
            }

            mId = cursor.getLong(0);
            mFactId = cursor.getLong(1);
            mCardModelId = cursor.getLong(2);
            mCreated = cursor.getDouble(3);
            mModified = cursor.getDouble(4);
            mTags = cursor.getString(5);
            mOrdinal = cursor.getInt(6);
            mQuestion = cursor.getString(7);
            mAnswer = cursor.getString(8);
            mPriority = cursor.getInt(9);
            mInterval = cursor.getDouble(10);
            mLastInterval = cursor.getDouble(11);
            mDue = cursor.getDouble(12);
            mLastDue = cursor.getDouble(13);
            mFactor = cursor.getDouble(14);
            mLastFactor = cursor.getDouble(15);
            mFirstAnswered = cursor.getDouble(16);
            mReps = cursor.getInt(17);
            mSuccessive = cursor.getInt(18);
            mAverageTime = cursor.getDouble(19);
            mReviewTime = cursor.getDouble(20);
            mYoungEase0 = cursor.getInt(21);
            mYoungEase1 = cursor.getInt(22);
            mYoungEase2 = cursor.getInt(23);
            mYoungEase3 = cursor.getInt(24);
            mYoungEase4 = cursor.getInt(25);
            mMatureEase0 = cursor.getInt(26);
            mMatureEase1 = cursor.getInt(27);
            mMatureEase2 = cursor.getInt(28);
            mMatureEase3 = cursor.getInt(29);
            mMatureEase4 = cursor.getInt(30);
            mYesCount = cursor.getInt(31);
            mNoCount = cursor.getInt(32);
            mSpaceUntil = cursor.getDouble(33);
            mIsDue = cursor.getInt(34);
            mType = cursor.getInt(35);
            mCombinedDue = cursor.getDouble(36);
            mRelativeDelay = cursor.getDouble(37);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        // TODO: Should also read JOINed entries CardModel and Fact.

        return true;
    }

    // TODO: Remove Redundancies
    // I did a separated method because I don't want to interfere with other code while fact adding is not tested.
    public void addToDb(){
        if (isNew()) {
            mType = TYPE_NEW;
        } else if (isRev()) {
            mType = TYPE_REV;
        } else {
            mType = TYPE_FAILED;
        }

        ContentValues values = new ContentValues();
        values.put(""id"", mId);
        values.put(""factId"", mFactId);
        values.put(""cardModelId"", mCardModelId);
        values.put(""created"", mCreated);
        values.put(""modified"", mModified);
        values.put(""tags"", mTags);
        values.put(""ordinal"", mOrdinal);
        values.put(""question"", mQuestion);
        values.put(""answer"", mAnswer);
        values.put(""priority"", mPriority);
        values.put(""interval"", mInterval);
        values.put(""lastInterval"", mLastInterval);
        values.put(""due"", mDue);
        values.put(""lastDue"", mLastDue);
        values.put(""factor"", mFactor);
        values.put(""lastFactor"", mLastFactor);
        values.put(""firstAnswered"", mFirstAnswered);
        values.put(""reps"", mReps);
        values.put(""successive"", mSuccessive);
        values.put(""averageTime"", mAverageTime);
        values.put(""reviewTime"", mReviewTime);
        values.put(""youngEase0"", mYoungEase0);
        values.put(""youngEase1"", mYoungEase1);
        values.put(""youngEase2"", mYoungEase2);
        values.put(""youngEase3"", mYoungEase3);
        values.put(""youngEase4"", mYoungEase4);
        values.put(""matureEase0"", mMatureEase0);
        values.put(""matureEase1"", mMatureEase1);
        values.put(""matureEase2"", mMatureEase2);
        values.put(""matureEase3"", mMatureEase3);
        values.put(""matureEase4"", mMatureEase4);
        values.put(""yesCount"", mYesCount);
        values.put(""noCount"", mNoCount);
        values.put(""spaceUntil"", mSpaceUntil);
        values.put(""isDue"", mIsDue);
        values.put(""type"", mType);
        values.put(""combinedDue"", Math.max(mSpaceUntil, mDue));
        values.put(""relativeDelay"", 0.0);
        AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).insert(mDeck, ""cards"", null, values);

    }

    public void toDB() {

        ContentValues values = new ContentValues();
        values.put(""factId"", mFactId);
        values.put(""cardModelId"", mCardModelId);
        values.put(""created"", mCreated);
        values.put(""modified"", mModified);
        values.put(""tags"", mTags);
        values.put(""ordinal"", mOrdinal);
        values.put(""question"", mQuestion);
        values.put(""answer"", mAnswer);
        values.put(""priority"", mPriority);
        values.put(""interval"", mInterval);
        values.put(""lastInterval"", mLastInterval);
        values.put(""due"", mDue);
        values.put(""lastDue"", mLastDue);
        values.put(""factor"", mFactor);
        values.put(""lastFactor"", mLastFactor);
        values.put(""firstAnswered"", mFirstAnswered);
        values.put(""reps"", mReps);
        values.put(""successive"", mSuccessive);
        values.put(""averageTime"", mAverageTime);
        values.put(""reviewTime"", mReviewTime);
        values.put(""youngEase0"", mYoungEase0);
        values.put(""youngEase1"", mYoungEase1);
        values.put(""youngEase2"", mYoungEase2);
        values.put(""youngEase3"", mYoungEase3);
        values.put(""youngEase4"", mYoungEase4);
        values.put(""matureEase0"", mMatureEase0);
        values.put(""matureEase1"", mMatureEase1);
        values.put(""matureEase2"", mMatureEase2);
        values.put(""matureEase3"", mMatureEase3);
        values.put(""matureEase4"", mMatureEase4);
        values.put(""yesCount"", mYesCount);
        values.put(""noCount"", mNoCount);
        values.put(""spaceUntil"", mSpaceUntil);
        values.put(""isDue"", 0);
        values.put(""type"", mType);
        values.put(""combinedDue"", mCombinedDue);
        values.put(""relativeDelay"", mRelativeDelay);
        AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).update(mDeck, ""cards"", values, ""id = "" + mId, null, true);

        // TODO: Should also write JOINED entries: CardModel and Fact.
    }


    /**
     * Commit question and answer fields to database.
     */
    public void updateQAfields() {
        setModified();
        ContentValues values = new ContentValues();
        values.put(""modified"", mModified);
        values.put(""question"", mQuestion);
        values.put(""answer"", mAnswer);
        AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).update(mDeck, ""cards"", values, ""id = "" + mId, null);
    }


    public ContentValues getAnswerValues() {
	ContentValues values = new ContentValues();
        values.put(""modified"", mModified);
        values.put(""priority"", mPriority);
        values.put(""interval"", mInterval);
        values.put(""lastInterval"", mLastInterval);
        values.put(""due"", mDue);
        values.put(""lastDue"", mLastDue);
        values.put(""factor"", mFactor);
        values.put(""lastFactor"", mLastFactor);
        values.put(""firstAnswered"", mFirstAnswered);
        values.put(""reps"", mReps);
        values.put(""successive"", mSuccessive);
        values.put(""averageTime"", mAverageTime);
        values.put(""reviewTime"", mReviewTime);
        values.put(""youngEase0"", mYoungEase0);
        values.put(""youngEase1"", mYoungEase1);
        values.put(""youngEase2"", mYoungEase2);
        values.put(""youngEase3"", mYoungEase3);
        values.put(""youngEase4"", mYoungEase4);
        values.put(""matureEase0"", mMatureEase0);
        values.put(""matureEase1"", mMatureEase1);
        values.put(""matureEase2"", mMatureEase2);
        values.put(""matureEase3"", mMatureEase3);
        values.put(""matureEase4"", mMatureEase4);
        values.put(""yesCount"", mYesCount);
        values.put(""noCount"", mNoCount);
        values.put(""type"", mType);
        values.put(""combinedDue"", mCombinedDue);
        values.put(""relativeDelay"", mRelativeDelay);
	return values;
    }


    public long getId() {
        return mId;
    }


    public String getCardDetails(Context context, boolean full) {
    	Resources res = context.getResources();
    	StringBuilder builder = new StringBuilder();
       	builder.append(""<html><body text=\""#FFFFFF\"">"");
       	if (full) {
            builder.append(""<b>"");
            builder.append(res.getString(R.string.card_details_question));
            builder.append(""</b>: "");
            builder.append(Utils.stripHTML(mQuestion));
            builder.append(""<br><b>"");
            builder.append(res.getString(R.string.card_details_answer));
            builder.append(""</b>: "");
            builder.append(Utils.stripHTML(mAnswer));
            builder.append(""<br>"");
       	}
        String[] userTags = mDeck.allUserTags(""WHERE id = "" + mFactId);
        if (userTags != null) {
            String tags = Arrays.toString(userTags);        	
            builder.append(""<b>"");
            builder.append(res.getString(R.string.card_details_tags));
            builder.append(""</b>: "");
            builder.append(tags.substring(1, tags.length() - 1));
            builder.append(""<br><br>"");
        }
        if (full) {
            builder.append(res.getString(R.string.card_details_due));
            builder.append("": "");
            if (mYesCount + mNoCount == 0) {
                builder.append(""-"");
            } else if (mCombinedDue < mDeck.getDueCutoff()) {
                builder.append(""<b>"").append(res.getString(R.string.card_details_now)).append(""</b>"");
            } else {
                builder.append(Utils.fmtTimeSpan(mCombinedDue - Utils.now(), Utils.TIME_FORMAT_IN, true));
            }
            builder.append(""<br>"");        	
        }
        builder.append(res.getString(R.string.card_details_last_due));
        builder.append("": "");
        if (mYesCount + mNoCount == 0 || mLastDue == 0 || mInterval == 0) {
            builder.append(""-"");
        } else {
        	builder.append(Utils.fmtTimeSpan(Utils.now() - mLastDue, Utils.TIME_FORMAT_BEFORE, true));
        }
        builder.append(""<br>"");
        builder.append(res.getString(R.string.card_details_interval));
        builder.append("": "");
        if (mInterval == 0) {
            builder.append(""-"");
        } else {
            builder.append(Utils.fmtTimeSpan(mInterval * 86400, Utils.TIME_FORMAT_DEFAULT, true));
        }
        builder.append(""<br><br>"");
        builder.append(res.getString(R.string.card_details_ease));
        builder.append("": <b>"");
        double ease = Math.round(mFactor * 100);
        builder.append(ease / 100);
        builder.append(""</b><br>"");
        builder.append(res.getString(R.string.card_details_average_time));
        builder.append("": <b>"");
        if (mYesCount + mNoCount == 0) {
            builder.append(""-"");
        } else {
            builder.append(Utils.doubleToTime(mAverageTime));
        }
        builder.append(""</b><br>"");
        builder.append(res.getString(R.string.card_details_total_time));
        builder.append("": <b>"");
        builder.append(Utils.doubleToTime(mReviewTime));
        builder.append(""</b><br><br>"");
        builder.append(res.getString(R.string.card_details_yes_count));
        builder.append("": <b>"");
        builder.append(mYesCount);
        builder.append(""</b><br>"");
        builder.append(res.getString(R.string.card_details_no_count));
        builder.append("": <b>"");
        builder.append(mNoCount);
        builder.append(""</b><br><br>"");
        builder.append(res.getString(R.string.card_details_added));
        builder.append("": <b>"");
        builder.append(DateFormat.getDateFormat(context).format((long) (mCreated - mDeck.getUtcOffset()) * 1000l));
        builder.append(""</b><br>"");
        builder.append(res.getString(R.string.card_details_changed));
        builder.append("": <b>"");
        builder.append(DateFormat.getDateFormat(context).format((long) (mModified - mDeck.getUtcOffset()) * 1000l));
        builder.append(""</b><br><br>"");
        builder.append(res.getString(R.string.card_details_model));
        builder.append("": <b>"");
        Model model = Model.getModel(mDeck, mCardModelId, false);
        builder.append(model.getName());
        builder.append(""</b><br>"");
        builder.append(res.getString(R.string.card_details_card_model));
        builder.append("": <b>"");
        builder.append(model.getCardModel(mCardModelId).getName());
        builder.append(""</b></body></html>"");
    return builder.toString();
    }


    public void setLastInterval(double lastInterval) {
        mLastInterval = lastInterval;
    }


    public double getLastInterval() {
        return mLastInterval;
    }


    public void setInterval(double interval) {
        mInterval = interval;
    }


    public double getInterval() {
        return mInterval;
    }


    public void setLastFactor(double lastFactor) {
        mLastFactor = lastFactor;
    }


    public double getLastFactor() {
        return mLastFactor;
    }


    public double getFactor() {
        return mFactor;
    }


    public int getReps() {
        return mReps;
    }


    public int getYesCount() {
        return mYesCount;
    }


    public int getNoCount() {
        return mNoCount;
    }


    public void setQuestion(String question) {
        mQuestion = question;
    }


    public String getQuestion() {
        return mQuestion;
    }


    public void setAnswer(String answer) {
        mAnswer = answer;
    }


    public String getAnswer() {
        return mAnswer;
    }


    public void setModified(double modified) {
        mModified = modified;
    }


    public void setCombinedDue(double combinedDue) {
        mCombinedDue = combinedDue;
    }


    public double getCombinedDue() {
        return mCombinedDue;
    }


    public void setLastDue(double lastDue) {
        mLastDue = lastDue;
    }


    public void setDue(double due) {
        mDue = due;
    }


    public double getDue() {
        return mDue;
    }


    public void setIsDue(int isDue) {
        mIsDue = isDue;
    }


    /**
     * Check whether the card is due.
     * @return True if the card is due, false otherwise
     */
    public boolean isDue() {
        return (mIsDue == 1);
    }


    public long getFactId() {
        return mFactId;
    }


    public void setSpaceUntil(double spaceUntil) {
        mSpaceUntil = spaceUntil;
    }


    public void setRelativeDelay(double relativeDelay) {
        mRelativeDelay = relativeDelay;
    }


    public void setPriority(int priority) {
        mPriority = priority;
    }


    public int getPriority() {
        return mPriority;
    }


    public int getType() {
        return mType;
    }


    public void setType(int type) {
        mType = type;
    }


    public long getCardModelId() {
        return mCardModelId;
    }


    public double nextInterval(Card card, int ease) {
        return mDeck.nextInterval(card, ease);
    }

    // Leech flag
    public boolean getLeechFlag() {
        return isLeechMarked;
    }
    public void setLeechFlag(boolean flag) {
        isLeechMarked = flag;
    }
    // Suspended flag
    public boolean getSuspendedFlag() {
        return isLeechSuspended;
    }
    public void setSuspendedFlag(boolean flag) {
        isLeechSuspended = flag;
    }

    public int getSuccessive() {
        return mSuccessive;
    }
    
    /**
     * The cardModel defines a field typeAnswer. If it is empty, then no answer should be typed.
     * Otherwise a typed answer should be compared to the value of field related to a cards fact.
     * A field is found based on the factId in the card and the fieldModelId.
     * The fieldModel's id is found by searching with the typeAnswer name and cardModel's modelId
     * 
     * @return 2 dimensional array with answer value at index=0 and fieldModel's class at index=1
     * null if typeAnswer is empty (i.e. do not prompt for answer). Otherwise a string (which can be empty) from the actual field value.
     * The fieldModel's id is correctly hexafied and formatted for class attribute of span for formatting 
     */
    public String[] getComparedFieldAnswer() {
    	String[] returnArray = new String[2];
    	CardModel myCardModel = this.getCardModel();
    	String typeAnswer = myCardModel.getTypeAnswer();
        // Check if we have a valid field to use as the answer to type.
    	if (null == typeAnswer || 0 == typeAnswer.trim().length()) {
		// no field specified, compare with whole answer
    		returnArray[0] = mAnswer;
    		returnArray[1] = """";
                return returnArray;
    	}

        Model myModel = Model.getModel(mDeck, myCardModel.getModelId(), true);
    	TreeMap<Long, FieldModel> fieldModels = myModel.getFieldModels();
    	FieldModel myFieldModel = null;
    	long myFieldModelId = 0l;
    	for (TreeMap.Entry<Long, FieldModel> entry : fieldModels.entrySet()) {
    		myFieldModel = entry.getValue();
    		myFieldModelId = myFieldModel.match(myCardModel.getModelId(), typeAnswer);
    		if (myFieldModelId != 0l) {
    			break;
    		}
    	}

        // Just in case we do not find the matching field model.
        if (myFieldModelId == 0) {
            Log.e(AnkiDroidApp.TAG, ""could not find field model for type answer: "" + typeAnswer);
            returnArray[0] = null;
            return null;
        }

    	returnArray[0] = com.ichi2.anki.Field.fieldValuefromDb(this.mDeck, this.mFactId, myFieldModelId);
    	returnArray[1] = ""fm"" + Long.toHexString(myFieldModelId);
    	return returnArray;
    }
}
",True,53,66,2,2,4,30
44,com.ichi2.anki.AnkiDroidProxy.java,"/***************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.util.Log;

import com.ichi2.async.Connection.Payload;
import com.ichi2.utils.Base64;

import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.zip.InflaterInputStream;

public class AnkiDroidProxy {

    // Sync protocol version
    public static final String SYNC_VERSION = ""2"";

    // The possible values for the status response from the AnkiWeb server.
    private static final String ANKIWEB_STATUS_OK = ""OK"";
    private static final String ANKIWEB_STATUS_INVALID_USER_PASS = ""invalidUserPass"";
    private static final String ANKIWEB_STATUS_OLD_VERSION = ""oldVersion"";
    private static final String ANKIWEB_STATUS_TOO_BUSY =
        ""AnkiWeb is too busy right now. Please try again later."";
    /**
     * Connection settings
     */
    // ankiweb.net hosted at 78.46.104.19
    public static final String SYNC_HOST = ""ankiweb.net"";
    public static final String SYNC_URL = ""http://"" + SYNC_HOST + ""/sync/"";
    public static final String SYNC_SEARCH = ""http://"" + SYNC_HOST + ""/file/search"";

    /**
     * Synchronization.
     */
    public static final int LOGIN_ERROR = -1;
    public static final int LOGIN_OK = 0;
    public static final int LOGIN_INVALID_USER_PASS = 1;
    public static final int LOGIN_CLOCKS_UNSYNCED = 2;
    public static final int SYNC_CONFLICT_RESOLUTION = 3;
    public static final int LOGIN_OLD_VERSION = 4;
    /** The server is too busy to serve the request. */
    public static final int LOGIN_TOO_BUSY = 5;
    public static final int DB_ERROR = 6;

    /**
     * Shared deck's fields
     */
    private static final int SD_ID = 0;
    private static final int SD_USERNAME = 1;
    private static final int SD_TITLE = 2;
    private static final int SD_DESCRIPTION = 3;
    private static final int SD_TAGS = 4;
    private static final int SD_VERSION = 5;
    private static final int SD_FACTS = 6;
    private static final int SD_SIZE = 7;
    private static final int SD_COUNT = 8;
    private static final int SD_MODIFIED = 9;
    private static final int SD_FNAME = 10;

    /**
     * List to hold the shared decks
     */
    private static List<SharedDeck> sSharedDecks;

    private String mUsername;
    private String mPassword;
    private String mDeckName;

    private JSONObject mDecks;
    private double mTimestamp;
    private double mTimediff;


    public AnkiDroidProxy(String user, String password) {
        mUsername = user;
        mPassword = password;
        mDeckName = """";
        mDecks = null;
        mTimediff = 0.0;
    }


    public void setDeckName(String deckName) {
        mDeckName = deckName;
    }


    public double getTimestamp() {
        return mTimestamp;
    }


    public double getTimediff() {
        return mTimediff;
    }


    public int connect(boolean checkClocks) {
        if (mDecks == null) {
            String decksString = getDecks();
            try {
                JSONObject jsonDecks = new JSONObject(decksString);
                String status = jsonDecks.getString(""status"");
                if (ANKIWEB_STATUS_OK.equalsIgnoreCase(status)) {
                    mDecks = jsonDecks.getJSONObject(""decks"");
                    // Log.i(AnkiDroidApp.TAG, ""Server decks = "" + mDecks.toString());
                    mTimestamp = jsonDecks.getDouble(""timestamp"");
                    mTimediff = Math.abs(mTimestamp - Utils.now());
                    // Log.i(AnkiDroidApp.TAG, ""Server timestamp = "" + mTimestamp);
                    if (checkClocks && (mTimediff > 300)) {
                        Log.e(AnkiDroidApp.TAG, ""connect - The clock of the device and that of the server are unsynchronized!"");
                        return LOGIN_CLOCKS_UNSYNCED;
                    }
                    return LOGIN_OK;
                } else if (ANKIWEB_STATUS_INVALID_USER_PASS.equalsIgnoreCase(status)) {
                    return LOGIN_INVALID_USER_PASS;
                } else if (ANKIWEB_STATUS_OLD_VERSION.equalsIgnoreCase(status)) {
                    return LOGIN_OLD_VERSION;
                } else if (ANKIWEB_STATUS_TOO_BUSY.equalsIgnoreCase(status)) {
                    return LOGIN_TOO_BUSY;
                } else {
                    Log.e(AnkiDroidApp.TAG, ""connect - unexpected status: "" + status);
                    return LOGIN_ERROR;
                }
            } catch (JSONException e) {
                Log.e(AnkiDroidApp.TAG, ""connect - JSONException = "" + e.getMessage());
                return LOGIN_ERROR;
            }
        }

        return LOGIN_OK;
    }


    /**
     * Returns true if the server has the given deck.
     * <p>
     * It assumes connect() has already been called and will fail if it was not or the connection
     * was unsuccessful.
     *
     * @param name the name of the deck to look for
     * @return true if the server has the given deck, false otherwise
     */
    public boolean hasDeck(String name) {
        // We assume that gets have already been loading by doing a connect.
        if (mDecks == null) throw new IllegalStateException(""Should have called connect first"");
        @SuppressWarnings(""unchecked"") Iterator<String> decksIterator = (Iterator<String>) mDecks.keys();
        while (decksIterator.hasNext()) {
            String serverDeckName = decksIterator.next();
            if (name.equalsIgnoreCase(serverDeckName)) {
                return true;
            }
        }

        return false;
    }


    public double modified() {
        double lastModified = 0;

        // TODO: Why do we need to run connect?
        if (connect(false) != LOGIN_OK) {
            return -1.0;
        }
        try {
            JSONArray deckInfo = mDecks.getJSONArray(mDeckName);
            lastModified = deckInfo.getDouble(0);
        } catch (JSONException e) {
            Log.e(AnkiDroidApp.TAG, ""modified - JSONException = "" + e.getMessage());
            return -1.0;
        }

        return lastModified;
    }


    public double lastSync() {
        double lastSync = 0;

        // TODO: Why do we need to run connect?
        if (connect(false) != LOGIN_OK) {
            return -1.0;
        }
        try {
            JSONArray deckInfo = mDecks.getJSONArray(mDeckName);
            lastSync = deckInfo.getDouble(1);
        } catch (JSONException e) {
            Log.e(AnkiDroidApp.TAG, ""lastSync - JSONException = "" + e.getMessage());
            return -1.0;
        }
        return lastSync;
    }


    public boolean finish() {
        try {
            String data = ""p="" + URLEncoder.encode(mPassword, ""UTF-8"") + ""&u="" + URLEncoder.encode(mUsername, ""UTF-8"")
                    + ""&v="" + URLEncoder.encode(SYNC_VERSION, ""UTF-8"") + ""&d="" + URLEncoder.encode(mDeckName, ""UTF-8"");
            HttpPost httpPost = new HttpPost(SYNC_URL + ""finish"");
            StringEntity entity = new StringEntity(data);
            httpPost.setEntity(entity);
            httpPost.setHeader(""Accept-Encoding"", ""identity"");
            httpPost.setHeader(""Content-type"", ""application/x-www-form-urlencoded"");
            DefaultHttpClient httpClient = new DefaultHttpClient();
            HttpResponse response = httpClient.execute(httpPost);
            HttpEntity entityResponse = response.getEntity();
            int respCode = response.getStatusLine().getStatusCode();
            if (respCode != 200) {
                Log.e(AnkiDroidApp.TAG, ""AnkiDroidProxy.finish error: "" + respCode + "" "" +
                        response.getStatusLine().getReasonPhrase());
                return false;
            }
            InputStream content = entityResponse.getContent();
            String contentString = Utils.convertStreamToString(new InflaterInputStream(content));
            // Log.i(AnkiDroidApp.TAG, ""finish: "" + contentString);
            return true;
        } catch (UnsupportedEncodingException e) {
            Log.e(AnkiDroidApp.TAG, ""UnsupportedEncodingException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            return false;
        } catch (ClientProtocolException e) {
            Log.e(AnkiDroidApp.TAG, ""ClientProtocolException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            return false;
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, ""IOException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            return false;
        }
    }


    public String getDecks() {
        String decksServer = ""{}"";

        try {
            String data = ""p="" + URLEncoder.encode(mPassword, ""UTF-8"") + ""&client=""
                    + URLEncoder.encode(""ankidroid-"" + AnkiDroidApp.getPkgVersion(), ""UTF-8"") + ""&u=""
                    + URLEncoder.encode(mUsername, ""UTF-8"") + ""&v="" + URLEncoder.encode(SYNC_VERSION, ""UTF-8"")
                    + ""&d=None&sources="" + URLEncoder.encode(""[]"", ""UTF-8"") + ""&libanki=""
                    + URLEncoder.encode(AnkiDroidApp.LIBANKI_VERSION, ""UTF-8"") + ""&pversion=5"";

            // // Log.i(AnkiDroidApp.TAG, ""Data json = "" + data);
            HttpPost httpPost = new HttpPost(SYNC_URL + ""getDecks"");
            StringEntity entity = new StringEntity(data);
            httpPost.setEntity(entity);
            httpPost.setHeader(""Accept-Encoding"", ""identity"");
            httpPost.setHeader(""Content-type"", ""application/x-www-form-urlencoded"");
            DefaultHttpClient httpClient = new DefaultHttpClient();
            HttpResponse response = httpClient.execute(httpPost);
            int respCode = response.getStatusLine().getStatusCode();
            if (respCode != 200) {
                Log.e(AnkiDroidApp.TAG, ""getDecks error: "" + respCode + "" "" +
                        response.getStatusLine().getReasonPhrase());
                return decksServer;
            }
            HttpEntity entityResponse = response.getEntity();
            InputStream content = entityResponse.getContent();
            decksServer = Utils.convertStreamToString(new InflaterInputStream(content));
            // Log.i(AnkiDroidApp.TAG, ""getDecks response = "" + decksServer);

        } catch (UnsupportedEncodingException e) {
            Log.e(AnkiDroidApp.TAG, ""getDecks - UnsupportedEncodingException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, ""getDecks - "" + Log.getStackTraceString(e));
        } catch (ClientProtocolException e) {
            Log.e(AnkiDroidApp.TAG, ""getDecks - ClientProtocolException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, ""getDecks - "" + Log.getStackTraceString(e));
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, ""getDecks - IOException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, ""getDecks - "" + Log.getStackTraceString(e));
        }

        return decksServer;
    }


    public List<String> getPersonalDecks() {
        ArrayList<String> personalDecks = new ArrayList<String>();
        @SuppressWarnings(""unchecked"") Iterator<String> decksIterator = (Iterator<String>) mDecks.keys();
        while (decksIterator.hasNext()) {
            personalDecks.add((String) decksIterator.next());
        }

        return personalDecks;
    }


    public Payload createDeck(String name) {
        // Log.i(AnkiDroidApp.TAG, ""createDeck"");
        
        Payload result = new Payload();

        try {
            String data = ""p="" + URLEncoder.encode(mPassword, ""UTF-8"") + ""&u="" + URLEncoder.encode(mUsername, ""UTF-8"")
                    + ""&v="" + URLEncoder.encode(SYNC_VERSION, ""UTF-8"") + ""&d=None&name=""
                    + URLEncoder.encode(name, ""UTF-8"");

            HttpPost httpPost = new HttpPost(SYNC_URL + ""createDeck"");
            StringEntity entity = new StringEntity(data);
            httpPost.setEntity(entity);
            httpPost.setHeader(""Accept-Encoding"", ""identity"");
            httpPost.setHeader(""Content-type"", ""application/x-www-form-urlencoded"");
            DefaultHttpClient httpClient = new DefaultHttpClient();
            HttpResponse response = httpClient.execute(httpPost);
            int respCode = response.getStatusLine().getStatusCode();
            HttpEntity entityResponse = response.getEntity();
            InputStream content = entityResponse.getContent();
            if (respCode != 200) {
                String reason = response.getStatusLine().getReasonPhrase();
                // Log.i(AnkiDroidApp.TAG, ""Failed to create Deck: "" + respCode + "" "" + reason);
                result.success = false;
                result.returnType = respCode;
                result.result = reason;
                return result;
            } else {
                // Log.i(AnkiDroidApp.TAG, ""createDeck - response = "" + Utils.convertStreamToString(new InflaterInputStream(content)));
                result.success = true;
                result.returnType = 200;
                // Add created deck to the list of decks on server
                mDecks.put(name, new JSONArray(""[0,0]""));
                return result;
            }
        } catch (UnsupportedEncodingException e) {
            Log.e(AnkiDroidApp.TAG, ""createDeck - UnsupportedEncodingException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.result = e.getMessage();
        } catch (ClientProtocolException e) {
            Log.e(AnkiDroidApp.TAG, ""createDeck - ClientProtocolException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.result = e.getMessage();
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, ""createDeck - IOException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.result = e.getMessage();
        } catch (JSONException e) {
            Log.e(AnkiDroidApp.TAG, ""createDeck - JSONException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            result.result = e.getMessage();
        }
        result.success = false;
        result.returnType = -1;
        return result;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, HttpSyncServerProxy - summary
     * 
     * @param lastSync
     */
    public JSONObject summary(double lastSync) {

        // Log.i(AnkiDroidApp.TAG, ""Summary Server"");

        JSONObject summaryServer = new JSONObject();

        try {
            String data = ""p="" + URLEncoder.encode(mPassword, ""UTF-8"")
                    + ""&u="" + URLEncoder.encode(mUsername, ""UTF-8"")
                    + ""&d="" + URLEncoder.encode(mDeckName, ""UTF-8"")
                    + ""&v="" + URLEncoder.encode(SYNC_VERSION, ""UTF-8"")
                    + ""&lastSync=""
                    + URLEncoder.encode(Base64.encodeBytes(Utils.compress(String.format(Utils.ENGLISH_LOCALE, ""%f"",
                            lastSync).getBytes())), ""UTF-8"") + ""&base64="" + URLEncoder.encode(""true"", ""UTF-8"");

            // // Log.i(AnkiDroidApp.TAG, ""Data json = "" + data);
            HttpPost httpPost = new HttpPost(SYNC_URL + ""summary"");
            StringEntity entity = new StringEntity(data);
            httpPost.setEntity(entity);
            httpPost.setHeader(""Accept-Encoding"", ""identity"");
            httpPost.setHeader(""Content-type"", ""application/x-www-form-urlencoded"");
            DefaultHttpClient httpClient = new DefaultHttpClient();
            HttpResponse response = httpClient.execute(httpPost);
            int respCode = response.getStatusLine().getStatusCode();
            if (respCode != 200) {
                Log.e(AnkiDroidApp.TAG, ""Error getting server summary: "" + respCode + "" "" + response.getStatusLine().getReasonPhrase());
                return null;
            }
            HttpEntity entityResponse = response.getEntity();
            InputStream content = entityResponse.getContent();
            summaryServer = new JSONObject(Utils.convertStreamToString(new InflaterInputStream(content)));
            // Log.i(AnkiDroidApp.TAG, ""Summary server = "");
            Utils.printJSONObject(summaryServer);
            return summaryServer;
        } catch (UnsupportedEncodingException e) {
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        } catch (ClientProtocolException e) {
            Log.e(AnkiDroidApp.TAG, ""ClientProtocolException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, ""IOException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        } catch (JSONException e) {
            Log.e(AnkiDroidApp.TAG, ""JSONException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        } catch (OutOfMemoryError e) {
            Log.e(AnkiDroidApp.TAG, ""OutOfMemoryError = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        }
        return null;
    }


    /**
     * Anki Desktop -> libanki/anki/sync.py, HttpSyncServerProxy - applyPayload
     * 
     * @param payload
     * @throws JSONException 
     */
    public JSONObject applyPayload(JSONObject payload) throws JSONException {
        // Log.i(AnkiDroidApp.TAG, ""applyPayload"");
        JSONObject payloadReply = new JSONObject();

        try {
            // FIXME: Try to do the connection without encoding the payload in Base 64
            String data = ""p="" + URLEncoder.encode(mPassword, ""UTF-8"") + ""&u="" + URLEncoder.encode(mUsername, ""UTF-8"")
                    + ""&v="" + URLEncoder.encode(SYNC_VERSION, ""UTF-8"") + ""&d="" + URLEncoder.encode(mDeckName, ""UTF-8"")
                    + ""&payload=""
                    + URLEncoder.encode(Base64.encodeBytes(Utils.compress(payload.toString().getBytes())), ""UTF-8"")
                    + ""&base64="" + URLEncoder.encode(""true"", ""UTF-8"");

            // // Log.i(AnkiDroidApp.TAG, ""Data json = "" + data);
            HttpPost httpPost = new HttpPost(SYNC_URL + ""applyPayload"");
            StringEntity entity = new StringEntity(data);
            httpPost.setEntity(entity);
            httpPost.setHeader(""Accept-Encoding"", ""identity"");
            httpPost.setHeader(""Content-type"", ""application/x-www-form-urlencoded"");
            DefaultHttpClient httpClient = new DefaultHttpClient();
            HttpResponse response = httpClient.execute(httpPost);
            int respCode = response.getStatusLine().getStatusCode();
            if (respCode != 200) {
                Log.e(AnkiDroidApp.TAG, ""applyPayload error: "" + respCode + "" "" +
                        response.getStatusLine().getReasonPhrase());
                return null;
            }
            HttpEntity entityResponse = response.getEntity();
            InputStream content = entityResponse.getContent();
            String contentString = Utils.convertStreamToString(new InflaterInputStream(content));
            // Log.i(AnkiDroidApp.TAG, ""Payload response = "");
            payloadReply = new JSONObject(contentString);
            Utils.printJSONObject(payloadReply, false);
            //Utils.saveJSONObject(payloadReply); //XXX: do we really want to append all JSON objects forever? I don't think so.
        } catch (UnsupportedEncodingException e) {
            Log.e(AnkiDroidApp.TAG, ""UnsupportedEncodingException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            return null;
        } catch (ClientProtocolException e) {
            Log.e(AnkiDroidApp.TAG, ""ClientProtocolException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            return null;
        } catch (IOException e) {
            Log.e(AnkiDroidApp.TAG, ""IOException = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            return null;
        }

        return payloadReply;
    }


    /**
     * Get shared decks.
     */
    public static List<SharedDeck> getSharedDecks() throws Exception {

        try {
            if (sSharedDecks == null) {
                sSharedDecks = new ArrayList<SharedDeck>();

                HttpGet httpGet = new HttpGet(SYNC_SEARCH);
                httpGet.setHeader(""Accept-Encoding"", ""identity"");
                httpGet.setHeader(""Host"", SYNC_HOST);
                DefaultHttpClient defaultHttpClient = new DefaultHttpClient();

                HttpResponse httpResponse = defaultHttpClient.execute(httpGet);
                String response = Utils.convertStreamToString(httpResponse.getEntity().getContent());
                // // Log.i(AnkiDroidApp.TAG, ""Content = "" + response);
                sSharedDecks.addAll(getSharedDecksListFromJSONArray(new JSONArray(response)));
            }
        } catch (Exception e) {
            sSharedDecks = null;
            throw new Exception();
        }

        return sSharedDecks;
    }


    public static void resetSharedDecks() {
    	sSharedDecks = null;
    }


    private static List<SharedDeck> getSharedDecksListFromJSONArray(JSONArray jsonSharedDecks) throws JSONException {
        List<SharedDeck> sharedDecks = new ArrayList<SharedDeck>();

        if (jsonSharedDecks != null) {
            // // Log.i(AnkiDroidApp.TAG, ""Number of shared decks = "" + jsonSharedDecks.length());

            int nbDecks = jsonSharedDecks.length();
            for (int i = 0; i < nbDecks; i++) {
                JSONArray jsonSharedDeck = jsonSharedDecks.getJSONArray(i);

                SharedDeck sharedDeck = new SharedDeck();
                sharedDeck.setId(jsonSharedDeck.getInt(SD_ID));
                sharedDeck.setUsername(jsonSharedDeck.getString(SD_USERNAME));
                sharedDeck.setTitle(jsonSharedDeck.getString(SD_TITLE));
                sharedDeck.setDescription(jsonSharedDeck.getString(SD_DESCRIPTION));
                sharedDeck.setTags(jsonSharedDeck.getString(SD_TAGS));
                sharedDeck.setVersion(jsonSharedDeck.getInt(SD_VERSION));
                sharedDeck.setFacts(jsonSharedDeck.getInt(SD_FACTS));
                sharedDeck.setSize(jsonSharedDeck.getInt(SD_SIZE));
                sharedDeck.setCount(jsonSharedDeck.getInt(SD_COUNT));
                sharedDeck.setModified(jsonSharedDeck.getDouble(SD_MODIFIED));
                sharedDeck.setFileName(jsonSharedDeck.getString(SD_FNAME));

                // sharedDeck.prettyLog();

                sharedDecks.add(sharedDeck);
            }
        }

        return sharedDecks;
    }

}
",True,92,67,2,2,5,34
45,com.ichi2.anki.Stats.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.database.Cursor;
import android.util.Log;

import org.json.JSONException;
import org.json.JSONObject;

import java.lang.reflect.Field;
import java.sql.Date;

/**
 * Deck statistics.
 */
public class Stats {

    public static final int STATS_LIFE = 0;
    public static final int STATS_DAY = 1;
    
    // BEGIN: SQL table columns
    private long mId;
    private int mType;
    private Date mDay;
    private int mReps;
    private double mAverageTime;
    private double mReviewTime;
    // Next two columns no longer used
    private double mDistractedTime;
    private int mDistractedReps;
    private int mNewEase0;
    private int mNewEase1;
    private int mNewEase2;
    private int mNewEase3;
    private int mNewEase4;
    private int mYoungEase0;
    private int mYoungEase1;
    private int mYoungEase2;
    private int mYoungEase3;
    private int mYoungEase4;
    private int mMatureEase0;
    private int mMatureEase1;
    private int mMatureEase2;
    private int mMatureEase3;
    private int mMatureEase4;
    // END: SQL table columns

    private Deck mDeck;


    public Stats(Deck deck) {
        mDeck = deck;
        mDay = null;
        mReps = 0;
        mAverageTime = 0;
        mReviewTime = 0;
        mDistractedTime = 0;
        mDistractedReps = 0;
        mNewEase0 = 0;
        mNewEase1 = 0;
        mNewEase2 = 0;
        mNewEase3 = 0;
        mNewEase4 = 0;
        mYoungEase0 = 0;
        mYoungEase1 = 0;
        mYoungEase2 = 0;
        mYoungEase3 = 0;
        mMatureEase0 = 0;
        mMatureEase1 = 0;
        mMatureEase2 = 0;
        mMatureEase3 = 0;
        mMatureEase4 = 0;
    }


    public void fromDB(long id) {
        Cursor cursor = null;

        try {
            // Log.i(AnkiDroidApp.TAG, ""Reading stats from DB..."");
            cursor = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).getDatabase().rawQuery(
                    ""SELECT * "" + ""FROM stats WHERE id = "" + String.valueOf(id), null);

            if (!cursor.moveToFirst()) {
                return;
            }

            mId = cursor.getLong(0);
            mType = cursor.getInt(1);
            mDay = Date.valueOf(cursor.getString(2));
            mReps = cursor.getInt(3);
            mAverageTime = cursor.getDouble(4);
            mReviewTime = cursor.getDouble(5);
            mDistractedTime = cursor.getDouble(6);
            mDistractedReps = cursor.getInt(7);
            mNewEase0 = cursor.getInt(8);
            mNewEase1 = cursor.getInt(9);
            mNewEase2 = cursor.getInt(10);
            mNewEase3 = cursor.getInt(11);
            mNewEase4 = cursor.getInt(12);
            mYoungEase0 = cursor.getInt(13);
            mYoungEase1 = cursor.getInt(14);
            mYoungEase2 = cursor.getInt(15);
            mYoungEase3 = cursor.getInt(16);
            mYoungEase4 = cursor.getInt(17);
            mMatureEase0 = cursor.getInt(18);
            mMatureEase1 = cursor.getInt(19);
            mMatureEase2 = cursor.getInt(20);
            mMatureEase3 = cursor.getInt(21);
            mMatureEase4 = cursor.getInt(22);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }


    public void create(int type, Date day) {
        // Log.i(AnkiDroidApp.TAG, ""Creating new stats for "" + day.toString() + ""..."");
        mType = type;
        mDay = day;

        ContentValues values = new ContentValues();
        values.put(""type"", type);
        values.put(""day"", day.toString());
        values.put(""reps"", 0);
        values.put(""averageTime"", 0);
        values.put(""reviewTime"", 0);
        values.put(""distractedTime"", 0);
        values.put(""distractedReps"", 0);
        values.put(""newEase0"", 0);
        values.put(""newEase1"", 0);
        values.put(""newEase2"", 0);
        values.put(""newEase3"", 0);
        values.put(""newEase4"", 0);
        values.put(""youngEase0"", 0);
        values.put(""youngEase1"", 0);
        values.put(""youngEase2"", 0);
        values.put(""youngEase3"", 0);
        values.put(""youngEase4"", 0);
        values.put(""matureEase0"", 0);
        values.put(""matureEase1"", 0);
        values.put(""matureEase2"", 0);
        values.put(""matureEase3"", 0);
        values.put(""matureEase4"", 0);
        mId = AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).insert(mDeck, ""stats"", null, values);
    }


    public void toDB() {
        AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).update(mDeck, ""stats"", getValues(), ""id = "" + mId, null);
    }


    public void toDB(ContentValues oldValues) {
        AnkiDatabaseManager.getDatabase(mDeck.getDeckPath()).update(mDeck, ""stats"", getValues(), ""id = "" + mId, null, true, new ContentValues[] {oldValues}, new String[] {""id = "" + mId});
    }


    private ContentValues getValues() {
        ContentValues values = new ContentValues();
        values.put(""type"", mType);
        values.put(""day"", mDay.toString());
        values.put(""reps"", mReps);
        values.put(""averageTime"", mAverageTime);
        values.put(""reviewTime"", mReviewTime);
        values.put(""newEase0"", mNewEase0);
        values.put(""newEase1"", mNewEase1);
        values.put(""newEase2"", mNewEase2);
        values.put(""newEase3"", mNewEase3);
        values.put(""newEase4"", mNewEase4);
        values.put(""youngEase0"", mYoungEase0);
        values.put(""youngEase1"", mYoungEase1);
        values.put(""youngEase2"", mYoungEase2);
        values.put(""youngEase3"", mYoungEase3);
        values.put(""youngEase4"", mYoungEase4);
        values.put(""matureEase0"", mMatureEase0);
        values.put(""matureEase1"", mMatureEase1);
        values.put(""matureEase2"", mMatureEase2);
        values.put(""matureEase3"", mMatureEase3);
        values.put(""matureEase4"", mMatureEase4);
	return values;
    }


    public static void updateAllStats(Stats global, Stats daily, Card card, int ease, String oldState) {
        updateStats(global, card, ease, oldState);
        updateStats(daily, card, ease, oldState);
    }


    public static void updateStats(Stats stats, Card card, int ease, String oldState) {
    	ContentValues oldValues = stats.getValues();
        char[] newState = oldState.toCharArray();
        stats.mReps += 1;
        double delay = card.totalTime();
        if (delay >= 60) {
            stats.mReviewTime += 60;
        } else {
            stats.mReviewTime += delay;
            stats.mAverageTime = (stats.mReviewTime / stats.mReps);
        }
        // update eases
        // We want attr to be of the form mYoungEase3
        newState[0] = Character.toUpperCase(newState[0]);
        StringBuilder attr = new StringBuilder();
		attr.append(""m"").append(String.valueOf(newState)).append(String.format(""Ease%d"", ease));
        try {
            Field f = stats.getClass().getDeclaredField(attr.toString());
            f.setInt(stats, f.getInt(stats) + 1);
        } catch (Exception e) {
            Log.e(AnkiDroidApp.TAG, ""Failed to update "" + attr.toString() + "" : "" + e.getMessage());
        }
        stats.toDB(oldValues);
    }


    public JSONObject bundleJson() {
        JSONObject bundledStat = new JSONObject();

        try {
            bundledStat.put(""type"", mType);
            bundledStat.put(""day"", Utils.dateToOrdinal(mDay));
            bundledStat.put(""reps"", mReps);
            bundledStat.put(""averageTime"", mAverageTime);
            bundledStat.put(""reviewTime"", mReviewTime);
            bundledStat.put(""distractedTime"", mDistractedTime);
            bundledStat.put(""distractedReps"", mDistractedReps);
            bundledStat.put(""newEase0"", mNewEase0);
            bundledStat.put(""newEase1"", mNewEase1);
            bundledStat.put(""newEase2"", mNewEase2);
            bundledStat.put(""newEase3"", mNewEase3);
            bundledStat.put(""newEase4"", mNewEase4);
            bundledStat.put(""youngEase0"", mYoungEase0);
            bundledStat.put(""youngEase1"", mYoungEase1);
            bundledStat.put(""youngEase2"", mYoungEase2);
            bundledStat.put(""youngEase3"", mYoungEase3);
            bundledStat.put(""youngEase4"", mYoungEase4);
            bundledStat.put(""matureEase0"", mMatureEase0);
            bundledStat.put(""matureEase1"", mMatureEase1);
            bundledStat.put(""matureEase2"", mMatureEase2);
            bundledStat.put(""matureEase3"", mMatureEase3);
            bundledStat.put(""matureEase4"", mMatureEase4);

        } catch (JSONException e) {
            // Log.i(AnkiDroidApp.TAG, ""JSONException = "" + e.getMessage());
        }

        return bundledStat;
    }


    public void updateFromJson(JSONObject remoteStat) {
        try {
            mAverageTime = remoteStat.getDouble(""averageTime"");
            mDay = Utils.ordinalToDate(remoteStat.getInt(""day""));
            mDistractedReps = remoteStat.getInt(""distractedReps"");
            mDistractedTime = remoteStat.getDouble(""distractedTime"");
            mMatureEase0 = remoteStat.getInt(""matureEase0"");
            mMatureEase1 = remoteStat.getInt(""matureEase1"");
            mMatureEase2 = remoteStat.getInt(""matureEase2"");
            mMatureEase3 = remoteStat.getInt(""matureEase3"");
            mMatureEase4 = remoteStat.getInt(""matureEase4"");
            mNewEase0 = remoteStat.getInt(""newEase0"");
            mNewEase1 = remoteStat.getInt(""newEase1"");
            mNewEase2 = remoteStat.getInt(""newEase2"");
            mNewEase3 = remoteStat.getInt(""newEase3"");
            mNewEase4 = remoteStat.getInt(""newEase4"");
            mReps = remoteStat.getInt(""reps"");
            mReviewTime = remoteStat.getDouble(""reviewTime"");
            mType = remoteStat.getInt(""type"");
            mYoungEase0 = remoteStat.getInt(""youngEase0"");
            mYoungEase1 = remoteStat.getInt(""youngEase1"");
            mYoungEase2 = remoteStat.getInt(""youngEase2"");
            mYoungEase3 = remoteStat.getInt(""youngEase3"");
            mYoungEase4 = remoteStat.getInt(""youngEase4"");

            toDB();
        } catch (JSONException e) {
            // Log.i(AnkiDroidApp.TAG, ""JSONException = "" + e.getMessage());
        }
    }


    public static Stats globalStats(Deck deck) {
        // Log.i(AnkiDroidApp.TAG, ""Getting global stats..."");
        int type = STATS_LIFE;
        Date today = Utils.genToday(deck.getUtcOffset());
        Cursor cursor = null;
        Stats stats = null;

        try {
            cursor = AnkiDatabaseManager.getDatabase(deck.getDeckPath()).getDatabase().rawQuery(
                    ""SELECT id "" + ""FROM stats WHERE type = "" + String.valueOf(type), null);

            if (cursor.moveToFirst()) {
                stats = new Stats(deck);
                stats.fromDB(cursor.getLong(0));
                return stats;
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        stats = new Stats(deck);
        stats.create(type, today);
        stats.mType = type;
        return stats;
    }


    public static Stats dailyStats(Deck deck) {
        // Log.i(AnkiDroidApp.TAG, ""Getting daily stats..."");
        int type = STATS_DAY;
        Date today = Utils.genToday(deck.getUtcOffset());
        Stats stats = null;
        Cursor cursor = null;

        try {
            // Log.i(AnkiDroidApp.TAG, ""Trying to get stats for "" + today.toString());
            cursor = AnkiDatabaseManager.getDatabase(deck.getDeckPath()).getDatabase().rawQuery(
                    ""SELECT id "" + ""FROM stats ""
                    + ""WHERE type = "" + String.valueOf(type) + "" and day = \"""" + today.toString() + ""\"""", null);

            if (cursor.moveToFirst()) {
                stats = new Stats(deck);
                stats.fromDB(cursor.getLong(0));
                return stats;
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        stats = new Stats(deck);
        stats.create(type, today);
        stats.mType = type;
        return stats;
    }

    
    /**
     * @return the reps
     */
    public int getReps() {
        return mReps;
    }


    /**
     * @return the reps
     */
    public int getYesReps() {
        return mReps - mNewEase0 - mNewEase1 - mMatureEase0 - mMatureEase1 - mYoungEase0 - mYoungEase1;
    }


    /**
     * @return the average time
     */
    public double getAverageTime() {
        return mAverageTime;
    }


    /**
     * @return the day
     */
    public Date getDay() {
        return mDay;
    }


    /**
     * @return the share of no answers on young cards
     */
    public double getYesShare() {
    	if (mReps != 0) {
        	return 1 - (((double)(mNewEase0 + mNewEase1 + mYoungEase0 + mYoungEase1 + mMatureEase0 + mMatureEase1)) / (double)mReps);
    	} else {
        	return 0;
    	}
    }


    /**
     * @return the share of no answers on young cards
     */
    public double getMatureYesShare() {
    	double matureNo = mMatureEase0 + mMatureEase1;
    	double matureTotal = matureNo + mMatureEase2 + mMatureEase3 + mMatureEase4;
    	if (matureTotal != 0) {
        	return 1 - (matureNo / matureTotal);
    	} else {
        	return 0;
    	}
    }


    /**
     * @return the share of no answers on mature cards
     */
    public double getYoungNoShare() {
	double youngNo = mYoungEase0 + mYoungEase1;
	double youngTotal = youngNo + mYoungEase2 + mYoungEase3 + mYoungEase4;
    	if (youngTotal != 0) {
        	return youngNo / youngTotal;
    	} else {
        	return 0;
    	}
    }


    /**
     * @return the total number of cards marked as new
     */
    public int getNewCardsCount() {
        return mNewEase0 + mNewEase1 + mNewEase2 + mNewEase3 + mNewEase4;
    }
}
",True,55,63,0,0,5,23
46,com.ichi2.anki.DeckPreferences.java,"/****************************************************************************************
 * Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.os.Bundle;
import android.preference.CheckBoxPreference;
import android.preference.Preference;
import android.preference.PreferenceActivity;
import android.util.Log;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

/**
 * Preferences for the current deck.
 */
public class DeckPreferences extends PreferenceActivity implements OnSharedPreferenceChangeListener {

    public class DeckPreferenceHack implements SharedPreferences {

        private Map<String, String> mValues = new HashMap<String, String>();


        public DeckPreferenceHack() {
            this.cacheValues();
        }


        protected void cacheValues() {
            // Log.i(AnkiDroidApp.TAG, ""DeckPreferences - CacheValues"");
            mValues.put(""newCardsPDay"", String.valueOf(AnkiDroidApp.deck().getNewCardsPerDay()));
            mValues.put(""sessionQLimit"", String.valueOf(AnkiDroidApp.deck().getSessionRepLimit()));
            mValues.put(""sessionTLimit"", String.valueOf(AnkiDroidApp.deck().getSessionTimeLimit() / 60));
            mValues.put(""newCardOrder"", String.valueOf(AnkiDroidApp.deck().getNewCardOrder()));
            mValues.put(""newCardSpacing"", String.valueOf(AnkiDroidApp.deck().getNewCardSpacing()));
            mValues.put(""revCardOrder"", String.valueOf(AnkiDroidApp.deck().getRevCardOrder()));
        }

        public class Editor implements SharedPreferences.Editor {

            private ContentValues mUpdate = new ContentValues();


            @Override
            public SharedPreferences.Editor clear() {
                // Log.d(AnkiDroidApp.TAG, ""clear()"");
                mUpdate = new ContentValues();
                return this;
            }


            @Override
            public boolean commit() {
                // Log.d(AnkiDroidApp.TAG, ""DeckPreferences - commit() changes back to database"");

                // make sure we refresh the parent cached values
                // cacheValues();

                for (Entry<String, Object> entry : mUpdate.valueSet()) {
                    if (entry.getKey().equals(""newCardsPDay"")) {
                        AnkiDroidApp.deck().setNewCardsPerDay(Integer.parseInt(entry.getValue().toString()));
                    } else if (entry.getKey().equals(""sessionQLimit"")) {
                        AnkiDroidApp.deck().setSessionRepLimit(Long.parseLong(entry.getValue().toString()));
                    } else if (entry.getKey().equals(""sessionTLimit"")) {
                        AnkiDroidApp.deck().setSessionTimeLimit(60 * Long.parseLong(entry.getValue().toString()));
                    } else if (entry.getKey().equals(""newCardOrder"")) {
                        AnkiDroidApp.deck().setNewCardOrder(Integer.parseInt(entry.getValue().toString()));
                    } else if (entry.getKey().equals(""newCardSpacing"")) {
                        AnkiDroidApp.deck().setNewCardSpacing(Integer.parseInt(entry.getValue().toString()));
                    } else if (entry.getKey().equals(""revCardOrder"")) {
                        AnkiDroidApp.deck().setRevCardOrder(Integer.parseInt(entry.getValue().toString()));
                    }
                }
                // make sure we refresh the parent cached values
                cacheValues();

                // and update any listeners
                for (OnSharedPreferenceChangeListener listener : listeners) {
                    listener.onSharedPreferenceChanged(DeckPreferenceHack.this, null);
                }

                return true;
            }


            @Override
            public SharedPreferences.Editor putBoolean(String key, boolean value) {
                return this.putString(key, Boolean.toString(value));
            }


            @Override
            public SharedPreferences.Editor putFloat(String key, float value) {
                return this.putString(key, Float.toString(value));
            }


            @Override
            public SharedPreferences.Editor putInt(String key, int value) {
                return this.putString(key, Integer.toString(value));
            }


            @Override
            public SharedPreferences.Editor putLong(String key, long value) {
                return this.putString(key, Long.toString(value));
            }


            @Override
            public SharedPreferences.Editor putString(String key, String value) {
                // Log.d(this.getClass().toString(), String.format(""Editor.putString(key=%s, value=%s)"", key, value));
                mUpdate.put(key, value);
                return this;
            }


            @Override
            public SharedPreferences.Editor remove(String key) {
                // Log.d(this.getClass().toString(), String.format(""Editor.remove(key=%s)"", key));
                mUpdate.remove(key);
                return this;
            }


            public void apply() {
                commit();
            }


			// @Override  On Android 1.5 this is not Override
			public android.content.SharedPreferences.Editor putStringSet(
					String arg0, Set<String> arg1) {
				// TODO Auto-generated method stub
				return null;
			}

        }


        @Override
        public boolean contains(String key) {
            return mValues.containsKey(key);
        }


        @Override
        public Editor edit() {
            return new Editor();
        }


        @Override
        public Map<String, ?> getAll() {
            return mValues;
        }


        @Override
        public boolean getBoolean(String key, boolean defValue) {
            return Boolean.valueOf(this.getString(key, Boolean.toString(defValue)));
        }


        @Override
        public float getFloat(String key, float defValue) {
            return Float.valueOf(this.getString(key, Float.toString(defValue)));
        }


        @Override
        public int getInt(String key, int defValue) {
            return Integer.valueOf(this.getString(key, Integer.toString(defValue)));
        }


        @Override
        public long getLong(String key, long defValue) {
            return Long.valueOf(this.getString(key, Long.toString(defValue)));
        }


        @Override
        public String getString(String key, String defValue) {
            // Log.d(this.getClass().toString(), String.format(""getString(key=%s, defValue=%s)"", key, defValue));

            if (!mValues.containsKey(key)) {
                return defValue;
            }
            return mValues.get(key);
        }

        public List<OnSharedPreferenceChangeListener> listeners = new LinkedList<OnSharedPreferenceChangeListener>();


        @Override
        public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
            listeners.add(listener);
        }


        @Override
        public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener listener) {
            listeners.remove(listener);
        }


		// @Override  On Android 1.5 this is not Override
		public Set<String> getStringSet(String arg0, Set<String> arg1) {
			// TODO Auto-generated method stub
			return null;
		}

    }

    private DeckPreferenceHack mPref;


    @Override
    public SharedPreferences getSharedPreferences(String name, int mode) {
        // Log.d(this.getClass().toString(), String.format(""getSharedPreferences(name=%s)"", name));
        return mPref;
    }


    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        if (AnkiDroidApp.deck() == null) {
            // Log.i(AnkiDroidApp.TAG, ""DeckPreferences - Selected Deck is NULL"");
            finish();
        } else {
            // requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

            mPref = new DeckPreferenceHack();
            mPref.registerOnSharedPreferenceChangeListener(this);

            this.addPreferencesFromResource(R.xml.deck_preferences);
            // this.updateSummaries();
        }
    }


    @Override
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
        // update values on changed preference
        // this.updateSummaries();
    }


    /**
     * XXX Currently unused.
     */
    protected void updateSummaries() {
        // for all text preferences, set summary as current database value
        for (String key : mPref.mValues.keySet()) {
            Preference pref = this.findPreference(key);
            if (pref == null) {
                continue;
            }
            if (pref instanceof CheckBoxPreference) {
                continue;
            }
            pref.setSummary(this.mPref.getString(key, """"));
        }
    }
}
",False,23,64,0,0,5,28
47,com.ichi2.anki.CardEditor.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.content.DialogInterface.OnDismissListener;
import android.content.res.Resources;
import android.os.Bundle;
import android.text.Editable;
import android.text.InputFilter;
import android.text.Spanned;
import android.text.method.KeyListener;
import android.text.style.StrikethroughSpan;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anim.ViewAnimation;
import com.ichi2.anki.DeckPicker.AnkiFilter;
import com.ichi2.anki.Fact.Field;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;

import org.amr.arabic.ArabicUtilities;

/**
 * Allows the user to edit a fact, for instance if there is a typo.
 * 
 * A card is a presentation of a fact, and has two sides: a question and an
 * answer. Any number of fields can appear on each side. When you add a fact to
 * Anki, cards which show that fact are generated. Some models generate one
 * card, others generate more than one.
 * 
 * @see http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Cards
 */
public class CardEditor extends Activity {

	public static final String SOURCE_LANGUAGE = ""SOURCE_LANGUAGE"";
	public static final String TARGET_LANGUAGE = ""TARGET_LANGUAGE"";
	public static final String SOURCE_TEXT = ""SOURCE_TEXT"";
	public static final String TARGET_TEXT = ""TARGET_TEXT"";
	public static final String DECKPATH = ""DECK_PATH"";

	public static final String CARD_EDITOR_ACTION = ""cea"";
	public static final int EDIT_REVIEWER_CARD = 0;
	public static final int EDIT_BROWSER_CARD = 1;
	public static final int ADD_CARD = 2;
	public static final int COPY_CARD = 3;

	private static final int DIALOG_MODEL_SELECT = 0;
	private static final int DIALOG_CARD_MODEL_SELECT = 1;
	private static final int DIALOG_TAGS = 2;
	private static final int DIALOG_DECK_SELECT = 3;
	private static final int DIALOG_RESET_CARD = 4;

	private static final String INTENT_CREATE_FLASHCARD = ""org.openintents.indiclash.CREATE_FLASHCARD"";
	private static final String INTENT_CREATE_FLASHCARD_SEND = ""android.intent.action.SEND"";

	private static final int MENU_LOOKUP = 0;
	private static final int MENU_RESET = 1;
	private static final int MENU_COPY_CARD = 2;
	private static final int MENU_ADD_CARD = 3;
	private static final int MENU_RESET_CARD_PROGRESS = 4;

	private static final int ACTION_ADD_CARD = 0;

	/**
	 * Broadcast that informs us when the sd card is about to be unmounted
	 */
	private BroadcastReceiver mUnmountReceiver = null;

	private LinearLayout mFieldsLayoutContainer;
	private HashMap<Long, Model> mModels;

	private Button mSave;
	private Button mCancel;
	private Button mTags;
	private LinearLayout mModelButtons;
	private Button mModelButton;
	private Button mSwapButton;
	private Button mCardModelButton;

	private StyledDialog mCardModelDialog;

	private Fact mEditorFact;
	private boolean mAddFact = false;
	private boolean mForCopy = false;
	private boolean mIntentAdd = false;
	private String mDeckPath;

	private boolean mCardReset = false;

	private Deck mDeck;
	private Long mCurrentSelectedModelId;

	private LinkedList<FieldEditText> mEditFields;
	private LinkedHashMap<Long, CardModel> mCardModels;

	private LinkedHashMap<Long, CardModel> mSelectedCardModels;
	private LinkedHashMap<Long, CardModel> mNewSelectedCardModels;
	private ArrayList<Long> cardModelIds = new ArrayList<Long>();

	private boolean mModified;

	private String[] allTags;
	private HashSet<String> mSelectedTags;
	private String mFactTags = """";
	private EditText mNewTagEditText;
	private StyledDialog mTagsDialog;

	private ProgressDialog mProgressDialog;

	private HashMap<String, String> mFullDeckPaths;
	private String[] mDeckNames;
//	private String mSourceLanguage;
//	private String mTargetLanguage;
	private String mSourceText;
	private String mTargetText;
	private int mSourcePosition = 0;
	private int mTargetPosition = 1;
	private boolean mCancelled = false;

	private boolean mPrefFixArabic;

	private int mFilledFields = 0;

	private DeckTask.TaskListener mSaveFactHandler = new DeckTask.TaskListener() {
		@Override
		public void onPreExecute() {
			Resources res = getResources();
			mProgressDialog = ProgressDialog.show(CardEditor.this, """", res
					.getString(R.string.saving_facts), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
			if (values[0].getBoolean()) {
				mEditorFact = mDeck.newFact(mCurrentSelectedModelId);
				populateEditFields();
				mSave.setEnabled(false);
				mSourceText = null;
				mTargetText = null;
				mSwapButton.setVisibility(View.GONE);
			} else {
				Themes.showThemedToast(CardEditor.this, getResources()
						.getString(R.string.factadder_saving_error), true);
			}
			if (mProgressDialog != null && mProgressDialog.isShowing()) {
				try {
					mProgressDialog.dismiss();
				} catch (IllegalArgumentException e) {
					Log.e(AnkiDroidApp.TAG, ""Card Editor: Error on dismissing progress dialog: "" + e);
				}

			}
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			if (mForCopy) {
				closeCardEditor();
			}
		}
	};


	// ----------------------------------------------------------------------------
	// ANDROID METHODS
	// ----------------------------------------------------------------------------

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		Themes.applyTheme(this);
		super.onCreate(savedInstanceState);

		if (savedInstanceState != null) {
			finish();
			return;
		}

		registerExternalStorageListener();

		View mainView = getLayoutInflater().inflate(R.layout.card_editor, null);
		setContentView(mainView);
		Themes.setWallpaper(mainView);

		mFieldsLayoutContainer = (LinearLayout) findViewById(R.id.CardEditorEditFieldsLayout);
		Themes.setTextViewStyle(mFieldsLayoutContainer);

		setTitle(R.string.cardeditor_title);
		mSave = (Button) findViewById(R.id.CardEditorSaveButton);
		mCancel = (Button) findViewById(R.id.CardEditorCancelButton);
		mSwapButton = (Button) findViewById(R.id.CardEditorSwapButton);
		mModelButtons = (LinearLayout) findViewById(R.id.CardEditorSelectModelLayout);
		mModelButton = (Button) findViewById(R.id.CardEditorModelButton);
		mCardModelButton = (Button) findViewById(R.id.CardEditorCardModelButton);
		mTags = (Button) findViewById(R.id.CardEditorTagButton);

		mNewSelectedCardModels = new LinkedHashMap<Long, CardModel>();
		cardModelIds = new ArrayList<Long>();

		Intent intent = getIntent();
		String action = intent.getAction();
		if (action != null && action.equals(INTENT_CREATE_FLASHCARD)) {
			prepareForIntentAddition();
			Bundle extras = intent.getExtras();
//			mSourceLanguage = extras.getString(SOURCE_LANGUAGE);
//			mTargetLanguage = extras.getString(TARGET_LANGUAGE);
			mSourceText = extras.getString(SOURCE_TEXT);
			mTargetText = extras.getString(TARGET_TEXT);
			mAddFact = true;
			mIntentAdd = true;
		} else if (action != null
				&& action.equals(INTENT_CREATE_FLASHCARD_SEND)) {
			prepareForIntentAddition();
			Bundle extras = intent.getExtras();
			mSourceText = extras.getString(Intent.EXTRA_SUBJECT);
			mTargetText = extras.getString(Intent.EXTRA_TEXT);
			mAddFact = true;
			mIntentAdd = true;
		} else {
			mDeckPath = intent.getStringExtra(DECKPATH);
			if (mDeckPath != null && mDeckPath.length() > 0) {
				mDeck = Deck.openDeck(mDeckPath, false);
			} else {
				mDeck = AnkiDroidApp.deck();
			}
			switch (intent.getIntExtra(CARD_EDITOR_ACTION, ADD_CARD)) {
			case EDIT_REVIEWER_CARD:
				Card revCard = Reviewer.getEditorCard();
				if (revCard == null) {
					finish();
					return;
				}
				mEditorFact = revCard.getFact();
				break;
			case EDIT_BROWSER_CARD:
				Card browCard = CardBrowser.getEditorCard();
				if (browCard == null) {
					finish();
					return;
				}
				mEditorFact = browCard.getFact();
				break;
			case COPY_CARD:
				mForCopy = true;
			case ADD_CARD:
				mAddFact = true;
				loadContents();
				modelChanged();
				mSave.setEnabled(false);
				if (mForCopy) {
					String[] contents = intent.getStringExtra(""contents"").split(""\\x1f"");
					for (int i = 0; i < mEditFields.size(); i++) {
						if (i < contents.length) {
							mEditFields.get(i).setText(contents[i]);
							if (contents[i].length() > 0) {
								mSave.setEnabled(true);								
							}
						}
					}
				}
				break;
			}
		}
		if (mAddFact) {
			mModelButtons.setVisibility(View.VISIBLE);
			mModelButton.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					showDialog(DIALOG_MODEL_SELECT);
				}
			});
			mCardModelButton.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					showDialog(DIALOG_CARD_MODEL_SELECT);
				}
			});
			mSave.setText(getResources().getString(R.string.add));
			mCancel.setText(getResources().getString(R.string.close));
		} else {
			mFactTags = mEditorFact.getTags();
		}

		mTags.setText(getResources().getString(R.string.CardEditorTags, mFactTags));
		mModified = false;

		SharedPreferences preferences = PrefSettings
				.getSharedPrefs(getBaseContext());
		mPrefFixArabic = preferences.getBoolean(""fixArabicText"", false);
		// if Arabic reshaping is enabled, disable the Save button to avoid
		// saving the reshaped string to the deck
		if (mPrefFixArabic && !mAddFact) {
			mSave.setEnabled(false);
		}

		mTags.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				showDialog(DIALOG_TAGS);
			}

		});
		allTags = null;
		mSelectedTags = new HashSet<String>();

		mSave.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				if (mAddFact) {
					boolean empty = true;
					for (FieldEditText current : mEditFields) {
						current.updateField();
						if (current.getText().length() != 0) {
							empty = false;
						}
					}
					if (!empty) {
						setResult(Reviewer.RESULT_EDIT_CARD_RESET);
						mEditorFact.setTags(mFactTags);
						DeckTask.launchDeckTask(DeckTask.TASK_TYPE_ADD_FACT,
								mSaveFactHandler, new DeckTask.TaskData(mDeck,
										mEditorFact, mSelectedCardModels));
					} else {
						if (!mCardReset) {
							setResult(RESULT_CANCELED);
						}
					}
				} else {
					Iterator<FieldEditText> iter = mEditFields.iterator();
					while (iter.hasNext()) {
						FieldEditText current = iter.next();
						mModified |= current.updateField();
					}
					if (!mEditorFact.getTags().equals(mFactTags)) {
						mEditorFact.setTags(mFactTags);
						mModified = true;
					}
					// Only send result to save if something was actually
					// changed
					if (!mCardReset) {
						if (mModified) {
							setResult(RESULT_OK);
						} else {
							setResult(RESULT_CANCELED);
						}						
					}
					closeCardEditor();
				}
			}

		});

		mCancel.setOnClickListener(new View.OnClickListener() {

			@Override
			public void onClick(View v) {
				if (!mCardReset) {
					setResult(RESULT_CANCELED);					
				}
				closeCardEditor();
			}

		});

		if (!mAddFact) {
			populateEditFields();
		}
	}


	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
			// Log.i(AnkiDroidApp.TAG, ""CardEditor - onBackPressed()"");
			closeCardEditor();
			return true;
		}

		return super.onKeyDown(keyCode, event);
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
		if (mUnmountReceiver != null) {
			unregisterReceiver(mUnmountReceiver);
		}
	}


	@Override
    protected void onSaveInstanceState(Bundle outState) {
		String path = mDeck.getDeckPath();
        // Log.i(AnkiDroidApp.TAG, ""onSaveInstanceState: "" + path);
        // Remember current deck's filename.
        if (path != null) {
            outState.putString(""deckFilename"", path);
        }
        // Log.i(AnkiDroidApp.TAG, ""onSaveInstanceState - Ending"");
    }


	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		MenuItem item;
		Resources res = getResources();
		Lookup.initialize(this, mDeck.getDeckPath());
		item = menu.add(Menu.NONE, MENU_LOOKUP, Menu.NONE, Lookup.getSearchStringTitle());
		item.setIcon(R.drawable.ic_menu_search);
		item.setEnabled(Lookup.isAvailable());
		item = menu.add(Menu.NONE, MENU_RESET, Menu.NONE, res.getString(R.string.card_editor_reset));
		item.setIcon(R.drawable.ic_menu_revert);
		if (!mAddFact) {
			item = menu.add(Menu.NONE, MENU_ADD_CARD, Menu.NONE, res.getString(R.string.card_editor_add_card));
			item.setIcon(R.drawable.ic_menu_add);			
		}
		item = menu.add(Menu.NONE, MENU_COPY_CARD, Menu.NONE, res.getString(R.string.card_editor_copy_card));
		item.setIcon(R.drawable.ic_menu_upload);
		if (!mAddFact) {
			item = menu.add(Menu.NONE, MENU_RESET_CARD_PROGRESS, Menu.NONE, res.getString(R.string.card_editor_reset_card));
			item.setIcon(R.drawable.ic_menu_delete);			
		}
		return true;
	}


	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		View focus = this.getWindow().getCurrentFocus();
        menu.findItem(MENU_LOOKUP).setEnabled(focus instanceof FieldEditText && ((TextView)focus).getText().length() > 0 && Lookup.isAvailable());			

        for (int i = 0; i < mEditFields.size(); i++) {
			if (mEditFields.get(i).getText().length() > 0) {
		        menu.findItem(MENU_COPY_CARD).setEnabled(true);
				break;
			} else if (i == mEditFields.size() - 1) {
		        menu.findItem(MENU_COPY_CARD).setEnabled(false);				
			}
		}
		return true;
	}


	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case MENU_COPY_CARD:
		case MENU_ADD_CARD:
			Intent intent = new Intent(CardEditor.this, CardEditor.class);
			if (item.getItemId() == MENU_COPY_CARD) {
				intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.COPY_CARD);
				StringBuilder contents = new StringBuilder();
				for (FieldEditText current : mEditFields) {
					contents.append(current.getText().toString()).append(""\u001f"");
				}
				intent.putExtra(""contents"", contents.toString());
				if (mDeckPath != null && mDeckPath.length() > 0) {
					intent.putExtra(DECKPATH, mDeckPath);
				}
			} else {
				intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.ADD_CARD);
			}
			startActivityForResult(intent, ACTION_ADD_CARD);
			if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
				ActivityTransitionAnimation.slide(CardEditor.this,
						ActivityTransitionAnimation.LEFT);
			}
			return true;
		case MENU_RESET:
			if (mAddFact) {
				if (mIntentAdd) {
					if (mSourceText != null) {
						mEditFields.get(0).setText(mSourceText);
					}
					if (mTargetText != null) {
						mEditFields.get(1).setText(mTargetText);
					}
				} else {
					for (FieldEditText current : mEditFields) {
						current.setText("""");
					}
					if (!mEditFields.isEmpty()) {
						mEditFields.getFirst().requestFocus();
					}
				}
			} else {
				populateEditFields();
			}
			return true;
		case MENU_LOOKUP:
			View focus = this.getWindow().getCurrentFocus();
			if (focus instanceof FieldEditText) {
				FieldEditText field = (FieldEditText)focus;
				if (!field.isSelected()) {
					field.selectAll();
				}
				Lookup.lookUp(field.getText().toString().substring(field.getSelectionStart(), field.getSelectionEnd()), null);
			}
			return true;
		case MENU_RESET_CARD_PROGRESS:
			showDialog(DIALOG_RESET_CARD);
			return true;
		}
		return false;
	}


	// ----------------------------------------------------------------------------
	// CUSTOM METHODS
	// ----------------------------------------------------------------------------

	/**
	 * Registers an intent to listen for ACTION_MEDIA_EJECT notifications.
	 */
	public void registerExternalStorageListener() {
		if (mUnmountReceiver == null) {
			mUnmountReceiver = new BroadcastReceiver() {
				@Override
				public void onReceive(Context context, Intent intent) {
					String action = intent.getAction();
					if (action.equals(Intent.ACTION_MEDIA_EJECT)) {
						finishNoStorageAvailable();
					}
				}
			};
			IntentFilter iFilter = new IntentFilter();
			iFilter.addAction(Intent.ACTION_MEDIA_EJECT);
			iFilter.addDataScheme(""file"");
			registerReceiver(mUnmountReceiver, iFilter);
		}
	}

	private void loadContents() {
		mModels = Model.getModels(mDeck);
		mCurrentSelectedModelId = mDeck.getCurrentModelId();
		modelChanged();
		mEditFields.get(0).setText(mSourceText);
		mEditFields.get(1).setText(mTargetText);
	}

	private void prepareForIntentAddition() {
		mSwapButton.setVisibility(View.VISIBLE);
		mSwapButton.setOnClickListener(new View.OnClickListener() {

			public void onClick(View v) {
				swapText(false);
			}
		});
		showDialog(DIALOG_DECK_SELECT);
	}

	private void finishNoStorageAvailable() {
		setResult(StudyOptions.CONTENT_NO_EXTERNAL_STORAGE);
		finish();
	}

	private void closeCardEditor() {
		if (mIntentAdd && mDeck != null) {
			Deck deck = AnkiDroidApp.deck();
			if (deck == null || !deck.getDeckPath().equals(mDeckPath)) {
				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_CLOSE_DECK,  new DeckTask.TaskListener() {
			        @Override
			        public void onPreExecute() {
			        }
			        @Override
			        public void onPostExecute(DeckTask.TaskData result) {
			        }
			        @Override
			        public void onProgressUpdate(DeckTask.TaskData... values) {
			        }
				}, new DeckTask.TaskData(mDeck, 0));
			}
		}
		finish();
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		StyledDialog dialog = null;
		Resources res = getResources();
		StyledDialog.Builder builder = new StyledDialog.Builder(this);

		switch (id) {
		case DIALOG_TAGS:
			builder.setTitle(R.string.studyoptions_limit_select_tags);
			builder.setPositiveButton(res.getString(R.string.select),
					new OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							String tags = mSelectedTags.toString();
							mFactTags = tags.substring(1, tags.length() - 1);
							mTags.setText(getResources().getString(
									R.string.CardEditorTags, mFactTags));
						}
					});
			builder.setNegativeButton(res.getString(R.string.cancel), null);

			mNewTagEditText = (EditText) new EditText(this);
			mNewTagEditText.setHint(R.string.add_new_tag);

			InputFilter filter = new InputFilter() {
				public CharSequence filter(CharSequence source, int start,
						int end, Spanned dest, int dstart, int dend) {
					for (int i = start; i < end; i++) {
						if (!(Character.isLetterOrDigit(source.charAt(i)))) {
							return """";
						}
					}
					return null;
				}
			};
			mNewTagEditText.setFilters(new InputFilter[] { filter });

			ImageView mAddTextButton = new ImageView(this);
			mAddTextButton.setImageResource(R.drawable.ic_addtag);
			mAddTextButton.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					String tag = mNewTagEditText.getText().toString();
					if (tag.length() != 0) {
						for (int i = 0; i < allTags.length; i++) {
							if (allTags[i].equalsIgnoreCase(tag)) {
								mNewTagEditText.setText("""");
								return;
							}
						}
						mSelectedTags.add(tag);
						String[] oldTags = allTags;
						allTags = new String[oldTags.length + 1];
						allTags[0] = tag;
						for (int j = 1; j < allTags.length; j++) {
							allTags[j] = oldTags[j - 1];
						}
						mTagsDialog.addMultiChoiceItems(tag, true);
						mNewTagEditText.setText("""");
					}
				}
			});

			FrameLayout frame = new FrameLayout(this);
			FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
					ViewGroup.LayoutParams.WRAP_CONTENT,
					ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.RIGHT
							| Gravity.CENTER_VERTICAL);
			params.rightMargin = 10;
			mAddTextButton.setLayoutParams(params);
			frame.addView(mNewTagEditText);
			frame.addView(mAddTextButton);

			builder.setView(frame, false, true);
			dialog = builder.create();
			mTagsDialog = dialog;
			break;

		case DIALOG_DECK_SELECT:
			int len = 0;
			File[] fileList;

			File dir = new File(PrefSettings.getSharedPrefs(getBaseContext())
					.getString(""deckPath"", AnkiDroidApp.getStorageDirectory()));
			fileList = dir.listFiles(new AnkiFilter());

			if (dir.exists() && dir.isDirectory() && fileList != null) {
				len = fileList.length;
			}

			TreeSet<String> tree = new TreeSet<String>();
			mFullDeckPaths = new HashMap<String, String>();

			if (len > 0 && fileList != null) {
				// Log.i(AnkiDroidApp.TAG, ""CardEditor - populateDeckDialog, number of anki files = "" + len);
				for (File file : fileList) {
					String name = file.getName().replaceAll("".anki"", """");
					tree.add(name);
					mFullDeckPaths.put(name, file.getAbsolutePath());
				}
			}

			builder.setTitle(R.string.fact_adder_select_deck);
			// Convert to Array
			mDeckNames = new String[tree.size()];
			tree.toArray(mDeckNames);

			builder.setItems(mDeckNames, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface dialog, int item) {
					loadDeck(item);
				}
			});
			builder.setOnCancelListener(new OnCancelListener() {
				@Override
				public void onCancel(DialogInterface arg0) {
					mCancelled = true;
				}

			});
			builder.setOnDismissListener(new OnDismissListener() {
				@Override
				public void onDismiss(DialogInterface arg0) {
					if (mCancelled == true) {
						finish();
					} else if (mDeck == null) {
						showDialog(DIALOG_DECK_SELECT);
					}
				}
			});
			dialog = builder.create();
			break;
		case DIALOG_MODEL_SELECT:
			ArrayList<CharSequence> dialogItems = new ArrayList<CharSequence>();
			// Use this array to know which ID is associated with each
			// Item(name)
			final ArrayList<Long> dialogIds = new ArrayList<Long>();

			Model mModel;
			builder.setTitle(R.string.select_model);
			for (Long i : mModels.keySet()) {
				mModel = mModels.get(i);
				dialogItems.add(mModel.getName());
				dialogIds.add(i);
			}
			// Convert to Array
			String[] items = new String[dialogItems.size()];
			dialogItems.toArray(items);

			builder.setItems(items, new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int item) {
					long oldModelId = mCurrentSelectedModelId;
					mCurrentSelectedModelId = dialogIds.get(item);
					if (oldModelId != mCurrentSelectedModelId) {
						int size = mEditFields.size();
						String[] oldValues = new String[size];
						for (int i = 0; i < size; i++) {
							oldValues[i] = mEditFields.get(i).getText()
									.toString();
						}
						modelChanged();
						if ((mSourceText == null || mSourceText.length() == 0)
								&& (mTargetText == null || mTargetText
										.length() == 0)) {
							for (int i = 0; i < Math.min(size, mEditFields
									.size()); i++) {
								mEditFields.get(i).setText(oldValues[i]);
							}
						}
					}
				}
			});
			dialog = builder.create();
			break;
		case DIALOG_CARD_MODEL_SELECT:
			builder.setTitle(res.getString(R.string.select_card_model));
			builder.setPositiveButton(res.getString(R.string.select),
					new OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							mSelectedCardModels.clear();
							mSelectedCardModels.putAll(mNewSelectedCardModels);
							cardModelsChanged();
						}
					});
			builder.setNegativeButton(res.getString(R.string.cancel),
					new OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
						}
					});
			mCardModelDialog = builder.create();
			dialog = mCardModelDialog;
			break;
		case DIALOG_RESET_CARD:
    		builder.setTitle(res.getString(R.string.reset_card_dialog_title));
    		builder.setMessage(res.getString(R.string.reset_card_dialog_message));
			builder.setPositiveButton(res.getString(R.string.yes),
					new OnClickListener() {
						@Override
						public void onClick(DialogInterface dialog, int which) {
							for (long cardId : mDeck.getCardsFromFactId(mEditorFact.getId())) {
								mDeck.cardFromId(cardId).resetCard();
							}
							mDeck.reset();
							setResult(Reviewer.RESULT_EDIT_CARD_RESET);
							mCardReset = true;
							Themes.showThemedToast(CardEditor.this, getResources().getString(
									R.string.reset_card_dialog_confirmation), true);
						}
					});
			builder.setNegativeButton(res.getString(R.string.no), null);
			builder.setCancelable(true);
			dialog = builder.create();
			break;
		}
		return dialog;
	}

	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		StyledDialog ad = (StyledDialog) dialog;
		switch (id) {
		case DIALOG_TAGS:
			if (allTags == null) {
				String[] oldTags = mDeck.allUserTags();
		        if (oldTags == null) {
		        	Themes.showThemedToast(CardEditor.this, getResources().getString(R.string.error_insufficient_memory), false);
		        	ad.setEnabled(false);
		        	return;
		        }
				// Log.i(AnkiDroidApp.TAG, ""all tags: "" + Arrays.toString(oldTags));
				allTags = new String[oldTags.length];
				for (int i = 0; i < oldTags.length; i++) {
					allTags[i] = oldTags[i];
				}
			}
			mSelectedTags.clear();
			List<String> selectedList = Arrays.asList(Utils
					.parseTags(mFactTags));
			int length = allTags.length;
			boolean[] checked = new boolean[length];
			for (int i = 0; i < length; i++) {
				String tag = allTags[i];
				if (selectedList.contains(tag)) {
					checked[i] = true;
					mSelectedTags.add(tag);
				}
			}
			ad.setMultiChoiceItems(allTags, checked,
					new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface arg0, int which) {
							String tag = allTags[which];
							if (mSelectedTags.contains(tag)) {
								Log
										.i(AnkiDroidApp.TAG, ""unchecked tag: ""
												+ tag);
								mSelectedTags.remove(tag);
							} else {
								// Log.i(AnkiDroidApp.TAG, ""checked tag: "" + tag);
								mSelectedTags.add(tag);
							}
						}
					});
			break;
		case DIALOG_CARD_MODEL_SELECT:
			mCardModels = mDeck.cardModels(mEditorFact);
			int size = mCardModels.size();
			String dialogItems[] = new String[size];
			cardModelIds.clear();
			int i = 0;
			for (Long id2 : mCardModels.keySet()) {
				dialogItems[i] = mCardModels.get(id2).getName();
				cardModelIds.add(id2);
				i++;
			}
			boolean[] checkedItems = new boolean[size];
			for (int j = 0; j < size; j++) {
				;
				checkedItems[j] = mSelectedCardModels.containsKey(cardModelIds
						.get(j));
			}
			mNewSelectedCardModels.clear();
			mNewSelectedCardModels.putAll(mSelectedCardModels);
			ad.setMultiChoiceItems(dialogItems, checkedItems,
					new DialogInterface.OnClickListener() {
						@Override
						public void onClick(DialogInterface arg0, int which) {
							long m = cardModelIds.get(which);
							if (mNewSelectedCardModels.containsKey(m)) {
								mNewSelectedCardModels.remove(m);
							} else {
								mNewSelectedCardModels.put(m, mCardModels
										.get(m));
							}
							mCardModelDialog.getButton(
									StyledDialog.BUTTON_POSITIVE).setEnabled(
									!mNewSelectedCardModels.isEmpty());
						}
					});
			ad.getButton(StyledDialog.BUTTON_POSITIVE).setEnabled(
					!mNewSelectedCardModels.isEmpty());
			break;
		}
	}


    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        if (resultCode == Reviewer.RESULT_EDIT_CARD_RESET) {
        	mCardReset = true;
        	setResult(Reviewer.RESULT_EDIT_CARD_RESET);
        }
    }


    private void modelChanged() {
		mEditorFact = mDeck.newFact(mCurrentSelectedModelId);
		mSelectedCardModels = mDeck.activeCardModels(mEditorFact);

		mModelButton.setText(getResources().getString(R.string.model) + "" ""
				+ mModels.get(mCurrentSelectedModelId).getName());
		cardModelsChanged();
		populateEditFields();
		swapText(true);
	}


	private void loadDeck(int item) {
		String deckName = mDeckNames[item];
		mDeckPath = mFullDeckPaths.get(deckName);
		Deck deck = AnkiDroidApp.deck();
		if (deck != null && deck.getDeckPath().equals(mDeckPath)) {
			mDeck = deck;
		} else {
			try {
				mDeck = Deck.openDeck(mDeckPath, false);
				if (mDeck == null) {
					Themes.showThemedToast(CardEditor.this, getResources().getString(
							R.string.fact_adder_deck_not_loaded), true);
					BackupManager.restoreDeckIfMissing(mDeckPath);
					return;
				}				
			} catch (RuntimeException e) {
				Log.e(AnkiDroidApp.TAG, ""CardEditor: error on opening deck: "" + e);
				Themes.showThemedToast(CardEditor.this, getResources().getString(
						R.string.fact_adder_deck_not_loaded), true);
				BackupManager.restoreDeckIfMissing(mDeckPath);
				return;				
			}
		}
		setTitle(deckName);
		loadContents();
	}

	private void swapText(boolean reset) {
		// get source text
		FieldEditText field = mEditFields.get(mSourcePosition);
		Editable sourceText = field.getText();
		boolean sourceCutMode = field.getCutMode();
		FieldEditText.WordRow[] sourceCutString = field.getCutString(); 

		// get target text
		field = mEditFields.get(mTargetPosition);
		Editable targetText = field.getText();
		boolean targetCutMode = field.getCutMode();
		FieldEditText.WordRow[] targetCutString = field.getCutString(); 

		if (mEditFields.size() > mSourcePosition) {
			mEditFields.get(mSourcePosition).setText("""");
		}
		if (mEditFields.size() > mTargetPosition) {
			mEditFields.get(mTargetPosition).setText("""");
		}
		if (reset) {
			mSourcePosition = 0;
			mTargetPosition = 1;
		} else {
			mTargetPosition++;
			while (mTargetPosition == mSourcePosition
					|| mTargetPosition >= mEditFields.size()) {
				mTargetPosition++;
				if (mTargetPosition >= mEditFields.size()) {
					mTargetPosition = 0;
					mSourcePosition++;
				}
				if (mSourcePosition >= mEditFields.size()) {
					mSourcePosition = 0;
				}
			}
		}
		if (sourceText != null) {
			mEditFields.get(mSourcePosition).setText(sourceText);
			mEditFields.get(mSourcePosition).setCutMode(sourceCutMode, sourceCutString);
		}
		if (targetText != null) {
			mEditFields.get(mTargetPosition).setText(targetText);
			mEditFields.get(mTargetPosition).setCutMode(targetCutMode, targetCutString);
		}
	}

	private void cardModelsChanged() {
		String cardModelNames = """";
		for (Map.Entry<Long, CardModel> entry : mSelectedCardModels.entrySet()) {
			cardModelNames = cardModelNames + entry.getValue().getName() + "", "";
		}
		cardModelNames = cardModelNames.substring(0,
				cardModelNames.length() - 2);

		if (mSelectedCardModels.size() == 1) {
			mCardModelButton.setText(getResources().getString(R.string.card)
					+ "" "" + cardModelNames);
		} else {
			mCardModelButton.setText(getResources().getString(R.string.cards)
					+ "" "" + cardModelNames);
		}
	}

	private void populateEditFields() {
		mFieldsLayoutContainer.removeAllViews();
		mEditFields = new LinkedList<FieldEditText>();
		TreeSet<Field> fields = mEditorFact.getFields();
		for (Field f : fields) {
			FieldEditText newTextbox = new FieldEditText(this, f);
			TextView label = newTextbox.getLabel();
			ImageView circle = newTextbox.getCircle();
			mEditFields.add(newTextbox);
			FrameLayout frame = new FrameLayout(this);
			FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(
					ViewGroup.LayoutParams.WRAP_CONTENT,
					ViewGroup.LayoutParams.WRAP_CONTENT, Gravity.RIGHT
							| Gravity.CENTER_VERTICAL);
			params.rightMargin = 10;
			circle.setLayoutParams(params);
			frame.addView(newTextbox);
			frame.addView(circle);
			mFieldsLayoutContainer.addView(label);
			mFieldsLayoutContainer.addView(frame);
		}
	}

	// ----------------------------------------------------------------------------
	// INNER CLASSES
	// ----------------------------------------------------------------------------

	public class FieldEditText extends EditText {

	    public final String NEW_LINE = System.getProperty(""line.separator"");
	    public final String NL_MARK = ""newLineMark"";

		private Field mPairField;
		private WordRow mCutString[];
		private boolean mCutMode = false;
		private ImageView mCircle;
		private KeyListener mKeyListener;
		private Context mContext;

		public FieldEditText(Context context, Field pairField) {
			super(context);
			mContext = context;
			mPairField = pairField;
			if (mPrefFixArabic) {
				this.setText(ArabicUtilities.reshapeSentence(pairField
						.getValue().replaceAll(""<br(\\s*\\/*)>"", NEW_LINE)));
			} else {
				this.setText(pairField.getValue().replaceAll(""<br(\\s*\\/*)>"",
						NEW_LINE));
			}
			this.setMinimumWidth(400);
			this.setOnClickListener(new View.OnClickListener() {

				@Override
				public void onClick(View v) {
					if (mCutMode) {
						updateSpannables();
					}
				}
			});
		}

		@Override
		public void onTextChanged(CharSequence text, int start, int before,
				int after) {
			super.onTextChanged(text, start, before, after);
			if (mCircle != null) {
				int visibility = mCircle.getVisibility();
				if (text.length() == 0) {
					if (visibility == View.VISIBLE) {
						mFilledFields--;
						mCircle.setVisibility(View.GONE);
						mCircle.setAnimation(ViewAnimation.fade(
								ViewAnimation.FADE_OUT, 300, 0));
					}
				} else if (visibility == View.GONE) {
					mFilledFields++;
					mCircle.setVisibility(View.VISIBLE);
					mCircle.setAnimation(ViewAnimation.fade(
							ViewAnimation.FADE_IN, 300, 0));
				}
				mSave.setEnabled(mFilledFields != 0 && (!mPrefFixArabic || mAddFact));
			}
		}

		private void splitText(String text) {
			text = text.replace(NEW_LINE, "" "" + NL_MARK + "" "");
			String[] cut = text.split(""\\s"");
			mCutString = new WordRow[cut.length];
			for (int i = 0; i < cut.length; i++) {
				mCutString[i] = new WordRow(cut[i]);
				if (mCutString[i].mWord.equals(NL_MARK)) {
					mCutString[i].mEnabled = true;
				}
			}
		}

		public TextView getLabel() {
			TextView label = new TextView(this.getContext());
			label.setText(mPairField.getFieldModel().getName());
			return label;
		}

		public ImageView getCircle() {
			mCircle = new ImageView(this.getContext());
			mCircle.setImageResource(R.drawable.ic_circle_normal);
			mKeyListener = FieldEditText.this.getKeyListener();
			mCircle.setOnClickListener(new View.OnClickListener() {
				@Override
				public void onClick(View v) {
					Editable editText = FieldEditText.this.getText();
					if (mCutMode) {
						setCutMode(false, null);
						updateContentAfterWordSelection(editText);
					} else {
						setCutMode(true, null);
						String text = editText.toString();
						splitText(text);
						int pos = 0;
						for (WordRow row : mCutString) {
							if (row.mWord.length() == 0 || row.mWord.equals(NL_MARK)) {
								continue;
							}
							row.mBegin = text.indexOf(row.mWord, pos);
							row.mEnd = row.mBegin + row.mWord.length();
							if (!row.mEnabled) {
								editText.setSpan(new StrikethroughSpan(),
										row.mBegin, row.mEnd, 0);
							}
							pos = row.mEnd;
						}
					}
				}
			});
			if (this.getText().toString().length() > 0) {
				mFilledFields++;
				mCircle.setVisibility(View.VISIBLE);
			} else {
				mCircle.setVisibility(View.GONE);
			}
			return mCircle;
		}


		public boolean getCutMode() {
			return mCutMode;
		}


		public WordRow[] getCutString() {
			return mCutString;
		}


		public void setCutMode(boolean active, WordRow[] cutString) {
			mCutMode = active;
			if (mCutMode) {
				mCircle.setImageResource(R.drawable.ic_circle_pressed);
				InputMethodManager imm = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
				imm.hideSoftInputFromWindow(FieldEditText.this.getWindowToken(), 0);
				FieldEditText.this.setKeyListener(null);
				FieldEditText.this.setCursorVisible(false);
				if (cutString != null) {
					mCutString = cutString;
				}
			} else {
				mCircle.setImageResource(R.drawable.ic_circle_normal);
				FieldEditText.this.setKeyListener(mKeyListener);
				FieldEditText.this.setCursorVisible(true);
			}
		}


		public boolean updateField() {
			if (mCutMode) {
				updateContentAfterWordSelection(FieldEditText.this.getText());
			}
			String newValue = this.getText().toString().replace(NEW_LINE, ""<br />"");
			if (!mPairField.getValue().equals(newValue)) {
				mPairField.setValue(newValue);
				return true;
			}
			return false;
		}


		public void updateContentAfterWordSelection(Editable editText) {
			for (WordRow row : mCutString) {
				if (row.mEnabled && !row.mWord.equals(NL_MARK)) {
					removeDeleted();
					break;
				}
			}
			StrikethroughSpan[] ss = editText.getSpans(0, editText
					.length(), StrikethroughSpan.class);
			for (StrikethroughSpan s : ss) {
				editText.removeSpan(s);
			}
			mCutMode = false;
		}


		public void updateSpannables() {
			int cursorPosition = this.getSelectionStart();
			Editable editText = this.getText();
			for (WordRow row : mCutString) {
				if (row.mBegin <= cursorPosition && row.mEnd > cursorPosition) {
					if (!row.mEnabled) {
						StrikethroughSpan[] ss = this.getText().getSpans(
								cursorPosition, cursorPosition,
								StrikethroughSpan.class);
						if (ss.length != 0) {
							editText.removeSpan(ss[0]);
						}
						row.mEnabled = true;
					} else {
						editText.setSpan(new StrikethroughSpan(), row.mBegin,
								row.mEnd, 0);
						row.mEnabled = false;
						break;
					}
				}
			}
			this.setText(editText);
			this.setSelection(cursorPosition);
		}

		public String cleanText(String text) {
			text = text.replaceAll(""\\s*("" + NL_MARK + ""\\s*)+"", NEW_LINE);
			text = text.replaceAll(""^[,;:\\s\\)\\]"" + NEW_LINE + ""]*"", """");
			text = text.replaceAll(""[,;:\\s\\(\\["" + NEW_LINE + ""]*$"", """");
			return text;
		}

		public void removeDeleted() {
			if (this.getText().length() > 0) {
				StringBuilder sb = new StringBuilder();
				for (WordRow row : mCutString) {
					if (row.mEnabled) {
						sb.append(row.mWord);
						sb.append("" "");
					}
				}
				this.setText(cleanText(sb.toString()));
			}
		}

		private class WordRow {
			public String mWord;
			public int mBegin;
			public int mEnd;
			public boolean mEnabled = false;

			WordRow(String word) {
				mWord = word;
			}
		}
	}
}
",True,64,63,0,0,3,33
48,com.ichi2.anki.DownloadViewWrapper.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

public class DownloadViewWrapper {

    private View mBase;
    private TextView mHeaderTitle = null;
    private TextView mDownloadTitle = null;
    private ProgressBar mProgressBar = null;
    private TextView mProgressBarText = null;
    private TextView mEstimatedTimeText = null;
    private TextView mDeckTitle = null;
    private TextView mDeckFacts = null;


    DownloadViewWrapper(View base) {
        mBase = base;
    }


    TextView getHeaderTitle() {
        if (mHeaderTitle == null) {
            mHeaderTitle = (TextView) mBase.findViewById(R.id.header_title);
        }
        return mHeaderTitle;
    }


    TextView getDownloadTitle() {
        if (mDownloadTitle == null) {
            mDownloadTitle = (TextView) mBase.findViewById(R.id.download_title);
        }
        return mDownloadTitle;
    }


    ProgressBar getProgressBar() {
        if (mProgressBar == null) {
            mProgressBar = (ProgressBar) mBase.findViewById(R.id.progress_bar);
        }
        return mProgressBar;
    }


    TextView getProgressBarText() {
        if (mProgressBarText == null) {
            mProgressBarText = (TextView) mBase.findViewById(R.id.progress_text);
        }
        return mProgressBarText;
    }


    TextView getEstimatedTimeText() {
        if (mEstimatedTimeText == null) {
            mEstimatedTimeText = (TextView) mBase.findViewById(R.id.estimated_text);
        }
        return mEstimatedTimeText;
    }


    TextView getDeckTitle() {
        if (mDeckTitle == null) {
            mDeckTitle = (TextView) mBase.findViewById(R.id.deck_title);
        }
        return mDeckTitle;
    }


    TextView getDeckFacts() {
        if (mDeckFacts == null) {
            mDeckFacts = (TextView) mBase.findViewById(R.id.deck_facts);
        }
        return mDeckFacts;
    }
}
",False,60,3,1,2,0,0
49,com.ichi2.anki.CardBrowser.java,"/****************************************************************************************
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.app.Activity;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnCancelListener;
import android.content.DialogInterface.OnClickListener;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.os.Bundle;
import android.os.Handler;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.util.TypedValue;
import android.view.ContextMenu;
import android.view.ContextMenu.ContextMenuInfo;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.SubMenu;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.SimpleAdapter;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.themes.StyledDialog;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.amr.arabic.ArabicUtilities;

public class CardBrowser extends Activity {
	private ArrayList<HashMap<String, String>> mCards;
	private ArrayList<HashMap<String, String>> mAllCards;
	private ArrayList<HashMap<String, String>> mDeletedCards;
	private ListView mCardsListView;
	private SimpleAdapter mCardsAdapter;
	private EditText mSearchEditText;

	private ProgressDialog mProgressDialog;
	private boolean mUndoRedoDialogShowing = false;
	private Card mSelectedCard;
	private Card mUndoRedoCard;
	private long mUndoRedoCardId;
	private static Card sEditorCard;
	private boolean mIsSuspended;
	private boolean mIsMarked;
	private Deck mDeck;
	private int mPositionInCardsList;

	/** Modifier of percentage of the font size of the card browser */
	private int mrelativeBrowserFontSize = CardModel.DEFAULT_FONT_SIZE_RATIO;

	public static final int LOAD_CHUNK = 200;

	private static final int CONTEXT_MENU_MARK = 0;
	private static final int CONTEXT_MENU_SUSPEND = 1;
	private static final int CONTEXT_MENU_DELETE = 2;
	private static final int CONTEXT_MENU_DETAILS = 3;

	private static final int DIALOG_ORDER = 0;
	private static final int DIALOG_CONTEXT_MENU = 1;

	private static final int BACKGROUND_NORMAL = 0;
	private static final int BACKGROUND_MARKED = 1;
	private static final int BACKGROUND_SUSPENDED = 2;
	private static final int BACKGROUND_MARKED_SUSPENDED = 3;

	private static final int MENU_UNDO = 0;
	private static final int MENU_REDO = 1;
	private static final int MENU_ADD_FACT = 2;
	private static final int MENU_SHOW_MARKED = 3;
	private static final int MENU_SELECT = 4;
	private static final int MENU_SELECT_SUSPENDED = 41;
	private static final int MENU_SELECT_TAG = 42;
	private static final int MENU_CHANGE_ORDER = 5;

	private static final int EDIT_CARD = 0;
	private static final int ADD_FACT = 1;
	private static final int DEFAULT_FONT_SIZE_RATIO = 100;

	private static final int CARD_ORDER_ANSWER = 0;
	private static final int CARD_ORDER_QUESTION = 1;
	private static final int CARD_ORDER_DUE = 2;
	private static final int CARD_ORDER_INTERVAL = 3;
	private static final int CARD_ORDER_FACTOR = 4;
	private static final int CARD_ORDER_CREATED = 5;

	private int[] mBackground;

	private boolean mShowOnlyMarSus = false;

	private int mSelectedOrder = CARD_ORDER_CREATED;
	
	private String[] allTags;
	private HashSet<String> mSelectedTags;
	private StyledDialog mTagsDialog;

	private boolean mPrefFixArabic;

    private Handler mTimerHandler = new Handler();
    private static final int WAIT_TIME_UNTIL_UPDATE = 500;

	private Runnable updateList = new Runnable() {
    	public void run() {
    		updateCardsList();
    	}
    };


    private DialogInterface.OnClickListener mContextMenuListener = new DialogInterface.OnClickListener() {

		@Override
		public void onClick(DialogInterface dialog, int which) {
			switch (which) {
			case CONTEXT_MENU_MARK:
				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_MARK_CARD,
						mMarkCardHandler, new DeckTask.TaskData(0, mDeck,
								mSelectedCard));
				return;
			case CONTEXT_MENU_SUSPEND:
				DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SUSPEND_CARD,
						mSuspendCardHandler, new DeckTask.TaskData(0, mDeck,
								mSelectedCard));
				return;
			case CONTEXT_MENU_DELETE:
				Resources res = getResources();
				StyledDialog.Builder builder = new StyledDialog.Builder(CardBrowser.this);
				builder.setTitle(res.getString(R.string.delete_card_title));
				builder.setIcon(android.R.drawable.ic_dialog_alert);
				builder.setMessage(String.format(res
						.getString(R.string.delete_card_message), mCards.get(
						mPositionInCardsList).get(""question""), mCards.get(
						mPositionInCardsList).get(""answer"")));
				builder.setPositiveButton(res.getString(R.string.yes),
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog, int which) {
								DeckTask.launchDeckTask(
										DeckTask.TASK_TYPE_DELETE_CARD,
										mDeleteCardHandler, new DeckTask.TaskData(
												0, mDeck, mSelectedCard));
							}
						});
				builder.setNegativeButton(res.getString(R.string.no), null);
				builder.create().show();
				return;
			case CONTEXT_MENU_DETAILS:
				Themes.htmlOkDialog(CardBrowser.this, getResources().getString(R.string.card_browser_card_details), mSelectedCard.getCardDetails(CardBrowser.this, true)).show();
				return;
			}
		}
    	
    };


	@Override
	protected void onCreate(Bundle savedInstanceState) {
		Themes.applyTheme(this);
		super.onCreate(savedInstanceState);

		View mainView = getLayoutInflater().inflate(R.layout.card_browser, null);
		setContentView(mainView);
		Themes.setContentStyle(mainView, Themes.CALLER_CARDBROWSER);

		mDeck = AnkiDroidApp.deck();
		if (mDeck == null) {
			finish();
			return;
		}
		mDeck.resetUndo();

		mBackground = Themes.getCardBrowserBackground();

		SharedPreferences preferences = PrefSettings
				.getSharedPrefs(getBaseContext());
		mrelativeBrowserFontSize = preferences.getInt(
				""relativeCardBrowserFontSize"", DEFAULT_FONT_SIZE_RATIO);
		mPrefFixArabic = preferences.getBoolean(""fixArabicText"", false);

		mCards = new ArrayList<HashMap<String, String>>();
		mAllCards = new ArrayList<HashMap<String, String>>();
		mCardsListView = (ListView) findViewById(R.id.card_browser_list);

		mCardsAdapter = new SizeControlledListAdapter(this, mCards,
				R.layout.card_item, new String[] { ""question"", ""answer"",
						""flags"" }, new int[] { R.id.card_question,
						R.id.card_answer, R.id.card_item },
				mrelativeBrowserFontSize);
		mCardsAdapter.setViewBinder(new SimpleAdapter.ViewBinder() {
			@Override
			public boolean setViewValue(View view, Object arg1, String text) {
				if (view.getId() == R.id.card_item) {
					int which = BACKGROUND_NORMAL;
					if (text.equals(""11"")) {
						which = BACKGROUND_MARKED_SUSPENDED;
					} else if (text.substring(1, 2).equals(""1"")) {
						which = BACKGROUND_SUSPENDED;
					} else if (text.substring(0, 1).equals(""1"")) {
						which = BACKGROUND_MARKED;
					}
					view.setBackgroundResource(mBackground[which]);
					return true;
				}
				return false;
			}
		});

		mCardsListView.setAdapter(mCardsAdapter);
		mCardsListView.setOnItemClickListener(new OnItemClickListener() {
			@Override
			public void onItemClick(AdapterView<?> parent, View view,
					int position, long id) {
				Intent editCard = new Intent(CardBrowser.this, CardEditor.class);
				editCard.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.EDIT_BROWSER_CARD);
				mPositionInCardsList = position;
				mSelectedCard = mDeck.cardFromId(Long.parseLong(mCards.get(
						mPositionInCardsList).get(""id"")));
				sEditorCard = mSelectedCard;
				editCard.putExtra(""callfromcardbrowser"", true);
				startActivityForResult(editCard, EDIT_CARD);
				if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
					ActivityTransitionAnimation.slide(CardBrowser.this,
							ActivityTransitionAnimation.LEFT);
				}
			}
		});
		registerForContextMenu(mCardsListView);

		mSearchEditText = (EditText) findViewById(R.id.card_browser_search);
		mSearchEditText.addTextChangedListener(new TextWatcher() {
			public void afterTextChanged(Editable s) {
		    	mTimerHandler.removeCallbacks(updateList);
		    	mTimerHandler.postDelayed(updateList, WAIT_TIME_UNTIL_UPDATE);
			}

			public void beforeTextChanged(CharSequence s, int start, int count,
					int after) {
			}

			public void onTextChanged(CharSequence s, int start, int before,
					int count) {
			}
		});
		getWindow().setSoftInputMode(
				WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);

		setTitle(mDeck.getDeckName());

		allTags = null;
		mSelectedTags = new HashSet<String>();

		getCards();
	}


	@Override
	public void onCreateContextMenu(ContextMenu menu, View v,
			ContextMenuInfo menuInfo) {
		mPositionInCardsList = ((AdapterView.AdapterContextMenuInfo) menuInfo).position;
		showDialog(DIALOG_CONTEXT_MENU);
	}


	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event) {
		if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
			// Log.i(AnkiDroidApp.TAG, ""CardBrowser - onBackPressed()"");
			if (mSearchEditText.getText().length() == 0 && !mShowOnlyMarSus
					&& mSelectedTags.size() == 0) {
				setResult(RESULT_OK);
				finish();
				if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
					ActivityTransitionAnimation.slide(CardBrowser.this,
							ActivityTransitionAnimation.RIGHT);
				}
			} else {
				mSearchEditText.setText("""");
				mSearchEditText.setHint(R.string.downloaddeck_search);
				mSelectedTags.clear();
				mCards.clear();
				mCards.addAll(mAllCards);
				updateList();
			}
			return true;
		}

		return super.onKeyDown(keyCode, event);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		MenuItem item;
		item = menu.add(Menu.NONE, MENU_UNDO, Menu.NONE, R.string.undo);
		item.setIcon(R.drawable.ic_menu_revert);
		item = menu.add(Menu.NONE, MENU_REDO, Menu.NONE, R.string.redo);
		item.setIcon(R.drawable.ic_menu_redo);
		item = menu.add(Menu.NONE, MENU_ADD_FACT, Menu.NONE, R.string.add);
		item.setIcon(R.drawable.ic_menu_add);
		item = menu.add(Menu.NONE, MENU_CHANGE_ORDER, Menu.NONE,
				R.string.card_browser_change_display_order);
		item.setIcon(R.drawable.ic_menu_sort_by_size);
		item = menu.add(Menu.NONE, MENU_SHOW_MARKED, Menu.NONE,
				R.string.card_browser_show_marked);
		item.setIcon(R.drawable.ic_menu_star_on);
		SubMenu selectSubMenu = menu.addSubMenu(Menu.NONE, MENU_SELECT,
				Menu.NONE, R.string.card_browser_search);
		selectSubMenu.setIcon(R.drawable.ic_menu_search);
		selectSubMenu.add(Menu.NONE, MENU_SELECT_SUSPENDED, Menu.NONE,
				R.string.card_browser_search_suspended);
		selectSubMenu.add(Menu.NONE, MENU_SELECT_TAG, Menu.NONE,
				R.string.card_browser_search_by_tag);
		item.setIcon(R.drawable.ic_menu_close_clear_cancel);
		return true;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		menu.findItem(MENU_UNDO).setEnabled(mDeck.undoAvailable());
		menu.findItem(MENU_REDO).setEnabled(mDeck.redoAvailable());
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
		case MENU_UNDO:
			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UNDO, mUndoRedoHandler,
					new DeckTask.TaskData(0, mDeck, 0, true));
			return true;
		case MENU_REDO:
			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_REDO, mUndoRedoHandler,
					new DeckTask.TaskData(0, mDeck, 0, true));
			return true;
		case MENU_ADD_FACT:
			Intent intent = new Intent(CardBrowser.this, CardEditor.class);
			intent.putExtra(CardEditor.CARD_EDITOR_ACTION, CardEditor.ADD_CARD);
			startActivityForResult(intent, ADD_FACT);
			if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
				ActivityTransitionAnimation.slide(CardBrowser.this,
						ActivityTransitionAnimation.LEFT);
			}
			return true;
		case MENU_SHOW_MARKED:
			mShowOnlyMarSus = true;
			mSearchEditText.setHint(R.string.card_browser_show_marked);
			mCards.clear();
			for (int i = 0; i < mAllCards.size(); i++) {
				if ((mAllCards.get(i).get(""question"").toLowerCase().indexOf(
						mSearchEditText.getText().toString().toLowerCase()) != -1 || mAllCards
						.get(i).get(""answer"").toLowerCase().indexOf(
								mSearchEditText.getText().toString()
										.toLowerCase()) != -1)
						&& mAllCards.get(i).get(""flags"").subSequence(0, 1)
								.equals(""1"")) {
					mCards.add(mAllCards.get(i));
				}
			}
			updateList();
			return true;
		case MENU_SELECT_SUSPENDED:
			mShowOnlyMarSus = true;
			mSearchEditText.setHint(R.string.card_browser_show_suspended);
			mCards.clear();
			for (int i = 0; i < mAllCards.size(); i++) {
				if ((mAllCards.get(i).get(""question"").toLowerCase().indexOf(
						mSearchEditText.getText().toString().toLowerCase()) != -1 || mAllCards
						.get(i).get(""answer"").toLowerCase().indexOf(
								mSearchEditText.getText().toString()
										.toLowerCase()) != -1)
						&& mAllCards.get(i).get(""flags"").subSequence(1, 2)
								.equals(""1"")) {
					mCards.add(mAllCards.get(i));
				}
			}
			updateList();
			return true;
		case MENU_SELECT_TAG:
			recreateTagsDialog();
			mTagsDialog.show();
			return true;
		case MENU_CHANGE_ORDER:
			showDialog(DIALOG_ORDER);
			return true;
		}
		return false;
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		super.onActivityResult(requestCode, resultCode, data);

		if (requestCode == EDIT_CARD && resultCode == RESULT_OK) {
			// Log.i(AnkiDroidApp.TAG, ""Saving card..."");
			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_UPDATE_FACT,
					mUpdateCardHandler, new DeckTask.TaskData(0, mDeck,
							mSelectedCard));
		} else if (requestCode == ADD_FACT && resultCode == RESULT_OK) {
			getCards();
		}
	}

	
	@Override
	protected Dialog onCreateDialog(int id) {
		StyledDialog dialog = null;
		Resources res = getResources();
		StyledDialog.Builder builder = new StyledDialog.Builder(this);

		switch (id) {
		case DIALOG_ORDER:
			builder.setTitle(res
					.getString(R.string.card_browser_change_display_order_title));
			builder.setIcon(android.R.drawable.ic_menu_sort_by_size);
	        builder.setSingleChoiceItems(getResources().getStringArray(R.array.card_browser_order_labels), mSelectedOrder, new DialogInterface.OnClickListener() {
				@Override
				public void onClick(DialogInterface arg0, int which) {
					if (which != mSelectedOrder) {
						mSelectedOrder = which;
						DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SORT_CARDS, mSortCardsHandler, new DeckTask.TaskData(mAllCards, new HashMapCompare()));
					}
				}
	        });
			dialog = builder.create();
			break;
		case DIALOG_CONTEXT_MENU:
			String[] entries = new String[4];
			@SuppressWarnings(""unused"")
			MenuItem item;
			entries[CONTEXT_MENU_MARK] = res.getString(R.string.card_browser_mark_card);
			entries[CONTEXT_MENU_SUSPEND] = res.getString(R.string.card_browser_suspend_card);
			entries[CONTEXT_MENU_DELETE] = res.getString(R.string.card_browser_delete_card);
			entries[CONTEXT_MENU_DETAILS] = res.getString(R.string.card_browser_card_details);
	        builder.setTitle(""contextmenu"");
	        builder.setIcon(R.drawable.ic_menu_manage);
	        builder.setItems(entries, mContextMenuListener);
	        dialog = builder.create();
			break;
		}
		return dialog;
	}


	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		Resources res = getResources();
		StyledDialog ad = (StyledDialog)dialog;
		switch (id) {
		case DIALOG_CONTEXT_MENU:
			mSelectedCard = mDeck.cardFromId(Long.parseLong(mCards.get(mPositionInCardsList).get(""id"")));
			if (mSelectedCard.isMarked()) {
				ad.changeListItem(CONTEXT_MENU_MARK, res.getString(R.string.card_browser_unmark_card));
				mIsMarked = true;
				// Log.i(AnkiDroidApp.TAG, ""Selected Card is currently marked"");
			} else {
				ad.changeListItem(CONTEXT_MENU_MARK, res.getString(R.string.card_browser_mark_card));
				mIsMarked = false;
			}
			if (mSelectedCard.getSuspendedState()) {
				ad.changeListItem(CONTEXT_MENU_SUSPEND, res.getString(R.string.card_browser_unsuspend_card));
				mIsSuspended = true;
				// Log.i(AnkiDroidApp.TAG, ""Selected Card is currently suspended"");
			} else {
				ad.changeListItem(CONTEXT_MENU_SUSPEND, res.getString(R.string.card_browser_suspend_card));
				mIsSuspended = false;
			}
			ad.setTitle(mCards.get(mPositionInCardsList).get(""question""));
			break;
		}		
	}


	private void recreateTagsDialog() {
		Resources res = getResources();
		if (allTags == null) {
			String[] oldTags = AnkiDroidApp.deck().allTags_();
			// Log.i(AnkiDroidApp.TAG, ""all tags: "" + Arrays.toString(oldTags));
			allTags = new String[oldTags.length];
			for (int i = 0; i < oldTags.length; i++) {
				allTags[i] = oldTags[i];
			}
		}
		mSelectedTags.clear();

		StyledDialog.Builder builder = new StyledDialog.Builder(this);
		builder.setTitle(R.string.studyoptions_limit_select_tags);
		builder.setMultiChoiceItems(allTags, new boolean[0],
				new DialogInterface.OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						String tag = allTags[which];
						if (mSelectedTags.contains(tag)) {
							// Log.i(AnkiDroidApp.TAG, ""unchecked tag: "" + tag);
							mSelectedTags.remove(tag);
						} else {
							// Log.i(AnkiDroidApp.TAG, ""checked tag: "" + tag);
							mSelectedTags.add(tag);
						}
					}
				});
		builder.setPositiveButton(res.getString(R.string.select),
				new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						updateCardsList();
					}
				});
		builder.setNegativeButton(res.getString(R.string.cancel),
				new OnClickListener() {
					@Override
					public void onClick(DialogInterface dialog, int which) {
						mSelectedTags.clear();
					}
				});
		builder.setOnCancelListener(new OnCancelListener() {

			@Override
			public void onCancel(DialogInterface dialog) {
				mSelectedTags.clear();
			}
		});
		mTagsDialog = builder.create();
	}

	private void updateCardsList() {
		mShowOnlyMarSus = false;
		if (mSelectedTags.size() == 0) {
			mSearchEditText.setHint(R.string.downloaddeck_search);
		} else {
			String tags = mSelectedTags.toString();
			mSearchEditText.setHint(getResources().getString(
					R.string.card_browser_tags_shown,
					tags.substring(1, tags.length() - 1)));
		}
		mCards.clear();
		if (mSearchEditText.getText().length() == 0
				&& mSelectedTags.size() == 0 && mSelectedTags.size() == 0) {
			mCards.addAll(mAllCards);
		} else {
			for (int i = 0; i < mAllCards.size(); i++) {
				if ((mAllCards.get(i).get(""question"").toLowerCase().indexOf(
						mSearchEditText.getText().toString().toLowerCase()) != -1 || mAllCards
						.get(i).get(""answer"").toLowerCase().indexOf(
								mSearchEditText.getText().toString()
										.toLowerCase()) != -1)
						&& Arrays.asList(
								Utils.parseTags(mAllCards.get(i).get(""tags"")))
								.containsAll(mSelectedTags)) {
					mCards.add(mAllCards.get(i));
				}
			}
		}
		updateList();
	}

	private void getCards() {
		DeckTask.launchDeckTask(DeckTask.TASK_TYPE_LOAD_CARDS,
				mLoadCardsHandler,
				new DeckTask.TaskData(mDeck, LOAD_CHUNK));
	}

	public static Card getEditorCard() {
		return sEditorCard;
	}

	private void updateList() {
		mCardsAdapter.notifyDataSetChanged();
		int count = mCards.size();
		setTitle(getResources().getQuantityString(R.plurals.card_browser_title,
				count, mDeck.getDeckName(), count, mAllCards.size()));
	}

	private int getPosition(ArrayList<HashMap<String, String>> list, long cardId) {
		String cardid = Long.toString(cardId);
		for (int i = 0; i < list.size(); i++) {
			if (list.get(i).get(""id"").equals(cardid)) {
				return i;
			}
		}
		return -1;
	}

	private void updateCard(Card card, ArrayList<HashMap<String, String>> list,
			int position) {
		list.get(position).put(""question"", Utils.stripHTML(card.getQuestion().replaceAll(""<br(\\s*\\/*)>"",""\n"")));
		list.get(position).put(""answer"", Utils.stripHTML(card.getAnswer().replaceAll(""<br(\\s*\\/*)>"",""\n"")));
		for (long cardId : mDeck.getCardsFromFactId(card.getFactId())) {
			if (cardId != card.getId()) {
				int positionC = getPosition(mCards, cardId);
				int positionA = getPosition(mAllCards, cardId);
				Card c = mDeck.cardFromId(cardId);
				String question = Utils.stripHTML(c.getQuestion().replaceAll(""<br(\\s*\\/*)>"",""\n""));
				String answer = Utils.stripHTML(c.getAnswer().replaceAll(""<br(\\s*\\/*)>"",""\n""));
				if (positionC != -1) {
					mCards.get(positionC).put(""question"", question);
					mCards.get(positionC).put(""answer"", answer);
				}
				mAllCards.get(positionA).put(""question"", question);
				mAllCards.get(positionA).put(""answer"", answer);
			}
		}
	}

	private void markCards(long factId, boolean mark) {
		for (long cardId : mDeck.getCardsFromFactId(factId)) {
			int positionC = getPosition(mCards, cardId);
			int positionA = getPosition(mAllCards, cardId);
			String marSus = mAllCards.get(positionA).get(""flags"");
			if (mark) {
				marSus = ""1"" + marSus.substring(1, 2);
				if (positionC != -1) {
					mCards.get(positionC).put(""flags"", marSus);
				}
				mAllCards.get(positionA).put(""flags"", marSus);
			} else {
				marSus = ""0"" + marSus.substring(1, 2);
				if (positionC != -1) {
					mCards.get(positionC).put(""flags"", marSus);
				}
				mAllCards.get(positionA).put(""flags"", marSus);
			}
		}
		updateList();
	}

	private void suspendCard(Card card, int position, boolean suspend) {
		int posA = getPosition(mAllCards, card.getId());
		String marSus = mAllCards.get(posA).remove(""flags"");
		if (suspend) {
			marSus = marSus.substring(0, 1) + ""1"";
			if (position != -1) {
				mCards.get(position).put(""flags"", marSus);
			}
			mAllCards.get(posA).put(""flags"", marSus);
		} else {
			marSus = marSus.substring(0, 1) + ""0"";
			if (position != -1) {
				mCards.get(position).put(""flags"", marSus);
			}
			mAllCards.get(posA).put(""flags"", marSus);
		}
		updateList();
	}

	private void deleteCard(String cardId, int position) {
		if (mDeletedCards == null) {
			mDeletedCards = new ArrayList<HashMap<String, String>>();
		}
		HashMap<String, String> data = new HashMap<String, String>();
		for (int i = 0; i < mAllCards.size(); i++) {
			if (mAllCards.get(i).get(""id"").equals(cardId)) {
				data.put(""id"", mAllCards.get(i).get(""id""));
				data.put(""question"", mAllCards.get(i).get(""question""));
				data.put(""answer"", mAllCards.get(i).get(""answer""));
				data.put(""flags"", mAllCards.get(i).get(""flags""));
				data.put(""allCardPos"", Integer.toString(i));
				mDeletedCards.add(data);
				mAllCards.remove(i);
				// Log.i(AnkiDroidApp.TAG, ""Remove card from list"");
				break;
			}
		}
		mCards.remove(position);
		updateList();
	}

	private DeckTask.TaskListener mLoadCardsHandler = new DeckTask.TaskListener() {

		@Override
		public void onPreExecute() {
			if (!mUndoRedoDialogShowing) {
				mProgressDialog = ProgressDialog.show(CardBrowser.this, """",
						getResources().getString(R.string.card_browser_load),
						true);
			} else {
				mProgressDialog.setMessage(getResources().getString(
						R.string.card_browser_load));
				mUndoRedoDialogShowing = false;
			}
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			// This verification would not be necessary if
			// onConfigurationChanged it's executed correctly (which seems
			// that emulator does not do)
//			DeckTask.launchDeckTask(DeckTask.TASK_TYPE_SORT_CARDS, mSortCardsHandler, new DeckTask.TaskData(mAllCards, new HashMapCompare()));
			if (mProgressDialog.isShowing()) {
				try {
					mProgressDialog.dismiss();
				} catch (Exception e) {
					Log.e(AnkiDroidApp.TAG,
							""onPostExecute - Dialog dismiss Exception = ""
									+ e.getMessage());
				}
			}
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
			ArrayList<HashMap<String, String>> cards = values[0].getCards();
			if (cards == null) {
				Resources res = getResources();
				StyledDialog.Builder builder = new StyledDialog.Builder(
						CardBrowser.this);
				builder.setTitle(res.getString(R.string.error));
				builder.setIcon(android.R.drawable.ic_dialog_alert);
				builder.setMessage(res
						.getString(R.string.card_browser_cardloading_error));
				builder.setPositiveButton(res.getString(R.string.ok),
						new DialogInterface.OnClickListener() {
							@Override
							public void onClick(DialogInterface dialog,
									int which) {
								CardBrowser.this.finish();
							}
						});
				builder.setOnCancelListener(new OnCancelListener() {
					@Override
					public void onCancel(DialogInterface dialog) {
						CardBrowser.this.finish();
					}
				});
				builder.create().show();
			} else {
				if (mPrefFixArabic) {
					for (HashMap<String, String> entry : cards) {
						entry.put(""question"", ArabicUtilities.reshapeSentence(entry.get(""question"")));
						entry.put(""answer"", ArabicUtilities.reshapeSentence(entry.get(""answer"")));
					}
				}
				try {
					mAllCards.addAll(cards);
					mCards.addAll(cards);					
				} catch (OutOfMemoryError e) {
			    	Log.e(AnkiDroidApp.TAG, ""CardBrowser: mLoadCardsHandler: OutOfMemoryError: "" + e);
					Themes.showThemedToast(CardBrowser.this, getResources().getString(R.string.error_insufficient_memory), false);
			    	finish();
				}
				updateList();
			}
		}
	};

	private DeckTask.TaskListener mMarkCardHandler = new DeckTask.TaskListener() {
		@Override
		public void onPreExecute() {
			Resources res = getResources();
			mProgressDialog = ProgressDialog.show(CardBrowser.this, """", res
					.getString(R.string.saving_changes), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
			mSelectedCard = values[0].getCard();
			markCards(mSelectedCard.getFactId(), !mIsMarked);
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			mProgressDialog.dismiss();

		}
	};

	private DeckTask.TaskListener mSuspendCardHandler = new DeckTask.TaskListener() {
		@Override
		public void onPreExecute() {
			Resources res = getResources();
			mProgressDialog = ProgressDialog.show(CardBrowser.this, """", res
					.getString(R.string.saving_changes), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
			suspendCard(mSelectedCard, mPositionInCardsList, !mIsSuspended);
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			mProgressDialog.dismiss();
		}
	};

	private DeckTask.TaskListener mDeleteCardHandler = new DeckTask.TaskListener() {
		@Override
		public void onPreExecute() {
			Resources res = getResources();
			mProgressDialog = ProgressDialog.show(CardBrowser.this, """", res
					.getString(R.string.saving_changes), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			deleteCard(result.getString(), mPositionInCardsList);
			mProgressDialog.dismiss();

		}
	};


	private DeckTask.TaskListener mSortCardsHandler = new DeckTask.TaskListener() {
		@Override
		public void onPreExecute() {
			Resources res = getResources();
			if (mProgressDialog != null && mProgressDialog.isShowing()) {
				mProgressDialog.setMessage(res.getString(R.string.card_browser_sorting_cards));
			} else {
				mProgressDialog = ProgressDialog.show(CardBrowser.this, """", res
						.getString(R.string.card_browser_sorting_cards), true);				
			}
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			updateCardsList();
			if (mProgressDialog != null && mProgressDialog.isShowing()) {
				mProgressDialog.dismiss();
			}
		}
	};


	private DeckTask.TaskListener mUndoRedoHandler = new DeckTask.TaskListener() {
		@Override
		public void onPreExecute() {
			Resources res = getResources();
			mProgressDialog = ProgressDialog.show(CardBrowser.this, """", res
					.getString(R.string.saving_changes), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			mUndoRedoCardId = result.getLong();
			String undoType = result.getString();
			if (undoType.equals(Deck.UNDO_TYPE_DELETE_CARD)) {
				int position = getPosition(mDeletedCards, mUndoRedoCardId);
				if (position != -1) {
					HashMap<String, String> data = new HashMap<String, String>();
					data.put(""id"", mDeletedCards.get(position).get(""id""));
					data.put(""question"", mDeletedCards.get(position).get(
							""question""));
					data.put(""answer"", mDeletedCards.get(position)
							.get(""answer""));
					data.put(""flags"", mDeletedCards.get(position)
							.get(""flags""));
					mAllCards.add(Integer.parseInt(mDeletedCards.get(position)
							.get(""allCardPos"")), data);
					mDeletedCards.remove(position);
					updateCardsList();
				} else {
					deleteCard(Long.toString(mUndoRedoCardId), getPosition(
							mCards, mUndoRedoCardId));
				}
				mProgressDialog.dismiss();
			} else {
				mUndoRedoCard = mDeck.cardFromId(mUndoRedoCardId);
				if (undoType.equals(Deck.UNDO_TYPE_EDIT_CARD)) {
					mUndoRedoCard.fromDB(mUndoRedoCardId);
					int pos = getPosition(mAllCards, mUndoRedoCardId);
					updateCard(mUndoRedoCard, mAllCards, pos);
					pos = getPosition(mCards, mUndoRedoCardId);
					if (pos != -1) {
						updateCard(mUndoRedoCard, mCards, pos);
					}
					updateList();
					mProgressDialog.dismiss();
				} else if (undoType.equals(Deck.UNDO_TYPE_MARK_CARD)) {
					markCards(mUndoRedoCard.getFactId(), mUndoRedoCard
							.isMarked());
					mProgressDialog.dismiss();
				} else if (undoType.equals(Deck.UNDO_TYPE_SUSPEND_CARD)) {
					suspendCard(mUndoRedoCard, getPosition(mCards,
							mUndoRedoCardId), mUndoRedoCard.getSuspendedState());
					mProgressDialog.dismiss();
				} else {
					mUndoRedoDialogShowing = true;
					getCards();
				}
			}
		}
	};

	private DeckTask.TaskListener mUpdateCardHandler = new DeckTask.TaskListener() {
		@Override
		public void onPreExecute() {
			mProgressDialog = ProgressDialog.show(CardBrowser.this, """",
					getResources().getString(R.string.saving_changes), true);
		}

		@Override
		public void onProgressUpdate(DeckTask.TaskData... values) {
			mSelectedCard.fromDB(mSelectedCard.getId());
			int pos = getPosition(mAllCards, mSelectedCard.getId());
			updateCard(mSelectedCard, mAllCards, pos);
			pos = getPosition(mCards, mSelectedCard.getId());
			if (pos != -1) {
				updateCard(mSelectedCard, mCards, pos);
			}
			updateList();
		}

		@Override
		public void onPostExecute(DeckTask.TaskData result) {
			mProgressDialog.dismiss();
		}
	};

	public class SizeControlledListAdapter extends SimpleAdapter {

		private int fontSizeScalePcent;
		private float originalTextSize = -1.0f;

		public SizeControlledListAdapter(Context context,
				List<? extends Map<String, ?>> data, int resource,
				String[] from, int[] to, int fontSizeScalePcent) {
			super(context, data, resource, from, to);
			this.fontSizeScalePcent = fontSizeScalePcent;

		}

		public View getView(int position, View convertView, ViewGroup parent) {
			View view = super.getView(position, convertView, parent);

			// Iterate on all first level children
			if (view instanceof ViewGroup) {
				ViewGroup group = ((ViewGroup) view);
				View child;
				for (int i = 0; i < group.getChildCount(); i++) {
					child = group.getChildAt(i);
					// and set text size on all TextViews found
					if (child instanceof TextView) {
						// mBrowserFontSize
						float currentSize = ((TextView) child).getTextSize();
						if (originalTextSize < 0) {
							originalTextSize = ((TextView) child).getTextSize();
						}
						// do nothing when pref is 100% and apply scaling only
						// once
						if ((fontSizeScalePcent < 99 || fontSizeScalePcent > 101)
								&& (Math.abs(originalTextSize - currentSize) < 0.1)) {
							((TextView) child).setTextSize(
									TypedValue.COMPLEX_UNIT_SP,
									originalTextSize
											* (fontSizeScalePcent / 100.0f));
						}
					}

				}

			}

			return view;
		}
	}


	private class HashMapCompare implements
	Comparator<HashMap<String, String>> {
		@Override
		public int compare(HashMap<String, String> object1,
				HashMap<String, String> object2) {
		    try {
		    	int result;
		    	switch (mSelectedOrder) {
		    	case CARD_ORDER_ANSWER:
		    		result = object1.get(""answer"").compareToIgnoreCase(object2.get(""answer""));
		    		if (result == 0) {
		    			result = object1.get(""question"").compareToIgnoreCase(object2.get(""question""));
		    		}
		    		return result;
		    	case CARD_ORDER_QUESTION:
		    		result = object1.get(""question"").compareToIgnoreCase(object2.get(""question""));
		    		if (result == 0) {
		    			result = object1.get(""answer"").compareToIgnoreCase(object2.get(""answer""));
		    		}
		    		return result;
		    	case CARD_ORDER_DUE:
		    		result = Double.valueOf(object1.get(""due"")).compareTo(Double.valueOf(object2.get(""due"")));
		    		if (result == 0) {
		    			Long.valueOf(object1.get(""id"")).compareTo(Long.valueOf(object2.get(""id"")));
		    		}
		    		return result;
		    	case CARD_ORDER_INTERVAL:
		    		result = Double.valueOf(object1.get(""interval"")).compareTo(Double.valueOf(object2.get(""interval"")));
		    		if (result == 0) {
		    			Long.valueOf(object1.get(""id"")).compareTo(Long.valueOf(object2.get(""id"")));
		    		}
		    		return result;
		    	case CARD_ORDER_FACTOR:
		    		result = Double.valueOf(object1.get(""factor"")).compareTo(Double.valueOf(object2.get(""factor"")));
		    		if (result == 0) {
		    			Long.valueOf(object1.get(""id"")).compareTo(Long.valueOf(object2.get(""id"")));
		    		}
		    		return result;
		    	case CARD_ORDER_CREATED:
		    		result = Double.valueOf(object1.get(""created"")).compareTo(Double.valueOf(object2.get(""created"")));
		    		if (result == 0) {
		    			Long.valueOf(object1.get(""id"")).compareTo(Long.valueOf(object2.get(""id"")));
		    		}
		    		return result;
		    	}
		    	return 0;
		    }
		    catch (Exception e) {
		    	Log.e(AnkiDroidApp.TAG, ""Error on sorting cards: "" + e);
		        return 0;
		    }
		}
	}

}
",True,66,63,0,0,4,25
50,com.ichi2.anki.MetaDB.java,"package com.ichi2.anki;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.tomgibara.android.veecheck.util.PrefSettings;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.util.Log;


/**
 * Used to store additional information besides what is stored in the deck itself.
 * <p>
 * Currently it used to store:
 * <ul>
 *   <li>The languages associated with questions and answers.</li>
 *   <li>The state of the whiteboard.</li>
 *   <li>The cached state of the widget.</li>
 * </ul>
 */
public class MetaDB {
    /** The name of the file storing the meta-db. */
    private static final String DATABASE_NAME = ""ankidroid.db"";

    // Possible values for the qa column of the languages table.
    /** The language refers to the question. */
    public static final int LANGUAGES_QA_QUESTION = 0;
    /** The language refers to the answer. */
    public static final int LANGUAGES_QA_ANSWER = 1;
    /** The language does not refer to either the question or answer. */
    public static final int LANGUAGES_QA_UNDEFINED = 2;

    /** The pattern used to remove quotes from file names. */
    private static final Pattern quotePattern = Pattern.compile(""[\""']"");

    /** The database object used by the meta-db. */
    private static SQLiteDatabase mMetaDb = null;


    /** Remove any pairs of quotes from the given text. */
    private static String stripQuotes(String text) {
        Matcher matcher = quotePattern.matcher(text);
        text = matcher.replaceAll("""");
        return text;
    }


    /** Open the meta-db and creates any table that is missing. */
    private static void openDB(Context context) {
        try {
            mMetaDb = context.openOrCreateDatabase(DATABASE_NAME,  0, null);
            mMetaDb.execSQL(
                    ""CREATE TABLE IF NOT EXISTS languages (""
                            + "" _id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                            + ""deckpath TEXT NOT NULL, modelid INTEGER NOT NULL, ""
                            + ""cardmodelid INTEGER NOT NULL, ""
                            + ""qa INTEGER, ""
                            + ""language TEXT)"");
            mMetaDb.execSQL(
                    ""CREATE TABLE IF NOT EXISTS whiteboardState (""
                            + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                            + ""deckpath TEXT NOT NULL, ""
                            + ""state INTEGER)"");
            mMetaDb.execSQL(
                    ""CREATE TABLE IF NOT EXISTS customDictionary (""
                            + ""_id INTEGER PRIMARY KEY AUTOINCREMENT, ""
                            + ""deckpath TEXT NOT NULL, ""
                            + ""dictionary INTEGER)"");
            mMetaDb.execSQL(
                    ""CREATE TABLE IF NOT EXISTS widgetStatus (""
                    + ""deckPath TEXT NOT NULL PRIMARY KEY, ""
                    + ""deckName TEXT NOT NULL, ""
                    + ""newCards INTEGER NOT NULL, ""
                    + ""dueCards INTEGER NOT NULL, ""
                    + ""failedCards INTEGER NOT NULL, ""
            		+ ""eta INTEGER NOT NULL, ""
            		+ ""time INTEGER NOT NULL)"");
        // Log.i(AnkiDroidApp.TAG, ""Opening MetaDB"");
        } catch(Exception e) {
            Log.e(""Error"", ""Error opening MetaDB "", e);
        }
    }


    /** Open the meta-db but only if it currently closed. */
    private static void openDBIfClosed(Context context) {
        if (mMetaDb == null || !mMetaDb.isOpen()) {
            openDB(context);
        }
    }


    /** Close the meta-db. */
    public static void closeDB() {
        if (mMetaDb != null && mMetaDb.isOpen()) {
            mMetaDb.close();
            mMetaDb = null;
            // Log.i(AnkiDroidApp.TAG, ""Closing MetaDB"");
        }
    }


    /** Reset the content of the meta-db, erasing all its content. */
    public static boolean resetDB(Context context) {
        openDBIfClosed(context);
        try {
            mMetaDb.execSQL(""DROP TABLE IF EXISTS languages;"");
            // Log.i(AnkiDroidApp.TAG, ""Resetting all language assignment"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS whiteboardState;"");
            // Log.i(AnkiDroidApp.TAG, ""Resetting whiteboard state"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS customDictionary;"");
            // Log.i(AnkiDroidApp.TAG, ""Resetting custom Dictionary"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS widgetStatus;"");
            // Log.i(AnkiDroidApp.TAG, ""Resetting widget status"");
            return true;
        } catch(Exception e) {
            Log.e(""Error"", ""Error resetting MetaDB "", e);
        }
        return false;
    }


    /** Reset the language associations for all the decks and card models. */
    public static boolean resetLanguages(Context context) {
        if (mMetaDb == null || !mMetaDb.isOpen()) {
            openDB(context);
        }
        try {
            // Log.i(AnkiDroidApp.TAG, ""Resetting all language assignments"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS languages;"");
            openDB(context);
            return true;
        } catch(Exception e) {
            Log.e(""Error"", ""Error resetting MetaDB "", e);
        }
        return false;
    }


    /** Reset the widget status. */
    public static boolean resetWidget(Context context) {
        if (mMetaDb == null || !mMetaDb.isOpen()) {
            openDB(context);
        }
        try {
            // Log.i(AnkiDroidApp.TAG, ""Resetting widget status"");
            mMetaDb.execSQL(""DROP TABLE IF EXISTS widgetStatus;"");
            openDB(context);
            return true;
        } catch(Exception e) {
            Log.e(""Error"", ""Error resetting MetaDB "", e);
        }
        return false;
    }

    /**
     * Associates a language to a deck, model, and card model for a given type.
     *
     * @param deckPath the deck for which to store the language association
     * @param modelId the model for which to store the language association
     * @param cardModelId the card model for which to store the language association
     * @param qa the part of the card for which to store the association, {@link #LANGUAGES_QA_QUESTION},
     *           {@link #LANGUAGES_QA_ANSWER}, or {@link #LANGUAGES_QA_UNDEFINED}
     * @param language the language to associate, as a two-characters, lowercase string
     */
    public static void storeLanguage(Context context, String deckPath, long modelId, long cardModelId, int qa,
            String language) {
        openDBIfClosed(context);
        deckPath = stripQuotes(deckPath);
        try {
            mMetaDb.execSQL(
                    ""INSERT INTO languages (deckpath, modelid, cardmodelid, qa, language) ""
                            + "" VALUES (?, ?, ?, ?, ?);"",
                            new Object[]{deckPath, modelId, cardModelId, qa, language});
            // Log.i(AnkiDroidApp.TAG, ""Store language for deck "" + deckPath);
        } catch(Exception e) {
            Log.e(""Error"", ""Error storing language in MetaDB "", e);
        }
    }


    /**
     * Returns the language associated with the given deck, model and card model, for the given type.
     *
     * @param deckPath the deck for which to store the language association
     * @param modelId the model for which to store the language association
     * @param cardModelId the card model for which to store the language association
     * @param qa the part of the card for which to store the association, {@link #LANGUAGES_QA_QUESTION},
     *           {@link #LANGUAGES_QA_ANSWER}, or {@link #LANGUAGES_QA_UNDEFINED}
     * return the language associate with the type, as a two-characters, lowercase string, or the empty string if no
     *        association is defined
     */
    public static String getLanguage(Context context, String deckPath, long modelId, long cardModelId, int qa) {
        openDBIfClosed(context);
        String language = """";
        deckPath = stripQuotes(deckPath);
        Cursor cur = null;
        try {
            String query =
                    ""SELECT language FROM languages ""
                            + ""WHERE deckpath = \'"" + deckPath+ ""\' ""
                            + ""AND modelid = "" + modelId + "" ""
                            + ""AND cardmodelid = "" + cardModelId + "" ""
                            + ""AND qa = "" + qa + "" ""
                            + ""LIMIT 1"";
            cur = mMetaDb.rawQuery(query, null);
            // Log.i(AnkiDroidApp.TAG, ""getLanguage: "" + query);
            if (cur.moveToNext()) {
                language = cur.getString(0);
            }
        } catch(Exception e) {
            Log.e(""Error"", ""Error fetching language "", e);
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        return language;
    }


    /**
     * Resets all the language associates for a given deck.
     *
     * @param deckPath the deck for which to reset the language associations
     * @return whether an error occurred while resetting the language for the deck
     */
    public static boolean resetDeckLanguages(Context context, String deckPath) {
        openDBIfClosed(context);
        deckPath = stripQuotes(deckPath);
        try {
            mMetaDb.execSQL(""DELETE FROM languages WHERE deckpath = \'"" + deckPath + ""\';"");
            // Log.i(AnkiDroidApp.TAG, ""Resetting language assignment for deck "" + deckPath);
            return true;
        } catch(Exception e) {
            Log.e(""Error"", ""Error resetting deck language"", e);
        }
        return false;
    }


    /**
     * Returns the state of the whiteboard for the given deck.
     *
     * @param deckPath the deck for which to retrieve the whiteboard state
     * @return 1 if the whiteboard should be shown, 0 otherwise
     */
    public static int getWhiteboardState(Context context, String deckPath) {
        openDBIfClosed(context);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery(""SELECT state FROM whiteboardState""
                    + "" WHERE deckpath = \'"" + stripQuotes(deckPath) + ""\'"", null);
            if (cur.moveToNext()) {
                return cur.getInt(0);
            } else {
                return 0;
            }
        } catch(Exception e) {
            Log.e(""Error"", ""Error retrieving whiteboard state from MetaDB "", e);
            return 0;
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Stores the state of the whiteboard for a given deck.
     *
     * @param deckPath the deck for which to store the whiteboard state
     * @param state 1 if the whiteboard should be shown, 0 otherwise
     */
    public static void storeWhiteboardState(Context context, String deckPath, int state) {
        openDBIfClosed(context);
        deckPath = stripQuotes(deckPath);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery(""SELECT _id FROM whiteboardState""
                    + "" WHERE deckpath = \'"" + deckPath + ""\'"", null);
            if (cur.moveToNext()) {
                mMetaDb.execSQL(""UPDATE whiteboardState ""
                        + ""SET deckpath=\'"" + deckPath + ""\', ""
                        + ""state="" + Integer.toString(state) + "" ""
                        + ""WHERE _id="" + cur.getString(0) + "";"");
                // Log.i(AnkiDroidApp.TAG, ""Store whiteboard state ("" + state + "") for deck "" + deckPath);
            } else {
                mMetaDb.execSQL(""INSERT INTO whiteboardState (deckpath, state) VALUES (?, ?)"",
                        new Object[]{deckPath, state});
                // Log.i(AnkiDroidApp.TAG, ""Store whiteboard state ("" + state + "") for deck "" + deckPath);
            }
        } catch(Exception e) {
            Log.e(""Error"", ""Error storing whiteboard state in MetaDB "", e);
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Returns a custom dictionary associated to a deck
     *
     * @param deckPath the deck for which a custom dictionary should be retrieved
     * @return integer number of dictionary, -1 if not set (standard dictionary will be used)
     */
    public static int getLookupDictionary(Context context, String deckPath) {
        openDBIfClosed(context);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery(""SELECT dictionary FROM customDictionary""
                    + "" WHERE deckpath = \'"" + stripQuotes(deckPath) + ""\'"", null);
            if (cur.moveToNext()) {
                return cur.getInt(0);
            } else {
                return -1;
            }
        } catch(Exception e) {
            Log.e(""Error"", ""Error retrieving custom dictionary from MetaDB "", e);
            return -1;
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Stores a custom dictionary for a given deck.
     *
     * @param deckPath the deck for which a custom dictionary should be retrieved
     * @param dictionary integer number of dictionary, -1 if not set (standard dictionary will be used)
     */
    public static void storeLookupDictionary(Context context, String deckPath, int dictionary) {
        openDBIfClosed(context);
        deckPath = stripQuotes(deckPath);
        Cursor cur = null;
        try {
            cur = mMetaDb.rawQuery(""SELECT _id FROM customDictionary""
                    + "" WHERE deckpath = \'"" + deckPath + ""\'"", null);
            if (cur.moveToNext()) {
                mMetaDb.execSQL(""UPDATE customDictionary ""
                        + ""SET deckpath=\'"" + deckPath + ""\', ""
                        + ""dictionary="" + Integer.toString(dictionary) + "" ""
                        + ""WHERE _id="" + cur.getString(0) + "";"");
                // Log.i(AnkiDroidApp.TAG, ""Store custom dictionary ("" + dictionary + "") for deck "" + deckPath);
            } else {
                mMetaDb.execSQL(""INSERT INTO customDictionary (deckpath, dictionary) VALUES (?, ?)"",
                        new Object[]{deckPath, dictionary});
                // Log.i(AnkiDroidApp.TAG, ""Store custom dictionary ("" + dictionary + "") for deck "" + deckPath);
            }
        } catch(Exception e) {
            Log.e(""Error"", ""Error storing custom dictionary to MetaDB "", e);
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }


    /**
     * Return the current status of the widget.
     *
     * @return an array of {@link DeckStatus} objects, each representing the status of one of the known decks
     */
    public static DeckStatus[] getWidgetStatus(Context context) {
        openDBIfClosed(context);
        Cursor cursor = null;
        try {
            cursor = mMetaDb.query(""widgetStatus"",
                    new String[]{""deckPath"", ""deckName"", ""newCards"", ""dueCards"", ""failedCards"", ""eta"", ""time""},
                    null, null, null, null, ""deckName"");
            int count = cursor.getCount();
            DeckStatus[] decks = new DeckStatus[count];
            for(int index = 0; index < count; ++index) {
                if (!cursor.moveToNext()) {
                    throw new SQLiteException(""cursor count was incorrect"");
                }
                decks[index] = new DeckStatus(
                        cursor.getString(cursor.getColumnIndexOrThrow(""deckPath"")),
                        cursor.getString(cursor.getColumnIndexOrThrow(""deckName"")),
                        cursor.getInt(cursor.getColumnIndexOrThrow(""newCards"")),
                        cursor.getInt(cursor.getColumnIndexOrThrow(""dueCards"")),
                        cursor.getInt(cursor.getColumnIndexOrThrow(""failedCards"")),
                        cursor.getInt(cursor.getColumnIndexOrThrow(""eta"")),
                		cursor.getInt(cursor.getColumnIndexOrThrow(""time"")));
            }
            return decks;
        } catch (SQLiteException e) {
            Log.e(AnkiDroidApp.TAG, ""Error while querying widgetStatus"", e);
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        return new DeckStatus[0];
    }


    /**
     * Return the current status of the widget.
     *
     * @return an int array, containing due, time, eta, currentDeckdue
     */
    public static int[] getWidgetSmallStatus(Context context) {
        openDBIfClosed(context);
        Cursor cursor = null;
        int due = 0;
        int eta = 0;
        int time = 0;
        boolean noDeck = true;
        try {
            cursor = mMetaDb.query(""widgetStatus"",
                    new String[]{""dueCards"", ""failedCards"", ""newCards"", ""time"", ""eta""},
                    null, null, null, null, null);
            while (cursor.moveToNext()) {
            	noDeck = false;
            	int d = cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
            	due += d;
            	time += cursor.getInt(3);
            	eta += cursor.getInt(4);
            }
        } catch (SQLiteException e) {
            Log.e(AnkiDroidApp.TAG, ""Error while querying widgetStatus"", e);
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        return new int[]{noDeck ? -1 : due, time, eta};
    }


    public static int getNotificationStatus(Context context) {
        openDBIfClosed(context);
        Cursor cursor = null;
        int due = 0;
        try {
            cursor = mMetaDb.query(""widgetStatus"",
                    new String[]{""dueCards"", ""failedCards"", ""newCards""},
                    null, null, null, null, null);
            while (cursor.moveToNext()) {
            	due += cursor.getInt(0) + cursor.getInt(1) + cursor.getInt(2);
            }
        } catch (SQLiteException e) {
            Log.e(AnkiDroidApp.TAG, ""Error while querying widgetStatus"", e);
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        return due;
    }


    /**
     * Stores the current state of the widget.
     * <p>
     * It replaces any stored state for the widget.
     *
     * @param decks an array of {@link DeckStatus} objects, one for each of the know decks.
     */
    public static void storeWidgetStatus(Context context, DeckStatus[] decks) {
        openDBIfClosed(context);
        try {
            mMetaDb.beginTransaction();
            // First clear all the existing content.
            mMetaDb.execSQL(""DELETE FROM widgetStatus"");
            for (DeckStatus deck : decks) {
                mMetaDb.execSQL(""INSERT INTO widgetStatus(deckPath, deckName, newCards, dueCards, failedCards, eta, time) ""
                        + ""VALUES (?, ?, ?, ?, ?, ?, ?)"",
                        new Object[]{deck.mDeckPath, deck.mDeckName, deck.mNewCards, deck.mDueCards, deck.mFailedCards, deck.mEta, deck.mTime}
                        );
            }
            mMetaDb.setTransactionSuccessful();
            mMetaDb.endTransaction();
        } catch (IllegalStateException e) {
            Log.e(AnkiDroidApp.TAG, ""MetaDB.storeWidgetStatus: failed"", e);
        } catch (SQLiteException e) {
            Log.e(AnkiDroidApp.TAG, ""MetaDB.storeWidgetStatus: failed"", e);
            closeDB();
            // Log.i(AnkiDroidApp.TAG, ""Trying to reset Widget: "" + resetWidget(context));
        }
    }
}
",True,40,64,1,1,5,27
51,com.ichi2.anki.AnkiDatabaseManager.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import java.util.HashMap;
import java.util.Set;

public class AnkiDatabaseManager {

    private static HashMap<String, AnkiDb> sAnkiDatabases = new HashMap<String, AnkiDb>();

    /* Prevent class from being instantiated */
    private AnkiDatabaseManager() { }

    /**
     * Get a reference over an Anki database, creating the connection if needed.
     * @param pathDB the path to the database.
     * @return the Anki database.
     */
    public static AnkiDb getDatabase(String pathDB) {
    	return getDatabase(pathDB, false);
    }
    public static AnkiDb getDatabase(String pathDB, boolean forceDeleteJournalMode) {
    	if (forceDeleteJournalMode) {
    		closeDatabase(pathDB);
    	}

        // If the DB is already opened
        if (sAnkiDatabases.containsKey(pathDB)) {
            return sAnkiDatabases.get(pathDB);
        }

        // If a connection to the desired DB does not exist, we create it
        AnkiDb ankiDB = new AnkiDb(pathDB, forceDeleteJournalMode);

        // Insert the new DB to the map of opened DBs
        sAnkiDatabases.put(pathDB, ankiDB);

        return ankiDB;
    }


    /**
     * Close connection to a given database.
     * @param pathDB the path to the database to close.
     */
    public static void closeDatabase(String pathDB) {
        AnkiDb ankiDB = sAnkiDatabases.remove(pathDB);
        if (ankiDB != null) {
            ankiDB.closeDatabase();
        }
    }


    /**
     * Close connections to all opened databases.
     * XXX Currently unused.
     */
    public static void closeAllDatabases() {
        Set<String> databases = sAnkiDatabases.keySet();
        for (String pathDB : databases) {
            AnkiDatabaseManager.closeDatabase(pathDB);
        }
    }


    /**
     * Check if there is a valid connection to the given database.
     * @param pathDB the path to the database we want to check.
     * @return True if the database is already opened, false otherwise.
     */
    public static boolean isDatabaseOpen(String pathDB) {
        return sAnkiDatabases.containsKey(pathDB);
    }
}
",False,44,63,0,0,6,23
52,com.ichi2.anki.Deck.java,"/****************************************************************************************
 * Copyright (c) 2009 Daniel Svärd <daniel.svard@gmail.com>                             *
 * Copyright (c) 2009 Casey Link <unnamedrambler@gmail.com>                             *
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 * Copyright (c) 2010 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.ContentValues;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteStatement;
import android.util.Log;

import com.ichi2.anki.Fact.Field;
import com.ichi2.anki.Utils.SqlCommandType;

import org.json.JSONException;
import org.json.JSONObject;

import java.io.File;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Date;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * A deck stores all of the cards and scheduling information. It is saved in a file with a name ending in .anki See
 * http://ichi2.net/anki/wiki/KeyTermsAndConcepts#Deck
 */
public class Deck {

    public static final String TAG_MARKED = ""Marked"";

    public static final int DECK_VERSION = 65;

    private static final int NEW_CARDS_DISTRIBUTE = 0;
    private static final int NEW_CARDS_LAST = 1;
    private static final int NEW_CARDS_FIRST = 2;

    private static final int NEW_CARDS_RANDOM = 0;
    private static final int NEW_CARDS_OLD_FIRST = 1;
    private static final int NEW_CARDS_NEW_FIRST = 2;

    private static final int REV_CARDS_OLD_FIRST = 0;
    private static final int REV_CARDS_NEW_FIRST = 1;
    private static final int REV_CARDS_DUE_FIRST = 2;
    private static final int REV_CARDS_RANDOM = 3;

    public static final double FACTOR_FOUR = 1.3;
    public static final double INITIAL_FACTOR = 2.5;
    private static final double MINIMUM_AVERAGE = 1.7;
    private static final double MAX_SCHEDULE_TIME = 36500.0;

    public static final String UNDO_TYPE_ANSWER_CARD = ""Answer Card"";
    public static final String UNDO_TYPE_SUSPEND_CARD = ""Suspend Card"";
    public static final String UNDO_TYPE_EDIT_CARD = ""Edit Card"";
    public static final String UNDO_TYPE_MARK_CARD = ""Mark Card"";
    public static final String UNDO_TYPE_BURY_CARD = ""Bury Card"";
    public static final String UNDO_TYPE_DELETE_CARD = ""Delete Card"";

    public String mCurrentUndoRedoType = """";


    // Card order strings for building SQL statements
    private static final String[] revOrderStrings = { ""priority desc, interval desc"", ""priority desc, interval"",
            ""priority desc, combinedDue"", ""priority desc, RANDOM()"" };
    private static final String[] newOrderStrings = { ""priority desc, RANDOM()"", ""priority desc, due"",
            ""priority desc, due desc"" };

    // BEGIN: SQL table columns
    private long mId;
    private double mCreated;
    private double mModified;
    private String mDescription;
    private int mVersion;
    private long mCurrentModelId;

    // syncName stores an md5sum of the deck path when syncing is enabled.
    // If it doesn't match the current deck path, the deck has been moved,
    // and syncing is disabled on load.
    private String mSyncName;
    private double mLastSync;

    private boolean mNeedUnpack = false;

    // Scheduling
    // Initial intervals
    private double mHardIntervalMin;
    private double mHardIntervalMax;
    private double mMidIntervalMin;
    private double mMidIntervalMax;
    private double mEasyIntervalMin;
    private double mEasyIntervalMax;

    // Delays on failure
    private long mDelay0;
    // Days to delay mature fails
    private long mDelay1;
    private double mDelay2;

    // Collapsing future cards
    private double mCollapseTime;

    // Priorities and postponing
    private String mHighPriority;
    private String mMedPriority;
    private String mLowPriority;
    private String mSuspended; // obsolete in libanki 1.1

    // Can be NEW_CARDS_RANDOM, NEW_CARDS_OLD_FIRST or NEW_CARDS_NEW_FIRST, i.e. random, by input date or by input date inverse. Should be an enum.
    private int mNewCardOrder;

    // When to show new cards
    private int mNewCardSpacing;

    // New card spacing global variable
    private double mNewSpacing;
    private double mRevSpacing;
    private boolean mNewFromCache;

    // Limit the number of failed cards in play
    private int mFailedCardMax;

    // Number of new cards to show per day
    private int mNewCardsPerDay;

    // Currently unused
    private long mSessionRepLimit;
    private long mSessionTimeLimit;

    // Stats offset
    private double mUtcOffset;

    // Count cache
    private int mCardCount;
    private int mFactCount;
    private int mFailedNowCount; // obsolete in libanki 1.1
    private int mFailedSoonCount;
    private int mRevCount;
    private int mNewCount;

    // Review order
    private int mRevCardOrder;

    // END: SQL table columns

    // BEGIN JOINed variables
    // Model currentModel; // Deck.currentModelId = Model.id
    // ArrayList<Model> models; // Deck.id = Model.deckId
    // END JOINed variables

    private double mAverageFactor;
    private int mNewCardModulus;
    private int mNewCountToday;
    private double mLastLoaded;
    private boolean mNewEarly;
    private boolean mReviewEarly;
    private String mMediaPrefix;

    private double mDueCutoff;
    private double mFailedCutoff;

    private String mScheduler;

    // Any comments resulting from upgrading the deck should be stored here, both in success and failure
    private ArrayList<Integer> upgradeNotes;

    // Queues
    private LinkedList<QueueItem> mFailedQueue;
    private LinkedList<QueueItem> mRevQueue;
    private LinkedList<QueueItem> mNewQueue;
    private LinkedList<QueueItem> mFailedCramQueue;
    private HashMap<Long, Double> mSpacedFacts;
    private LinkedList<SpacedCardsItem> mSpacedCards;
    private int mQueueLimit;

    // Cramming
    private String[] mActiveCramTags;
    private String mCramOrder;

    // Not in Anki Desktop
    private String mDeckPath;
    private String mDeckName;

    private Stats mGlobalStats;
    private Stats mDailyStats;

    private long mCurrentCardId;
    
    private int markedTagId = 0;

    private HashMap<String, String> mDeckVars = new HashMap<String, String>();

    /**
     * Undo/Redo variables.
     */
    private Stack<UndoRow> mUndoStack;
    private Stack<UndoRow> mRedoStack;
    private boolean mUndoEnabled = false;
    private Stack<UndoRow> mUndoRedoStackToRecord = null;


    public static synchronized Deck openDeck(String path) throws SQLException {
        return openDeck(path, true);
    }
    public static synchronized Deck openDeck(String path, boolean rebuild) throws SQLException {
    	return openDeck(path, rebuild, false);
    }
    public static synchronized Deck openDeck(String path, boolean rebuild, boolean forceDeleteJournalMode) throws SQLException {
	// first do a backup if last backup is very old or not existing
	// this is normally done on loading in studyoptions (full) or loading in deckpicker
	// nevertheless, it's still necessary to check here, if it has been really done because other routines open decks too (widget, card editor, syncing)
	// a cache variable will indicate, if the deck has been already treated
    	if (BackupManager.safetyBackupNeeded(path, BackupManager.SAFETY_BACKUP_THRESHOLD)) {
    		// Log.i(AnkiDroidApp.TAG, ""openDeck: Backup needed"");
    		if (BackupManager.backupDeck(path) == BackupManager.RETURN_BACKUP_CREATED) {
    			// Log.i(AnkiDroidApp.TAG, ""openDeck: Backup successfully created"");
    		} else {
    			Log.e(AnkiDroidApp.TAG, ""openDeck: Backup creation failed"");
    		}
    	}

        Deck deck = null;
        Cursor cursor = null;
        // Log.i(AnkiDroidApp.TAG, ""openDeck - Opening database "" + path);
        AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(path, forceDeleteJournalMode);

        try {
            // Read in deck table columns
            cursor = ankiDB.getDatabase().rawQuery(""SELECT * FROM decks LIMIT 1"", null);

            if (!cursor.moveToFirst()) {
                return null;
            }

            deck = new Deck();

            deck.mId = cursor.getLong(0);
            deck.mCreated = cursor.getDouble(1);
            deck.mModified = cursor.getDouble(2);
            deck.mDescription = cursor.getString(3);
            deck.mVersion = cursor.getInt(4);
            deck.mCurrentModelId = cursor.getLong(5);
            deck.mSyncName = cursor.getString(6);
            deck.mLastSync = cursor.getDouble(7);
            deck.mHardIntervalMin = cursor.getDouble(8);
            deck.mHardIntervalMax = cursor.getDouble(9);
            deck.mMidIntervalMin = cursor.getDouble(10);
            deck.mMidIntervalMax = cursor.getDouble(11);
            deck.mEasyIntervalMin = cursor.getDouble(12);
            deck.mEasyIntervalMax = cursor.getDouble(13);
            deck.mDelay0 = cursor.getLong(14);
            deck.mDelay1 = cursor.getLong(15);
            deck.mDelay2 = cursor.getDouble(16);
            deck.mCollapseTime = cursor.getDouble(17);
            deck.mHighPriority = cursor.getString(18);
            deck.mMedPriority = cursor.getString(19);
            deck.mLowPriority = cursor.getString(20);
            deck.mSuspended = cursor.getString(21);
            deck.mNewCardOrder = cursor.getInt(22);
            deck.mNewCardSpacing = cursor.getInt(23);
            deck.mFailedCardMax = cursor.getInt(24);
            deck.mNewCardsPerDay = cursor.getInt(25);
            deck.mSessionRepLimit = cursor.getInt(26);
            deck.mSessionTimeLimit = cursor.getInt(27);
            deck.mUtcOffset = cursor.getDouble(28);
            deck.mCardCount = cursor.getInt(29);
            deck.mFactCount = cursor.getInt(30);
            deck.mFailedNowCount = cursor.getInt(31);
            deck.mFailedSoonCount = cursor.getInt(32);
            deck.mRevCount = cursor.getInt(33);
            deck.mNewCount = cursor.getInt(34);
            deck.mRevCardOrder = cursor.getInt(35);

            // Log.i(AnkiDroidApp.TAG, ""openDeck - Read "" + cursor.getColumnCount() + "" columns from decks table."");
        } catch (SQLiteException e) {
            return null;
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        // Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""openDeck - modified: %f currentTime: %f"", deck.mModified, Utils.now()));

        // Initialise queues
        deck.mFailedQueue = new LinkedList<QueueItem>();
        deck.mRevQueue = new LinkedList<QueueItem>();
        deck.mNewQueue = new LinkedList<QueueItem>();
        deck.mFailedCramQueue = new LinkedList<QueueItem>();
        deck.mSpacedFacts = new HashMap<Long, Double>();
        deck.mSpacedCards = new LinkedList<SpacedCardsItem>();

        deck.mDeckPath = path;
        deck.initDeckvarsCache();
        deck.mDeckName = (new File(path)).getName().replace("".anki"", """");

        if (deck.mVersion < DECK_VERSION) {
            deck.createMetadata();
        }

        deck.mNeedUnpack = false;
        if (Math.abs(deck.getUtcOffset() - 1.0) < 1e-9 || Math.abs(deck.getUtcOffset() - 2.0) < 1e-9) {
            // do the rest later
            deck.mNeedUnpack = (Math.abs(deck.getUtcOffset() - 1.0) < 1e-9);
            // make sure we do this before initVars
            deck.setUtcOffset();
            deck.mCreated = Utils.now();
        }

        deck.initVars();

        // Upgrade to latest version
        deck.upgradeDeck();

        if (!rebuild) {
            // Minimal startup for deckpicker: only counts are needed
            deck.mGlobalStats = Stats.globalStats(deck);
            deck.mDailyStats = Stats.dailyStats(deck);
            deck.rebuildCounts();
            return deck;
        }

        if (deck.mNeedUnpack) {
            deck.addIndices();
        }

        double oldMod = deck.mModified;

        // Ensure necessary indices are available
        deck.updateDynamicIndices();

        // FIXME: Temporary code for upgrade - ensure cards suspended on older clients are recognized
        // Ensure cards suspended on older clients are recognized
        deck.getDB().getDatabase().execSQL(
                ""UPDATE cards SET type = type - 3 WHERE type BETWEEN 0 AND 2 AND priority = -3"");

        // - New delay1 handling
        if (deck.mDelay1 > 7l) {
            deck.mDelay1 = 0l;
        }

        ArrayList<Long> ids = new ArrayList<Long>();
        // Unsuspend buried/rev early - can remove priorities in the future
        ids = deck.getDB().queryColumn(Long.class,
                ""SELECT id FROM cards WHERE type > 2 OR (priority BETWEEN -2 AND -1)"", 0);
        if (!ids.isEmpty()) {
            deck.updatePriorities(Utils.toPrimitive(ids));
            deck.getDB().getDatabase().execSQL(""UPDATE cards SET type = relativeDelay WHERE type > 2"");
            // Save deck to database
            deck.commitToDB();
        }

        // Determine starting factor for new cards
        Cursor cur = null;
        try {
            cur = deck.getDB().getDatabase().rawQuery(""SELECT avg(factor) FROM cards WHERE type = 1"", null);
            if (cur.moveToNext()) {
                deck.mAverageFactor = cur.getDouble(0);
            } else {
                deck.mAverageFactor = INITIAL_FACTOR;
            }
            if (deck.mAverageFactor == 0.0) {
                deck.mAverageFactor = INITIAL_FACTOR;
            }
        } catch (Exception e) {
            deck.mAverageFactor = INITIAL_FACTOR;
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        deck.mAverageFactor = Math.max(deck.mAverageFactor, MINIMUM_AVERAGE);

        // Rebuild queue
        deck.reset();
        // Make sure we haven't accidentally bumped the modification time
        double dbMod = 0.0;
        try {
            cur = deck.getDB().getDatabase().rawQuery(""SELECT modified FROM decks"", null);
            if (cur.moveToNext()) {
                dbMod = cur.getDouble(0);
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        assert Math.abs(dbMod - oldMod) < 1.0e-9;
        assert deck.mModified == oldMod;
        // 4.3.2011: deactivated since it's not used anywhere
        // Create a temporary view for random new cards. Randomizing the cards by themselves
        // as is done in desktop Anki in Deck.randomizeNewCards() takes too long.
//        try {
//            deck.getDB().getDatabase().execSQL(
//                    ""CREATE TEMPORARY VIEW acqCardsRandom AS SELECT * FROM cards "" + ""WHERE type = "" + Card.TYPE_NEW
//                            + "" AND isDue = 1 ORDER BY RANDOM()"");
//        } catch (SQLException e) {
//            /* Temporary view may still be present if the DB has not been closed */
//            // Log.i(AnkiDroidApp.TAG, ""Failed to create temporary view: "" + e.getMessage());
//        }

        // Initialize Undo
        deck.initUndo();
        return deck;
    }


    public void createMetadata() {
        // Just create table deckvars for now
        getDB().getDatabase().execSQL(
                ""CREATE TABLE IF NOT EXISTS deckVars (\""key\"" TEXT NOT NULL, value TEXT, "" + ""PRIMARY KEY (\""key\""))"");
    }


    public synchronized void closeDeck() {
    	closeDeck(true);
    }

    public synchronized void closeDeck(boolean wait) {
        if (wait) {
        	DeckTask.waitToFinish(); // Wait for any thread working on the deck to finish.
        }
        if (finishSchedulerMethod != null) {
            finishScheduler();
            reset();
        }
        if (modifiedSinceSave()) {
            commitToDB();
        }
        AnkiDatabaseManager.closeDatabase(mDeckPath);
    }


    public static synchronized int getDeckVersion(String path) throws SQLException {
        int version = (int) AnkiDatabaseManager.getDatabase(path).queryScalar(""SELECT version FROM decks LIMIT 1"");
        return version;
    }


    public Fact newFact(Long modelId) {
    	Model m = Model.getModel(this, modelId, true);
    	Fact mFact = new Fact(this, m);
        return mFact;
    }


    public Fact newFact() {
        Model m = Model.getModel(this, getCurrentModelId(), true);
        Fact mFact = new Fact(this, m);
        return mFact;
    }

    public LinkedHashMap<Long, CardModel> activeCardModels(Fact fact) {
    	LinkedHashMap<Long, CardModel> activeCM = new LinkedHashMap<Long, CardModel>();
        for (Map.Entry<Long, CardModel> entry : cardModels(fact).entrySet()) {
            CardModel cardmodel = entry.getValue();
            if (cardmodel.isActive()) {
                // TODO: check for emptiness
            	activeCM.put(cardmodel.getId(), cardmodel);
            }
        }
        return activeCM;
    }

    public LinkedHashMap<Long, CardModel> cardModels(Fact fact) {
    	LinkedHashMap<Long, CardModel> cardModels = new LinkedHashMap<Long, CardModel>();
        CardModel.fromDb(this, fact.getModelId(), cardModels);
        return cardModels;
    }

    /**
     * deckVars methods
     */

    public void initDeckvarsCache() {
        mDeckVars.clear();
        Cursor cur = null;
        try {
            cur = getDB().getDatabase().rawQuery(""SELECT key, value FROM deckVars"", null);
            while (cur.moveToNext()) {
                mDeckVars.put(cur.getString(0), cur.getString(1));
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    }

    public boolean hasKey(String key) {
        return mDeckVars.containsKey(key);
    }

    public int getInt(String key) {
        if (mDeckVars.containsKey(key)) {
            try {
                return Integer.parseInt(mDeckVars.get(key));
            } catch (NumberFormatException e) {
                Log.w(AnkiDroidApp.TAG, ""NumberFormatException: Converting deckvar to int failed, key: \"""" + key +
                        ""\"", value: \"""" + mDeckVars.get(key) + ""\"""");
                return 0;
            }
        } else {
            return 0;
        }
    }


    public double getFloat(String key) {
        if (mDeckVars.containsKey(key)) {
            try {
                return Double.parseDouble(mDeckVars.get(key));
            } catch (NumberFormatException e) {
                Log.w(AnkiDroidApp.TAG, ""NumberFormatException: Converting deckvar to double failed, key: \"""" + key +
                        ""\"", value: \"""" + mDeckVars.get(key) + ""\"""");
                return 0.0;
            }
        } else {
            return 0.0;
        }
    }


    public boolean getBool(String key) {
        if (mDeckVars.containsKey(key)) {
            return mDeckVars.get(key).equals(""1"");
        } else {
            return false;
        }
    }


    public String getVar(String key) {
        return mDeckVars.get(key);
    }


    public void setVar(String key, String value) {
        setVar(key, value, true);
    }


    public void setVar(String key, String value, boolean mod) {
        try {
            if (mDeckVars.containsKey(key)) {
                getDB().getDatabase().execSQL(""UPDATE deckVars SET value='"" + value + ""' WHERE key = '"" + key + ""'"");
            } else {
                getDB().getDatabase().execSQL(""INSERT INTO deckVars (key, value) VALUES ('"" + key + ""', '"" +
                        value + ""')"");
            }
            mDeckVars.put(key, value);
        } catch (SQLException e) {
            Log.e(AnkiDroidApp.TAG, ""setVar: "" + e.toString());
            throw new RuntimeException(e);
        }
        if (mod) {
            setModified();
        }
    }


    public void setVarDefault(String key, String value) {
        if (!mDeckVars.containsKey(key)) {
            setVar(key, value, false);
        }
    }


    private void initVars() {
        // tmpMediaDir = null;
        mMediaPrefix = null;
        // lastTags = """";
        mLastLoaded = Utils.now();
        // undoEnabled = false;
        // sessionStartReps = 0;
        // sessionStartTime = 0;
        // lastSessionStart = 0;
        mQueueLimit = 200;
        // If most recent deck var not defined, make sure defaults are set
        if (!hasKey(""revSpacing"")) {
            setVarDefault(""suspendLeeches"", ""1"");
            setVarDefault(""leechFails"", ""16"");
            setVarDefault(""perDay"", ""1"");
            setVarDefault(""newActive"", """");
            setVarDefault(""revActive"", """");
            setVarDefault(""newInactive"", mSuspended);
            setVarDefault(""revInactive"", mSuspended);
            setVarDefault(""newSpacing"", ""60"");
            setVarDefault(""mediaURL"", """");
            setVarDefault(""latexPre"", ""\\documentclass[12pt]{article}\n"" + ""\\special{papersize=3in,5in}\n""
                    + ""\\usepackage[utf8]{inputenc}\n"" + ""\\usepackage{amssymb,amsmath}\n"" + ""\\pagestyle{empty}\n""
                    + ""\\begin{document}\n"");
            setVarDefault(""latexPost"", ""\\end{document}"");
            setVarDefault(""revSpacing"", ""0.1"");
            // FIXME: The next really belongs to the dropbox setup module, it's not supposed to be empty if the user
            // wants to use dropbox. ankiqt/ankiqt/ui/main.py : setupMedia
            // setVarDefault(""mediaLocation"", """");
        }
        updateCutoff();
        setupStandardScheduler();
    }


    // Media
    // *****

    /**
     * Return the media directory if exists, none if couldn't be created.
     *
     * @param create If true it will attempt to create the folder if it doesn't exist
     * @param rename This is used to simulate the python with create=None that is only used when renaming the mediaDir
     * @return The path of the media directory
     */
    public String mediaDir() {
        return mediaDir(false, false);
    }
    public String mediaDir(boolean create) {
        return mediaDir(create, false);
    }
    public String mediaDir(boolean create, boolean rename) {
        String dir = null;
        File mediaDir = null;
        if (mDeckPath != null && !mDeckPath.equals("""")) {
            // Log.i(AnkiDroidApp.TAG, ""mediaDir - mediaPrefix = "" + mMediaPrefix);
            if (mMediaPrefix != null) {
                dir = mMediaPrefix + ""/"" + mDeckName + "".media"";
            } else {
                dir = mDeckPath.replaceAll(""\\.anki$"", "".media"");
            }
            if (rename) {
                // Don't create, but return dir
                return dir;
            }
            mediaDir = new File(dir);
            if (!mediaDir.exists() && create) {
                try {
                    if (!mediaDir.mkdir()) {
                        Log.e(AnkiDroidApp.TAG, ""Couldn't create media directory "" + dir);
                        return null;
                    }
                } catch (SecurityException e) {
                    Log.e(AnkiDroidApp.TAG, ""Security restriction: Couldn't create media directory "" + dir);
                    return null;
                }
            }
        }

        if (dir == null) {
            return null;
        } else {
            if (!mediaDir.exists() || !mediaDir.isDirectory()) {
                return null;
            }
        }
        // Log.i(AnkiDroidApp.TAG, ""mediaDir - mediaDir = "" + dir);
        return dir;
    }

    public String getMediaPrefix() {
        return mMediaPrefix;
    }
    public void setMediaPrefix(String mediaPrefix) {
        mMediaPrefix = mediaPrefix;
    }


    /**
     * Upgrade deck to latest version. Any comments resulting from the upgrade, should be stored in upgradeNotes, as
     * R.string.id, successful or not. The idea is to have Deck.java generate the notes from upgrading and not the UI.
     * Still we need access to a Resources object and it's messy to pass that in openDeck. Instead we store the ids for
     * the messages and make a separate call from the UI to static upgradeNotesToMessages in order to properly translate
     * the IDs to messages for viewing. We shouldn't do this directly from the UI, as the messages contain %s variables
     * that need to be populated from deck values, and it's better to contain the libanki logic to the relevant classes.
     *
     * @return True if the upgrade is supported, false if the upgrade needs to be performed by Anki Desktop
     */
    private boolean upgradeDeck() {
        // Oldest versions in existence are 31 as of 11/07/2010
        // We support upgrading from 39 and up.
        // Unsupported are about 135 decks, missing about 6% as of 11/07/2010
        //
        double oldmod = mModified;

        upgradeNotes = new ArrayList<Integer>();
        if (mVersion < 39) {
            // Unsupported version
            upgradeNotes.add(com.ichi2.anki.R.string.deck_upgrade_too_old_version);
            return false;
        }
        if (mVersion < 40) {
            // Now stores media url
            getDB().getDatabase().execSQL(""UPDATE models SET features = ''"");
            mVersion = 40;
            commitToDB();
        }
        if (mVersion < 43) {
            getDB().getDatabase().execSQL(""UPDATE fieldModels SET features = ''"");
            mVersion = 43;
            commitToDB();
        }
        if (mVersion < 44) {
            // Leaner indices
            getDB().getDatabase().execSQL(""DROP INDEX IF EXISTS ix_cards_factId"");
            mVersion = 44;
            commitToDB();
        }
        if (mVersion < 48) {
            updateFieldCache(Utils.toPrimitive(getDB().queryColumn(Long.class, ""SELECT id FROM facts"", 0)));
            mVersion = 48;
            commitToDB();
        }
        if (mVersion < 50) {
            // more new type handling
            rebuildTypes();
            mVersion = 50;
            commitToDB();
        }
        if (mVersion < 52) {
            // The commented code below follows libanki by setting the syncName to the MD5 hash of the path.
            // The problem with that is that it breaks syncing with already uploaded decks.
            // if ((mSyncName != null) && !mSyncName.equals("""")) {
            // if (!mDeckName.equals(mSyncName)) {
            // upgradeNotes.add(com.ichi2.anki.R.string.deck_upgrade_52_note);
            // disableSyncing(false);
            // } else {
            // enableSyncing(false);
            // }
            // }
            mVersion = 52;
            commitToDB();
        }
        if (mVersion < 53) {
            if (getBool(""perDay"")) {
                if (Math.abs(mHardIntervalMin - 0.333) < 0.001) {
                    mHardIntervalMin = Math.max(1.0, mHardIntervalMin);
                    mHardIntervalMax = Math.max(1.1, mHardIntervalMax);
                }
            }
            mVersion = 53;
            commitToDB();
        }
        if (mVersion < 54) {
            // editFontFamily now used as a boolean, but in integer type, so set to 1 == true
            getDB().getDatabase().execSQL(""UPDATE fieldModels SET editFontFamily = 1"");
            mVersion = 54;
            commitToDB();
        }
        if (mVersion < 57) {
            // Add an index for priority & modified
            mVersion = 57;
            commitToDB();
        }
        if (mVersion < 61) {
            // First check if the deck has LaTeX, if so it should be upgraded in Anki
            if (hasLaTeX()) {
                upgradeNotes.add(com.ichi2.anki.R.string.deck_upgrade_version_61_has_latex);
                return false;
            }
            // Do our best to upgrade templates to the new style
            String txt =
                ""<span style=\""font-family: %s; font-size: %spx; color: %s; white-space: pre-wrap;\"">%s</span>"";
            Map<Long, Model> models = Model.getModels(this);
            Set<String> unstyled = new HashSet<String>();
            boolean changed = false;
            for (Model m : models.values()) {
                TreeMap<Long, FieldModel> fieldModels = m.getFieldModels();
                for (FieldModel fm : fieldModels.values()) {
                    changed = false;
                    // Log.i(AnkiDroidApp.TAG, ""family: '"" + fm.getQuizFontFamily() + ""'"");
                    // Log.i(AnkiDroidApp.TAG, ""family: "" + fm.getQuizFontSize());
                    // Log.i(AnkiDroidApp.TAG, ""family: '"" + fm.getQuizFontColour() + ""'"");
                    if ((fm.getQuizFontFamily() != null && !fm.getQuizFontFamily().equals("""")) ||
                            fm.getQuizFontSize() != 0 ||
                            (fm.getQuizFontColour() != null && fm.getQuizFontColour().equals(""""))) {
                    } else {
                        unstyled.add(fm.getName());
                    }
                    // Fill out missing info
                    if (fm.getQuizFontFamily() == null || fm.getQuizFontFamily().equals("""")) {
                        fm.setQuizFontFamily(""Arial"");
                        changed = true;
                    }
                    if (fm.getQuizFontSize() == 0) {
                        fm.setQuizFontSize(20);
                        changed = true;
                    }
                    if (fm.getQuizFontColour() == null || fm.getQuizFontColour().equals("""")) {
                        fm.setQuizFontColour(""#000000"");
                        changed = true;
                    }
                    if (fm.getEditFontSize() == 0) {
                        fm.setEditFontSize(20);
                        changed = true;
                    }
                    if (changed) {
                        fm.toDB(this);
                    }
                }

                for (CardModel cm : m.getCardModels()) {
                    // Embed the old font information into card templates
                    String format = cm.getQFormat();
                    cm.setQFormat(String.format(txt, cm.getQuestionFontFamily(), cm.getQuestionFontSize(),
                            cm.getQuestionFontColour(), format));
                    format = cm.getAFormat();
                    cm.setAFormat(String.format(txt, cm.getAnswerFontFamily(), cm.getAnswerFontSize(),
                            cm.getAnswerFontColour(), format));

                    // Escape fields that had no previous styling
                    for (String un : unstyled) {
                        String oldStyle = ""%("" + un + "")s"";
                        String newStyle = ""{{{"" + un + ""}}}"";
                        cm.setQFormat(cm.getQFormat().replace(oldStyle, newStyle));
                        cm.setAFormat(cm.getAFormat().replace(oldStyle, newStyle));
                    }
                    cm.toDB(this);
                }
            }
            // Rebuild q/a for the above & because latex has changed
            // We should be doing updateAllCards(), but it takes too long (really)
            // updateAllCards();
            // Rebuild the media db based on new format
            Media.rebuildMediaDir(this, false);
            mVersion = 61;
            commitToDB();
        }
        if (mVersion < 62) {
            // Updated Indices
            String[] indices = { ""intervalDesc"", ""intervalAsc"", ""randomOrder"", ""dueAsc"", ""dueDesc"" };
            for (String d : indices) {
                getDB().getDatabase().execSQL(""DROP INDEX IF EXISTS ix_cards_"" + d + ""2"");
            }
            getDB().getDatabase().execSQL(""DROP INDEX IF EXISTS ix_cards_typeCombined"");
            addIndices();
            updateDynamicIndices();
            getDB().getDatabase().execSQL(""VACUUM"");
            mVersion = 62;
            commitToDB();
        }
        if (mVersion < 64) {
            // Remove old static indices, as all clients should be libanki1.2+
            String[] oldStaticIndices = { ""ix_cards_duePriority"", ""ix_cards_priorityDue"" };
            for (String d : oldStaticIndices) {
                getDB().getDatabase().execSQL(""DROP INDEX IF EXISTS "" + d);
            }
            // Remove old dynamic indices
            String[] oldDynamicIndices = { ""intervalDesc"", ""intervalAsc"", ""randomOrder"", ""dueAsc"", ""dueDesc"" };
            for (String d : oldDynamicIndices) {
                getDB().getDatabase().execSQL(""DROP INDEX IF EXISTS ix_cards_"" + d);
            }
            getDB().getDatabase().execSQL(""ANALYZE"");
            mVersion = 64;
            commitToDB();
            // Note: we keep the priority index for now
        }
        if (mVersion < 65) {
            // We weren't correctly setting relativeDelay when answering cards in previous versions, so ensure
            // everything is set correctly
            rebuildTypes();
            mVersion = 65;
            commitToDB();
        }
        // Executing a pragma here is very slow on large decks, so we store our own record
        if ((!hasKey(""pageSize"")) || (getInt(""pageSize"") != 4096)) {
            commitToDB();
            getDB().getDatabase().execSQL(""PRAGMA page_size = 4096"");
            getDB().getDatabase().execSQL(""PRAGMA legacy_file_format = 0"");
            getDB().getDatabase().execSQL(""VACUUM"");
            setVar(""pageSize"", ""4096"", false);
            commitToDB();
        }
        assert (mModified == oldmod);
        return true;
    }


    public static String upgradeNotesToMessages(Deck deck, Resources res) {
        String notes = """";
        for (Integer note : deck.upgradeNotes) {
            notes = notes.concat(res.getString(note.intValue()) + ""\n"");
        }
        return notes;
    }

    private boolean hasLaTeX() {
        Cursor cursor = null;
        try {
            cursor = getDB().getDatabase().rawQuery(
                ""SELECT Id FROM fields WHERE "" +
                ""(value like '%[latex]%[/latex]%') OR "" +
                ""(value like '%[$]%[/$]%') OR "" +
                ""(value like '%[$$]%[/$$]%') LIMIT 1 "", null);
            if (cursor.moveToFirst()) {
                return true;
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
        return false;
    }

    /**
     * Add indices to the DB.
     */
    private void addIndices() {
        // Counts, failed cards
        getDB().getDatabase().execSQL(
                ""CREATE INDEX IF NOT EXISTS ix_cards_typeCombined ON cards (type, "" + ""combinedDue, factId)"");
        // Scheduler-agnostic type
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cards_relativeDelay ON cards (relativeDelay)"");
        // Index on modified, to speed up sync summaries
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cards_modified ON cards (modified)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_facts_modified ON facts (modified)"");
        // Priority - temporary index to make compat code faster. This can be removed when all clients are on 1.2,
        // as can the ones below
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cards_priority ON cards (priority)"");
        // Average factor
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cards_factor ON cards (type, factor)"");
        // Card spacing
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cards_factId ON cards (factId)"");
        // Stats
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_stats_typeDay ON stats (type, day)"");
        // Fields
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_fields_factId ON fields (factId)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_fields_fieldModelId ON fields (fieldModelId)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_fields_value ON fields (value)"");
        // Media
        getDB().getDatabase().execSQL(""CREATE UNIQUE INDEX IF NOT EXISTS ix_media_filename ON media (filename)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_media_originalPath ON media (originalPath)"");
        // Deletion tracking
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cardsDeleted_cardId ON cardsDeleted (cardId)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_modelsDeleted_modelId ON modelsDeleted (modelId)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_factsDeleted_factId ON factsDeleted (factId)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_mediaDeleted_factId ON mediaDeleted (mediaId)"");
        // Tags
        String txt = ""CREATE UNIQUE INDEX IF NOT EXISTS ix_tags_tag on tags (tag)"";
        try {
            getDB().getDatabase().execSQL(txt);
        } catch (SQLException e) {
            getDB().getDatabase().execSQL(""DELETE FROM tags WHERE EXISTS (SELECT 1 FROM tags t2 "" +
                    ""WHERE tags.tag = t2.tag AND tags.rowid > t2.rowid)"");
            getDB().getDatabase().execSQL(txt);
        }
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cardTags_tagCard ON cardTags (tagId, cardId)"");
        getDB().getDatabase().execSQL(""CREATE INDEX IF NOT EXISTS ix_cardTags_cardId ON cardTags (cardId)"");
    }


    /*
     * Add stripped HTML cache for sorting/searching. Currently needed as part of the upgradeDeck, the cache is not
     * really used, yet.
     */
    private void updateFieldCache(long[] fids) {
        HashMap<Long, String> r = new HashMap<Long, String>();
        Cursor cur = null;

        // Log.i(AnkiDroidApp.TAG, ""updatefieldCache fids: "" + Utils.ids2str(fids));
        try {
            cur = getDB().getDatabase().rawQuery(
                    ""SELECT factId, group_concat(value, ' ') FROM fields "" + ""WHERE factId IN "" + Utils.ids2str(fids)
                            + "" GROUP BY factId"", null);
            while (cur.moveToNext()) {
                String values = cur.getString(1);
                // if (values.charAt(0) == ' ') {
                // Fix for a slight difference between how Android SQLite and python sqlite work.
                // Inconsequential difference in this context, but messes up any effort for automated testing.
                values = values.replaceFirst(""^ *"", """");
                // }
                r.put(cur.getLong(0), Utils.stripHTMLMedia(values));
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

        if (r.size() > 0) {
            getDB().getDatabase().beginTransaction();
            SQLiteStatement st = getDB().getDatabase().compileStatement(""UPDATE facts SET spaceUntil=? WHERE id=?"");
            for (Entry<Long, String> entry : r.entrySet()) {
                st.bindString(1, entry.getValue());
                st.bindLong(2, entry.getKey().longValue());
                st.execute();
            }
            getDB().getDatabase().setTransactionSuccessful();
            getDB().getDatabase().endTransaction();
        }
    }


    private boolean modifiedSinceSave() {
        return mModified > mLastLoaded;
    }


    public long optimizeDeck() {
    	File file = new File(mDeckPath);
		long size = file.length();
    	commitToDB();
    	// Log.i(AnkiDroidApp.TAG, ""executing VACUUM statement"");
        getDB().getDatabase().execSQL(""VACUUM"");
    	// Log.i(AnkiDroidApp.TAG, ""executing ANALYZE statement"");
        getDB().getDatabase().execSQL(""ANALYZE"");
        file = new File(mDeckPath);
        size -= file.length();
        return size;
    }


    /*
     * Queue Management*****************************
     */

    private class QueueItem {
        private long cardID;
        private long factID;
        private double due;


        QueueItem(long cardID, long factID) {
            this.cardID = cardID;
            this.factID = factID;
            this.due = 0.0;
        }


        QueueItem(long cardID, long factID, double due) {
            this.cardID = cardID;
            this.factID = factID;
            this.due = due;
        }


        long getCardID() {
            return cardID;
        }


        long getFactID() {
            return factID;
        }


        double getDue() {
            return due;
        }
    }

    private class SpacedCardsItem {
        private double space;
        private ArrayList<Long> cards;


        SpacedCardsItem(double space, ArrayList<Long> cards) {
            this.space = space;
            this.cards = cards;
        }


        double getSpace() {
            return space;
        }


        ArrayList<Long> getCards() {
            return cards;
        }
    }


    /*
     * Next day's due cards ******************************
     */
    public int getNextDueCards(int day) {
    	double dayStart = mDueCutoff + (86400 * (day - 1));
    	String sql = String.format(Utils.ENGLISH_LOCALE,
                    ""SELECT count(*) FROM cards c WHERE type = 1 AND combinedDue BETWEEN %f AND %f AND PRIORITY > -1"", dayStart, dayStart + 86400);
        return (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", sql));
    }


    public int getNextDueMatureCards(int day) {
    	double dayStart = mDueCutoff + (86400 * (day - 1));
        String sql = String.format(Utils.ENGLISH_LOCALE,
                    ""SELECT count(*) FROM cards c WHERE type = 1 AND combinedDue BETWEEN %f AND %f AND interval >= %d"", dayStart, dayStart + 86400, Card.MATURE_THRESHOLD);
        return (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", sql));
    }


    /*
     * Get failed cards count ******************************
     */
    public int getFailedDelayedCount() {
        String sql = String.format(Utils.ENGLISH_LOCALE,
                ""SELECT count(*) FROM cards c WHERE type = 0 AND combinedDue >= "" + mFailedCutoff + "" AND PRIORITY > -1"");
        return (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", sql));
    }


    public int getNextNewCards() {
        String sql = String.format(Utils.ENGLISH_LOCALE,
                ""SELECT count(*) FROM cards c WHERE type = 2 AND combinedDue < %f"", mDueCutoff + 86400);
        return Math.min((int) getDB().queryScalar(cardLimit(""newActive"", ""newInactive"", sql)), mNewCardsPerDay);
    }


    /*
     * Next cards by interval ******************************
     */
    public int getCardsByInterval(int interval) {
        String sql = String.format(Utils.ENGLISH_LOCALE,
                ""SELECT count(*) FROM cards c WHERE type = 1 AND interval BETWEEN %d AND %d"", interval, interval + 1);
        return (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", sql));
    }


    /*
     * Review counts ******************************
     */
    public int[] getDaysReviewed(int day) {
        Date value = Utils.genToday(getUtcOffset() - (86400 * day));
    	Cursor cur = null;
    	int[] count = {0, 0, 0};
    	try {
            cur = getDB().getDatabase().rawQuery(String.format(Utils.ENGLISH_LOCALE,
            		""SELECT reps, (matureease1 + matureease2 + matureease3 + matureease4 +  youngease1 + youngease2 + youngease3 + youngease4), "" +
            		""(matureease1 + matureease2 + matureease3 + matureease4) FROM stats WHERE day = \'%tF\' AND type = %d"", value, Stats.STATS_DAY), null);
            while (cur.moveToNext()) {
            	count[0] = cur.getInt(0);
            	count[1] = cur.getInt(1);
            	count[2] = cur.getInt(2);
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

    	return count;
    }


    /*
     * Review time ******************************
     */
    public int getReviewTime(int day) {
        Date value = Utils.genToday(getUtcOffset() - (86400 * day));
    	Cursor cur = null;
    	int count = 0;
    	try {
            cur = getDB().getDatabase().rawQuery(String.format(Utils.ENGLISH_LOCALE,
            		""SELECT reviewTime FROM stats WHERE day = \'%tF\' AND reps > 0 AND type = %d"", value, Stats.STATS_DAY), null);
            while (cur.moveToNext()) {
            	count = cur.getInt(0);
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }

    	return count;
    }

    /*
     * Stats ******************************
     */

    public double getProgress(boolean global) {
    	if (global) {
    		return mGlobalStats.getMatureYesShare();
    	} else {
    		return mDailyStats.getYesShare();
    	}
    }

    public double getSessionProgress() {
    	int done = mDailyStats.getYesReps();
    	int total = done + mFailedSoonCount + mRevCount + mNewCountToday;
    	if (hasFinishScheduler()) {
    		return 1.0d;
    	} else {
    		return (double) done / total;    		
    	}
    }

    public int getSessionFinishedCards() {
    	//TODO: add failedTomorrowCount and leeches
    	return mDailyStats.getYesReps();
    }

    public int getETA() {
    	if (mDailyStats.getReps() >= 10 && mDailyStats.getAverageTime() > 0) {
    		return getETA(mFailedSoonCount, mRevCount, mNewCountToday, false);
		} else if (mGlobalStats.getAverageTime() > 0) {
			return getETA(mFailedSoonCount, mRevCount, mNewCountToday, true);
		} else {
			return -1;
		}
    }


    public int getETA(int failedCards, int revCards, int newCards, boolean global) {
    	double left;
    	double count;
    	double averageTime;
    	if (global) {
			averageTime = mGlobalStats.getAverageTime();		
		} else {
    		averageTime = mDailyStats.getAverageTime();
		}
 
    	double globalYoungNoShare = mGlobalStats.getYoungNoShare();

    	// rev + new cards first, account for failures
    	count = newCards + revCards;
    	count *= 1 + globalYoungNoShare;
    	left = count * averageTime;

    	//failed - higher time per card for higher amount of cards
    	double failedBaseMulti = 1.5;
    	double failedMod = 0.07;
    	double failedBaseCount = 20;
    	double factor = (failedBaseMulti + (failedMod * (failedCards - failedBaseCount)));
    	left += failedCards * averageTime * factor;
        	
    	return (int) (left / 60);
    }


    /*
     * Scheduler related overridable methods******************************
     */
    private Method getCardIdMethod;
    private Method fillFailedQueueMethod;
    private Method fillRevQueueMethod;
    private Method fillNewQueueMethod;
    private Method rebuildFailedCountMethod;
    private Method rebuildRevCountMethod;
    private Method rebuildNewCountMethod;
    private Method requeueCardMethod;
    private Method timeForNewCardMethod;
    private Method updateNewCountTodayMethod;
    private Method cardQueueMethod;
    private Method finishSchedulerMethod;
    private Method answerCardMethod;
    private Method cardLimitMethod;
    private Method answerPreSaveMethod;
    private Method spaceCardsMethod;


    private long getCardId() {
        try {
            return ((Long) getCardIdMethod.invoke(Deck.this, true)).longValue();
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private long getCardId(boolean check) {
        try {
            return ((Long) getCardIdMethod.invoke(Deck.this, check)).longValue();
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void fillFailedQueue() {
        try {
            fillFailedQueueMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void fillRevQueue() {
        try {
            fillRevQueueMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void fillNewQueue() {
        try {
            fillNewQueueMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void rebuildFailedCount() {
        try {
            rebuildFailedCountMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void rebuildRevCount() {
        try {
            rebuildRevCountMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void rebuildNewCount() {
        try {
            rebuildNewCountMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void requeueCard(Card card, boolean oldIsRev) {
        try {
            requeueCardMethod.invoke(Deck.this, card, oldIsRev);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private boolean timeForNewCard() {
        try {
            return ((Boolean) timeForNewCardMethod.invoke(Deck.this)).booleanValue();
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void updateNewCountToday() {
        try {
            updateNewCountTodayMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private int cardQueue(Card card) {
        try {
            return ((Integer) cardQueueMethod.invoke(Deck.this, card)).intValue();
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    public void finishScheduler() {
        try {
            finishSchedulerMethod.invoke(Deck.this);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    public void answerCard(Card card, int ease) {
        try {
            answerCardMethod.invoke(Deck.this, card, ease);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private String cardLimit(String active, String inactive, String sql) {
        try {
            return ((String) cardLimitMethod.invoke(Deck.this, active, inactive, sql));
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private String cardLimit(String[] active, String[] inactive, String sql) {
        try {
            return ((String) cardLimitMethod.invoke(Deck.this, active, inactive, sql));
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void answerPreSave(Card card, int ease) {
        try {
            answerPreSaveMethod.invoke(Deck.this, card, ease);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    private void spaceCards(Card card) {
        try {
            spaceCardsMethod.invoke(Deck.this, card);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException(e);
        }
    }


    public boolean hasFinishScheduler() {
        return !(finishSchedulerMethod == null);
    }


    public String name() {
        return mScheduler;
    }


    /*
     * Standard Scheduling*****************************
     */
    public void setupStandardScheduler() {
        try {
            getCardIdMethod = Deck.class.getDeclaredMethod(""_getCardId"", boolean.class);
            fillFailedQueueMethod = Deck.class.getDeclaredMethod(""_fillFailedQueue"");
            fillRevQueueMethod = Deck.class.getDeclaredMethod(""_fillRevQueue"");
            fillNewQueueMethod = Deck.class.getDeclaredMethod(""_fillNewQueue"");
            rebuildFailedCountMethod = Deck.class.getDeclaredMethod(""_rebuildFailedCount"");
            rebuildRevCountMethod = Deck.class.getDeclaredMethod(""_rebuildRevCount"");
            rebuildNewCountMethod = Deck.class.getDeclaredMethod(""_rebuildNewCount"");
            requeueCardMethod = Deck.class.getDeclaredMethod(""_requeueCard"", Card.class, boolean.class);
            timeForNewCardMethod = Deck.class.getDeclaredMethod(""_timeForNewCard"");
            updateNewCountTodayMethod = Deck.class.getDeclaredMethod(""_updateNewCountToday"");
            cardQueueMethod = Deck.class.getDeclaredMethod(""_cardQueue"", Card.class);
            finishSchedulerMethod = null;
            answerCardMethod = Deck.class.getDeclaredMethod(""_answerCard"", Card.class, int.class);
            cardLimitMethod = Deck.class.getDeclaredMethod(""_cardLimit"", String.class, String.class, String.class);
            answerPreSaveMethod = null;
            spaceCardsMethod = Deck.class.getDeclaredMethod(""_spaceCards"", Card.class);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
        mScheduler = ""standard"";
        // Restore any cards temporarily suspended by alternate schedulers
        if (mVersion == DECK_VERSION) {
            resetAfterReviewEarly();
        }
    }


    private void fillQueues() {
        fillFailedQueue();
        fillRevQueue();
        fillNewQueue();
        //for (QueueItem i : mFailedQueue) {
        //    // Log.i(AnkiDroidApp.TAG, ""failed queue: cid: "" + i.getCardID() + "" fid: "" + i.getFactID() + "" cd: "" + i.getDue());
        //}
        //for (QueueItem i : mRevQueue) {
        //    // Log.i(AnkiDroidApp.TAG, ""rev queue: cid: "" + i.getCardID() + "" fid: "" + i.getFactID());
        //}
        //for (QueueItem i : mNewQueue) {
        //    // Log.i(AnkiDroidApp.TAG, ""new queue: cid: "" + i.getCardID() + "" fid: "" + i.getFactID());
        //}
    }


    public long retrieveCardCount() {
        return getDB().queryScalar(""SELECT count(*) from cards"");
    }


    private void rebuildCounts() {
        // global counts
        try {
            mCardCount = (int) getDB().queryScalar(""SELECT count(*) from cards"");
            mFactCount = (int) getDB().queryScalar(""SELECT count(*) from facts"");
        } catch (SQLException e) {
            Log.e(AnkiDroidApp.TAG, ""rebuildCounts: Error while getting global counts: "" + e.toString());
            mCardCount = 0;
            mFactCount = 0;
        }
        // due counts
        rebuildFailedCount();
        rebuildRevCount();
        rebuildNewCount();
    }


    @SuppressWarnings(""unused"")
    private String _cardLimit(String active, String inactive, String sql) {
        String[] yes = Utils.parseTags(getVar(active));
        String[] no = Utils.parseTags(getVar(inactive));
        if (yes.length > 0) {
            long yids[] = Utils.toPrimitive(tagIds(yes).values());
            long nids[] = Utils.toPrimitive(tagIds(no).values());
            return sql.replace(""WHERE"", ""WHERE +c.id IN (SELECT cardId FROM cardTags WHERE "" + ""tagId IN ""
                    + Utils.ids2str(yids) + "") AND +c.id NOT IN (SELECT cardId FROM "" + ""cardTags WHERE tagId in ""
                    + Utils.ids2str(nids) + "") AND"");
        } else if (no.length > 0) {
            long nids[] = Utils.toPrimitive(tagIds(no).values());
            return sql.replace(""WHERE"", ""WHERE +c.id NOT IN (SELECT cardId FROM cardTags WHERE tagId IN ""
                    + Utils.ids2str(nids) + "") AND"");
        } else {
            return sql;
        }
    }


    /**
     * This is a count of all failed cards within the current day cutoff. The cards may not be ready for review yet, but
     * can still be displayed if failedCardsMax is reached.
     */
    @SuppressWarnings(""unused"")
    private void _rebuildFailedCount() {
        String sql = String.format(Utils.ENGLISH_LOCALE,
                ""SELECT count(*) FROM cards c WHERE type = 0 AND combinedDue < %f"", mFailedCutoff);
        mFailedSoonCount = (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", sql));
    }


    @SuppressWarnings(""unused"")
    private void _rebuildRevCount() {
        String sql = String.format(Utils.ENGLISH_LOCALE,
                ""SELECT count(*) FROM cards c WHERE type = 1 AND combinedDue < %f"", mDueCutoff);
        mRevCount = (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", sql));
    }


    @SuppressWarnings(""unused"")
    private void _rebuildNewCount() {
        String sql = String.format(Utils.ENGLISH_LOCALE,
                ""SELECT count(*) FROM cards c WHERE type = 2 AND combinedDue < %f"", mDueCutoff);
        mNewCount = (int) getDB().queryScalar(cardLimit(""newActive"", ""newInactive"", sql));
        updateNewCountToday();
        mSpacedCards.clear();
    }


    @SuppressWarnings(""unused"")
    private void _updateNewCountToday() {
        mNewCountToday = Math.max(Math.min(mNewCount, mNewCardsPerDay - newCardsDoneToday()), 0);
    }


    @SuppressWarnings(""unused"")
    private void _fillFailedQueue() {
        if ((mFailedSoonCount != 0) && mFailedQueue.isEmpty()) {
            Cursor cur = null;
            try {
                String sql = ""SELECT c.id, factId, combinedDue FROM cards c WHERE type = 0 AND combinedDue < ""
                        + mFailedCutoff + "" ORDER BY combinedDue LIMIT "" + mQueueLimit;
                cur = getDB().getDatabase().rawQuery(cardLimit(""revActive"", ""revInactive"", sql), null);
                while (cur.moveToNext()) {
                    QueueItem qi = new QueueItem(cur.getLong(0), cur.getLong(1), cur.getDouble(2));
                    mFailedQueue.add(0, qi); // Add to front, so list is reversed as it is built
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
        }
    }


    @SuppressWarnings(""unused"")
    private void _fillRevQueue() {
        if ((mRevCount != 0) && mRevQueue.isEmpty()) {
            Cursor cur = null;
            try {
                String sql = ""SELECT c.id, factId, combinedDue FROM cards c WHERE type = 1 AND combinedDue < ""
                        + mDueCutoff + "" ORDER BY "" + revOrder() + "" LIMIT "" + mQueueLimit;
                cur = getDB().getDatabase().rawQuery(cardLimit(""revActive"", ""revInactive"", sql), null);
                while (cur.moveToNext()) {
                    QueueItem qi = new QueueItem(cur.getLong(0), cur.getLong(1), cur.getDouble(2));
                    mRevQueue.add(0, qi); // Add to front, so list is reversed as it is built
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
        }
    }


    @SuppressWarnings(""unused"")
    private void _fillNewQueue() {
        if ((mNewCountToday != 0) && mNewQueue.isEmpty() && mSpacedCards.isEmpty()) {
            Cursor cur = null;
            try {
                String sql = ""SELECT c.id, factId, combinedDue FROM cards c WHERE type = 2 AND combinedDue < ""
                        + mDueCutoff + "" ORDER BY "" + newOrder() + "" LIMIT "" + mQueueLimit;
                cur = getDB().getDatabase().rawQuery(cardLimit(""newActive"", ""newInactive"", sql), null);
                while (cur.moveToNext()) {
                    QueueItem qi = new QueueItem(cur.getLong(0), cur.getLong(1), cur.getDouble(2));
                    mNewQueue.addFirst(qi); // Add to front, so list is reversed as it is built
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
        }
    }


    private boolean queueNotEmpty(LinkedList<QueueItem> queue, Method fillFunc) {
        return queueNotEmpty(queue, fillFunc, false);
    }


    private boolean queueNotEmpty(LinkedList<QueueItem> queue, Method fillFunc, boolean _new) {
//        while (true) {
            removeSpaced(queue, _new);
            if (!queue.isEmpty()) {
                return true;
            }
            try {
                fillFunc.invoke(Deck.this);
                // with libanki
            } catch (Exception e) {
                Log.e(AnkiDroidApp.TAG, ""queueNotEmpty: Error while invoking overridable fill method:"" + e.toString());
                return false;
            }
//            if (queue.isEmpty()) {
                return false;
//            }
//        }
    }


    private void removeSpaced(LinkedList<QueueItem> queue, boolean _new) {
        ArrayList<Long> popped = new ArrayList<Long>();
        double delay = 0.0;
        while (!queue.isEmpty()) {
            long fid = ((QueueItem) queue.getLast()).getFactID();
            if (mSpacedFacts.containsKey(fid)) {
                // Still spaced
                long id = queue.removeLast().getCardID();
                // Assuming 10 cards/minute, track id if likely to expire before queue refilled
                if (_new && (mNewSpacing < (double) mQueueLimit * 6.0)) {
                    popped.add(id);
                    delay = mSpacedFacts.get(fid);
                }
            } else {
                if (!popped.isEmpty()) {
                    mSpacedCards.add(new SpacedCardsItem(delay, popped));
                }
                break;
            }
        }
    }


    private boolean revNoSpaced() {
        return queueNotEmpty(mRevQueue, fillRevQueueMethod);
    }


    private boolean newNoSpaced() {
        return queueNotEmpty(mNewQueue, fillNewQueueMethod, true);
    }


    @SuppressWarnings(""unused"")
    private void _requeueCard(Card card, boolean oldIsRev) {
        int newType = 0;
        // try {
        if (card.getReps() == 1) {
            if (mNewFromCache) {
                // Fetched from spaced cache
                newType = 2;
                ArrayList<Long> cards = mSpacedCards.remove().getCards();
                // Reschedule the siblings
                if (cards.size() > 1) {
                    cards.remove(0);
                    mSpacedCards.addLast(new SpacedCardsItem(Utils.now() + mNewSpacing, cards));
                }
            } else {
                // Fetched from normal queue
                newType = 1;
                mNewQueue.removeLast();
            }
        } else if (!oldIsRev) {
            mFailedQueue.removeLast();
        } else {
            // try {
                mRevQueue.removeLast();
            // }
            // catch(NoSuchElementException e) {
            //     Log.w(AnkiDroidApp.TAG, ""mRevQueue empty"");
            // }
        }
        // } catch (Exception e) {
        // throw new RuntimeException(""requeueCard() failed. Counts: "" +
        // mFailedSoonCount + "" "" + mRevCount + "" "" + mNewCountToday + "", Queue: "" +
        // mFailedQueue.size() + "" "" + mRevQueue.size() + "" "" + mNewQueue.size() + "", Card info: "" +
        // card.getReps() + "" "" + card.isRev() + "" "" + oldIsRev);
        // }
    }


    private String revOrder() {
        return revOrderStrings[mRevCardOrder];
    }


    private String newOrder() {
        return newOrderStrings[mNewCardOrder];
    }


    // Rebuild the type cache. Only necessary on upgrade.
    private void rebuildTypes() {
        getDB().getDatabase().execSQL(
                ""UPDATE cards SET "" + ""relativeDelay = (CASE WHEN successive THEN 1 WHEN reps THEN 0 ELSE 2 END)"");
        getDB().getDatabase().execSQL(
                ""UPDATE cards SET "" + ""type = (CASE WHEN type >= 0 THEN relativeDelay ELSE relativeDelay - 3 END)"");
    }


    @SuppressWarnings(""unused"")
    private int _cardQueue(Card card) {
        return cardType(card);
    }


    // Return the type of the current card (what queue it's in)
    private int cardType(Card card) {
        if (card.isRev()) {
            return 1;
        } else if (!card.isNew()) {
            return 0;
        } else {
            return 2;
        }
    }


    public void updateCutoff() {
        Calendar cal = Calendar.getInstance();
        int newday = (int) mUtcOffset + (cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET)) / 1000;
        cal.add(Calendar.MILLISECOND, -cal.get(Calendar.ZONE_OFFSET) - cal.get(Calendar.DST_OFFSET));
        cal.add(Calendar.SECOND, (int) -mUtcOffset + 86400);
        cal.set(Calendar.AM_PM, Calendar.AM);
        cal.set(Calendar.HOUR, 0); // Yes, verbose but crystal clear
        cal.set(Calendar.MINUTE, 0); // Apologies for that, here was my rant
        cal.set(Calendar.SECOND, 0); // But if you can improve this bit and
        cal.set(Calendar.MILLISECOND, 0); // collapse it to one statement please do
        cal.getTimeInMillis();

        // Log.d(AnkiDroidApp.TAG, ""New day happening at "" + newday + "" sec after 00:00 UTC"");
        cal.add(Calendar.SECOND, newday);
        long cutoff = cal.getTimeInMillis() / 1000;
        // Cutoff must not be in the past
        while (cutoff < System.currentTimeMillis() / 1000) {
            cutoff += 86400.0;
        }
        // Cutoff must not be more than 24 hours in the future
        cutoff = Math.min(System.currentTimeMillis() / 1000 + 86400, cutoff);
        mFailedCutoff = cutoff;
        if (getBool(""perDay"")) {
            mDueCutoff = (double) cutoff;
        } else {
            mDueCutoff = (double) Utils.now();
        }
    }


    public void reset() {
        // Setup global/daily stats
        mGlobalStats = Stats.globalStats(this);
        mDailyStats = Stats.dailyStats(this);
        // Recheck counts
        rebuildCounts();
        // Empty queues; will be refilled by getCard()
        mFailedQueue.clear();
        mRevQueue.clear();
        mNewQueue.clear();
        mSpacedFacts.clear();
        // Determine new card distribution
        if (mNewCardSpacing == NEW_CARDS_DISTRIBUTE) {
            if (mNewCountToday != 0) {
                mNewCardModulus = (mNewCountToday + mRevCount) / mNewCountToday;
                // If there are cards to review, ensure modulo >= 2
                if (mRevCount != 0) {
                    mNewCardModulus = Math.max(2, mNewCardModulus);
                }
            } else {
                mNewCardModulus = 0;
            }
        } else {
            mNewCardModulus = 0;
        }
        // Recache css - Removed for speed optim, we don't use this cache anyway
        // rebuildCSS();

        // Spacing for delayed cards - not to be confused with newCardSpacing above
        mNewSpacing = getFloat(""newSpacing"");
        mRevSpacing = getFloat(""revSpacing"");
    }


    // Checks if the day has rolled over.
    private void checkDailyStats() {
        if (!Utils.genToday(mUtcOffset).toString().equals(mDailyStats.getDay().toString())) {
            mDailyStats = Stats.dailyStats(this);
        }
    }


    /*
     * Review early*****************************
     */

    public void setupReviewEarlyScheduler() {
        try {
            fillRevQueueMethod = Deck.class.getDeclaredMethod(""_fillRevEarlyQueue"");
            rebuildRevCountMethod = Deck.class.getDeclaredMethod(""_rebuildRevEarlyCount"");
            finishSchedulerMethod = Deck.class.getDeclaredMethod(""_onReviewEarlyFinished"");
            answerPreSaveMethod = Deck.class.getDeclaredMethod(""_reviewEarlyPreSave"", Card.class, int.class);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
        mScheduler = ""reviewEarly"";
    }


    @SuppressWarnings(""unused"")
    private void _reviewEarlyPreSave(Card card, int ease) {
        if (ease > 1) {
            // Prevent it from appearing in next queue fill
            card.setType(card.getType() + 6);
        }
    }


    private void resetAfterReviewEarly() {
        // Put temporarily suspended cards back into play. Caller must .reset()
        // FIXME: Can ignore priorities in the future (following libanki)
        ArrayList<Long> ids = getDB().queryColumn(Long.class,
                ""SELECT id FROM cards WHERE type BETWEEN 6 AND 8 OR priority = -1"", 0);

        if (!ids.isEmpty()) {
            updatePriorities(Utils.toPrimitive(ids));
            getDB().getDatabase().execSQL(""UPDATE cards SET type = type -6 WHERE type BETWEEN 6 AND 8"");
            flushMod();
        }
    }


    @SuppressWarnings(""unused"")
    private void _onReviewEarlyFinished() {
        // Clean up buried cards
        resetAfterReviewEarly();
        // And go back to regular scheduler
        setupStandardScheduler();
    }


    @SuppressWarnings(""unused"")
    private void _rebuildRevEarlyCount() {
        // In the future it would be nice to skip the first x days of due cards

        mRevCount = (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", String.format(Utils.ENGLISH_LOCALE,
                        ""SELECT count() FROM cards c WHERE type = 1 AND combinedDue > %f"", mDueCutoff)));
    }


    @SuppressWarnings(""unused"")
    private void _fillRevEarlyQueue() {
        if ((mRevCount != 0) && mRevQueue.isEmpty()) {
            Cursor cur = null;
            try {
                cur = getDB().getDatabase().rawQuery(cardLimit(""revActive"", ""revInactive"", String.format(
                                Utils.ENGLISH_LOCALE,
                                ""SELECT id, factId, combinedDue FROM cards c WHERE type = 1 AND combinedDue > %f "" +
                                ""ORDER BY combinedDue LIMIT %d"", mDueCutoff, mQueueLimit)), null);
                while (cur.moveToNext()) {
                    QueueItem qi = new QueueItem(cur.getLong(0), cur.getLong(1));
                    mRevQueue.add(0, qi); // Add to front, so list is reversed as it is built
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
        }
    }


    /*
     * Learn more*****************************
     */

    public void setupLearnMoreScheduler() {
        try {
            rebuildNewCountMethod = Deck.class.getDeclaredMethod(""_rebuildLearnMoreCount"");
            updateNewCountTodayMethod = Deck.class.getDeclaredMethod(""_updateLearnMoreCountToday"");
            finishSchedulerMethod = Deck.class.getDeclaredMethod(""setupStandardScheduler"");
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
        mScheduler = ""learnMore"";
    }


    @SuppressWarnings(""unused"")
    private void _rebuildLearnMoreCount() {
        mNewCount = (int) getDB().queryScalar(
                cardLimit(""newActive"", ""newInactive"", String.format(Utils.ENGLISH_LOCALE,
                        ""SELECT count(*) FROM cards c WHERE type = 2 AND combinedDue < %f"", mDueCutoff)));
        mSpacedCards.clear();
    }


    @SuppressWarnings(""unused"")
    private void _updateLearnMoreCountToday() {
        mNewCountToday = mNewCount;
    }


    /*
     * Cramming*****************************
     */

    public void setupCramScheduler(String[] active, String order) {
        try {
            getCardIdMethod = Deck.class.getDeclaredMethod(""_getCramCardId"", boolean.class);
            mActiveCramTags = active;
            mCramOrder = order;
            rebuildFailedCountMethod = Deck.class.getDeclaredMethod(""_rebuildFailedCramCount"");
            rebuildRevCountMethod = Deck.class.getDeclaredMethod(""_rebuildCramCount"");
            rebuildNewCountMethod = Deck.class.getDeclaredMethod(""_rebuildNewCramCount"");
            fillFailedQueueMethod = Deck.class.getDeclaredMethod(""_fillFailedCramQueue"");
            fillRevQueueMethod = Deck.class.getDeclaredMethod(""_fillCramQueue"");
            finishSchedulerMethod = Deck.class.getDeclaredMethod(""setupStandardScheduler"");
            mFailedCramQueue.clear();
            requeueCardMethod = Deck.class.getDeclaredMethod(""_requeueCramCard"", Card.class, boolean.class);
            cardQueueMethod = Deck.class.getDeclaredMethod(""_cramCardQueue"", Card.class);
            answerCardMethod = Deck.class.getDeclaredMethod(""_answerCramCard"", Card.class, int.class);
            spaceCardsMethod = Deck.class.getDeclaredMethod(""_spaceCramCards"", Card.class);
            // Reuse review early's code
            answerPreSaveMethod = Deck.class.getDeclaredMethod(""_cramPreSave"", Card.class, int.class);
            cardLimitMethod = Deck.class.getDeclaredMethod(""_cramCardLimit"", String[].class, String[].class,
                    String.class);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
        mScheduler = ""cram"";
    }


    @SuppressWarnings(""unused"")
    private void _answerCramCard(Card card, int ease) {
        _answerCard(card, ease);
        if (ease == 1) {
            mFailedCramQueue.addFirst(new QueueItem(card.getId(), card.getFactId()));
        }
    }


    @SuppressWarnings(""unused"")
    private long _getCramCardId(boolean check) {
        checkDailyStats();
        fillQueues();

        if ((mFailedCardMax != 0) && (mFailedSoonCount >= mFailedCardMax)) {
            return ((QueueItem) mFailedQueue.getLast()).getCardID();
        }
        // Card due for review?
        if (revNoSpaced()) {
            return ((QueueItem) mRevQueue.getLast()).getCardID();
        }
        if (!mFailedQueue.isEmpty()) {
            return ((QueueItem) mFailedQueue.getLast()).getCardID();
        }
        if (check) {
            // Collapse spaced cards before reverting back to old scheduler
            reset();
            return getCardId(false);
        }
        // If we're in a custom scheduler, we may need to switch back
        if (finishSchedulerMethod != null) {
            finishScheduler();
            reset();
            return getCardId();
        }
        return 0l;
    }


    @SuppressWarnings(""unused"")
    private int _cramCardQueue(Card card) {
        if ((!mRevQueue.isEmpty()) && (((QueueItem) mRevQueue.getLast()).getCardID() == card.getId())) {
            return 1;
        } else {
            return 0;
        }
    }


    @SuppressWarnings(""unused"")
    private void _requeueCramCard(Card card, boolean oldIsRev) {
        if (cardQueue(card) == 1) {
            mRevQueue.removeLast();
        } else {
            mFailedCramQueue.removeLast();
        }
    }


    @SuppressWarnings(""unused"")
    private void _rebuildNewCramCount() {
        mNewCount = 0;
        mNewCountToday = 0;
    }


    @SuppressWarnings(""unused"")
    private String _cramCardLimit(String active[], String inactive[], String sql) {
        // inactive is (currently) ignored
        if (active.length > 0) {
            long yids[] = Utils.toPrimitive(tagIds(active).values());
            return sql.replace(""WHERE "", ""WHERE +c.id IN (SELECT cardId FROM cardTags WHERE "" + ""tagId IN ""
                    + Utils.ids2str(yids) + "") AND "");
        } else {
            return sql;
        }
    }


    @SuppressWarnings(""unused"")
    private void _fillCramQueue() {
        if ((mRevCount != 0) && mRevQueue.isEmpty()) {
            Cursor cur = null;
            try {
                // Log.i(AnkiDroidApp.TAG, ""fill cram queue: "" + Arrays.toString(mActiveCramTags) + "" "" + mCramOrder + "" "" + mQueueLimit);
                String sql = ""SELECT id, factId FROM cards c WHERE type BETWEEN 0 AND 2 ORDER BY "" + mCramOrder
                        + "" LIMIT "" + mQueueLimit;
                sql = cardLimit(mActiveCramTags, null, sql);
                // Log.i(AnkiDroidApp.TAG, ""SQL: "" + sql);
                cur = getDB().getDatabase().rawQuery(sql, null);
                while (cur.moveToNext()) {
                    QueueItem qi = new QueueItem(cur.getLong(0), cur.getLong(1));
                    mRevQueue.add(0, qi); // Add to front, so list is reversed as it is built
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }

        }
    }


    @SuppressWarnings(""unused"")
    private void _rebuildCramCount() {
        mRevCount = (int) getDB().queryScalar(
                cardLimit(mActiveCramTags, null, ""SELECT count(*) FROM cards c WHERE type BETWEEN 0 AND 2""));
    }


    @SuppressWarnings(""unused"")
    private void _rebuildFailedCramCount() {
        mFailedSoonCount = mFailedCramQueue.size();
    }


    @SuppressWarnings(""unused"")
    private void _fillFailedCramQueue() {
        mFailedQueue = mFailedCramQueue;
    }


    @SuppressWarnings(""unused"")
    private void _spaceCramCards(Card card) {
        mSpacedFacts.put(card.getFactId(), Utils.now() + mNewSpacing);
    }


    @SuppressWarnings(""unused"")
    private void _cramPreSave(Card card, int ease) {
        // prevent it from appearing in next queue fill
        card.setType(card.getType() + 6);
    }


    private void setModified() {
        mModified = Utils.now();
    }


    public void setModified(double mod) {
        mModified = mod;
    }


    public void flushMod() {
        setModified();
        commitToDB();
    }


    public void commitToDB() {
        // Log.i(AnkiDroidApp.TAG, ""commitToDB - Saving deck to DB..."");
        ContentValues values = new ContentValues();
        values.put(""created"", mCreated);
        values.put(""modified"", mModified);
        values.put(""description"", mDescription);
        values.put(""version"", mVersion);
        values.put(""currentModelId"", mCurrentModelId);
        values.put(""syncName"", mSyncName);
        values.put(""lastSync"", mLastSync);
        values.put(""hardIntervalMin"", mHardIntervalMin);
        values.put(""hardIntervalMax"", mHardIntervalMax);
        values.put(""midIntervalMin"", mMidIntervalMin);
        values.put(""midIntervalMax"", mMidIntervalMax);
        values.put(""easyIntervalMin"", mEasyIntervalMin);
        values.put(""easyIntervalMax"", mEasyIntervalMax);
        values.put(""delay0"", mDelay0);
        values.put(""delay1"", mDelay1);
        values.put(""delay2"", mDelay2);
        values.put(""collapseTime"", mCollapseTime);
        values.put(""highPriority"", mHighPriority);
        values.put(""medPriority"", mMedPriority);
        values.put(""lowPriority"", mLowPriority);
        values.put(""suspended"", mSuspended);
        values.put(""newCardOrder"", mNewCardOrder);
        values.put(""newCardSpacing"", mNewCardSpacing);
        values.put(""failedCardMax"", mFailedCardMax);
        values.put(""newCardsPerDay"", mNewCardsPerDay);
        values.put(""sessionRepLimit"", mSessionRepLimit);
        values.put(""sessionTimeLimit"", mSessionTimeLimit);
        values.put(""utcOffset"", mUtcOffset);
        values.put(""cardCount"", mCardCount);
        values.put(""factCount"", mFactCount);
        values.put(""failedNowCount"", mFailedNowCount);
        values.put(""failedSoonCount"", mFailedSoonCount);
        values.put(""revCount"", mRevCount);
        values.put(""newCount"", mNewCount);
        values.put(""revCardOrder"", mRevCardOrder);

        getDB().update(this, ""decks"", values, ""id = "" + mId, null);
    }


    /*
     * Getters and Setters for deck properties NOTE: The setters flushMod()
     * *********************************************************
     */

    public AnkiDb getDB() {
        // TODO: Make this a reference to a member variable
        return AnkiDatabaseManager.getDatabase(mDeckPath);
    }


    public String getDeckPath() {
        return mDeckPath;
    }


    public void setDeckPath(String path) {
        mDeckPath = path;
    }


    // public String getSyncName() {
    //     return mSyncName;
    // }


    // public void setSyncName(String name) {
    //     mSyncName = name;
    //     flushMod();
    // }


    public int getRevCardOrder() {
        return mRevCardOrder;
    }


    public void setRevCardOrder(int num) {
        if (num >= 0) {
            mRevCardOrder = num;
            flushMod();
        }
    }


    public int getNewCardSpacing() {
        return mNewCardSpacing;
    }


    public void setNewCardSpacing(int num) {
        if (num >= 0) {
            mNewCardSpacing = num;
            flushMod();
        }
    }


    public int getNewCardOrder() {
        return mNewCardOrder;
    }


    public void setNewCardOrder(int num) {
        if (num >= 0) {
            mNewCardOrder = num;
            flushMod();
        }
    }


    public int getFailedCardMax() {
        return mFailedCardMax;
    }


    public void setFailedCardMax(int num) {
        if (num >= 0) {
	    mFailedCardMax = num;
	    flushMod();
        }
    }


    public boolean getPerDay() {
        return getBool(""perDay"");
    }


    public void setPerDay(boolean perDay) {
        if (perDay) {
            setVar(""perDay"", ""1"");
        } else {
            setVar(""perDay"", ""0"");
        }
    }


    public boolean getSuspendLeeches() {
        return getBool(""suspendLeeches"");
    }


    public void setSuspendLeeches(boolean suspendLeeches) {
        if (suspendLeeches) {
            setVar(""suspendLeeches"", ""1"");
        } else {
            setVar(""suspendLeeches"", ""0"");
        }
    }


    public int getNewCardsPerDay() {
        return mNewCardsPerDay;
    }


    public void setNewCardsPerDay(int num) {
        if (num >= 0) {
            mNewCardsPerDay = num;
            flushMod();
            reset();
        }
    }


    public long getSessionRepLimit() {
        return mSessionRepLimit;
    }


    public void setSessionRepLimit(long num) {
        if (num >= 0) {
            mSessionRepLimit = num;
            flushMod();
        }
    }


    public long getSessionTimeLimit() {
        return mSessionTimeLimit;
    }


    public void setSessionTimeLimit(long num) {
        if (num >= 0) {
            mSessionTimeLimit = num;
            flushMod();
        }
    }


    /**
     * @return the failedSoonCount
     */
    public int getFailedSoonCount() {
        return mFailedSoonCount;
    }


    /**
     * @return the revCount
     */
    public int getRevCount() {
        return mRevCount;
    }


    /**
     * @return the newCountToday
     */
    public int getNewCountToday() {
        return mNewCountToday;
    }


    /**
     * @return the number of due cards in the deck
     */
    public int getDueCount() {
        return mFailedSoonCount + mRevCount;
    }


    /**
     * @param cardCount the cardCount to set
     */
    public void setCardCount(int cardCount) {
        mCardCount = cardCount;
        // XXX: Need to flushmod() ?
    }


    /**
     * Get the cached total number of cards of the deck.
     *
     * @return The number of cards contained in the deck
     */
    public int getCardCount() {
        return mCardCount;
    }


    /**
     * @return True, if there are any tag limits
     */
    public boolean isLimitedByTag() {
        if (!getVar(""newActive"").equals("""")) {
            return true;
        } else if (!getVar(""newInactive"").equals("""")) {
            return true;
        } else if (!getVar(""revActive"").equals("""")) {
            return true;
        } else if (!getVar(""revInactive"").equals("""")) {
            return true;
        } else {
            return false;
        }
    }


    /**
	 * Get the number of mature cards of the deck.
	 *
	 * @return The number of cards contained in the deck
	 */
	public int getMatureCardCount(boolean restrictToActive) {
        String sql = String.format(Utils.ENGLISH_LOCALE,
                ""SELECT count(*) from cards c WHERE (type = 1 OR TYPE = 0) AND interval >= %d"", Card.MATURE_THRESHOLD);
        if (restrictToActive) {
            return (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", sql));
        } else {
            return (int) getDB().queryScalar(sql);
        }
    }


    /**
     * @return the newCount
     */
    public int getNewCount(boolean restrictToActive) {
        if (restrictToActive) {
            return getNewCount();
        } else {
            return (int) getDB().queryScalar(""SELECT count(*) from cards WHERE type = 2"");
        }
    }


    /**
     * @return the rev card count
     */
    public int getTotalRevFailedCount(boolean restrictToActive) {
        if (restrictToActive) {
            return (int) getDB().queryScalar(cardLimit(""revActive"", ""revInactive"", ""SELECT count(*) from cards c WHERE (type = 1 OR type = 0)""));
        } else {
            return getCardCount() - getNewCount(false);
        }
    }


    /**
     * @return the currentModelId
     */
    public long getCurrentModelId() {
        return mCurrentModelId;
    }


    /**
     * @return the deckName
     */
    public String getDeckName() {
        return mDeckName;
    }


    /**
     * @return the deck UTC offset in number seconds
     */
    public double getUtcOffset() {
        return mUtcOffset;
    }
    public void setUtcOffset() {
        mUtcOffset = Utils.utcOffset();
    }


    /**
     * @return the newCount
     */
    public int getNewCount() {
        return mNewCount;
    }


    /**
     * @return the modified
     */
    public double getModified() {
        return mModified;
    }


    /**
     * @param lastSync the lastSync to set
     */
    public void setLastSync(double lastSync) {
        mLastSync = lastSync;
    }


    /**
     * @return the lastSync
     */
    public double getLastSync() {
    	Utils.printDate(""getLastSync"", mLastSync);
        return mLastSync;
    }


    /**
     * @param factCount the factCount to set
     */
    public void setFactCount(int factCount) {
        mFactCount = factCount;
        // XXX: Need to flushmod() ?
    }


    /**
     * @return the factCount
     */
    public int getFactCount() {
        return mFactCount;
    }


    /**
     * @param lastLoaded the lastLoaded to set
     */
    public double getLastLoaded() {
        return mLastLoaded;
    }


    /**
     * @param lastLoaded the lastLoaded to set
     */
    public void setLastLoaded(double lastLoaded) {
        mLastLoaded = lastLoaded;
    }


    public int getVersion() {
        return mVersion;
    }

    public boolean isUnpackNeeded() {
        return mNeedUnpack;
    }

    public double getDueCutoff() {
        return mDueCutoff;
    }


    public String getScheduler() {
        return mScheduler;
    }


    public ArrayList<Long> getCardsFromFactId(Long factId) {
        Cursor cursor = null;
        ArrayList<Long> cardIds = new ArrayList<Long>();
        try {
            cursor = getDB().getDatabase().rawQuery(
                    ""SELECT id FROM cards WHERE factid = "" + factId, null);
            while (cursor.moveToNext()) {
                cardIds.add(cursor.getLong(0));
            }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        return cardIds;
    }


    /*
     * Getting the next card*****************************
     */

    /**
     * Return the next card object.
     *
     * @return The next due card or null if nothing is due.
     */
    public Card getCard() {
        mCurrentCardId = getCardId();
        if (mCurrentCardId != 0l) {
            return cardFromId(mCurrentCardId);
        } else {
            return null;
        }
    }


    // Refreshes the current card and returns it (used when editing cards)
    public Card getCurrentCard() {
        return cardFromId(mCurrentCardId);
    }


    /**
     * Return the next due card Id, or 0
     *
     * @param check Check for expired, or new day rollover
     * @return The Id of the next card, or 0 in case of error
     */
    @SuppressWarnings(""unused"")
    private long _getCardId(boolean check) {
        checkDailyStats();
        fillQueues();
        updateNewCountToday();
        if (!mFailedQueue.isEmpty()) {
            // Failed card due?
            if (mDelay0 != 0l) {
                if ((long) ((QueueItem) mFailedQueue.getLast()).getDue() + mDelay0 < System.currentTimeMillis() / 1000) {
                    return mFailedQueue.getLast().getCardID();
                }
            }
            // Failed card queue too big?
            if ((mFailedCardMax != 0) && (mFailedSoonCount >= mFailedCardMax)) {
                return mFailedQueue.getLast().getCardID();
            }
        }
        // Distribute new cards?
        if (newNoSpaced() && timeForNewCard()) {
            long id = getNewCard();
            if (id != 0L) {
                return id;
            }
        }
        // Card due for review?
        if (revNoSpaced()) {
            return mRevQueue.getLast().getCardID();
        }
        // New cards left?
        if (mNewCountToday != 0) {
            return getNewCard();
        }
        if (check) {
            // Check for expired cards, or new day rollover
            updateCutoff();
            reset();
            return getCardId(false);
        }
        // Display failed cards early/last
        if ((!check) && showFailedLast() && (!mFailedQueue.isEmpty())) {
            return mFailedQueue.getLast().getCardID();
        }
        // If we're in a custom scheduler, we may need to switch back
        if (finishSchedulerMethod != null) {
            finishScheduler();
            reset();
            return getCardId();
        }
        return 0l;
    }


    /*
     * Get card: helper functions*****************************
     */

    @SuppressWarnings(""unused"")
    private boolean _timeForNewCard() {
        // True if it's time to display a new card when distributing.
        if (mNewCountToday == 0) {
            return false;
        }
        if (mNewCardSpacing == NEW_CARDS_LAST) {
            return false;
        }
        if (mNewCardSpacing == NEW_CARDS_FIRST) {
            return true;
        }
        // Force review if there are very high priority cards
        try {
            if (!mRevQueue.isEmpty()) {
                if (getDB().queryScalar(
                        ""SELECT 1 FROM cards WHERE id = "" + mRevQueue.getLast().getCardID() + "" AND priority = 4"") == 1) {
                    return false;
                }
            }
        } catch (Exception e) {
            // No result from query.
        }
        if (mNewCardModulus != 0) {
            return (mDailyStats.getReps() % mNewCardModulus == 0);
        } else {
            return false;
        }
    }


    private long getNewCard() {
        int src = 0;
        if ((!mSpacedCards.isEmpty()) && (mSpacedCards.get(0).getSpace() < Utils.now())) {
            // Spaced card has expired
            src = 0;
        } else if (!mNewQueue.isEmpty()) {
            // Card left in new queue
            src = 1;
        } else if (!mSpacedCards.isEmpty()) {
            // Card left in spaced queue
            src = 0;
        } else {
            // Only cards spaced to another day left
            return 0L;
        }

        if (src == 0) {
            mNewFromCache = true;
            return mSpacedCards.get(0).getCards().get(0);
        } else {
            mNewFromCache = false;
            return mNewQueue.getLast().getCardID();
        }
    }


    private boolean showFailedLast() {
        return ((mCollapseTime != 0.0) || (mDelay0 == 0));
    }


    /**
     * Given a card ID, return a card and start the card timer.
     *
     * @param id The ID of the card to be returned
     */

    public Card cardFromId(long id) {
        if (id == 0) {
            return null;
        }
        Card card = new Card(this);
        boolean result = card.fromDB(id);

        if (!result) {
            return null;
        }
        card.mDeck = this;
        card.genFuzz();
        card.startTimer();
        return card;
    }


    // TODO: The real methods to update cards on Anki should be implemented instead of this
    public void updateAllCards() {
        updateAllCardsFromPosition(0, Long.MAX_VALUE);
    }


    public long updateAllCardsFromPosition(long numUpdatedCards, long limitCards) {
        // TODO: Cache this query, order by FactId, Id
        Cursor cursor = null;
        try {
            cursor = getDB().getDatabase().rawQuery(
                    ""SELECT id, factId "" + ""FROM cards "" + ""ORDER BY factId, id "" + ""LIMIT "" + limitCards + "" OFFSET ""
                            + numUpdatedCards, null);

            getDB().getDatabase().beginTransaction();
            while (cursor.moveToNext()) {
                // Get card
                Card card = new Card(this);
                card.fromDB(cursor.getLong(0));
                // Log.i(AnkiDroidApp.TAG, ""Card id = "" + card.getId() + "", numUpdatedCards = "" + numUpdatedCards);

                // Load tags
                card.loadTags();

                // Get the related fact
                Fact fact = card.getFact();
                // // Log.i(AnkiDroidApp.TAG, ""Fact id = "" + fact.id);

                // Generate the question and answer for this card and update it
                HashMap<String, String> newQA = CardModel.formatQA(fact, card.getCardModel(), card.splitTags());
                card.setQuestion(newQA.get(""question""));
                // Log.i(AnkiDroidApp.TAG, ""Question = "" + card.getQuestion());
                card.setAnswer(newQA.get(""answer""));
                // Log.i(AnkiDroidApp.TAG, ""Answer = "" + card.getAnswer());

                card.updateQAfields();

                numUpdatedCards++;

            }
            getDB().getDatabase().setTransactionSuccessful();
        } finally {
            getDB().getDatabase().endTransaction();
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }

        return numUpdatedCards;
    }


    /*
     * Answering a card*****************************
     */

    public void _answerCard(Card card, int ease) {
        // Log.i(AnkiDroidApp.TAG, ""answerCard"");
        double now = Utils.now();
        long id = card.getId();

        String undoName = UNDO_TYPE_ANSWER_CARD;
        setUndoStart(undoName, id);

        // Old state
        String oldState = card.getState();
        int oldQueue = cardQueue(card);
        double lastDelaySecs = Utils.now() - card.getCombinedDue();
        double lastDelay = lastDelaySecs / 86400.0;
        boolean oldIsRev = card.isRev();
        ContentValues oldvalues = card.getAnswerValues();

        // update card details
        double last = card.getInterval();
        card.setInterval(nextInterval(card, ease));
        if (lastDelay >= 0) {
            card.setLastInterval(last); // keep last interval if reviewing early
        }
        if (!card.isNew()) {
            card.setLastDue(card.getDue()); // only update if card was not new
        }
        card.setDue(nextDue(card, ease, oldState));
        card.setIsDue(0);
        card.setLastFactor(card.getFactor());
        card.setSpaceUntil(0);
        if (lastDelay >= 0) {
            card.updateFactor(ease, mAverageFactor); // don't update factor if learning ahead
        }

        // Spacing
        spaceCards(card);
        // Adjust counts for current card
        if (ease == 1) {
            if (card.getDue() < mFailedCutoff) {
                mFailedSoonCount += 1;
            }
        }
        if (oldQueue == 0) {
            mFailedSoonCount -= 1;
        } else if (oldQueue == 1) {
            mRevCount -= 1;
        } else {
            mNewCount -= 1;
        }

        // card stats
        card.updateStats(ease, oldState);
        // Update type & ensure past cutoff
        card.setType(cardType(card));
        card.setRelativeDelay(card.getType());
        if (ease != 1) {
            card.setDue(Math.max(card.getDue(), mDueCutoff + 1));
        }

        // Allow custom schedulers to munge the card
        if (answerPreSaveMethod != null) {
            answerPreSave(card, ease);
        }

        // Save
        card.setCombinedDue(card.getDue());
        // card.toDB();
        getDB().update(this, ""cards"", card.getAnswerValues(), ""id = "" + id, null, true, new ContentValues[] {oldvalues}, new String[] {""id = "" + id});

        // global/daily stats
        Stats.updateAllStats(mGlobalStats, mDailyStats, card, ease, oldState);

        // review history
        CardHistoryEntry entry = new CardHistoryEntry(this, card, ease, lastDelay);
        entry.writeSQL();
        mModified = now;
        setUndoEnd(undoName);

        // Remove form queue
        requeueCard(card, oldIsRev);

        // Leech handling - we need to do this after the queue, as it may cause a reset
        if (isLeech(card)) {
            // Log.i(AnkiDroidApp.TAG, ""card is leech!"");
            handleLeech(card);
        }
    }


    @SuppressWarnings(""unused"")
    private void _spaceCards(Card card) {
        // Update new counts
        double _new = Utils.now() + mNewSpacing;
        ContentValues values = new ContentValues();
        values.put(""combinedDue"", String.format(Utils.ENGLISH_LOCALE, ""(CASE WHEN type = 1 THEN "" +
                		""combinedDue + 86400 * (CASE WHEN interval*%f < 1 THEN 0 ELSE interval*%f END) "" +
                		""WHEN type = 2 THEN %f ELSE combinedDue END)"", mRevSpacing, mRevSpacing, _new));
        values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
        values.put(""isDue"", 0);
        getDB().update(this, ""cards"", values, String.format(Utils.ENGLISH_LOCALE, ""id != %d AND factId = %d "" 
                + ""AND combinedDue < %f AND type BETWEEN 1 AND 2"", card.getId(), card.getFactId(), mDueCutoff), null, false);
        mSpacedFacts.put(card.getFactId(), _new);
    }


    private boolean isLeech(Card card) {
        int no = card.getNoCount();
        int fmax = 0;
        if (hasKey(""leechFails"")) {
            fmax = getInt(""leechFails"");
            if (fmax == 0) {
            	return false;
            }
        } else {
            // No leech threshold found in DeckVars
            return false;
        }
        // Log.i(AnkiDroidApp.TAG, ""leech handling: "" + card.getSuccessive() + "" successive fails and "" + no + "" total fails, threshold at "" + fmax);
        // Return true if:
        // - The card failed AND
        // - The number of failures exceeds the leech threshold AND
        // - There were at least threshold/2 reps since last time
        if (!card.isRev() && (no >= fmax) && (((double)(fmax - no)) % Math.max(fmax / 2, 1) == 0)) {
            return true;
        } else {
            return false;
        }
    }


    private void handleLeech(Card card) {
        Card scard = cardFromId(card.getId());
        String tags = scard.getFact().getTags();
        tags = Utils.addTags(""Leech"", tags);
        scard.getFact().setTags(Utils.canonifyTags(tags));
        // FIXME: Inefficient, we need to save the fact so that the modified tags can be used in setModified,
        // then after setModified we need to save again! Just make setModified to use the tags from the fact,
        // not reload them from the DB.
        scard.getFact().toDb();
        scard.getFact().setModified(true, this);
        scard.getFact().toDb();
        updateFactTags(new long[] { scard.getFact().getId() });
        card.setLeechFlag(true);
        if (getBool(""suspendLeeches"")) {
        	String undoName = UNDO_TYPE_SUSPEND_CARD;
        	setUndoStart(undoName);
        	suspendCards(new long[] { card.getId() });
        	card.setSuspendedFlag(true);
        	setUndoEnd(undoName);
        }
        reset();
    }


    /*
     * Interval management*********************************************************
     */

    public double nextInterval(Card card, int ease) {
        double delay = card.adjustedDelay(ease);
        return nextInterval(card, delay, ease);
    }


    private double nextInterval(Card card, double delay, int ease) {
        double interval = card.getInterval();
        double factor = card.getFactor();

        // if shown early and not failed
        if ((delay < 0) && card.isRev()) {
            // FIXME: From libanki: This should recreate lastInterval from interval /
            // lastFactor, or we lose delay information when reviewing early
            interval = Math.max(card.getLastInterval(), card.getInterval() + delay);
            if (interval < mMidIntervalMin) {
                interval = 0;
            }
            delay = 0;
        }

        // if interval is less than mid interval, use presets
        if (ease == Card.EASE_FAILED) {
            interval *= mDelay2;
            if (interval < mHardIntervalMin) {
                interval = 0;
            }
        } else if (interval == 0) {
            if (ease == Card.EASE_HARD) {
                interval = mHardIntervalMin + card.getFuzz() * (mHardIntervalMax - mHardIntervalMin);
            } else if (ease == Card.EASE_MID) {
                interval = mMidIntervalMin + card.getFuzz() * (mMidIntervalMax - mMidIntervalMin);
            } else if (ease == Card.EASE_EASY) {
                interval = mEasyIntervalMin + card.getFuzz() * (mEasyIntervalMax - mEasyIntervalMin);
            }
        } else {
            // if not cramming, boost initial 2
            if ((interval < mHardIntervalMax) && (interval > 0.166)) {
                double mid = (mMidIntervalMin + mMidIntervalMax) / 2.0;
                interval = mid / factor;
            }
            // multiply last interval by factor
            if (ease == Card.EASE_HARD) {
                interval = (interval + delay / 4.0) * 1.2;
            } else if (ease == Card.EASE_MID) {
                interval = (interval + delay / 2.0) * factor;
            } else if (ease == Card.EASE_EASY) {
                interval = (interval + delay) * factor * FACTOR_FOUR;
            }
            interval *= 0.95 + card.getFuzz() * (1.05 - 0.95);
        }
        interval = Math.min(interval, MAX_SCHEDULE_TIME);
        return interval;
    }


    private double nextDue(Card card, int ease, String oldState) {
        double due;
        if (ease == Card.EASE_FAILED) {
        	// 600 is a magic value which means no bonus, and is used to ease upgrades
            if (oldState.equals(Card.STATE_MATURE) && mDelay1 != 0 && mDelay1 != 600) {
                // user wants a bonus of 1+ days. put the failed cards at the
            	// start of the future day, so that failures that day will come
            	// after the waiting cards
            	return mFailedCutoff + (mDelay1 - 1) * 86400;
            } else {
                due = 0.0;
            }
        } else {
            due = card.getInterval() * 86400.0;
        }
        return (due + Utils.now());
    }


    /*
     * Tags: Querying*****************************
     */

    /**
     * Get a map of card IDs to their associated tags (fact, model and template)
     *
     * @param where SQL restriction on the query. If empty, then returns tags for all the cards
     * @return The map of card IDs to an array of strings with 3 elements representing the triad {card tags, model tags,
     *         template tags}
     */
    private HashMap<Long, List<String>> splitTagsList() {
        return splitTagsList("""");
    }


    private HashMap<Long, List<String>> splitTagsList(String where) {
        Cursor cur = null;
        HashMap<Long, List<String>> results = new HashMap<Long, List<String>>();
        try {
            cur = getDB().getDatabase().rawQuery(
                    ""SELECT cards.id, facts.tags, models.tags, cardModels.name ""
                            + ""FROM cards, facts, models, cardModels ""
                            + ""WHERE cards.factId == facts.id AND facts.modelId == models.id ""
                            + ""AND cards.cardModelId = cardModels.id "" + where, null);
            while (cur.moveToNext()) {
                ArrayList<String> tags = new ArrayList<String>();
                tags.add(cur.getString(1));
                tags.add(cur.getString(2));
                tags.add(cur.getString(3));
                results.put(cur.getLong(0), tags);
            }
        } catch (SQLException e) {
            Log.e(AnkiDroidApp.TAG, ""splitTagsList: Error while retrieving tags from DB: "" + e.toString());
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        return results;
    }


    /**
     * Returns all model tags, all template tags and a filtered set of fact tags
     *
     * @param where Optional, SQL filter for fact tags. If skipped, returns all fact tags
     * @return All the distinct individual tags, sorted, as an array of string
     */
    public String[] allTags_() {
        return allTags_("""");
    }


    private String[] allTags_(String where) {
    	try {
            ArrayList<String> t = new ArrayList<String>();
            t.addAll(getDB().queryColumn(String.class, ""SELECT tags FROM facts "" + where, 0));
            t.addAll(getDB().queryColumn(String.class, ""SELECT tags FROM models"", 0));
            t.addAll(getDB().queryColumn(String.class, ""SELECT name FROM cardModels"", 0));
            String joined = Utils.joinTags(t);
            String[] parsed = Utils.parseTags(joined);
            List<String> joinedList = Arrays.asList(parsed);
            TreeSet<String> joinedSet = new TreeSet<String>(joinedList);
            return joinedSet.toArray(new String[joinedSet.size()]);
    	} catch (OutOfMemoryError e) {
    		Log.e(AnkiDroidApp.TAG, ""OutOfMemoryError on retrieving allTags: "" + e);
    		return null;
    	}
    }


    public String[] allUserTags() {
        return allUserTags("""");
    }


    public String[] allUserTags(String where) {
    	try {
    		ArrayList<String> t = new ArrayList<String>();
            t.addAll(getDB().queryColumn(String.class, ""SELECT tags FROM facts "" + where, 0));
            String joined = Utils.joinTags(t);
            String[] parsed = Utils.parseTags(joined);
            List<String> joinedList = Arrays.asList(parsed);
            TreeSet<String> joinedSet = new TreeSet<String>(joinedList);
            return joinedSet.toArray(new String[joinedSet.size()]);
    	} catch (OutOfMemoryError e) {
    		Log.e(AnkiDroidApp.TAG, ""OutOfMemoryError on retrieving allTags: "" + e);
    		return null;
    	}
    }


    /*
     * Tags: Caching*****************************
     */

    public void updateFactTags(long[] factIds) {
        updateCardTags(Utils.toPrimitive(getDB().queryColumn(Long.class,
                ""SELECT id FROM cards WHERE factId IN "" + Utils.ids2str(factIds), 0)));
    }


    public void updateCardTags() {
        updateCardTags(null);
    }


    public void updateCardTags(long[] cardIds) {
        HashMap<String, Long> tagIds = new HashMap<String, Long>();
        HashMap<Long, List<String>> cardsWithTags = new HashMap<Long, List<String>>();
        if (cardIds == null) {
            getDB().getDatabase().execSQL(""DELETE FROM cardTags"");
            getDB().getDatabase().execSQL(""DELETE FROM tags"");
            String[] allTags = allTags_();
            if (allTags != null) {
                tagIds = tagIds(allTags);
            }
            cardsWithTags = splitTagsList();
        } else {
            // Log.i(AnkiDroidApp.TAG, ""updateCardTags cardIds: "" + Arrays.toString(cardIds));
            getDB().delete(this, ""cardTags"", ""cardId IN "" + Utils.ids2str(cardIds), null);
            String factIds = Utils.ids2str(Utils.toPrimitive(getDB().queryColumn(Long.class,
                    ""SELECT factId FROM cards WHERE id IN "" + Utils.ids2str(cardIds), 0)));
            // Log.i(AnkiDroidApp.TAG, ""updateCardTags factIds: "" + factIds);
            String[] allTags = allTags_(""WHERE id IN "" + factIds);
            if (allTags != null) {
                tagIds = tagIds(allTags);
            }
            // Log.i(AnkiDroidApp.TAG, ""updateCardTags tagIds keys: "" + Arrays.toString(tagIds.keySet().toArray(new String[tagIds.size()])));
            // Log.i(AnkiDroidApp.TAG, ""updateCardTags tagIds values: "" + Arrays.toString(tagIds.values().toArray(new Long[tagIds.size()])));
            cardsWithTags = splitTagsList(""AND facts.id IN "" + factIds);
            // Log.i(AnkiDroidApp.TAG, ""updateCardTags cardTags keys: "" + Arrays.toString(cardsWithTags.keySet().toArray(new Long[cardsWithTags.size()])));
            for (List<String> tags : cardsWithTags.values()) {
                // Log.i(AnkiDroidApp.TAG, ""updateCardTags cardTags values: "");
                for (String tag : tags) {
                    // Log.i(AnkiDroidApp.TAG, ""updateCardTags row item: "" + tag);
                }
            }
        }

        ArrayList<HashMap<String, Long>> cardTags = new ArrayList<HashMap<String, Long>>();

        for (Entry<Long, List<String>> card : cardsWithTags.entrySet()) {
            Long cardId = card.getKey();
            for (int src = 0; src < 3; src++) { // src represents the tag type, fact: 0, model: 1, template: 2
                for (String tag : Utils.parseTags(card.getValue().get(src))) {
                    HashMap<String, Long> association = new HashMap<String, Long>();
                    association.put(""cardId"", cardId);
                    association.put(""tagId"", tagIds.get(tag.toLowerCase()));
                    association.put(""src"", new Long(src));
                    // Log.i(AnkiDroidApp.TAG, ""populating association "" + src + "" "" + tag);
                    cardTags.add(association);
                }
            }
        }

        for (HashMap<String, Long> cardTagAssociation : cardTags) {
            ContentValues values = new ContentValues();
            values.put(""cardId"", cardTagAssociation.get(""cardId""));
            values.put(""tagId"", cardTagAssociation.get(""tagId""));
            values.put(""src"",  cardTagAssociation.get(""src""));
            getDB().insert(this, ""cardTags"", null, values);
        }
        getDB().delete(this, ""tags"", ""priority = 2 AND id NOT IN (SELECT DISTINCT tagId FROM cardTags)"", null);
    }


    public ArrayList<HashMap<String, String>> getCards(int chunk, String startId) {
    	ArrayList<HashMap<String, String>> cards = new ArrayList<HashMap<String, String>>();

        Cursor cur = null;
        try {
        	cur = getDB().getDatabase().rawQuery(""SELECT cards.id, cards.question, cards.answer, "" +
        			""facts.tags, models.tags, cardModels.name, cards.priority, cards.due, cards.interval, "" +
        			""cards.factor, cards.created FROM cards, facts, "" +
        			""models, cardModels WHERE cards.factId == facts.id AND facts.modelId == models.id "" +
        			""AND cards.cardModelId = cardModels.id "" + (startId != """" ? (""AND cards.id > "" + startId) : """") +
        			"" ORDER BY cards.id LIMIT "" + chunk, null);
            while (cur.moveToNext()) {
            	HashMap<String, String> data = new HashMap<String, String>();
            	data.put(""id"", Long.toString(cur.getLong(0)));
            	data.put(""question"", Utils.stripHTML(cur.getString(1).replaceAll(""<br(\\s*\\/*)>"",""\n"")));
            	data.put(""answer"", Utils.stripHTML(cur.getString(2).replaceAll(""<br(\\s*\\/*)>"",""\n"")));
            	String tags = cur.getString(3);
            	String flags = null;
           	    if (tags.contains(TAG_MARKED)) {
           	    	flags = ""1"";
           	    } else {
           	    	flags = ""0"";
           	    }
            	if (cur.getString(6).equals(""-3"")) {
            		flags = flags + ""1"";
                } else {
                	flags = flags + ""0"";
                }
            	data.put(""tags"", tags + "" "" + cur.getString(4) + "" "" + cur.getString(5));
            	data.put(""flags"", flags);
            	data.put(""due"", Double.toString(cur.getDouble(6)));
            	data.put(""interval"", Double.toString(cur.getDouble(7)));
            	data.put(""factor"", Double.toString(cur.getDouble(8)));
            	data.put(""created"", Double.toString(cur.getDouble(9)));
            	cards.add(data);
            }
        } catch (SQLException e) {
            Log.e(AnkiDroidApp.TAG, ""getAllCards: "" + e.toString());
            return null;
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
    	return cards;
    }


    public int getMarketTagId() {
    	if (markedTagId == 0) {
    		markedTagId = -1;
            Cursor cur = null;
            try {
                cur = getDB().getDatabase().rawQuery(""SELECT id FROM tags WHERE tag = \"""" + TAG_MARKED + ""\"""", null);
                while (cur.moveToNext()) {
                	markedTagId = cur.getInt(0);
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
    	}
    	return markedTagId;
    }


    public void resetMarkedTagId() {
    	markedTagId = 0;
    }
    
    /*
     * Tags: adding/removing in bulk*********************************************************
     */

    public ArrayList<String> factTags(long[] factIds) {
        return getDB().queryColumn(String.class, ""SELECT tags FROM facts WHERE id IN "" + Utils.ids2str(factIds), 0);
    }


    public void addTag(long factId, String tag) {
        long[] ids = new long[1];
        ids[0] = factId;
        addTag(ids, tag);
    }


    public void addTag(long[] factIds, String tag) {
        ArrayList<String> factTagsList = factTags(factIds);

        // Create tag if necessary
        long tagId = tagId(tag, true);

        int nbFactTags = factTagsList.size();
        for (int i = 0; i < nbFactTags; i++) {
            String newTags = factTagsList.get(i);

            if (newTags.indexOf(tag) == -1) {
                if (newTags.length() == 0) {
                    newTags += tag;
                } else {
                    newTags += "","" + tag;
                }
            }
            // Log.i(AnkiDroidApp.TAG, ""old tags = "" + factTagsList.get(i));
            // Log.i(AnkiDroidApp.TAG, ""new tags = "" + newTags);

            if (newTags.length() > factTagsList.get(i).length()) {
            	ContentValues values = new ContentValues();
            	values.put(""tags"", newTags);
            	values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
                getDB().update(this, ""facts"", values, ""id = "" + factIds[i], null);
            }
        }

        ArrayList<String> cardIdList = getDB().queryColumn(String.class,
                ""select id from cards where factId in "" + Utils.ids2str(factIds), 0);

        for (String cardId : cardIdList) {
            try {
                // Check if the tag already exists
                getDB().queryScalar(
                        ""SELECT id FROM cardTags WHERE cardId = "" + cardId + "" and tagId = "" + tagId + "" and src = ""
                                + Card.TAGS_FACT);
            } catch (SQLException e) {
            	ContentValues values = new ContentValues();
                values.put(""cardId"", cardId);
                values.put(""tagId"", tagId);
                values.put(""src"", String.valueOf(Card.TAGS_FACT));
                getDB().insert(this, ""cardTags"", null, values);
            }
        }

        flushMod();
    }


    public void deleteTag(long factId, String tag) {
        long[] ids = new long[1];
        ids[0] = factId;
        deleteTag(ids, tag);
    }


    public void deleteTag(long[] factIds, String tag) {
        ArrayList<String> factTagsList = factTags(factIds);

        long tagId = tagId(tag, false);

        int nbFactTags = factTagsList.size();
        for (int i = 0; i < nbFactTags; i++) {
            String factTags = factTagsList.get(i);
            String newTags = factTags;

            int tagIdx = factTags.indexOf(tag);
            if ((tagIdx == 0) && (factTags.length() > tag.length())) {
                // tag is the first element of many, remove ""tag,""
                newTags = factTags.substring(tag.length() + 1, factTags.length());
            } else if ((tagIdx > 0) && (tagIdx + tag.length() == factTags.length())) {
                // tag is the last of many elements, remove "",tag""
                newTags = factTags.substring(0, tagIdx - 1);
            } else if (tagIdx > 0) {
                // tag is enclosed between other elements, remove "",tag""
                newTags = factTags.substring(0, tagIdx - 1) + factTags.substring(tag.length(), factTags.length());
            } else if (tagIdx == 0) {
                // tag is the only element
                newTags = """";
            }
            // Log.i(AnkiDroidApp.TAG, ""old tags = "" + factTags);
            // Log.i(AnkiDroidApp.TAG, ""new tags = "" + newTags);

            if (newTags.length() < factTags.length()) {
            	ContentValues values = new ContentValues();
                values.put(""tags"", newTags);
                values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
                getDB().update(this, ""facts"", values, ""id = "" + factIds[i], null);
            }
        }

        ArrayList<String> cardIdList = getDB().queryColumn(String.class,
                ""select id from cards where factId in "" + Utils.ids2str(factIds), 0);

        for (String cardId : cardIdList) {
        	getDB().delete(this, ""cardTags"", ""cardId = "" + cardId + "" and tagId = "" + tagId + "" and src = "" + Card.TAGS_FACT, null);
        }

        // delete unused tags from tags table
        try {
            getDB().queryScalar(""select id from cardTags where tagId = "" + tagId + "" limit 1"");
        } catch (SQLException e) {
        	getDB().delete(this, ""tags"", ""id = "" + tagId, null);
        }

        flushMod();
    }


    /*
     * Suspending*****************************
     */

    /**
     * Suspend cards in bulk. Caller must .reset()
     *
     * @param ids List of card IDs of the cards that are to be suspended.
     */
    public void suspendCards(long[] ids) {
    	ContentValues values = new ContentValues();
        values.put(""type"", ""relativeDelay -3"");
        values.put(""priority"", -3);
        values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
        values.put(""isDue"", 0);
        getDB().update(this, ""cards"", values, ""type >= 0 AND id IN "" + Utils.ids2str(ids), null, false);
        // Log.i(AnkiDroidApp.TAG, ""Cards suspended"");
        flushMod();
    }


    /**
     * Unsuspend cards in bulk. Caller must .reset()
     *
     * @param ids List of card IDs of the cards that are to be unsuspended.
     */
    public void unsuspendCards(long[] ids) {
    	ContentValues values = new ContentValues();
        values.put(""type"", ""relativeDelay"");
        values.put(""priority"", 0);
        values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
        values.put(""isDue"", 0);
        getDB().update(this, ""cards"", values, ""type < 0 AND id IN "" + Utils.ids2str(ids), null, false);
        // Log.i(AnkiDroidApp.TAG, ""Cards unsuspended"");
        updatePriorities(ids);
        flushMod();
    }


    public boolean getSuspendedState(long id) {
        return (getDB().queryScalar(""SELECT count(*) from cards WHERE id = "" + id + "" AND priority = -3"") == 1);
    }


    /**
     * Bury all cards for fact until next session. Caller must .reset()
     *
     * @param Fact
     */
    public void buryFact(long factId, long cardId) {
        // TODO: Unbury fact after return to StudyOptions
        String undoName = UNDO_TYPE_BURY_CARD;
        setUndoStart(undoName, cardId);
        // libanki code:
//        for (long cid : getCardsFromFactId(factId)) {
//            Card card = cardFromId(cid);
//            int type = card.getType();
//            if (type == 0 || type == 1 || type == 2) {
//                card.setPriority(card.getPriority() - 2);
//                card.setType(type + 3);
//                card.setDue(0);
//            }
//        }
        // This differs from libanki:
    	ContentValues values = new ContentValues();
        values.put(""type"", ""type + 3"");
        values.put(""priority"", -2);
        values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
        values.put(""isDue"", 0);
        getDB().update(this, ""cards"", values, ""type >= 0 AND type <= 3 AND factId = "" + factId, null, false);
        setUndoEnd(undoName);
        flushMod();
    }


    /**
     * Priorities
     *******************************/

    /**
     * Update all card priorities if changed. If partial is true, only updates cards with tags defined as priority low,
     * med or high in the deck, or with tags whose priority is set to 2 and they are not found in the priority tags of
     * the deck. If false, it updates all card priorities Caller must .reset()
     *
     * @param partial Partial update (true) or not (false)
     * @param dirty Passed to updatePriorities(), if true it updates the modified field of the cards
     */
    public void updateAllPriorities() {
        updateAllPriorities(false, true);
    }


    public void updateAllPriorities(boolean partial) {
        updateAllPriorities(partial, true);
    }


    public void updateAllPriorities(boolean partial, boolean dirty) {
        HashMap<Long, Integer> newPriorities = updateTagPriorities();
        if (!partial) {
            newPriorities.clear();
            Cursor cur = null;
            try {
                cur = getDB().getDatabase().rawQuery(""SELECT id, priority AS pri FROM tags"", null);
                while (cur.moveToNext()) {
                    newPriorities.put(cur.getLong(0), cur.getInt(1));
                }
            } catch (SQLException e) {
                Log.e(AnkiDroidApp.TAG, ""updateAllPriorities: Error while getting all tags: "" + e.toString());
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
            ArrayList<Long> cids = getDB().queryColumn(
                    Long.class,
                    ""SELECT DISTINCT cardId FROM cardTags WHERE tagId in ""
                            + Utils.ids2str(Utils.toPrimitive(newPriorities.keySet())), 0);
            updatePriorities(Utils.toPrimitive(cids), null, dirty);
        }
    }


    /**
     * Update priority setting on tags table
     */
    private HashMap<Long, Integer> updateTagPriorities() {
        // Make sure all priority tags exist
        for (String s : new String[] { mLowPriority, mMedPriority, mHighPriority }) {
            tagIds(Utils.parseTags(s));
        }

        HashMap<Long, Integer> newPriorities = new HashMap<Long, Integer>();
        Cursor cur = null;
        ArrayList<String> tagNames = null;
        ArrayList<Long> tagIdList = null;
        ArrayList<Integer> tagPriorities = null;
        try {
            tagNames = new ArrayList<String>();
            tagIdList = new ArrayList<Long>();
            tagPriorities = new ArrayList<Integer>();
            cur = getDB().getDatabase().rawQuery(""SELECT tag, id, priority FROM tags"", null);
            while (cur.moveToNext()) {
                tagNames.add(cur.getString(0).toLowerCase());
                tagIdList.add(cur.getLong(1));
                tagPriorities.add(cur.getInt(2));
            }
        } catch (SQLException e) {
            Log.e(AnkiDroidApp.TAG, ""updateTagPriorities: Error while tag priorities: "" + e.toString());
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        HashMap<String, Integer> typeAndPriorities = new HashMap<String, Integer>();
        typeAndPriorities.put(mLowPriority, 1);
        typeAndPriorities.put(mMedPriority, 3);
        typeAndPriorities.put(mHighPriority, 4);
        HashMap<String, Integer> up = new HashMap<String, Integer>();
        for (Entry<String, Integer> entry : typeAndPriorities.entrySet()) {
            for (String tag : Utils.parseTags(entry.getKey().toLowerCase())) {
                up.put(tag, entry.getValue());
            }
        }
        String tag = null;
        long tagId = 0l;
        for (int i = 0; i < tagNames.size(); i++) {
            tag = tagNames.get(i);
            tagId = tagIdList.get(i).longValue();
            if (up.containsKey(tag) && (up.get(tag).compareTo(tagPriorities.get(i)) == 0)) {
                newPriorities.put(tagId, up.get(tag));
            } else if ((!up.containsKey(tag)) && (tagPriorities.get(i).intValue() != 2)) {
                newPriorities.put(tagId, 2);
            } else {
                continue;
            }
            try {
            	ContentValues values = new ContentValues();
                values.put(""priority"", newPriorities.get(tagId));
                getDB().update(this, ""tags"", values, ""id = "" + tagId, null);
            } catch (SQLException e) {
                Log.e(AnkiDroidApp.TAG, ""updatePriorities: Error while updating tag priorities for tag "" + tag + "": ""
                        + e.toString());
                continue;
            }
        }
        return newPriorities;
    }


    /**
     * Update priorities for cardIds in bulk. Caller must .reset().
     *
     * @param cardIds List of card IDs identifying whose cards' priorities to update.
     * @param suspend List of tags. The cards from the above list that have those tags will be suspended.
     * @param dirty If true will update the modified value of each card handled.
     */
    private void updatePriorities(long[] cardIds) {
        updatePriorities(cardIds, null, true);
    }


    void updatePriorities(long[] cardIds, String[] suspend, boolean dirty) {
        Cursor cursor = null;
        // Log.i(AnkiDroidApp.TAG, ""updatePriorities - Updating priorities..."");
        // Any tags to suspend
        if (suspend != null && suspend.length > 0) {
            long ids[] = Utils.toPrimitive(tagIds(suspend, false).values());
        	ContentValues values = new ContentValues();
            values.put(""priority"", 0);
            getDB().update(this, ""tags"", values, ""id in "" + Utils.ids2str(ids), null);
        }

        String limit = """";
        if (cardIds.length <= 1000) {
            limit = ""and cardTags.cardId in "" + Utils.ids2str(cardIds);
        }
        String query = ""SELECT cardTags.cardId, CASE WHEN max(tags.priority) > 2 THEN max(tags.priority) ""
                + ""WHEN min(tags.priority) = 1 THEN 1 ELSE 2 END FROM cardTags,tags ""
                + ""WHERE cardTags.tagId = tags.id "" + limit + "" GROUP BY cardTags.cardId"";
        try {
            cursor = getDB().getDatabase().rawQuery(query, null);
            if (cursor.moveToFirst()) {
                int len = cursor.getCount();
                long[][] cards = new long[len][2];
                for (int i = 0; i < len; i++) {
                    cards[i][0] = cursor.getLong(0);
                    cards[i][1] = cursor.getInt(1);
                }

                String extra = """";
                if (dirty) {
                    extra = "", modified = "" + String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now());
                }
                for (int pri = Card.PRIORITY_NONE; pri <= Card.PRIORITY_HIGH; pri++) {
                    int count = 0;
                    for (int i = 0; i < len; i++) {
                        if (cards[i][1] == pri) {
                            count++;
                        }
                    }
                    long[] cs = new long[count];
                    int j = 0;
                    for (int i = 0; i < len; i++) {
                        if (cards[i][1] == pri) {
                            cs[j] = cards[i][0];
                            j++;
                        }
                    }
                    // Catch review early & buried but not suspended cards
                	ContentValues values = new ContentValues();
                    values.put(""priority"", pri + extra);
                    getDB().update(this, ""cards"", values, ""id IN "" + Utils.ids2str(cs) + "" AND priority != "" + pri + "" AND "" + ""priority >= -2"", null);
                }
            }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
    }


    /*
     * Counts related to due cards *********************************************************
     */

    private int newCardsDoneToday() {
        return mDailyStats.getNewCardsCount();
    }


    /*
     * Cards CRUD*********************************************************
     */

    /**
     * Bulk delete cards by ID. Caller must .reset()
     *
     * @param ids List of card IDs of the cards to be deleted.
     */
    public void deleteCards(List<String> ids) {
        // Log.i(AnkiDroidApp.TAG, ""deleteCards = "" + ids.toString());
        String undoName = UNDO_TYPE_DELETE_CARD;
        if (ids.size() == 1) {
            setUndoStart(undoName, Long.parseLong(ids.get(0)));
        } else {
            setUndoStart(undoName);
        }
        // Bulk delete cards by ID
        if (ids != null && ids.size() > 0) {
            commitToDB();
            double now = Utils.now();
            // Log.i(AnkiDroidApp.TAG, ""Now = "" + now);
            String idsString = Utils.ids2str(ids);

            // Grab fact ids
            // ArrayList<String> factIds = ankiDB.queryColumn(String.class,
            // ""SELECT factId FROM cards WHERE id in "" + idsString,
            // 0);

            // Delete cards
            getDB().delete(this, ""cards"", ""id IN "" + idsString, null);

            // Note deleted cards
            for (String id : ids) {
                ContentValues values = new ContentValues();
                values.put(""cardId"", id);
                values.put(""deletedTime"", String.format(Utils.ENGLISH_LOCALE, ""%f"", now));
                getDB().insert(this, ""cardsDeleted"", null, values);
            }

            // Gather affected tags (before we delete the corresponding cardTags)
            ArrayList<String> tags = getDB().queryColumn(String.class,
                    ""SELECT tagId FROM cardTags WHERE cardId in "" + idsString, 0);

            // Delete cardTags
            getDB().delete(this, ""cardTags"", ""cardId IN "" + idsString, null);

            // Find out if this tags are used by anything else
            ArrayList<String> unusedTags = new ArrayList<String>();
            for (String tagId : tags) {
                Cursor cursor = null;
                try {
                    cursor = getDB().getDatabase().rawQuery(
                            ""SELECT * FROM cardTags WHERE tagId = "" + tagId + "" LIMIT 1"", null);
                    if (!cursor.moveToFirst()) {
                        unusedTags.add(tagId);
                    }
                } finally {
                    if (cursor != null && !cursor.isClosed()) {
                        cursor.close();
                    }
                }
            }

            // Delete unused tags
            getDB().delete(this, ""tags"", ""id in "" + Utils.ids2str(unusedTags) + "" and priority = ""
                            + Card.PRIORITY_NORMAL, null);

            // Remove any dangling fact
            deleteDanglingFacts();
            setUndoEnd(undoName);
            flushMod();
        }
    }


    /*
     * Facts CRUD*********************************************************
     */

    /**
     * Add a fact to the deck. Return list of new cards
     */
    public Fact addFact(Fact fact, HashMap<Long, CardModel> cardModels) {
        return addFact(fact, cardModels, true);
    }


    public Fact addFact(Fact fact, HashMap<Long, CardModel> cardModels, boolean reset) {
        // TODO: assert fact is Valid
        // TODO: assert fact is Unique
        double now = Utils.now();
        // add fact to fact table
        ContentValues values = new ContentValues();
        values.put(""id"", fact.getId());
        values.put(""modelId"", fact.getModelId());
        values.put(""created"", now);
        values.put(""modified"", now);
        values.put(""tags"", fact.getTags());
        values.put(""spaceUntil"", 0);
        getDB().insert(this, ""facts"", null, values);

        // get cardmodels for the new fact
        // TreeMap<Long, CardModel> availableCardModels = availableCardModels(fact);
        if (cardModels.isEmpty()) {
            Log.e(AnkiDroidApp.TAG, ""Error while adding fact: No cardmodels for the new fact"");
            return null;
        }
        // update counts
        mFactCount++;

        // add fields to fields table
        for (Field f : fact.getFields()) {
            // Re-use the content value
            values.clear();
            values.put(""value"", f.getValue());
            values.put(""id"", f.getId());
            values.put(""factId"", f.getFactId());
            values.put(""fieldModelId"", f.getFieldModelId());
            values.put(""ordinal"", f.getOrdinal());
            getDB().insert(this, ""fields"", null, values);
        }

        ArrayList<Long> newCardIds = new ArrayList<Long>();
        for (Map.Entry<Long, CardModel> entry : cardModels.entrySet()) {
            CardModel cardModel = entry.getValue();
            Card newCard = new Card(this, fact, cardModel, Utils.now());
            newCard.addToDb();
            newCardIds.add(newCard.getId());
            mCardCount++;
            mNewCount++;
            // Log.i(AnkiDroidApp.TAG, entry.getKey().toString());
        }
        commitToDB();
        // TODO: code related to random in newCardOrder

        // Update card q/a
        fact.setModified(true, this);
        updateFactTags(new long[] { fact.getId() });

        // This will call reset() which will update counts
        updatePriorities(Utils.toPrimitive(newCardIds));

        flushMod();
        if (reset) {
            reset();
        }

        return fact;
    }


    public boolean importFact(Fact fact, CardModel cardModel) {
        double now = Utils.now();
        // add fact to fact table
        ContentValues values = new ContentValues();
        values.put(""id"", fact.getId());
        values.put(""modelId"", fact.getModelId());
        values.put(""created"", now);
        values.put(""modified"", now);
        values.put(""tags"", """");
        values.put(""spaceUntil"", 0);
        getDB().insert(this, ""facts"", null, values);

        // add fields to fields table
        for (Field f : fact.getFields()) {
            values.clear();
            values.put(""value"", f.getValue());
            values.put(""id"", f.getId());
            values.put(""factId"", f.getFactId());
            values.put(""fieldModelId"", f.getFieldModelId());
            values.put(""ordinal"", f.getOrdinal());
            getDB().insert(this, ""fields"", null, values);
        }

        Card newCard = new Card(this, fact, cardModel, Utils.now());
        HashMap<String, String> newQA = CardModel.formatQA(fact, newCard.getCardModel(), newCard.splitTags());
        newCard.setQuestion(newQA.get(""question""));
        newCard.setAnswer(newQA.get(""answer""));
        newCard.addToDb();

        return true;
    }


    /**
     * Bulk delete facts by ID. Don't touch cards, assume any cards have already been removed. Caller must .reset().
     *
     * @param ids List of fact IDs of the facts to be removed.
     */
    public void deleteFacts(List<String> ids) {
        // Log.i(AnkiDroidApp.TAG, ""deleteFacts = "" + ids.toString());
        int len = ids.size();
        if (len > 0) {
            commitToDB();
            double now = Utils.now();
            String idsString = Utils.ids2str(ids);
            // Log.i(AnkiDroidApp.TAG, ""DELETE FROM facts WHERE id in "" + idsString);
            getDB().delete(this, ""facts"", ""id in "" + idsString, null);
            // Log.i(AnkiDroidApp.TAG, ""DELETE FROM fields WHERE factId in "" + idsString);
            getDB().delete(this, ""fields"", ""factId in "" + idsString, null);
            for (String id : ids) {
                ContentValues values = new ContentValues();
                values.put(""factId"", id);
                values.put(""deletedTime"", String.format(Utils.ENGLISH_LOCALE, ""%f"", now));
            	// Log.i(AnkiDroidApp.TAG, ""inserting into factsDeleted"");
                getDB().insert(this, ""factsDeleted"", null, values);
            }
            setModified();
        }
    }


    /**
     * Delete any fact without cards.
     *
     * @return ArrayList<String> list with the id of the deleted facts
     */
    private ArrayList<String> deleteDanglingFacts() {
        // Log.i(AnkiDroidApp.TAG, ""deleteDanglingFacts"");
        ArrayList<String> danglingFacts = getDB().queryColumn(String.class,
                ""SELECT facts.id FROM facts WHERE facts.id NOT IN (SELECT DISTINCT factId from cards)"", 0);

        if (danglingFacts.size() > 0) {
            deleteFacts(danglingFacts);
        }

        return danglingFacts;
    }


    /*
     * Models CRUD*********************************************************
     */

    /**
     * Delete MODEL, and all its cards/facts. Caller must .reset() TODO: Handling of the list of models and currentModel
     *
     * @param id The ID of the model to be deleted.
     */
    public void deleteModel(String id) {
        // Log.i(AnkiDroidApp.TAG, ""deleteModel = "" + id);
        Cursor cursor = null;
        boolean modelExists = false;

        try {
            cursor = getDB().getDatabase().rawQuery(""SELECT * FROM models WHERE id = "" + id, null);
            // Does the model exist?
            if (cursor.moveToFirst()) {
                modelExists = true;
            }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }

        if (modelExists) {
            // Delete the cards that use the model id, through fact
            ArrayList<String> cardsToDelete = getDB()
                    .queryColumn(
                            String.class,
                            ""SELECT cards.id FROM cards, facts WHERE facts.modelId = "" + id
                                    + "" AND facts.id = cards.factId"", 0);
            deleteCards(cardsToDelete);

            // Delete model
            getDB().delete(this, ""models"", ""id = "" + id, null);

            // Note deleted model
            ContentValues values = new ContentValues();
            values.put(""modelId"", id);
            values.put(""deletedTime"", Utils.now());
            getDB().insert(this, ""modelsDeleted"", null, values);

            flushMod();
        }
    }


    public void deleteFieldModel(String modelId, String fieldModelId) {
        // Log.i(AnkiDroidApp.TAG, ""deleteFieldModel, modelId = "" + modelId + "", fieldModelId = "" + fieldModelId);

        // Delete field model
        getDB().delete(this, ""fields"", ""fieldModel = "" + fieldModelId, null);

        // Note like modified the facts that use this model
        getDB().getDatabase().execSQL(
                ""UPDATE facts SET modified = "" + String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now())
                        + "" WHERE modelId = "" + modelId);

        // TODO: remove field model from list

        // Update Question/Answer formats
        // TODO: All these should be done with the field object
        String fieldName = """";
        Cursor cursor = null;
        try {
            cursor = getDB().getDatabase().rawQuery(""SELECT name FROM fieldModels WHERE id = "" + fieldModelId, null);
            if (cursor.moveToNext()) {
                fieldName = cursor.getString(0);
            }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }

        SQLiteStatement statement = null;
        try {
            cursor = getDB().getDatabase().rawQuery(
                    ""SELECT id, qformat, aformat FROM cardModels WHERE modelId = "" + modelId, null);
            String sql = ""UPDATE cardModels SET qformat = ?, aformat = ? WHERE id = ?"";
            statement = getDB().getDatabase().compileStatement(sql);
            while (cursor.moveToNext()) {
                String id = cursor.getString(0);
                String newQFormat = cursor.getString(1);
                String newAFormat = cursor.getString(2);

                newQFormat = newQFormat.replace(""%%("" + fieldName + "")s"", """");
                newQFormat = newQFormat.replace(""%%(text:"" + fieldName + "")s"", """");
                newAFormat = newAFormat.replace(""%%("" + fieldName + "")s"", """");
                newAFormat = newAFormat.replace(""%%(text:"" + fieldName + "")s"", """");

                statement.bindString(1, newQFormat);
                statement.bindString(2, newAFormat);
                statement.bindString(3, id);

                statement.execute();
            }
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        statement.close();

        // TODO: updateCardsFromModel();

        // Note the model like modified (TODO: We should use the object model instead handling the DB directly)
    	ContentValues values = new ContentValues();
        values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
        getDB().update(this, ""models"", values, ""id = "" + modelId, null);
        flushMod();
    }


    public void deleteCardModel(String modelId, String cardModelId) {
        // Log.i(AnkiDroidApp.TAG, ""deleteCardModel, modelId = "" + modelId + "", fieldModelId = "" + cardModelId);

        // Delete all cards that use card model from the deck
        ArrayList<String> cardIds = getDB().queryColumn(String.class,
                ""SELECT id FROM cards WHERE cardModelId = "" + cardModelId, 0);
        deleteCards(cardIds);

        // I assume that the line ""model.cardModels.remove(cardModel)"" actually deletes cardModel from DB (I might be
        // wrong)
        getDB().delete(this, ""cardModels"", ""id = "" + cardModelId, null);

        // Note the model like modified (TODO: We should use the object model instead handling the DB directly)
    	ContentValues values = new ContentValues();
        values.put(""modified"", String.format(Utils.ENGLISH_LOCALE, ""%f"", Utils.now()));
        getDB().update(this, ""models"", values, ""id = "" + modelId, null);
        flushMod();
    }


    /*
    // CSS for all the fields
    private String rebuildCSS() {
        StringBuilder css = new StringBuilder(512);
        Cursor cur = null;

        try {
            cur = getDB().getDatabase().rawQuery(
                    ""SELECT id, quizFontFamily, quizFontSize, quizFontColour, -1, ""
                            + ""features, editFontFamily FROM fieldModels"", null);
            while (cur.moveToNext()) {
                css.append(_genCSS("".fm"", cur));
            }
            cur.close();
            cur = getDB().getDatabase().rawQuery(""SELECT id, null, null, null, questionAlign, 0, 0 FROM cardModels"",
                    null);
            StringBuilder cssAnswer = new StringBuilder(512);
            while (cur.moveToNext()) {
                css.append(_genCSS(""#cmq"", cur));
                cssAnswer.append(_genCSS(""#cma"", cur));
            }
            css.append(cssAnswer.toString());
            cur.close();
            cur = getDB().getDatabase().rawQuery(""SELECT id, lastFontColour FROM cardModels"", null);
            while (cur.moveToNext()) {
                css.append("".cmb"").append(Utils.hexifyID(cur.getLong(0))).append("" {background:"").append(
                        cur.getString(1)).append("";}\n"");
            }
        } finally {
            if (cur != null && !cur.isClosed()) {
                cur.close();
            }
        }
        setVar(""cssCache"", css.toString(), false);
        addHexCache();

        return css.toString();
    }


    private String _genCSS(String prefix, Cursor row) {
        StringBuilder t = new StringBuilder(256);
        long id = row.getLong(0);
        String fam = row.getString(1);
        int siz = row.getInt(2);
        String col = row.getString(3);
        int align = row.getInt(4);
        String rtl = row.getString(5);
        int pre = row.getInt(6);
        if (fam != null) {
            t.append(""font-family:\"""").append(fam).append(""\"";"");
        }
        if (siz != 0) {
            t.append(""font-size:"").append(siz).append(""px;"");
        }
        if (col != null) {
            t.append(""color:"").append(col).append("";"");
        }
        if (rtl != null && rtl.compareTo(""rtl"") == 0) {
            t.append(""direction:rtl;unicode-bidi:embed;"");
        }
        if (pre != 0) {
            t.append(""white-space:pre-wrap;"");
        }
        if (align != -1) {
            if (align == 0) {
                t.append(""text-align:center;"");
            } else if (align == 1) {
                t.append(""text-align:left;"");
            } else {
                t.append(""text-align:right;"");
            }
        }
        if (t.length() > 0) {
            t.insert(0, prefix + Utils.hexifyID(id) + "" {"").append(""}\n"");
        }
        return t.toString();
    }


    private void addHexCache() {
        ArrayList<Long> ids = getDB().queryColumn(Long.class,
                ""SELECT id FROM fieldModels UNION SELECT id FROM cardModels UNION SELECT id FROM models"", 0);
        JSONObject jsonObject = new JSONObject();
        for (Long id : ids) {
            try {
                jsonObject.put(id.toString(), Utils.hexifyID(id.longValue()));
            } catch (JSONException e) {
                Log.e(AnkiDroidApp.TAG, ""addHexCache: Error while generating JSONObject: "" + e.toString());
                throw new RuntimeException(e);
            }
        }
        setVar(""hexCache"", jsonObject.toString(), false);
    }
    */

    //
    // Syncing
    // *************************
    // Toggling does not bump deck mod time, since it may happen on upgrade and the variable is not synced

    // public void enableSyncing() {
    // enableSyncing(true);
    // }

    // public void enableSyncing(boolean ls) {
    // mSyncName = Utils.checksum(mDeckPath);
    // if (ls) {
    // mLastSync = 0;
    // }
    // commitToDB();
    // }

    // private void disableSyncing() {
    // disableSyncing(true);
    // }
    // private void disableSyncing(boolean ls) {
    // mSyncName = """";
    // if (ls) {
    // mLastSync = 0;
    // }
    // commitToDB();
    // }

    // public boolean syncingEnabled() {
    // return (mSyncName != null) && !(mSyncName.equals(""""));
    // }

    // private void checkSyncHash() {
    // if ((mSyncName != null) && !mSyncName.equals(Utils.checksum(mDeckPath))) {
    // disableSyncing();
    // }
    // }

    /*
     * Undo/Redo*********************************************************
     */

    private class UndoRow {
        private String mName;
        private Long mCardId;
        private ArrayList<UndoCommand> mUndoCommands;

        UndoRow(String name, Long cardId) {
            mName = name;
            mCardId = cardId;
            mUndoCommands = new ArrayList<UndoCommand>();
        }
    }


    private class UndoCommand {
        private SqlCommandType mCommand;
        private String mTable;
        private ContentValues mValues;
        private String mWhereClause;

        UndoCommand(SqlCommandType command, String table, ContentValues values, String whereClause) {
        	mCommand = command;
        	mTable = table;
        	mValues = values;
        	mWhereClause = whereClause;
        }
    }


    private void initUndo() {
        mUndoStack = new Stack<UndoRow>();
        mRedoStack = new Stack<UndoRow>();
        mUndoEnabled = true;
    }


    public String undoName() {
        return mUndoStack.peek().mName;
    }


    public String redoName() {
        return mRedoStack.peek().mName;
    }


    public boolean undoAvailable() {
        return (mUndoEnabled && !mUndoStack.isEmpty());
    }


    public boolean redoAvailable() {
        return (mUndoEnabled && !mRedoStack.isEmpty());
    }


    public void resetUndo() {
        mUndoStack.clear();
        mRedoStack.clear();
    }


    //XXX: this method has never been used.
    /*
    private void setUndoBarrier() {
        if (mUndoStack.isEmpty() || mUndoStack.peek() != null) {
            mUndoStack.push(null);
        }
    }
    */


    public void setUndoStart(String name) {
        setUndoStart(name, 0, false);
    }

    public void setUndoStart(String name, long cardId) {
        setUndoStart(name, cardId, false);
    }


    /**
     * @param reviewEarly set to true for early review
     */
    public void setReviewEarly(boolean reviewEarly) {
        mReviewEarly = reviewEarly;
    }


    private void setUndoStart(String name, long cardId, boolean merge) {
        if (!mUndoEnabled) {
            return;
        }
        if (merge && !mUndoStack.isEmpty()) {
            if ((mUndoStack.peek() != null) && (mUndoStack.peek().mName.equals(name))) {
                // libanki: merge with last entry?
                return;
            }
        }
        mUndoStack.push(new UndoRow(name, cardId));
        if (mUndoStack.size() > 20) {
        	mUndoStack.removeElementAt(0);
        }
        startRecordingUndoInfo(mUndoStack);
    }


    public void setUndoEnd(String name) {
        if (!mUndoEnabled) {
            return;
        }
        while (mUndoStack.peek() == null) {
            mUndoStack.pop(); // Strip off barrier
        }
        UndoRow row = mUndoStack.peek();
        if (row.mUndoCommands.size() == 0) {
            mUndoStack.pop();
        } else {
            mRedoStack.clear();
        }
        stopRecordingUndoInfo();
    }

    private void startRecordingUndoInfo(Stack<UndoRow> dst) {
        mUndoRedoStackToRecord = dst;
    }

    private void stopRecordingUndoInfo() {
        mUndoRedoStackToRecord = null;
    }

    public boolean recordUndoInformation() {
    	return mUndoEnabled && (mUndoRedoStackToRecord != null);
    }


    public void addUndoCommand(SqlCommandType command, String table, ContentValues values, String whereClause) {
	if(!mUndoRedoStackToRecord.empty()) {
	    	mUndoRedoStackToRecord.peek().mUndoCommands.add(new UndoCommand(command, table, values, whereClause));
	}
    }


    private long undoredo(Stack<UndoRow> src, Stack<UndoRow> dst, long oldCardId, boolean inReview) {
        UndoRow row;
        while (true) {
            row = src.pop();
            if (row != null) {
                break;
            }
        }
        if (inReview) {
           dst.push(new UndoRow(row.mName, row.mCardId));
        } else {
           dst.push(new UndoRow(row.mName, oldCardId));
        }
        startRecordingUndoInfo(dst);
        getDB().getDatabase().beginTransaction();
        try {
            for (UndoCommand u : row.mUndoCommands) {
                getDB().execSQL(this, u.mCommand, u.mTable, u.mValues, u.mWhereClause);
            }
            getDB().getDatabase().setTransactionSuccessful();
        } finally {
        	stopRecordingUndoInfo();
        	getDB().getDatabase().endTransaction();
        }
        if (row.mUndoCommands.size() == 0) {
        	dst.pop();
        }
        mCurrentUndoRedoType = row.mName;
        return row.mCardId;
    }

    /**
     * Undo the last action(s). Caller must .reset()
     */
    public long undo(long oldCardId, boolean inReview) {
        long cardId = 0;
    	if (!mUndoStack.isEmpty()) {
            cardId = undoredo(mUndoStack, mRedoStack, oldCardId, inReview);
            commitToDB();
            reset();
        }
        return cardId;
    }


    /**
     * Redo the last action(s). Caller must .reset()
     */
    public long redo(long oldCardId, boolean inReview) {
        long cardId = 0;
        if (!mRedoStack.isEmpty()) {
        	cardId = undoredo(mRedoStack, mUndoStack, oldCardId, inReview);
            commitToDB();
            reset();
        }
        return cardId;
    }


    public String getUndoType() {
    	return mCurrentUndoRedoType;
    }

    /*
     * Dynamic indices*********************************************************
     */

    private void updateDynamicIndices() {
        // Log.i(AnkiDroidApp.TAG, ""updateDynamicIndices - Updating indices..."");
        HashMap<String, String> indices = new HashMap<String, String>();
        indices.put(""intervalDesc"", ""(type, priority desc, interval desc, factId, combinedDue)"");
        indices.put(""intervalAsc"", ""(type, priority desc, interval, factId, combinedDue)"");
        indices.put(""randomOrder"", ""(type, priority desc, factId, ordinal, combinedDue)"");
        indices.put(""dueAsc"", ""(type, priority desc, due, factId, combinedDue)"");
        indices.put(""dueDesc"", ""(type, priority desc, due desc, factId, combinedDue)"");

        ArrayList<String> required = new ArrayList<String>();
        if (mRevCardOrder == REV_CARDS_OLD_FIRST) {
            required.add(""intervalDesc"");
        }
        if (mRevCardOrder == REV_CARDS_NEW_FIRST) {
            required.add(""intervalAsc"");
        }
        if (mRevCardOrder == REV_CARDS_RANDOM) {
            required.add(""randomOrder"");
        }
        if (mRevCardOrder == REV_CARDS_DUE_FIRST || mNewCardOrder == NEW_CARDS_OLD_FIRST
                || mNewCardOrder == NEW_CARDS_RANDOM) {
            required.add(""dueAsc"");
        }
        if (mNewCardOrder == NEW_CARDS_NEW_FIRST) {
            required.add(""dueDesc"");
        }

        // Add/delete
        boolean analyze = false;
        Set<Entry<String, String>> entries = indices.entrySet();
        Iterator<Entry<String, String>> iter = entries.iterator();
        String indexName = null;
        while (iter.hasNext()) {
            Entry<String, String> entry = iter.next();
            indexName = ""ix_cards_"" + entry.getKey() + ""2"";
            if (required.contains(entry.getKey())) {
                Cursor cursor = null;
                try {
                    cursor = getDB().getDatabase().rawQuery(
                            ""SELECT 1 FROM sqlite_master WHERE name = '"" + indexName + ""'"", null);
                    if ((!cursor.moveToNext()) || (cursor.getInt(0) != 1)) {
                        getDB().getDatabase().execSQL(""CREATE INDEX "" + indexName + "" ON cards "" + entry.getValue());
                        analyze = true;
                    }
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            } else {
                // Leave old indices for older clients
                getDB().getDatabase().execSQL(""DROP INDEX IF EXISTS "" + indexName);
            }
        }
        if (analyze) {
            getDB().getDatabase().execSQL(""ANALYZE"");
        }
    }


    /*
     * JSON
     */

    public JSONObject bundleJson(JSONObject bundledDeck) {
        try {
            bundledDeck.put(""averageFactor"", mAverageFactor);
            bundledDeck.put(""cardCount"", mCardCount);
            bundledDeck.put(""collapseTime"", mCollapseTime);
            bundledDeck.put(""created"", mCreated);
            // bundledDeck.put(""currentModelId"", mCurrentModelId); //XXX: Why? I believe this should is sent by AnkiDesktop.
            bundledDeck.put(""delay0"", mDelay0);
            bundledDeck.put(""delay1"", mDelay1);
            bundledDeck.put(""delay2"", mDelay2);
            bundledDeck.put(""description"", mDescription);
            bundledDeck.put(""easyIntervalMax"", mEasyIntervalMax);
            bundledDeck.put(""easyIntervalMin"", mEasyIntervalMin);
            bundledDeck.put(""factCount"", mFactCount);
            bundledDeck.put(""failedCardMax"", mFailedCardMax);
            bundledDeck.put(""failedNowCount"", mFailedNowCount);
            bundledDeck.put(""failedSoonCount"", mFailedSoonCount);
            bundledDeck.put(""hardIntervalMax"", mHardIntervalMax);
            bundledDeck.put(""hardIntervalMin"", mHardIntervalMin);
            bundledDeck.put(""highPriority"", mHighPriority);
            bundledDeck.put(""id"", mId);
            bundledDeck.put(""lastLoaded"", mLastLoaded);
            bundledDeck.put(""lastSync"", mLastSync);
            bundledDeck.put(""lowPriority"", mLowPriority);
            bundledDeck.put(""medPriority"", mMedPriority);
            bundledDeck.put(""midIntervalMax"", mMidIntervalMax);
            bundledDeck.put(""midIntervalMin"", mMidIntervalMin);
            bundledDeck.put(""modified"", mModified);
            bundledDeck.put(""newCardModulus"", mNewCardModulus);
            bundledDeck.put(""newCardSpacing"", mNewCardSpacing);
            bundledDeck.put(""newCardOrder"", mNewCardOrder);
            bundledDeck.put(""newCardsPerDay"", mNewCardsPerDay);
            bundledDeck.put(""sessionTimeLimit"", mSessionTimeLimit);
            bundledDeck.put(""sessionRepLimit"", mSessionRepLimit);
            bundledDeck.put(""newCount"", mNewCount);
            bundledDeck.put(""newCountToday"", mNewCountToday);
            bundledDeck.put(""newEarly"", mNewEarly);
            bundledDeck.put(""revCardOrder"", mRevCardOrder);
            bundledDeck.put(""revCount"", mRevCount);
            bundledDeck.put(""reviewEarly"", mReviewEarly);
            bundledDeck.put(""suspended"", mSuspended);
            bundledDeck.put(""undoEnabled"", mUndoEnabled); //XXX: this is synced in Anki 1.2.8, but I believe it should not be, as it's useless.
            bundledDeck.put(""utcOffset"", mUtcOffset);
        } catch (JSONException e) {
            // Log.i(AnkiDroidApp.TAG, ""JSONException = "" + e.getMessage());
        }

        return bundledDeck;
    }


    public void updateFromJson(JSONObject deckPayload) {
        try {
            // Update deck
            mCardCount = deckPayload.getInt(""cardCount"");
            mCollapseTime = deckPayload.getDouble(""collapseTime"");
            mCreated = deckPayload.getDouble(""created"");
            // css
            mCurrentModelId = deckPayload.getLong(""currentModelId"");
            mDelay0 = deckPayload.getLong(""delay0"");
            mDelay1 = deckPayload.getLong(""delay1"");
            mDelay2 = deckPayload.getDouble(""delay2"");
            mDescription = deckPayload.getString(""description"");
            mDueCutoff = deckPayload.getDouble(""dueCutoff"");
            mEasyIntervalMax = deckPayload.getDouble(""easyIntervalMax"");
            mEasyIntervalMin = deckPayload.getDouble(""easyIntervalMin"");
            mFactCount = deckPayload.getInt(""factCount"");
            mFailedCardMax = deckPayload.getInt(""failedCardMax"");
            mFailedNowCount = deckPayload.getInt(""failedNowCount"");
            mFailedSoonCount = deckPayload.getInt(""failedSoonCount"");
            // forceMediaDir
            mHardIntervalMax = deckPayload.getDouble(""hardIntervalMax"");
            mHardIntervalMin = deckPayload.getDouble(""hardIntervalMin"");
            mHighPriority = deckPayload.getString(""highPriority"");
            mId = deckPayload.getLong(""id"");
            // key
            mLastLoaded = deckPayload.getDouble(""lastLoaded"");
            // lastSessionStart
            mLastSync = deckPayload.getDouble(""lastSync"");
            // lastTags
            mLowPriority = deckPayload.getString(""lowPriority"");
            mMedPriority = deckPayload.getString(""medPriority"");
            mMidIntervalMax = deckPayload.getDouble(""midIntervalMax"");
            mMidIntervalMin = deckPayload.getDouble(""midIntervalMin"");
            mModified = deckPayload.getDouble(""modified"");
            // needLock
            mNewCardOrder = deckPayload.getInt(""newCardOrder"");
            mNewCardSpacing = deckPayload.getInt(""newCardSpacing"");
            mNewCardsPerDay = deckPayload.getInt(""newCardsPerDay"");
            mNewCount = deckPayload.getInt(""newCount"");
            // progressHandlerCalled
            // progressHandlerEnabled
            mQueueLimit = deckPayload.getInt(""queueLimit"");
            mRevCardOrder = deckPayload.getInt(""revCardOrder"");
            mRevCount = deckPayload.getInt(""revCount"");
            mScheduler = deckPayload.getString(""scheduler"");
            mSessionRepLimit = deckPayload.getInt(""sessionRepLimit"");
            // sessionStartReps
            // sessionStartTime
            mSessionTimeLimit = deckPayload.getInt(""sessionTimeLimit"");
            mSuspended = deckPayload.getString(""suspended"");
            // tmpMediaDir
            //mUndoEnabled = deckPayload.getBoolean(""undoEnabled""); //XXX: this is synced in Anki 1.2.8, but it should not be... it causes a bug!
            mUtcOffset = deckPayload.getDouble(""utcOffset"");

            commitToDB();
        } catch (JSONException e) {
            // Log.i(AnkiDroidApp.TAG, ""JSONException = "" + e.getMessage());
        }
    }


    /*
     * Utility functions (might be better in a separate class) *********************************************************
     */

    /**
     * Return ID for tag, creating if necessary.
     *
     * @param tag the tag we are looking for
     * @param create whether to create the tag if it doesn't exist in the database
     * @return ID of the specified tag, 0 if it doesn't exist, and -1 in the case of error
     */
    private long tagId(String tag, Boolean create) {
        long id = 0;

        try {
            id = getDB().queryScalar(""select id from tags where tag = \"""" + tag + ""\"""");
        } catch (SQLException e) {
            if (create) {
                ContentValues value = new ContentValues();
                value.put(""tag"", tag);
                id = getDB().insert(this, ""tags"", null, value);
            } else {
                id = 0;
            }
        }
        return id;
    }


    /**
     * Gets the IDs of the specified tags.
     *
     * @param tags An array of the tags to get IDs for.
     * @param create Whether to create the tag if it doesn't exist in the database. Default = true
     * @return An array of IDs of the tags.
     */
    private HashMap<String, Long> tagIds(String[] tags) {
        return tagIds(tags, true);
    }


    private HashMap<String, Long> tagIds(String[] tags, boolean create) {
        HashMap<String, Long> results = new HashMap<String, Long>();

        if (create) {
            for (String tag : tags) {
                getDB().getDatabase().execSQL(""INSERT OR IGNORE INTO tags (tag) VALUES ('"" + tag.replace(""'"", ""''"") + ""')"");
            }
        }
        if (tags.length != 0) {
            StringBuilder tagList = new StringBuilder(128);
            for (int i = 0; i < tags.length; i++) {
                tagList.append(""'"").append(tags[i].replaceAll(""\\'+"", ""\'\'"")).append(""'"");
                if (i < tags.length - 1) {
                    tagList.append("", "");
                }
            }
            Cursor cur = null;
            try {
                cur = getDB().getDatabase().rawQuery(
                        ""SELECT tag, id FROM tags WHERE tag in ("" + tagList.toString() + "")"", null);
                while (cur.moveToNext()) {
                    results.put(cur.getString(0).toLowerCase(), cur.getLong(1));
                }
            } finally {
                if (cur != null && !cur.isClosed()) {
                    cur.close();
                }
            }
        }
        return results;
    }

    /**
     * Initialize an empty deck that has just been creating by copying the existing ""empty.anki"" file.
     *
     * From Damien:
     * Just copying a file is not sufficient - you need to give each model, cardModel and fieldModel new ids as well, and make sure they are all still linked up. If you don't do that, and people modify one model and then import/export one deck into another, the models will be treated as identical even though they have different layouts, and half the cards will end up corrupted.
     *  It's only the IDs that you have to worry about, and the utcOffset IIRC.
     */
    public static synchronized void initializeEmptyDeck(String deckPath) {
        AnkiDb db = AnkiDatabaseManager.getDatabase(deckPath);

        // Regenerate IDs.
        long modelId = Utils.genID();
        db.getDatabase().execSQL(""UPDATE models SET id="" + modelId);
        db.getDatabase().execSQL(""UPDATE cardModels SET id="" + Utils.genID() + "" where ordinal=0;"");
        db.getDatabase().execSQL(""UPDATE cardModels SET id="" + Utils.genID() + "" where ordinal=1;"");
        db.getDatabase().execSQL(""UPDATE fieldModels SET id="" + Utils.genID() + "" where ordinal=0;"");
        db.getDatabase().execSQL(""UPDATE fieldModels SET id="" + Utils.genID() + "" where ordinal=1;"");

        // Update columns that refer to modelId.
        db.getDatabase().execSQL(""UPDATE fieldModels SET modelId="" + modelId);
        db.getDatabase().execSQL(""UPDATE cardModels SET modelId="" + modelId);
        db.getDatabase().execSQL(""UPDATE decks SET currentModelId="" + modelId);

        // Set the UTC offset.
        db.getDatabase().execSQL(""UPDATE decks SET utcOffset="" + Utils.utcOffset());

        // Set correct creation time
        db.getDatabase().execSQL(""UPDATE decks SET created = "" + Utils.now());
    }


    public ContentValues getDeckSummary() {
    	ContentValues values = new ContentValues();

    	values.put(""cardCount"", (int)getDB().queryScalar(""SELECT count(*) FROM cards""));
    	values.put(""factCount"", (int)getDB().queryScalar(""SELECT count(*) FROM facts""));
    	values.put(""matureCount"", (int)getDB().queryScalar(""SELECT count(*) FROM cards WHERE interval >= 21""));
    	values.put(""unseenCount"", (int)getDB().queryScalar(""SELECT count(*) FROM cards WHERE reps = 0""));
        Cursor cursor = null;
        try {
            cursor = getDB().getDatabase().rawQuery(""SELECT sum(interval) FROM cards WHERE reps > 0"", null);
            if (cursor.moveToFirst()) {
            	values.put(""intervalSum"", (int)cursor.getLong(0));            	
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    	values.put(""repsMatCount"", (int)getDB().queryScalar(""SELECT (matureEase1 + matureEase2 + matureEase3 + matureEase4) FROM stats WHERE type = 0""));
    	values.put(""repsMatNoCount"", (int)getDB().queryScalar(""SELECT (matureEase1) FROM stats WHERE type = 0""));
    	values.put(""repsYoungCount"", (int)getDB().queryScalar(""SELECT (youngEase1 + youngEase2 + youngEase3 + youngEase4) FROM stats WHERE type = 0""));
    	values.put(""repsYoungNoCount"", (int)getDB().queryScalar(""SELECT (youngEase1) FROM stats WHERE type = 0""));
    	values.put(""repsFirstCount"", (int)getDB().queryScalar(""SELECT (newEase1 + newEase2 + newEase3 + newEase4) FROM stats WHERE type = 0""));
    	values.put(""repsFirstNoCount"", (int)getDB().queryScalar(""SELECT (newEase1) FROM stats WHERE type = 0""));

        Date value = Utils.genToday(getUtcOffset() + (86400 * 7));
    	values.put(""reviewsLastWeek"", (int)getDB().queryScalar(String.format(Utils.ENGLISH_LOCALE,
        		""SELECT sum(youngEase1 + youngEase2 + youngEase3 + youngEase4 + matureEase1 + matureEase2 + matureEase3 + matureEase4) FROM stats WHERE day > \'%tF\' AND type = %d"", value, Stats.STATS_DAY)));
    	values.put(""newsLastWeek"", (int)getDB().queryScalar(String.format(Utils.ENGLISH_LOCALE,
        		""SELECT sum(newEase1 + newEase2 + newEase3 + newEase4) FROM stats WHERE day > \'%tF\' AND type = %d"", value, Stats.STATS_DAY)));
        value = Utils.genToday(getUtcOffset() + (86400 * 30));
    	values.put(""reviewsLastMonth"", (int)getDB().queryScalar(String.format(Utils.ENGLISH_LOCALE,
        		""SELECT sum(youngEase1 + youngEase2 + youngEase3 + youngEase4 + matureEase1 + matureEase2 + matureEase3 + matureEase4) FROM stats WHERE day > \'%tF\' AND type = %d"", value, Stats.STATS_DAY)));
    	values.put(""newsLastMonth"", (int)getDB().queryScalar(String.format(Utils.ENGLISH_LOCALE,
        		""SELECT sum(newEase1 + newEase2 + newEase3 + newEase4) FROM stats WHERE day > \'%tF\' AND type = %d"", value, Stats.STATS_DAY)));
        value = Utils.genToday(getUtcOffset() + (86400 * 365));
    	values.put(""reviewsLastYear"", (int)getDB().queryScalar(String.format(Utils.ENGLISH_LOCALE,
        		""SELECT sum(youngEase1 + youngEase2 + youngEase3 + youngEase4 + matureEase1 + matureEase2 + matureEase3 + matureEase4) FROM stats WHERE day > \'%tF\' AND type = %d"", value, Stats.STATS_DAY)));
    	values.put(""newsLastYear"", (int)getDB().queryScalar(String.format(Utils.ENGLISH_LOCALE,
        		""SELECT sum(newEase1 + newEase2 + newEase3 + newEase4) FROM stats WHERE day > \'%tF\' AND type = %d"", value, Stats.STATS_DAY)));
        Float created = 0.0f;
    	try {
            cursor = getDB().getDatabase().rawQuery(""SELECT created FROM decks"", null);
            if (cursor.moveToFirst()) {
            	created = cursor.getFloat(0);
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    	values.put(""deckAge"", (int)((Utils.now() - created) / 86400));
    	int failedCards = getFailedDelayedCount() + getFailedSoonCount();
        int revCards = getNextDueCards(1) + getNextDueCards(0);
        int newCards = Math.min(mNewCardsPerDay, (int)getDB().queryScalar(""SELECT count(*) FROM cards WHERE reps = 0 AND type >= 0""));
        int eta = getETA(failedCards, revCards, newCards, true);
        values.put(""revTomorrow"", (int)(failedCards + revCards));
        values.put(""newTomorrow"", (int)newCards);
        values.put(""timeTomorrow"", (int)eta);
        return values;
    }


    public static boolean isWalEnabled(String deckPath) {
        Cursor cursor = null;
        boolean value = false;
        boolean dbAlreadyOpened = AnkiDatabaseManager.isDatabaseOpen(deckPath);
        try {
            cursor = AnkiDatabaseManager.getDatabase(deckPath).getDatabase().rawQuery(
            		""PRAGMA journal_mode"", null);
        	if (cursor.moveToFirst()) {
        		value = cursor.getString(0).equalsIgnoreCase(""wal"");
        	}
        } finally {
            if (cursor != null && !cursor.isClosed()) {
                cursor.close();
            }
        }
        if (!dbAlreadyOpened) {
            AnkiDatabaseManager.closeDatabase(deckPath);
        }
        return value;
    }

}
",True,16,67,2,2,4,30
53,com.ichi2.anki.CustomExceptionHandler.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki;

import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.os.Environment;
import android.os.StatFs;
import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.TimeZone;

public class CustomExceptionHandler implements Thread.UncaughtExceptionHandler {

    private static CustomExceptionHandler sInstance;
    private Thread.UncaughtExceptionHandler mPreviousHandler;
    private Context mCurContext;
    // private Random randomGenerator = new Random();

    private HashMap<String, String> mInformation = new HashMap<String, String>(20);


    static CustomExceptionHandler getInstance() {
        if (sInstance == null) {
            sInstance = new CustomExceptionHandler();
            // Log.i(AnkiDroidApp.TAG, ""New instance of custom exception handler"");
        }

        return sInstance;
    }


    public void init(Context context) {
        mPreviousHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(this);
        mCurContext = context;
    }


    private long getAvailableInternalMemorySize() {
        File path = Environment.getDataDirectory();
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();
        long availableBlocks = stat.getAvailableBlocks();
        return availableBlocks * blockSize;
    }


    private long getTotalInternalMemorySize() {
        File path = Environment.getDataDirectory();
        StatFs stat = new StatFs(path.getPath());
        long blockSize = stat.getBlockSize();
        long totalBlocks = stat.getBlockCount();
        return totalBlocks * blockSize;
    }


    private void collectInformation() {
        // Log.i(AnkiDroidApp.TAG, ""collectInformation"");

        if (mCurContext == null) {
            return;
        }

        try {
            // Log.i(AnkiDroidApp.TAG, ""collecting information"");

            PackageManager pm = mCurContext.getPackageManager();
            PackageInfo pi = pm.getPackageInfo(mCurContext.getPackageName(), 0);

            mInformation.put(""VersionName"", pi.versionName); // Version
            mInformation.put(""PackageName"", pi.packageName); // Package name
            mInformation.put(""AndroidVersion"", android.os.Build.VERSION.RELEASE); // Android version
            mInformation.put(""Board"", android.os.Build.BOARD);
            mInformation.put(""Brand"", android.os.Build.BRAND);
            mInformation.put(""Device"", android.os.Build.DEVICE);
            mInformation.put(""Display"", android.os.Build.DISPLAY);
            //mInformation.put(""FingerPrint"", android.os.Build.FINGERPRINT);
            mInformation.put(""Host"", android.os.Build.HOST);
            mInformation.put(""ID"", android.os.Build.ID);
            mInformation.put(""Model"", android.os.Build.MODEL);
            mInformation.put(""Product"", android.os.Build.PRODUCT);
            //mInformation.put(""Tags"", android.os.Build.TAGS);
            mInformation.put(""Time"", Long.toString(android.os.Build.TIME));
            //mInformation.put(""Type"", android.os.Build.TYPE);
            //mInformation.put(""User"", android.os.Build.USER);
            mInformation.put(""TotalInternalMemory"", Long.toString(getTotalInternalMemorySize()));
            mInformation.put(""AvailableInternalMemory"", Long.toString(getAvailableInternalMemorySize()));

            // Log.i(AnkiDroidApp.TAG, ""Information collected"");
        } catch (Exception e) {
            // Log.i(AnkiDroidApp.TAG, e.toString());
        }
    }


    @Override
    public void uncaughtException(Thread t, Throwable e) {
    	uncaughtException(t, e, null);
    }
    public void uncaughtException(Thread t, Throwable e, String origin) {
        // Log.i(AnkiDroidApp.TAG, ""uncaughtException"");

        collectInformation();

        Date ts = new Date();
    	TimeZone tz = TimeZone.getDefault();
    	
        SimpleDateFormat df1 = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"", Locale.US);
        SimpleDateFormat df2 = new SimpleDateFormat(""Z"", Locale.US);
        
        df1.setTimeZone(TimeZone.getTimeZone(""UTC""));
        
        String reportgeneratedutc = String.format(""%s"", df1.format(ts));
        String reportgeneratedtzoffset = String.format(""%s"", df2.format(ts));
        String reportgeneratedtz = String.format(""%s"", tz.getID());
        
        StringBuilder reportInformation = new StringBuilder(10000);
        
        reportInformation.append(String.format(""reportgeneratedutc=%s\n"", reportgeneratedutc));
        reportInformation.append(String.format(""reportgeneratedtzoffset=%s\n"", reportgeneratedtzoffset));
        reportInformation.append(String.format(""reportgeneratedtz=%s\n"", reportgeneratedtz));

        if (origin != null && origin.length() > 0) {
        	reportInformation.append(String.format(""origin=%s\n"", origin));
        }

        for (String key : mInformation.keySet()) {
            String value = mInformation.get(key);

            reportInformation.append(String.format(""%s=%s\n"", key.toLowerCase(), value));
        }

        reportInformation.append(""stacktrace=\nBegin Stacktrace\n"");	

        // Stack trace
        final Writer result = new StringWriter();
        final PrintWriter printWriter = new PrintWriter(result);
        e.printStackTrace(printWriter);
        reportInformation.append(String.format(""%s\n"", result.toString()));

        reportInformation.append(""End Stacktrace\n\nBegin Inner exceptions\n"");

        // Cause, inner exceptions
        Throwable cause = e.getCause();
        while (cause != null) {
            cause.printStackTrace(printWriter);
            reportInformation.append(String.format(""%s\n"", result.toString()));
            cause = cause.getCause();
        }
        reportInformation.append(""End Inner exceptions"");

        printWriter.close();

        // Log.i(AnkiDroidApp.TAG, ""report infomation string created"");
        saveReportToFile(reportInformation.toString());

        if (t != null) {
            mPreviousHandler.uncaughtException(t, e);
        }
    }


    private void saveReportToFile(String reportInformation) {
        try {
            // Log.i(AnkiDroidApp.TAG, ""saveReportFile"");

            Date currentDate = new Date();
            SimpleDateFormat formatter = new SimpleDateFormat(""yyyyMMddHHmmss"");
            String filename = String.format(""ad-%s.stacktrace"", formatter.format(currentDate));

            // Log.i(AnkiDroidApp.TAG, ""No external storage available"");
            FileOutputStream trace = mCurContext.openFileOutput(filename, Context.MODE_PRIVATE);
            trace.write(reportInformation.getBytes());
            trace.close();

            // Log.i(AnkiDroidApp.TAG, ""report saved"");
        } catch (Exception e) {
            // Log.i(AnkiDroidApp.TAG, e.toString());
        }
    }
}
",True,67,56,3,45,0,0
54,com.ichi2.anki.services.DownloadManagerService.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.services;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Resources;
import android.database.CursorIndexOutOfBoundsException;
import android.database.SQLException;
import android.os.AsyncTask;
import android.os.IBinder;
import android.os.RemoteCallbackList;
import android.os.RemoteException;
import android.util.Log;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.AnkiDroidProxy;
import com.ichi2.anki.Card;
import com.ichi2.anki.Deck;
import com.ichi2.anki.DeckTask;
import com.ichi2.anki.Download;
import com.ichi2.anki.R;
import com.ichi2.anki.SharedDeckDownload;
import com.ichi2.anki.StudyOptions;
import com.ichi2.anki.Utils;
import com.ichi2.async.Connection;
import com.ichi2.async.Connection.Payload;
import com.tomgibara.android.veecheck.util.PrefSettings;

import java.io.DataOutputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.InflaterInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class DownloadManagerService extends Service {

    // private int counter = 0;
    // private Handler serviceHandler = null;

    // Max size of download buffer.
    private static final int MAX_BUFFER_SIZE = 1024;

    // Regex for finding incomplete downloads shared preferences
    private static final Pattern sNumUpdatedCardsPattern = Pattern.compile(""^numUpdatedCards:.*/([^/]+\\.anki\\.updating)$"");
    private static final Pattern sPausedPattern = Pattern.compile(""^paused:.*/([^/]+\\.anki\\.updating)$"");

    private String mUsername;
    private String mPassword;
    private String mDestination;

    private ArrayList<Download> mPersonalDeckDownloads;
    private final RemoteCallbackList<IPersonalDeckServiceCallback> mPersonalDeckCallbacks = new RemoteCallbackList<IPersonalDeckServiceCallback>();

    private ArrayList<SharedDeckDownload> mSharedDeckDownloads;
    private final RemoteCallbackList<ISharedDeckServiceCallback> mSharedDeckCallbacks = new RemoteCallbackList<ISharedDeckServiceCallback>();


    /********************************************************************
     * Lifecycle methods *
     ********************************************************************/

    @Override
    public void onCreate() {
        super.onCreate();
        // Log.i(AnkiDroidApp.TAG, ""Service - onCreate"");
        mPersonalDeckDownloads = new ArrayList<Download>();
        mSharedDeckDownloads = new ArrayList<SharedDeckDownload>();

        restorePreferences();

        // If there is incomplete work, finish it
        addIncompleteDownloads();
        // Clean up shared preferences of completed downloads
        removeCompletedDownloadsPrefs();
        resumeDownloads();

        // serviceHandler = new Handler();
        // serviceHandler.postDelayed( new RunTask(),1000L );
    }


    @Override
    public void onStart(Intent intent, int startId) {
        // Log.i(AnkiDroidApp.TAG, ""Service - onStart"");
        super.onStart(intent, startId);
        restorePreferences();
    }


    @Override
    public IBinder onBind(Intent intent) {
        // Log.i(AnkiDroidApp.TAG, ""Service - onBind"");
        restorePreferences();
        return mBinder;
    }


    @Override
    public boolean onUnbind(Intent intent) {
        // Log.i(AnkiDroidApp.TAG, ""onUnbind"");
        return super.onUnbind(intent);
    }


    @Override
    public void onDestroy() {
        super.onDestroy();
        // Log.i(AnkiDroidApp.TAG, ""Service - onDestroy"");
        // serviceHandler = null;
    }


    public void stopIfFinished() {
        if (!hasMoreWork()) {
            // Delete tmp folder
            boolean deleted = new File(mDestination + ""/tmp"").delete();
            // Log.i(AnkiDroidApp.TAG, mDestination + ""/tmp folder was deleted = "" + deleted);
            // Log.i(AnkiDroidApp.TAG, ""Service stopping itself..."");
            stopSelf();
        }
    }


    /********************************************************************
     * Custom methods *
     ********************************************************************/

    private boolean hasMoreWork() {
        return (mPersonalDeckDownloads.size() != 0 || mSharedDeckDownloads.size() != 0);
    }


    private void restorePreferences() {
        SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
        mUsername = pref.getString(""username"", """");
        mPassword = pref.getString(""password"", """");
        mDestination = pref.getString(""deckPath"", AnkiDroidApp.getStorageDirectory());
    }


    // It could be part of the AIDL Interface but at the moment no Activity uses it directly
    public void addIncompleteDownloads() {
        // Log.i(AnkiDroidApp.TAG, ""DownloadManagerService - Adding incomplete downloads:"");

        File dir = new File(mDestination + ""/tmp/"");
        File[] fileList = dir.listFiles(new IncompleteDownloadsFilter());

        if (fileList != null) {
            for (File file : fileList) {
                String filename = file.getName();
                // Log.i(AnkiDroidApp.TAG, ""Filename = "" + filename);

                // Personal decks
                if (filename.endsWith("".anki.tmp"")) {
                    Download download = new Download(filename.substring(0, filename.length() - "".anki.tmp"".length()));
                    download.setDownloaded(file.length());
                    mPersonalDeckDownloads.add(download);
                }
                // Shared decks
                else if (filename.endsWith("".shared.zip.tmp"")) {
                    filename = filename.substring(0, filename.length() - "".shared.zip.tmp"".length());
                    int lastDotPosition = filename.lastIndexOf(""."");
                    String identifier = filename.substring(lastDotPosition + 1, filename.length());
                    String title = filename.substring(0, lastDotPosition);

                    SharedDeckDownload download = new SharedDeckDownload(Integer.parseInt(identifier), title);
                    download.setDownloaded(file.length());
                    mSharedDeckDownloads.add(download);
                }
                // Shared but not totally updated decks
                else if (filename.endsWith("".anki.updating"")) {
                    String title = filename.substring(0, filename.length() - "".anki.updating"".length());
                    SharedDeckDownload download = new SharedDeckDownload(title);

                    SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
                    String pausedPref = ""paused:"" + mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"";
                    if (pref.getBoolean(pausedPref, false)) {
                        download.setStatus(SharedDeckDownload.STATUS_PAUSED);
                    } else {
                        download.setStatus(SharedDeckDownload.STATUS_UPDATING);
                    }
                    mSharedDeckDownloads.add(download);
                }
            }
            notifyObservers();
        }
        // If no decks were added, stop the service
        stopIfFinished();
    }

    /**
     * Cleans up the SharedPreferences space from numUpdatedCards records of downloads that have been
     * completed or cancelled.
     */
    public void removeCompletedDownloadsPrefs() {
        // Log.i(AnkiDroidApp.TAG, ""DownloadManagerService - Removing shared preferences of completed or cancelled downloads"");

        File dir = new File(mDestination + ""/tmp/"");
        File[] fileList = dir.listFiles(new IncompleteDownloadsFilter());
        HashSet<String> filenames = new HashSet<String>();

        // Get all incomplete downloads filenames
        if (fileList != null) {
            for (File file : fileList) {
                filenames.add(file.getName());
            }
        }

        // Remove any download related shared preference that doesn't have a corresponding incomplete file
        SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
        Matcher sharedPrefMatcher;
        Editor editor = pref.edit();
        boolean sharedPreferencesChanged = false;
        for (String key : pref.getAll().keySet()) {
            sharedPrefMatcher = sNumUpdatedCardsPattern.matcher(key);
            if (sharedPrefMatcher.matches() && sharedPrefMatcher.groupCount() > 0) {
                if (!filenames.contains(sharedPrefMatcher.group(1))) {
                    editor.remove(key);
                    sharedPreferencesChanged = true;
                }
            }
            sharedPrefMatcher = sPausedPattern.matcher(key);
            if (sharedPrefMatcher.matches() && sharedPrefMatcher.groupCount() > 0) {
                if (!filenames.contains(sharedPrefMatcher.group(1))) {
                    editor.remove(key);
                    sharedPreferencesChanged = true;
                }
            }
        }
        if (sharedPreferencesChanged) {
            editor.commit();
        }
    }


    // It could be part of the AIDL Interface but at the moment no Activity uses it directly
    public void resumeDownloads() {
        int i = 0;
        int j = 0;

        int personalDeckDownloadsSize = mPersonalDeckDownloads.size();
        int sharedDeckDownloadsSize = mSharedDeckDownloads.size();

        // Resume both personal deck downloads and shared deck downloads
        for (i = 0; i < personalDeckDownloadsSize && i < sharedDeckDownloadsSize; i++) {
            resumeDownload(mPersonalDeckDownloads.get(i));
            resumeDownload(mSharedDeckDownloads.get(i));
        }

        // Resume remaining personal deck downloads
        for (j = i; j < personalDeckDownloadsSize; j++) {
            resumeDownload(mPersonalDeckDownloads.get(j));
        }

        // Resume remaining shared deck downloads
        for (j = i; j < sharedDeckDownloadsSize; j++) {
            resumeDownload(mSharedDeckDownloads.get(j));
        }
    }


    // It could be part of the AIDL Interface but at the moment no Activity uses it directly
    public void resumeDownload(Download download) {
        // Create tmp folder where the temporal decks are going to be stored
        new File(mDestination + ""/tmp/"").mkdirs();
        AnkiDroidApp.createNoMediaFileIfMissing(new File(mDestination));

        if (download instanceof SharedDeckDownload) {
            SharedDeckDownload sharedDeckDownload = (SharedDeckDownload) download;
            // We need to go through UpdateDeckTask even when the download is paused, in order for
            // numUpdatedCards and numTotalCards to get updated, so that progress is displayed correctly
            if (sharedDeckDownload.getStatus() == SharedDeckDownload.STATUS_PAUSED ||
                 sharedDeckDownload.getStatus() == SharedDeckDownload.STATUS_UPDATING) {
                new UpdateDeckTask().execute(new Payload(new Object[] { sharedDeckDownload }));
            } else {
                new DownloadSharedDeckTask().execute(sharedDeckDownload);
            }
        } else {
            // TODO: Check if there is already a deck with the same name, and if that's so
            // add the current milliseconds to the end of the name or notify the user
            new DownloadPersonalDeckTask().execute(download);
        }
    }


    private String unzipSharedDeckFile(String zipFilename, String title) {
        ZipInputStream zipInputStream = null;
        // Log.i(AnkiDroidApp.TAG, ""unzipSharedDeckFile"");
        if (zipFilename.endsWith("".zip"")) {
            // Log.i(AnkiDroidApp.TAG, ""zipFilename ends with .zip"");
            try {
                zipInputStream = new ZipInputStream(new FileInputStream(new File(zipFilename)));

                if (new File(mDestination + ""/"" + title + "".anki"").exists()) {
                    title += System.currentTimeMillis();
                }

                String partialDeckPath = mDestination + ""/tmp/"" + title;
                String deckFilename = partialDeckPath + "".anki.updating"";

                ZipEntry zipEntry = null;
                while ((zipEntry = zipInputStream.getNextEntry()) != null) {
                    // Log.i(AnkiDroidApp.TAG, ""zipEntry = "" + zipEntry.getName());

                    if (""shared.anki"".equalsIgnoreCase(zipEntry.getName())) {
                        Utils.writeToFile(zipInputStream, deckFilename);
                    } else if (zipEntry.getName().startsWith(""shared.media/"", 0)) {
                        // Log.i(AnkiDroidApp.TAG, ""Folder created = "" + new File(partialDeckPath + "".media/"").mkdir());
                        // Log.i(AnkiDroidApp.TAG, ""Destination = "" + AnkiDroidApp.getStorageDirectory() + ""/"" + title + "".media/"" + zipEntry.getName().replace(""shared.media/"", """"));
                        Utils.writeToFile(zipInputStream,
                                partialDeckPath + "".media/"" + zipEntry.getName().replace(""shared.media/"", """"));
                    }
                }
                zipInputStream.close();

                // Delete zip file
                new File(zipFilename).delete();
            } catch (FileNotFoundException e) {
                Log.e(AnkiDroidApp.TAG, ""FileNotFoundException = "" + e.getMessage());
                e.printStackTrace();
            } catch (IOException e) {
                Log.e(AnkiDroidApp.TAG, ""IOException = "" + e.getMessage());
                e.printStackTrace();
            }
        }

        return title;
    }


    private int getNextNotificationId() {
        // Retrieve previously saved value
        SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
        int notificationCounter = pref.getInt(""notificationCounter"", 0);

        // Increment it
        notificationCounter++;

        // Save new value
        Editor editor = pref.edit();
        editor.putInt(""notificationCounter"", notificationCounter);
        editor.commit();

        return notificationCounter;
    }


    /********************************************************************
     * Notification methods *
     ********************************************************************/

    /**
     * Show a notification informing the user when a deck is ready to be used
     */
    private void showNotification(String deckTitle, String deckFilename) {
        NotificationManager mNotificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        Resources res = getResources();

        // Set the icon, scrolling text and timestamp
        Notification notification = new Notification(R.drawable.anki, res.getString(R.string.download_finished),
                System.currentTimeMillis());

        String deckPath = mDestination + ""/"" + deckFilename + "".anki"";
        Intent loadDeckIntent = StudyOptions.getLoadDeckIntent(this, deckPath);
        // The PendingIntent to launch our activity if the user selects this notification
        PendingIntent contentIntent = PendingIntent.getActivity(this, 0, loadDeckIntent, 0);

        // Set the info for the views that show in the notification panel
        notification.setLatestEventInfo(this, deckTitle, res.getString(R.string.deck_downloaded), contentIntent);

        // Clear the notification when the user selects it
        notification.flags |= Notification.FLAG_AUTO_CANCEL;

        // Vibrate
        notification.defaults |= Notification.DEFAULT_VIBRATE;

        // Show a blue light
        notification.ledARGB = 0xff0000ff;
        notification.ledOnMS = 500;
        notification.ledOffMS = 1000;
        notification.flags |= Notification.FLAG_SHOW_LIGHTS;

        // Send the notification
        // Log.i(AnkiDroidApp.TAG, ""Sending notification..."");
        mNotificationManager.notify(getNextNotificationId(), notification);
    }


    private synchronized void notifyObservers() {
        notifyPersonalDeckObservers();
        notifySharedDeckObservers();
    }


    private synchronized void notifyPersonalDeckObservers() {
        final int numPersonalDeckCallbacks = mPersonalDeckCallbacks.beginBroadcast();
        for (int i = 0; i < numPersonalDeckCallbacks; i++) {
            try {
                mPersonalDeckCallbacks.getBroadcastItem(i).publishProgress(mPersonalDeckDownloads);
            } catch (RemoteException e) {
                // There is nothing special we need to do if the service has crashed
                Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                e.printStackTrace();
            }
        }
        mPersonalDeckCallbacks.finishBroadcast();
    }


    private synchronized void notifySharedDeckObservers() {
        // Log.i(AnkiDroidApp.TAG, ""notifySharedDeckObservers"");
        final int numSharedDeckCallbacks = mSharedDeckCallbacks.beginBroadcast();
        for (int i = 0; i < numSharedDeckCallbacks; i++) {
            try {
                mSharedDeckCallbacks.getBroadcastItem(i).publishProgress(mSharedDeckDownloads);
            } catch (RemoteException e) {
                // There is nothing special we need to do if the service has crashed
                Log.e(AnkiDroidApp.TAG, ""RemoteException = "" + e.getMessage());
                e.printStackTrace();
            }
        }
        mSharedDeckCallbacks.finishBroadcast();
    }

    /********************************************************************
     * Filters *
     ********************************************************************/

    private static final class IncompleteDownloadsFilter implements FileFilter {
        public boolean accept(File pathname) {
            String filename = pathname.getName();
            // The filter searches for unfinished tasks:
            // * not completed personal deck downloads
            // * not completed shared deck downloads
            // * downloaded but not totally updated shared decks
            if (pathname.isFile()
                    && (filename.endsWith("".anki.tmp"") || filename.endsWith("".shared.zip.tmp"") || filename
                            .endsWith("".anki.updating""))) {
                return true;
            }
            return false;
        }
    }

    /********************************************************************
     * Interfaces *
     ********************************************************************/

    /**
     * IDownloadManagerService is defined through IDL
     */
    private final IDownloadManagerService.Stub mBinder = new IDownloadManagerService.Stub() {

        @Override
        public void registerPersonalDeckCallback(IPersonalDeckServiceCallback cb) {
            // Log.i(AnkiDroidApp.TAG, ""registerPersonalDeckCallback"");
            if (cb != null) {
                mPersonalDeckCallbacks.register(cb);
                notifyPersonalDeckObservers();
            }
        }


        @Override
        public void unregisterPersonalDeckCallback(IPersonalDeckServiceCallback cb) {
            // Log.i(AnkiDroidApp.TAG, ""unregisterPersonalDeckCallback"");
            if (cb != null) {
                mPersonalDeckCallbacks.unregister(cb);
            }
        }


        @Override
        public void registerSharedDeckCallback(ISharedDeckServiceCallback cb) throws RemoteException {
            // Log.i(AnkiDroidApp.TAG, ""registerSharedDeckCallback"");
            if (cb != null) {
                mSharedDeckCallbacks.register(cb);
                notifySharedDeckObservers();
            }
        }


        @Override
        public void unregisterSharedDeckCallback(ISharedDeckServiceCallback cb) throws RemoteException {
            // Log.i(AnkiDroidApp.TAG, ""unregisterSharedDeckCallback"");
            if (cb != null) {
                mSharedDeckCallbacks.unregister(cb);
            }
        }


        @Override
        public void downloadFile(Download download) throws RemoteException {
            if (download instanceof SharedDeckDownload) {
                mSharedDeckDownloads.add((SharedDeckDownload) download);
            } else {
                mPersonalDeckDownloads.add(download);
            }
            resumeDownload(download);
        }


        @Override
        public void resumeDownloadUpdating(Download download) throws RemoteException {
            if (download instanceof SharedDeckDownload) {
                resumeDownload(download);
            }
        }


        @Override
        public List<Download> getPersonalDeckDownloads() throws RemoteException {
            return mPersonalDeckDownloads;
        }


        @Override
        public List<SharedDeckDownload> getSharedDeckDownloads() throws RemoteException {
            return mSharedDeckDownloads;
        }
    };

    /********************************************************************
     * Listeners *
     ********************************************************************/

    // public interface ProgressListener {
    //     public void onProgressUpdate(Object... values);
    // }
    // private ProgressListener mUpdateListener = new ProgressListener() {
    //     @Override
    //     public void onProgressUpdate(Object... values) {
    //         String deckPath = (String) values[0];
    //         Long numUpdatedCards = (Long) values[1];
    //         //Save on preferences
    //         SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
    //         Editor editor = pref.edit();
    //         editor.putLong(""numUpdatedCards:"" + deckPath, numUpdatedCards); editor.commit();
    //     }
    // };


    /********************************************************************
     * Async Tasks *
     ********************************************************************/

    private class DownloadPersonalDeckTask extends AsyncTask<Download, Object, Download> {

        @Override
        protected Download doInBackground(Download... downloads) {
            Download download = downloads[0];

            URL url;
            RandomAccessFile file = null;
            InflaterInputStream iis = null;

            try {
                url = new URL(AnkiDroidProxy.SYNC_URL + ""fulldown"");
                HttpURLConnection connection = (HttpURLConnection) url.openConnection();

                connection.setDoInput(true);
                connection.setDoOutput(true);
                connection.setUseCaches(false);
                connection.setRequestMethod(""POST"");
                // FIXME: The connection always returns all bytes, regardless of what is indicated in range property, so
                // resuming downloads of personal decks is not possible at the moment
                // Fix this when the connection is fixed on AnkiOnline
                // // Log.i(AnkiDroidApp.TAG, ""Range = "" + download.getDownloaded());
                // connection.setRequestProperty(""Range"",""bytes="" + download.getDownloaded() + ""-"");
                connection.setRequestProperty(""Content-type"", ""application/x-www-form-urlencoded"");

                connection.connect();

                long startTime = System.currentTimeMillis();

                DataOutputStream ds = new DataOutputStream(connection.getOutputStream());
                String data = ""p="" + URLEncoder.encode(mPassword, ""UTF-8"") + ""&u=""
                        + URLEncoder.encode(mUsername, ""UTF-8"") + ""&d=""
                        + URLEncoder.encode(download.getTitle(), ""UTF-8"");
                ds.writeBytes(data);
                // Log.i(AnkiDroidApp.TAG, ""Closing streams..."");
                ds.flush();
                ds.close();

                // Make sure response code is in the 200 range.
                if (connection.getResponseCode() / 100 != 2) {
                    download.setStatus(Download.STATUS_ERROR);
                    publishProgress();
                } else {
                    download.setStatus(Download.STATUS_DOWNLOADING);
                    publishProgress();
                }

                // Log.i(AnkiDroidApp.TAG, ""Response code = "" + connection.getResponseCode());

                // Check for valid content length.
                // Log.i(AnkiDroidApp.TAG, ""Connection length = "" + connection.getContentLength());
                int contentLength = connection.getContentLength();
                if (contentLength < 1) {
                    // Log.i(AnkiDroidApp.TAG, ""Content Length = -1"");
                    // download.setStatus(Download.ERROR);
                }

                // Set the size for this download if it hasn't been already set
                if (download.getSize() == -1 && contentLength != -1) {
                    download.setSize(contentLength);
                    // Log.i(AnkiDroidApp.TAG, ""File size = "" + contentLength);
                }

                // Open file
                file = new RandomAccessFile(mDestination + ""/tmp/"" + download.getFilename() + "".anki.tmp"", ""rw"");
                // FIXME: Uncomment next line when the connection is fixed on AnkiOnline (= when the connection only
                // returns the bytes specified on the range property)
                // file.seek(download.getDownloaded());

                iis = new InflaterInputStream(connection.getInputStream());

                int phase = 0;
                while (download.getStatus() == Download.STATUS_DOWNLOADING) {
                    // Size buffer according to how much of the file is left to download
                    // Log.v(AnkiDroidApp.TAG, ""Downloading... "" + download.getDownloaded());
                    byte[] buffer;
                    // if (size - downloaded > MAX_BUFFER_SIZE) {
                    buffer = new byte[MAX_BUFFER_SIZE];
                    // } else {
                    // buffer = new byte[size - downloaded];
                    // }

                    // Read from server into buffer.
                    int read = iis.read(buffer);
                    if (read == -1) {
                        break;
                    }

                    // Write buffer to file.
                    file.write(buffer, 0, read);
                    download.setDownloaded(download.getDownloaded() + read);
                    // Less frequent updates
                    phase++;
                    if (phase == 249) {
                        phase = 0;
                        publishProgress();
                    }
                }

                if (download.getStatus() == Download.STATUS_DOWNLOADING) {
                    // Change status to complete if this point was reached because downloading has finished
                    download.setStatus(Download.STATUS_COMPLETE);
                    new File(mDestination + ""/tmp/"" + download.getFilename() + "".anki.tmp"").renameTo(new File(mDestination
                            + ""/"" + download.getFilename() + "".anki""));
                    long finishTime = System.currentTimeMillis();
                    // Log.i(AnkiDroidApp.TAG, ""Finished in "" + ((finishTime - startTime) / 1000) + "" seconds!"");
                    // Log.i(AnkiDroidApp.TAG, ""Downloaded = "" + download.getDownloaded());
                } else if (download.getStatus() == Download.STATUS_CANCELLED) {
                    // Cancelled download, clean up
                    new File(mDestination + ""/tmp/"" + download.getFilename() + "".anki.tmp"").delete();
                    // Log.i(AnkiDroidApp.TAG, ""Download cancelled."");
                }
                publishProgress();
                connection.disconnect();
            } catch (Exception e) {
                e.printStackTrace();
                // Log.i(AnkiDroidApp.TAG, ""Exception Error = "" + e.getMessage());
                download.setStatus(Download.STATUS_ERROR);
                publishProgress();
            } finally {
                // Log.i(AnkiDroidApp.TAG, ""finally"");
                // Close file
                if (file != null) {
                    try {
                        // Log.i(AnkiDroidApp.TAG, ""closing file"");
                        file.close();
                    } catch (Exception e) {
                        // Log.i(AnkiDroidApp.TAG, ""exception closing file"");
                    }
                }

                // Close connection to server
                if (iis != null) {
                    try {
                        // Log.i(AnkiDroidApp.TAG, ""closing iis"");
                        iis.close();
                        // Log.i(AnkiDroidApp.TAG, ""closed iis"");
                    } catch (Exception e) {
                        // Log.i(AnkiDroidApp.TAG, ""exception closing iis: "" + e.getMessage());
                    }
                }
            }

            return download;
        }


        @Override
        protected void onProgressUpdate(Object... values) {
            notifyPersonalDeckObservers();
        }


        @Override
        protected void onPostExecute(Download download) {
            // Log.i(AnkiDroidApp.TAG, ""on post execute"");
            if (download.getStatus() == Download.STATUS_COMPLETE) {
                showNotification(download.getTitle(), download.getFilename());
            } else if (download.getStatus() == Download.STATUS_ERROR) {
                // Error - Clean up
                // Log.i(AnkiDroidApp.TAG, ""deleting file"");
                new File(mDestination + ""/tmp/"" + download.getFilename() + "".anki.tmp"").delete();
                Log.e(AnkiDroidApp.TAG, ""Error while downloading personal deck."");
            }
            mPersonalDeckDownloads.remove(download);
            notifyPersonalDeckObservers();
            stopIfFinished();
        }
    }

    private class DownloadSharedDeckTask extends AsyncTask<Download, Object, SharedDeckDownload> {

        @Override
        protected SharedDeckDownload doInBackground(Download... downloads) {
            SharedDeckDownload download = (SharedDeckDownload) downloads[0];

            URL url;
            RandomAccessFile file = null;
            InputStream is = null;

            try {
                url = new URL(""http://"" + AnkiDroidProxy.SYNC_HOST + ""/file/get?id="" + download.getId());
                HttpURLConnection connection = (HttpURLConnection) url.openConnection();

                connection.setDoInput(true);
                connection.setDoOutput(true);
                connection.setUseCaches(false);
                connection.setRequestMethod(""GET"");
                // Log.i(AnkiDroidApp.TAG, ""Range = "" + download.getDownloaded());
                // FIXME: Seems that Range property is also not working well here -> TEST IT!
                // connection.setRequestProperty(""Range"",""bytes="" + download.getDownloaded() + ""-"");
                connection.setRequestProperty(""Accept-Encoding"", ""identity"");
                connection.setRequestProperty(""Host"", AnkiDroidProxy.SYNC_HOST);
                connection.setRequestProperty(""Connection"", ""close"");

                connection.connect();

                long startTime = System.currentTimeMillis();

                // Make sure response code is in the 200 range.
                if (connection.getResponseCode() / 100 != 2) {
                    download.setStatus(Download.STATUS_ERROR);
                    publishProgress();
                } else {
                    download.setStatus(Download.STATUS_DOWNLOADING);
                    publishProgress();
                }

                // Log.i(AnkiDroidApp.TAG, ""Response code = "" + connection.getResponseCode());

                // Check for valid content length.
                // Log.i(AnkiDroidApp.TAG, ""Connection length = "" + connection.getContentLength());
                int contentLength = connection.getContentLength();
                if (contentLength < 1) {
                    // Log.i(AnkiDroidApp.TAG, ""Content Length = -1"");
                    // download.setStatus(Download.ERROR);
                }

                // Set the size for this download if it hasn't been already set
                if (download.getSize() == -1 && contentLength != -1) {
                    download.setSize(contentLength);
                    // Log.i(AnkiDroidApp.TAG, ""File size = "" + contentLength);
                    // TODO: NOTIFY???
                }

                // Open file
                file = new RandomAccessFile(mDestination + ""/tmp/"" + download.getFilename() + ""."" + download.getId()
                        + "".shared.zip.tmp"", ""rw"");
                // FIXME: Uncomment next line when the connection is fixed on AnkiOnline (= when the connection only
                // returns the bytes specified on the range property)
                // file.seek(download.getDownloaded());

                is = connection.getInputStream();

                while (download.getStatus() == Download.STATUS_DOWNLOADING) {
                    // Log.i(AnkiDroidApp.TAG, ""Downloading... "" + download.getDownloaded());
                    byte[] buffer;
                    // if (size - downloaded > MAX_BUFFER_SIZE) {
                    buffer = new byte[MAX_BUFFER_SIZE];
                    // } else {
                    // buffer = new byte[size - downloaded];
                    // }

                    // Read from server into buffer.
                    int read = is.read(buffer);
                    if (read == -1) {
                        break;
                    }

                    // Write buffer to file.
                    file.write(buffer, 0, read);
                    download.setDownloaded(download.getDownloaded() + read);
                    publishProgress();
                }

                if (download.getStatus() == Download.STATUS_DOWNLOADING) {
                    // Change status to complete if this point was reached because downloading has finished
                    download.setStatus(Download.STATUS_COMPLETE);
                    new File(mDestination + ""/tmp/"" + download.getFilename() + ""."" + download.getId() + "".shared.zip.tmp"")
                            .renameTo(new File(mDestination + ""/tmp/"" + download.getFilename() + "".zip""));
                    long finishTime = System.currentTimeMillis();
                    // Log.i(AnkiDroidApp.TAG, ""Finished in "" + ((finishTime - startTime) / 1000) + "" seconds!"");
                    // Log.i(AnkiDroidApp.TAG, ""Downloaded = "" + download.getDownloaded());
                } else if (download.getStatus() == Download.STATUS_CANCELLED) {
                    // Cancelled download, clean up
                    new File(mDestination + ""/tmp/"" + download.getFilename() + ""."" + download.getId()
                            + "".shared.zip.tmp"").delete();
                    // Log.i(AnkiDroidApp.TAG, ""Download cancelled."");
                }
                publishProgress();
                connection.disconnect();
            } catch (Exception e) {
                e.printStackTrace();
                // Log.i(AnkiDroidApp.TAG, ""Exception Error = "" + e.getMessage());
                download.setStatus(Download.STATUS_ERROR);
                publishProgress();
            } finally {
                // Close file
                if (file != null) {
                    try {
                        file.close();
                    } catch (Exception e) {
                    }
                }
                // Close connection to server
                if (is != null) {
                    try {
                        is.close();
                    } catch (Exception e) {
                    }
                }
            }

            return download;
        }


        @Override
        protected void onProgressUpdate(Object... values) {
            notifySharedDeckObservers();
        }


        @Override
        protected void onPostExecute(SharedDeckDownload download) {
            // Log.i(AnkiDroidApp.TAG, ""onPostExecute"");
            if (download.getStatus() == Download.STATUS_COMPLETE) {
                download.setStatus(SharedDeckDownload.STATUS_UPDATING);
                notifySharedDeckObservers();

                // Unzip deck and media
                String unzippedDeckName = unzipSharedDeckFile(mDestination + ""/tmp/"" + download.getFilename() + "".zip"",
                        download.getFilename());
                download.setTitle(unzippedDeckName);

                // Update all cards in deck
                SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
                Editor editor = pref.edit();
                editor.putLong(""numUpdatedCards:"" + mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"", 0);
                editor.commit();

                new UpdateDeckTask().execute(new Payload(new Object[] { download }));

            } else if (download.getStatus() == Download.STATUS_CANCELLED) {
                mSharedDeckDownloads.remove(download);
                notifySharedDeckObservers();
                stopIfFinished();
            }
        }
    }

    private class UpdateDeckTask extends AsyncTask<Connection.Payload, Connection.Payload, Connection.Payload> {

        private static final int sRunningAvgLength = 5;
        private long[] mRecentBatchTimings;
        private long mElapsedTime;
        private double mTotalBatches;

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            // Pass
        }


        @Override
        protected void onProgressUpdate(Payload... values) {
            notifySharedDeckObservers();
        }


        @Override
        protected Payload doInBackground(Payload... args) {

            Payload data = doInBackgroundLoadDeck(args);
            if (data.returnType == DeckTask.DECK_LOADED) {
                HashMap<String, Object> results = (HashMap<String, Object>) data.result;
                Deck deck = (Deck) results.get(""deck"");
                if (!deck.isUnpackNeeded()) {
                    data.success = true;
                    return data;
                }
                // deck.beforeUpdateCards();
                // deck.updateAllCards();
                SharedDeckDownload download = (SharedDeckDownload) args[0].data[0];
                SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
                String updatedCardsPref = ""numUpdatedCards:"" + mDestination + ""/tmp/"" + download.getFilename()
                        + "".anki.updating"";
                long totalCards = deck.retrieveCardCount();
                download.setNumTotalCards((int) totalCards);
                long updatedCards = pref.getLong(updatedCardsPref, 0);
                download.setNumUpdatedCards((int) updatedCards);
                long batchSize = Math.max(100, totalCards / 200);
                mRecentBatchTimings = new long[sRunningAvgLength];
                mTotalBatches = ((double) totalCards) / batchSize;
                int currentBatch = (int) (updatedCards / batchSize);
                long runningAvgCount = 0;
                long batchStart;
                mElapsedTime = 0;
                while (updatedCards < totalCards && download.getStatus() == SharedDeckDownload.STATUS_UPDATING) {
                    batchStart = System.currentTimeMillis();
                    updatedCards = deck.updateAllCardsFromPosition(updatedCards, batchSize);
                    Editor editor = pref.edit();
                    editor.putLong(updatedCardsPref, updatedCards);
                    editor.commit();
                    download.setNumUpdatedCards((int) updatedCards);
                    publishProgress();
                    estimateTimeToCompletion(download, currentBatch, runningAvgCount, System.currentTimeMillis()
                            - batchStart);
                    currentBatch++;
                    runningAvgCount++;
                }
                if (download.getStatus() == SharedDeckDownload.STATUS_UPDATING) {
                    data.success = true;
                } else if (download.getStatus() == SharedDeckDownload.STATUS_PAUSED) {
                    Editor editor = pref.edit();
                    String pausedPref = ""paused:"" + mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"";
                    editor.putBoolean(pausedPref, true);
                    editor.commit();
                    data.success = false;
                    // Log.i(AnkiDroidApp.TAG, ""pausing deck "" + download.getFilename());
                } else if (download.getStatus() == SharedDeckDownload.STATUS_CANCELLED) {
                    data.success = false;
                }
                // // Log.i(AnkiDroidApp.TAG, ""Time to update deck = "" + download.getEstTimeToCompletion() + "" sec."");
                // deck.afterUpdateCards();
            } else {
                data.success = false;
            }
            return data;
        }


        private void estimateTimeToCompletion(SharedDeckDownload download, long currentBatch, long runningAvgCount,
                long lastBatchTime) {
            double avgBatchTime = 0.0;
            avgBatchTime = 0;
            mRecentBatchTimings[((int) runningAvgCount) % sRunningAvgLength] = lastBatchTime;
            mElapsedTime += lastBatchTime;
            int usedForAvg = Math.min(((int) runningAvgCount) + 1, sRunningAvgLength);
            for (int i = 0; i < usedForAvg; i++) {
                avgBatchTime += mRecentBatchTimings[i];
            }
            avgBatchTime /= usedForAvg;
            download.setEstTimeToCompletion(Math.max(0, mTotalBatches - currentBatch - 1) * avgBatchTime / 1000.0);
            // // Log.i(AnkiDroidApp.TAG, ""TotalBatches: "" + totalBatches + "" Current: "" + currentBatch + "" LastBatch: "" +
            // lastBatchTime/1000.0 + "" RunningAvg: "" + avgBatchTime/1000.0 + "" Elapsed: "" + elapsedTime/1000.0 +
            // "" TotalEstimated: "" + (elapsedTime + Math.max(0, totalBatches - currentBatch - 1) * avgBatchTime) /
            // 1000.0 + "" sec"");
        }


        private Payload doInBackgroundLoadDeck(Payload... params) {
            Payload data = params[0];
            SharedDeckDownload download = (SharedDeckDownload) data.data[0];
            String deckFilename = mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"";
            // Log.i(AnkiDroidApp.TAG, ""doInBackgroundLoadDeck - deckFilename = "" + deckFilename);

            // Log.i(AnkiDroidApp.TAG, ""loadDeck - SD card mounted and existent file -> Loading deck..."");
            try {
                // Open the right deck.
                Deck deck = Deck.openDeck(deckFilename);
                // Start by getting the first card and displaying it.
                Card card = deck.getCard();
                // Log.i(AnkiDroidApp.TAG, ""Deck loaded!"");

                // Set the result
                data.returnType = DeckTask.DECK_LOADED;
                HashMap<String, Object> results = new HashMap<String, Object>();
                results.put(""deck"", deck);
                results.put(""card"", card);
                results.put(""position"", download.getNumUpdatedCards());
                data.result = results;
                return data;
            } catch (SQLException e) {
                // Log.i(AnkiDroidApp.TAG, ""The database "" + deckFilename + "" could not be opened = "" + e.getMessage());
                data.success = false;
                data.returnType = DeckTask.DECK_NOT_LOADED;
                data.exception = e;
                return data;
            } catch (CursorIndexOutOfBoundsException e) {
                // XXX: Where is this exception thrown?
                // Log.i(AnkiDroidApp.TAG, ""The deck has no cards = "" + e.getMessage());
                data.success = false;
                data.returnType = DeckTask.DECK_EMPTY;
                data.exception = e;
                return data;
            }
        }


        @Override
        protected void onPostExecute(Payload result) {
            super.onPostExecute(result);
            HashMap<String, Object> results = (HashMap<String, Object>) result.result;
            Deck deck = (Deck) results.get(""deck"");
            // Close the previously opened deck.
            if (deck != null) {
                deck.closeDeck();
            }
            SharedDeckDownload download = (SharedDeckDownload) result.data[0];
            SharedPreferences pref = PrefSettings.getSharedPrefs(getBaseContext());
            Editor editor = pref.edit();

            // Log.i(AnkiDroidApp.TAG, ""Finished deck "" + download.getFilename() + "" "" + result.success);
            if (result.success) {
                // Put updated cards to 0
                // TODO: Why do we need to zero the updated cards?
                editor.putLong(""numUpdatedCards:"" + mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"", 0);
                editor.commit();
                // Move deck and media to the default deck path
                new File(mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"").renameTo(new File(
                        mDestination + ""/"" + download.getFilename() + "".anki""));
                new File(mDestination + ""/tmp/"" + download.getFilename() + "".media/"").renameTo(new File(mDestination + ""/""
                        + download.getFilename() + "".media/""));
                mSharedDeckDownloads.remove(download);
                showNotification(download.getTitle(), download.getFilename());
            } else {
                // If paused do nothing, if cancelled clean up
                if (download.getStatus() == Download.STATUS_CANCELLED) {
                    try {
                        new File(mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"").delete();
                        File mediaFolder = new File(mDestination + ""/tmp/"" + download.getFilename() + "".media/"");
                        if (mediaFolder != null && mediaFolder.listFiles() != null) {
                            for (File f : mediaFolder.listFiles()) {
                                f.delete();
                            }
                            mediaFolder.delete();
                        }
                    } catch (SecurityException e) {
                        Log.e(AnkiDroidApp.TAG, ""SecurityException = "" + e.getMessage());
                        e.printStackTrace();
                    }
                    editor.remove(""numUpdatedCards:"" + mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"");
                    editor.remove(""paused:"" + mDestination + ""/tmp/"" + download.getFilename() + "".anki.updating"");
                    editor.commit();
                    mSharedDeckDownloads.remove(download);
                }
            }
            notifySharedDeckObservers();
            stopIfFinished();
        }
    }

    // To test when the service is alive
    /*
     * class RunTask implements Runnable { public void run() { // Log.i(AnkiDroidApp.TAG, ""Service running...""); ++counter;
     * if(serviceHandler != null) { serviceHandler.postDelayed( this, 1000L ); } } }
     */
}
",True,56,68,1,2,4,34
55,com.ichi2.anki.services.NotificationService.java,"/***************************************************************************************
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.anki.services;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.StudyOptions;
import com.ichi2.anki.WidgetStatus;
import com.tomgibara.android.veecheck.util.PrefSettings;

import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.os.IBinder;

import android.util.Log;

public class NotificationService extends Service {

    /** The notification service to show notifications of due cards. */
    private NotificationManager mNotificationManager;

    /** The id of the notification for due cards. */
    private static final int WIDGET_NOTIFY_ID = 1;

    @Override
    public void onCreate() {
        super.onCreate();
        mNotificationManager =
            (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
    }


    @Override
    public void onStart(Intent intent, int startId) {
        // Log.i(AnkiDroidApp.TAG, ""NotificationService: OnStart"");

        Context context = AnkiDroidApp.getInstance().getBaseContext();
        SharedPreferences preferences = PrefSettings.getSharedPrefs(context);
        int minimumCardsDueForNotification = Integer.parseInt(preferences.getString(""minimumCardsDueForNotification"", ""25""));
        int dueCardsCount = WidgetStatus.fetchDue(context);
        if (dueCardsCount >= minimumCardsDueForNotification) {
            // Show a notification
            int icon = R.drawable.anki;
            CharSequence tickerText = String.format(
                    getString(R.string.widget_minimum_cards_due_notification_ticker_text),
                    dueCardsCount);
            long when = System.currentTimeMillis();

            Notification notification = new Notification(icon, tickerText, when);

            if (preferences.getBoolean(""widgetVibrate"", false)) {
                notification.defaults |= Notification.DEFAULT_VIBRATE;
            }
            if (preferences.getBoolean(""widgetBlink"", false)) {
                notification.defaults |= Notification.DEFAULT_LIGHTS;
            }

            Context appContext = getApplicationContext();
            CharSequence contentTitle = getText(R.string.widget_minimum_cards_due_notification_ticker_title);

            Intent ankiDroidIntent = new Intent(context, StudyOptions.class);
            ankiDroidIntent.setAction(Intent.ACTION_MAIN);
            ankiDroidIntent.addCategory(Intent.CATEGORY_LAUNCHER);
            PendingIntent pendingAnkiDroidIntent = PendingIntent.getActivity(context, 0, ankiDroidIntent, PendingIntent.FLAG_UPDATE_CURRENT);
            notification.setLatestEventInfo(appContext, contentTitle, tickerText, pendingAnkiDroidIntent);

            mNotificationManager.notify(WIDGET_NOTIFY_ID, notification);
        } else {
            // Cancel the existing notification, if any.
            mNotificationManager.cancel(WIDGET_NOTIFY_ID);
        }
    }


	@Override
	public IBinder onBind(Intent arg0) {
		return null;
	}
}",False,73,63,0,0,5,27
56,com.ichi2.utils.HttpUtility.java,"package com.ichi2.utils;

import java.io.IOException;
import java.util.List;

import org.apache.http.HttpResponse;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.DefaultHttpClient;

import android.util.Log;

import com.ichi2.anki.AnkiDroidApp;

public class HttpUtility {
	public static Boolean postReport(String url, List<NameValuePair> values) {
    	HttpClient httpClient = new DefaultHttpClient();  
        HttpPost httpPost = new HttpPost(url);  
      
        try {  
        	httpPost.setEntity(new UrlEncodedFormEntity(values));  
            HttpResponse response = httpClient.execute(httpPost);  
            
            switch(response.getStatusLine().getStatusCode()) {
	            case 200:
	            	Log.e(AnkiDroidApp.TAG, String.format(""feedback report posted to %s"", url));
	            	return true;
	            	
            	default:
            		Log.e(AnkiDroidApp.TAG, String.format(""feedback report posted to %s message"", url));
            		Log.e(AnkiDroidApp.TAG, String.format(""%d: %s"", response.getStatusLine().getStatusCode(), response.getStatusLine().getReasonPhrase()));
	            	break;
            }
        } catch (ClientProtocolException ex) {  
        	Log.e(AnkiDroidApp.TAG, ex.toString());
        } catch (IOException ex) {  
        	Log.e(AnkiDroidApp.TAG, ex.toString());  
        }
        
        return false;
	}
}
",False,24,64,0,0,5,28
57,com.ichi2.utils.Base64.java,"/**
 * <p>Encodes and decodes to and from Base64 notation.</p>
 * <p>Homepage: <a href=""http://iharder.net/base64"">http://iharder.net/base64</a>.</p>
 * 
 * <p>Example:</p>
 * 
 * <code>String encoded = Base64.encode( myByteArray );</code>
 * <br />
 * <code>byte[] myByteArray = Base64.decode( encoded );</code>
 *
 * <p>The <tt>options</tt> parameter, which appears in a few places, is used to pass 
 * several pieces of information to the encoder. In the ""higher level"" methods such as 
 * encodeBytes( bytes, options ) the options parameter can be used to indicate such 
 * things as first gzipping the bytes before encoding them, not inserting linefeeds,
 * and encoding using the URL-safe and Ordered dialects.</p>
 *
 * <p>Note, according to <a href=""http://www.faqs.org/rfcs/rfc3548.html"">RFC3548</a>,
 * Section 2.1, implementations should not add line feeds unless explicitly told
 * to do so. I've got Base64 set to this behavior now, although earlier versions
 * broke lines by default.</p>
 *
 * <p>The constants defined in Base64 can be OR-ed together to combine options, so you 
 * might make a call like this:</p>
 *
 * <code>String encoded = Base64.encodeBytes( mybytes, Base64.GZIP | Base64.DO_BREAK_LINES );</code>
 * <p>to compress the data before encoding it and then making the output have newline characters.</p>
 * <p>Also...</p>
 * <code>String encoded = Base64.encodeBytes( crazyString.getBytes() );</code>
 *
 * <p>
 * I am placing this code in the Public Domain. Do with it as you will.
 * This software comes with no guarantees or warranties but with
 * plenty of well-wishing instead!
 * Please visit <a href=""http://iharder.net/base64"">http://iharder.net/base64</a>
 * periodically to check for updates or to contribute improvements.
 * </p>
 *
 * @author Robert Harder
 * @author rob@iharder.net
 * @version 2.3.3
 */

package com.ichi2.utils;

public class Base64 extends Object {

    /* ******** P U B L I C F I E L D S ******** */

    /** No options specified. Value is zero. */
    public final static int NO_OPTIONS = 0;

    /** Specify encoding in first bit. Value is one. */
    public final static int ENCODE = 1;

    /** Specify decoding in first bit. Value is zero. */
    public final static int DECODE = 0;

    /** Specify that data should be gzip-compressed in second bit. Value is two. */
    public final static int GZIP = 2;

    /**
     * Specify that gzipped data should <em>not</em> be automatically gunzipped.
     */
    public final static int DONT_GUNZIP = 4;

    /** Do break lines when encoding. Value is 8. */
    public final static int DO_BREAK_LINES = 8;

    /**
     * Encode using Base64-like encoding that is URL- and Filename-safe as described in Section 4 of RFC3548: <a
     * href=""http://www.faqs.org/rfcs/rfc3548.html"" >http://www.faqs.org/rfcs/rfc3548.html</a>. It is important to note
     * that data encoded this way is <em>not</em> officially valid Base64, or at the very least should not be called
     * Base64 without also specifying that is was encoded using the URL- and Filename-safe dialect.
     */
    public final static int URL_SAFE = 16;

    /**
     * Encode using the special ""ordered"" dialect of Base64 described here: <a
     * href=""http://www.faqs.org/qa/rfcc-1940.html"">http://www.faqs.org/qa/rfcc- 1940.html</a>.
     */
    public final static int ORDERED = 32;

    /* ******** P R I V A T E F I E L D S ******** */

    /** Maximum line length (76) of Base64 output. */
    private final static int MAX_LINE_LENGTH = 76;

    /** The equals sign (=) as a byte. */
    private final static byte EQUALS_SIGN = (byte) '=';

    /** The new line character (\n) as a byte. */
    private final static byte NEW_LINE = (byte) '\n';

    /** Preferred encoding. */
    private final static String PREFERRED_ENCODING = ""US-ASCII"";

    private final static byte WHITE_SPACE_ENC = -5; // Indicates white space in
                                                    // encoding

    private final static byte EQUALS_SIGN_ENC = -1; // Indicates equals sign in
                                                    // encoding

    /* ******** S T A N D A R D B A S E 6 4 A L P H A B E T ******** */

    /** The 64 valid Base64 values. */
    /*
     * Host platform me be something funny like EBCDIC, so we hardcode these values.
     */
    private final static byte[] _STANDARD_ALPHABET = { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E',
            (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N',
            (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W',
            (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f',
            (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
            (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x',
            (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6',
            (byte) '7', (byte) '8', (byte) '9', (byte) '+', (byte) '/' };

    /**
     * Translates a Base64 value to either its 6-bit reconstruction value or a negative number indicating some other
     * meaning.
     **/
    private final static byte[] _STANDARD_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
                                                                // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            62, // Plus sign at decimal 43
            -9, -9, -9, // Decimal 44 - 46
            63, // Slash at decimal 47
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through
                                                          // 'N'
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
                                                            // through 'Z'
            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
                                                                // through 'm'
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
                                                                // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };

    /* ******** U R L S A F E B A S E 6 4 A L P H A B E T ******** */

    /**
     * Used in the URL- and Filename-safe dialect described in Section 4 of RFC3548: <a
     * href=""http://www.faqs.org/rfcs/rfc3548.html"">http://www.faqs.org /rfcs/rfc3548.html</a>. Notice that the last two
     * bytes become ""hyphen"" and ""underscore"" instead of ""plus"" and ""slash.""
     */
    private final static byte[] _URL_SAFE_ALPHABET = { (byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E',
            (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L', (byte) 'M', (byte) 'N',
            (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U', (byte) 'V', (byte) 'W',
            (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e', (byte) 'f',
            (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
            (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x',
            (byte) 'y', (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3', (byte) '4', (byte) '5', (byte) '6',
            (byte) '7', (byte) '8', (byte) '9', (byte) '-', (byte) '_' };

    /**
     * Used in decoding URL- and Filename-safe dialects of Base64.
     */
    private final static byte[] _URL_SAFE_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
                                                                // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            -9, // Plus sign at decimal 43
            -9, // Decimal 44
            62, // Minus sign at decimal 45
            -9, // Decimal 46
            -9, // Slash at decimal 47
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through
                                                          // 'N'
            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O'
                                                            // through 'Z'
            -9, -9, -9, -9, // Decimal 91 - 94
            63, // Underscore at decimal 95
            -9, // Decimal 96
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a'
                                                                // through 'm'
            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n'
                                                                // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };

    /* ******** O R D E R E D B A S E 6 4 A L P H A B E T ******** */

    /**
     * I don't get the point of this technique, but someone requested it, and it is described here: <a
     * href=""http://www.faqs.org/qa/rfcc-1940.html"">http:// www.faqs.org/qa/rfcc-1940.html</a>.
     */
    private final static byte[] _ORDERED_ALPHABET = { (byte) '-', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
            (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8', (byte) '9', (byte) 'A', (byte) 'B', (byte) 'C',
            (byte) 'D', (byte) 'E', (byte) 'F', (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K', (byte) 'L',
            (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P', (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
            (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z', (byte) '_', (byte) 'a', (byte) 'b', (byte) 'c',
            (byte) 'd', (byte) 'e', (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j', (byte) 'k', (byte) 'l',
            (byte) 'm', (byte) 'n', (byte) 'o', (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't', (byte) 'u',
            (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y', (byte) 'z' };

    /**
     * Used in decoding the ""ordered"" dialect of Base64.
     */
    private final static byte[] _ORDERED_DECODABET = { -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 0 - 8
            -5, -5, // Whitespace: Tab and Linefeed
            -9, -9, // Decimal 11 - 12
            -5, // Whitespace: Carriage Return
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 -
                                                                // 26
            -9, -9, -9, -9, -9, // Decimal 27 - 31
            -5, // Whitespace: Space
            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
            -9, // Plus sign at decimal 43
            -9, // Decimal 44
            0, // Minus sign at decimal 45
            -9, // Decimal 46
            -9, // Slash at decimal 47
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, // Numbers zero through nine
            -9, -9, -9, // Decimal 58 - 60
            -1, // Equals sign at decimal 61
            -9, -9, -9, // Decimal 62 - 64
            11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, // Letters 'A'
                                                                // through 'M'
            24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, // Letters 'N'
                                                                // through 'Z'
            -9, -9, -9, -9, // Decimal 91 - 94
            37, // Underscore at decimal 95
            -9, // Decimal 96
            38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, // Letters 'a'
                                                                // through 'm'
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, // Letters 'n'
                                                                // through 'z'
            -9, -9, -9, -9 // Decimal 123 - 126
    /*
     * ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 127 - 139 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 140 - 152 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 153 - 165 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 166 - 178 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 179 - 191
     * -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 192 - 204 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal
     * 205 - 217 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, // Decimal 218 - 230 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9, //
     * Decimal 231 - 243 -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9 // Decimal 244 - 255
     */
    };


    /* ******** D E T E R M I N E W H I C H A L H A B E T ******** */

    /**
     * Returns one of the _SOMETHING_ALPHABET byte arrays depending on the options specified. It's possible, though
     * silly, to specify ORDERED <b>and</b> URLSAFE in which case one of them will be picked, though there is no
     * guarantee as to which one will be picked.
     */
    private final static byte[] getAlphabet(int options) {
        if ((options & URL_SAFE) == URL_SAFE) {
            return _URL_SAFE_ALPHABET;
        } else if ((options & ORDERED) == ORDERED) {
            return _ORDERED_ALPHABET;
        } else {
            return _STANDARD_ALPHABET;
        }
    } // end getAlphabet


    /**
     * Returns one of the _SOMETHING_DECODABET byte arrays depending on the options specified. It's possible, though
     * silly, to specify ORDERED and URL_SAFE in which case one of them will be picked, though there is no guarantee as
     * to which one will be picked.
     */
    private final static byte[] getDecodabet(int options) {
        if ((options & URL_SAFE) == URL_SAFE) {
            return _URL_SAFE_DECODABET;
        } else if ((options & ORDERED) == ORDERED) {
            return _ORDERED_DECODABET;
        } else {
            return _STANDARD_DECODABET;
        }
    } // end getAlphabet


    /** Defeats instantiation. */
    private Base64() {
    }


    /* ******** E N C O D I N G M E T H O D S ******** */

    /**
     * Encodes up to the first three bytes of array <var>threeBytes</var> and returns a four-byte array in Base64
     * notation. The actual number of significant bytes in your array is given by <var>numSigBytes</var>. The array
     * <var>threeBytes</var> needs only be as big as <var>numSigBytes</var>. Code can reuse a byte array by passing a
     * four-byte array as <var>b4</var>.
     * 
     * @param b4 A reusable byte array to reduce array instantiation
     * @param threeBytes the array to convert
     * @param numSigBytes the number of significant bytes in your array
     * @return four byte array in Base64 notation.
     * @since 1.5.1
     */
    private static byte[] encode3to4(byte[] b4, byte[] threeBytes, int numSigBytes, int options) {
        encode3to4(threeBytes, 0, numSigBytes, b4, 0, options);
        return b4;
    } // end encode3to4


    /**
     * <p>
     * Encodes up to three bytes of the array <var>source</var> and writes the resulting four Base64 bytes to
     * <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by
     * specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays
     * are large enough to accomodate <var>srcOffset</var> + 3 for the <var>source</var> array or <var>destOffset</var>
     * + 4 for the <var>destination</var> array. The actual number of significant bytes in your array is given by
     * <var>numSigBytes</var>.
     * </p>
     * <p>
     * This is the lowest level of the encoding methods with all possible parameters.
     * </p>
     * 
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param numSigBytes the number of significant bytes in your array
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @return the <var>destination</var> array
     * @since 1.3
     */
    private static byte[] encode3to4(byte[] source, int srcOffset, int numSigBytes, byte[] destination, int destOffset,
            int options) {

        byte[] ALPHABET = getAlphabet(options);

        // 1 2 3
        // 01234567890123456789012345678901 Bit position
        // --------000000001111111122222222 Array position from threeBytes
        // --------| || || || | Six bit groups to index ALPHABET
        // >>18 >>12 >> 6 >> 0 Right shift necessary
        // 0x3f 0x3f 0x3f Additional AND

        // Create buffer with zero-padding if there are only one or two
        // significant bytes passed in the array.
        // We have to shift left 24 in order to flush out the 1's that appear
        // when Java treats a value as negative that is cast from a byte to an
        // int.
        int inBuff = (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
                | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
                | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);

        switch (numSigBytes) {
            case 3:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = ALPHABET[(inBuff) & 0x3f];
                return destination;

            case 2:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = ALPHABET[(inBuff >>> 6) & 0x3f];
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;

            case 1:
                destination[destOffset] = ALPHABET[(inBuff >>> 18)];
                destination[destOffset + 1] = ALPHABET[(inBuff >>> 12) & 0x3f];
                destination[destOffset + 2] = EQUALS_SIGN;
                destination[destOffset + 3] = EQUALS_SIGN;
                return destination;

            default:
                return destination;
        } // end switch
    } // end encode3to4


    /**
     * Performs Base64 encoding on the <code>raw</code> ByteBuffer, writing it to the <code>encoded</code> ByteBuffer.
     * This is an experimental feature. Currently it does not pass along any options (such as {@link #DO_BREAK_LINES} or
     * {@link #GZIP}.
     * 
     * @param raw input buffer
     * @param encoded output buffer
     * @since 2.3
     */
    public static void encode(java.nio.ByteBuffer raw, java.nio.ByteBuffer encoded) {
        byte[] raw3 = new byte[3];
        byte[] enc4 = new byte[4];

        while (raw.hasRemaining()) {
            int rem = Math.min(3, raw.remaining());
            raw.get(raw3, 0, rem);
            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS);
            encoded.put(enc4);
        } // end input remaining
    }


    /**
     * Performs Base64 encoding on the <code>raw</code> ByteBuffer, writing it to the <code>encoded</code> CharBuffer.
     * This is an experimental feature. Currently it does not pass along any options (such as {@link #DO_BREAK_LINES} or
     * {@link #GZIP}.
     * 
     * @param raw input buffer
     * @param encoded output buffer
     * @since 2.3
     */
    public static void encode(java.nio.ByteBuffer raw, java.nio.CharBuffer encoded) {
        byte[] raw3 = new byte[3];
        byte[] enc4 = new byte[4];

        while (raw.hasRemaining()) {
            int rem = Math.min(3, raw.remaining());
            raw.get(raw3, 0, rem);
            Base64.encode3to4(enc4, raw3, rem, Base64.NO_OPTIONS);
            for (int i = 0; i < 4; i++) {
                encoded.put((char) (enc4[i] & 0xFF));
            }
        } // end input remaining
    }


    /**
     * Serializes an object and returns the Base64-encoded version of that serialized object.
     * <p>
     * As of v 2.3, if the object cannot be serialized or there is another error, the method will throw an
     * java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned a null value, but in
     * retrospect that's a pretty poor way to handle it.
     * </p>
     * The object is not GZip-compressed before being encoded.
     * 
     * @param serializableObject The object to encode
     * @return The Base64-encoded object
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if serializedObject is null
     * @since 1.4
     */
    public static String encodeObject(java.io.Serializable serializableObject) throws java.io.IOException {
        return encodeObject(serializableObject, NO_OPTIONS);
    } // end encodeObject


    /**
     * Serializes an object and returns the Base64-encoded version of that serialized object.
     * <p>
     * As of v 2.3, if the object cannot be serialized or there is another error, the method will throw an
     * java.io.IOException. <b>This is new to v2.3!</b> In earlier versions, it just returned a null value, but in
     * retrospect that's a pretty poor way to handle it.
     * </p>
     * The object is not GZip-compressed before being encoded.
     * <p>
     * Example options:
     * 
     * <pre>
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     * </pre>
     * <p>
     * Example: <code>encodeObject( myObj, Base64.GZIP )</code> or
     * <p>
     * Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DO_BREAK_LINES )</code>
     * 
     * @param serializableObject The object to encode
     * @param options Specified options
     * @return The Base64-encoded object
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @since 2.0
     */
    public static String encodeObject(java.io.Serializable serializableObject, int options) throws java.io.IOException {

        if (serializableObject == null) {
            throw new NullPointerException(""Cannot serialize a null object."");
        } // end if: null

        // Streams
        java.io.ByteArrayOutputStream baos = null;
        java.io.OutputStream b64os = null;
        java.util.zip.GZIPOutputStream gzos = null;
        java.io.ObjectOutputStream oos = null;

        try {
            // ObjectOutputStream -> (GZIP) -> Base64 -> ByteArrayOutputStream
            baos = new java.io.ByteArrayOutputStream();
            b64os = new Base64.OutputStream(baos, ENCODE | options);
            if ((options & GZIP) != 0) {
                // Gzip
                gzos = new java.util.zip.GZIPOutputStream(b64os);
                oos = new java.io.ObjectOutputStream(gzos);
            } else {
                // Not gzipped
                oos = new java.io.ObjectOutputStream(b64os);
            }
            oos.writeObject(serializableObject);
        } // end try
        catch (java.io.IOException e) {
            // Catch it and then throw it immediately so that
            // the finally{} block is called for cleanup.
            throw e;
        } // end catch
        finally {
            try {
                oos.close();
            } catch (Exception e) {
            }
            try {
                gzos.close();
            } catch (Exception e) {
            }
            try {
                b64os.close();
            } catch (Exception e) {
            }
            try {
                baos.close();
            } catch (Exception e) {
            }
        } // end finally

        // Return value according to relevant encoding.
        try {
            return new String(baos.toByteArray(), PREFERRED_ENCODING);
        } // end try
        catch (java.io.UnsupportedEncodingException uue) {
            // Fall back to some Java default
            return new String(baos.toByteArray());
        } // end catch

    } // end encode


    /**
     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
     * 
     * @param source The data to convert
     * @return The data in Base64-encoded form
     * @throws NullPointerException if source array is null
     * @since 1.4
     */
    public static String encodeBytes(byte[] source) {
        // Since we're not going to have the GZIP encoding turned on,
        // we're not going to have an java.io.IOException thrown, so
        // we should not force the user to have to catch it.
        String encoded = null;
        try {
            encoded = encodeBytes(source, 0, source.length, NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : ex.getMessage();
        } // end catch
        assert encoded != null;
        return encoded;
    } // end encodeBytes


    /**
     * Encodes a byte array into Base64 notation.
     * <p>
     * Example options:
     * 
     * <pre>
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * </pre>
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>
     * <p>
     * As of v 2.3, if there is an error with the GZIP stream, the method will throw an java.io.IOException. <b>This is
     * new to v2.3!</b> In earlier versions, it just returned a null value, but in retrospect that's a pretty poor way
     * to handle it.
     * </p>
     * 
     * @param source The data to convert
     * @param options Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if source array is null
     * @since 2.0
     */
    public static String encodeBytes(byte[] source, int options) throws java.io.IOException {
        return encodeBytes(source, 0, source.length, options);
    } // end encodeBytes


    /**
     * Encodes a byte array into Base64 notation. Does not GZip-compress data.
     * <p>
     * As of v 2.3, if there is an error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned a null value, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @return The Base64-encoded data as a String
     * @throws NullPointerException if source array is null
     * @throws IllegalArgumentException if source array, offset, or length are invalid
     * @since 1.4
     */
    public static String encodeBytes(byte[] source, int off, int len) {
        // Since we're not going to have the GZIP encoding turned on,
        // we're not going to have an java.io.IOException thrown, so
        // we should not force the user to have to catch it.
        String encoded = null;
        try {
            encoded = encodeBytes(source, off, len, NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : ex.getMessage();
        } // end catch
        assert encoded != null;
        return encoded;
    } // end encodeBytes


    /**
     * Encodes a byte array into Base64 notation.
     * <p>
     * Example options:
     * 
     * <pre>
     *   GZIP: gzip-compresses object before encoding it.
     *   DO_BREAK_LINES: break lines at 76 characters
     *     &lt;i&gt;Note: Technically, this makes your encoding non-compliant.&lt;/i&gt;
     * </pre>
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
     * <p>
     * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DO_BREAK_LINES )</code>
     * <p>
     * As of v 2.3, if there is an error with the GZIP stream, the method will throw an java.io.IOException. <b>This is
     * new to v2.3!</b> In earlier versions, it just returned a null value, but in retrospect that's a pretty poor way
     * to handle it.
     * </p>
     * 
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @param options Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if source array is null
     * @throws IllegalArgumentException if source array, offset, or length are invalid
     * @since 2.0
     */
    public static String encodeBytes(byte[] source, int off, int len, int options) throws java.io.IOException {
        byte[] encoded = encodeBytesToBytes(source, off, len, options);

        // Return value according to relevant encoding.
        try {
            return new String(encoded, PREFERRED_ENCODING);
        } // end try
        catch (java.io.UnsupportedEncodingException uue) {
            return new String(encoded);
        } // end catch

    } // end encodeBytes


    /**
     * Similar to {@link #encodeBytes(byte[])} but returns a byte array instead of instantiating a String. This is more
     * efficient if you're working with I/O streams and have large data sets to encode.
     * 
     * @param source The data to convert
     * @return The Base64-encoded data as a byte[] (of ASCII characters)
     * @throws NullPointerException if source array is null
     * @since 2.3.1
     */
    public static byte[] encodeBytesToBytes(byte[] source) {
        byte[] encoded = null;
        try {
            encoded = encodeBytesToBytes(source, 0, source.length, Base64.NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : ""IOExceptions only come from GZipping, which is turned off: "" + ex.getMessage();
        }
        return encoded;
    }


    /**
     * Similar to {@link #encodeBytes(byte[], int, int, int)} but returns a byte array instead of instantiating a
     * String. This is more efficient if you're working with I/O streams and have large data sets to encode.
     * 
     * @param source The data to convert
     * @param off Offset in array where conversion should begin
     * @param len Length of data to convert
     * @param options Specified options
     * @return The Base64-encoded data as a String
     * @see Base64#GZIP
     * @see Base64#DO_BREAK_LINES
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if source array is null
     * @throws IllegalArgumentException if source array, offset, or length are invalid
     * @since 2.3.1
     */
    public static byte[] encodeBytesToBytes(byte[] source, int off, int len, int options) throws java.io.IOException {

        if (source == null) {
            throw new NullPointerException(""Cannot serialize a null array."");
        } // end if: null

        if (off < 0) {
            throw new IllegalArgumentException(""Cannot have negative offset: "" + off);
        } // end if: off < 0

        if (len < 0) {
            throw new IllegalArgumentException(""Cannot have length offset: "" + len);
        } // end if: len < 0

        if (off + len > source.length) {
            throw new IllegalArgumentException(String.format(
                    ""Cannot have offset of %d and length of %d with array of length %d"", off, len, source.length));
        } // end if: off < 0

        // Compress?
        if ((options & GZIP) != 0) {
            java.io.ByteArrayOutputStream baos = null;
            java.util.zip.GZIPOutputStream gzos = null;
            Base64.OutputStream b64os = null;

            try {
                // GZip -> Base64 -> ByteArray
                baos = new java.io.ByteArrayOutputStream();
                b64os = new Base64.OutputStream(baos, ENCODE | options);
                gzos = new java.util.zip.GZIPOutputStream(b64os);

                gzos.write(source, off, len);
                gzos.close();
            } // end try
            catch (java.io.IOException e) {
                // Catch it and then throw it immediately so that
                // the finally{} block is called for cleanup.
                throw e;
            } // end catch
            finally {
                try {
                    gzos.close();
                } catch (Exception e) {
                }
                try {
                    b64os.close();
                } catch (Exception e) {
                }
                try {
                    baos.close();
                } catch (Exception e) {
                }
            } // end finally

            return baos.toByteArray();
        } // end if: compress

        // Else, don't compress. Better not to use streams at all then.
        else {
            boolean breakLines = (options & DO_BREAK_LINES) > 0;

            // int len43 = len * 4 / 3;
            // byte[] outBuff = new byte[ ( len43 ) // Main 4:3
            // + ( (len % 3) > 0 ? 4 : 0 ) // Account for padding
            // + (breakLines ? ( len43 / MAX_LINE_LENGTH ) : 0) ]; // New lines
            // Try to determine more precisely how big the array needs to be.
            // If we get it right, we don't have to do an array copy, and
            // we save a bunch of memory.
            int encLen = (len / 3) * 4 + (len % 3 > 0 ? 4 : 0); // Bytes needed
                                                                // for actual
                                                                // encoding
            if (breakLines) {
                encLen += encLen / MAX_LINE_LENGTH; // Plus extra newline
                                                    // characters
            }
            byte[] outBuff = new byte[encLen];

            int d = 0;
            int e = 0;
            int len2 = len - 2;
            int lineLength = 0;
            for (; d < len2; d += 3, e += 4) {
                encode3to4(source, d + off, 3, outBuff, e, options);

                lineLength += 4;
                if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                    outBuff[e + 4] = NEW_LINE;
                    e++;
                    lineLength = 0;
                } // end if: end of line
            } // en dfor: each piece of array

            if (d < len) {
                encode3to4(source, d + off, len - d, outBuff, e, options);
                e += 4;
            } // end if: some padding needed

            // Only resize array if we didn't guess it right.
            if (e < outBuff.length - 1) {
                byte[] finalOut = new byte[e];
                System.arraycopy(outBuff, 0, finalOut, 0, e);
                // System.err.println(""Having to resize array from "" +
                // outBuff.length + "" to "" + e );
                return finalOut;
            } else {
                // System.err.println(""No need to resize array."");
                return outBuff;
            }

        } // end else: don't compress

    } // end encodeBytesToBytes


    /* ******** D E C O D I N G M E T H O D S ******** */

    /**
     * Decodes four bytes from array <var>source</var> and writes the resulting bytes (up to three of them) to
     * <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by
     * specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays
     * are large enough to accomodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var>
     * + 3 for the <var>destination</var> array. This method returns the actual number of bytes that were converted from
     * the Base64 encoding.
     * <p>
     * This is the lowest level of the decoding methods with all possible parameters.
     * </p>
     * 
     * @param source the array to convert
     * @param srcOffset the index where conversion begins
     * @param destination the array to hold the conversion
     * @param destOffset the index where output will be put
     * @param options alphabet type is pulled from this (standard, url-safe, ordered)
     * @return the number of decoded bytes converted
     * @throws NullPointerException if source or destination arrays are null
     * @throws IllegalArgumentException if srcOffset or destOffset are invalid or there is not enough room in the array.
     * @since 1.3
     */
    private static int decode4to3(byte[] source, int srcOffset, byte[] destination, int destOffset, int options) {

        // Lots of error checking and exception throwing
        if (source == null) {
            throw new NullPointerException(""Source array was null."");
        } // end if
        if (destination == null) {
            throw new NullPointerException(""Destination array was null."");
        } // end if
        if (srcOffset < 0 || srcOffset + 3 >= source.length) {
            throw new IllegalArgumentException(String.format(
                    ""Source array with length %d cannot have offset of %d and still process four bytes."",
                    source.length, srcOffset));
        } // end if
        if (destOffset < 0 || destOffset + 2 >= destination.length) {
            throw new IllegalArgumentException(String.format(
                    ""Destination array with length %d cannot have offset of %d and still store three bytes."",
                    destination.length, destOffset));
        } // end if

        byte[] DECODABET = getDecodabet(options);

        // Example: Dk==
        if (source[srcOffset + 2] == EQUALS_SIGN) {
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1] ] << 24 ) >>> 12 );
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12);

            destination[destOffset] = (byte) (outBuff >>> 16);
            return 1;
        }

        // Example: DkL=
        else if (source[srcOffset + 3] == EQUALS_SIGN) {
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 );
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12)
                    | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6);

            destination[destOffset] = (byte) (outBuff >>> 16);
            destination[destOffset + 1] = (byte) (outBuff >>> 8);
            return 2;
        }

        // Example: DkLE
        else {
            // Two ways to do the same thing. Don't know which way I like best.
            // int outBuff = ( ( DECODABET[ source[ srcOffset ] ] << 24 ) >>> 6
            // )
            // | ( ( DECODABET[ source[ srcOffset + 1 ] ] << 24 ) >>> 12 )
            // | ( ( DECODABET[ source[ srcOffset + 2 ] ] << 24 ) >>> 18 )
            // | ( ( DECODABET[ source[ srcOffset + 3 ] ] << 24 ) >>> 24 );
            int outBuff = ((DECODABET[source[srcOffset]] & 0xFF) << 18)
                    | ((DECODABET[source[srcOffset + 1]] & 0xFF) << 12)
                    | ((DECODABET[source[srcOffset + 2]] & 0xFF) << 6) | ((DECODABET[source[srcOffset + 3]] & 0xFF));

            destination[destOffset] = (byte) (outBuff >> 16);
            destination[destOffset + 1] = (byte) (outBuff >> 8);
            destination[destOffset + 2] = (byte) (outBuff);

            return 3;
        }
    } // end decodeToBytes


    /**
     * Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores GUNZIP option, if it's
     * set.</strong> This is not generally a recommended method, although it is used internally as part of the decoding
     * process. Special case: if len = 0, an empty array is returned. Still, if you need more speed and reduced memory
     * footprint (and aren't gzipping), consider this method.
     * 
     * @param source The Base64 encoded data
     * @return decoded data
     * @since 2.3.1
     */
    public static byte[] decode(byte[] source) {
        byte[] decoded = null;
        try {
            decoded = decode(source, 0, source.length, Base64.NO_OPTIONS);
        } catch (java.io.IOException ex) {
            assert false : ""IOExceptions only come from GZipping, which is turned off: "" + ex.getMessage();
        }
        return decoded;
    }


    /**
     * Low-level access to decoding ASCII characters in the form of a byte array. <strong>Ignores GUNZIP option, if it's
     * set.</strong> This is not generally a recommended method, although it is used internally as part of the decoding
     * process. Special case: if len = 0, an empty array is returned. Still, if you need more speed and reduced memory
     * footprint (and aren't gzipping), consider this method.
     * 
     * @param source The Base64 encoded data
     * @param off The offset of where to begin decoding
     * @param len The length of characters to decode
     * @param options Can specify options such as alphabet type to use
     * @return decoded data
     * @throws java.io.IOException If bogus characters exist in source data
     * @since 1.3
     */
    public static byte[] decode(byte[] source, int off, int len, int options) throws java.io.IOException {

        // Lots of error checking and exception throwing
        if (source == null) {
            throw new NullPointerException(""Cannot decode null source array."");
        } // end if
        if (off < 0 || off + len > source.length) {
            throw new IllegalArgumentException(String.format(
                    ""Source array with length %d cannot have offset of %d and process %d bytes."", source.length, off,
                    len));
        } // end if

        if (len == 0) {
            return new byte[0];
        } else if (len < 4) {
            throw new IllegalArgumentException(
                    ""Base64-encoded string must have at least four characters, but length specified was "" + len);
        } // end if

        byte[] DECODABET = getDecodabet(options);

        int len34 = len * 3 / 4; // Estimate on array size
        byte[] outBuff = new byte[len34]; // Upper limit on size of output
        int outBuffPosn = 0; // Keep track of where we're writing

        byte[] b4 = new byte[4]; // Four byte buffer from source, eliminating
                                 // white space
        int b4Posn = 0; // Keep track of four byte input buffer
        int i = 0; // Source array counter
        byte sbiCrop = 0; // Low seven bits (ASCII) of input
        byte sbiDecode = 0; // Special value from DECODABET

        for (i = off; i < off + len; i++) { // Loop through source

            sbiCrop = (byte) (source[i] & 0x7f); // Only the low seven bits
            sbiDecode = DECODABET[sbiCrop]; // Special value

            // White space, Equals sign, or legit Base64 character
            // Note the values such as -5 and -9 in the
            // DECODABETs at the top of the file.
            if (sbiDecode >= WHITE_SPACE_ENC) {
                if (sbiDecode >= EQUALS_SIGN_ENC) {
                    b4[b4Posn++] = sbiCrop; // Save non-whitespace
                    if (b4Posn > 3) { // Time to decode?
                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, options);
                        b4Posn = 0;

                        // If that was the equals sign, break out of 'for' loop
                        if (sbiCrop == EQUALS_SIGN) {
                            break;
                        } // end if: equals sign
                    } // end if: quartet built
                } // end if: equals sign or better
            } // end if: white space, equals sign or better
            else {
                // There's a bad input character in the Base64 stream.
                throw new java.io.IOException(String.format(""Bad Base64 input character '%c' in array position %d"",
                        source[i], i));
            } // end else:
        } // each input character

        byte[] out = new byte[outBuffPosn];
        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
        return out;
    } // end decode


    /**
     * Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it.
     * 
     * @param s the string to decode
     * @return the decoded data
     * @throws java.io.IOException If there is a problem
     * @since 1.4
     */
    public static byte[] decode(String s) throws java.io.IOException {
        return decode(s, NO_OPTIONS);
    }


    /**
     * Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it.
     * 
     * @param s the string to decode
     * @param options encode options such as URL_SAFE
     * @return the decoded data
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if <tt>s</tt> is null
     * @since 1.4
     */
    public static byte[] decode(String s, int options) throws java.io.IOException {

        if (s == null) {
            throw new NullPointerException(""Input string was null."");
        } // end if

        byte[] bytes;
        try {
            bytes = s.getBytes(PREFERRED_ENCODING);
        } // end try
        catch (java.io.UnsupportedEncodingException uee) {
            bytes = s.getBytes();
        } // end catch
          // </change>

        // Decode
        bytes = decode(bytes, 0, bytes.length, options);

        // Check to see if it's gzip-compressed
        // GZIP Magic Two-Byte Number: 0x8b1f (35615)
        boolean dontGunzip = (options & DONT_GUNZIP) != 0;
        if ((bytes != null) && (bytes.length >= 4) && (!dontGunzip)) {

            int head = (bytes[0] & 0xff) | ((bytes[1] << 8) & 0xff00);
            if (java.util.zip.GZIPInputStream.GZIP_MAGIC == head) {
                java.io.ByteArrayInputStream bais = null;
                java.util.zip.GZIPInputStream gzis = null;
                java.io.ByteArrayOutputStream baos = null;
                byte[] buffer = new byte[2048];
                int length = 0;

                try {
                    baos = new java.io.ByteArrayOutputStream();
                    bais = new java.io.ByteArrayInputStream(bytes);
                    gzis = new java.util.zip.GZIPInputStream(bais);

                    while ((length = gzis.read(buffer)) >= 0) {
                        baos.write(buffer, 0, length);
                    } // end while: reading input

                    // No error? Get new bytes.
                    bytes = baos.toByteArray();

                } // end try
                catch (java.io.IOException e) {
                    e.printStackTrace();
                    // Just return originally-decoded bytes
                } // end catch
                finally {
                    try {
                        baos.close();
                    } catch (Exception e) {
                    }
                    try {
                        gzis.close();
                    } catch (Exception e) {
                    }
                    try {
                        bais.close();
                    } catch (Exception e) {
                    }
                } // end finally

            } // end if: gzipped
        } // end if: bytes.length >= 2

        return bytes;
    } // end decode


    /**
     * Attempts to decode Base64 data and deserialize a Java Object within. Returns <tt>null</tt> if there was an error.
     * 
     * @param encodedObject The Base64 data to decode
     * @return The decoded and deserialized object
     * @throws NullPointerException if encodedObject is null
     * @throws java.io.IOException if there is a general error
     * @throws ClassNotFoundException if the decoded object is of a class that cannot be found by the JVM
     * @since 1.5
     */
    public static Object decodeToObject(String encodedObject) throws java.io.IOException,
            java.lang.ClassNotFoundException {
        return decodeToObject(encodedObject, NO_OPTIONS, null);
    }


    /**
     * Attempts to decode Base64 data and deserialize a Java Object within. Returns <tt>null</tt> if there was an error.
     * If <tt>loader</tt> is not null, it will be the class loader used when deserializing.
     * 
     * @param encodedObject The Base64 data to decode
     * @param options Various parameters related to decoding
     * @param loader Optional class loader to use in deserializing classes.
     * @return The decoded and deserialized object
     * @throws NullPointerException if encodedObject is null
     * @throws java.io.IOException if there is a general error
     * @throws ClassNotFoundException if the decoded object is of a class that cannot be found by the JVM
     * @since 2.3.4
     */
    public static Object decodeToObject(String encodedObject, int options, final ClassLoader loader)
            throws java.io.IOException, java.lang.ClassNotFoundException {

        // Decode and gunzip if necessary
        byte[] objBytes = decode(encodedObject, options);

        java.io.ByteArrayInputStream bais = null;
        java.io.ObjectInputStream ois = null;
        Object obj = null;

        try {
            bais = new java.io.ByteArrayInputStream(objBytes);

            // If no custom class loader is provided, use Java's builtin OIS.
            if (loader == null) {
                ois = new java.io.ObjectInputStream(bais);
            } // end if: no loader provided

            // Else make a customized object input stream that uses
            // the provided class loader.
            else {
                ois = new java.io.ObjectInputStream(bais) {
                    @Override
                    public Class<?> resolveClass(java.io.ObjectStreamClass streamClass) throws java.io.IOException,
                            ClassNotFoundException {
                        Class<?> c = Class.forName(streamClass.getName(), false, loader);
                        if (c == null) {
                            return super.resolveClass(streamClass);
                        } else {
                            return c; // Class loader knows of this class.
                        } // end else: not null
                    } // end resolveClass
                }; // end ois
            } // end else: no custom class loader

            obj = ois.readObject();
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and throw in order to execute finally{}
        } // end catch
        catch (java.lang.ClassNotFoundException e) {
            throw e; // Catch and throw in order to execute finally{}
        } // end catch
        finally {
            try {
                bais.close();
            } catch (Exception e) {
            }
            try {
                ois.close();
            } catch (Exception e) {
            }
        } // end finally

        return obj;
    } // end decodeObject


    /**
     * Convenience method for encoding data to a file.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param dataToEncode byte array of data to encode in base64 form
     * @param filename Filename for saving encoded data
     * @throws java.io.IOException if there is an error
     * @throws NullPointerException if dataToEncode is null
     * @since 2.1
     */
    public static void encodeToFile(byte[] dataToEncode, String filename) throws java.io.IOException {

        if (dataToEncode == null) {
            throw new NullPointerException(""Data to encode was null."");
        } // end iff

        Base64.OutputStream bos = null;
        try {
            bos = new Base64.OutputStream(new java.io.FileOutputStream(filename), Base64.ENCODE);
            bos.write(dataToEncode);
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and throw to execute finally{} block
        } // end catch: java.io.IOException
        finally {
            try {
                bos.close();
            } catch (Exception e) {
            }
        } // end finally

    } // end encodeToFile


    /**
     * Convenience method for decoding data to a file.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param dataToDecode Base64-encoded data as a string
     * @param filename Filename for saving decoded data
     * @throws java.io.IOException if there is an error
     * @since 2.1
     */
    public static void decodeToFile(String dataToDecode, String filename) throws java.io.IOException {

        Base64.OutputStream bos = null;
        try {
            bos = new Base64.OutputStream(new java.io.FileOutputStream(filename), Base64.DECODE);
            bos.write(dataToDecode.getBytes(PREFERRED_ENCODING));
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and throw to execute finally{} block
        } // end catch: java.io.IOException
        finally {
            try {
                bos.close();
            } catch (Exception e) {
            }
        } // end finally

    } // end decodeToFile


    /**
     * Convenience method for reading a base64-encoded file and decoding it.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param filename Filename for reading encoded data
     * @return decoded byte array
     * @throws java.io.IOException if there is an error
     * @since 2.1
     */
    public static byte[] decodeFromFile(String filename) throws java.io.IOException {

        byte[] decodedData = null;
        Base64.InputStream bis = null;
        try {
            // Set up some useful variables
            java.io.File file = new java.io.File(filename);
            byte[] buffer = null;
            int length = 0;
            int numBytes = 0;

            // Check for size of file
            if (file.length() > Integer.MAX_VALUE) {
                throw new java.io.IOException(""File is too big for this convenience method ("" + file.length()
                        + "" bytes)."");
            } // end if: file too big for int index
            buffer = new byte[(int) file.length()];

            // Open a stream
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)),
                    Base64.DECODE);

            // Read until done
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {
                length += numBytes;
            } // end while

            // Save in a variable to return
            decodedData = new byte[length];
            System.arraycopy(buffer, 0, decodedData, 0, length);

        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch: java.io.IOException
        finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        } // end finally

        return decodedData;
    } // end decodeFromFile


    /**
     * Convenience method for reading a binary file and base64-encoding it.
     * <p>
     * As of v 2.3, if there is a error, the method will throw an java.io.IOException. <b>This is new to v2.3!</b> In
     * earlier versions, it just returned false, but in retrospect that's a pretty poor way to handle it.
     * </p>
     * 
     * @param filename Filename for reading binary data
     * @return base64-encoded string
     * @throws java.io.IOException if there is an error
     * @since 2.1
     */
    public static String encodeFromFile(String filename) throws java.io.IOException {

        String encodedData = null;
        Base64.InputStream bis = null;
        try {
            // Set up some useful variables
            java.io.File file = new java.io.File(filename);
            byte[] buffer = new byte[Math.max((int) (file.length() * 1.4), 40)]; // Need
                                                                                 // max()
                                                                                 // for
                                                                                 // math
                                                                                 // on
                                                                                 // small
                                                                                 // files
                                                                                 // (v2.2.1)
            int length = 0;
            int numBytes = 0;

            // Open a stream
            bis = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(file)),
                    Base64.ENCODE);

            // Read until done
            while ((numBytes = bis.read(buffer, length, 4096)) >= 0) {
                length += numBytes;
            } // end while

            // Save in a variable to return
            encodedData = new String(buffer, 0, length, Base64.PREFERRED_ENCODING);

        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch: java.io.IOException
        finally {
            try {
                bis.close();
            } catch (Exception e) {
            }
        } // end finally

        return encodedData;
    } // end encodeFromFile


    /**
     * Reads <tt>infile</tt> and encodes it to <tt>outfile</tt>.
     * 
     * @param infile Input file
     * @param outfile Output file
     * @throws java.io.IOException if there is an error
     * @since 2.2
     */
    public static void encodeFileToFile(String infile, String outfile) throws java.io.IOException {

        String encoded = Base64.encodeFromFile(infile);
        java.io.OutputStream out = null;
        try {
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            out.write(encoded.getBytes(""US-ASCII"")); // Strict, 7-bit output.
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch
        finally {
            try {
                out.close();
            } catch (Exception ex) {
            }
        } // end finally
    } // end encodeFileToFile


    /**
     * Reads <tt>infile</tt> and decodes it to <tt>outfile</tt>.
     * 
     * @param infile Input file
     * @param outfile Output file
     * @throws java.io.IOException if there is an error
     * @since 2.2
     */
    public static void decodeFileToFile(String infile, String outfile) throws java.io.IOException {

        byte[] decoded = Base64.decodeFromFile(infile);
        java.io.OutputStream out = null;
        try {
            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));
            out.write(decoded);
        } // end try
        catch (java.io.IOException e) {
            throw e; // Catch and release to execute finally{}
        } // end catch
        finally {
            try {
                out.close();
            } catch (Exception ex) {
            }
        } // end finally
    } // end decodeFileToFile

    /* ******** I N N E R C L A S S I N P U T S T R E A M ******** */

    /**
     * A {@link Base64.InputStream} will read data from another <tt>java.io.InputStream</tt>, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     * 
     * @see Base64
     * @since 1.3
     */
    public static class InputStream extends java.io.FilterInputStream {

        private boolean encode; // Encoding or decoding

        private int position; // Current position in the buffer

        private byte[] buffer; // Small buffer holding converted data

        private int bufferLength; // Length of buffer (3 or 4)

        private int numSigBytes; // Number of meaningful bytes in the buffer

        private int lineLength;

        private boolean breakLines; // Break lines at less than 80 characters

        private int options; // Record options used to create the stream.

        private byte[] decodabet; // Local copies to avoid extra method calls


        /**
         * Constructs a {@link Base64.InputStream} in DECODE mode.
         * 
         * @param in the <tt>java.io.InputStream</tt> from which to read data.
         * @since 1.3
         */
        public InputStream(java.io.InputStream in) {
            this(in, DECODE);
        } // end constructor


        /**
         * Constructs a {@link Base64.InputStream} in either ENCODE or DECODE mode.
         * <p>
         * Valid options:
         * 
         * <pre>
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DO_BREAK_LINES: break lines at 76 characters
         *     (only meaningful when encoding)&lt;/i&gt;
         * </pre>
         * <p>
         * Example: <code>new Base64.InputStream( in, Base64.DECODE )</code>
         * 
         * @param in the <tt>java.io.InputStream</tt> from which to read data.
         * @param options Specified options
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DO_BREAK_LINES
         * @since 2.0
         */
        public InputStream(java.io.InputStream in, int options) {

            super(in);
            this.options = options; // Record for later
            breakLines = (options & DO_BREAK_LINES) > 0;
            encode = (options & ENCODE) > 0;
            bufferLength = encode ? 4 : 3;
            buffer = new byte[bufferLength];
            position = -1;
            lineLength = 0;
            decodabet = getDecodabet(options);
        } // end constructor


        /**
         * Reads enough of the input stream to convert to/from Base64 and returns the next byte.
         * 
         * @return next byte
         * @since 1.3
         */
        @Override
        public int read() throws java.io.IOException {

            // Do we need to get data?
            if (position < 0) {
                if (encode) {
                    byte[] b3 = new byte[3];
                    int numBinaryBytes = 0;
                    for (int i = 0; i < 3; i++) {
                        int b = in.read();

                        // If end of stream, b is -1.
                        if (b >= 0) {
                            b3[i] = (byte) b;
                            numBinaryBytes++;
                        } else {
                            break; // out of for loop
                        } // end else: end of stream

                    } // end for: each needed input byte

                    if (numBinaryBytes > 0) {
                        encode3to4(b3, 0, numBinaryBytes, buffer, 0, options);
                        position = 0;
                        numSigBytes = 4;
                    } // end if: got data
                    else {
                        return -1; // Must be end of stream
                    } // end else
                } // end if: encoding

                // Else decoding
                else {
                    byte[] b4 = new byte[4];
                    int i = 0;
                    for (i = 0; i < 4; i++) {
                        // Read four ""meaningful"" bytes:
                        int b = 0;
                        do {
                            b = in.read();
                        } while (b >= 0 && decodabet[b & 0x7f] <= WHITE_SPACE_ENC);

                        if (b < 0) {
                            break; // Reads a -1 if end of stream
                        } // end if: end of stream

                        b4[i] = (byte) b;
                    } // end for: each needed input byte

                    if (i == 4) {
                        numSigBytes = decode4to3(b4, 0, buffer, 0, options);
                        position = 0;
                    } // end if: got four characters
                    else if (i == 0) {
                        return -1;
                    } // end else if: also padded correctly
                    else {
                        // Must have broken out from above.
                        throw new java.io.IOException(""Improperly padded Base64 input."");
                    } // end

                } // end else: decode
            } // end else: get data

            // Got data?
            if (position >= 0) {
                // End of relevant data?
                if ( /* !encode && */position >= numSigBytes) {
                    return -1;
                } // end if: got data

                if (encode && breakLines && lineLength >= MAX_LINE_LENGTH) {
                    lineLength = 0;
                    return '\n';
                } // end if
                else {
                    lineLength++; // This isn't important when decoding
                    // but throwing an extra ""if"" seems
                    // just as wasteful.

                    int b = buffer[position++];

                    if (position >= bufferLength) {
                        position = -1;
                    } // end if: end

                    return b & 0xFF; // This is how you ""cast"" a byte that's
                    // intended to be unsigned.
                } // end else
            } // end if: position >= 0

            // Else error
            else {
                throw new java.io.IOException(""Error in Base64 code reading stream."");
            } // end else
        } // end read


        /**
         * Calls {@link #read()} repeatedly until the end of stream is reached or <var>len</var> bytes are read. Returns
         * number of bytes read into array or -1 if end of stream is encountered.
         * 
         * @param dest array to hold values
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @return bytes read into array or -1 if end of stream is encountered.
         * @since 1.3
         */
        @Override
        public int read(byte[] dest, int off, int len) throws java.io.IOException {
            int i;
            int b;
            for (i = 0; i < len; i++) {
                b = read();

                if (b >= 0) {
                    dest[off + i] = (byte) b;
                } else if (i == 0) {
                    return -1;
                } else {
                    break; // Out of 'for' loop
                } // Out of 'for' loop
            } // end for: each byte read
            return i;
        } // end read

    } // end inner class InputStream

    /* ******** I N N E R C L A S S O U T P U T S T R E A M ******** */

    /**
     * A {@link Base64.OutputStream} will write data to another <tt>java.io.OutputStream</tt>, given in the constructor,
     * and encode/decode to/from Base64 notation on the fly.
     * 
     * @see Base64
     * @since 1.3
     */
    public static class OutputStream extends java.io.FilterOutputStream {

        private boolean encode;

        private int position;

        private byte[] buffer;

        private int bufferLength;

        private int lineLength;

        private boolean breakLines;

        private byte[] b4; // Scratch used in a few places

        private boolean suspendEncoding;

        private int options; // Record for later

        private byte[] decodabet; // Local copies to avoid extra method calls


        /**
         * Constructs a {@link Base64.OutputStream} in ENCODE mode.
         * 
         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
         * @since 1.3
         */
        public OutputStream(java.io.OutputStream out) {
            this(out, ENCODE);
        } // end constructor


        /**
         * Constructs a {@link Base64.OutputStream} in either ENCODE or DECODE mode.
         * <p>
         * Valid options:
         * 
         * <pre>
         *   ENCODE or DECODE: Encode or Decode as data is read.
         *   DO_BREAK_LINES: don't break lines at 76 characters
         *     (only meaningful when encoding)&lt;/i&gt;
         * </pre>
         * <p>
         * Example: <code>new Base64.OutputStream( out, Base64.ENCODE )</code>
         * 
         * @param out the <tt>java.io.OutputStream</tt> to which data will be written.
         * @param options Specified options.
         * @see Base64#ENCODE
         * @see Base64#DECODE
         * @see Base64#DO_BREAK_LINES
         * @since 1.3
         */
        public OutputStream(java.io.OutputStream out, int options) {
            super(out);
            breakLines = (options & DO_BREAK_LINES) != 0;
            encode = (options & ENCODE) != 0;
            bufferLength = encode ? 3 : 4;
            buffer = new byte[bufferLength];
            position = 0;
            lineLength = 0;
            suspendEncoding = false;
            b4 = new byte[4];
            this.options = options;
            decodabet = getDecodabet(options);
        } // end constructor


        /**
         * Writes the byte to the output stream after converting to/from Base64 notation. When encoding, bytes are
         * buffered three at a time before the output stream actually gets a write() call. When decoding, bytes are
         * buffered four at a time.
         * 
         * @param theByte the byte to write
         * @since 1.3
         */
        @Override
        public void write(int theByte) throws java.io.IOException {
            // Encoding suspended?
            if (suspendEncoding) {
                out.write(theByte);
                return;
            } // end if: supsended

            // Encode?
            if (encode) {
                buffer[position++] = (byte) theByte;
                if (position >= bufferLength) { // Enough to encode.

                    out.write(encode3to4(b4, buffer, bufferLength, options));

                    lineLength += 4;
                    if (breakLines && lineLength >= MAX_LINE_LENGTH) {
                        out.write(NEW_LINE);
                        lineLength = 0;
                    } // end if: end of line

                    position = 0;
                } // end if: enough to output
            } // end if: encoding

            // Else, Decoding
            else {
                // Meaningful Base64 character?
                if (decodabet[theByte & 0x7f] > WHITE_SPACE_ENC) {
                    buffer[position++] = (byte) theByte;
                    if (position >= bufferLength) { // Enough to output.

                        int len = Base64.decode4to3(buffer, 0, b4, 0, options);
                        out.write(b4, 0, len);
                        position = 0;
                    } // end if: enough to output
                } // end if: meaningful base64 character
                else if (decodabet[theByte & 0x7f] != WHITE_SPACE_ENC) {
                    throw new java.io.IOException(""Invalid character in Base64 data."");
                } // end else: not white space either
            } // end else: decoding
        } // end write


        /**
         * Calls {@link #write(int)} repeatedly until <var>len</var> bytes are written.
         * 
         * @param theBytes array from which to read bytes
         * @param off offset for array
         * @param len max number of bytes to read into array
         * @since 1.3
         */
        @Override
        public void write(byte[] theBytes, int off, int len) throws java.io.IOException {
            // Encoding suspended?
            if (suspendEncoding) {
                out.write(theBytes, off, len);
                return;
            } // end if: supsended

            for (int i = 0; i < len; i++) {
                write(theBytes[off + i]);
            } // end for: each byte written

        } // end write


        /**
         * Method added by PHIL. [Thanks, PHIL. -Rob] This pads the buffer without closing the stream.
         * 
         * @throws java.io.IOException if there's an error.
         */
        public void flushBase64() throws java.io.IOException {
            if (position > 0) {
                if (encode) {
                    out.write(encode3to4(b4, buffer, position, options));
                    position = 0;
                } // end if: encoding
                else {
                    throw new java.io.IOException(""Base64 input not properly padded."");
                } // end else: decoding
            } // end if: buffer partially full

        } // end flush


        /**
         * Flushes and closes (I think, in the superclass) the stream.
         * 
         * @since 1.3
         */
        @Override
        public void close() throws java.io.IOException {
            // 1. Ensure that pending characters are written
            flushBase64();

            // 2. Actually close the stream
            // Base class both flushes and closes.
            super.close();

            buffer = null;
            out = null;
        } // end close


        /**
         * Suspends encoding of the stream. May be helpful if you need to embed a piece of base64-encoded data in a
         * stream.
         * 
         * @throws java.io.IOException if there's an error flushing
         * @since 1.5.1
         */
        public void suspendEncoding() throws java.io.IOException {
            flushBase64();
            suspendEncoding = true;
        } // end suspendEncoding


        /**
         * Resumes encoding of the stream. May be helpful if you need to embed a piece of base64-encoded data in a
         * stream.
         * 
         * @since 1.5.1
         */
        public void resumeEncoding() {
            suspendEncoding = false;
        } // end resumeEncoding

    } // end inner class OutputStream

} // end class Base64
",True,89,56,5,32,0,0
58,com.ichi2.utils.RubyParser.java,"/****************************************************************************************
 * Copyright (c) 2009 Brennan D'Aguilar <brennan.daguilar@gmail.com>                    *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.utils;

/**
 * Parses text input from Anki cards to display ruby text correctly in AnkiDroid. Anki's Japanese language support
 * handles ruby text as: <code>basetext[rubytext]</code> where the base text begins after the first spacer proceeding
 * the ruby text, or the beginning of the string of text if no spacers exist before the start of the base text. This is
 * converted to basic ruby markup: <code><ruby><rb>baseText</rb><rt>rubyText</rt></ruby></code> While webkit on android
 * devices does not support ruby markup yet, the text can be adjusted adequately using css.
 */
public class RubyParser {

//    private static final char RUBY_SPACER_JAP_SPACE = ' ';
//    private static final char RUBY_SPACER_JAP_COMMA = '\u3001';
//    private static final char RUBY_TEXT_START = '[';
//    private static final char RUBY_TEXT_END = ']';
//    private static final char HTML_TAG_START = '<';
//    private static final char HTML_TAG_END = '>';


    /**
     * Converts ruby text from the format used by Anki's Japanese support plugin to html ruby markup.
     * 
     * @param sourceText the japanese text containing ruby text
     * @return html ruby markup equivalent of the input text.
     */
    public static String ankiRubyToMarkup(String sourceText) {
        return sourceText.replaceAll("" ?([^ >]+?)\\[([^(sound:)].*?)\\]"", ""<ruby><rb>$1</rb><rt>$2</rt></ruby>"");
        /*int cursorIndex = 0;

        int nextRubyTextStart; // The first '[' after the cursorIndex
        int nextSpacer; // The first spacer (' ', or '、') after the cursorIndex
        int nextRubyTextEnd; // The first ']' after the cursorIndex
        int nextHtmlTagStart; // The first '<' after the cursorIndex

        StringBuilder builder = new StringBuilder();

        // Loop until the entire string is parsed
        while (cursorIndex < sourceText.length() - 1) {
            // Find the location of the beginning of the next ruby text
            nextRubyTextStart = sourceText.indexOf(RUBY_TEXT_START, cursorIndex);

            // Find the location of the next spacing character (only -1 if neither possible
            // spacing character remains.
            nextSpacer = sourceText.indexOf(RUBY_SPACER_JAP_SPACE, cursorIndex);
            if (nextSpacer == -1) {
                nextSpacer = Math.max(nextSpacer, sourceText.indexOf(RUBY_SPACER_JAP_COMMA, cursorIndex));
            }

            // Check for html tags that come before any ruby text. If found, pass the full tag
            // without parsing.
            nextHtmlTagStart = sourceText.indexOf(HTML_TAG_START, cursorIndex);

            if (nextHtmlTagStart != -1 && (nextSpacer == -1 || nextHtmlTagStart < nextSpacer)
                    && (nextRubyTextStart == -1 || nextHtmlTagStart < nextRubyTextStart)) {
                int nextHtmlTagEnd = sourceText.indexOf(HTML_TAG_END, nextHtmlTagStart);
                builder.append(sourceText.substring(cursorIndex, nextHtmlTagEnd + 1));
                cursorIndex = nextHtmlTagEnd + 1;
            } else // If no html tag is passed through on this cycle, check for ruby text.
            {
                // If any unparsed ruby text remains
                if (nextRubyTextStart != -1) {
                    // If there is any text before the next ruby tag that is part of the ruby base text,
                    // pass it through unparsed.
                    if (nextSpacer < nextRubyTextStart && nextSpacer != -1) {
                        // Remove spaces from the text
                        if (sourceText.charAt(nextSpacer) == RUBY_SPACER_JAP_SPACE) {
                            builder.append(sourceText.substring(cursorIndex, nextSpacer));
                        } else // If spacing character is not a space (eg. a comma), pass it through as well.
                        {
                            builder.append(sourceText.substring(cursorIndex, nextSpacer + 1));
                        }
                        cursorIndex = nextSpacer + 1;
                    } else {
                        // Find the end of the ruby text, and parse it into html tags.
                        nextRubyTextEnd = sourceText.indexOf(RUBY_TEXT_END, cursorIndex);
                        builder.append(newRubyPair(sourceText.substring(cursorIndex, nextRubyTextStart),
                                sourceText.substring(nextRubyTextStart + 1, nextRubyTextEnd)));
                        cursorIndex = nextRubyTextEnd + 1;
                    }
                } else {
                    // If no ruby text remains to be parsed, pass any remaining text through and finish.
                    builder.append(sourceText.substring(cursorIndex));
                    cursorIndex = sourceText.length();
                }
            }
        }

        return builder.toString();*/

    }

    /**
     * Strips kanji from ruby markup. Used for reading in question
     * 
     * @param sourceText the japanese text containing ruby text
     * @return text with kanji substituted by it's reading
     */
    public static String ankiStripKanji(String sourceText) {
    	return sourceText.replaceAll("" ?([^ >]+?)\\[([^(sound:)].*?)\\]"", ""$2"");
    }
    
    /*
    private static String newRubyPair(String baseText, String rubyText) {
        return ""<ruby><rb>"" + baseText + ""</rb><rt>"" + rubyText + ""</rt></ruby>"";
    }
    */
}
",False,42,56,5,27,0,0
59,com.ichi2.utils.DiffEngine.java,"/*
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ichi2.utils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Pattern;

/**
 * Functions for diff, match and patch. Computes the difference between two texts to create a patch. Applies the patch
 * onto another text, allowing for errors.
 * 
 * @author fraser@google.com (Neil Fraser) Class containing the diff, match and patch methods. Also contains the
 *         behaviour settings. TODO if possible, remove the merging code, unneeded.
 */
public class DiffEngine {

    // Defaults.
    // Set these on your diff_match_patch instance to override the defaults.

    /**
     * Number of seconds to map a diff before giving up (0 for infinity).
     */
    public float Diff_Timeout = 1.0f;
    /**
     * Cost of an empty edit operation in terms of edit characters.
     */
    public short Diff_EditCost = 4;
    /**
     * The size beyond which the double-ended diff activates. Double-ending is twice as fast, but less accurate.
     */
    public short Diff_DualThreshold = 32;

    /**
     * Colors for right and wrong answer
     */
    private static final String RIGHT_COLOR = ""#c0ffc0"";
    private static final String WRONG_COLOR = ""#ffc0c0"";

    /**
     * Internal class for returning results from diff_linesToChars(). Other less paranoid languages just use a
     * three-element array.
     */
    protected static class LinesToCharsResult {
        protected String chars1;
        protected String chars2;
        protected List<String> lineArray;


        protected LinesToCharsResult(String chars1, String chars2, List<String> lineArray) {
            this.chars1 = chars1;
            this.chars2 = chars2;
            this.lineArray = lineArray;
        }
    }

    // DIFF FUNCTIONS

    /**
     * The data structure representing a diff is a Linked list of Diff objects: {Diff(Operation.DELETE, ""Hello""),
     * Diff(Operation.INSERT, ""Goodbye""), Diff(Operation.EQUAL, "" world."")} which means: delete ""Hello"", add ""Goodbye""
     * and keep "" world.""
     */
    public enum Operation {
        DELETE, INSERT, EQUAL
    }


    /**
     * Find the differences between two texts. Run a faster slightly less optimal diff This method allows the
     * 'checklines' of diff_main() to be optional. Most of the time checklines is wanted, so default to true.
     * 
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @return Linked List of Diff objects.
     */
    public LinkedList<DiffAction> diff_main(String text1, String text2) {
        return diff_main(text1, text2, true);
    }


    /**
     * Find the differences between two texts. Simplifies the problem by stripping any common prefix or suffix off the
     * texts before diffing.
     * 
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param checklines Speedup flag. If false, then don't run a line-level diff first to identify the changed areas.
     *            If true, then run a faster slightly less optimal diff
     * @return Linked List of Diff objects.
     */
    public LinkedList<DiffAction> diff_main(String text1, String text2, boolean checklines) {
        // Check for equality (speedup)
        LinkedList<DiffAction> diffs;
        if (text1.equals(text2)) {
            diffs = new LinkedList<DiffAction>();
            diffs.add(new DiffAction(Operation.EQUAL, text1));
            return diffs;
        }

        // Trim off common prefix (speedup)
        int commonlength = diff_commonPrefix(text1, text2);
        String commonprefix = text1.substring(0, commonlength);
        text1 = text1.substring(commonlength);
        text2 = text2.substring(commonlength);

        // Trim off common suffix (speedup)
        commonlength = diff_commonSuffix(text1, text2);
        String commonsuffix = text1.substring(text1.length() - commonlength);
        text1 = text1.substring(0, text1.length() - commonlength);
        text2 = text2.substring(0, text2.length() - commonlength);

        // Compute the diff on the middle block
        diffs = diff_compute(text1, text2, checklines);

        // Restore the prefix and suffix
        if (commonprefix.length() > 0) {
            diffs.addFirst(new DiffAction(Operation.EQUAL, commonprefix));
        }
        if (commonsuffix.length() > 0) {
            diffs.addLast(new DiffAction(Operation.EQUAL, commonsuffix));
        }

        diff_cleanupMerge(diffs);
        return diffs;
    }


    /**
     * Find the differences between two texts. Assumes that the texts do not have any common prefix or suffix.
     * 
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @param checklines Speedup flag. If false, then don't run a line-level diff first to identify the changed areas.
     *            If true, then run a faster slightly less optimal diff
     * @return Linked List of Diff objects.
     */
    protected LinkedList<DiffAction> diff_compute(String text1, String text2, boolean checklines) {
        LinkedList<DiffAction> diffs = new LinkedList<DiffAction>();

        if (text1.length() == 0) {
            // Just add some text (speedup)
            diffs.add(new DiffAction(Operation.INSERT, text2));
            return diffs;
        }

        if (text2.length() == 0) {
            // Just delete some text (speedup)
            diffs.add(new DiffAction(Operation.DELETE, text1));
            return diffs;
        }

        String longtext = text1.length() > text2.length() ? text1 : text2;
        String shorttext = text1.length() > text2.length() ? text2 : text1;
        int i = longtext.indexOf(shorttext);
        if (i != -1) {
            // Shorter text is inside the longer text (speedup)
            Operation op = (text1.length() > text2.length()) ? Operation.DELETE : Operation.INSERT;
            diffs.add(new DiffAction(op, longtext.substring(0, i)));
            diffs.add(new DiffAction(Operation.EQUAL, shorttext));
            diffs.add(new DiffAction(op, longtext.substring(i + shorttext.length())));
            return diffs;
        }
        longtext = shorttext = null; // Garbage collect

        // Check to see if the problem can be split in two.
        String[] hm = diff_halfMatch(text1, text2);
        if (hm != null) {
            // A half-match was found, sort out the return data.
            String text1_a = hm[0];
            String text1_b = hm[1];
            String text2_a = hm[2];
            String text2_b = hm[3];
            String mid_common = hm[4];
            // Send both pairs off for separate processing.
            LinkedList<DiffAction> diffs_a = diff_main(text1_a, text2_a, checklines);
            LinkedList<DiffAction> diffs_b = diff_main(text1_b, text2_b, checklines);
            // Merge the results.
            diffs = diffs_a;
            diffs.add(new DiffAction(Operation.EQUAL, mid_common));
            diffs.addAll(diffs_b);
            return diffs;
        }

        // Perform a real diff.
        if (checklines && (text1.length() < 100 || text2.length() < 100)) {
            checklines = false; // Too trivial for the overhead.
        }
        List<String> linearray = null;
        if (checklines) {
            // Scan the text on a line-by-line basis first.
            LinesToCharsResult b = diff_linesToChars(text1, text2);
            text1 = b.chars1;
            text2 = b.chars2;
            linearray = b.lineArray;
        }

        diffs = diff_map(text1, text2);
        if (diffs == null) {
            // No acceptable result.
            diffs = new LinkedList<DiffAction>();
            diffs.add(new DiffAction(Operation.DELETE, text1));
            diffs.add(new DiffAction(Operation.INSERT, text2));
        }

        if (checklines) {
            // Convert the diff back to original text.
            diff_charsToLines(diffs, linearray);
            // Eliminate freak matches (e.g. blank lines)
            diff_cleanupSemantic(diffs);

            // Rediff any replacement blocks, this time character-by-character.
            // Add a dummy entry at the end.
            diffs.add(new DiffAction(Operation.EQUAL, """"));
            int count_delete = 0;
            int count_insert = 0;
            String text_delete = """";
            String text_insert = """";
            ListIterator<DiffAction> pointer = diffs.listIterator();
            DiffAction thisDiff = pointer.next();
            while (thisDiff != null) {
                switch (thisDiff.operation) {
                    case INSERT:
                        count_insert++;
                        text_insert += thisDiff.text;
                        break;
                    case DELETE:
                        count_delete++;
                        text_delete += thisDiff.text;
                        break;
                    case EQUAL:
                        // Upon reaching an equality, check for prior redundancies.
                        if (count_delete >= 1 && count_insert >= 1) {
                            // Delete the offending records and add the merged ones.
                            pointer.previous();
                            for (int j = 0; j < count_delete + count_insert; j++) {
                                pointer.previous();
                                pointer.remove();
                            }
                            for (DiffAction newDiff : diff_main(text_delete, text_insert, false)) {
                                pointer.add(newDiff);
                            }
                        }
                        count_insert = 0;
                        count_delete = 0;
                        text_delete = """";
                        text_insert = """";
                        break;
                }
                thisDiff = pointer.hasNext() ? pointer.next() : null;
            }
            diffs.removeLast(); // Remove the dummy entry at the end.
        }
        return diffs;
    }


    /**
     * Split two texts into a list of strings. Reduce the texts to a string of hashes where each Unicode character
     * represents one line.
     * 
     * @param text1 First string.
     * @param text2 Second string.
     * @return An object containing the encoded text1, the encoded text2 and the List of unique strings. The zeroth
     *         element of the List of unique strings is intentionally blank.
     */
    protected LinesToCharsResult diff_linesToChars(String text1, String text2) {
        List<String> lineArray = new ArrayList<String>();
        Map<String, Integer> lineHash = new HashMap<String, Integer>();
        // e.g. linearray[4] == ""Hello\n""
        // e.g. linehash.get(""Hello\n"") == 4

        // ""\x00"" is a valid character, but various debuggers don't like it.
        // So we'll insert a junk entry to avoid generating a null character.
        lineArray.add("""");

        String chars1 = diff_linesToCharsMunge(text1, lineArray, lineHash);
        String chars2 = diff_linesToCharsMunge(text2, lineArray, lineHash);
        return new LinesToCharsResult(chars1, chars2, lineArray);
    }


    /**
     * Split a text into a list of strings. Reduce the texts to a string of hashes where each Unicode character
     * represents one line.
     * 
     * @param text String to encode.
     * @param lineArray List of unique strings.
     * @param lineHash Map of strings to indices.
     * @return Encoded string.
     */
    private String diff_linesToCharsMunge(String text, List<String> lineArray, Map<String, Integer> lineHash) {
        int lineStart = 0;
        int lineEnd = -1;
        String line;
        StringBuilder chars = new StringBuilder();
        // Walk the text, pulling out a substring for each line.
        // text.split('\n') would would temporarily double our memory footprint.
        // Modifying text would create many large strings to garbage collect.
        while (lineEnd < text.length() - 1) {
            lineEnd = text.indexOf('\n', lineStart);
            if (lineEnd == -1) {
                lineEnd = text.length() - 1;
            }
            line = text.substring(lineStart, lineEnd + 1);
            lineStart = lineEnd + 1;

            if (lineHash.containsKey(line)) {
                chars.append(String.valueOf((char) (int) lineHash.get(line)));
            } else {
                lineArray.add(line);
                lineHash.put(line, lineArray.size() - 1);
                chars.append(String.valueOf((char) (lineArray.size() - 1)));
            }
        }
        return chars.toString();
    }


    /**
     * Rehydrate the text in a diff from a string of line hashes to real lines of text.
     * 
     * @param diffs LinkedList of Diff objects.
     * @param lineArray List of unique strings.
     */
    protected void diff_charsToLines(LinkedList<DiffAction> diffs, List<String> lineArray) {
        StringBuilder text;
        for (DiffAction diff : diffs) {
            text = new StringBuilder();
            for (int y = 0; y < diff.text.length(); y++) {
                text.append(lineArray.get(diff.text.charAt(y)));
            }
            diff.text = text.toString();
        }
    }


    /**
     * Explore the intersection points between the two texts.
     * 
     * @param text1 Old string to be diffed.
     * @param text2 New string to be diffed.
     * @return LinkedList of Diff objects or null if no diff available.
     */
    protected LinkedList<DiffAction> diff_map(String text1, String text2) {
        long ms_end = System.currentTimeMillis() + (long) (Diff_Timeout * 1000);
        // Cache the text lengths to prevent multiple calls.
        int text1_length = text1.length();
        int text2_length = text2.length();
        int max_d = text1_length + text2_length - 1;
        boolean doubleEnd = Diff_DualThreshold * 2 < max_d;
        List<Set<Long>> v_map1 = new ArrayList<Set<Long>>();
        List<Set<Long>> v_map2 = new ArrayList<Set<Long>>();
        Map<Integer, Integer> v1 = new HashMap<Integer, Integer>();
        Map<Integer, Integer> v2 = new HashMap<Integer, Integer>();
        v1.put(1, 0);
        v2.put(1, 0);
        int x, y;
        Long footstep = 0L; // Used to track overlapping paths.
        Map<Long, Integer> footsteps = new HashMap<Long, Integer>();
        boolean done = false;
        // If the total number of characters is odd, then the front path will
        // collide with the reverse path.
        boolean front = ((text1_length + text2_length) % 2 == 1);
        for (int d = 0; d < max_d; d++) {
            // Bail out if timeout reached.
            if (Diff_Timeout > 0 && System.currentTimeMillis() > ms_end) {
                return null;
            }

            // Walk the front path one step.
            v_map1.add(new HashSet<Long>()); // Adds at index 'd'.
            for (int k = -d; k <= d; k += 2) {
                if (k == -d || k != d && v1.get(k - 1) < v1.get(k + 1)) {
                    x = v1.get(k + 1);
                } else {
                    x = v1.get(k - 1) + 1;
                }
                y = x - k;
                if (doubleEnd) {
                    footstep = diff_footprint(x, y);
                    if (front && (footsteps.containsKey(footstep))) {
                        done = true;
                    }
                    if (!front) {
                        footsteps.put(footstep, d);
                    }
                }
                while (!done && x < text1_length && y < text2_length && text1.charAt(x) == text2.charAt(y)) {
                    x++;
                    y++;
                    if (doubleEnd) {
                        footstep = diff_footprint(x, y);
                        if (front && (footsteps.containsKey(footstep))) {
                            done = true;
                        }
                        if (!front) {
                            footsteps.put(footstep, d);
                        }
                    }
                }
                v1.put(k, x);
                v_map1.get(d).add(diff_footprint(x, y));
                if (x == text1_length && y == text2_length) {
                    // Reached the end in single-path mode.
                    return diff_path1(v_map1, text1, text2);
                } else if (done) {
                    // Front path ran over reverse path.
                    v_map2 = v_map2.subList(0, footsteps.get(footstep) + 1);
                    LinkedList<DiffAction> a = diff_path1(v_map1, text1.substring(0, x), text2.substring(0, y));
                    a.addAll(diff_path2(v_map2, text1.substring(x), text2.substring(y)));
                    return a;
                }
            }

            if (doubleEnd) {
                // Walk the reverse path one step.
                v_map2.add(new HashSet<Long>()); // Adds at index 'd'.
                for (int k = -d; k <= d; k += 2) {
                    if (k == -d || k != d && v2.get(k - 1) < v2.get(k + 1)) {
                        x = v2.get(k + 1);
                    } else {
                        x = v2.get(k - 1) + 1;
                    }
                    y = x - k;
                    footstep = diff_footprint(text1_length - x, text2_length - y);
                    if (!front && (footsteps.containsKey(footstep))) {
                        done = true;
                    }
                    if (front) {
                        footsteps.put(footstep, d);
                    }
                    while (!done && x < text1_length && y < text2_length
                            && text1.charAt(text1_length - x - 1) == text2.charAt(text2_length - y - 1)) {
                        x++;
                        y++;
                        footstep = diff_footprint(text1_length - x, text2_length - y);
                        if (!front && (footsteps.containsKey(footstep))) {
                            done = true;
                        }
                        if (front) {
                            footsteps.put(footstep, d);
                        }
                    }
                    v2.put(k, x);
                    v_map2.get(d).add(diff_footprint(x, y));
                    if (done) {
                        // Reverse path ran over front path.
                        v_map1 = v_map1.subList(0, footsteps.get(footstep) + 1);
                        LinkedList<DiffAction> a = diff_path1(v_map1, text1.substring(0, text1_length - x),
                                text2.substring(0, text2_length - y));
                        a.addAll(diff_path2(v_map2, text1.substring(text1_length - x),
                                text2.substring(text2_length - y)));
                        return a;
                    }
                }
            }
        }
        // Number of diffs equals number of characters, no commonality at all.
        return null;
    }


    /**
     * Work from the middle back to the start to determine the path.
     * 
     * @param v_map List of path sets.
     * @param text1 Old string fragment to be diffed.
     * @param text2 New string fragment to be diffed.
     * @return LinkedList of Diff objects.
     */
    protected LinkedList<DiffAction> diff_path1(List<Set<Long>> v_map, String text1, String text2) {
        LinkedList<DiffAction> path = new LinkedList<DiffAction>();
        int x = text1.length();
        int y = text2.length();
        Operation last_op = null;
        for (int d = v_map.size() - 2; d >= 0; d--) {
            while (true) {
                if (v_map.get(d).contains(diff_footprint(x - 1, y))) {
                    x--;
                    if (last_op == Operation.DELETE) {
                        path.getFirst().text = text1.charAt(x) + path.getFirst().text;
                    } else {
                        path.addFirst(new DiffAction(Operation.DELETE, text1.substring(x, x + 1)));
                    }
                    last_op = Operation.DELETE;
                    break;
                } else if (v_map.get(d).contains(diff_footprint(x, y - 1))) {
                    y--;
                    if (last_op == Operation.INSERT) {
                        path.getFirst().text = text2.charAt(y) + path.getFirst().text;
                    } else {
                        path.addFirst(new DiffAction(Operation.INSERT, text2.substring(y, y + 1)));
                    }
                    last_op = Operation.INSERT;
                    break;
                } else {
                    x--;
                    y--;
                    assert (text1.charAt(x) == text2.charAt(y)) : ""No diagonal.  Can't happen. (diff_path1)"";
                    if (last_op == Operation.EQUAL) {
                        path.getFirst().text = text1.charAt(x) + path.getFirst().text;
                    } else {
                        path.addFirst(new DiffAction(Operation.EQUAL, text1.substring(x, x + 1)));
                    }
                    last_op = Operation.EQUAL;
                }
            }
        }
        return path;
    }


    /**
     * Work from the middle back to the end to determine the path.
     * 
     * @param v_map List of path sets.
     * @param text1 Old string fragment to be diffed.
     * @param text2 New string fragment to be diffed.
     * @return LinkedList of Diff objects.
     */
    protected LinkedList<DiffAction> diff_path2(List<Set<Long>> v_map, String text1, String text2) {
        LinkedList<DiffAction> path = new LinkedList<DiffAction>();
        int x = text1.length();
        int y = text2.length();
        Operation last_op = null;
        for (int d = v_map.size() - 2; d >= 0; d--) {
            while (true) {
                if (v_map.get(d).contains(diff_footprint(x - 1, y))) {
                    x--;
                    if (last_op == Operation.DELETE) {
                        path.getLast().text += text1.charAt(text1.length() - x - 1);
                    } else {
                        path.addLast(new DiffAction(Operation.DELETE, text1.substring(text1.length() - x - 1,
                                text1.length() - x)));
                    }
                    last_op = Operation.DELETE;
                    break;
                } else if (v_map.get(d).contains(diff_footprint(x, y - 1))) {
                    y--;
                    if (last_op == Operation.INSERT) {
                        path.getLast().text += text2.charAt(text2.length() - y - 1);
                    } else {
                        path.addLast(new DiffAction(Operation.INSERT, text2.substring(text2.length() - y - 1,
                                text2.length() - y)));
                    }
                    last_op = Operation.INSERT;
                    break;
                } else {
                    x--;
                    y--;
                    assert (text1.charAt(text1.length() - x - 1) == text2.charAt(text2.length() - y - 1)) : ""No diagonal.  Can't happen. (diff_path2)"";
                    if (last_op == Operation.EQUAL) {
                        path.getLast().text += text1.charAt(text1.length() - x - 1);
                    } else {
                        path.addLast(new DiffAction(Operation.EQUAL, text1.substring(text1.length() - x - 1,
                                text1.length() - x)));
                    }
                    last_op = Operation.EQUAL;
                }
            }
        }
        return path;
    }


    /**
     * Compute a good hash of two integers.
     * 
     * @param x First int.
     * @param y Second int.
     * @return A long made up of both ints.
     */
    protected long diff_footprint(int x, int y) {
        // The maximum size for a long is 9,223,372,036,854,775,807
        // The maximum size for an int is 2,147,483,647
        // Two ints fit nicely in one long.
        long result = x;
        result = result << 32;
        result += y;
        return result;
    }


    /**
     * Determine the common prefix of two strings
     * 
     * @param text1 First string.
     * @param text2 Second string.
     * @return The number of characters common to the start of each string.
     */
    public int diff_commonPrefix(String text1, String text2) {
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
        int n = Math.min(text1.length(), text2.length());
        for (int i = 0; i < n; i++) {
            if (text1.charAt(i) != text2.charAt(i)) {
                return i;
            }
        }
        return n;
    }


    /**
     * Determine the common suffix of two strings
     * 
     * @param text1 First string.
     * @param text2 Second string.
     * @return The number of characters common to the end of each string.
     */
    public int diff_commonSuffix(String text1, String text2) {
        // Performance analysis: http://neil.fraser.name/news/2007/10/09/
        int text1_length = text1.length();
        int text2_length = text2.length();
        int n = Math.min(text1_length, text2_length);
        for (int i = 1; i <= n; i++) {
            if (text1.charAt(text1_length - i) != text2.charAt(text2_length - i)) {
                return i - 1;
            }
        }
        return n;
    }


    /**
     * Do the two texts share a substring which is at least half the length of the longer text?
     * 
     * @param text1 First string.
     * @param text2 Second string.
     * @return Five element String array, containing the prefix of text1, the suffix of text1, the prefix of text2, the
     *         suffix of text2 and the common middle. Or null if there was no match.
     */
    protected String[] diff_halfMatch(String text1, String text2) {
        String longtext = text1.length() > text2.length() ? text1 : text2;
        String shorttext = text1.length() > text2.length() ? text2 : text1;
        if (longtext.length() < 10 || shorttext.length() < 1) {
            return null; // Pointless.
        }

        // First check if the second quarter is the seed for a half-match.
        String[] hm1 = diff_halfMatchI(longtext, shorttext, (longtext.length() + 3) / 4);
        // Check again based on the third quarter.
        String[] hm2 = diff_halfMatchI(longtext, shorttext, (longtext.length() + 1) / 2);
        String[] hm;
        if (hm1 == null && hm2 == null) {
            return null;
        } else if (hm2 == null) {
            hm = hm1;
        } else if (hm1 == null) {
            hm = hm2;
        } else {
            // Both matched. Select the longest.
            hm = hm1[4].length() > hm2[4].length() ? hm1 : hm2;
        }

        // A half-match was found, sort out the return data.
        if (text1.length() > text2.length()) {
            return hm;
            // return new String[]{hm[0], hm[1], hm[2], hm[3], hm[4]};
        } else {
            return new String[] { hm[2], hm[3], hm[0], hm[1], hm[4] };
        }
    }


    /**
     * Does a substring of shorttext exist within longtext such that the substring is at least half the length of
     * longtext?
     * 
     * @param longtext Longer string.
     * @param shorttext Shorter string.
     * @param i Start index of quarter length substring within longtext.
     * @return Five element String array, containing the prefix of longtext, the suffix of longtext, the prefix of
     *         shorttext, the suffix of shorttext and the common middle. Or null if there was no match.
     */
    private String[] diff_halfMatchI(String longtext, String shorttext, int i) {
        // Start with a 1/4 length substring at position i as a seed.
        String seed = longtext.substring(i, i + longtext.length() / 4);
        int j = -1;
        String best_common = """";
        String best_longtext_a = """", best_longtext_b = """";
        String best_shorttext_a = """", best_shorttext_b = """";
        while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
            int prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));
            int suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));
            if (best_common.length() < suffixLength + prefixLength) {
                best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);
                best_longtext_a = longtext.substring(0, i - suffixLength);
                best_longtext_b = longtext.substring(i + prefixLength);
                best_shorttext_a = shorttext.substring(0, j - suffixLength);
                best_shorttext_b = shorttext.substring(j + prefixLength);
            }
        }
        if (best_common.length() >= longtext.length() / 2) {
            return new String[] { best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common };
        } else {
            return null;
        }
    }


    /**
     * Reduce the number of edits by eliminating semantically trivial equalities.
     * 
     * @param diffs LinkedList of Diff objects.
     */
    public void diff_cleanupSemantic(LinkedList<DiffAction> diffs) {
        if (diffs.isEmpty()) {
            return;
        }
        boolean changes = false;
        Stack<DiffAction> equalities = new Stack<DiffAction>(); // Stack of qualities.
        String lastequality = null; // Always equal to equalities.lastElement().text
        ListIterator<DiffAction> pointer = diffs.listIterator();
        // Number of characters that changed prior to the equality.
        int length_changes1 = 0;
        // Number of characters that changed after the equality.
        int length_changes2 = 0;
        DiffAction thisDiff = pointer.next();
        while (thisDiff != null) {
            if (thisDiff.operation == Operation.EQUAL) {
                // equality found
                equalities.push(thisDiff);
                length_changes1 = length_changes2;
                length_changes2 = 0;
                lastequality = thisDiff.text;
            } else {
                // an insertion or deletion
                length_changes2 += thisDiff.text.length();
                if (lastequality != null && (lastequality.length() <= length_changes1)
                        && (lastequality.length() <= length_changes2)) {
                    // System.out.println(""Splitting: '"" + lastequality + ""'"");
                    // Walk back to offending equality.
                    while (thisDiff != equalities.lastElement()) {
                        thisDiff = pointer.previous();
                    }
                    pointer.next();

                    // Replace equality with a delete.
                    pointer.set(new DiffAction(Operation.DELETE, lastequality));
                    // Insert a corresponding an insert.
                    pointer.add(new DiffAction(Operation.INSERT, lastequality));

                    equalities.pop(); // Throw away the equality we just deleted.
                    if (!equalities.empty()) {
                        // Throw away the previous equality (it needs to be reevaluated).
                        equalities.pop();
                    }
                    if (equalities.empty()) {
                        // There are no previous equalities, walk back to the start.
                        while (pointer.hasPrevious()) {
                            pointer.previous();
                        }
                    } else {
                        // There is a safe equality we can fall back to.
                        thisDiff = equalities.lastElement();
                        while (thisDiff != pointer.previous()) {
                            // Intentionally empty loop.
                        }
                    }

                    length_changes1 = 0; // Reset the counters.
                    length_changes2 = 0;
                    lastequality = null;
                    changes = true;
                }
            }
            thisDiff = pointer.hasNext() ? pointer.next() : null;
        }

        if (changes) {
            diff_cleanupMerge(diffs);
        }
        diff_cleanupSemanticLossless(diffs);
    }


    /**
     * Look for single edits surrounded on both sides by equalities which can be shifted sideways to align the edit to a
     * word boundary. e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
     * 
     * @param diffs LinkedList of Diff objects.
     */
    public void diff_cleanupSemanticLossless(LinkedList<DiffAction> diffs) {
        String equality1, edit, equality2;
        String commonString;
        int commonOffset;
        int score, bestScore;
        String bestEquality1, bestEdit, bestEquality2;
        // Create a new iterator at the start.
        ListIterator<DiffAction> pointer = diffs.listIterator();
        DiffAction prevDiff = pointer.hasNext() ? pointer.next() : null;
        DiffAction thisDiff = pointer.hasNext() ? pointer.next() : null;
        DiffAction nextDiff = pointer.hasNext() ? pointer.next() : null;
        // Intentionally ignore the first and last element (don't need checking).
        while (nextDiff != null) {
            if (prevDiff.operation == Operation.EQUAL && nextDiff.operation == Operation.EQUAL) {
                // This is a single edit surrounded by equalities.
                equality1 = prevDiff.text;
                edit = thisDiff.text;
                equality2 = nextDiff.text;

                // First, shift the edit as far left as possible.
                commonOffset = diff_commonSuffix(equality1, edit);
                if (commonOffset != 0) {
                    commonString = edit.substring(edit.length() - commonOffset);
                    equality1 = equality1.substring(0, equality1.length() - commonOffset);
                    edit = commonString + edit.substring(0, edit.length() - commonOffset);
                    equality2 = commonString + equality2;
                }

                // Second, step character by character right, looking for the best fit.
                bestEquality1 = equality1;
                bestEdit = edit;
                bestEquality2 = equality2;
                bestScore = diff_cleanupSemanticScore(equality1, edit) + diff_cleanupSemanticScore(edit, equality2);
                while (edit.length() > 0 && equality2.length() > 0 && edit.charAt(0) == equality2.charAt(0)) {
                    equality1 += edit.charAt(0);
                    edit = edit.substring(1) + equality2.charAt(0);
                    equality2 = equality2.substring(1);
                    score = diff_cleanupSemanticScore(equality1, edit) + diff_cleanupSemanticScore(edit, equality2);
                    // The >= encourages trailing rather than leading whitespace on edits.
                    if (score >= bestScore) {
                        bestScore = score;
                        bestEquality1 = equality1;
                        bestEdit = edit;
                        bestEquality2 = equality2;
                    }
                }

                if (!prevDiff.text.equals(bestEquality1)) {
                    // We have an improvement, save it back to the diff.
                    if (bestEquality1.length() > 0) {
                        prevDiff.text = bestEquality1;
                    } else {
                        pointer.previous(); // Walk past nextDiff.
                        pointer.previous(); // Walk past thisDiff.
                        pointer.previous(); // Walk past prevDiff.
                        pointer.remove(); // Delete prevDiff.
                        pointer.next(); // Walk past thisDiff.
                        pointer.next(); // Walk past nextDiff.
                    }
                    thisDiff.text = bestEdit;
                    if (bestEquality2.length() > 0) {
                        nextDiff.text = bestEquality2;
                    } else {
                        pointer.remove(); // Delete nextDiff.
                        nextDiff = thisDiff;
                        thisDiff = prevDiff;
                    }
                }
            }
            prevDiff = thisDiff;
            thisDiff = nextDiff;
            nextDiff = pointer.hasNext() ? pointer.next() : null;
        }
    }


    /**
     * Given two strings, compute a score representing whether the internal boundary falls on logical boundaries. Scores
     * range from 5 (best) to 0 (worst).
     * 
     * @param one First string.
     * @param two Second string.
     * @return The score.
     */
    private int diff_cleanupSemanticScore(String one, String two) {
        if (one.length() == 0 || two.length() == 0) {
            // Edges are the best.
            return 5;
        }

        // Each port of this function behaves slightly differently due to
        // subtle differences in each language's definition of things like
        // 'whitespace'. Since this function's purpose is largely cosmetic,
        // the choice has been made to use each language's native features
        // rather than force total conformity.
        int score = 0;
        // One point for non-alphanumeric.
        if (!Character.isLetterOrDigit(one.charAt(one.length() - 1)) || !Character.isLetterOrDigit(two.charAt(0))) {
            score++;
            // Two points for whitespace.
            if (Character.isWhitespace(one.charAt(one.length() - 1)) || Character.isWhitespace(two.charAt(0))) {
                score++;
                // Three points for line breaks.
                if (Character.getType(one.charAt(one.length() - 1)) == Character.CONTROL
                        || Character.getType(two.charAt(0)) == Character.CONTROL) {
                    score++;
                    // Four points for blank lines.
                    if (BLANKLINEEND.matcher(one).find() || BLANKLINESTART.matcher(two).find()) {
                        score++;
                    }
                }
            }
        }
        return score;
    }

    private Pattern BLANKLINEEND = Pattern.compile(""\\n\\r?\\n\\Z"", Pattern.DOTALL);
    private Pattern BLANKLINESTART = Pattern.compile(""\\A\\r?\\n\\r?\\n"", Pattern.DOTALL);


    /**
     * Reorder and merge like edit sections. Merge equalities. Any edit section can move as long as it doesn't cross an
     * equality.
     * 
     * @param diffs LinkedList of Diff objects.
     */
    public void diff_cleanupMerge(LinkedList<DiffAction> diffs) {
        diffs.add(new DiffAction(Operation.EQUAL, """")); // Add a dummy entry at the end.
        ListIterator<DiffAction> pointer = diffs.listIterator();
        int count_delete = 0;
        int count_insert = 0;
        String text_delete = """";
        String text_insert = """";
        DiffAction thisDiff = pointer.next();
        DiffAction prevEqual = null;
        int commonlength;
        while (thisDiff != null) {
            switch (thisDiff.operation) {
                case INSERT:
                    count_insert++;
                    text_insert += thisDiff.text;
                    prevEqual = null;
                    break;
                case DELETE:
                    count_delete++;
                    text_delete += thisDiff.text;
                    prevEqual = null;
                    break;
                case EQUAL:
                    if (count_delete != 0 || count_insert != 0) {
                        // Delete the offending records.
                        pointer.previous(); // Reverse direction.
                        while (count_delete-- > 0) {
                            pointer.previous();
                            pointer.remove();
                        }
                        while (count_insert-- > 0) {
                            pointer.previous();
                            pointer.remove();
                        }
                        if (count_delete != 0 && count_insert != 0) {
                            // Factor out any common prefixies.
                            commonlength = diff_commonPrefix(text_insert, text_delete);
                            if (commonlength != 0) {
                                if (pointer.hasPrevious()) {
                                    thisDiff = pointer.previous();
                                    assert thisDiff.operation == Operation.EQUAL : ""Previous diff should have been an equality."";
                                    thisDiff.text += text_insert.substring(0, commonlength);
                                    pointer.next();
                                } else {
                                    pointer.add(new DiffAction(Operation.EQUAL, text_insert.substring(0, commonlength)));
                                }
                                text_insert = text_insert.substring(commonlength);
                                text_delete = text_delete.substring(commonlength);
                            }
                            // Factor out any common suffixies.
                            commonlength = diff_commonSuffix(text_insert, text_delete);
                            if (commonlength != 0) {
                                thisDiff = pointer.next();
                                thisDiff.text = text_insert.substring(text_insert.length() - commonlength)
                                        + thisDiff.text;
                                text_insert = text_insert.substring(0, text_insert.length() - commonlength);
                                text_delete = text_delete.substring(0, text_delete.length() - commonlength);
                                pointer.previous();
                            }
                        }
                        // Insert the merged records.
                        if (text_delete.length() > 0) {
                            pointer.add(new DiffAction(Operation.DELETE, text_delete));
                        }
                        if (text_insert.length() > 0) {
                            pointer.add(new DiffAction(Operation.INSERT, text_insert));
                        }
                        // Step forward to the equality.
                        thisDiff = pointer.hasNext() ? pointer.next() : null;
                    } else if (prevEqual != null) {
                        // Merge this equality with the previous one.
                        prevEqual.text += thisDiff.text;
                        pointer.remove();
                        thisDiff = pointer.previous();
                        pointer.next(); // Forward direction
                    }
                    count_insert = 0;
                    count_delete = 0;
                    text_delete = """";
                    text_insert = """";
                    prevEqual = thisDiff;
                    break;
            }
            thisDiff = pointer.hasNext() ? pointer.next() : null;
        }
        // System.out.println(diff);
        if (diffs.getLast().text.length() == 0) {
            diffs.removeLast(); // Remove the dummy entry at the end.
        }

        /*
         * Second pass: look for single edits surrounded on both sides by equalities which can be shifted sideways to
         * eliminate an equality. e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
         */
        boolean changes = false;
        // Create a new iterator at the start.
        // (As opposed to walking the current one back.)
        pointer = diffs.listIterator();
        DiffAction prevDiff = pointer.hasNext() ? pointer.next() : null;
        thisDiff = pointer.hasNext() ? pointer.next() : null;
        DiffAction nextDiff = pointer.hasNext() ? pointer.next() : null;
        // Intentionally ignore the first and last element (don't need checking).
        while (nextDiff != null) {
            if (prevDiff.operation == Operation.EQUAL && nextDiff.operation == Operation.EQUAL) {
                // This is a single edit surrounded by equalities.
                if (thisDiff.text.endsWith(prevDiff.text)) {
                    // Shift the edit over the previous equality.
                    thisDiff.text = prevDiff.text
                            + thisDiff.text.substring(0, thisDiff.text.length() - prevDiff.text.length());
                    nextDiff.text = prevDiff.text + nextDiff.text;
                    pointer.previous(); // Walk past nextDiff.
                    pointer.previous(); // Walk past thisDiff.
                    pointer.previous(); // Walk past prevDiff.
                    pointer.remove(); // Delete prevDiff.
                    pointer.next(); // Walk past thisDiff.
                    thisDiff = pointer.next(); // Walk past nextDiff.
                    nextDiff = pointer.hasNext() ? pointer.next() : null;
                    changes = true;
                } else if (thisDiff.text.startsWith(nextDiff.text)) {
                    // Shift the edit over the next equality.
                    prevDiff.text += nextDiff.text;
                    thisDiff.text = thisDiff.text.substring(nextDiff.text.length()) + nextDiff.text;
                    pointer.remove(); // Delete nextDiff.
                    nextDiff = pointer.hasNext() ? pointer.next() : null;
                    changes = true;
                }
            }
            prevDiff = thisDiff;
            thisDiff = nextDiff;
            nextDiff = pointer.hasNext() ? pointer.next() : null;
        }
        // If shifts were made, the diff needs reordering and another shift sweep.
        if (changes) {
            diff_cleanupMerge(diffs);
        }
    }


    /**
     * Convert a Diff list into a pretty HTML report.
     * 
     * @param diffs LinkedList of Diff objects.
     * @return HTML representation.
     */
    public String diff_prettyHtml(LinkedList<DiffAction> diffs) {
        StringBuilder html = new StringBuilder();
        int i = 0;
        for (DiffAction aDiff : diffs) {
            String text = aDiff.text.replace(""&"", ""&amp;"").replace(""<"", ""&lt;"").replace("">"", ""&gt;"")
                    .replace(""\n"", ""<br>"");
            switch (aDiff.operation) {
                case INSERT:
                    String spaces = """";
                    int l = text.length();
                    for (int j = 0; j < l; j++) {
                        spaces += ""&nbsp;"";
                    }
                    html.append(""<span style=\""background:"" + WRONG_COLOR + "";\"">"").append(spaces).append(""</span>"");
                    break;
                case DELETE:
                    html.append(""<span style=\""background:"" + WRONG_COLOR + "";\"">"").append(text).append(""</span>"");
                    break;
                case EQUAL:
                    html.append(""<span style=\""background:"" + RIGHT_COLOR + "";\"">"").append(text).append(""</span>"");
                    break;
            }
            if (aDiff.operation != Operation.DELETE) {
                i += aDiff.text.length();
            }
        }
        return html.toString();
    }

    /**
     * Class representing one diff operation.
     */
    public static class DiffAction {
        /**
         * One of: INSERT, DELETE or EQUAL.
         */
        public Operation operation;
        /**
         * The text associated with this diff operation.
         */
        public String text;


        /**
         * Constructor. Initializes the diff with the provided values.
         * 
         * @param operation One of INSERT, DELETE or EQUAL.
         * @param text The text being applied.
         */
        public DiffAction(Operation operation, String text) {
            // Construct a diff with the specified operation and text.
            this.operation = operation;
            this.text = text;
        }


        /**
         * Display a human-readable version of this Diff.
         * 
         * @return text version.
         */
        @Override
        public String toString() {
            String prettyText = text.replace('\n', '\u00b6');
            return ""Diff("" + operation + "",\"""" + prettyText + ""\"")"";
        }


        /**
         * Is this Diff equivalent to another Diff?
         * 
         * @param d Another Diff to compare against.
         * @return true or false.
         */
        @Override
        public boolean equals(Object d) {
            try {
                return (((DiffAction) d).operation == operation) && (((DiffAction) d).text.equals(text));
            } catch (ClassCastException e) {
                return false;
            }
        }
    }
}
",True,8,56,5,27,0,0
60,com.ichi2.charts.ChartBuilder.java,"/**
 * Copyright (C) 2009, 2010 SC 4ViewSoft SRL
 * Copyright (C) 2011 Norbert Nagold <norbert.nagold@gmail.com>
 *  
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *  
 *      http://www.apache.org/licenses/LICENSE-2.0
 *  
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ichi2.charts;

import org.achartengine.ChartFactory;
import org.achartengine.GraphicalView;
import org.achartengine.chart.BarChart;
import org.achartengine.model.XYMultipleSeriesDataset;
import org.achartengine.model.XYSeries;
import org.achartengine.renderer.XYMultipleSeriesRenderer;
import org.achartengine.renderer.XYSeriesRenderer;

import android.app.Activity;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Resources;
import android.graphics.Paint.Align;
import android.os.Bundle;
import android.util.Log;
import android.view.GestureDetector;
import android.view.KeyEvent;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.view.GestureDetector.SimpleOnGestureListener;
import android.view.ViewGroup.LayoutParams;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.ichi2.anim.ActivityTransitionAnimation;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.R;
import com.ichi2.anki.Statistics;
import com.ichi2.anki.StudyOptions;
import com.ichi2.themes.Themes;
import com.tomgibara.android.veecheck.util.PrefSettings;

public class ChartBuilder extends Activity {
    public static final String TYPE = ""type"";
    public static final int ZOOM_MAX = 20;

    private XYMultipleSeriesDataset mDataset = new XYMultipleSeriesDataset();
    private XYMultipleSeriesRenderer mRenderer = new XYMultipleSeriesRenderer();

    private GraphicalView mChartView;
    private TextView mTitle;
    private double[] mPan;
    private int zoom = 0;

    private boolean mFullScreen;

    private static final int MENU_FULLSCREEN = 0;
    private static final int MENU_ZOOM_IN = 1;
    private static final int MENU_ZOOM_OUT = 2;

	/**
     * Swipe Detection
     */    
 	private GestureDetector gestureDetector;
 	View.OnTouchListener gestureListener;
 	private boolean mSwipeEnabled;

    @Override
    protected void onRestoreInstanceState(Bundle savedState) {
        super.onRestoreInstanceState(savedState);
        mDataset = (XYMultipleSeriesDataset) savedState.getSerializable(""dataset"");
        mRenderer = (XYMultipleSeriesRenderer) savedState.getSerializable(""renderer"");
    }


    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);
        outState.putSerializable(""dataset"", mDataset);
        outState.putSerializable(""renderer"", mRenderer);
    }


    public void setDataset(int row) {
        XYSeries series = new XYSeries(Statistics.Titles[row]);
        for (int i = 0; i < Statistics.xAxisData.length; i++) {
            series.add(Statistics.xAxisData[i], Statistics.sSeriesList[row][i]);
        }
        mDataset.addSeries(series);
    }


    public void setRenderer(int type, int row) {
        Resources res = getResources();
        XYSeriesRenderer renderer = new XYSeriesRenderer();
        if (type <= Statistics.TYPE_CUMULATIVE_DUE) {
        	switch (row) {
        	case 0: 
                renderer.setColor(res.getColor(R.color.statistics_due_young_cards));
        		break;
        	case 1:
                renderer.setColor(res.getColor(R.color.statistics_due_mature_cards));
                break;
        	case 2:
                renderer.setColor(res.getColor(R.color.statistics_due_failed_cards));
        		break;
        	}
        } else if (type == Statistics.TYPE_REVIEWS) {
        	switch (row) {
        	case 0: 
                renderer.setColor(res.getColor(R.color.statistics_reps_new_cards));
        		break;
        	case 1:
                renderer.setColor(res.getColor(R.color.statistics_reps_young_cards));
                break;
        	case 2:
                renderer.setColor(res.getColor(R.color.statistics_reps_mature_cards));
        		break;
        	}
        } else {
            renderer.setColor(res.getColor(R.color.statistics_default));        	
        }
        mRenderer.addSeriesRenderer(renderer);
    }


    private void zoom() {
        if (mChartView != null) {
            if (zoom > 0) {
                mRenderer.setXAxisMin(mPan[0] / (zoom + 1));
                mRenderer.setXAxisMax(mPan[1] / (zoom + 1));
            } else {
                mRenderer.setXAxisMin(mPan[0]);
                mRenderer.setXAxisMax(mPan[1]);
            }
            mChartView = ChartFactory.getBarChartView(this, mDataset, mRenderer, BarChart.Type.STACKED);
            LinearLayout layout = (LinearLayout) findViewById(R.id.chart);
            layout.addView(mChartView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
        }
    }


    public void closeChartBuilder() {
        finish();
        if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
            ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.UP);
        }
    }


    private SharedPreferences restorePreferences() {
        SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
        mFullScreen = preferences.getBoolean(""fullScreen"", false);
		mSwipeEnabled = preferences.getBoolean(""swipe"", false);
        return preferences;
    }


    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuItem item;
        item = menu.add(Menu.NONE, MENU_FULLSCREEN, Menu.NONE, R.string.statistics_fullscreen);
        item.setIcon(R.drawable.ic_menu_manage);
        item = menu.add(Menu.NONE, MENU_ZOOM_IN, Menu.NONE, R.string.statistics_zoom_in);
        item.setIcon(R.drawable.ic_menu_zoom_in);
        item = menu.add(Menu.NONE, MENU_ZOOM_OUT, Menu.NONE, R.string.statistics_zoom_out);
        item.setIcon(R.drawable.ic_menu_zoom_out);
        return true;
    }


    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        menu.findItem(MENU_ZOOM_IN).setEnabled(zoom < ZOOM_MAX);
        menu.findItem(MENU_ZOOM_OUT).setEnabled(zoom > 0);
        return true;
    }


    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case MENU_FULLSCREEN:
                SharedPreferences preferences = PrefSettings.getSharedPrefs(getBaseContext());
                Editor editor = preferences.edit();
                editor.putBoolean(""fullScreen"", !mFullScreen);
                Statistics.sZoom = zoom;
                editor.commit();
                finish();
                Intent intent = new Intent(this, com.ichi2.charts.ChartBuilder.class);
                startActivity(intent);
                if (Integer.valueOf(android.os.Build.VERSION.SDK) > 4) {
                    ActivityTransitionAnimation.slide(this, ActivityTransitionAnimation.FADE);
                }
                return true;
            case MENU_ZOOM_IN:
                zoom += 1;
                zoom();
                return true;
            case MENU_ZOOM_OUT:
                if (zoom > 0) {
                    zoom -= 1;
                }
                zoom();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
    	Themes.applyTheme(this);
        super.onCreate(savedInstanceState);
        restorePreferences();
        if (Statistics.sSeriesList == null) {
            // Log.i(AnkiDroidApp.TAG, ""ChartBuilder - Data variable empty, closing chartbuilder"");
        	finish();
        	return;
        }
        if (mFullScreen) {
            getWindow()
                    .setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
            requestWindowFeature(Window.FEATURE_NO_TITLE);
        }
        View mainView = getLayoutInflater().inflate(R.layout.statistics, null);
        setContentView(mainView);
        int[] colors = Themes.getChartColors();
        mainView.setBackgroundColor(colors[1]);
        mTitle = (TextView) findViewById(R.id.statistics_title);
        if (mChartView == null) {
            if (mFullScreen) {
                mTitle.setText(Statistics.sTitle);
                mTitle.setTextColor(colors[0]);
            } else {
                setTitle(Statistics.sTitle);
                mTitle.setVisibility(View.GONE);
            }
            for (int i = 0; i < Statistics.sSeriesList.length; i++) {
                setDataset(i);
                setRenderer(Statistics.sType, i);
            }
            if (Statistics.sSeriesList.length == 1) {
                mRenderer.setShowLegend(false);
            }
            mPan = new double[] { Statistics.xAxisData[0] - 1,
                    Statistics.xAxisData[Statistics.xAxisData.length - 1] + 1 };
            mRenderer.setLegendTextSize(17);
            mRenderer.setLegendHeight(60);
            mRenderer.setAxisTitleTextSize(17);
            mRenderer.setLabelsTextSize(17);
            mRenderer.setXAxisMin(mPan[0]);
            mRenderer.setXAxisMax(mPan[1]);
            mRenderer.setYAxisMin(0);
            mRenderer.setXTitle(Statistics.axisLabels[0]);
            mRenderer.setYTitle(Statistics.axisLabels[1]);
            mRenderer.setBackgroundColor(colors[1]);
            mRenderer.setMarginsColor(colors[1]);
            mRenderer.setAxesColor(colors[0]);
            mRenderer.setLabelsColor(colors[0]);
            mRenderer.setZoomEnabled(false, false);
            if (Statistics.sSeriesList[0][0] > 100 || Statistics.sSeriesList[0][1] > 100 || Statistics.sSeriesList[0][Statistics.sSeriesList[0].length - 1] > 100) {
                mRenderer.setMargins(new int[] { 15, 50, 25, 0 });
            } else {
                mRenderer.setMargins(new int[] { 15, 42, 25, 0 });
            }
            mRenderer.setPanEnabled(true, false);
            mRenderer.setPanLimits(mPan);
            mRenderer.setXLabelsAlign(Align.CENTER);
            mRenderer.setYLabelsAlign(Align.RIGHT);
            mChartView = ChartFactory.getBarChartView(this, mDataset, mRenderer, BarChart.Type.STACKED);
            LinearLayout layout = (LinearLayout) findViewById(R.id.chart);
            layout.addView(mChartView, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
        } else {
            mChartView.repaint();
        }
		gestureDetector = new GestureDetector(new MyGestureDetector());
        mChartView.setOnTouchListener(new View.OnTouchListener() {
        	public boolean onTouch(View v, MotionEvent event) {
        		if (gestureDetector.onTouchEvent(event)) {
        			return true;
        		}
        		return false;
        		}
        	});
		zoom = Statistics.sZoom;
        if (zoom > 0) {
        	zoom();
        }
    }


    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
            // Log.i(AnkiDroidApp.TAG, ""ChartBuilder - onBackPressed()"");
            closeChartBuilder();
        }
        return super.onKeyDown(keyCode, event);
    }

    class MyGestureDetector extends SimpleOnGestureListener {	
    	@Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
            if (mSwipeEnabled) {
                try {
                	if (e1.getY() - e2.getY() > StudyOptions.sSwipeMinDistance && Math.abs(velocityY) > StudyOptions.sSwipeThresholdVelocity && Math.abs(e1.getX() - e2.getX()) < StudyOptions.sSwipeMaxOffPath) {
                		closeChartBuilder();
                    }
       			}
                catch (Exception e) {
                  	Log.e(AnkiDroidApp.TAG, ""onFling Exception = "" + e.getMessage());
                }
            }	            	
            return false;
    	}
    }
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (gestureDetector.onTouchEvent(event))
	        return true;
	    else
	    	return false;
    }
}
",True,35,63,0,0,5,29
61,com.ichi2.veecheck.CheckService.java,"/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.veecheck;

import android.content.Intent;
import android.content.IntentFilter;

import com.ichi2.anki.R;
import com.tomgibara.android.veecheck.VeecheckNotifier;
import com.tomgibara.android.veecheck.VeecheckService;
import com.tomgibara.android.veecheck.VeecheckState;
import com.tomgibara.android.veecheck.util.DefaultNotifier;
import com.tomgibara.android.veecheck.util.PrefState;

public class CheckService extends VeecheckService {

    public static final int NOTIFICATION_ID = 1;


    @Override
    protected VeecheckNotifier createNotifier() {
        IntentFilter[] filters = new IntentFilter[1];

        IntentFilter filter = new IntentFilter(Intent.ACTION_VIEW);
        filter.addDataScheme(""http"");
        filters[0] = filter;

        return new DefaultNotifier(this, NOTIFICATION_ID, filters, new Intent(this, Notification.class),
                R.drawable.anki, R.string.notify_ticker, R.string.notify_title, R.string.notify_message);
    }


    @Override
    protected VeecheckState createState() {
        return new PrefState(this);
    }

}
",False,90,12,0,0,3,5
62,com.ichi2.veecheck.Notification.java,"/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.veecheck;

import android.os.Bundle;
import android.view.View;
import android.widget.Checkable;

import com.ichi2.anki.R;
import com.tomgibara.android.veecheck.VeecheckActivity;
import com.tomgibara.android.veecheck.VeecheckState;
import com.tomgibara.android.veecheck.util.PrefState;

public class Notification extends VeecheckActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.notification);
    }


    @Override
    protected VeecheckState createState() {
        return new PrefState(this);
    }


    @Override
    protected View getNoButton() {
        return findViewById(R.id.no);
    }


    @Override
    protected View getYesButton() {
        return findViewById(R.id.yes);
    }


    @Override
    protected Checkable getStopCheckBox() {
        return (Checkable) findViewById(R.id.stop);
    }
}
",False,18,4,0,0,1,3
63,com.ichi2.veecheck.CheckReceiver.java,"/****************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.veecheck;

import android.content.Context;

import com.tomgibara.android.veecheck.VeecheckReceiver;
import com.tomgibara.android.veecheck.VeecheckSettings;
import com.tomgibara.android.veecheck.VeecheckState;
import com.tomgibara.android.veecheck.util.PrefSettings;
import com.tomgibara.android.veecheck.util.PrefState;

public class CheckReceiver extends VeecheckReceiver {

    @Override
    protected VeecheckSettings createSettings(Context context) {
        return new PrefSettings(context);
    }


    @Override
    protected VeecheckState createState(Context context) {
        return new PrefState(context);
    }

}
",False,52,7,0,0,2,5
64,com.ichi2.async.Connection.java,"/***************************************************************************************
 * Copyright (c) 2009 Edu Zamora <edu.zasu@gmail.com>                                   *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.async;

import android.app.Application;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.res.Resources;
import android.database.Cursor;
import android.database.SQLException;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.os.AsyncTask;
import android.util.Log;

import com.ichi2.anki.AnkiDatabaseManager;
import com.ichi2.anki.AnkiDb;
import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.AnkiDroidProxy;
import com.ichi2.anki.Deck;
import com.ichi2.anki.Feedback;
import com.ichi2.anki.R;
import com.ichi2.anki.Reviewer;
import com.ichi2.anki.SyncClient;
import com.ichi2.anki.Utils;
import com.tomgibara.android.veecheck.util.PrefSettings;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;

public class Connection extends AsyncTask<Connection.Payload, Object, Connection.Payload> {

    public static final int TASK_TYPE_LOGIN = 0;
    public static final int TASK_TYPE_GET_SHARED_DECKS = 1;
    public static final int TASK_TYPE_GET_PERSONAL_DECKS = 2;
    public static final int TASK_TYPE_SYNC_ALL_DECKS = 3;
    public static final int TASK_TYPE_SYNC_DECK = 4;
    public static final int TASK_TYPE_SYNC_DECK_FROM_PAYLOAD = 5;
    public static final int TASK_TYPE_SEND_CRASH_REPORT = 6;
    public static final int TASK_TYPE_DOWNLOAD_MEDIA = 7;

    private static Context sContext;

    private static Connection sInstance;
    private TaskListener mListener;

    public static final int RETURN_TYPE_OUT_OF_MEMORY = -1;

    public static final String CONFLICT_RESOLUTION = ""ConflictResolutionRequired"";

    
    private static Connection launchConnectionTask(TaskListener listener, Payload data) {

        if (!isOnline()) {
            data.success = false;
            listener.onDisconnected();
            return null;
        }

        try {
            if ((sInstance != null) && (sInstance.getStatus() != AsyncTask.Status.FINISHED)) {
                sInstance.get();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        sInstance = new Connection();
        sInstance.mListener = listener;

        sInstance.execute(data);
        return sInstance;
    }


    /*
     * Runs on GUI thread
     */
    @Override
    protected void onPreExecute() {
        if (mListener != null) {
            mListener.onPreExecute();
        }
    }


    /*
     * Runs on GUI thread
     */
    @Override
    protected void onPostExecute(Payload data) {
        if (mListener != null) {
            mListener.onPostExecute(data);
        }
    }


    /*
     * Runs on GUI thread
     */
    @Override
    protected void onProgressUpdate(Object... values) {
        if (mListener != null) {
            mListener.onProgressUpdate(values);
        }
    }


    public static Connection login(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_LOGIN;
        return launchConnectionTask(listener, data);
    }


    public static Connection getSharedDecks(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_GET_SHARED_DECKS;
        return launchConnectionTask(listener, data);
    }


    public static Connection getPersonalDecks(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_GET_PERSONAL_DECKS;
        return launchConnectionTask(listener, data);
    }


    public static Connection syncAllDecks(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_SYNC_ALL_DECKS;
        return launchConnectionTask(listener, data);
    }


    public static Connection syncDeck(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_SYNC_DECK;
        return launchConnectionTask(listener, data);
    }


    public static Connection syncDeckFromPayload(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_SYNC_DECK_FROM_PAYLOAD;
        return launchConnectionTask(listener, data);
    }


    public static Connection sendFeedback(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_SEND_CRASH_REPORT;
        return launchConnectionTask(listener, data);
    }


    public static Connection downloadMissingMedia(TaskListener listener, Payload data) {
        data.taskType = TASK_TYPE_DOWNLOAD_MEDIA;
        return launchConnectionTask(listener, data);
    }

    @Override
    protected Payload doInBackground(Payload... params) {
    	if (params.length != 1)
    		throw new IllegalArgumentException();
    	return doOneInBackground(params[0]);
    }
    
    private Payload doOneInBackground(Payload data) {
        switch (data.taskType) {
            case TASK_TYPE_LOGIN:
                return doInBackgroundLogin(data);

            case TASK_TYPE_GET_SHARED_DECKS:
                return doInBackgroundGetSharedDecks(data);

            case TASK_TYPE_GET_PERSONAL_DECKS:
                return doInBackgroundGetPersonalDecks(data);

            case TASK_TYPE_SYNC_ALL_DECKS:
                return doInBackgroundSyncAllDecks(data);

            case TASK_TYPE_SYNC_DECK:
                return doInBackgroundSyncDeck(data);

            case TASK_TYPE_SYNC_DECK_FROM_PAYLOAD:
                return doInBackgroundSyncDeckFromPayload(data);

            case TASK_TYPE_SEND_CRASH_REPORT:
                return doInBackgroundSendFeedback(data);
                
            case TASK_TYPE_DOWNLOAD_MEDIA:
                return doInBackgroundDownloadMissingMedia(data);

            default:
                return null;
        }
    }


    public static void cancelGetSharedDecks() {
       	AnkiDroidProxy.resetSharedDecks();
    	sInstance.cancel(true);
    }


    private Payload doInBackgroundLogin(Payload data) {
        try {
            String username = (String) data.data[0];
            String password = (String) data.data[1];
            AnkiDroidProxy server = new AnkiDroidProxy(username, password);

            int status = server.connect(false);
            if (status != AnkiDroidProxy.LOGIN_OK) {
                data.success = false;
                data.returnType = status;
            }
        } catch (Exception e) {
            data.success = false;
            data.exception = e;
            Log.e(AnkiDroidApp.TAG, ""Error trying to log in"");
        }
        return data;
    }


    private Payload doInBackgroundGetSharedDecks(Payload data) {
        if (AnkiDroidApp.deck() != null) {
            AnkiDroidApp.deck().closeDeck();
            AnkiDroidApp.setDeck(null);
        }
        try {
            data.result = AnkiDroidProxy.getSharedDecks();
        } catch (OutOfMemoryError e) {
            data.success = false;
            data.returnType = RETURN_TYPE_OUT_OF_MEMORY;
	    	Log.e(AnkiDroidApp.TAG, ""doInBackgroundGetSharedDecks: OutOfMemoryError: "" + e);
        } catch (Exception e) {
            data.success = false;
            data.exception = e;
            Log.e(AnkiDroidApp.TAG, ""doInBackgroundGetSharedDecks - Error getting shared decks = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        }
        return data;
    }


    private Payload doInBackgroundGetPersonalDecks(Payload data) {
        Resources res = sContext.getResources();
        if (AnkiDroidApp.deck() != null) {
            AnkiDroidApp.deck().closeDeck();
            AnkiDroidApp.setDeck(null);
        }
        try {
            String username = (String) data.data[0];
            String password = (String) data.data[1];
            AnkiDroidProxy server = new AnkiDroidProxy(username, password);

            int connectResult = server.connect(false);
            if (connectResult != AnkiDroidProxy.LOGIN_OK) {
                if (connectResult == AnkiDroidProxy.LOGIN_INVALID_USER_PASS) {
                    data.result = res.getString(R.string.invalid_username_password);
                } else if (connectResult == AnkiDroidProxy.LOGIN_OLD_VERSION) {
                    data.result = String.format(res.getString(R.string.sync_log_old_version), res.getString(R.string.link_ankidroid));
                } else if (connectResult == AnkiDroidProxy.LOGIN_TOO_BUSY) {
                    data.result = res.getString(R.string.sync_too_busy);
                } else {
                    data.result = res.getString(R.string.login_generic_error);
                }
                data.success = false;
                return data;
            }

            data.result = server.getPersonalDecks();
        } catch (Exception e) {
            data.success = false;
            data.result = null;
            data.exception = e;
            Log.e(AnkiDroidApp.TAG, ""doInBackgroundGetPersonalDecks - Error getting personal decks = "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
        }
        return data;
    }


    private Payload doInBackgroundSyncAllDecks(Payload data) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundSyncAllDecks"");
        ArrayList<HashMap<String, String>> decksChangelogs = new ArrayList<HashMap<String, String>>();

        String username = (String) data.data[0];
        String password = (String) data.data[1];
        //// Log.i(AnkiDroidApp.TAG, ""username = "" + username);
        //// Log.i(AnkiDroidApp.TAG, ""password = "" + password);

        Deck currentDeck = AnkiDroidApp.deck();
        if (currentDeck != null) {
        	currentDeck.closeDeck();
        	AnkiDroidApp.setDeck(null);
        }

        ArrayList<HashMap<String, String>> decksToSync = (ArrayList<HashMap<String, String>>) data.data[2];
        for (HashMap<String, String> deckToSync : decksToSync) {
            // Log.i(AnkiDroidApp.TAG, ""Synchronizing deck"");
            String deckPath = deckToSync.get(""filepath"");
            try {
            	boolean forceDeleteJournalMode =  Deck.isWalEnabled(deckPath);
                Deck deck = Deck.openDeck(deckPath, true, forceDeleteJournalMode);

                Payload syncDeckData = new Payload(new Object[] { username, password, deck, null, false });
                syncDeckData = doInBackgroundSyncDeck(syncDeckData);
                if (deck != null) {
                	deck.closeDeck();
                }
                decksChangelogs.add((HashMap<String, String>) syncDeckData.result);
            } catch (Exception e) {
                Log.e(AnkiDroidApp.TAG, ""Exception e = "" + e.getMessage());
                // Probably, there was an error trying to open the deck, so we can not retrieve the deck name from it
                String deckName = deckPath.substring(deckPath.lastIndexOf(""/"") + 1);
                deckName = deckName.substring(0, deckName.length() - "".anki"".length());

                // Create sync changelog and add it to the list
                HashMap<String, String> deckChangelog = new HashMap<String, String>();
                deckChangelog.put(""deckName"", deckName);
                deckChangelog.put(""message"", sContext.getResources().getString(R.string.sync_log_error_message));

                decksChangelogs.add(deckChangelog);
            }
        }

        data.result = decksChangelogs;
        return data;
    }

    

    private Payload doInBackgroundSyncDeck(Payload data) {
        Resources res = sContext.getResources();
        HashMap<String, String> syncChangelog = new HashMap<String, String>();
        String username = (String) data.data[0];
        String password = (String) data.data[1];
        Deck deck = (Deck) data.data[2];
        String deckPath = deck.getDeckPath();
        String syncName = deckPath.substring(deckPath.lastIndexOf(""/"") + 1, deckPath.length() - 5);
        String conflictResolution = (String) data.data[3];
        boolean singleDeckSync = (Boolean) data.data[4];

        try {
            syncChangelog.put(""deckName"", syncName);

            if (singleDeckSync) {
            	// if syncing in study options screen, deck must be reloaded in order to set delete journal mode
            	publishProgress(syncName, res.getString(R.string.sync_set_journal_mode));
            	deck.closeDeck();
            	deck = Deck.openDeck(deckPath, true, true);        		
            	AnkiDroidApp.setDeck(deck);
            }


            AnkiDb ankiDB = AnkiDatabaseManager.getDatabase(deckPath);
            ankiDB.getDatabase().beginTransaction();

            try {
                AnkiDroidProxy server = new AnkiDroidProxy(username, password);

                publishProgress(syncName, res.getString(R.string.sync_connecting_message));
                int connectResult = server.connect(true);
                if (connectResult != AnkiDroidProxy.LOGIN_OK) {
                    if (connectResult == AnkiDroidProxy.LOGIN_INVALID_USER_PASS) {
                        syncChangelog.put(""message"", res.getString(R.string.invalid_username_password));
                    } else if (connectResult == AnkiDroidProxy.LOGIN_CLOCKS_UNSYNCED) {
                        double diff = server.getTimediff();
                        if (Math.abs(diff) >= 86400.0) {
                            // The difference if more than a day
                            syncChangelog.put(""message"", res.getString(R.string.sync_log_clocks_unsynchronized,
                                    ((long) diff), res.getString(R.string.sync_log_clocks_unsynchronized_date)));
                        } else if (Math.abs((Math.abs(diff) % 3600.0) - 1800.0) >= 1500.0) {
                            // The difference would be within limit if we adjusted the time by few hours
                            // It doesn't work for all timezones, but it covers most and it's a guess anyway
                            syncChangelog.put(""message"", res.getString(R.string.sync_log_clocks_unsynchronized,
                                    ((long) diff), res.getString(R.string.sync_log_clocks_unsynchronized_tz)));
                        } else {
                            syncChangelog.put(""message"", res.getString(R.string.sync_log_clocks_unsynchronized,
                                    ((long) diff), """"));
                        }
                    } else if (connectResult == AnkiDroidProxy.LOGIN_OLD_VERSION) {
                        syncChangelog.put(""message"", String.format(res.getString(R.string.sync_log_old_version), res.getString(R.string.link_ankidroid)));
                    } else if (connectResult == AnkiDroidProxy.LOGIN_TOO_BUSY) {
                        syncChangelog.put(""message"", res.getString(R.string.sync_too_busy));
                    } else {
                        syncChangelog.put(""message"", res.getString(R.string.login_generic_error));
                    }
                    data.result = syncChangelog;
                    data.success = false;
                    ankiDB.getDatabase().endTransaction();
                    return data;
                }

                // Exists on server?
                if (!server.hasDeck(syncName)) {
                    // Log.i(AnkiDroidApp.TAG, ""AnkiOnline does not have this deck: Creating it..."");
                    Payload result = server.createDeck(syncName);
                    if (result.success != true) {
                        syncChangelog.put(""message"", res.getString(R.string.sync_log_create_deck_failed,
                                ((String)result.result)));
                        result.result = syncChangelog;
                        ankiDB.getDatabase().endTransaction();
                        return result;
                    }
                }
                publishProgress(syncName, res.getString(R.string.sync_syncing_message, new Object[] { syncName }));
                SyncClient client = new SyncClient(deck);
                client.setServer(server);
                server.setDeckName(syncName);
                
                // Check conflicts
                double localMod = deck.getModified();
                double localSync = deck.getLastSync();
                double remoteMod = server.modified();
                double remoteSync = server.lastSync();
                if (remoteMod < 0 || remoteSync < 0) {
                    data.success = false;
                    syncChangelog.put(""message"", res.getString(R.string.sync_log_error_message));
                    data.result = syncChangelog;
                    ankiDB.getDatabase().endTransaction();
                    return data;
                }
                double minSync = Math.min(localSync, remoteSync);
                if ((localMod != remoteMod) && (minSync > 0) &&
                        (localMod > minSync) && (remoteMod > minSync)) {
                    if (conflictResolution == null) {
                        // Log.i(AnkiDroidApp.TAG, ""Syncing needs conflict resolution user input..."");
                        data.success = false;
                        data.returnType = AnkiDroidProxy.SYNC_CONFLICT_RESOLUTION;
                        syncChangelog.put(""message"", res.getString(R.string.sync_log_conflict_resolution_required));
                        data.result = syncChangelog;
                        return data;
                    }
                }
                if (client.prepareSync(server.getTimediff())) {
                    if (deck.getLastSync() <= 0) {
                        if (client.getRemoteTime() > client.getLocalTime()) {
                            conflictResolution = ""keepRemote"";
                        } else {
                            conflictResolution = ""keepLocal"";
                        }
                    }

                    // summary
                    JSONArray sums = null;
                    if (conflictResolution == null) {
                        publishProgress(syncName, res.getString(R.string.sync_summary_from_server_message));
                        sums = client.summaries();
                        if (sums == null) {
                            data.success = false;
                            syncChangelog.put(""message"", res.getString(R.string.sync_log_error_message));
                            data.result = syncChangelog;
                            ankiDB.getDatabase().endTransaction();
                            return data;
                        }
                    }

                    if ((conflictResolution != null) || client.needFullSync(sums)) {
                        // Log.i(AnkiDroidApp.TAG, ""DECK NEEDS FULL SYNC"");

                        publishProgress(syncName, res.getString(R.string.sync_preparing_full_sync_message));

                        if (conflictResolution != null) {
                            if (conflictResolution.equals(""keepLocal"")) {
                                client.setRemoteTime(0.0);
                            } else if (conflictResolution.equals(""keepRemote"")) {
                                client.setLocalTime(0.0);
                            }
                        }
                        
                        String syncFrom = client.prepareFullSync();

                        HashMap<String, String> result = new HashMap<String, String>();
                        if (""fromLocal"".equalsIgnoreCase(syncFrom)) {
                            publishProgress(syncName, res.getString(R.string.sync_uploading_message));
                            result = SyncClient.fullSyncFromLocal(password, username, deck, syncName);
                            if (result.containsKey(""code"") && result.get(""code"").equals(""200"")) {
                                syncChangelog.put(""message"", res.getString(R.string.sync_log_uploading_message));
                            }
                            ankiDB.getDatabase().setTransactionSuccessful();
                            ankiDB.getDatabase().endTransaction();
                        } else if (""fromServer"".equalsIgnoreCase(syncFrom)) {
                            publishProgress(syncName, res.getString(R.string.sync_downloading_message));
                            ankiDB.getDatabase().endTransaction();
                            if (deck != null) {
                                deck.closeDeck();
                            }
                            result = SyncClient.fullSyncFromServer(password, username, syncName, deckPath);
                            if (result.containsKey(""code"") && result.get(""code"").equals(""200"")) {
                                syncChangelog.put(""message"", res.getString(R.string.sync_log_downloading_message));
                            }
                            deck = Deck.openDeck(deckPath);
                        	AnkiDroidApp.setDeck(deck);
                        }

                        publishProgress(syncName, res.getString(R.string.sync_complete_message));
                        // Pass error (if any) to UI
                        if (!result.containsKey(""code"") || !result.get(""code"").equals(""200"")) {
                            if (result.containsKey(""message"")) {
                            syncChangelog.put(""message"", String.format(
                                    res.getString(R.string.sync_log_error_specific),
                                    result.get(""code""), result.get(""message"")));
                            } else {
                                syncChangelog.put(""message"", res.getString(R.string.sync_log_error_message));
                            }
                        }
                    } else {
                        // Log.i(AnkiDroidApp.TAG, ""DECK DOES NOT NEED FULL SYNC"");

                        publishProgress(syncName, res.getString(R.string.sync_determining_differences_message));

                        JSONObject payload = client.genPayload(sums);
                        int factsAddedOnLocal = payload.getJSONArray(""added-cards"").length();
                        if (factsAddedOnLocal > 0) {
                            syncChangelog.put(""message"", res.getQuantityString(R.plurals.sync_log_facts_to_server_message,
                                    factsAddedOnLocal, factsAddedOnLocal));
                        }

                        publishProgress(syncName, res.getString(R.string.sync_transferring_payload_message));
                        JSONObject payloadReply = client.getServer().applyPayload(payload);
                        if (payloadReply == null) {
                            data.success = false;
                            syncChangelog.put(""message"", res.getString(R.string.sync_log_error_message));
                            data.result = syncChangelog;
                            ankiDB.getDatabase().endTransaction();
                            return data;
                        }
                        int factsAddedOnServer = payloadReply.getJSONArray(""added-cards"").length();
                        if (factsAddedOnLocal == 0 && factsAddedOnServer == 0) {
                            syncChangelog.put(""message"", res.getString(R.string.sync_log_zero_facts));
                        } else if (factsAddedOnServer > 0) {
                            syncChangelog.put(""message"", res.getQuantityString(R.plurals.sync_log_facts_from_server_message,
                                    factsAddedOnServer, factsAddedOnServer));
                        }

                        publishProgress(syncName, res.getString(R.string.sync_applying_reply_message));
                        client.applyPayloadReply(payloadReply);
                        deck.initDeckvarsCache();
                        
                        Reviewer.setupMedia(deck); // FIXME: setupMedia should be part of Deck?
                        SharedPreferences preferences = PrefSettings.getSharedPrefs(sContext);
                        if (preferences.getBoolean(""syncFetchMedia"", true)) {
                            doInBackgroundDownloadMissingMedia(new Payload(new Object[] {deck}));
                        }

                        if (!client.getServer().finish()) {
                            data.success = false;
                            syncChangelog.put(""message"", res.getString(R.string.sync_log_finish_error));
                            data.result = syncChangelog;
                            ankiDB.getDatabase().endTransaction();
                            return data;
                        }
                        deck.reset();

                        deck.setLastLoaded(deck.getModified());
                        deck.commitToDB();
                        // Log.i(AnkiDroidApp.TAG, String.format(Utils.ENGLISH_LOCALE, ""Modified: %f, LastSync: %f, LastLoaded: %f"", deck.getModified(), deck.getLastSync(), deck.getLastLoaded()));

                        ankiDB.getDatabase().setTransactionSuccessful();
                        publishProgress(syncName, res.getString(R.string.sync_complete_message));
                    }
                } else {
                    // Log.i(AnkiDroidApp.TAG, ""NO CHANGES."");
                    publishProgress(syncName, res.getString(R.string.sync_no_changes_message));
                    syncChangelog.put(""message"", res.getString(R.string.sync_log_no_changes_message));
                }
            } finally {
                if (ankiDB.getDatabase() != null && ankiDB.getDatabase().isOpen() && ankiDB.getDatabase().inTransaction()) {
                    ankiDB.getDatabase().endTransaction();
                }
            }
        } catch (OutOfMemoryError e) {
            Log.e(AnkiDroidApp.TAG, ""doInBackgroundSyncDeck - JSONException: "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            syncChangelog.put(""message"", res.getString(R.string.sync_log_error_message));
            data.success = false;
        } catch (JSONException e) {
            Log.e(AnkiDroidApp.TAG, ""doInBackgroundSyncDeck - JSONException: "" + e.getMessage());
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            syncChangelog.put(""message"", res.getString(R.string.sync_log_error_message));
            data.success = false;
            data.exception = e;
		} catch (SQLException e) {
            AnkiDroidApp.saveExceptionReportFile(e, ""doInBackgroundSyncDeck"");
			Log.w(AnkiDroidApp.TAG, ""doInBackgroundSyncDeck - Error on "" + deckPath + "": "" + e);
            Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            data.returnType = AnkiDroidProxy.DB_ERROR;
            syncChangelog.put(""message"", res.getString(R.string.sync_log_db_error));
            data.success = false;
            data.exception = e;
        }

        data.result = syncChangelog;
        return data;
    }


    private Payload doInBackgroundSyncDeckFromPayload(Payload data) {
        // Log.i(AnkiDroidApp.TAG, ""SyncDeckFromPayload"");
        Deck deck = (Deck) data.data[0];
        SyncClient client = new SyncClient(deck);
        BufferedReader bufPython;
        try {
            bufPython = new BufferedReader(new FileReader(""/sdcard/jsonObjectPython.txt""));
            JSONObject payloadReply = new JSONObject(bufPython.readLine());
            client.applyPayloadReply(payloadReply);
            deck.setLastLoaded(deck.getModified());
            deck.commitToDB();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (JSONException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        // Log.i(AnkiDroidApp.TAG, ""Synchronization from payload finished!"");
        return data;
    }


    private Payload doInBackgroundSendFeedback(Payload data) {
        // Log.i(AnkiDroidApp.TAG, ""doInBackgroundSendFeedback"");
        String feedbackUrl = (String) data.data[0];
        String errorUrl = (String) data.data[1];
        String feedback  = (String) data.data[2];
        ArrayList<HashMap<String, String>> errors  = (ArrayList<HashMap<String, String>>) data.data[3];
        String groupId  = ((Long) data.data[4]).toString();
        Application app  = (Application) data.data[5];
        boolean deleteAfterSending = (Boolean) data.data[6];

        String postType = null;
        if (feedback.length() > 0) {
            if (errors.size() > 0) {
                postType = Feedback.TYPE_ERROR_FEEDBACK;
            } else {
                postType = Feedback.TYPE_FEEDBACK;
            }
            publishProgress(postType, 0, Feedback.STATE_UPLOADING);
            Payload reply = Feedback.postFeedback(feedbackUrl, postType, feedback, groupId, 0, null);
            if (reply.success) {
                publishProgress(postType, 0, Feedback.STATE_SUCCESSFUL, reply.returnType, reply.result);
            } else {
                publishProgress(postType, 0, Feedback.STATE_FAILED, reply.returnType, reply.result);
            }
        }
        
        for (int i = 0; i < errors.size(); i++) {
            HashMap<String, String> error = errors.get(i);
            if (error.containsKey(""state"") && error.get(""state"").equals(Feedback.STATE_WAITING)) {
                postType = Feedback.TYPE_STACKTRACE; 
                publishProgress(postType, i, Feedback.STATE_UPLOADING);
                Payload reply = Feedback.postFeedback(errorUrl, postType, error.get(""filename""), groupId, i, app);
                if (reply.success) {
                    publishProgress(postType, i, Feedback.STATE_SUCCESSFUL, reply.returnType, reply.result);
                } else {
                    publishProgress(postType, i, Feedback.STATE_FAILED, reply.returnType, reply.result);
                }
                if (deleteAfterSending && (reply.success || reply.returnType == 200)) {
                	File file = new File(app.getFilesDir() + ""/"" + error.get(""filename""));
                	file.delete();
                }
            }
        }

        app = null;

        return data;
    }
    
    /**
     * Downloads any missing media files according to the mediaURL deckvar.
     * @param data
     * @return The return type contains data.resultType and an array of Integer
     * in data.data. data.data[0] is the number of total missing media, data.data[1] is the number
     * of downloaded ones.
     */
    private Payload doInBackgroundDownloadMissingMedia(Payload data) {
        // Log.i(AnkiDroidApp.TAG, ""DownloadMissingMedia"");
        HashMap<String, String> missingPaths = new HashMap<String, String>();
        HashMap<String, String> missingSums = new HashMap<String, String>();
        
        Deck deck = (Deck) data.data[0];
        data.result = deck; // pass it to the return object so we close the deck in the deck picker
        String syncName = deck.getDeckName();
                
        data.success = false;
        data.data = new Object[] {0, 0, 0};
        if (!deck.hasKey(""mediaURL"")) {
            data.success = true;
            return data;
        }
        String urlbase = deck.getVar(""mediaURL"");
        if (urlbase.equals("""")) {
            data.success = true;
            return data;
        }

        String mdir = deck.mediaDir(true);
        int totalMissing = 0;
        int missing = 0;
        int grabbed = 0;

        Cursor cursor = null;
        try {
            cursor = deck.getDB().getDatabase().rawQuery(""SELECT filename, originalPath FROM media"", null);
            String path = null;
            String f = null;
            while (cursor.moveToNext()) {
                f = cursor.getString(0);
                path = mdir + ""/"" + f;
                File file = new File(path);
                if (!file.exists()) {
                    missingPaths.put(f, path);
                    missingSums.put(f, cursor.getString(1));
                    // Log.i(AnkiDroidApp.TAG, ""Missing file: "" + f);
                }
            }
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }

        totalMissing = missingPaths.size();
        data.data[0] = new Integer(totalMissing);
        if (totalMissing == 0) {
            data.success = true;
            return data;
        }
        publishProgress(Boolean.FALSE, new Integer(totalMissing), new Integer(0), syncName);

        URL url = null;
        HttpURLConnection connection = null;
        String path = null;
        String sum = null;
        int readbytes = 0;
        byte[] buf = new byte[4096];
        for (String file : missingPaths.keySet()) {
            
            try {
                android.net.Uri uri = android.net.Uri.parse(urlbase + Uri.encode(file));
                url = new URI(uri.toString()).toURL();
                connection = (HttpURLConnection) url.openConnection();
                connection.connect();
                if (connection.getResponseCode() == 200) {
                    path = missingPaths.get(file);
                    InputStream is = connection.getInputStream();
                    BufferedInputStream bis = new BufferedInputStream(is, 4096);
                    FileOutputStream fos = new FileOutputStream(path);
                    while ((readbytes = bis.read(buf, 0, 4096)) != -1) {
                        fos.write(buf, 0, readbytes);
                        // Log.i(AnkiDroidApp.TAG, ""Downloaded "" + readbytes + "" file: "" + path);
                    }
                    fos.close();
    
                    // Verify with checksum
                    sum = missingSums.get(file);
                    if (sum.equals("""") || sum.equals(Utils.fileChecksum(path))) {
                        grabbed++;
                    } else {
                        // Download corrupted, delete file
                        // Log.i(AnkiDroidApp.TAG, ""Downloaded media file "" + path + "" failed checksum."");
                        File f = new File(path);
                        f.delete();
                        missing++;
                    }
                } else {
                    Log.e(AnkiDroidApp.TAG, ""Connection error ("" + connection.getResponseCode() +
                            "") while retrieving media file "" + urlbase + file);
                    Log.e(AnkiDroidApp.TAG, ""Connection message: "" + connection.getResponseMessage());
                    if (missingSums.get(file).equals("""")) {
                        // Ignore and keep going
                        missing++;
                    } else {
                        data.success = false;
                        data.data = new Object[] {file};
                        return data;
                    }
                }
                connection.disconnect();
            } catch (URISyntaxException e) {
                Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
            } catch (MalformedURLException e) {
                Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
                Log.e(AnkiDroidApp.TAG, ""MalformedURLException while download media file "" + path);
                if (missingSums.get(file).equals("""")) {
                    // Ignore and keep going
                    missing++;
                } else {
                    data.success = false;
                    data.data = new Object[] {file};
                    return data;
                }
            } catch (IOException e) {
                Log.e(AnkiDroidApp.TAG, Log.getStackTraceString(e));
                Log.e(AnkiDroidApp.TAG, ""IOException while download media file "" + path);
                if (missingSums.get(file).equals("""")) {
                    // Ignore and keep going
                    missing++;
                } else {
                    data.success = false;
                    data.data = new Object[] {file};
                    return data;
                }
            } finally {
                if (connection != null) {
                    connection.disconnect();
                }
            }
            publishProgress(Boolean.TRUE, new Integer(totalMissing), new Integer(grabbed + missing), syncName);
        }

        data.data[1] = new Integer(grabbed);
        data.data[2] = new Integer(missing);
        data.success = true;
        return data;
    }


    public static boolean isOnline() {
        ConnectivityManager cm = (ConnectivityManager) sContext.getSystemService(Context.CONNECTIVITY_SERVICE);

        if (cm.getActiveNetworkInfo() != null) {
            return cm.getActiveNetworkInfo().isConnectedOrConnecting();
        } else {
            return false;
        }
    }


    public static void setContext(Context applicationContext) {
        sContext = applicationContext;
    }

    public static interface TaskListener {
        public void onPreExecute();


        public void onProgressUpdate(Object... values);


        public void onPostExecute(Payload data);


        public void onDisconnected();
    }

    public static class Payload {
        public int taskType;
        public Object[] data;
        public Object result;
        public boolean success;
        public int returnType;
        public Exception exception;

        public Payload() {
            data = null;
            success = true;
        }

        public Payload(Object[] data) {
            this.data = data;
            success = true;
        }


        public Payload(int taskType, Object[] data) {
            this.taskType = taskType;
            this.data = data;
            success = true;
        }
    }
}
",True,51,67,1,4,4,33
65,com.ichi2.preferences.CustomDialogPreference.java,"/***************************************************************************************
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com>                         *
 *                                                                                      *
 * This program is free software; you can redistribute it and/or modify it under        *
 * the terms of the GNU General Public License as published by the Free Software        *
 * Foundation; either version 3 of the License, or (at your option) any later           *
 * version.                                                                             *
 *                                                                                      *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY      *
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A      *
 * PARTICULAR PURPOSE. See the GNU General Public License for more details.             *
 *                                                                                      *
 * You should have received a copy of the GNU General Public License along with         *
 * this program.  If not, see <http://www.gnu.org/licenses/>.                           *
 ****************************************************************************************/

package com.ichi2.preferences;

import android.content.Context;
import android.content.DialogInterface;
import android.content.SharedPreferences.Editor;
import android.preference.DialogPreference;
import android.util.AttributeSet;
import android.widget.Toast;

import com.ichi2.anki.AnkiDroidApp;
import com.ichi2.anki.MetaDB;
import com.ichi2.anki.R;
import com.tomgibara.android.veecheck.util.PrefSettings;

public class CustomDialogPreference extends DialogPreference implements DialogInterface.OnClickListener {
    private Context mContext;

    public CustomDialogPreference(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
    }


    public void onClick(DialogInterface dialog, int which) {
        if (which == DialogInterface.BUTTON_POSITIVE) {
        	if (this.getTitle().equals(mContext.getResources().getString(R.string.reset_dialogs))) {
        		Editor editor = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit();
        		editor.putBoolean(""dontShowLowMemory"", false);
        		editor.commit();
        	} else if (this.getTitle().equals(mContext.getResources().getString(R.string.reset_messages))) {
            		Editor editor = PrefSettings.getSharedPrefs(AnkiDroidApp.getInstance().getBaseContext()).edit();
            		editor.putInt(""lastMessageNum"", 0);
            		editor.putBoolean(""showBroadcastMessageToday"", true);
            		editor.commit();
        	} else if (this.getTitle().equals(mContext.getResources().getString(R.string.reset_all))) {
            	if (MetaDB.resetDB(mContext)) {
                    Toast successReport = 
                        Toast.makeText(this.getContext() , 
                                AnkiDroidApp.getAppResources().getString(R.string.reset_confirmation), Toast.LENGTH_SHORT);
                    successReport.show();
                }	
        	} else {
            	if (MetaDB.resetLanguages(mContext)) {
                    Toast successReport = 
                        Toast.makeText(this.getContext() , 
                                AnkiDroidApp.getAppResources().getString(R.string.reset_confirmation), Toast.LENGTH_SHORT);
                    successReport.show();
                }	
        	}
        }
    }

} ",False,80,64,0,0,5,27
66,com.ichi2.anim.Animation3D.java,"/*
 * Copyright (C) 2007 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 * Copyright (c) 2011 Norbert Nagold <norbert.nagold@gmail.com> 
 */

package com.ichi2.anim;

import com.ichi2.anki.Reviewer;

import android.view.animation.Animation;
import android.view.animation.Transformation;
import android.graphics.Camera;
import android.graphics.Matrix;

public class Animation3D extends Animation {
	
	public static final int ANIMATION_TURN = 0;
	public static final int ANIMATION_EXCHANGE_CARD = 1;
	public static final int ANIMATION_SLIDE_IN_CARD = 2;
	public static final int ANIMATION_SLIDE_OUT_CARD = 3;

    private final float mValueX;
    private final float mValueY;
    private final float mDepthZ;
    private Camera mCamera;
    private Reviewer mReviewer;
    boolean mDirection;
    boolean mFlipped = false;
    int mAction;
    boolean mRealTurn;

    public Animation3D(float valueX, float valueY, float depthZ, int action, boolean direction, boolean realturn, Reviewer reviewer) {
        mValueX = valueX;
        mValueY = valueY;
        mDepthZ = depthZ;
        mReviewer = reviewer;
        mDirection = direction;
        mAction = action;
        mRealTurn = realturn;
    }

    @Override
    public void initialize(int width, int height, int parentWidth, int parentHeight) {
        super.initialize(width, height, parentWidth, parentHeight);
        mCamera = new Camera();
    }


    @Override
    protected void applyTransformation(float interpolatedTime, Transformation t) {
        float centerX = 0;
        float centerY = 0;
        final Camera camera = mCamera;
        final Matrix matrix = t.getMatrix();
        camera.save();
        float time;
        switch (mAction) {
        case ANIMATION_TURN:
        	if (mRealTurn) {
                time = interpolatedTime >= 0.5f ? (interpolatedTime - 1.0f) : interpolatedTime;        		
        	} else {
                time = interpolatedTime >= 0.5f ? -(interpolatedTime - 1.0f) : interpolatedTime;
        	}
        	float degrees = time * (mDirection ? -180 : 180);
            if (interpolatedTime >= 0.5f && !mFlipped) {
                mReviewer.fillFlashcard(false);
                mFlipped = true;
            }
            camera.translate(0.0f, 0.0f, mDepthZ * Math.abs(degrees));
            if (mDirection) {
                centerX = mValueX / 2;
                centerY = mValueY / (mRealTurn ? 2 : 3);
            	camera.rotateX(degrees);
            } else {
                centerX = mValueX / (mRealTurn ? 2 : 3);
                centerY = mValueY / 2;
            	camera.rotateY(degrees);
            }
            break;
        case ANIMATION_EXCHANGE_CARD:
            if (mDirection) {
            	time = interpolatedTime >= 0.5f ? -(interpolatedTime - 1.0f) : -interpolatedTime;
            } else {
            	time = interpolatedTime >= 0.5f ? (interpolatedTime - 1.0f) : interpolatedTime;
            }
            if (interpolatedTime >= 0.5f && !mFlipped) {
                mReviewer.fillFlashcard(false);
                mFlipped = true;
            }
            camera.translate(mValueX * time * 2, 0.0f, mDepthZ * Math.abs(time * 180));
            centerX = mValueX / 2;
            centerY = mValueY / 2;
            break;
        case ANIMATION_SLIDE_IN_CARD:
            if (mDirection) {
            	time = 1 - interpolatedTime;
            } else {
            	time = -1 + interpolatedTime;
            }
            if (interpolatedTime >= 0.0f && !mFlipped) {
                mReviewer.showFlashcard(true);
                mReviewer.fillFlashcard(false);
                mFlipped = true;
            }
            camera.translate(mValueX * time * 2, 0.0f, mDepthZ * Math.abs(time * 180));
            centerX = mValueX / 2;
            centerY = mValueY / 2;
            break;        	
        case ANIMATION_SLIDE_OUT_CARD:
            if (mDirection) {
            	time = -interpolatedTime;
            } else {
            	time = interpolatedTime;
            }
            if (interpolatedTime == 1.0f && !mFlipped) {
                mReviewer.showFlashcard(false);
                mFlipped = true;
            }
            camera.translate(mValueX * time * 2, 0.0f, mDepthZ * Math.abs(time * 180));
            centerX = mValueX / 2;
            centerY = mValueY / 2;
            break;
        }

        camera.getMatrix(matrix);
        camera.restore();

        matrix.preTranslate(-centerX, -centerY);
        matrix.postTranslate(centerX, centerY);
    }
}
",False,6,63,0,0,4,32
67,com.ichi2.anim.ActivityTransitionAnimation.java,"package com.ichi2.anim;

import com.ichi2.anki.R;
import android.app.Activity;

public class ActivityTransitionAnimation {
	public static int LEFT = 0;
	public static int RIGHT = 1;
	public static int FADE = 2;
	public static int UP = 3;
    public static int DOWN = 4;
    public static int NONE = 5;
	
	public static void slide(Activity activity, int direction) {
		if (direction == LEFT) {
			activity.overridePendingTransition(R.anim.slide_left_in, R.anim.slide_left_out);
		} else if (direction == RIGHT) {
			activity.overridePendingTransition(R.anim.slide_right_in, R.anim.slide_right_out);
		} else if (direction == FADE) {
			activity.overridePendingTransition(R.anim.fade_out, R.anim.fade_in);
		} else if (direction == UP) {
			activity.overridePendingTransition(R.anim.slide_up_in, R.anim.slide_up_out);
		} else if (direction == DOWN) {
			activity.overridePendingTransition(R.anim.slide_down_in, R.anim.slide_down_out);
		} else if (direction == NONE){
		    activity.overridePendingTransition(R.anim.none, R.anim.none);
		}
	}
}",True,41,56,4,17,0,0
68,com.ichi2.anim.ViewAnimation.java,"package com.ichi2.anim;

import android.view.animation.AccelerateInterpolator;
import android.view.animation.AlphaAnimation;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.TranslateAnimation;

public class ViewAnimation {

	public static final int SLIDE_IN_FROM_RIGHT = 0;
	public static final int SLIDE_OUT_TO_RIGHT = 1;
	public static final int SLIDE_IN_FROM_LEFT = 2;
	public static final int SLIDE_OUT_TO_LEFT = 3;
	public static final int SLIDE_IN_FROM_BOTTOM = 4;

	public static final int FADE_IN = 0;
	public static final int FADE_OUT = 1;

	
	public static Animation slide(int type, int duration, int offset) {
        Animation animation;
        switch (type) {
        case SLIDE_IN_FROM_RIGHT:
            animation = new TranslateAnimation(
                    Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                );
            animation.setInterpolator(new DecelerateInterpolator());
        	break;
        case SLIDE_OUT_TO_RIGHT:
            animation = new TranslateAnimation(
                    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, +1.0f,
                    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                );
            animation.setInterpolator(new AccelerateInterpolator());
        	break;
        case SLIDE_IN_FROM_LEFT:
            animation = new TranslateAnimation(
                    Animation.RELATIVE_TO_SELF, -1.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                );
            animation.setInterpolator(new DecelerateInterpolator());
        	break;
        case SLIDE_OUT_TO_LEFT:
            animation = new TranslateAnimation(
                    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, -1.0f,
                    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f
                );
            animation.setInterpolator(new AccelerateInterpolator());
        	break;
        case SLIDE_IN_FROM_BOTTOM:
            animation = new TranslateAnimation(
                    Animation.RELATIVE_TO_SELF, 0.0f, Animation.RELATIVE_TO_SELF, 0.0f,
                    Animation.RELATIVE_TO_SELF, +1.0f, Animation.RELATIVE_TO_SELF, 0.0f
                );
            animation.setInterpolator(new DecelerateInterpolator());
        	break;
    	default:
    		animation = null;
        }
        animation.setDuration(duration);
        animation.setStartOffset(offset);
        return animation;
	}


	public static Animation fade(int type, int duration, int offset) {
		float startValue = type;
        Animation animation = new AlphaAnimation(startValue, 1.0f - startValue);
        animation.setDuration(duration);
        if (type == FADE_IN) {
        	animation.setZAdjustment(Animation.ZORDER_TOP);
        }
        animation.setStartOffset(offset);
        return animation;
	}
}
",False,4,56,4,18,0,0
