,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.geometerplus.fbreader.Paths.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader;

import org.geometerplus.zlibrary.core.options.ZLStringOption;

import android.os.Environment;

public abstract class Paths {
	public static final ZLStringOption BooksDirectoryOption = new ZLStringOption(""Files"", ""BooksDirectory"", Environment.getExternalStorageDirectory() + ""/Books"");

	public static String cacheDirectory() {
		return BooksDirectoryOption.getValue() + ""/.FBReader"";
	}

	public static String networkCacheDirectory() {
		return cacheDirectory() + ""/cache"";
	}
}
",False,168,7,67,3,2,9,1,L3
1,org.geometerplus.fbreader.constants.XMLNamespace.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.constants;

public interface XMLNamespace {
	String DublinCorePrefix = ""http://purl.org/dc/elements"";
	String DublinCoreLegacyPrefix = ""http://purl.org/metadata/dublin_core"";
	String XLink = ""http://www.w3.org/1999/xlink"";
	String OpenPackagingFormat = ""http://www.idpf.org/2007/opf"";

	String Atom = ""http://www.w3.org/2005/Atom"";
	String Opds = ""http://opds-spec.org/2010/catalog"";
	String DublinCoreTerms = ""http://purl.org/dc/terms/"";
	String OpenSearch = ""http://a9.com/-/spec/opensearch/1.1/"";
	String CalibreMetadata = ""http://calibre.kovidgoyal.net/2009/metadata"";

	String FBReaderCatalogMetadata = ""http://data.fbreader.org/catalog/metadata/"";
}
",False,160,13,45,0,0,7,0,L3
2,org.geometerplus.fbreader.formats.FormatPlugin.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public abstract class FormatPlugin {
	public abstract boolean acceptsFile(ZLFile file);
	public abstract	boolean readMetaInfo(Book book);
	public abstract boolean readModel(BookModel model);
	public abstract ZLImage readCover(Book book);

	/*
	public static void detectEncodingAndLanguage(Book book, InputStream stream) throws IOException {	
		String language = book.getLanguage();
		String encoding = book.getEncoding();
		if (encoding.length() == 0 || language.length() == 0) {
			PluginCollection collection = PluginCollection.instance();
			if (language.length() == 0) {
				language = collection.DefaultLanguageOption.getValue();
			}
			if (encoding.length() == 0) {
				encoding = collection.DefaultEncodingOption.getValue();
			}
			if (collection.LanguageAutoDetectOption.getValue() && stream != null) {
				int BUFSIZE = 65536;
				byte[] buffer = new byte[BUFSIZE];
				int size = stream.read(buffer, 0, BUFSIZE);
				stream.close();
				ZLLanguageDetector.LanguageInfo info =
					new ZLLanguageDetector().findInfo(buffer, 0, size);
				buffer = null;
				if (info != null) {
					language = info.Language;
					encoding = info.Encoding;
					if ((encoding == ""US-ASCII"") || (encoding == ""ISO-8859-1"")) {
						encoding = ""windows-1252"";
					}
				}
			}
			book.setEncoding(encoding);
			book.setLanguage(language);
		}
	}
	//Last working version
	public static void detectEncodingAndLanguage(Book book, InputStream stream) {	
		String encoding = book.getEncoding();
		if (encoding.length() == 0) {
			encoding = EncodingDetector.detect(stream, PluginCollection.instance().DefaultLanguageOption.getValue());
			if (encoding == ""unknown"") {
				encoding = ""windows-1252"";
			}
			book.setEncoding(encoding);
		}

		if (book.getLanguage() == """") {
			if ((encoding.equals(""US-ASCII"")) ||
					(encoding.equals(""ISO-8859-1""))) {
				book.setLanguage(""en"");
			} else if ((book.getEncoding().equals(""KOI8-R"")) ||
					(encoding.equals(""windows-1251"")) ||
					(encoding.equals(""ISO-8859-5"")) ||
					(encoding.equals(""IBM866""))) {
				book.setLanguage(""ru"");
			} /*else if (
	                (PluginCollection.instance().DefaultLanguageOption.getValue() == EncodingDetector.Language.CZECH) &&
					((encoding == ""windows-1250"") ||
					 (encoding == ""ISO-8859-2"") ||
					 (encoding == ""IBM852""))) {
				book.setLanguage(""cs"");
			}*/
		/*}

	}*/
}
",False,134,1,1,7,32,7,4,L3
3,org.geometerplus.fbreader.formats.PluginCollection.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats;

import java.util.*;

import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.formats.fb2.FB2Plugin;
import org.geometerplus.fbreader.formats.oeb.OEBPlugin;
import org.geometerplus.fbreader.formats.pdb.MobipocketPlugin;

public class PluginCollection {
	private static PluginCollection ourInstance;

	private final ArrayList<FormatPlugin> myPlugins = new ArrayList<FormatPlugin>();
	public ZLStringOption DefaultLanguageOption;
	public ZLStringOption DefaultEncodingOption;
	public ZLBooleanOption LanguageAutoDetectOption;
	
	public static PluginCollection instance() {
		if (ourInstance == null) {
			ourInstance = new PluginCollection();
			ourInstance.myPlugins.add(new FB2Plugin());
			//ourInstance.myPlugins.add(new PluckerPlugin());
			//ourInstance->myPlugins.push_back(new DocBookPlugin());
			//ourInstance.myPlugins.add(new HtmlPlugin());
			//ourInstance.myPlugins.add(new TxtPlugin());
			//ourInstance.myPlugins.add(new PalmDocPlugin());
			ourInstance.myPlugins.add(new MobipocketPlugin());
			//ourInstance.myPlugins.add(new ZTXTPlugin());
			//ourInstance.myPlugins.add(new TcrPlugin());
			//ourInstance.myPlugins.add(new CHMPlugin());
			ourInstance.myPlugins.add(new OEBPlugin());
			//ourInstance.myPlugins.add(new RtfPlugin());
			//ourInstance.myPlugins.add(new OpenReaderPlugin());
		}
		return ourInstance;
	}
	
	public static void deleteInstance() {
		if (ourInstance != null) {
			ourInstance = null;
		}
	}

	private PluginCollection() {
		LanguageAutoDetectOption = new ZLBooleanOption(""Format"", ""AutoDetect"", true);
		DefaultLanguageOption = new ZLStringOption(""Format"", ""DefaultLanguage"", ""en""); 
		DefaultEncodingOption = new ZLStringOption(""Format"", ""DefaultEncoding"", ""windows-1252"");
	}
		
	public FormatPlugin getPlugin(ZLFile file) {
		for (FormatPlugin plugin : myPlugins) {
			if (plugin.acceptsFile(file)) {
				return plugin;
			}
		}
		return null;
	}
}
",False,133,0,0,8,44,2,7,L3
4,org.geometerplus.fbreader.formats.html.HtmlMetaInfoReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;

public class HtmlMetaInfoReader extends ZLXMLReaderAdapter {
	private final Book myBook;

	private boolean myReadTitle;

	public HtmlMetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle("""");
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}

	public boolean readMetaInfo() {
		myReadTitle = false;
		return readDocument(myBook.File);
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (HtmlTag.getTagByName(tagName)) {
			case HtmlTag.TITLE:
				myReadTitle = true;
				break;
			default:
				break;
		}
		return false;
	}

	public boolean endElementHandler(String tag) {
		switch (HtmlTag.getTagByName(tag)) {
			case HtmlTag.TITLE:
				myReadTitle = false;
				break;
			default:
				break;
		}
		return false;
	}

	public void characterDataHandler(char[] ch, int start, int length) {
		// TODO + length -- remove
		final String text = new String(ch).substring(start, start + length);
		if (myReadTitle) {
			myBook.setTitle(myBook.getTitle() + text);
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file);
	}

}
",False,135,1,1,7,30,1,6,L8
5,org.geometerplus.fbreader.formats.html.HtmlPlugin.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.io.IOException;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class HtmlPlugin extends FormatPlugin {
	
	@Override
	public boolean acceptsFile(ZLFile file) {
		return ""htm"".equals(file.getExtension()) 
			|| ""html"".equals(file.getExtension());
	}

	@Override
	public boolean readMetaInfo(Book book) {
		return new HtmlMetaInfoReader(book).readMetaInfo();
	}

	@Override
	public boolean readModel(BookModel model) {
		try {
			return new HtmlReader(model).readBook();
		} catch (IOException e) {
			return false;
		}
	}

	@Override
	public ZLImage readCover(Book book) {
		return null;
	}
}
",False,135,0,0,7,36,0,7,L8
6,org.geometerplus.fbreader.formats.html.HtmlTag.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.util.*;

public final class HtmlTag {
	public static final byte UNKNOWN = 0;
	public static final byte HTML = 1;
	public static final byte HEAD = 2;
	public static final byte BODY = 3;
	public static final byte TITLE = 4;
	public static final byte P = 5;
	public static final byte H1 = 6;
	public static final byte H2 = 7;
	public static final byte H3 = 8;
	public static final byte H4 = 9;
	public static final byte H5 = 10;
	public static final byte H6 = 11;
	public static final byte A = 12;
	public static final byte B = 13;
	public static final byte I = 14;
	public static final byte BR = 15;
	public static final byte STRONG = 16;
	public static final byte IMG = 17;
	public static final byte SCRIPT = 18;
	public static final byte OL = 19;
	public static final byte UL = 20;
	public static final byte LI = 21;
	public static final byte SELECT = 22;
	public static final byte DIV = 23;
	public static final byte TR = 24;
	public static final byte STYLE = 25;
	
	public static final byte S = 26;
	public static final byte SUB = 27;
	public static final byte SUP = 28;
	public static final byte PRE = 29;
	public static final byte CODE = 30;
	public static final byte EM = 31;
	public static final byte DFN = 32;
	public static final byte CITE = 33;

	public static final byte HR = 34;
	
	// mobipocket specific tags
	public static final byte REFERENCE = 35;
	public static final byte GUIDE = 36;

	public static final byte TAG_NUMBER = 37;
	
	private static final HashMap<String,Byte> ourTagByName = new HashMap<String,Byte>(256, 0.2f);
	private static final Byte ourUnknownTag;

	static {
		ourTagByName.put(""unknown"", UNKNOWN);
		ourUnknownTag = (Byte)ourTagByName.get(""unknown"");
		ourTagByName.put(""html"", HTML);
		ourTagByName.put(""head"", HEAD);
		ourTagByName.put(""body"", BODY);
		ourTagByName.put(""title"", TITLE);
		ourTagByName.put(""p"", P);
		ourTagByName.put(""h1"", H1);
		ourTagByName.put(""h2"", H2);
		ourTagByName.put(""h3"", H3);
		ourTagByName.put(""h4"", H4);
		ourTagByName.put(""h5"", H5);
		ourTagByName.put(""h6"", H6);
		ourTagByName.put(""a"", A);
		ourTagByName.put(""b"", B);
		ourTagByName.put(""i"", I);
		ourTagByName.put(""br"", BR);
		ourTagByName.put(""strong"", STRONG);
		ourTagByName.put(""img"", IMG);
		ourTagByName.put(""script"", SCRIPT);
		ourTagByName.put(""ol"", OL);
		ourTagByName.put(""ul"", UL);
		ourTagByName.put(""li"", LI);
		ourTagByName.put(""select"", SELECT);
		ourTagByName.put(""tr"", TR);
		ourTagByName.put(""style"", STYLE);
		ourTagByName.put(""s"", S);
		ourTagByName.put(""sub"", SUB);
		ourTagByName.put(""sup"", SUP);
		ourTagByName.put(""pre"", PRE);
		ourTagByName.put(""code"", CODE);
		ourTagByName.put(""em"", EM);
		ourTagByName.put(""def"", DFN);
		ourTagByName.put(""cite"", CITE);
		ourTagByName.put(""hr"", HR);
		ourTagByName.put(""guide"", GUIDE);
		ourTagByName.put(""reference"", REFERENCE);
	}

	public static byte getTagByName(String name) {
		final HashMap<String,Byte> tagByName = ourTagByName;
		Byte num = tagByName.get(name);
		if (num == null) {
			final String lowerCaseName = name.toLowerCase().intern();
			num = (Byte)tagByName.get(lowerCaseName);
			if (num == null) {
				num = ourUnknownTag;
				tagByName.put(lowerCaseName, num);
			}
			tagByName.put(name, num);
		}
		return num.byteValue();
	}
}
",False,157,13,42,0,0,3,0,L3
7,org.geometerplus.fbreader.formats.html.HtmlReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.util.HashMap;
import java.io.*;
import java.nio.charset.*;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.bookmodel.BookReader;
import org.geometerplus.fbreader.bookmodel.FBTextKind;
import org.geometerplus.zlibrary.core.html.*;
import org.geometerplus.zlibrary.core.util.ZLArrayUtils;
import org.geometerplus.zlibrary.text.model.ZLTextParagraph;

import org.geometerplus.zlibrary.core.xml.ZLXMLProcessor;
import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;

public class HtmlReader extends BookReader implements ZLHtmlReader {
	private final byte[] myStyleTable = new byte[HtmlTag.TAG_NUMBER];
	{
		myStyleTable[HtmlTag.H1] = FBTextKind.H1;
		myStyleTable[HtmlTag.H2] = FBTextKind.H2;
		myStyleTable[HtmlTag.H3] = FBTextKind.H3;
		myStyleTable[HtmlTag.H4] = FBTextKind.H4;
		myStyleTable[HtmlTag.H5] = FBTextKind.H5;
		myStyleTable[HtmlTag.H6] = FBTextKind.H6;
		myStyleTable[HtmlTag.B] = FBTextKind.BOLD;
		myStyleTable[HtmlTag.SUB] = FBTextKind.SUB;
		myStyleTable[HtmlTag.SUP] = FBTextKind.SUP;
		myStyleTable[HtmlTag.S] = FBTextKind.STRIKETHROUGH;
		myStyleTable[HtmlTag.PRE] = FBTextKind.PREFORMATTED;
		myStyleTable[HtmlTag.EM] = FBTextKind.EMPHASIS;
		myStyleTable[HtmlTag.DFN] = FBTextKind.DEFINITION;
		myStyleTable[HtmlTag.CITE] = FBTextKind.CITE;
		myStyleTable[HtmlTag.CODE] = FBTextKind.CODE;
		myStyleTable[HtmlTag.STRONG] = FBTextKind.STRONG;
		myStyleTable[HtmlTag.I] = FBTextKind.ITALIC;
	}

	protected final CharsetDecoder myAttributeDecoder;

	private boolean myInsideTitle = false;
	private boolean mySectionStarted = false;
	private byte myHyperlinkType;
	private final char[] SPACE = { ' ' };
	private String myHrefAttribute = ""href"";
	private boolean myOrderedListIsStarted = false;
	//private boolean myUnorderedListIsStarted = false;
	private int myOLCounter = 0;
	private byte[] myControls = new byte[10];
	private byte myControlsNumber = 0;
	
	public HtmlReader(BookModel model) throws UnsupportedEncodingException {
		super(model);
		try {	
			//String encoding = model.Book.getEncoding();
			myAttributeDecoder = createDecoder();
			setByteDecoder(createDecoder());
		} catch (UnsupportedCharsetException e) {
			throw new UnsupportedEncodingException(e.getMessage());
		}
	}

	protected final CharsetDecoder createDecoder() throws UnsupportedEncodingException {
		return Charset.forName(Model.Book.getEncoding()).newDecoder()
			.onMalformedInput(CodingErrorAction.REPLACE)
			.onUnmappableCharacter(CodingErrorAction.REPLACE);
	}

	public boolean readBook() throws IOException {
		return ZLHtmlProcessor.read(this, getInputStream());
	}

	public InputStream getInputStream() throws IOException {
		return Model.Book.File.getInputStream();
	}

	public void startDocumentHandler() {
	}

	public void endDocumentHandler() {
		unsetCurrentTextModel();
	}

	public void byteDataHandler(byte[] data, int start, int length) {
		addByteData(data, start, length);
	}

	private HashMap<String,char[]> myEntityMap;
	public void entityDataHandler(String entity) {
		if (myEntityMap == null) {
			myEntityMap = new HashMap<String,char[]>(ZLXMLProcessor.getEntityMap(XHTMLReader.xhtmlDTDs()));
		}
		char[] data = myEntityMap.get(entity);
		if (data == null) {
			if ((entity.length() > 0) && (entity.charAt(0) == '#')) {
				try {
					int number;
					if (entity.charAt(1) == 'x') {
						number = Integer.parseInt(entity.substring(2), 16);
					} else {
						number = Integer.parseInt(entity.substring(1));
					}
					data = new char[] { (char)number };
				} catch (NumberFormatException e) {
				}
			}
			if (data == null) {
				data = new char[0];
			}
			myEntityMap.put(entity, data);
		}
		addData(data);
	}

	private void openControl(byte control) {
		addControl(control, true);
		if (myControlsNumber == myControls.length) {
			myControls = ZLArrayUtils.createCopy(myControls, myControlsNumber, 2 * myControlsNumber);
		}
		myControls[myControlsNumber++] = control;
	}
	
	private void closeControl(byte control) {
		for (int i = 0; i < myControlsNumber; i++) {
			addControl(myControls[i], false);
		}
		boolean flag = false;
		int removedControl = myControlsNumber;
		for (int i = 0; i < myControlsNumber; i++) {
			if (!flag && (myControls[i] == control)) {
				flag = true;
				removedControl = i;
				continue;
			}
			addControl(myControls[i], true);
		}
		if (removedControl == myControlsNumber) {
			return;
		}
		--myControlsNumber;
		for (int i = removedControl; i < myControlsNumber; i++) {
			myControls[i] = myControls[i + 1];
		}
	}
	
	private void startNewParagraph() {
		endParagraph();
		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
	}
	
	public final void endElementHandler(String tagName) {
		endElementHandler(HtmlTag.getTagByName(tagName));
	}

	public void endElementHandler(byte tag) {
		switch (tag) {
			case HtmlTag.SCRIPT:
			case HtmlTag.SELECT:
			case HtmlTag.STYLE:
			case HtmlTag.P:
				startNewParagraph();
				break;

			case HtmlTag.H1:
			case HtmlTag.H2:
			case HtmlTag.H3:
			case HtmlTag.H4:
			case HtmlTag.H5:
			case HtmlTag.H6:
			case HtmlTag.PRE:
				closeControl(myStyleTable[tag]);
				startNewParagraph();
				break;

			case HtmlTag.A:
				closeControl(myHyperlinkType);
				break;

			case HtmlTag.BODY:
				break;

			case HtmlTag.HTML:
				//unsetCurrentTextModel();
				break;
				
			case HtmlTag.B:
			case HtmlTag.S:
			case HtmlTag.SUB:
			case HtmlTag.SUP:
			case HtmlTag.EM:
			case HtmlTag.DFN:
			case HtmlTag.CITE:
			case HtmlTag.CODE:
			case HtmlTag.STRONG:
			case HtmlTag.I:
				closeControl(myStyleTable[tag]);
				break;

			case HtmlTag.OL:
				myOrderedListIsStarted = false;
				myOLCounter = 0;
				break;
				
			case HtmlTag.UL:
				//myUnorderedListIsStarted = false;
				break;
				
			default:
				break;
		}
	}

	public final void startElementHandler(String tagName, int offset, ZLHtmlAttributeMap attributes) {
		startElementHandler(HtmlTag.getTagByName(tagName), offset, attributes);
	}

	public void startElementHandler(byte tag, int offset, ZLHtmlAttributeMap attributes) {
		switch (tag) {
			case HtmlTag.HTML:
				break;

			case HtmlTag.BODY:
				setMainTextModel();
				pushKind(FBTextKind.REGULAR);
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;

			case HtmlTag.P:
				if (mySectionStarted) {
					mySectionStarted = false;
				} else if (myInsideTitle) {
					addContentsData(SPACE);
				}
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;

			case HtmlTag.A:{
				String ref = attributes.getStringValue(myHrefAttribute, myAttributeDecoder);
				if ((ref != null) && (ref.length() != 0)) {
					if (ref.charAt(0) == '#') {
						myHyperlinkType = FBTextKind.FOOTNOTE;
						ref = ref.substring(1);
					} else {
						myHyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
					}
					addHyperlinkControl(myHyperlinkType, ref);
					myControls[myControlsNumber] = myHyperlinkType;
					myControlsNumber++;
				}
				break;
			}
			
			case HtmlTag.IMG: {
				/*
				String ref = attributes.getStringValue(mySrcAttribute, myAttributeDecoder);
				if ((ref != null) && (ref.length() != 0)) {
					addImageReference(ref, (short)0);
					String filePath = ref;
					if (!"":\\"".equals(ref.substring(1, 3))) {
						filePath = Model.Book.File.getPath();
						filePath = filePath.substring(0, filePath.lastIndexOf('\\') + 1) + ref;
					}
					addImage(ref, new ZLFileImage(""image/auto"", ZLFile.createFileByPath(filePath)));
				}
				*/
				break;
			}
			
			case HtmlTag.B:
			case HtmlTag.S:
			case HtmlTag.SUB:
			case HtmlTag.SUP:
			case HtmlTag.PRE:
			case HtmlTag.STRONG:
			case HtmlTag.CODE:
			case HtmlTag.EM:
			case HtmlTag.CITE:
			case HtmlTag.DFN:
			case HtmlTag.I:
				openControl(myStyleTable[tag]);
				break;
				
			case HtmlTag.H1:
			case HtmlTag.H2:
			case HtmlTag.H3:
			case HtmlTag.H4:
			case HtmlTag.H5:
			case HtmlTag.H6:
				startNewParagraph();
				openControl(myStyleTable[tag]);
				break;
				
			case HtmlTag.OL:
				myOrderedListIsStarted = true;
				break;
				
			case HtmlTag.UL:
				//myUnorderedListIsStarted = true;
				break;
				
			case HtmlTag.LI:
				startNewParagraph();
				if (myOrderedListIsStarted) {
					char[] number = (new Integer(++myOLCounter)).toString().toCharArray();
					addData(number);
					addData(new char[] {'.', ' '});
				} else {
					addData(new char[] {'*', ' '});
				}
				break;
				
			case HtmlTag.SCRIPT:
			case HtmlTag.SELECT:
			case HtmlTag.STYLE:
				endParagraph();
				break;
				
			case HtmlTag.TR: 
			case HtmlTag.BR:
				startNewParagraph();
				break;
			default:
				break;
		}
	}
}
",True,134,1,1,7,44,3,13,L3
8,org.geometerplus.fbreader.formats.util.MiscUtil.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.util;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class MiscUtil {
	public static String htmlDirectoryPrefix(ZLFile file) {
		String shortName = file.getName(false);
		String path = file.getPath();
		int index = -1;
		if ((path.length() > shortName.length()) &&
				(path.charAt(path.length() - shortName.length() - 1) == ':')) {
			index = shortName.lastIndexOf('/');
		}
		return path.substring(0, path.length() - shortName.length() + index + 1);
	}

	public static String archiveEntryName(String fullPath) {
		final int index = fullPath.lastIndexOf(':');
		return (index >= 2) ? fullPath.substring(index + 1) : fullPath;
	}

	private static boolean isHexDigit(char ch) {
		return
			(ch >= '0' && ch <= '9') ||
			(ch >= 'a' && ch <= 'f') ||
			(ch >= 'A' && ch <= 'F');
	}

	public static String decodeHtmlReference(String name) {
		int index = 0;
		while (true) {
			index = name.indexOf('%', index);
			if (index == -1 || index >= name.length() - 2) {
				break;
			}
			if (isHexDigit(name.charAt(index + 1)) &&
				isHexDigit(name.charAt(index + 2))) {
				char c = 0;
				try {
					c = (char)Integer.decode(""0x"" + name.substring(index + 1, index + 3)).intValue();
				} catch (NumberFormatException e) {
				}
				name = name.substring(0, index) + c + name.substring(index + 3);
			}
			index = index + 1;
		}
		return name;
	}
}
",True,179,11,43,5,7,5,1,L3
9,org.geometerplus.fbreader.formats.oeb.OEBPlugin.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class OEBPlugin extends FormatPlugin {
	public boolean acceptsFile(ZLFile file) {
		final String extension = file.getExtension().intern();
		return (extension == ""opf"") || (extension == ""oebzip"") || (extension == ""epub"");
	}

	private ZLFile getOpfFile(ZLFile oebFile) {
		if (oebFile.getExtension().equals(""opf"")) {
			return oebFile;
		}

		for (ZLFile child : oebFile.children()) {
			if (child.getExtension().equals(""opf"")) {
				return child;
			}
		}
		return null;
	}

	@Override
	public boolean readMetaInfo(Book book) {
		final ZLFile opfFile = getOpfFile(book.File);
		return (opfFile != null) ? new OEBMetaInfoReader(book).readMetaInfo(opfFile) : false;
	}
	
	@Override
	public boolean readModel(BookModel model) {
		model.Book.File.setCached(true);
		final ZLFile opfFile = getOpfFile(model.Book.File);
		return (opfFile != null) ? new OEBBookReader(model).readBook(opfFile) : false;
	}

	@Override
	public ZLImage readCover(Book book) {
		final ZLFile opfFile = getOpfFile(book.File);
		return (opfFile != null) ? new OEBCoverReader().readCover(opfFile) : null;
	}
}
",False,133,0,0,7,34,1,8,L3
10,org.geometerplus.fbreader.formats.oeb.OEBCoverReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.constants.XMLNamespace;
import org.geometerplus.fbreader.formats.util.MiscUtil;

class OEBCoverReader extends ZLXMLReaderAdapter implements XMLNamespace {

	private class XHTMLImageFinder extends ZLXMLReaderAdapter {

		private static final String IMG = ""img"";

		@Override
		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			tag = tag.toLowerCase().intern();
			if (tag == IMG) {
				final String src = attributes.getValue(""src"");
				if (src != null) {
					myImage = new ZLFileImage(
						""image/auto"",
						ZLFile.createFileByPath(myPathPrefix + src)
					);
					return true;
				}
			}
			return false;
		}
	}


	private ZLImage myImage;
	private String myPathPrefix;
	private String myCoverXHTML;
	private boolean myReadGuide;


	OEBCoverReader() {
	}

	public ZLImage readCover(ZLFile file) {
		myPathPrefix = MiscUtil.htmlDirectoryPrefix(file);
		myReadGuide = false;
		myImage = null;
		myCoverXHTML = null;
		read(file);
		if (myCoverXHTML != null) {
			final ZLFile coverFile = ZLFile.createFileByPath(myCoverXHTML);
			if (coverFile != null) {
				final String ext = coverFile.getExtension();
				if (ext != null && (ext.equals(""gif"") || ext.equals(""jpg"") || ext.equals(""jpeg""))) {
					myImage = new ZLFileImage(""image/auto"", coverFile);
				} else {
					new XHTMLImageFinder().read(coverFile);
				}
			}
		}
		return myImage;
	}

	private static final String GUIDE = ""guide"";
	private static final String REFERENCE = ""reference"";
	private static final String COVER = ""cover"";
	private static final String COVER_IMAGE = ""other.ms-coverimage-standard"";

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (GUIDE == tag) {
			myReadGuide = true;
		} else if (myReadGuide && REFERENCE == tag) {
			final String type = attributes.getValue(""type"");
			if (COVER == type) {
				final String href = attributes.getValue(""href"");
				if (href != null) {
					myCoverXHTML = myPathPrefix + MiscUtil.decodeHtmlReference(href);
					return true;
				}
			} else if (COVER_IMAGE == type) {
				final String href = attributes.getValue(""href"");
				if (href != null) {
					myImage = new ZLFileImage(
						""image/auto"",
						ZLFile.createFileByPath(myPathPrefix + MiscUtil.decodeHtmlReference(href))
					);
					return true;
				}
			}
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if (GUIDE == tag) {
			myReadGuide = false;
			return true;
		}
		return false;
	}
}
",False,191,12,42,5,9,1,7,L3
11,org.geometerplus.fbreader.formats.oeb.OEBBookReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;
import org.geometerplus.fbreader.formats.util.MiscUtil;
import org.geometerplus.fbreader.constants.XMLNamespace;

class Reference {
	public final String Title;
	public final String HRef;

	public Reference(String title, String href) {
		Title = title;
		HRef = href;
	}
}

class OEBBookReader extends ZLXMLReaderAdapter implements XMLNamespace {
	private static final char[] Dots = new char[] {'.', '.', '.'};

	private final BookReader myModelReader;
	private final HashMap<String,String> myIdToHref = new HashMap<String,String>();
	private final ArrayList<String> myHtmlFileNames = new ArrayList<String>();
	private final ArrayList<Reference> myTourTOC = new ArrayList<Reference>();
	private final ArrayList<Reference> myGuideTOC = new ArrayList<Reference>();

	private String myOPFSchemePrefix;
	private String myFilePrefix;
	private String myNCXTOCFileName;

	OEBBookReader(BookModel model) {
		myModelReader = new BookReader(model);
	}

	private TreeMap<String,Integer> myFileNumbers = new TreeMap<String,Integer>();
	private TreeMap<String,Integer> myTOCLabels = new TreeMap<String,Integer>();

	boolean readBook(ZLFile file) {
		myFilePrefix = MiscUtil.htmlDirectoryPrefix(file);

		myIdToHref.clear();
		myHtmlFileNames.clear();
		myNCXTOCFileName = null;
		myTourTOC.clear();
		myGuideTOC.clear();
		myState = READ_NONE;

		if (!read(file)) {
			return false;
		}

		myModelReader.setMainTextModel();
		myModelReader.pushKind(FBTextKind.REGULAR);

		for (String name : myHtmlFileNames) {
			final ZLFile xhtmlFile = ZLFile.createFileByPath(myFilePrefix + name);
			final XHTMLReader reader = new XHTMLReader(myModelReader, myFileNumbers);
			final String referenceName = reader.getFileAlias(MiscUtil.archiveEntryName(xhtmlFile.getPath()));

			myModelReader.addHyperlinkLabel(referenceName);
			myTOCLabels.put(referenceName, myModelReader.Model.BookTextModel.getParagraphsNumber());
			reader.readFile(xhtmlFile, referenceName + '#');
			myModelReader.insertEndOfSectionParagraph();
		}

		generateTOC();

		return true;
	}

	private BookModel.Label getTOCLabel(String id) {
		final int index = id.indexOf('#');
		final String path = (index >= 0) ? id.substring(0, index) : id;
		Integer num = myFileNumbers.get(path);
		if (num == null) {
			return null;
		}
		if (index == -1) {
			final Integer para = myTOCLabels.get(num.toString());
			if (para == null) {
				return null;
			}
			return new BookModel.Label(null, para);
		}
		return myModelReader.Model.getLabel(num + id.substring(index));
	}

	private void generateTOC() {
		if (myNCXTOCFileName != null) {
			final NCXReader ncxReader = new NCXReader(myModelReader);
			if (ncxReader.readFile(myFilePrefix + myNCXTOCFileName)) {
				final Map<Integer,NCXReader.NavPoint> navigationMap = ncxReader.navigationMap();
				if (!navigationMap.isEmpty()) {
					int level = 0;
					for (NCXReader.NavPoint point : navigationMap.values()) {
						final BookModel.Label label = getTOCLabel(point.ContentHRef);
						int index = (label != null) ? label.ParagraphIndex : -1;
						while (level > point.Level) {
							myModelReader.endContentsParagraph();
							--level;
						}
						while (++level <= point.Level) {
							myModelReader.beginContentsParagraph(-2);
							myModelReader.addContentsData(Dots);
						}
						myModelReader.beginContentsParagraph(index);
						myModelReader.addContentsData(point.Text.toCharArray());
					}
					while (level > 0) {
						myModelReader.endContentsParagraph();
						--level;
					}
					return;
				}
			}
		}

		for (Reference ref : myTourTOC.isEmpty() ? myGuideTOC : myTourTOC) {
			final BookModel.Label label = getTOCLabel(ref.HRef);
			if (label != null) {
				final int index = label.ParagraphIndex;
				if (index != -1) {
					myModelReader.beginContentsParagraph(index);
					myModelReader.addContentsData(ref.Title.toCharArray());
					myModelReader.endContentsParagraph();
				}
			}
		}
	}

	private static final String MANIFEST = ""manifest"";
	private static final String SPINE = ""spine"";
	private static final String GUIDE = ""guide"";
	private static final String TOUR = ""tour"";
	private static final String SITE = ""site"";
	private static final String REFERENCE = ""reference"";
	private static final String ITEMREF = ""itemref"";
	private static final String ITEM = ""item"";

	private static final String COVER_IMAGE = ""other.ms-coverimage-standard"";

	private static final int READ_NONE = 0;
	private static final int READ_MANIFEST = 1;
	private static final int READ_SPINE = 2;
	private static final int READ_GUIDE = 3;
	private static final int READ_TOUR = 4;
	
	private int myState;

	public boolean startElementHandler(String tag, ZLStringMap xmlattributes) {
		tag = tag.toLowerCase();
		if ((myOPFSchemePrefix != null) && tag.startsWith(myOPFSchemePrefix)) {
			tag = tag.substring(myOPFSchemePrefix.length());
		}
		tag = tag.intern();
		if (MANIFEST == tag) {
			myState = READ_MANIFEST;
		} else if (SPINE == tag) {
			myNCXTOCFileName = myIdToHref.get(xmlattributes.getValue(""toc""));
			myState = READ_SPINE;
		} else if (GUIDE == tag) {
			myState = READ_GUIDE;
		} else if (TOUR == tag) {
			myState = READ_TOUR;
		} else if ((myState == READ_MANIFEST) && (ITEM == tag)) {
			final String id = xmlattributes.getValue(""id"");
			String href = xmlattributes.getValue(""href"");
			if ((id != null) && (href != null)) {
				href = MiscUtil.decodeHtmlReference(href);
				myIdToHref.put(id, href);
			}
		} else if ((myState == READ_SPINE) && (ITEMREF == tag)) {
			final String id = xmlattributes.getValue(""idref"");
			if (id != null) {
				final String fileName = myIdToHref.get(id);
				if (fileName != null) {
					myHtmlFileNames.add(fileName);
				}
			}
		} else if ((myState == READ_GUIDE) && (REFERENCE == tag)) {
			final String type = xmlattributes.getValue(""type"");
			final String title = xmlattributes.getValue(""title"");
			String href = xmlattributes.getValue(""href"");
			if (href != null) {
				href = MiscUtil.decodeHtmlReference(href);
				if (title != null) {
					myGuideTOC.add(new Reference(title, href));
				}
				if ((type != null) && (COVER_IMAGE.equals(type))) {
					myModelReader.setMainTextModel();
					final ZLFile imageFile = ZLFile.createFileByPath(myFilePrefix + href);
					final String imageName = imageFile.getName(false);
					myModelReader.addImageReference(imageName, (short)0);
					myModelReader.addImage(imageName, new ZLFileImage(""image/auto"", imageFile));
				}
			}
		} else if ((myState == READ_TOUR) && (SITE == tag)) {
			final String title = xmlattributes.getValue(""title"");
			String href = xmlattributes.getValue(""href"");
			if ((title != null) && (href != null)) {
				href = MiscUtil.decodeHtmlReference(href);
				myTourTOC.add(new Reference(title, href));
			}
		}
		return false;
	}

	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if ((myOPFSchemePrefix != null) && tag.startsWith(myOPFSchemePrefix)) {
			tag = tag.substring(myOPFSchemePrefix.length());
		}
		tag = tag.intern();
		if ((MANIFEST == tag) || (SPINE == tag) || (GUIDE == tag) || (TOUR == tag)) {
			myState = READ_NONE;
		}
		return false;
	}

	public boolean processNamespaces() {
		return true;
	}

	public void namespaceMapChangedHandler(HashMap<String,String> namespaceMap) {
		myOPFSchemePrefix = null;
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			if (OpenPackagingFormat.equals(entry.getValue())) {
				myOPFSchemePrefix = entry.getKey() + "":"";
				break;
			}
		}
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}
}
",True,133,0,0,8,33,1,12,L3
12,org.geometerplus.fbreader.formats.oeb.NCXReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.util.MiscUtil;

class NCXReader extends ZLXMLReaderAdapter {
	static class NavPoint {
		final int Order;
		final int Level;
		String Text = """";
		String ContentHRef = """";

		NavPoint(int order, int level) {
			Order = order;
			Level = level;
		}
	}

	private final TreeMap<Integer,NavPoint> myNavigationMap = new TreeMap<Integer,NavPoint>();
	private final ArrayList<NavPoint> myPointStack = new ArrayList<NavPoint>();

	private static final int READ_NONE = 0;
	private static final int READ_MAP = 1;
	private static final int READ_POINT = 2;
	private static final int READ_LABEL = 3;
	private static final int READ_TEXT = 4;

	int myReadState = READ_NONE;
	int myPlayIndex = -65535;
	private String myLocalPathPrefix;

	NCXReader(BookReader modelReader) {
	}

	boolean readFile(String filePath) {
		final ZLFile file = ZLFile.createFileByPath(filePath);
		myLocalPathPrefix = MiscUtil.archiveEntryName(MiscUtil.htmlDirectoryPrefix(file));
		return read(file);
	}

	Map<Integer,NavPoint> navigationMap() {
		return myNavigationMap;
	}

	private static final String TAG_NAVMAP = ""navmap"";
	private static final String TAG_NAVPOINT = ""navpoint"";
	private static final String TAG_NAVLABEL = ""navlabel"";
	private static final String TAG_CONTENT = ""content"";
	private static final String TAG_TEXT = ""text"";

	private static final String ATTRIBUTE_PLAYORDER = ""playOrder"";

	private int atoi(String number) {
		try {
			return Integer.parseInt(number);
		} catch (NumberFormatException e) {
			return 0;
		}
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		switch (myReadState) {
			case READ_NONE:
				if (tag == TAG_NAVMAP) {
					myReadState = READ_MAP;
				}
				break;
			case READ_MAP:
				if (tag == TAG_NAVPOINT) {
					final String order = attributes.getValue(ATTRIBUTE_PLAYORDER);
					final int index = (order != null) ? atoi(order) : myPlayIndex++;
					myPointStack.add(new NavPoint(index, myPointStack.size()));
					myReadState = READ_POINT;
				}
				break;
			case READ_POINT:
				if (tag == TAG_NAVPOINT) {
					final String order = attributes.getValue(ATTRIBUTE_PLAYORDER);
					final int index = (order != null) ? atoi(order) : myPlayIndex++;
					myPointStack.add(new NavPoint(index, myPointStack.size()));
				} else if (tag == TAG_NAVLABEL) {
					myReadState = READ_LABEL;
				} else if (tag == TAG_CONTENT) {
					final int size = myPointStack.size();
					if (size > 0) {
						myPointStack.get(size - 1).ContentHRef = myLocalPathPrefix + attributes.getValue(""src"");
					}
				}
				break;
			case READ_LABEL:
				if (TAG_TEXT == tag) {
					myReadState = READ_TEXT;
				}
				break;
			case READ_TEXT:
				break;
		}
		return false;
	}
	
	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase().intern();
		switch (myReadState) {
			case READ_NONE:
				break;
			case READ_MAP:
				if (TAG_NAVMAP == tag) {
					myReadState = READ_NONE;
				}
				break;
			case READ_POINT:
				if (TAG_NAVPOINT == tag) {
					NavPoint last = myPointStack.get(myPointStack.size() - 1);
					if (last.Text.length() == 0) {
						last.Text = ""..."";
					}
					myNavigationMap.put(last.Order, last);
					myPointStack.remove(myPointStack.size() - 1);
					myReadState = (myPointStack.isEmpty()) ? READ_MAP : READ_POINT;
				}
			case READ_LABEL:
				if (TAG_NAVLABEL == tag) {
					myReadState = READ_POINT;
				}
				break;
			case READ_TEXT:
				if (TAG_TEXT == tag) {
					myReadState = READ_LABEL;
				}
				break;
		}
		return false;
	}
	
	@Override
	public void characterDataHandler(char[] ch, int start, int length) {
		if (myReadState == READ_TEXT) {
			final ArrayList<NavPoint> stack = myPointStack;
			final NavPoint last = stack.get(stack.size() - 1);
			last.Text += new String(ch, start, length);
		}
	}

	@Override
	public boolean dontCacheAttributeValues() {
		return true;
	}
}
",True,133,0,0,9,29,1,5,L3
13,org.geometerplus.fbreader.formats.oeb.OEBMetaInfoReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.constants.XMLNamespace;

class OEBMetaInfoReader extends ZLXMLReaderAdapter implements XMLNamespace {
	private final Book myBook;

	private String myDCMetadataTag = ""dc-metadata"";
	private String myMetadataTag = ""metadata"";
	private String myOpfMetadataTag = ""metadata"";
	private String myMetadataTagRealName;
	private String myTitleTag;
	private String myAuthorTag;
	private String mySubjectTag;
	private String myLanguageTag;
	private String myMetaTag = ""meta"";

	private String mySeriesTitle = """";
	private int mySeriesIndex = 0;
	
	private final ArrayList<String> myAuthorList = new ArrayList<String>();
	private final ArrayList<String> myAuthorList2 = new ArrayList<String>();

	OEBMetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle(null);
		myBook.setLanguage(null);
	}

	boolean readMetaInfo(ZLFile file) {
		myReadMetaData = false;
		myReadState = READ_NONE;

		if (!ZLXMLProcessor.read(this, file, 512)) {
			return false;
		}

		final ArrayList<String> authors = myAuthorList.isEmpty() ? myAuthorList2 : myAuthorList;
		for (String a : authors) {
			final int index = a.indexOf(',');
			if (index >= 0) {
				a = a.substring(index + 1).trim() + ' ' + a.substring(0, index).trim();
			} else {
				a = a.trim();
			}
			myBook.addAuthor(a);
		}

		return true;
	}

	private static final int READ_NONE = 0;
	private static final int READ_AUTHOR = 1;
	private static final int READ_AUTHOR2 = 2;
	private static final int READ_TITLE = 3;
	private static final int READ_SUBJECT = 4;
	private static final int READ_LANGUAGE = 5;
	private int myReadState;
	private boolean myReadMetaData;

	private final StringBuffer myBuffer = new StringBuffer();

	public boolean processNamespaces() {
		return true;
	}

	public void namespaceMapChangedHandler(HashMap<String,String> namespaceMap) {
		myTitleTag = null;
		myAuthorTag = null;
		mySubjectTag = null;
		myLanguageTag = null;
		myOpfMetadataTag = ""metadata"";
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String id = entry.getValue();
			if (id.startsWith(DublinCorePrefix) || id.startsWith(DublinCoreLegacyPrefix)) {
				final String name = entry.getKey();
				myTitleTag = (name + "":title"").intern();
				myAuthorTag = (name + "":creator"").intern();
				mySubjectTag = (name + "":subject"").intern();
				myLanguageTag = (name + "":language"").intern();
			} else if (id.equals(OpenPackagingFormat)) {
				final String name = entry.getKey();
				myOpfMetadataTag = (name + "":metadata"").intern();
			}
		}
	}

	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (tag == myMetadataTag || tag == myDCMetadataTag || tag == myOpfMetadataTag) {
			myMetadataTagRealName = tag;
			myReadMetaData = true;
		} else if (myReadMetaData) {
			if (tag == myTitleTag) {
				myReadState = READ_TITLE;
			} else if (tag == myAuthorTag) {
				final String role = attributes.getValue(""role"");
				if (role == null) {
					myReadState = READ_AUTHOR2;
				} else if (role.equals(""aut"")) {
					myReadState = READ_AUTHOR;
				}
			} else if (tag == mySubjectTag) {
				myReadState = READ_SUBJECT;
			} else if (tag == myLanguageTag) {
				myReadState = READ_LANGUAGE;
			} else if (tag == myMetaTag) {
				if (attributes.getValue(""name"").equals(""calibre:series"")) {
					mySeriesTitle = attributes.getValue(""content"");
				} else if (attributes.getValue(""name"").equals(""calibre:series_index"")) {
					final String strIndex = attributes.getValue(""content"");
					try {
						mySeriesIndex = Integer.parseInt(strIndex);
					} catch (NumberFormatException e) {
					}
				}
			}
		}
		return false;
	}

	public void characterDataHandler(char[] data, int start, int len) {
		switch (myReadState) {
			case READ_NONE:
				break;
			case READ_AUTHOR:
			case READ_AUTHOR2:
			case READ_TITLE:
			case READ_SUBJECT:
			case READ_LANGUAGE:
				myBuffer.append(data, start, len);
				break;
		}
	}

	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if (tag.equals(myMetadataTagRealName)) {
			return true;
		}

		String bufferContent = myBuffer.toString().trim();
		if (bufferContent.length() != 0) {
			switch (myReadState) {
				case READ_TITLE:
					myBook.setTitle(bufferContent);
					break;
				case READ_AUTHOR:
					myAuthorList.add(bufferContent);
					break;
				case READ_AUTHOR2:
					myAuthorList2.add(bufferContent);
					break;
				case READ_SUBJECT:
					myBook.addTag(bufferContent);
					break;
				case READ_LANGUAGE:
					{
						int index = bufferContent.indexOf('_');
						if (index >= 0) {
							bufferContent = bufferContent.substring(0, index);
						}
						index = bufferContent.indexOf('-');
						if (index >= 0) {
							bufferContent = bufferContent.substring(0, index);
						}
						myBook.setLanguage(""cz"".equals(bufferContent) ? ""cs"" : bufferContent);
					}
					break;
			}
		} else {
			if (tag.equals(myMetaTag)) {
				if (!mySeriesTitle.equals("""") && mySeriesIndex > 0) {
					myBook.setSeriesInfo(mySeriesTitle, mySeriesIndex);
				}
			}
		}
		myBuffer.delete(0, myBuffer.length());
		myReadState = READ_NONE;
		return false;
	}
}
",True,133,0,0,7,30,1,6,L3
14,org.geometerplus.fbreader.formats.fb2.Base64EncodedImage.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.io.*;

import org.geometerplus.zlibrary.core.image.ZLBase64EncodedImage;

import org.geometerplus.fbreader.Paths;

final class Base64EncodedImage extends ZLBase64EncodedImage {
	private static int ourCounter;

	static void resetCounter() {
		ourCounter = 0;
	}

	private final String myDirName;
	private final int myFileNumber;
	private OutputStreamWriter myStreamWriter;
	
	public Base64EncodedImage(String contentType) {
		// TODO: use contentType
		super(contentType);
		myDirName = Paths.cacheDirectory();
		new File(myDirName).mkdirs();
		myFileNumber = ourCounter++;
		try {
			myStreamWriter = new OutputStreamWriter(new FileOutputStream(myDirName + ""/image"" + myFileNumber), ""UTF-8"");
		} catch (IOException e) {
		}
	}

	@Override
	protected String encodedFileName() {
		return myDirName + ""/image"" + myFileNumber;
	}

	@Override
	protected String decodedFileName() {
		return myDirName + ""/dimage"" + myFileNumber;
	}

	void addData(char[] data, int offset, int length) {
		if (myStreamWriter != null) {
			try {
				myStreamWriter.write(data, offset, length);
			} catch (IOException e) {
			}
		}
	}

	void close() {
		try {
			myStreamWriter.close();
		} catch (IOException e) {
		}
	}
}
",True,166,13,42,4,3,2,2,L3
15,org.geometerplus.fbreader.formats.fb2.FB2Tag.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

final class FB2Tag {
	public static final byte UNKNOWN = 0;
	public static final byte P = 1;
	public static final byte V = 2;
	public static final byte SUBTITLE = 3;
	public static final byte TEXT_AUTHOR = 4;
	public static final byte DATE = 5;
	public static final byte CITE = 6;
	public static final byte SECTION = 7;
	public static final byte POEM = 8;
	public static final byte STANZA = 9;
	public static final byte EPIGRAPH = 10;
	public static final byte ANNOTATION = 11;
	public static final byte COVERPAGE = 12;
	public static final byte A = 13;
	public static final byte EMPTY_LINE = 14;
	public static final byte SUP = 15;
	public static final byte SUB = 16;
	public static final byte EMPHASIS = 17;
	public static final byte STRONG = 18;
	public static final byte CODE = 19;
	public static final byte STRIKETHROUGH = 20;
	public static final byte TITLE = 21;
	public static final byte BODY = 22;
	public static final byte IMAGE = 23;
	public static final byte BINARY = 24;
	public static final byte FICTIONBOOK = 25;
	
	public static final byte TITLE_INFO = 26;
	public static final byte BOOK_TITLE = 27;
	public static final byte AUTHOR = 28;
	public static final byte LANG = 29;
	public static final byte FIRST_NAME = 30;
	public static final byte MIDDLE_NAME = 31;
	public static final byte LAST_NAME = 32;
	public static final byte SEQUENCE = 33;
	public static final byte GENRE = 34;

	public static final byte DESCRIPTION = 35;


	private static final HashMap<String, Byte> ourTagByName = new HashMap<String, Byte>(256, 0.2f);
	private static final Byte ourUnknownTag;

	static {	
		ourTagByName.put(""unknown"", UNKNOWN);
		ourUnknownTag = (Byte)ourTagByName.get(""unknown"");
		ourTagByName.put(""p"", P);
		ourTagByName.put(""v"", V);
		ourTagByName.put(""subtitle"", SUBTITLE);
		ourTagByName.put(""text-author"", TEXT_AUTHOR);
		ourTagByName.put(""date"", DATE);
		ourTagByName.put(""cite"", CITE);
		ourTagByName.put(""section"", SECTION);
		ourTagByName.put(""poem"", POEM);
		ourTagByName.put(""stanza"", STANZA);
		ourTagByName.put(""epigraph"", EPIGRAPH);
		ourTagByName.put(""annotation"", ANNOTATION);
		ourTagByName.put(""coverpage"", COVERPAGE);
		ourTagByName.put(""a"", A);
		ourTagByName.put(""empty-line"", EMPTY_LINE);
		ourTagByName.put(""sup"", SUP);
		ourTagByName.put(""sub"", SUB);
		ourTagByName.put(""emphasis"", EMPHASIS);
		ourTagByName.put(""strong"", STRONG);
		ourTagByName.put(""code"", CODE);
		ourTagByName.put(""strikethrough"", STRIKETHROUGH);
		ourTagByName.put(""title"", TITLE);
		ourTagByName.put(""title-info"", TITLE_INFO);
		ourTagByName.put(""body"", BODY);
		ourTagByName.put(""image"", IMAGE);
		ourTagByName.put(""binary"", BINARY);
		ourTagByName.put(""fictionbook"", FICTIONBOOK);
		ourTagByName.put(""book-title"", BOOK_TITLE);
		ourTagByName.put(""sequence"", SEQUENCE);
		ourTagByName.put(""first-name"", FIRST_NAME);
		ourTagByName.put(""middle-name"", MIDDLE_NAME);
		ourTagByName.put(""last-name"", LAST_NAME);
		ourTagByName.put(""book-title"", BOOK_TITLE);
		ourTagByName.put(""author"", AUTHOR);
		ourTagByName.put(""lang"", LANG);
		ourTagByName.put(""genre"", GENRE);
		ourTagByName.put(""description"", DESCRIPTION);
	}

	public static byte getTagByName(String name) {
		final HashMap<String,Byte> tagByName = ourTagByName;
		Byte num = tagByName.get(name);
		if (num == null) {
			final String upperCaseName = name.toLowerCase().intern();
			num = (Byte)tagByName.get(upperCaseName);
			if (num == null) {
				num = ourUnknownTag;
				tagByName.put(upperCaseName, num);
			}
			tagByName.put(name, num);
		}
		return num.byteValue();
	}

	private FB2Tag() {
	}
}
",False,158,13,42,0,0,3,0,L3
16,org.geometerplus.fbreader.formats.fb2.FB2MetaInfoReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Tag;

public class FB2MetaInfoReader extends ZLXMLReaderAdapter {
	private final static int READ_NOTHING = 0;
	private final static int READ_SOMETHING = 1;
	private final static int READ_TITLE = 2;
	private final static int READ_AUTHOR = 3;
	private final static int READ_AUTHOR_NAME_0 = 4;
	private final static int READ_AUTHOR_NAME_1 = 5;
	private final static int READ_AUTHOR_NAME_2 = 6;
	private final static int READ_LANGUAGE = 7;
	private final static int READ_GENRE = 8;

	private final Book myBook;
	private int myReadState = READ_NOTHING;

	private	final String[] myAuthorNames = new String[3];
	private final StringBuilder myBuffer = new StringBuilder();

	public FB2MetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle(null);
		myBook.setLanguage(null);
	}
	
	public boolean dontCacheAttributeValues() {
		return true;
	}
	
	public boolean readMetaInfo() {
		myReadState = READ_NOTHING;
		myAuthorNames[0] = """";
		myAuthorNames[1] = """";
		myAuthorNames[2] = """";
		myBuffer.delete(0, myBuffer.length());
		return readDocument(myBook.File);
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (FB2Tag.getTagByName(tagName)) {
			case FB2Tag.BODY:
				return true;
			case FB2Tag.TITLE_INFO:
				myReadState = READ_SOMETHING;
				break;
			case FB2Tag.BOOK_TITLE:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_TITLE;
				}
				break;
			case FB2Tag.GENRE:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_GENRE;
				}
				break;
			case FB2Tag.AUTHOR:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.LANG:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_LANGUAGE;
				}
				break;
			case FB2Tag.FIRST_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_0;
				}
				break;
			case FB2Tag.MIDDLE_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_1;
				}
				break;
			case FB2Tag.LAST_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_2;
				}
				break;
			case FB2Tag.SEQUENCE:
				if (myReadState == READ_SOMETHING) {
					String name = attributes.getValue(""name"");
					if (name != null) {
						name.trim();
						if (name.length() != 0) {
							int index = 0;
							try {
								final String sIndex = attributes.getValue(""number"");
								if (sIndex != null) {
									index = Integer.parseInt(sIndex);
								}
							} catch (NumberFormatException e) {
							}
							myBook.setSeriesInfo(name, index);
						}
					}
				}
				break;
		}
		return false;
	}
	
	public boolean endElementHandler(String tag) {
		switch (FB2Tag.getTagByName(tag)) {
			case FB2Tag.TITLE_INFO:
				myReadState = READ_NOTHING;
				break;
			case FB2Tag.BOOK_TITLE:
				if (myReadState == READ_TITLE) {
					myBook.setTitle(myBuffer.toString().trim());
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.GENRE:
				if (myReadState == READ_GENRE) {
					final String genre = myBuffer.toString().trim();
					if (genre.length() > 0) {
						final ArrayList<Tag> tags = FB2TagManager.humanReadableTags(genre);
						if (tags != null) {
							for (Tag t : tags) {
								myBook.addTag(t);
							}
						} else {
							myBook.addTag(genre);
						}
					}
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.AUTHOR:
				if (myReadState == READ_AUTHOR) {
					myAuthorNames[0] = myAuthorNames[0].trim();
					myAuthorNames[1] = myAuthorNames[1].trim();
					myAuthorNames[2] = myAuthorNames[2].trim();
					String fullName = myAuthorNames[0];
					if (fullName.length() != 0 && myAuthorNames[1].length() != 0) {
						fullName += ' ';
					}
					fullName += myAuthorNames[1];
					if (fullName.length() != 0 && myAuthorNames[2].length() != 0) {
						fullName += ' ';
					}
					fullName += myAuthorNames[2];
					myBook.addAuthor(fullName, myAuthorNames[2]);
					myAuthorNames[0] = """";
					myAuthorNames[1] = """";
					myAuthorNames[2] = """";
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.LANG:
				if (myReadState == READ_LANGUAGE) {
					myBook.setLanguage(myBuffer.toString().trim());
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.FIRST_NAME:
				if (myReadState == READ_AUTHOR_NAME_0) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.MIDDLE_NAME:
				if (myReadState == READ_AUTHOR_NAME_1) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.LAST_NAME:
				if (myReadState == READ_AUTHOR_NAME_2) {
					myReadState = READ_AUTHOR;
				}
				break;
			default:
				break;
		}	
		myBuffer.delete(0, myBuffer.length());
		return false;
	}
	
	public void characterDataHandler(char[] data, int start, int length) {
		switch (myReadState) {
			case READ_AUTHOR_NAME_0:
				myAuthorNames[0] += new String(data, start, length);
				break;
			case READ_AUTHOR_NAME_1:
				myAuthorNames[1] += new String(data, start, length);
				break;
			case READ_AUTHOR_NAME_2:
				myAuthorNames[2] += new String(data, start, length);
				break;
			case READ_TITLE:
			case READ_LANGUAGE:
			case READ_GENRE:
				myBuffer.append(data, start, length);
				break;
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file, 512);
	}
}
",True,133,0,0,7,29,1,8,L3
17,org.geometerplus.fbreader.formats.fb2.FB2Reader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.util.*;
import org.geometerplus.zlibrary.text.model.ZLTextParagraph;

public final class FB2Reader extends BookReader implements ZLXMLReader {
	private boolean myInsidePoem = false;
	private boolean myInsideTitle = false;
	private int myBodyCounter = 0;
	private boolean myReadMainText = false;
	private int mySectionDepth = 0;
	private boolean mySectionStarted = false;
	
	private byte myHyperlinkType;
	
	private Base64EncodedImage myCurrentImage;
	private boolean myInsideCoverpage = false;
	private String myCoverImageReference;
	private int myParagraphsBeforeBodyNumber = Integer.MAX_VALUE;

	private final char[] SPACE = { ' ' }; 
	private String myHrefAttribute;

	private byte[] myTagStack = new byte[10];
	private int myTagStackSize = 0;

	public FB2Reader(BookModel model) {
 		super(model);
	}

	boolean readBook() {
		Base64EncodedImage.resetCounter();
		return ZLXMLProcessor.read(this, Model.Book.File);
	}

	public void startDocumentHandler() {
	}

	public void endDocumentHandler() {
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}

	public void characterDataHandler(char[] ch, int start, int length) {
		if (length == 0) {
			return;
		}
		final Base64EncodedImage image = myCurrentImage;
		if (image != null) {
			image.addData(ch, start, length);
		} else {
			addData(ch, start, length, false);
		}		
	}

	public void characterDataHandlerFinal(char[] ch, int start, int length) {
		if (length == 0) {
			return;
		}
		final Base64EncodedImage image = myCurrentImage;
		if (image != null) {
			image.addData(ch, start, length);
		} else {
			addData(ch, start, length, true);
		}		
	}

	public boolean endElementHandler(String tagName) {
		final byte tag = myTagStack[--myTagStackSize];
		switch (tag) {
			case FB2Tag.P:
				endParagraph();		
				break;
			case FB2Tag.SUB:
				addControl(FBTextKind.SUB, false);
				break;
			case FB2Tag.SUP:
				addControl(FBTextKind.SUP, false);
				break;
			case FB2Tag.CODE:
				addControl(FBTextKind.CODE, false);
				break;
			case FB2Tag.EMPHASIS:
				addControl(FBTextKind.EMPHASIS, false);
				break;
			case FB2Tag.STRONG:
				addControl(FBTextKind.STRONG, false);
				break;
			case FB2Tag.STRIKETHROUGH:
				addControl(FBTextKind.STRIKETHROUGH, false);
				break;
			
			case FB2Tag.V:
			case FB2Tag.SUBTITLE:
			case FB2Tag.TEXT_AUTHOR:
			case FB2Tag.DATE:
				popKind();
				endParagraph();
				break;	
			
			case FB2Tag.CITE:
			case FB2Tag.EPIGRAPH:
				popKind();
				break;	
			
			case FB2Tag.POEM:
				myInsidePoem = false;
				break;
			
			case FB2Tag.STANZA:
				beginParagraph(ZLTextParagraph.Kind.AFTER_SKIP_PARAGRAPH);
				endParagraph();
				beginParagraph(ZLTextParagraph.Kind.EMPTY_LINE_PARAGRAPH);
				endParagraph();
				popKind();
				break;
				
			case FB2Tag.SECTION:
				if (myReadMainText) {
					endContentsParagraph();
					--mySectionDepth;
					mySectionStarted = false;
				} else {
					unsetCurrentTextModel();
				}
				break;
			
			case FB2Tag.ANNOTATION:
				popKind();
				if (myBodyCounter == 0) {
					insertEndOfSectionParagraph();
					unsetCurrentTextModel();
				}
				break;
			
			case FB2Tag.TITLE:
				popKind();
				exitTitle();
				myInsideTitle = false;
				break;
				
			case FB2Tag.BODY:
				popKind();
				myReadMainText = false;
				unsetCurrentTextModel();
				break;
			
			case FB2Tag.A:
				addControl(myHyperlinkType, false);
				break;
			
			case FB2Tag.COVERPAGE:
				if (myBodyCounter == 0) {
					myInsideCoverpage = false;
					insertEndOfSectionParagraph();
					unsetCurrentTextModel();
				}
				break;	
			
			case FB2Tag.BINARY:
				if (myCurrentImage != null) {
					myCurrentImage.close();
					myCurrentImage = null;
				}
				break;	
				
			default:
				break;
		}		
		return false;
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		String id = attributes.getValue(""id"");
		if (id != null) {
			if (!myReadMainText) {
				setFootnoteTextModel(id);
			}
			addHyperlinkLabel(id);
		}
		final byte tag = FB2Tag.getTagByName(tagName);
		byte[] tagStack = myTagStack;
		if (tagStack.length == myTagStackSize) {
			tagStack = ZLArrayUtils.createCopy(tagStack, myTagStackSize, myTagStackSize * 2);
			myTagStack = tagStack;
		}
		tagStack[myTagStackSize++] = tag;
		switch (tag) {
			case FB2Tag.P:
				if (mySectionStarted) {
					mySectionStarted = false;
				} else if (myInsideTitle) {
					addContentsData(SPACE);
				}
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			
			case FB2Tag.SUB:
				addControl(FBTextKind.SUB, true);
				break;
			case FB2Tag.SUP:
				addControl(FBTextKind.SUP, true);
				break;
			case FB2Tag.CODE:
				addControl(FBTextKind.CODE, true);
				break;
			case FB2Tag.EMPHASIS:
				addControl(FBTextKind.EMPHASIS, true);
				break;
			case FB2Tag.STRONG:
				addControl(FBTextKind.STRONG, true);
				break;
			case FB2Tag.STRIKETHROUGH:
				addControl(FBTextKind.STRIKETHROUGH, true);
				break;
			
			case FB2Tag.V:
				pushKind(FBTextKind.VERSE);
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
				
			case FB2Tag.TEXT_AUTHOR:
				pushKind(FBTextKind.AUTHOR);
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
				
			case FB2Tag.SUBTITLE:
				pushKind(FBTextKind.SUBTITLE);
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			case FB2Tag.DATE:
				pushKind(FBTextKind.DATE);
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			
			case FB2Tag.EMPTY_LINE:
				beginParagraph(ZLTextParagraph.Kind.EMPTY_LINE_PARAGRAPH);
				endParagraph();
				break;
			
			case FB2Tag.CITE:
				pushKind(FBTextKind.CITE);
				break;
			case FB2Tag.EPIGRAPH:
				pushKind(FBTextKind.EPIGRAPH);
				break;
			
			case FB2Tag.POEM:
				myInsidePoem = true;
				break;	
			
			case FB2Tag.STANZA:
				pushKind(FBTextKind.STANZA);
				beginParagraph(ZLTextParagraph.Kind.BEFORE_SKIP_PARAGRAPH);
				endParagraph();
				break;
				
			case FB2Tag.SECTION:
				if (myReadMainText) {
					insertEndOfSectionParagraph();
					++mySectionDepth;
					beginContentsParagraph();
					mySectionStarted = true;
				}
				break;
			
			case FB2Tag.ANNOTATION:
				if (myBodyCounter == 0) {
					setMainTextModel();
				}
				pushKind(FBTextKind.ANNOTATION);
				break;
			
			case FB2Tag.TITLE:
				if (myInsidePoem) {
					pushKind(FBTextKind.POEM_TITLE);
				} else if (mySectionDepth == 0) {
					insertEndOfSectionParagraph();
					pushKind(FBTextKind.TITLE);
				} else {
					pushKind(FBTextKind.SECTION_TITLE);
					myInsideTitle = true;
					enterTitle();
				}
				break;
				
			case FB2Tag.BODY:
				++myBodyCounter;
				myParagraphsBeforeBodyNumber = Model.BookTextModel.getParagraphsNumber();
				if ((myBodyCounter == 1) || (attributes.getValue(""name"") == null)) {
					setMainTextModel();
					myReadMainText = true;
				}
				pushKind(FBTextKind.REGULAR);
				break;
			
			case FB2Tag.A:
				if (myHrefAttribute != null) {
					String ref = attributes.getValue(myHrefAttribute);
					String type = attributes.getValue(""type"");
					if ((ref != null) && (ref.length() != 0)) {
						if (ref.charAt(0) == '#') {
							myHyperlinkType = ""note"".equals(type) ? FBTextKind.FOOTNOTE : FBTextKind.INTERNAL_HYPERLINK;
							ref = ref.substring(1);
						} else {
							myHyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
						}
						addHyperlinkControl(myHyperlinkType, ref);
					} else {
						myHyperlinkType = FBTextKind.FOOTNOTE;
						addControl(myHyperlinkType, true);
					}
				}
				break;
			
			case FB2Tag.COVERPAGE:
				if (myBodyCounter == 0) {
					myInsideCoverpage = true;
					setMainTextModel();
				}
				break;	
			
			case FB2Tag.IMAGE:
				if (myHrefAttribute != null) {
					String imgRef = attributes.getValue(myHrefAttribute);
					if ((imgRef != null) && (imgRef.length() != 0) && (imgRef.charAt(0) == '#')) {
						String vOffset = attributes.getValue(""voffset"");
						short offset = 0;
						try {
							offset = Short.parseShort(vOffset);
						} catch (NumberFormatException e) {
						}
						imgRef = imgRef.substring(1);
						if (!imgRef.equals(myCoverImageReference) ||
								myParagraphsBeforeBodyNumber != Model.BookTextModel.getParagraphsNumber()) {
							addImageReference(imgRef, offset);
						}
						if (myInsideCoverpage) {
							myCoverImageReference = imgRef;
						}
					}
				}
				break;
			
			case FB2Tag.BINARY:			
				String contentType = attributes.getValue(""content-type"");
				String imgId = attributes.getValue(""id"");
				if ((contentType != null) && (id != null)) {
					myCurrentImage = new Base64EncodedImage(contentType);
					addImage(imgId, myCurrentImage);
				}
				break;	
				
			default:
				break;
		}
		return false;
	}

	public boolean processNamespaces() {
		return true;
	}

	public void namespaceMapChangedHandler(HashMap<String,String> namespaceMap) {
		myHrefAttribute = null;
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			if (""http://www.w3.org/1999/xlink"".equals(entry.getValue())) {
				myHrefAttribute = (entry.getKey() + "":href"").intern();
				break;
			}
		}
	}

	public void addExternalEntities(HashMap<String,char[]> entityMap) {
		entityMap.put(""FBReaderVersion"", ZLibrary.Instance().getVersionName().toCharArray());
	}

	public List<String> externalDTDs() {
		return Collections.emptyList();
	}
}
",True,134,1,1,7,29,2,14,L3
18,org.geometerplus.fbreader.formats.fb2.FB2TagManager.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Tag;

abstract class FB2TagManager {
	private static final HashMap<String,ArrayList<Tag>> ourMap = new HashMap<String,ArrayList<Tag>>();

	static ArrayList<Tag> humanReadableTags(String id) {
		if (ourMap.isEmpty()) {
			new FB2TagInfoReader().read(
				ZLResourceFile.createResourceFile(""data/formats/fb2/fb2genres.xml"")
			);
		}
		return ourMap.get(id);
	}

	private FB2TagManager() {
	}

	private static class FB2TagInfoReader extends ZLXMLReaderAdapter {
		private final String myLanguage;
		private Tag myCategoryTag;
		private Tag mySubCategoryTag;
		private final ArrayList<String> myGenreIds = new ArrayList<String>();

		FB2TagInfoReader() {
			final String language = Locale.getDefault().getLanguage();
			myLanguage = (""ru"".equals(language)) ? ""ru"" : ""en"";
		}

		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			if ((tag == ""subgenre"") || (tag == ""genre-alt"")) {
				final String id = attributes.getValue(""value"");
				if (id != null) {
					myGenreIds.add(id);
				}
			} else if (tag == ""root-descr"") {
				if (myLanguage == attributes.getValue(""lang"")) {
					myCategoryTag = Tag.getTag(null, attributes.getValue(""genre-title""));
				}
			} else if (tag == ""genre-descr"") {
				if (myLanguage == attributes.getValue(""lang"")) {
					mySubCategoryTag = Tag.getTag(myCategoryTag, attributes.getValue(""title""));
				}
			}
			return false;
		}

		public boolean endElementHandler(String tag) {
			if (tag == ""genre"") {
				myCategoryTag = null;
				mySubCategoryTag = null;
				myGenreIds.clear();
			} else if (tag == ""subgenre"") {
				if (mySubCategoryTag != null) {
					for (String id : myGenreIds) {
						ArrayList<Tag> list = ourMap.get(id);
						if (list == null) {
							list = new ArrayList<Tag>();
							ourMap.put(id, list);
						}
						list.add(mySubCategoryTag);
					}
				}
				mySubCategoryTag = null;
				myGenreIds.clear();
			}
			return false;
		}
	}
}
",True,187,13,42,6,8,1,4,L3
19,org.geometerplus.fbreader.formats.fb2.FB2Plugin.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class FB2Plugin extends FormatPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		return ""fb2"".equals(file.getExtension());
	}
	
	@Override
	public boolean readMetaInfo(Book book) {
		return new FB2MetaInfoReader(book).readMetaInfo();
	}
	
	@Override
	public boolean readModel(BookModel model) {
		return new FB2Reader(model).readBook();
	}

	@Override
	public ZLImage readCover(Book book) {
		return new FB2CoverReader().readCover(book.File);
	}
}
",False,133,0,0,7,35,1,8,L3
20,org.geometerplus.fbreader.formats.fb2.FB2CoverReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.constants.XMLNamespace;


public class FB2CoverReader extends ZLXMLReaderAdapter {

	private boolean myReadCoverPage;
	private String myImageReference;
	private Base64EncodedImage myImage;


	public ZLImage readCover(ZLFile file) {
		myReadCoverPage = false;
		myImageReference = null;
		read(file);
		return myImage;
	}


	private String myXLinkPrefix;

	@Override
	public boolean processNamespaces() {
		return true;
	}

	public void namespaceMapChangedHandler(HashMap<String,String> namespaceMap) {
		myXLinkPrefix = null;
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			if (XMLNamespace.XLink.equals(entry.getValue())) {
				myXLinkPrefix = entry.getKey() + "":"";
				break;
			}
		}
	}


	@Override
	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (FB2Tag.getTagByName(tagName)) {
		case FB2Tag.COVERPAGE:
			myReadCoverPage = true;
			break;
		case FB2Tag.IMAGE:
			if (myReadCoverPage) {
				if (myXLinkPrefix == null) {
					break;
				}
				final String href = attributes.getValue((myXLinkPrefix + ""href"").intern());
				if (href != null && href.length() > 1 && href.charAt(0) == '#') {
					myImageReference = href.substring(1);
				}
			}
			break;
		case FB2Tag.BINARY:
			if (myImageReference != null) {
				final String id = attributes.getValue(""id"");
				final String contentType = attributes.getValue(""content-type"");
				if (id != null && contentType != null && myImageReference.equals(id)) {
					// FIXME: make different Base64EncodedImage constructor to use another cache for covers
					myImage = new Base64EncodedImage((contentType != null) ? contentType : ""image/auto"");
				}
			}
			break;
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		switch (FB2Tag.getTagByName(tag)) {
		case FB2Tag.COVERPAGE:
			myReadCoverPage = false;
			break;
		case FB2Tag.DESCRIPTION:
			if (myImageReference == null) {
				return true;
			}
			break;
		case FB2Tag.BINARY:
			if (myImage != null) {
				myImage.close();
				return true;
			}
			break;
		}	
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int length) {
		if (length > 0 && myImage != null) {
			myImage.addData(data, start, length);
		}
	}
}
",False,197,12,42,5,11,1,7,L3
21,org.geometerplus.fbreader.formats.pdb.MobipocketHtmlBookReader.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.util.*;
import java.io.*;
import java.nio.charset.CharsetDecoder;

import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.html.ZLByteBuffer;
import org.geometerplus.zlibrary.core.html.ZLHtmlAttributeMap;

import org.geometerplus.fbreader.formats.html.HtmlReader;
import org.geometerplus.fbreader.formats.html.HtmlTag;
import org.geometerplus.fbreader.bookmodel.BookModel;

public class MobipocketHtmlBookReader extends HtmlReader {
	private final CharsetDecoder myTocDecoder;
	private MobipocketStream myMobipocketStream;

	MobipocketHtmlBookReader(BookModel model) throws UnsupportedEncodingException {
		super(model);
		myTocDecoder = createDecoder();
	}

	public InputStream getInputStream() throws IOException {
		myMobipocketStream = new MobipocketStream(Model.Book.File);
		return myMobipocketStream;
	}

	private boolean myReadGuide;
	private int myTocStartOffset = Integer.MAX_VALUE;
	private int myTocEndOffset = Integer.MAX_VALUE;
	private final TreeMap<Integer,String> myTocEntries = new TreeMap<Integer,String>();
	private final TreeMap<Integer,Integer> myPositionToParagraph = new TreeMap<Integer,Integer>();
	private final TreeSet<Integer> myFileposReferences = new TreeSet<Integer>();
	private int myCurrentTocPosition = -1;
	private final ZLByteBuffer myTocBuffer = new ZLByteBuffer();

	private boolean tocRangeContainsPosition(int position) {
		return (myTocStartOffset <= position) && (position < myTocEndOffset);
	}

	@Override
	public void startElementHandler(byte tag, int offset, ZLHtmlAttributeMap attributes) {
		final int paragraphIndex = Model.BookTextModel.getParagraphsNumber();
		myPositionToParagraph.put(offset, paragraphIsOpen() ? paragraphIndex - 1 : paragraphIndex);
		switch (tag) {
			case HtmlTag.IMG:
			{
				final ZLByteBuffer recIndex = attributes.getValue(""recindex"");
				if (recIndex != null) {
					try {
						final int index = Integer.parseInt(recIndex.toString());
						if (paragraphIsOpen()) {
							endParagraph();
							addImageReference("""" + index);
							beginParagraph();
						} else {
							addImageReference("""" + index);
						}
					} catch (NumberFormatException e) {
					}
				}
				break;
			}
			case HtmlTag.GUIDE:
				myReadGuide = true;
				break;
			case HtmlTag.REFERENCE:
				if (myReadGuide) {
					final ZLByteBuffer fp = attributes.getValue(""filepos"");
					final ZLByteBuffer title = attributes.getValue(""title"");
					if ((fp != null) && (title != null)) {
						try {
							int filePosition = Integer.parseInt(fp.toString());
							myTocEntries.put(filePosition, title.toString(myAttributeDecoder));
							if (tocRangeContainsPosition(filePosition)) {
								myTocEndOffset = filePosition;
							}
							if (attributes.getValue(""type"").equalsToLCString(""toc"")) {
								myTocStartOffset = filePosition;
								final SortedMap<Integer,String> subMap =
									myTocEntries.tailMap(filePosition + 1);
								if (!subMap.isEmpty()) {
									myTocEndOffset = subMap.firstKey();
								}
							}
						} catch (NumberFormatException e) {
						}
					}
				}
				break;
			case HtmlTag.A:
			{
				final ZLByteBuffer fp = attributes.getValue(""filepos"");
				if (fp != null) {
					try {
						int filePosition = Integer.parseInt(fp.toString());
						if (tocRangeContainsPosition(offset)) {
							myCurrentTocPosition = filePosition;
							if (tocRangeContainsPosition(filePosition)) {
								myTocEndOffset = filePosition;
							}
						}
						myFileposReferences.add(filePosition);
						// TODO: add hyperlink control
					} catch (NumberFormatException e) {
					}
				}
				super.startElementHandler(tag, offset, attributes);
				break;
			}
			default:
				super.startElementHandler(tag, offset, attributes);
				break;
		}
	}

	@Override
	public void endElementHandler(byte tag) {
		switch (tag) {
			case HtmlTag.IMG:
				break;
			case HtmlTag.GUIDE:
				myReadGuide = false;
				break;
			case HtmlTag.REFERENCE:
				break;
			case HtmlTag.A:
				if (myCurrentTocPosition != -1) {
					if (!myTocBuffer.isEmpty()) {
						myTocEntries.put(myCurrentTocPosition, myTocBuffer.toString(myTocDecoder));
						myTocBuffer.clear();
					}
					myCurrentTocPosition = -1;
				}
				super.endElementHandler(tag);
				break;
			default:
				super.endElementHandler(tag);
				break;
		}
	}

	@Override
	public void byteDataHandler(byte[] data, int start, int length) {
		if (myCurrentTocPosition != -1) {
			myTocBuffer.append(data, start, length);
		}
		super.addByteData(data, start, length);
	}

	@Override
	public void startDocumentHandler() {
		super.startDocumentHandler();

		for (int index = 0; ; ++index) {
			final int offset = myMobipocketStream.getImageOffset(index);
			if (offset < 0) {
				break;
			}
			final int length = myMobipocketStream.getImageLength(index);
			if (length <= 0) {
				break;
			}
			addImage("""" + index, new ZLFileImage(""image/auto"", Model.Book.File, offset, length));
		}
	}

	@Override
	public void endDocumentHandler() {
		for (Map.Entry<Integer,String> entry : myTocEntries.entrySet()) {
			final SortedMap<Integer,Integer> subMap =
				myPositionToParagraph.tailMap(entry.getKey());
			if (subMap.isEmpty()) {
				break;
			}
			beginContentsParagraph(subMap.get(subMap.firstKey()));
			addContentsData(entry.getValue().toCharArray());
			endContentsParagraph();
		}
		super.endDocumentHandler();
	}
}
",True,133,0,0,7,36,1,10,L3
22,org.geometerplus.fbreader.formats.pdb.PdbStream.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.util.ZLInputStreamWithOffset;

public abstract class PdbStream extends InputStream {
	protected final ZLInputStreamWithOffset myBase;
	public PdbHeader myHeader;
	protected byte[] myBuffer;

	protected short myBufferLength;
	protected short myBufferOffset;

	public PdbStream(ZLFile file) throws IOException {
		myBase = new ZLInputStreamWithOffset(file.getInputStream());

		myHeader = new PdbHeader(myBase);

		myBase.skip(myHeader.Offsets[0] - myHeader.length());

		myBufferLength = 0;
		myBufferOffset = 0;
	}
	
	public int read() {
		if (!fillBuffer()) {
			return -1;
		}
		return myBuffer[myBufferOffset++];
	}

	public int read(byte[] buffer, int offset, int maxSize) {
		int realSize = 0;
		while (realSize < maxSize) {
			if (!fillBuffer()) {
				break;
			}
			int size = Math.min(maxSize - realSize, myBufferLength - myBufferOffset);
			if (size > 0) {
				if (buffer != null) {
					System.arraycopy(myBuffer, myBufferOffset, buffer, offset + realSize, size);
				}
				realSize += size;
				myBufferOffset += size;
			}
		}
		return (realSize > 0) ? realSize : -1;
	}
	
	public void close() throws IOException {
		if (myBase != null) {
			myBase.close();
		}
		if (myBuffer != null) {
			myBuffer = null;
		}
	}

	public void skip(int offset) throws IOException {
		if (offset > 0) {
			read(null, 0, offset);
		} else {
			throw new IOException(""Cannot skip: "" + offset + "" bytes"");
		}
	}

	protected abstract boolean fillBuffer();
}
",True,184,13,42,5,7,3,3,L3
23,org.geometerplus.fbreader.formats.pdb.PdbPlugin.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.fbreader.formats.FormatPlugin;

public abstract class PdbPlugin extends FormatPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		final String extension = file.getExtension();
		return (extension == ""prc"") || (extension == ""pdb"") || (extension == ""mobi"");
	}

	protected static String fileType(final ZLFile file) {
		// TODO: use database instead of option (?)
		ZLStringOption palmTypeOption = new ZLStringOption(file.getPath(), ""PalmType"", """");
		String palmType = palmTypeOption.getValue();
		if (palmType.length() != 8) {
			byte[] id = new byte[8];
			try {
				final InputStream stream = file.getInputStream();
				if (stream == null) {
					return null;
				}
				stream.skip(60);
				stream.read(id);
				stream.close();
			} catch (IOException e) {
			}
			palmType = new String(id).intern();
			palmTypeOption.setValue(palmType);
		}
		return palmType.intern();
	}
}
",True,134,1,1,8,27,2,3,L3
24,org.geometerplus.fbreader.formats.pdb.MobipocketPlugin.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.encoding.ZLEncodingCollection;
import org.geometerplus.zlibrary.core.util.ZLLanguageUtil;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.bookmodel.BookModel;

public class MobipocketPlugin extends PdbPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		return super.acceptsFile(file) && (fileType(file) == ""BOOKMOBI"");
	}

	@Override
	public boolean readMetaInfo(Book book) {
		InputStream stream = null;
		try {
			stream = book.File.getInputStream();
			final PdbHeader header = new PdbHeader(stream);
			PdbUtil.skip(stream, header.Offsets[0] + 16 - header.length());
			if (PdbUtil.readInt(stream) != 0x4D4F4249) /* ""MOBI"" */ {
				return false;
			}
			final int length = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 4);
			final int encodingCode = (int)PdbUtil.readInt(stream);
			String encodingName = ZLEncodingCollection.Instance().getEncodingName(encodingCode);
			if (encodingName == null) {
				encodingName = ""utf-8"";
			}
			book.setEncoding(encodingName);
			PdbUtil.skip(stream, 52);
			final int fullNameOffset = (int)PdbUtil.readInt(stream);
			final int fullNameLength = (int)PdbUtil.readInt(stream);
			final int languageCode = (int)PdbUtil.readInt(stream);
			book.setLanguage(ZLLanguageUtil.languageByCode(languageCode & 0xFF, (languageCode >> 8) & 0xFF));
			PdbUtil.skip(stream, 32);
			int offset = 132;
			if ((PdbUtil.readInt(stream) & 0x40) != 0) {
				PdbUtil.skip(stream, length - 116);
				offset = length + 20;
				if (PdbUtil.readInt(stream) == 0x45585448) /* ""EXTH"" */ {
					PdbUtil.skip(stream, 4);
					final int recordsNumber = (int)PdbUtil.readInt(stream);
					offset += 8;
					for (int i = 0; i < recordsNumber; ++i) {
						final int type = (int)PdbUtil.readInt(stream);
						final int size = (int)PdbUtil.readInt(stream);
						offset += size;
						if (size <= 8) {
							continue;
						}
						switch (type) {
							default:
								PdbUtil.skip(stream, size - 8);
								break;
							case 100:
							{
								final byte[] buffer = new byte[size - 8];
								stream.read(buffer);
								String author = new String(buffer, encodingName);
								final int index = author.indexOf(',');
								if (index != -1) {
									author = author.substring(index + 1).trim() +
											 ' ' +
											 author.substring(0, index).trim(); 
								} else {
									author = author.trim();
								}
								book.addAuthor(author);
								break;
							}
							case 105:
							{
								final byte[] buffer = new byte[size - 8];
								stream.read(buffer);
								book.addTag(new String(buffer, encodingName));
								break;
							}
						}
					}
				}
			}
			PdbUtil.skip(stream, fullNameOffset - offset);
			final byte[] titleBuffer = new byte[fullNameLength];
			stream.read(titleBuffer);
			book.setTitle(new String(titleBuffer, encodingName));
			return true;
		} catch (IOException e) {
			return false;
		} finally {
			if (stream != null) {
				try {
					stream.close();
				} catch (IOException e) {
				}
			}
		}
	}

	@Override
	public boolean readModel(BookModel model) {
		try {
			return new MobipocketHtmlBookReader(model).readBook();
		} catch (IOException e) {
			//e.printStackTrace();
			return false;
		}
	}

	@Override
	public ZLImage readCover(Book book) {
		InputStream stream = null;
		try {
			stream = book.File.getInputStream();
			final PdbHeader header = new PdbHeader(stream);
			PdbUtil.skip(stream, header.Offsets[0] + 16 - header.length());
			if (PdbUtil.readInt(stream) != 0x4D4F4249) /* ""MOBI"" */ {
				return null;
			}
			final int length = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 104);

			final int exthFlags = (int)PdbUtil.readInt(stream);
			int coverIndex = -1;
			int thumbIndex = -1;

			int offset = 132;
			if ((exthFlags & 0x40) != 0) {
				PdbUtil.skip(stream, length - 116);
				offset = length + 20;
				if (PdbUtil.readInt(stream) != 0x45585448) /* ""EXTH"" */ {
					return null;
				}
				PdbUtil.skip(stream, 4);
				final int recordsNumber = (int)PdbUtil.readInt(stream);
				offset += 8;
				for (int i = 0; i < recordsNumber; ++i) {
					final int type = (int)PdbUtil.readInt(stream);
					final int size = (int)PdbUtil.readInt(stream);
					offset += size;
					if (size <= 8) {
						continue;
					}
					switch (type) {
						default:
							PdbUtil.skip(stream, size - 8);
							break;
						case 201:
						{
							if (size == 12) {
								coverIndex = (int)PdbUtil.readInt(stream);
							} else {
								PdbUtil.skip(stream, size - 8);
							}
							break;
						}
						case 202:
						{
							if (size == 12) {
								thumbIndex = (int)PdbUtil.readInt(stream);
							} else {
								PdbUtil.skip(stream, size - 8);
							}
							break;
						}
					}
				}
			}
			final InputStream tempStream = stream;
			stream = null;
			tempStream.close();

			if (coverIndex == -1) {
				if (thumbIndex == -1) {
					return null;
				}
				coverIndex = thumbIndex;
			}

			final ZLFile file = book.File;
			final MobipocketStream mpStream = new MobipocketStream(file);

			// TODO: implement
			/*int index = pbStream.firstImageLocationIndex(file.path());
			if (index >= 0) {
				std::pair<int,int> imageLocation = pbStream.imageLocation(pbStream.header(), index + coverIndex);
				if ((imageLocation.first > 0) && (imageLocation.second > 0)) {
					return new ZLFileImage(
						file,
						imageLocation.first,
						imageLocation.second
					);
				}
			}*/
			return null; 
		} catch (IOException e) {
			return null;
		} finally {
			if (stream != null) {
				try {
					stream.close();
				} catch (IOException e) {
				}
			}
		}
	}
}
",True,133,0,0,7,38,1,12,L3
25,org.geometerplus.fbreader.formats.pdb.PdbUtil.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class PdbUtil {
	public static void skip(InputStream stream, int numBytes) throws IOException {
		numBytes -= stream.skip(numBytes);
		for (; numBytes > 0; --numBytes) {
			if (stream.read() == -1) {
				throw new IOException(""Unexpected end of stream"");
			}
		}
	}

	public static int readShort(InputStream stream) throws IOException {
		final byte[] tmp = new byte[2];
		stream.read(tmp, 0, 2);
		return (tmp[1] & 0xFF) + ((tmp[0] & 0xFF) << 8);
	}

	public static long readInt(InputStream stream) throws IOException {
		final byte[] tmp = new byte[4];
		stream.read(tmp, 0, 4);
		return (((long)(tmp[0] & 0xFF)) << 24) +
			  + ((tmp[1] & 0xFF) << 16) +
			  + ((tmp[2] & 0xFF) << 8) +
			  + (tmp[3] & 0xFF);
	}
}
",True,162,12,42,0,0,5,0,L3
26,org.geometerplus.fbreader.formats.pdb.MobipocketStream.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

class MobipocketStream extends PalmDocLikeStream {
	private final int myFileSize;

	MobipocketStream(ZLFile file) throws IOException {
		super(file);
		myFileSize = (int)file.size();

		myCompressionType = PdbUtil.readShort(myBase);
		PdbUtil.skip(myBase, 6);
		myMaxRecordIndex = Math.min(PdbUtil.readShort(myBase), myHeader.Offsets.length - 1);
		final int maxRecordSize = PdbUtil.readShort(myBase);
		if (maxRecordSize == 0) {
			throw new IOException(""The records are too short"");
		}
		myBuffer = new byte[maxRecordSize];
		myRecordIndex = 0;
	}

	int getImageOffset(int index) {
		try {
			return myHeader.Offsets[index + myMaxRecordIndex + 1];
		} catch (ArrayIndexOutOfBoundsException e) {
			return -1;
		}
	}

	int getImageLength(int index) {
		try {
			final int i = index + myMaxRecordIndex + 1;
			final int start = myHeader.Offsets[i];
			final int end = (i == myHeader.Offsets.length) ? myFileSize : myHeader.Offsets[i + 1];
			return end - start;
		} catch (ArrayIndexOutOfBoundsException e) {
			return -1;
		}
	}
}
",False,184,12,42,5,7,2,5,L3
27,org.geometerplus.fbreader.formats.pdb.PdbHeader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

public class PdbHeader {
	public final String DocName;
	public final int Flags;
	public final String Id;
	public final int[] Offsets;

	public PdbHeader(InputStream stream) throws IOException {
		final byte[] buffer = new byte[32];
		if (stream.read(buffer, 0, 32) != 32) {
			throw new IOException(""PdbHeader: cannot reader document name"");
		}
		DocName = new String(buffer);
		Flags = PdbUtil.readShort(stream);

		PdbUtil.skip(stream, 26);
		
		if (stream.read(buffer, 0, 8) != 8) {
			throw new IOException(""PdbHeader: cannot reader palm id"");
		}
		Id = new String(buffer, 0, 8);

		PdbUtil.skip(stream, 8);

		int numRecords = PdbUtil.readShort(stream);
		if (numRecords <= 0) {
			throw new IOException(""PdbHeader: record number = "" + numRecords);
		}
		Offsets = new int[numRecords];

		for (int i = 0; i < numRecords; ++i) {
			Offsets[i] = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 4);
		}
	}

	public final int length() {
		return 78 + Offsets.length * 8;
	}
}
",False,162,12,42,1,1,6,1,L3
28,org.geometerplus.fbreader.formats.pdb.PalmDocLikeStream.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

abstract class PalmDocLikeStream extends PdbStream {
	protected int myMaxRecordIndex;
	protected int myRecordIndex;
	protected interface CompressionType {
		int NONE = 1;
		int DOC = 2;
		int HUFFDIC = 17480;
	}
	protected int myCompressionType;

	private final long myFileSize;

	PalmDocLikeStream(ZLFile file) throws IOException {
		super(file);
		myFileSize = file.size();
	}

	protected final boolean fillBuffer() {
		while (myBufferOffset == myBufferLength) {
			if (myRecordIndex + 1 > myMaxRecordIndex) {
				return false;
			}
			++myRecordIndex;
			final int currentOffset = myHeader.Offsets[myRecordIndex];

			try {
				myBase.skip(currentOffset - myBase.offset());
				final int nextOffset =
					(myRecordIndex + 1 < myHeader.Offsets.length) ?
						myHeader.Offsets[myRecordIndex + 1] :
						(int)myFileSize;
				if (nextOffset < currentOffset) {
					return false;
				}
				final short recordSize = (short)Math.min(nextOffset - currentOffset, myBuffer.length);

				switch (myCompressionType) {
					case CompressionType.NONE:
						myBase.read(myBuffer, 0, recordSize);
						myBufferLength = recordSize;
						break;
					case CompressionType.DOC:
						myBufferLength = (short)DocDecompressor.decompress(myBase, myBuffer, recordSize);
						break;
					//case CompressionType.HUFFDIC:
					//	myBufferLength = (short)HuffdicDecompressor.decompress(myBase, myBuffer, recordSize);
					//	break;
					default:
						// Unsupported compression type
						return false;
				}
			} catch (IOException e) {
				return false;
			}
			myBufferOffset = 0;
		}
		
		return true;
	}
}
",True,184,13,42,5,7,1,5,L3
29,org.geometerplus.fbreader.formats.pdb.HuffdicDecompressor.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class HuffdicDecompressor {
	public static int decompress(InputStream stream, byte[] targetBuffer, int compressedSize) throws IOException {
		final byte[] sourceBuffer = new byte[compressedSize];

		if (stream.read(sourceBuffer) != compressedSize) {
			return 0;
		}

		int sourceIndex = 0;
		int targetIndex = 0;

		int count0 = 0;
		int count1 = 0;
		int count2 = 0;
		int count3 = 0;
		try {
			while (true) {
				final byte token = sourceBuffer[sourceIndex++];
				switch (token) {
					default:
						++count0;
						targetBuffer[targetIndex++] = token;
						break;
					case 1: case 2: case 3: case 4:
					case 5: case 6: case 7: case 8:
						++count1;
						System.arraycopy(sourceBuffer, sourceIndex, targetBuffer, targetIndex, token);
						sourceIndex += token;
						targetIndex += token;
						break;
					case -64: case -63: case -62: case -61:
					case -60: case -59: case -58: case -57:
					case -56: case -55: case -54: case -53:
					case -52: case -51: case -50: case -49:
					case -48: case -47: case -46: case -45:
					case -44: case -43: case -42: case -41:
					case -40: case -39: case -38: case -37:
					case -36: case -35: case -34: case -33:
					case -32: case -31: case -30: case -29:
					case -28: case -27: case -26: case -25:
					case -24: case -23: case -22: case -21:
					case -20: case -19: case -18: case -17:
					case -16: case -15: case -14: case -13:
					case -12: case -11: case -10: case -9:
					case -8: case -7: case -6: case -5:
					case -4: case -3: case -2: case -1:
						++count2;
						targetBuffer[targetIndex++] = ' ';
						targetBuffer[targetIndex++] = (byte)(token ^ 0x80);
						break;
					case -128: case -127: case -126: case -125:
					case -124: case -123: case -122: case -121:
					case -120: case -119: case -118: case -117:
					case -116: case -115: case -114: case -113:
					case -112: case -111: case -110: case -109:
					case -108: case -107: case -106: case -105:
					case -104: case -103: case -102: case -101:
					case -100: case -99: case -98: case -97:
					case -96: case -95: case -94: case -93:
					case -92: case -91: case -90: case -89:
					case -88: case -87: case -86: case -85:
					case -84: case -83: case -82: case -81:
					case -80: case -79: case -78: case -77:
					case -76: case -75: case -74: case -73:
					case -72: case -71: case -70: case -69:
					case -68: case -67: case -66: case -65:
						++count3;
						final int N = ((token & 0x3F) << 8) + (sourceBuffer[sourceIndex++] & 0xFF);
						int copyLength = (N & 7) + 3;
						int srcIndex = targetIndex - (N >> 3);
						if (targetIndex >= srcIndex + copyLength) {
							System.arraycopy(targetBuffer, srcIndex, targetBuffer, targetIndex, copyLength);
							targetIndex += copyLength;
						} else {
							while (copyLength-- > 0) {
								targetBuffer[targetIndex++] = targetBuffer[srcIndex++];
							}
						}
						break;
				}
			}
		} catch (Exception e) {
			if (targetIndex > targetBuffer.length) {
				targetIndex = targetBuffer.length;
			}
		}

		return targetIndex;
	}
}
",True,1,0,0,0,0,0,0,I0
30,org.geometerplus.fbreader.formats.pdb.DocDecompressor.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class DocDecompressor {
	public static int decompress(InputStream stream, byte[] targetBuffer, int compressedSize) throws IOException {
		final byte[] sourceBuffer = new byte[compressedSize];

		if (stream.read(sourceBuffer) != compressedSize) {
			return 0;
		}

		int sourceIndex = 0;
		int targetIndex = 0;

		int count0 = 0;
		int count1 = 0;
		int count2 = 0;
		int count3 = 0;
		try {
			while (true) {
				final byte token = sourceBuffer[sourceIndex++];
				switch (token) {
					default:
						++count0;
						targetBuffer[targetIndex++] = token;
						break;
					case 1: case 2: case 3: case 4:
					case 5: case 6: case 7: case 8:
						++count1;
						System.arraycopy(sourceBuffer, sourceIndex, targetBuffer, targetIndex, token);
						sourceIndex += token;
						targetIndex += token;
						break;
					case -64: case -63: case -62: case -61:
					case -60: case -59: case -58: case -57:
					case -56: case -55: case -54: case -53:
					case -52: case -51: case -50: case -49:
					case -48: case -47: case -46: case -45:
					case -44: case -43: case -42: case -41:
					case -40: case -39: case -38: case -37:
					case -36: case -35: case -34: case -33:
					case -32: case -31: case -30: case -29:
					case -28: case -27: case -26: case -25:
					case -24: case -23: case -22: case -21:
					case -20: case -19: case -18: case -17:
					case -16: case -15: case -14: case -13:
					case -12: case -11: case -10: case -9:
					case -8: case -7: case -6: case -5:
					case -4: case -3: case -2: case -1:
						++count2;
						targetBuffer[targetIndex++] = ' ';
						targetBuffer[targetIndex++] = (byte)(token ^ 0x80);
						break;
					case -128: case -127: case -126: case -125:
					case -124: case -123: case -122: case -121:
					case -120: case -119: case -118: case -117:
					case -116: case -115: case -114: case -113:
					case -112: case -111: case -110: case -109:
					case -108: case -107: case -106: case -105:
					case -104: case -103: case -102: case -101:
					case -100: case -99: case -98: case -97:
					case -96: case -95: case -94: case -93:
					case -92: case -91: case -90: case -89:
					case -88: case -87: case -86: case -85:
					case -84: case -83: case -82: case -81:
					case -80: case -79: case -78: case -77:
					case -76: case -75: case -74: case -73:
					case -72: case -71: case -70: case -69:
					case -68: case -67: case -66: case -65:
						++count3;
						final int N = ((token & 0x3F) << 8) + (sourceBuffer[sourceIndex++] & 0xFF);
						int copyLength = (N & 7) + 3;
						int srcIndex = targetIndex - (N >> 3);
						if (targetIndex >= srcIndex + copyLength) {
							System.arraycopy(targetBuffer, srcIndex, targetBuffer, targetIndex, copyLength);
							targetIndex += copyLength;
						} else {
							while (copyLength-- > 0) {
								targetBuffer[targetIndex++] = targetBuffer[srcIndex++];
							}
						}
						break;
				}
			}
		} catch (Exception e) {
			if (targetIndex > targetBuffer.length) {
				targetIndex = targetBuffer.length;
			}
		}

		return targetIndex;
	}
}
",True,160,14,42,0,0,3,0,L3
31,org.geometerplus.fbreader.formats.xhtml.XHTMLTagParagraphWithControlAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagParagraphWithControlAction extends XHTMLTagAction {
	final byte myControl;

	XHTMLTagParagraphWithControlAction(byte control) {
		myControl = control;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		if ((myControl == FBTextKind.TITLE) &&
				(modelReader.Model.BookTextModel.getParagraphsNumber() > 1)) {
			modelReader.insertEndOfSectionParagraph();
		}
		modelReader.pushKind(myControl);
		modelReader.beginParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.endParagraph();
		modelReader.popKind();
	}
}
/*
void XHTMLTagParagraphWithControlAction::doAtStart(XHTMLReader &reader, const char**) {
	if ((myControl == TITLE) && (bookReader(reader).model().bookTextModel()->paragraphsNumber() > 1)) {
		bookReader(reader).insertEndOfSectionParagraph();
	}
	bookReader(reader).pushKind(myControl);
	bookReader(reader).beginParagraph();
}
*/
",False,133,0,0,8,31,1,7,L3
32,org.geometerplus.fbreader.formats.xhtml.XHTMLTagAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public abstract class XHTMLTagAction {
	protected abstract void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes);
	protected abstract void doAtEnd(XHTMLReader reader);
};
",False,133,0,0,10,29,10,2,L3
33,org.geometerplus.fbreader.formats.xhtml.XHTMLTagItemAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagItemAction extends XHTMLTagAction {
	private final char[] BULLET = { '\u2022', '\240' };

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.endParagraph();
		// TODO: increase left indent
		modelReader.beginParagraph();
		// TODO: replace bullet sign by number inside OL tag
		modelReader.addData(BULLET);
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
	}
}
",False,133,0,0,9,34,1,4,L3
34,org.geometerplus.fbreader.formats.xhtml.XHTMLReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.util.MiscUtil;

public class XHTMLReader extends ZLXMLReaderAdapter {
	private static final HashMap<String,XHTMLTagAction> ourTagActions = new HashMap<String,XHTMLTagAction>();

	public static XHTMLTagAction addAction(String tag, XHTMLTagAction action) {
		XHTMLTagAction old = (XHTMLTagAction)ourTagActions.get(tag);
		ourTagActions.put(tag, action);
		return old;
	}

	public static void fillTagTable() {
		if (!ourTagActions.isEmpty()) {
			return;
		}

		//addAction(""html"", new XHTMLTagAction());
		addAction(""body"", new XHTMLTagBodyAction());
		//addAction(""title"", new XHTMLTagAction());
		//addAction(""meta"", new XHTMLTagAction());
		//addAction(""script"", new XHTMLTagAction());

		//addAction(""font"", new XHTMLTagAction());
		//addAction(""style"", new XHTMLTagAction());

		addAction(""p"", new XHTMLTagParagraphAction());
		addAction(""h1"", new XHTMLTagParagraphWithControlAction(FBTextKind.H1));
		addAction(""h2"", new XHTMLTagParagraphWithControlAction(FBTextKind.H2));
		addAction(""h3"", new XHTMLTagParagraphWithControlAction(FBTextKind.H3));
		addAction(""h4"", new XHTMLTagParagraphWithControlAction(FBTextKind.H4));
		addAction(""h5"", new XHTMLTagParagraphWithControlAction(FBTextKind.H5));
		addAction(""h6"", new XHTMLTagParagraphWithControlAction(FBTextKind.H6));

		//addAction(""ol"", new XHTMLTagAction());
		//addAction(""ul"", new XHTMLTagAction());
		//addAction(""dl"", new XHTMLTagAction());
		addAction(""li"", new XHTMLTagItemAction());

		addAction(""strong"", new XHTMLTagControlAction(FBTextKind.STRONG));
		addAction(""b"", new XHTMLTagControlAction(FBTextKind.BOLD));
		addAction(""em"", new XHTMLTagControlAction(FBTextKind.EMPHASIS));
		addAction(""i"", new XHTMLTagControlAction(FBTextKind.ITALIC));
		final XHTMLTagAction codeControlAction = new XHTMLTagControlAction(FBTextKind.CODE);
		addAction(""code"", codeControlAction);
		addAction(""tt"", codeControlAction);
		addAction(""kbd"", codeControlAction);
		addAction(""var"", codeControlAction);
		addAction(""samp"", codeControlAction);
		addAction(""cite"", new XHTMLTagControlAction(FBTextKind.CITE));
		addAction(""sub"", new XHTMLTagControlAction(FBTextKind.SUB));
		addAction(""sup"", new XHTMLTagControlAction(FBTextKind.SUP));
		addAction(""dd"", new XHTMLTagControlAction(FBTextKind.DEFINITION_DESCRIPTION));
		addAction(""dfn"", new XHTMLTagControlAction(FBTextKind.DEFINITION));
		addAction(""strike"", new XHTMLTagControlAction(FBTextKind.STRIKETHROUGH));

		addAction(""a"", new XHTMLTagHyperlinkAction());

		addAction(""img"", new XHTMLTagImageAction(""src""));
		addAction(""object"", new XHTMLTagImageAction(""data""));

		//addAction(""area"", new XHTMLTagAction());
		//addAction(""map"", new XHTMLTagAction());

		//addAction(""base"", new XHTMLTagAction());
		//addAction(""blockquote"", new XHTMLTagAction());
		addAction(""br"", new XHTMLTagRestartParagraphAction());
		//addAction(""center"", new XHTMLTagAction());
		addAction(""div"", new XHTMLTagParagraphAction());
		addAction(""dt"", new XHTMLTagParagraphAction());
		//addAction(""head"", new XHTMLTagAction());
		//addAction(""hr"", new XHTMLTagAction());
		//addAction(""link"", new XHTMLTagAction());
		//addAction(""param"", new XHTMLTagAction());
		//addAction(""q"", new XHTMLTagAction());
		//addAction(""s"", new XHTMLTagAction());

		addAction(""pre"", new XHTMLTagPreAction());
		//addAction(""big"", new XHTMLTagAction());
		//addAction(""small"", new XHTMLTagAction());
		//addAction(""u"", new XHTMLTagAction());

		//addAction(""table"", new XHTMLTagAction());
		addAction(""td"", new XHTMLTagParagraphAction());
		addAction(""th"", new XHTMLTagParagraphAction());
		//addAction(""tr"", new XHTMLTagAction());
		//addAction(""caption"", new XHTMLTagAction());
		//addAction(""span"", new XHTMLTagAction());
	}

	private final BookReader myModelReader;
	String myPathPrefix;
	String myLocalPathPrefix;
	String myReferencePrefix;
	boolean myPreformatted;
	boolean myInsideBody;
	private final Map<String,Integer> myFileNumbers;

	public XHTMLReader(BookReader modelReader, Map<String,Integer> fileNumbers) {
		myModelReader = modelReader;
		myFileNumbers = fileNumbers;
	}

	final BookReader getModelReader() {
		return myModelReader;
	}

	public final String getFileAlias(String fileName) {
		fileName = MiscUtil.decodeHtmlReference(fileName);
		Integer num = myFileNumbers.get(fileName);
		if (num == null) {
			num = myFileNumbers.size();
			myFileNumbers.put(fileName, num);
		}
		return num.toString();
	}

	public boolean readFile(ZLFile file, String referencePrefix) {
		fillTagTable();

		myReferencePrefix = referencePrefix;

		myPathPrefix = MiscUtil.htmlDirectoryPrefix(file);
		myLocalPathPrefix = MiscUtil.archiveEntryName(myPathPrefix);

		myPreformatted = false;
		myInsideBody = false;

		return read(file);
	}

	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		String id = attributes.getValue(""id"");
		if (id != null) {
			myModelReader.addHyperlinkLabel(myReferencePrefix + id);
		}

		XHTMLTagAction action = (XHTMLTagAction)ourTagActions.get(tag.toLowerCase());
		if (action != null) {
			action.doAtStart(this, attributes);
		}
		return false;
	}

	public boolean endElementHandler(String tag) {
		XHTMLTagAction action = (XHTMLTagAction)ourTagActions.get(tag.toLowerCase());
		if (action != null) {
			action.doAtEnd(this);
		}
		return false;
	}

	public void characterDataHandler(char[] data, int start, int len) {
		if (myPreformatted) {
			final char first = data[start]; 
			if ((first == '\r') || (first == '\n')) {
				myModelReader.addControl(FBTextKind.CODE, false);
				myModelReader.endParagraph();
				myModelReader.beginParagraph();
				myModelReader.addControl(FBTextKind.CODE, true);
			}
			int spaceCounter = 0;
cycle:
			while (spaceCounter < len) {
				switch (data[start + spaceCounter]) {
					case 0x08:
					case 0x09:
					case 0x0A:
					case 0x0B:
					case 0x0C:
					case 0x0D:
					case ' ':
						break;
					default:
						break cycle;
				}
				++spaceCounter;
			}
			myModelReader.addFixedHSpace((short)spaceCounter);
			start += spaceCounter;
			len -= spaceCounter;
		}
		if (len > 0) {
			if (myInsideBody && !myModelReader.paragraphIsOpen()) {
				myModelReader.beginParagraph();
			}
			myModelReader.addData(data, start, len, false);
		}
	}

	private static ArrayList<String> ourExternalDTDs = new ArrayList<String>();

	public static List<String> xhtmlDTDs() {
		if (ourExternalDTDs.isEmpty()) {
			ourExternalDTDs.add(""data/formats/xhtml/xhtml-lat1.ent"");
			ourExternalDTDs.add(""data/formats/xhtml/xhtml-special.ent"");
			ourExternalDTDs.add(""data/formats/xhtml/xhtml-symbol.ent"");
		}
		return ourExternalDTDs;
	}

	public List<String> externalDTDs() {
		return xhtmlDTDs();
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}

	public boolean processNamespaces() {
		return true;
	}

	public void namespaceMapChangedHandler(HashMap<String,String> namespaceMap) {
	}
}
",False,245,10,33,9,29,13,16,L3
35,org.geometerplus.fbreader.formats.xhtml.XHTMLTagImageAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.fbreader.formats.util.MiscUtil;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagImageAction extends XHTMLTagAction {
	private final String myNameAttribute;

	XHTMLTagImageAction(String nameAttribute) {
		myNameAttribute = nameAttribute;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		String fileName = xmlattributes.getValue(myNameAttribute);
		if (fileName != null) {
			fileName = MiscUtil.decodeHtmlReference(fileName);
			final ZLFile imageFile = ZLFile.createFileByPath(reader.myPathPrefix + fileName);
			if (imageFile != null) {
				final BookReader modelReader = reader.getModelReader();
				boolean flag = modelReader.paragraphIsOpen() && !modelReader.paragraphIsNonEmpty();
				if (flag) {
					modelReader.endParagraph();
				}
				final String imageName = imageFile.getName(false);
				modelReader.addImageReference(imageName, (short)0);
				modelReader.addImage(imageName, new ZLFileImage(""image/auto"", imageFile));
				if (flag) {
					modelReader.beginParagraph();
				}
			}
		}
	}

	protected void doAtEnd(XHTMLReader reader) {
	}
}
",False,133,0,0,9,31,1,7,L3
36,org.geometerplus.fbreader.formats.xhtml.XHTMLTagHyperlinkAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.util.ZLArrayUtils;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagHyperlinkAction extends XHTMLTagAction {
	private byte[] myHyperlinkStack = new byte[10];
	private int myHyperlinkStackSize;

	private static boolean isReference(String text) {
		return
			text.startsWith(""http://"") ||
			text.startsWith(""https://"") ||
			text.startsWith(""mailto:"") ||
			text.startsWith(""ftp://"");
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		final String href = xmlattributes.getValue(""href"");
		if (myHyperlinkStackSize == myHyperlinkStack.length) {
			myHyperlinkStack = ZLArrayUtils.createCopy(myHyperlinkStack, myHyperlinkStackSize, 2 * myHyperlinkStackSize);
		}
		if ((href != null) && (href.length() > 0)) {
			String link = href;
			final byte hyperlinkType;
			if (isReference(link)) {
				hyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
			} else {
				hyperlinkType = FBTextKind.INTERNAL_HYPERLINK;
				final int index = href.indexOf('#');
				if (index == 0) {
					link = reader.myReferencePrefix + href.substring(1);
				} else if (index > 0) {
					link = reader.getFileAlias(reader.myLocalPathPrefix + href.substring(0, index)) + href.substring(index);
				} else {
					link = reader.getFileAlias(reader.myLocalPathPrefix + href);
				}
			}
			myHyperlinkStack[myHyperlinkStackSize++] = hyperlinkType;
			modelReader.addHyperlinkControl(hyperlinkType, link);
		} else {
			myHyperlinkStack[myHyperlinkStackSize++] = FBTextKind.REGULAR;
		}
		final String name = xmlattributes.getValue(""name"");
		if (name != null) {
			modelReader.addHyperlinkLabel(reader.myReferencePrefix + name);
		}
	}

	protected void doAtEnd(XHTMLReader reader) {
		byte kind = myHyperlinkStack[--myHyperlinkStackSize];
		if (kind != FBTextKind.REGULAR) {
			reader.getModelReader().addControl(kind, false);
		}
	}
}
",False,133,0,0,9,34,1,6,L3
37,org.geometerplus.fbreader.formats.xhtml.XHTMLTagParagraphAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagParagraphAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.getModelReader().beginParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
	}
}
",False,133,0,0,9,34,1,4,L3
38,org.geometerplus.fbreader.formats.xhtml.XHTMLTagRestartParagraphAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagRestartParagraphAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.getModelReader().beginParagraph();
		reader.getModelReader().endParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
	}
}
",False,133,0,0,9,34,1,4,L3
39,org.geometerplus.fbreader.formats.xhtml.XHTMLTagPreAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagPreAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.myPreformatted = true;
		final BookReader modelReader = reader.getModelReader();
		modelReader.beginParagraph();
		modelReader.addControl(FBTextKind.CODE, true);
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.addControl(FBTextKind.CODE, false);
		modelReader.endParagraph();
		reader.myPreformatted = false;
	}
}
",False,133,0,0,9,34,1,5,L3
40,org.geometerplus.fbreader.formats.xhtml.XHTMLTagBodyAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagBodyAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.myInsideBody = true;
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
		reader.myInsideBody = false;
	}
}
",False,133,0,0,9,34,1,4,L3
41,org.geometerplus.fbreader.formats.xhtml.XHTMLTagControlAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagControlAction extends XHTMLTagAction {
	final byte myControl;

	XHTMLTagControlAction(byte control) {
		myControl = control;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.pushKind(myControl);
		modelReader.addControl(myControl, true);
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.addControl(myControl, false);
		modelReader.popKind();
	}
}
",False,133,0,0,9,34,1,4,L3
42,org.geometerplus.fbreader.formats.plucker.PluckerTextStream.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;

import org.geometerplus.fbreader.formats.pdb.PdbStream;
import org.geometerplus.fbreader.formats.pdb.PdbUtil;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class PluckerTextStream extends PdbStream {
	private short myCompressionVersion;
	private	byte[] myFullBuffer;
	private	int myRecordIndex;

	public PluckerTextStream(ZLFile file) throws IOException {
		super(file);
		myFullBuffer = null;
	}
	
	public int read() {
		return 0;
	}
	
	public boolean open() throws IOException {
		//if (!super.open()) {
		//	return false;
		//}

		myCompressionVersion = (short) PdbUtil.readShort(myBase);

		myBuffer = new byte[65536];
		myFullBuffer = new byte[65536];

		myRecordIndex = 0;

		return true;
	}
	
	public	void close() throws IOException {
		if (myFullBuffer != null) {
			myFullBuffer = null;
		}
		super.close();
	}

	protected boolean fillBuffer() {
		while (myBufferOffset == myBufferLength) {
			if (myRecordIndex + 1 > myHeader.Offsets.length - 1) {
				return false;
			}
			++myRecordIndex;
			int currentOffset = myHeader.Offsets[myRecordIndex];
			//if (currentOffset < myBase.offset()) {
			//	return false;
			//}
			//((PdbStream)myBase).seek(currentOffset, true);
			int nextOffset =
				(myRecordIndex + 1 < myHeader.Offsets.length) ?
						myHeader.Offsets[myRecordIndex + 1] : 0;//myBase.sizeOfOpened();
			if (nextOffset < currentOffset) {
				return false;
			}
			try {
				processRecord(nextOffset - currentOffset);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return true;
	}

	private void processRecord(int recordSize) throws IOException {
		myBase.skip(2);

		int paragraphs = PdbUtil.readShort(myBase);
		int size = PdbUtil.readShort(myBase);
		
		char type = (char)myBase.read(); 
		if (type > 1) { // this record is not text record
			return;
		}

		myBase.skip(1);

		final int[] pars = new int[paragraphs];
		for (int i = 0; i < paragraphs; ++i) {
			pars[i] = PdbUtil.readShort(myBase);
			myBase.skip(2);
		}

		boolean doProcess = false;
		if (type == 0) {
			doProcess = myBase.read(myFullBuffer, 0, size) == size;
		} else if (myCompressionVersion == 1) {
			//doProcess =
				//DocDecompressor().decompress(myBase, myFullBuffer, recordSize - 8 - 4 * paragraphs, size) == size;
		} else if (myCompressionVersion == 2) {
			myBase.skip(2);
			//doProcess =
				//ZLZDecompressor(recordSize - 10 - 4 * paragraphs).decompress(myBase, myFullBuffer, size) == size;
		}
		if (doProcess) {
			myBufferLength = 0;
			myBufferOffset = 0;

			int start = 0;
			int end = 0;

			for (int i = 0; i < paragraphs; ++i) {
				start = end;
				end = start + pars[i];
				if (end > myFullBuffer[size]) {
					break;
				}
				processTextParagraph(myFullBuffer.toString().toCharArray(), start, end);
			}
		}
	}
	
	private	void processTextParagraph(char[] data, int start, int end) {
		int textStart = start;
		boolean functionFlag = false;
		for (int ptr = start; ptr < end; ++ptr) {
			if (data[ptr] == 0) {
				functionFlag = true;
				if (ptr != textStart) {
					//memcpy(myBuffer + myBufferLength, textStart, ptr - textStart);
					myBufferLength += ptr - textStart;
				}
			} else if (functionFlag) {
				int paramCounter = (data[ptr]) % 8;
				if (end - ptr > paramCounter + 1) {
					ptr += paramCounter;
				} else {
					ptr = end - 1;
				}
				functionFlag = false;
				textStart = ptr + 1;
			}
		}
		if (end != textStart) {
			//memcpy(myBuffer + myBufferLength, textStart, end - textStart);
			myBufferLength += end - textStart;
		}
	}
}
",True,27,1,1,5,7,1,5,L8
43,org.geometerplus.fbreader.formats.plucker.PluckerPlugin.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.pdb.PdbPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class PluckerPlugin extends PdbPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {		
		return ""DataPlkr"".equals(fileType(file));
	}
	
	@Override
	public boolean readMetaInfo(Book book) {
		try {
			PluckerTextStream stream = new PluckerTextStream(book.File);
			if (stream.open()) {
				//detectEncodingAndLanguage(book, stream);
				stream.close();
			}
		} catch (IOException e) {
		}
		
		if (book.getEncoding().length() == 0) {
			return false;
		}

		return true;
	}
	
	@Override
	public boolean readModel(BookModel model)  {
		return new PluckerBookReader(model.Book.File, model, model.Book.getEncoding()).readDocument();
	}

	@Override
	public ZLImage readCover(Book book) {
		return null;
	}
}
",True,139,0,0,7,33,0,7,L8
44,org.geometerplus.fbreader.formats.plucker.PluckerBookReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.util.*;
import java.util.zip.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.util.ZLInputStreamWithOffset;
import org.geometerplus.zlibrary.core.image.*;
import org.geometerplus.zlibrary.text.model.*;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.pdb.*;

public class PluckerBookReader extends BookReader {
	private final ZLFile myFile;
	private final int myFileSize;
	private ZLInputStreamWithOffset myStream;
	private	int myFont;
	private	char[] myCharBuffer;
	private	String myConvertedTextBuffer;
	private	boolean myParagraphStarted = false;
	private	boolean myBufferIsEmpty;
	//private	ZLTextForcedControlEntry myForcedEntry;
	private	final ArrayList/*<std::pair<FBTextKind,bool> >*/ myDelayedControls = new ArrayList();
	private	final ArrayList/*<std::string> */myDelayedHyperlinks = new ArrayList();
	private	short myCompressionVersion;
	private	char myBytesToSkip;

	private	final ArrayList/*<std::pair<int, int> >*/ myReferencedParagraphs = new ArrayList();
	private	final HashMap/*<int, std::vector<int> >*/ myParagraphMap = new HashMap(); /*<int, vector<pair<int, int>>>*/
	private	ArrayList/*<Integer, Integer>*/ myParagraphVector = new ArrayList();
	private	boolean myParagraphStored;
	
	public PluckerBookReader(ZLFile file, BookModel model, String encoding){
		super(model);
		//myConverter = new EncodedTextReader(encoding).getConverter(); 
		myFile = file; 
		myFileSize = (int)file.size();
		//System.out.println(filePath + ""  "" + encoding);
		myFont = FontType.FT_REGULAR;
		myCharBuffer = new char[65535];
		//myForcedEntry = null;
	}

	public boolean readDocument() {
		try {
			myStream = new ZLInputStreamWithOffset(myFile.getInputStream());
        
			PdbHeader header = new PdbHeader(myStream);
        
			setMainTextModel();
			myFont = FontType.FT_REGULAR;
        
			for (int index = 0; index < header.Offsets.length; ++index) {
				int currentOffset = myStream.offset();
				int pit = header.Offsets[index];
				if (currentOffset > pit) {
					break;
				}
				//myStream.seek(pit - currentOffset, false);
				myStream.skip(pit - currentOffset);
				
				if (myStream.offset() != pit) {
					break;
				}
				int recordSize = ((index != header.Offsets.length - 1) ? header.Offsets[index + 1] : myFileSize) - pit;
				readRecord(recordSize);
			}
			myStream.close();
		} catch (IOException e) {
			return false;
		}

		for (Iterator it = myReferencedParagraphs.iterator(); it.hasNext();) {
			Pair pair = (Pair)it.next();
			int first = (Integer)pair.myFirst;
			int second = (Integer)pair.mySecond;
			ArrayList/*<Integer>*/ list = (ArrayList)myParagraphMap.get(first);
			if (list != null) {
				for(int k = second; k < list.size(); ++k) {
					if (((Integer) ((Pair)list.get(k)).myFirst) != -1) {
						//addHyperlinkLabel(fromNumber(first) + '#' + fromNumber(second), (Integer)list.get(k));
						final Pair p = (Pair)list.get(k);
						//addHyperlinkLabel(fromNumber(first) + '#' + fromNumber(second), (Integer) p.mySecond, (Integer) p.myFirst);
						break;						
					}
				}
			}
		}
		myReferencedParagraphs.clear();
		myParagraphMap.clear();
		return true;
	}

	private class FontType {
			public static final int FT_REGULAR = 0;
			public static final int FT_H1 = 1;
			public static final int FT_H2 = 2;
			public static final int FT_H3 = 3;
			public static final int FT_H4 = 4;
			public static final int FT_H5 = 5;
			public static final int FT_H6 = 6;
			public static final int FT_BOLD = 7;
			public static final int FT_TT = 8;
			public static final int FT_SMALL = 9;
			public static final int FT_SUB = 10;
			public static final int FT_SUP = 11;
		};

	private	void readRecord(int recordSize) throws IOException {
		int uid = PdbUtil.readShort(myStream);
		if (uid == 1) {
			myCompressionVersion = (short) PdbUtil.readShort(myStream );
		} else {
			int paragraphs = PdbUtil.readShort(myStream);

			int size = PdbUtil.readShort(myStream);
            //TODO ??????  
			int type = myStream.read();

			int flags = myStream.read();

			switch (type) {
				case 0: // text (TODO: found sample file and test this code)
				case 1: // compressed text
				{
					ArrayList/*<Integer>*/ pars = new ArrayList();
					for (int i = 0; i < paragraphs; ++i) {
						int pSize = PdbUtil.readShort(myStream);
						pars.add(pSize);
						myStream.skip(2);
					}

					boolean doProcess = false;
					if (type == 0) {//?
						byte[] buf = new byte[size];
						doProcess = myStream.read(buf, 0, (int)size) == size;
						if (doProcess) {
							// TODO: use encoding!!!!
							// TODO: don't create any new objects!!!!
							myCharBuffer = new String(buf).toCharArray();
						}
					} else if (myCompressionVersion == 1) {
						byte[] buf = new byte[size];
						doProcess =
							DocDecompressor.decompress(myStream, buf, recordSize - 8 - 4 * paragraphs) == size;
						if (doProcess) {
							myCharBuffer = new String(buf).toCharArray();
						}
					} else if (myCompressionVersion == 2) {
						byte input [] = new byte[(int) (recordSize - 10 - 4 * paragraphs)];
						final int inputSize = myStream.read(input);
						Inflater decompressor = new Inflater();
						decompressor.setInput(input, 0, inputSize);
						byte output [] = new byte[size];
						try {
							doProcess = decompressor.inflate(output) == size;
							decompressor.end();
							myCharBuffer = new String(output, 0, size).toCharArray();
						} catch (DataFormatException e) {
							// TODO Auto-generated catch block
							//e.printStackTrace();
							//System.out.println(e.getMessage());
						}
						//doProcess =
							//ZLZDecompressor(recordSize - 10 - 4 * paragraphs).
								//decompress(myStream, myCharBuffer, size) == size;
					}
					if (doProcess) {
						addHyperlinkLabel(fromNumber(uid));
						myParagraphMap.put(uid, new ArrayList());
						myParagraphVector = (ArrayList)myParagraphMap.get(uid);
						processTextRecord(size, pars);
						if ((flags & 0x1) == 0) {
//							insertEndOfTextParagraph();
							//setNewTextModel();
						}
					}
					break;
				}
				case 2: // image
				case 3: // compressed image
				{
					final String mime = ""image/palm"";
					ZLImage image = null;
					if (type == 2) {
						//System.out.println(""non-compressed image"");
						image = new PluckerFileImage(mime, myFile, myStream.offset(), recordSize - 8);
					} else if (myCompressionVersion == 1) {
						//System.out.println(""DocCompressedImage"");
						image = new DocCompressedFileImage(mime, myFile, myStream.offset(), recordSize - 8);
					} else if (myCompressionVersion == 2) {
						//System.out.println(""ZCompressedImage"");
						image = new ZCompressedFileImage(mime, myFile, myStream.offset() + 2, recordSize - 10);
					}
					if (image != null) {
						addImage(fromNumber(uid), image);
					}
					break;
				}
				case 9: // category record is ignored
					break;
				case 10:
					short typeCode = (short) PdbUtil.readShort(myStream);
					break;
				case 11: // style sheet record is ignored
					break;
				case 12: // font page record is ignored
					break;
				case 13: // TODO: process tables
				case 14: // TODO: process tables
					break;
				case 15: // multiimage
				{
					short columns = (short) PdbUtil.readShort(myStream);
					short rows = (short) PdbUtil.readShort(myStream);
					//System.out.println(""multiimage"");
					/*PluckerMultiImage image = new PluckerMultiImage(rows, columns, Model.getImageMap());
					for (int i = 0; i < size / 2 - 2; ++i) {
						short us = (short)myStream.read();
						PdbUtil.readShort(myStream, us);
						image.addId(fromNumber(us));
					}
					addImage(fromNumber(uid), image);
					*/break;
				}
				default:
					//std::cerr << ""type = "" << (int)type << ""\n"";
					break;
			}
		}	
	}
	
    private	void processTextRecord(int size, ArrayList/*<Integer>*/ pars) {
    	int start = 0;
    	int end = 0;

    	for (Iterator it = pars.iterator(); it.hasNext();) {
    		start = end;
    		end = start + (Integer)it.next();
    		if (end > size) {
    			return;
    		}
    		myParagraphStored = false;
    		processTextParagraph(myCharBuffer, start, end);
    		if (!myParagraphStored) {
    			myParagraphVector.add(new Pair(-1, -1));
    		}
    	}
    }
    
    private	void processTextParagraph(char[] data, int start, int end) {
    	changeFont(FontType.FT_REGULAR);
    	while (popKind()) {}

    	myParagraphStarted = false;
    	myBytesToSkip = 0;

    	int textStart = start;
    	boolean functionFlag = false;
    	for (int ptr = start; ptr < end; ++ptr) {
    		if (data[ptr] == 0) {
    			functionFlag = true;
    			if (ptr > textStart) {
    				safeBeginParagraph();
    	//			myConvertedTextBuffer = """";//.erase();
    				myConvertedTextBuffer = """";//myConverter.convert(data, textStart, ptr);
    				addData(myConvertedTextBuffer.toCharArray());
    				myBufferIsEmpty = false;
    			}
    		} else if (functionFlag) {
    			int paramCounter = (data[ptr]) % 8;
    			if (end - ptr > paramCounter) {
    				processTextFunction(data, ptr);
    				ptr += paramCounter;
    			} else {
    				ptr = end - 1;
    			}
    			functionFlag = false;
    			if (myBytesToSkip > 0) {
    				ptr += myBytesToSkip;
    				myBytesToSkip = 0;
    			}
    			textStart = ptr + 1;
    		} else {
    			if (data[ptr] == 0xA0) {
    				data[ptr] = 0x20;
    			}
    			if (!myParagraphStarted && (textStart == ptr) && (data[ptr] == ' ')) {
    				++textStart;
    			}
    		}
    	}
    	if (end > textStart) {
    		safeBeginParagraph();
    	//	myConvertedTextBuffer = """";//erase();
    		myConvertedTextBuffer = """";//myConverter.convert(data, textStart, end);
    		addData(myConvertedTextBuffer.toCharArray());
    		myBufferIsEmpty = false;
    	}
    	safeEndParagraph();
    	//if (myForcedEntry != null) {
    	//	myForcedEntry = null;
    	//}
    	myDelayedControls.clear();
    }
    
    private	void processTextFunction(char[] ptr, int cur) {
			switch (ptr[cur]) {
				case 0x08:
					safeAddControl(FBTextKind.INTERNAL_HYPERLINK, false);
					break;
				case 0x0A:
					safeAddHyperlinkControl(fromNumber(twoBytes(ptr, cur+ 1)));
					break;
				case 0x0C:
				{
					int sectionNum = twoBytes(ptr, cur + 1);
					int paragraphNum = twoBytes(ptr, cur + 3);
					safeAddHyperlinkControl(fromNumber(sectionNum) + '#' + fromNumber(paragraphNum));
					myReferencedParagraphs.add(new Pair(sectionNum, paragraphNum));
					break;
				}
				case 0x11:
					changeFont((ptr[cur + 1]));
					break;
				case 0x1A:
					safeBeginParagraph();
			//		System.out.println(""image ref"");
					addImageReference(fromNumber(twoBytes(ptr, cur + 1)), (short) 0);
					break;
				case 0x22:
					if (!myParagraphStarted) {
						//if (myForcedEntry == null) {
						//	myForcedEntry = new ZLTextForcedControlEntry();
						//}
						//myForcedEntry.setLeftIndent((short)ptr[cur + 1]);
						//myForcedEntry.setRightIndent((short)ptr[cur + 2]);
					}
					break;
				case 0x29:
					if (!myParagraphStarted) {
						//if (myForcedEntry == null) {
						//	myForcedEntry = new ZLTextForcedControlEntry();
						//}
						//switch (ptr[cur + 1]) {
						//	case 0: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_LEFT); break;
						//	case 1: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_RIGHT); break;
						//	case 2: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_CENTER); break;
						//	case 3: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_JUSTIFY); break;
						//}
					}
					break;
				case 0x33: // just break line instead of horizontal rule (TODO: draw horizontal rule?)
					safeEndParagraph();
					break;
				case 0x38:
					safeEndParagraph();
					break;
				case 0x40: 
					safeAddControl(FBTextKind.EMPHASIS, true);
					break;
				case 0x48:
					safeAddControl(FBTextKind.EMPHASIS, false);
					break;
				case 0x53: // color setting is ignored
					break;
				case 0x5C:
		//			System.out.println(""image ref"");
					addImageReference(fromNumber(twoBytes(ptr, cur + 3)), (short) 0);
					break;
				case 0x60: // underlined text is ignored
					break;
				case 0x68: // underlined text is ignored
					break;
				case 0x70: // strike-through text is ignored
					break;
				case 0x78: // strike-through text is ignored
					break;
				case 0x83: 
				{
					safeBeginParagraph();
					addData(new char[] { (char)twoBytes(ptr, cur + 2) });
					myBufferIsEmpty = false;
					myBytesToSkip = ptr[cur+1];
					break;
				}
				case 0x85: // TODO: process 4-byte unicode character
					break;
				case 0x8E: // custom font operations are ignored
				case 0x8C:
				case 0x8A:
				case 0x88:
					break;
				case 0x90: // TODO: add table processing
				case 0x92: // TODO: process table
				case 0x97: // TODO: process table
					break;
				default: // this should be impossible
					//std::cerr << ""Oops... function #"" << (int)(unsigned char)*ptr << ""\n"";
					break;
	}	
    }
    
    private	void setFont(int font, boolean start) {
			switch (font) {
				case FontType.FT_REGULAR:
					break;
				case FontType.FT_H1:
				case FontType.FT_H2:
				case FontType.FT_H3:
				case FontType.FT_H4:
				case FontType.FT_H5:
				case FontType.FT_H6:
					processHeader(font, start);
					break;
				case FontType.FT_BOLD:
					safeAddControl(FBTextKind.BOLD, start);
					break;
				case FontType.FT_TT:
					safeAddControl(FBTextKind.CODE, start);
					break;
				case FontType.FT_SMALL:
					break;
				case FontType.FT_SUB:
					safeAddControl(FBTextKind.SUB, start);
					break;
				case FontType.FT_SUP:
					safeAddControl(FBTextKind.SUP, start);
					break;
	    }
    }

    private	void changeFont(int font) {
    	if (myFont == font) {
    		return;
    	}
    	setFont(myFont, false);
    	myFont = font;
    	setFont(myFont, true);
    }

    private void safeAddControl(byte kind, boolean start) {
    	if (myParagraphStarted) {
    		addControl((Byte)kind, (Boolean)start);
    	} else {
    		myDelayedControls.add(new Pair(kind, start));
    	}
    }
    private void safeAddHyperlinkControl(String id) {
    	if (myParagraphStarted) {
    		addHyperlinkControl(FBTextKind.INTERNAL_HYPERLINK, id);
    	} else {
    		myDelayedHyperlinks.add(id);
    	}
    }
    
    private void safeBeginParagraph() {
    	if (!myParagraphStarted) {
    		myParagraphStarted = true;
    		myBufferIsEmpty = true;
    		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
    		if (!myParagraphStored) {
    			//final ArrayList models = Model.getBookTextModels();
    			//myParagraphVector.add(new Pair(((ZLTextPlainModel) models.get(models.size()-1)/*BookTextModel*/).getParagraphsNumber() - 1, models.size() - 1));
    			myParagraphStored = true;
    		}
    		for (Iterator it = myDelayedControls.iterator(); it.hasNext(); ) {
    			Pair pit = (Pair)it.next();
    			addControl((Byte)pit.myFirst, (Boolean)pit.mySecond);
    		}
    		//if (myForcedEntry != null) {
    		//	addControl(myForcedEntry);
    		//} else {
    			addControl(FBTextKind.REGULAR, true);
    		//}
    		for (Iterator it = myDelayedHyperlinks.iterator(); it.hasNext(); ) {
    			addHyperlinkControl(FBTextKind.INTERNAL_HYPERLINK, (String)it.next());
    		}
    		myDelayedHyperlinks.clear();
    	}
    }
    
    private void safeEndParagraph() {
    	if (myParagraphStarted) {
    		if (myBufferIsEmpty) {
    			final String SPACE = "" "";
    			addData(SPACE.toCharArray());
    		}
    		endParagraph();
    		myParagraphStarted = false;
    	}
    }

    private void processHeader(int font, boolean start) {
    	if (start) {
    		enterTitle();
    		int kind;
    		switch (font) {
    			case FontType.FT_H1:
    				kind = FBTextKind.H1;
    				break;
    			case FontType.FT_H2:
    				kind = FBTextKind.H2;
    				break;
    			case FontType.FT_H3:
    				kind = FBTextKind.H3;
    				break;
    			case FontType.FT_H4:
    				kind = FBTextKind.H4;
    				break;
    			case FontType.FT_H5:
    				kind = FBTextKind.H5;
    				break;
    			case FontType.FT_H6:
    			default:
    				kind = FBTextKind.H6;
    				break;
    		}
    		pushKind((byte)kind);
    	} else {
    		popKind();
    		exitTitle();
    	}
    }
	
	static private class Pair {
		public Object myFirst;
		public Object mySecond;
		Pair(Object first, Object second) {
			this.myFirst = first;
			this.mySecond = second;
		}
	}

	static private int twoBytes(char[] ptr, int offset) {
		return 256 * ptr[offset] + ptr[offset+1];
	}

	static String fromNumber(int num) {
		String str = """";
		str += num;
		//ZLStringUtil.appendNumber(str, num);
		return str;
	}
}
",True,138,1,1,8,30,1,13,L8
45,org.geometerplus.fbreader.formats.plucker.PluckerFileImage.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class PluckerFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int mySize;

	public PluckerFileImage(String mimeType, final ZLFile file, final int offset, final int size) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		mySize = size;
	}

	public byte[] byteData() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return new byte[0];
			}

			stream.skip(myOffset);
			byte [] buffer = new byte[mySize];
			stream.read(buffer, 0, mySize);
			return buffer;
		} catch (IOException e) {}
		
		return new byte[0];
	}
}
",True,26,2,1,5,7,1,2,L8
46,org.geometerplus.fbreader.formats.plucker.DocCompressedFileImage.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.fbreader.formats.pdb.DocDecompressor;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class DocCompressedFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int myCompressedSize;
	
	public DocCompressedFileImage(String mimeType, final ZLFile file, final int offset, final int compressedSize) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		myCompressedSize = compressedSize;
	}

	public byte[] byteData() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return new byte[0];
			}

			stream.skip(myOffset);
			byte [] targetBuffer = new byte[65535];
			final int size = DocDecompressor.decompress(stream, targetBuffer, myCompressedSize);
			if (size > 0 && size != 65535) {
				byte [] buffer = new byte[size];
				System.arraycopy(targetBuffer, 0, buffer, 0, size);
				return buffer;
			}
			return targetBuffer;
		} catch (IOException e) {}
		
		return new byte[0];
	}
}
",True,27,2,1,5,7,1,3,L8
47,org.geometerplus.fbreader.formats.plucker.ZCompressedFileImage.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;

import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class ZCompressedFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int myCompressedSize;
	
	public ZCompressedFileImage(String mimeType, final ZLFile file, final int offset, final int compressedSize) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		myCompressedSize = compressedSize;
	}

	public byte[] byteData() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return new byte[0];
			}
			
			final ArrayList<byte[]> data = new ArrayList<byte[]>();
			byte[] buffer;
			int sizeOfBufferData;

			stream.skip(myOffset);
			byte [] targetBuffer = new byte[myCompressedSize];
			stream.read(targetBuffer, 0, myCompressedSize);
			Inflater decompressor = new Inflater();
			decompressor.setInput(targetBuffer, 0, myCompressedSize);
			do {
				buffer = new byte[4096];
				sizeOfBufferData = decompressor.inflate(buffer);
				data.add(buffer);
			} while (sizeOfBufferData == 4096);
			decompressor.end();
			final int dataSizeMinus1 = data.size() - 1;
			buffer = new byte[dataSizeMinus1 * 4096 + sizeOfBufferData];
			for (int i = 0; i < dataSizeMinus1; ++i) {
				System.arraycopy(data.get(i), 0, buffer, i * 4096, 4096);
			}
			System.arraycopy(data.get(dataSizeMinus1), 0, buffer, dataSizeMinus1 * 4096, sizeOfBufferData);
			return buffer;
		} catch (IOException e) {
		} catch (DataFormatException e) {
		}
		return new byte[0];
	}
}
",True,26,2,1,5,7,1,2,L8
48,org.geometerplus.fbreader.library.SeriesInfo.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class SeriesInfo {
	public final String Name;
	public final long Index;

	public SeriesInfo(String name, long index) {
		Name = name;
		Index = index;
	}
}
",False,157,11,38,0,0,5,0,L3
49,org.geometerplus.fbreader.library.BookInSeriesTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.fbreader.tree.FBTree;

public final class BookInSeriesTree extends BookTree {
	BookInSeriesTree(LibraryTree parent, Book book) {
		super(parent, book, false);
	}

	@Override
	public int compareTo(FBTree tree) {
		if (tree instanceof BookInSeriesTree) {
			final long difference =
				Book.getSeriesInfo().Index - ((BookTree)tree).Book.getSeriesInfo().Index;
			if (difference != 0) {
				return (int)difference;
			}
		}
		return super.compareTo(tree);
	}
}
",False,140,0,0,7,36,1,5,L6
50,org.geometerplus.fbreader.library.BooksDatabase.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.zlibrary.text.view.ZLTextPosition;

public abstract class BooksDatabase {
	private static BooksDatabase ourInstance;

	static BooksDatabase Instance() {
		return ourInstance;
	}

	protected BooksDatabase() {
		ourInstance = this;
	}

	protected Book createBook(long id, long fileId, String title, String encoding, String language) {
		final FileInfoSet infos = new FileInfoSet(fileId);
		return createBook(id, infos.getFile(fileId), title, encoding, language);
	}
	protected Book createBook(long id, ZLFile file, String title, String encoding, String language) {
		return (file != null) ? new Book(id, file, title, encoding, language) : null;
	}
	protected void addAuthor(Book book, Author author) {
		book.addAuthorWithNoCheck(author);
	}
	protected void addTag(Book book, Tag tag) {
		book.addTagWithNoCheck(tag);
	}
	protected void setSeriesInfo(Book book, String series, long index) {
		book.setSeriesInfoWithNoCheck(series, index);
	}

	protected abstract void executeAsATransaction(Runnable actions);

	// returns map fileId -> book
	protected abstract Map<Long,Book> listBooks(FileInfoSet infos);
	protected abstract Book loadBook(long bookId);
	protected abstract Book loadBookByFile(long fileId, ZLFile file);

	protected abstract List<Author> loadAuthors(long bookId);
	protected abstract List<Tag> loadTags(long bookId);
	protected abstract SeriesInfo loadSeriesInfo(long bookId);
	protected abstract void updateBookInfo(long bookId, long fileId, String encoding, String language, String title);
	protected abstract long insertBookInfo(ZLFile file, String encoding, String language, String title);
	protected abstract void deleteAllBookAuthors(long bookId);
	protected abstract void saveBookAuthorInfo(long bookId, long index, Author author);
	protected abstract void deleteAllBookTags(long bookId);
	protected abstract void saveBookTagInfo(long bookId, Tag tag);
	protected abstract void saveBookSeriesInfo(long bookId, SeriesInfo seriesInfo);

	protected FileInfo createFileInfo(long id, String name, FileInfo parent) {
		return new FileInfo(name, parent, id);
	}

	protected abstract Collection<FileInfo> loadFileInfos();
	protected abstract Collection<FileInfo> loadFileInfos(ZLFile file);
	protected abstract Collection<FileInfo> loadFileInfos(long fileId);
	protected abstract void removeFileInfo(long fileId);
	protected abstract void saveFileInfo(FileInfo fileInfo);

	protected abstract List<Long> listRecentBookIds();
	protected abstract void saveRecentBookIds(final List<Long> ids);

	protected Bookmark createBookmark(long id, long bookId, String bookTitle, String text, Date creationDate, Date modificationDate, Date accessDate, int accessCounter, String modelId, int paragraphIndex, int wordIndex, int charIndex) {
		return new Bookmark(id, bookId, bookTitle, text, creationDate, modificationDate, accessDate, accessCounter, modelId, paragraphIndex, wordIndex, charIndex);
	}

	protected abstract List<Bookmark> listBookmarks(long bookId);
	protected abstract List<Bookmark> listAllBookmarks();
	protected abstract long saveBookmark(Bookmark bookmark);
	protected abstract void deleteBookmark(Bookmark bookmark);

	protected abstract ZLTextPosition getStoredPosition(long bookId);
	protected abstract void storePosition(long bookId, ZLTextPosition position);

	protected abstract boolean insertIntoBookList(long bookId);
	protected abstract boolean deleteFromBookList(long bookId);
	protected abstract boolean checkBookList(long bookId);
}
",False,208,8,29,7,39,5,9,L3
51,org.geometerplus.fbreader.library.Book.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.text.view.ZLTextPosition;

import org.geometerplus.fbreader.formats.*;

import org.geometerplus.fbreader.Paths;

public class Book {
	public static Book getById(long bookId) {
		final Book book = BooksDatabase.Instance().loadBook(bookId);
		if (book == null) {
			return null;
		}
		book.loadLists();

		final ZLPhysicalFile physicalFile = book.File.getPhysicalFile();
		if (physicalFile == null) {
			return book;
		}
		if (!physicalFile.exists()) {
			return null;
		}

		FileInfoSet fileInfos = new FileInfoSet(physicalFile);
		if (fileInfos.check(physicalFile)) {
			return book;
		}
		fileInfos.save();

		return book.readMetaInfo() ? book : null;
	}

	public static Book getByFile(ZLFile bookFile) {
		if (bookFile == null) {
			return null;
		}

		final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
		if ((physicalFile != null) && !physicalFile.exists()) {
			return null;
		}

		final FileInfoSet fileInfos = new FileInfoSet(bookFile);

		Book book = BooksDatabase.Instance().loadBookByFile(fileInfos.getId(bookFile), bookFile);
		if (book != null) {
			book.loadLists();
		}

		if (book != null && fileInfos.check(physicalFile)) {
			return book;
		}
		fileInfos.save();

		if (book == null) {
			book = new Book(bookFile);
		}
		if (book.readMetaInfo()) {
			book.save();
			return book;
		}
		return null;
	}

	public final ZLFile File;

	private long myId;

	private String myEncoding;
	private String myLanguage;
	private String myTitle;
	private List<Author> myAuthors;
	private List<Tag> myTags;
	private SeriesInfo mySeriesInfo;

	private boolean myIsSaved;

	Book(long id, ZLFile file, String title, String encoding, String language) {
		myId = id;
		File = file;
		myTitle = title;
		myEncoding = encoding;
		myLanguage = language;
		myIsSaved = true;
	}

	Book(ZLFile file) {
		myId = -1;
		File = file;
	}

	boolean readMetaInfo() {
		final FormatPlugin plugin = PluginCollection.instance().getPlugin(File);
		if ((plugin == null) || !plugin.readMetaInfo(this)) {
			return false;
		}
		if ((myTitle == null) || (myTitle.length() == 0)) {
			setTitle(File.getName(true));
		}
		final String demoPathPrefix = Paths.BooksDirectoryOption.getValue() + java.io.File.separator + ""Demos"" + java.io.File.separator;
		if (File.getPath().startsWith(demoPathPrefix)) {
			final String demoTag = ZLResource.resource(""library"").getResource(""demo"").getValue();
			setTitle(getTitle() + "" ("" + demoTag + "")"");
			addTag(demoTag);
		}
		return true;
	}

	private void loadLists() {
		final BooksDatabase database = BooksDatabase.Instance();
		myAuthors = database.loadAuthors(myId);
		myTags = database.loadTags(myId);
		mySeriesInfo = database.loadSeriesInfo(myId);
		myIsSaved = true;
	}

	public List<Author> authors() {
		return (myAuthors != null) ? Collections.unmodifiableList(myAuthors) : Collections.<Author>emptyList();
	}

	void addAuthorWithNoCheck(Author author) {
		if (myAuthors == null) {
			myAuthors = new ArrayList<Author>();
		}
		myAuthors.add(author);
	}

	private void addAuthor(Author author) {
		if (author == null) {
			return;
		}
		if (myAuthors == null) {
			myAuthors = new ArrayList<Author>();
			myAuthors.add(author);
			myIsSaved = false;
		} else if (!myAuthors.contains(author)) {
			myAuthors.add(author);
			myIsSaved = false;
		}
	}

	public void addAuthor(String name) {
		addAuthor(name, """");
	}

	public void addAuthor(String name, String sortKey) {
		String strippedName = name;
		strippedName.trim();
		if (strippedName.length() == 0) {
			return;
		}

		String strippedKey = sortKey;
		strippedKey.trim();
		if (strippedKey.length() == 0) {
			int index = strippedName.lastIndexOf(' ');
			if (index == -1) {
				strippedKey = strippedName;
			} else {
				strippedKey = strippedName.substring(index + 1);
				while ((index >= 0) && (strippedName.charAt(index) == ' ')) {
					--index;
				}
				strippedName = strippedName.substring(0, index + 1) + ' ' + strippedKey;
			}
		}

		addAuthor(new Author(strippedName, strippedKey));
	}

	public long getId() {
		return myId;
	}

	public String getTitle() {
		return myTitle;
	}

	public void setTitle(String title) {
		if (!ZLMiscUtil.equals(myTitle, title)) {
			myTitle = title;
			myIsSaved = false;
		}
	}

	public SeriesInfo getSeriesInfo() {
		return mySeriesInfo;
	}

	void setSeriesInfoWithNoCheck(String name, long index) {
		mySeriesInfo = new SeriesInfo(name, index);
	}

	public void setSeriesInfo(String name, long index) {
		if (mySeriesInfo == null) {
			if (name != null) {
				mySeriesInfo = new SeriesInfo(name, index);
				myIsSaved = false;
			}
		} else if (name == null) {
			mySeriesInfo = null;
			myIsSaved = false;
		} else if (!mySeriesInfo.Name.equals(name) || (mySeriesInfo.Index != index)) {
			mySeriesInfo = new SeriesInfo(name, index);
			myIsSaved = false;
		}
	}

	public String getLanguage() {
		return myLanguage;
	}

	public void setLanguage(String language) {
		if (!ZLMiscUtil.equals(myLanguage, language)) {
			myLanguage = language;
			myIsSaved = false;
		}
	}

	public String getEncoding() {
		return myEncoding;
	}

	public void setEncoding(String encoding) {
		if (!ZLMiscUtil.equals(myEncoding, encoding)) {
			myEncoding = encoding;
			myIsSaved = false;
		}
	}

	public List<Tag> tags() {
		return (myTags != null) ? Collections.unmodifiableList(myTags) : Collections.<Tag>emptyList();
	}

	void addTagWithNoCheck(Tag tag) {
		if (myTags == null) {
			myTags = new ArrayList<Tag>();
		}
		myTags.add(tag);
	}

	public void addTag(Tag tag) {
		if (tag != null) {
			if (myTags == null) {
				myTags = new ArrayList<Tag>();
			}
			if (!myTags.contains(tag)) {
				myTags.add(tag);
				myIsSaved = false;
			}
		}
	}

	public void addTag(String tagName) {
		addTag(Tag.getTag(null, tagName));
	}

	boolean matches(String pattern) {
		if ((myTitle != null) && ZLMiscUtil.matchesIgnoreCase(myTitle, pattern)) {
			return true;
		}
		if ((mySeriesInfo != null) && ZLMiscUtil.matchesIgnoreCase(mySeriesInfo.Name, pattern)) {
			return true;
		}
		if (myAuthors != null) {
			for (Author author : myAuthors) {
				if (ZLMiscUtil.matchesIgnoreCase(author.DisplayName, pattern)) {
					return true;
				}
			}
		}
		if (myTags != null) {
			for (Tag tag : myTags) {
				if (ZLMiscUtil.matchesIgnoreCase(tag.Name, pattern)) {
					return true;
				}
			}
		}
		return false;
	}

	public boolean save() {
		if (myIsSaved) {
			return false;
		}
		final BooksDatabase database = BooksDatabase.Instance();
		database.executeAsATransaction(new Runnable() {
			public void run() {
				if (myId >= 0) {
					final FileInfoSet fileInfos = new FileInfoSet(File);
					database.updateBookInfo(myId, fileInfos.getId(File), myEncoding, myLanguage, myTitle);
				} else {
					myId = database.insertBookInfo(File, myEncoding, myLanguage, myTitle);
				}
            
				long index = 0;
				database.deleteAllBookAuthors(myId);
				for (Author author : authors()) {
					database.saveBookAuthorInfo(myId, index++, author);
				}
				database.deleteAllBookTags(myId);
				for (Tag tag : tags()) {
					database.saveBookTagInfo(myId, tag);
				}
				database.saveBookSeriesInfo(myId, mySeriesInfo);
			}
		});

		myIsSaved = true;
		return true;
	}

	public ZLTextPosition getStoredPosition() {
		return BooksDatabase.Instance().getStoredPosition(myId);
	}

	public void storePosition(ZLTextPosition position) {
		if (myId != -1) {
			BooksDatabase.Instance().storePosition(myId, position);
		}
	}

	public void insertIntoBookList() {
		if (myId != -1) {
			BooksDatabase.Instance().insertIntoBookList(myId);
		}
	}

	@Override
	public int hashCode() {
		return (int)myId;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof Book)) {
			return false;
		}
		return myId == ((Book)o).myId;
	}
}
",True,218,8,31,6,36,25,14,L3
52,org.geometerplus.fbreader.library.Bookmark.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.text.view.ZLTextFixedPosition;
import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

public final class Bookmark extends ZLTextFixedPosition {
	public final static int CREATION = 0;
	public final static int MODIFICATION = 1;
	public final static int ACCESS = 2;
	public final static int LATEST = 3;

	public static List<Bookmark> bookmarks() {
		return BooksDatabase.Instance().listAllBookmarks();
	}

	private long myId;
	private final long myBookId;
	private final String myBookTitle;
	private String myText;
	private final Date myCreationDate;
	private Date myModificationDate;
	private Date myAccessDate;
	private int myAccessCount;
	private Date myLatestDate;
	private final String myModelId;

	private boolean myIsChanged;

	Bookmark(long id, long bookId, String bookTitle, String text, Date creationDate, Date modificationDate, Date accessDate, int accessCount, String modelId, int paragraphIndex, int elementIndex, int charIndex) {
		super(paragraphIndex, elementIndex, charIndex);

		myId = id;
		myBookId = bookId;
		myBookTitle = bookTitle;
		myText = text;
		myCreationDate = creationDate;
		myModificationDate = modificationDate;
		myLatestDate = (modificationDate != null) ? modificationDate : creationDate;
		if (accessDate != null) {
			myAccessDate = accessDate;
			if (myLatestDate.compareTo(accessDate) < 0) {
				myLatestDate = accessDate;
			}
		}
		myAccessCount = accessCount;
		myModelId = modelId;
		myIsChanged = false;
	}

	public Bookmark(Book book, String text, String modelId, ZLTextWordCursor cursor) {
		super(cursor);

		myId = -1;
		myBookId = book.getId();
		myBookTitle = book.getTitle();
		myText = text;
		myCreationDate = new Date();
		myModelId = modelId;
		myIsChanged = true;
	}

	public long getId() {
		return myId;
	}

	public long getBookId() {
		return myBookId;
	}

	public String getText() {
		return myText;
	}

	public String getBookTitle() {
		return myBookTitle;
	}

	public String getModelId() {
		return myModelId;
	}

	public Date getTime(int timeStamp) {
		switch (timeStamp) {
			default:
			case CREATION:
				return myCreationDate;
			case MODIFICATION:
				return myModificationDate;
			case ACCESS:
				return myAccessDate;
			case LATEST:
				return myLatestDate;
		}
	}

	public int getAccessCount() {
		return myAccessCount;
	}

	public void setText(String text) {
		if (!text.equals(myText)) {
			myText = text;
			myModificationDate = new Date();
			myLatestDate = myModificationDate;
			myIsChanged = true;
		}
	}

	public void onOpen() {
		myAccessDate = new Date();
		++myAccessCount;
		myLatestDate = myAccessDate;
		myIsChanged = true;
	}

	public void save() {
		if (myIsChanged) {
			myId = BooksDatabase.Instance().saveBookmark(this);
			myIsChanged = false;
		}
	}

	public void delete() {
		if (myId != -1) {
			BooksDatabase.Instance().deleteBookmark(this);
		}
	}

	public static class ByTimeComparator implements Comparator<Bookmark> {
		public int compare(Bookmark bm0, Bookmark bm1) {
			return bm1.getTime(LATEST).compareTo(bm0.getTime(LATEST));
		}
	}
}
",False,207,8,29,7,30,5,4,L3
53,org.geometerplus.fbreader.library.FileInfo.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.tree.ZLTree;

public final class FileInfo extends ZLTree<FileInfo> {
	public final String Name;
	public long Id;
	public long FileSize = -1;

	FileInfo(String name, FileInfo parent) {
		this(name, parent, -1);
	}

	FileInfo(String name, FileInfo parent, long id) {
		super(parent);
		Name = name;
		Id = id;
	}
}
",False,158,12,39,1,1,3,1,L3
54,org.geometerplus.fbreader.library.Author.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class Author {
	public final String DisplayName;
	public final String SortKey;

	public Author(String displayName, String sortKey) {
		DisplayName = displayName;
		SortKey = sortKey;
	}
		
	public static int hashCode(Author author) {
		return author == null ? 0 : author.hashCode();
	}

	@Override
	public boolean equals(Object o) {
		if (o == this) {
			return true;
		}
		if (!(o instanceof Author)) {
			return false;
		}
		Author a = (Author)o;
		return SortKey.equals(a.SortKey) && DisplayName.equals(a.DisplayName);
	}

	@Override
	public int hashCode() {
		return SortKey.hashCode() + DisplayName.hashCode();
	}
}
",False,157,11,35,0,0,7,0,L3
55,org.geometerplus.fbreader.library.TagTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.resources.ZLResource;

final class TagTree extends LibraryTree {
	private final Tag myTag;

	TagTree(LibraryTree parent, Tag tag) {
		super(parent);
		myTag = tag;
	}

	public String getName() {
		return
			(myTag != null) ?
				myTag.Name :
				ZLResource.resource(""library"").getResource(""booksWithNoTags"").getValue();
	}

	protected String getSortKey() {
		return (myTag != null) ? myTag.Name : null;
	}
}
",False,215,9,28,8,37,2,3,L6
56,org.geometerplus.fbreader.library.BookTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public class BookTree extends LibraryTree {
	public final Book Book;
	private final boolean myShowAuthors;

	BookTree(LibraryTree parent, Book book, boolean showAuthors) {
		super(parent);
		Book = book;
		myShowAuthors = showAuthors;
	}

	public String getName() {
		return Book.getTitle();
	}

	public String getSummary() {
		if (!myShowAuthors) {
			return super.getSummary();
		}
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (Author author : Book.authors()) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(author.DisplayName);
			if (count == 5) {
				break;
			}
		}
		return builder.toString();
	}
}
",False,214,10,28,7,36,4,4,L6
57,org.geometerplus.fbreader.library.RootTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

final class RootTree extends LibraryTree {
	public String getName() {
		return null;
	}
}
",False,216,9,28,8,36,1,1,L6
58,org.geometerplus.fbreader.library.FileInfoSet.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.filesystem.*;

public final class FileInfoSet {
	private static final class Pair {
		private final String myName;
		private final FileInfo myParent;

		Pair(String name, FileInfo parent) {
			myName = name;
			myParent = parent;
		}

		@Override
		public int hashCode() {
			return (myParent == null) ? myName.hashCode() : myParent.hashCode() + myName.hashCode();
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof Pair)) {
				return false;
			}
			Pair p = (Pair)o;
			return (myName.equals(p.myName)) && ZLMiscUtil.equals(myParent, p.myParent);
		}
	}

	private final HashMap<ZLFile,FileInfo> myInfosByFile = new HashMap<ZLFile,FileInfo>();
	private final HashMap<FileInfo,ZLFile> myFilesByInfo = new HashMap<FileInfo,ZLFile>();
	private final HashMap<Pair,FileInfo> myInfosByPair = new HashMap<Pair,FileInfo>();
	private final HashMap<Long,FileInfo> myInfosById = new HashMap<Long,FileInfo>();

	private final LinkedHashSet<FileInfo> myInfosToSave = new LinkedHashSet<FileInfo>();
	private final LinkedHashSet<FileInfo> myInfosToRemove = new LinkedHashSet<FileInfo>();

	public FileInfoSet() {
		load(BooksDatabase.Instance().loadFileInfos());
	}

	public FileInfoSet(ZLFile file) {
		load(BooksDatabase.Instance().loadFileInfos(file));
	}

	FileInfoSet(long fileId) {
		load(BooksDatabase.Instance().loadFileInfos(fileId));
	}

	private void load(Collection<FileInfo> infos) {
		for (FileInfo info : infos) {
			myInfosByPair.put(new Pair(info.Name, info.Parent), info);
			myInfosById.put(info.Id, info);
		}
	}

	public void save() {
		final BooksDatabase database = BooksDatabase.Instance();
		database.executeAsATransaction(new Runnable() {
			public void run() {
				for (FileInfo info : myInfosToRemove) {
					database.removeFileInfo(info.Id);
					myInfosByPair.remove(new Pair(info.Name, info.Parent));
				}
				myInfosToRemove.clear();
				for (FileInfo info : myInfosToSave) {
					database.saveFileInfo(info);
				}
				myInfosToSave.clear();
			}
		});
	}

	public boolean check(ZLPhysicalFile file) {
		if (file == null) {
			return true;
		}
		final long fileSize = file.size();
		FileInfo info = get(file);
		if (info.FileSize == fileSize) {
			return true;
		} else {
			info.FileSize = fileSize;
			removeChildren(info);
			myInfosToSave.add(info);
			addChildren(file);
			return false;
		}
	}

	public List<ZLFile> archiveEntries(ZLFile file) {
		final FileInfo info = get(file);
		if (!info.hasChildren()) {
			return Collections.emptyList();
		}
		final LinkedList<ZLFile> entries = new LinkedList<ZLFile>();
		for (FileInfo child : info.subTrees()) {
			if (!myInfosToRemove.contains(child)) {
				entries.add(ZLArchiveEntryFile.createArchiveEntryFile(file, child.Name));
			}
		}
		return entries;
	}

	private FileInfo get(String name, FileInfo parent) {
		final Pair pair = new Pair(name, parent);
		FileInfo info = myInfosByPair.get(pair);
		if (info == null) {
			info = new FileInfo(name, parent);
			myInfosByPair.put(pair, info);
			myInfosToSave.add(info);
		}
		return info;
	}


	private FileInfo get(ZLFile file) {
		if (file == null) {
			return null;
		}
		FileInfo info = myInfosByFile.get(file);
		if (info == null) {
			info = get(file.getName(false), get(file.getParent()));
			myInfosByFile.put(file, info);
		}
		return info;
	}

	public long getId(ZLFile file) {
		final FileInfo info = get(file);
		if (info == null) {
			return -1;
		}
		if (info.Id == -1) {
			save();
		}
		return info.Id;
	}	

	private ZLFile getFile(FileInfo info) {
		if (info == null) {
			return null;
		}
		ZLFile file = myFilesByInfo.get(info);
		if (file == null) {
			file = ZLFile.createFile(getFile(info.Parent), info.Name);
			myFilesByInfo.put(info, file);
		}
		return file;
	}

	public ZLFile getFile(long id) {
		return getFile(myInfosById.get(id));
	}

	private void removeChildren(FileInfo info) {
		for (FileInfo child : info.subTrees()) {
			if (myInfosToSave.contains(child)) {
				myInfosToSave.remove(child);
			} else {
				myInfosToRemove.add(child);
			}
			removeChildren(child);
		}
	}

	private void addChildren(ZLFile file) {
		for (ZLFile child : file.children()) {
			final FileInfo info = get(child);
			if (myInfosToRemove.contains(info)) {
				myInfosToRemove.remove(info);
			} else {
				myInfosToSave.add(info);
			}
			addChildren(child);
		}
	}
}
",False,208,8,29,8,36,4,7,L3
59,org.geometerplus.fbreader.library.AuthorTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.resources.ZLResource;

public class AuthorTree extends LibraryTree {
	private final Author myAuthor;

	AuthorTree(LibraryTree parent, Author author) {
		super(parent);
		myAuthor = author;
	}

	SeriesTree createSeriesSubTree(String series) {
		return new SeriesTree(this, series);
	}

	public String getName() {
		return
			(myAuthor != null) ?
				myAuthor.DisplayName :
				ZLResource.resource(""library"").getResource(""unknownAuthor"").getValue();
	}

	protected String getSortKey() {
		return (myAuthor != null) ? myAuthor.SortKey : null;
	}
}
",False,215,9,28,8,37,2,4,L6
60,org.geometerplus.fbreader.library.Library.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.io.File;
import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

import org.geometerplus.fbreader.Paths;

public final class Library {
	private static Library ourInstance;

	public static Library Instance() {
		if (ourInstance == null) {
			ourInstance = new Library();
		}
		return ourInstance;
	}

	private final LinkedList<Book> myBooks = new LinkedList<Book>();
	private final HashSet<Book> myExternalBooks = new HashSet<Book>();
	private final LibraryTree myLibraryByAuthor = new RootTree();
	private final LibraryTree myLibraryByTag = new RootTree();
	private final LibraryTree myRecentBooks = new RootTree();
	private final LibraryTree mySearchResult = new RootTree();

	private boolean myDoRebuild = true;

	private Library() {
	}

	public void clear() {
		myDoRebuild = true;

		myBooks.clear();
		myExternalBooks.clear();
		myLibraryByAuthor.clear();
		myLibraryByTag.clear();
		myRecentBooks.clear();
		mySearchResult.clear();
	}

	public ZLResourceFile getHelpFile() {
		final ZLResourceFile file = ZLResourceFile.createResourceFile(
			""data/help/MiniHelp."" + Locale.getDefault().getLanguage() + "".fb2""
		);
		if (file.exists()) {
			return file;
		}

		return ZLResourceFile.createResourceFile(""data/help/MiniHelp.en.fb2"");
	}

	private static Book getBook(ZLFile bookFile, FileInfoSet fileInfos, Map<Long,Book> saved, boolean doReadMetaInfo) {
		Book book = saved.remove(fileInfos.getId(bookFile));
		if (book == null) {
			doReadMetaInfo = true;
			book = new Book(bookFile);
		}

		if (doReadMetaInfo && !book.readMetaInfo()) {
			return null;
		}
		return book;
	}

	private void collectBooks(
		ZLFile file,
		FileInfoSet fileInfos,
		Map<Long,Book> savedBooks,
		boolean doReadMetaInfo
	) {
		Book book = getBook(file, fileInfos, savedBooks, doReadMetaInfo);
		if (book != null) {
			myBooks.add(book);
		} else if (file.isArchive()) {
			for (ZLFile entry : fileInfos.archiveEntries(file)) {
				collectBooks(entry, fileInfos, savedBooks, doReadMetaInfo);
			}
		}
	}

	private void collectExternalBooks(FileInfoSet fileInfos, Map<Long,Book> savedBooks) {
		final HashSet<ZLPhysicalFile> myUpdatedFiles = new HashSet<ZLPhysicalFile>();
		final HashSet<Long> files = new HashSet<Long>(savedBooks.keySet());
		for (Long fileId: files) {
			final ZLFile bookFile = fileInfos.getFile(fileId);
			if (bookFile == null) {
				continue;
			}
			final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
			if (physicalFile == null || !physicalFile.exists()) {
				continue;
			}
			boolean reloadMetaInfo = false; 
			if (myUpdatedFiles.contains(physicalFile)) {
				reloadMetaInfo = true;
			} else if (!fileInfos.check(physicalFile)) {
				reloadMetaInfo = true;
				myUpdatedFiles.add(physicalFile);
			}
			final Book book = getBook(bookFile, fileInfos, savedBooks, reloadMetaInfo);
			if (book == null) {
				continue;
			}
			final long bookId = book.getId();
			if (bookId != -1 && BooksDatabase.Instance().checkBookList(bookId)) {
				myBooks.add(book);
				myExternalBooks.add(book);
			}
		}
	}

	private List<ZLPhysicalFile> collectPhysicalFiles() {
		final Queue<ZLFile> dirQueue = new LinkedList<ZLFile>();
		final HashSet<ZLFile> dirSet = new HashSet<ZLFile>();
		final LinkedList<ZLPhysicalFile> fileList = new LinkedList<ZLPhysicalFile>();

		dirQueue.offer(new ZLPhysicalFile(new File(Paths.BooksDirectoryOption.getValue())));

		while (!dirQueue.isEmpty()) {
			for (ZLFile file : dirQueue.poll().children()) {
				if (file.isDirectory()) {
					if (!dirSet.contains(file)) {
						dirQueue.add(file);
						dirSet.add(file);
					}
				} else {
					file.setCached(true);
					fileList.add((ZLPhysicalFile)file);
				}
			}
		}
		return fileList;
	}

	private void collectBooks() {
		//final long start = System.currentTimeMillis();
		//android.os.Debug.startMethodTracing(""/sdcard/ll0"");
		final List<ZLPhysicalFile> physicalFilesList = collectPhysicalFiles();
		//android.os.Debug.stopMethodTracing();
		//System.err.println(physicalFilesList.size() + "" files "" + (System.currentTimeMillis() - start));

		//android.os.Debug.startMethodTracing(""/sdcard/ll2"");
		FileInfoSet fileInfos = new FileInfoSet();
		//android.os.Debug.stopMethodTracing();
		//System.err.println(""file infos have been loaded "" + (System.currentTimeMillis() - start));

		//android.os.Debug.startMethodTracing(""/sdcard/ll1"");
		final Map<Long,Book> savedBooks = BooksDatabase.Instance().listBooks(fileInfos);
		//android.os.Debug.stopMethodTracing();
		//System.err.println(savedBooks.size() + "" saved books "" + (System.currentTimeMillis() - start));

		//android.os.Debug.startMethodTracing(""/sdcard/ll3"");
		for (ZLPhysicalFile file : physicalFilesList) {
			collectBooks(file, fileInfos, savedBooks, !fileInfos.check(file));
			file.setCached(false);
		}
		myBooks.add(getBook(getHelpFile(), fileInfos, savedBooks, false));
		//android.os.Debug.stopMethodTracing();
		//System.err.println(""books have been synchronized "" + (System.currentTimeMillis() - start));

		collectExternalBooks(fileInfos, savedBooks);

		//android.os.Debug.startMethodTracing(""/sdcard/ll4"");
		fileInfos.save();
		//android.os.Debug.stopMethodTracing();
	}

	private static class AuthorSeriesPair {
		private final Author myAuthor;
		private final String mySeries;

		AuthorSeriesPair(Author author, String series) {
			myAuthor = author;
			mySeries = series;
		}

		public boolean equals(Object object) {
			if (this == object) {
				return true;
			}
			if (!(object instanceof AuthorSeriesPair)) {
				return false;
			}
			AuthorSeriesPair pair = (AuthorSeriesPair)object;
			return ZLMiscUtil.equals(myAuthor, pair.myAuthor) && mySeries.equals(pair.mySeries);
		}

		public int hashCode() {
			return Author.hashCode(myAuthor) + mySeries.hashCode();
		}
	}

	private static final ArrayList ourNullList = new ArrayList(1);
	static {
		ourNullList.add(null);
	}

	private TagTree getTagTree(Tag tag, HashMap<Tag,TagTree> tagTreeMap) {
		TagTree tagTree = tagTreeMap.get(tag);
		if (tagTree == null) {
			LibraryTree parent =
				((tag != null) && (tag.Parent != null)) ?
					getTagTree(tag.Parent, tagTreeMap) : myLibraryByTag;
			tagTree = parent.createTagSubTree(tag);
			tagTreeMap.put(tag, tagTree);
		}
		return tagTree;
	}

	private void build() {
		//System.err.println(""before build: "" + System.currentTimeMillis() % 20000);
		final HashMap<Tag,TagTree> tagTreeMap = new HashMap<Tag,TagTree>();
		final HashMap<Author,AuthorTree> authorTreeMap = new HashMap<Author,AuthorTree>();
		final HashMap<AuthorSeriesPair,SeriesTree> seriesTreeMap = new HashMap<AuthorSeriesPair,SeriesTree>();
		final HashMap<Long,Book> bookById = new HashMap<Long,Book>();

		collectBooks();
		//System.err.println(myBooks.size() + "" books "" + System.currentTimeMillis() % 20000);
		for (Book book : myBooks) {
			bookById.put(book.getId(), book);
			List<Author> authors = book.authors();
			if (authors.isEmpty()) {
				authors = (List<Author>)ourNullList;
			}
			final SeriesInfo seriesInfo = book.getSeriesInfo();
			for (Author a : authors) {
				AuthorTree authorTree = authorTreeMap.get(a);
				if (authorTree == null) {
					authorTree = myLibraryByAuthor.createAuthorSubTree(a);
					authorTreeMap.put(a, authorTree);
				}
				if (seriesInfo == null) {
					authorTree.createBookSubTree(book, false);
				} else {
					final String series = seriesInfo.Name;
					final AuthorSeriesPair pair = new AuthorSeriesPair(a, series);
					SeriesTree seriesTree = seriesTreeMap.get(pair);
					if (seriesTree == null) {
						seriesTree = authorTree.createSeriesSubTree(series);
						seriesTreeMap.put(pair, seriesTree);
					}
					seriesTree.createBookInSeriesSubTree(book);
				}
			}

			List<Tag> tags = book.tags();
			if (tags.isEmpty()) {
				tags = (List<Tag>)ourNullList;
			}
			for (Tag t : tags) {
				getTagTree(t, tagTreeMap).createBookSubTree(book, true);
			}
		}

		final BooksDatabase db = BooksDatabase.Instance();
		for (long id : db.listRecentBookIds()) {
			Book book = bookById.get(id);
			if (book != null) {
				myRecentBooks.createBookSubTree(book, true);
			}
		}

		db.executeAsATransaction(new Runnable() {
			public void run() {
				for (Book book : myBooks) {
					book.save();
				}
			}
		});
		//System.err.println(""after build: "" + System.currentTimeMillis() % 20000);
	}

	public void synchronize() {
		if (myDoRebuild) {
			build();

			myLibraryByAuthor.sortAllChildren();
			myLibraryByTag.sortAllChildren();

			myDoRebuild = false;
		}
	}

	public LibraryTree byAuthor() {
		synchronize();
		return myLibraryByAuthor;
	}

	public LibraryTree byTag() {
		synchronize();
		return myLibraryByTag;
	}

	public LibraryTree recentBooks() {
		synchronize();
		return myRecentBooks;
	}

	public Book getRecentBook() {
		List<Long> recentIds = BooksDatabase.Instance().listRecentBookIds();
		return (recentIds.size() > 0) ? Book.getById(recentIds.get(0)) : null;
	}

	public LibraryTree searchBooks(String pattern) {
		synchronize();
		mySearchResult.clear();
		if (pattern != null) {
			pattern = pattern.toLowerCase();
			for (Book book : myBooks) {
				if (book.matches(pattern)) {
					mySearchResult.createBookSubTree(book, true);
				}
			}
			mySearchResult.sortAllChildren();
		}
		return mySearchResult;
	}

	public void addBookToRecentList(Book book) {
		final BooksDatabase db = BooksDatabase.Instance();
		final List<Long> ids = db.listRecentBookIds();
		final Long bookId = book.getId();
		ids.remove(bookId);
		ids.add(0, bookId);
		if (ids.size() > 12) {
			ids.remove(12);
		}
		db.saveRecentBookIds(ids);
	}

	public static final int REMOVE_DONT_REMOVE = 0x00;
	public static final int REMOVE_FROM_LIBRARY = 0x01;
	public static final int REMOVE_FROM_DISK = 0x02;
	public static final int REMOVE_FROM_LIBRARY_AND_DISK = REMOVE_FROM_LIBRARY | REMOVE_FROM_DISK;

	public int getRemoveBookMode(Book book) {
		synchronize();
		return (myExternalBooks.contains(book) ? REMOVE_FROM_LIBRARY : REMOVE_DONT_REMOVE)
			| (canDeleteBookFile(book) ? REMOVE_FROM_DISK : REMOVE_DONT_REMOVE);
	}

	private boolean canDeleteBookFile(Book book) {
		ZLFile file = book.File;
		if (file.getPhysicalFile() == null) {
			return false;
		}
		while (file instanceof ZLArchiveEntryFile) {
			file = file.getParent();
			if (file.children().size() != 1) {
				return false;
			}
		}
		return true;
	}

	public void removeBook(Book book, int removeMode) {
		if (removeMode == REMOVE_DONT_REMOVE) {
			return;
		}
		synchronize();
		myBooks.remove(book);
		myLibraryByAuthor.removeBook(book);
		myLibraryByTag.removeBook(book);
		if (myRecentBooks.removeBook(book)) {
			final BooksDatabase db = BooksDatabase.Instance();
			final List<Long> ids = db.listRecentBookIds();
			ids.remove(book.getId());
			db.saveRecentBookIds(ids);
		}
		mySearchResult.removeBook(book);

		BooksDatabase.Instance().deleteFromBookList(book.getId());
		if ((removeMode & REMOVE_FROM_DISK) != 0) {
			book.File.getPhysicalFile().delete();
		}
	}
}
",True,216,8,28,7,35,4,20,L6
61,org.geometerplus.fbreader.library.LibraryTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

//import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.fbreader.tree.FBTree;

public abstract class LibraryTree extends FBTree {
	protected LibraryTree() {
		super();
	}

	protected LibraryTree(LibraryTree parent) {
		super(parent);
	}

	TagTree createTagSubTree(Tag tag) {
		return new TagTree(this, tag);
	}

	AuthorTree createAuthorSubTree(Author author) {
		return new AuthorTree(this, author);
	}

	BookTree createBookSubTree(Book book, boolean showAuthors) {
		return new BookTree(this, book, showAuthors);
	}

	public boolean removeBook(Book book) {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();
		for (FBTree tree : this) {
			if ((tree instanceof BookTree) && ((BookTree)tree).Book.equals(book)) {
				toRemove.add(tree);
			}
		}
		for (FBTree tree : toRemove) {
			tree.removeSelf();
			FBTree parent = tree.Parent;
			for (; (parent != null) && !parent.hasChildren(); parent = parent.Parent) {
				parent.removeSelf();
			}
			for (; parent != null; parent = parent.Parent) {
				((LibraryTree)parent).invalidateChildren();
			}
		}
		return !toRemove.isEmpty();
	}
}
",False,216,9,28,7,36,9,8,L6
62,org.geometerplus.fbreader.library.SeriesTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

final class SeriesTree extends LibraryTree {
	private final String mySeries;

	SeriesTree(LibraryTree parent, String series) {
		super(parent);
		mySeries = series;
	}

	public String getName() {
		return mySeries;
	}

	BookTree createBookInSeriesSubTree(Book book) {
		return new BookInSeriesTree(this, book);
	}
}
",False,215,9,28,7,36,2,4,L6
63,org.geometerplus.fbreader.library.Tag.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.HashMap;

public final class Tag {
	private static final HashMap<Tag,Tag> ourTagSet = new HashMap<Tag,Tag>();

	public static Tag getTag(Tag parent, String name) {
		if (name == null) {
			return parent;
		}
		name = name.trim();
		if (name.length() == 0) {
			return parent;
		}
		Tag tag = new Tag(parent, name);
		Tag stored = ourTagSet.get(tag);
		if (stored != null) {
			return stored;
		}
		ourTagSet.put(tag, tag);
		return tag;
	}

	public final Tag Parent;
	public final String Name;

	private Tag(Tag parent, String name) {
		Parent = parent;
		Name = name;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof Tag)) {
			return false;
		}
		Tag t = (Tag)o;
		return (Parent == t.Parent) && Name.equals(t.Name);
	}

	@Override
	public int hashCode() {
		return (Parent == null) ? Name.hashCode() : Parent.hashCode() + Name.hashCode();
	}
}
",False,158,11,35,0,0,8,0,L3
64,org.geometerplus.fbreader.bookmodel.FBTextKind.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

public interface FBTextKind {
	byte REGULAR = 0;
	byte TITLE = 1;
	byte SECTION_TITLE = 2;
	byte POEM_TITLE = 3;
	byte SUBTITLE = 4;
	byte ANNOTATION = 5;
	byte EPIGRAPH = 6;
	byte STANZA = 7;
	byte VERSE = 8;
	byte PREFORMATTED = 9;
	byte IMAGE = 10;
	byte END_OF_SECTION = 11;
	byte CITE = 12;
	byte AUTHOR = 13;
	byte DATE = 14;
	byte INTERNAL_HYPERLINK = 15;
	byte FOOTNOTE = 16;
	byte EMPHASIS = 17;
	byte STRONG = 18;
	byte SUB = 19;
	byte SUP = 20;
	byte CODE = 21;
	byte STRIKETHROUGH = 22;
	byte CONTENTS_TABLE_ENTRY = 23;
	byte LIBRARY_AUTHOR_ENTRY = 24;
	byte LIBRARY_BOOK_ENTRY = 25;
	byte RECENT_BOOK_LIST = 26;
	byte ITALIC = 27;
	byte BOLD = 28;
	byte DEFINITION = 29;
	byte DEFINITION_DESCRIPTION = 30;
	byte H1 = 31;
	byte H2 = 32;
	byte H3 = 33;
	byte H4 = 34;
	byte H5 = 35;
	byte H6 = 36;
	byte EXTERNAL_HYPERLINK = 37;
};
",False,159,10,37,0,0,11,0,L3
65,org.geometerplus.fbreader.bookmodel.TOCTree.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.text.model.ZLTextModel;

public class TOCTree extends ZLTree<TOCTree> {
	private String myText;
	private Reference myReference;

	protected TOCTree() {
		super();
	}

	public TOCTree(TOCTree parent) {
		super(parent);
	}

	public final String getText() {
		return myText;
	}

	public final void setText(String text) {
		myText = text;
	}
	
	public Reference getReference() {
		return myReference;
	}
	
	public void setReference(ZLTextModel model, int reference) {
		myReference = new Reference(reference, model);
	}

	public static class Reference {
		public final int ParagraphIndex;
		public final ZLTextModel Model;
		
		public Reference(final int paragraphIndex, final ZLTextModel model) {
			ParagraphIndex = paragraphIndex;
			Model = model;
		}
	}
}
",False,164,9,32,4,2,3,2,L3
66,org.geometerplus.fbreader.bookmodel.BookModel.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import java.util.*;

import org.geometerplus.zlibrary.core.image.*;

import org.geometerplus.zlibrary.text.model.*;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.*;
import org.geometerplus.fbreader.Paths;

public final class BookModel {
	public static BookModel createModel(Book book) {
		FormatPlugin plugin = PluginCollection.instance().getPlugin(book.File);
		if (plugin == null) {
			return null;
		}
		BookModel model = new BookModel(book);
		//android.os.Debug.startMethodTracing(""bookReadingLT"", 1 << 25);
		//final boolean code = plugin.readModel(model);
		//android.os.Debug.stopMethodTracing();
		//if (code) {
		if (plugin.readModel(model)) {
			return model;
		}
		return null;
	}

	private final ZLImageMap myImageMap = new ZLImageMap(); 
	
	public final Book Book;
	public final ZLTextModel BookTextModel;
	public final TOCTree TOCTree = new TOCTree();

	private final HashMap<String,ZLTextModel> myFootnotes = new HashMap<String,ZLTextModel>();

	public static final class Label {
		public final String ModelId;
		public final int ParagraphIndex;
		
		public Label(String modelId, int paragraphIndex) {
			ModelId = modelId;
			ParagraphIndex = paragraphIndex;
		}
	}
	
	//private static String linksFileName(int index) {
	//	return Constants.CACHE_DIRECTORY + ""/links"" + index + "".cache"";
	//}

	private BookModel(Book book) {
		Book = book;
		BookTextModel = new ZLTextWritablePlainModel(null, book.getLanguage(), 1024, 65536, Paths.cacheDirectory(), ""cache"", myImageMap);
		//for (int i = 0; i < 50; ++i) {
		//	new File(linksFileName(i)).delete();
		//}
	}

	public ZLTextModel getFootnoteModel(String id) {
		ZLTextModel model = myFootnotes.get(id);
		if (model == null) {
			model = new ZLTextWritablePlainModel(id, Book.getLanguage(), 8, 512, Paths.cacheDirectory(), ""cache"" + myFootnotes.size(), myImageMap); 
			myFootnotes.put(id, model); 
		}
		return model;
	}
	
	private final CharStorage myInternalHyperlinks = new CachedCharStorage(32768, Paths.cacheDirectory(), ""links"");
	private char[] myCurrentLinkBlock;
	private int myCurrentLinkBlockOffset;

	void addHyperlinkLabel(String label, ZLTextModel model, int paragraphNumber) {
		final String modelId = model.getId();
		final int labelLength = label.length();
		final int idLength = (modelId != null) ? modelId.length() : 0;
		final int len = 4 + labelLength + idLength;

		/*
		try {
			final OutputStreamWriter writer =
				new OutputStreamWriter(
					new FileOutputStream(linksFileName(label.hashCode() % 50), true),
					""UTF-16LE""
				);
			writer.write(labelLength);
			writer.write(label);
			writer.write(idLength);
			if (idLength > 0) {
				writer.write(modelId);
			}
			writer.write(paragraphNumber >> 16);
			writer.write(paragraphNumber);
			writer.close();
		} catch (IOException e) {
		}
		*/

		char[] block = myCurrentLinkBlock;
		int offset = myCurrentLinkBlockOffset;
		if ((block == null) || (offset + len > block.length)) {
			if (block != null) {
				myInternalHyperlinks.freezeLastBlock();
			}
			block = myInternalHyperlinks.createNewBlock(len);
			myCurrentLinkBlock = block;
			offset = 0;
		}
		block[offset++] = (char)labelLength;
		label.getChars(0, labelLength, block, offset);
		offset += labelLength;
		block[offset++] = (char)idLength;
		if (idLength > 0) {
			modelId.getChars(0, idLength, block, offset);
			offset += idLength;
		}
		block[offset++] = (char)(paragraphNumber >> 16);
		block[offset++] = (char)paragraphNumber;
		myCurrentLinkBlockOffset = offset;
	}

	public Label getLabel(String id) {
		final int len = id.length();
		final int size = myInternalHyperlinks.size();
		/*
		try {
			final File file = new File(linksFileName(id.hashCode() % 50));
			if (!file.exists()) {
				return null;
			}
			final char[] block = new char[(int)file.length()];
			final InputStreamReader reader =
				new InputStreamReader(
					new FileInputStream(file),
					""UTF-16LE""
				);
			reader.read(block);
			reader.close();
			for (int offset = 0; offset < block.length; ) {
				final int labelLength = (int)block[offset++];
				if (labelLength == 0) {
					break;
				}
				final int idLength = (int)block[offset + labelLength];
				if ((labelLength != len) || !id.equals(new String(block, offset, labelLength))) {
					offset += labelLength + idLength + 3;
					continue;
				}
				offset += labelLength + 1;
				final String modelId = (idLength > 0) ? new String(block, offset, idLength) : null;
				offset += idLength;
				final int paragraphNumber = (((int)block[offset++]) << 16) + (int)block[offset];
				return new Label(modelId, paragraphNumber);
			}
		} catch (IOException e) {
		}
		*/
		for (int i = 0; i < size; ++i) {
			final char[] block = myInternalHyperlinks.block(i);
			for (int offset = 0; offset < block.length; ) {
				final int labelLength = (int)block[offset++];
				if (labelLength == 0) {
					break;
				}
				final int idLength = (int)block[offset + labelLength];
				if ((labelLength != len) || !id.equals(new String(block, offset, labelLength))) {
					offset += labelLength + idLength + 3;
					continue;
				}
				offset += labelLength + 1;
				final String modelId = (idLength > 0) ? new String(block, offset, idLength) : null;
				offset += idLength;
				final int paragraphNumber = (((int)block[offset++]) << 16) + (int)block[offset];
				return new Label(modelId, paragraphNumber);
			}
		}
		return null;
	}
	
	void addImage(String id, ZLImage image) {
		myImageMap.put(id, image);
	}
}
",False,212,7,27,7,29,22,11,L3
67,org.geometerplus.fbreader.bookmodel.BookReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import org.geometerplus.zlibrary.core.util.*;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharsetDecoder;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.text.model.*;

public class BookReader {
	public final BookModel Model;

	private ZLTextWritableModel myCurrentTextModel = null;
	
	private boolean myTextParagraphExists = false;
	private boolean myTextParagraphIsNonEmpty = false;
	
	private char[] myTextBuffer = new char[4096];
	private int myTextBufferLength;
	private StringBuilder myContentsBuffer = new StringBuilder();

	private byte[] myKindStack = new byte[20];
	private int myKindStackSize;
	
	private byte myHyperlinkKind;
	private String myHyperlinkReference = """";
	
	private boolean myInsideTitle = false;
	private boolean mySectionContainsRegularContents = false;
	
	private TOCTree myCurrentContentsTree;

	private CharsetDecoder myByteDecoder;

	public BookReader(BookModel model) {
		Model = model;
		myCurrentContentsTree = model.TOCTree;
	}

	public final void setByteDecoder(CharsetDecoder decoder) {
		myByteDecoder = decoder;
	}
	
	private final void flushTextBufferToParagraph() {
		if (myTextBufferLength > 0) {
			myCurrentTextModel.addText(myTextBuffer, 0, myTextBufferLength);
			myTextBufferLength = 0;
			if (myByteDecoder != null) {
				myByteDecoder.reset();
			}
		}
	}
	
	public final void addControl(byte kind, boolean start) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addControl(kind, start);
		}
		if (!start && (myHyperlinkReference.length() != 0) && (kind == myHyperlinkKind)) {
			myHyperlinkReference = """";
		}
	}
	
	/*
	public final void addControl(ZLTextForcedControlEntry entry) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addControl(entry);
		}
	}
	*/
	
	public final void pushKind(byte kind) {
		byte[] stack = myKindStack;
		if (stack.length == myKindStackSize) {
			stack = ZLArrayUtils.createCopy(stack, myKindStackSize, myKindStackSize << 1);
			myKindStack = stack;
		}
		stack[myKindStackSize++] = kind;
	}
	
	public final boolean popKind() {
		if (myKindStackSize != 0) {
			--myKindStackSize;
			return true;
		}
		return false;
	}
	
	public final void beginParagraph() {
		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
	}

	public final void beginParagraph(byte kind) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			textModel.createParagraph(kind);
			final byte[] stack = myKindStack;
			final int size = myKindStackSize;
			for (int i = 0; i < size; ++i) {
				textModel.addControl(stack[i], true);
			}
			if (myHyperlinkReference.length() != 0) {
				textModel.addHyperlinkControl(myHyperlinkKind, hyperlinkType(myHyperlinkKind), myHyperlinkReference);
			}
			myTextParagraphExists = true;
		}		
	}
	
	public final void endParagraph() {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myTextParagraphExists = false;
			myTextParagraphIsNonEmpty = false;
		}
	}
	
	private final void insertEndParagraph(byte kind) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if ((textModel != null) && mySectionContainsRegularContents) {
			int size = textModel.getParagraphsNumber();
			if ((size > 0) && (textModel.getParagraph(size-1).getKind() != kind)) {
				textModel.createParagraph(kind);
				mySectionContainsRegularContents = false;
			}
		}
	}
	
	public final void insertEndOfSectionParagraph() {
		insertEndParagraph(ZLTextParagraph.Kind.END_OF_SECTION_PARAGRAPH);
	}
	
/*	public final void insertEndOfTextParagraph() {
		insertEndParagraph(ZLTextParagraph.Kind.END_OF_TEXT_PARAGRAPH);
	}
*/	
	public final void unsetCurrentTextModel() {
		if (myCurrentTextModel != null) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = null;
	}
	
	public final void enterTitle() {
		myInsideTitle = true;
	}
	
	public final void exitTitle() {
		myInsideTitle = false;
	}
	
	public final void setMainTextModel() {
		if ((myCurrentTextModel != null) && (myCurrentTextModel != Model.BookTextModel)) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = (ZLTextWritableModel)Model.BookTextModel;
	}
	
	public final void setFootnoteTextModel(String id) {
		if ((myCurrentTextModel != null) && (myCurrentTextModel != Model.BookTextModel)) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = (ZLTextWritableModel)Model.getFootnoteModel(id);
	}
	
	public final void addData(char[] data) {
		addData(data, 0, data.length, false);
	}

	public final void addData(char[] data, int offset, int length, boolean direct) {
		if (!myTextParagraphExists || (length == 0)) {
			return;
		}
		myTextParagraphIsNonEmpty = true;

		if (direct && (myTextBufferLength == 0) && !myInsideTitle) {
			myCurrentTextModel.addText(data, offset, length);
		} else {
			final int oldLength = myTextBufferLength;
			final int newLength = oldLength + length;
			if (myTextBuffer.length < newLength) {
				myTextBuffer = ZLArrayUtils.createCopy(myTextBuffer, oldLength, newLength);
			}
			System.arraycopy(data, offset, myTextBuffer, oldLength, length);
			myTextBufferLength = newLength;
			if (myInsideTitle) {
				addContentsData(myTextBuffer, oldLength, length);
			}
		}
		if (!myInsideTitle) {
			mySectionContainsRegularContents = true;
		}
	}

	private byte[] myUnderflowByteBuffer = new byte[4];
	private int myUnderflowLength;

	public final void addByteData(byte[] data, int start, int length) {
		if (!myTextParagraphExists || (length == 0)) {
			return;
		}
		myTextParagraphIsNonEmpty = true;

		final int oldLength = myTextBufferLength;
		if (myTextBuffer.length < oldLength + length) {
			myTextBuffer = ZLArrayUtils.createCopy(myTextBuffer, oldLength, oldLength + length);
		}
		final CharBuffer cb = CharBuffer.wrap(myTextBuffer, myTextBufferLength, length);

		if (myUnderflowLength > 0) {
			int l = myUnderflowLength;
			while (length-- > 0) {
				myUnderflowByteBuffer[l++] = data[start++];
				final ByteBuffer ubb = ByteBuffer.wrap(myUnderflowByteBuffer);
				myByteDecoder.decode(ubb, cb, false);
				if (cb.position() != oldLength) {
					myUnderflowLength = 0;
					break;
				}
			}
			if (length == 0) {
				myUnderflowLength = l;
				return;
			}
		}

		ByteBuffer bb = ByteBuffer.wrap(data, start, length);
		myByteDecoder.decode(bb, cb, false);
		myTextBufferLength = cb.position();
		int rem = bb.remaining();
		if (rem > 0) {
			for (int i = 0, j = start + length - rem; i < rem;) {
				myUnderflowByteBuffer[i++] = data[j++];
			}
			myUnderflowLength = rem;
		}

		if (myInsideTitle) {
			addContentsData(myTextBuffer, oldLength, myTextBufferLength - oldLength);
		} else {
			mySectionContainsRegularContents = true;
		}
	}
	
	private static byte hyperlinkType(byte kind) {
		return (kind == FBTextKind.EXTERNAL_HYPERLINK) ?
			FBHyperlinkType.EXTERNAL : FBHyperlinkType.INTERNAL;
	}

	public final void addHyperlinkControl(byte kind, String label) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addHyperlinkControl(kind, hyperlinkType(kind), label);
		}
		myHyperlinkKind = kind;
		myHyperlinkReference = label;
	}
	
	public final void addHyperlinkLabel(String label) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			int paragraphNumber = textModel.getParagraphsNumber();
			if (myTextParagraphExists) {
				--paragraphNumber;
			}
			Model.addHyperlinkLabel(label, textModel, paragraphNumber);
		}
	}
	
	public final void addHyperlinkLabel(String label, int paragraphIndex) {
		Model.addHyperlinkLabel(label, myCurrentTextModel, paragraphIndex);
	}
	
	public final void addContentsData(char[] data) {
		addContentsData(data, 0, data.length);
	}

	public final void addContentsData(char[] data, int offset, int length) {
		if ((length != 0) && (myCurrentContentsTree != null)) {
			myContentsBuffer.append(data, offset, length);
		}
	}
	
	public final void beginContentsParagraph(int referenceNumber) {
		beginContentsParagraph(Model.BookTextModel, referenceNumber);
	}

	public final void beginContentsParagraph(ZLTextModel bookTextModel, int referenceNumber) {
		final ZLTextModel textModel = myCurrentTextModel;
		if (textModel == bookTextModel) {
			if (referenceNumber == -1) {
				referenceNumber = textModel.getParagraphsNumber();
			}
			TOCTree parentTree = myCurrentContentsTree;
			if (parentTree.Level > 0) {
				if (myContentsBuffer.length() > 0) {
					parentTree.setText(myContentsBuffer.toString());
					myContentsBuffer.delete(0, myContentsBuffer.length());
				} else if (parentTree.getText() == null) {
					parentTree.setText(""..."");
				}
			} else {
				myContentsBuffer.delete(0, myContentsBuffer.length());
			}
			TOCTree tree = new TOCTree(parentTree);
			tree.setReference(myCurrentTextModel, referenceNumber);
			myCurrentContentsTree = tree;
		}
	}
	
	public final void endContentsParagraph() {
		final TOCTree tree = myCurrentContentsTree;
		if (tree.Level == 0) {
			myContentsBuffer.delete(0, myContentsBuffer.length());
			return;
		}
		if (myContentsBuffer.length() > 0) {
			tree.setText(myContentsBuffer.toString());
			myContentsBuffer.delete(0, myContentsBuffer.length());
		} else if (tree.getText() == null) {
			tree.setText(""..."");
		}
		myCurrentContentsTree = tree.Parent;
	}

	public final void setReference(int contentsParagraphNumber, int referenceNumber) {
		setReference(contentsParagraphNumber, myCurrentTextModel, referenceNumber);
	}
	
	public final void setReference(int contentsParagraphNumber, ZLTextWritableModel textModel, int referenceNumber) {
		final TOCTree contentsTree = Model.TOCTree;
		if (contentsParagraphNumber < contentsTree.getSize()) {
			contentsTree.getTreeByParagraphNumber(contentsParagraphNumber).setReference(
				textModel, referenceNumber
			);
		}
	}
	
	public final boolean paragraphIsOpen() {
		return myTextParagraphExists;
	}
	
	public boolean paragraphIsNonEmpty() {
		return myTextParagraphIsNonEmpty;
	}

	public final boolean contentsParagraphIsOpen() {
		return myCurrentContentsTree.Level > 0;
	}

	public final void beginContentsParagraph() {
		beginContentsParagraph(-1);
	}
	
	public final void addImageReference(String ref) {
		addImageReference(ref, (short)0);
	}

	public final void addImageReference(String ref, short vOffset) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			mySectionContainsRegularContents = true;
			if (myTextParagraphExists) {
				flushTextBufferToParagraph();
				textModel.addImage(ref, vOffset);
			} else {
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				textModel.addControl(FBTextKind.IMAGE, true);
				textModel.addImage(ref, vOffset);
				textModel.addControl(FBTextKind.IMAGE, false);
				endParagraph();
			}
		}
	}

	public final void addImage(String id, ZLImage image) {
		Model.addImage(id, image);
	}

	public final void addFixedHSpace(short length) {
		if (myTextParagraphExists) {
			myCurrentTextModel.addFixedHSpace(length);
		}
	}
}
",False,135,2,1,8,28,16,10,L3
68,org.geometerplus.fbreader.bookmodel.FBHyperlinkType.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

public interface FBHyperlinkType {
	byte NONE = 0;
	byte INTERNAL = 1;
	byte EXTERNAL = 2;
}
",False,157,9,34,0,0,2,0,L3
69,org.geometerplus.fbreader.fbreader.ScrollingPreferences.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;

public class ScrollingPreferences {
	private static ScrollingPreferences ourInstance;

	public static ScrollingPreferences Instance() {
		return (ourInstance != null) ? ourInstance : new ScrollingPreferences();
	}

	public final ZLBooleanOption FlickOption = new ZLBooleanOption(""Scrolling"", ""Flick"", true);
	public final ZLBooleanOption VolumeKeysOption = new ZLBooleanOption(""Scrolling"", ""VolumeKeys"", true);
	public final ZLBooleanOption AnimateOption = new ZLBooleanOption(""Scrolling"", ""ShowAnimated"", true);
	public final ZLBooleanOption HorizontalOption = new ZLBooleanOption(""Scrolling"", ""Horizontal"", false);
	public final ZLBooleanOption InvertVolumeKeysOption = new ZLBooleanOption(""Scrolling"", ""InvertVolumeKeys"", false);

	private ScrollingPreferences() {
		ourInstance = this;
	}
}
",False,79,9,24,3,2,3,1,L6
70,org.geometerplus.fbreader.fbreader.FindNextAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class FindNextAction extends FBAction {
	FindNextAction(FBReader fbreader) {
		super(fbreader);
	}

	public boolean isEnabled() {
		FBView view = Reader.getTextView();
		return (view != null) && view.canFindNext();
	}

	public void run() {
		Reader.getTextView().findNext();
	}
}
",False,374,0,0,10,73,1,4,L6
71,org.geometerplus.fbreader.fbreader.FBReader.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.application.*;
import org.geometerplus.zlibrary.core.dialogs.ZLDialogManager;
import org.geometerplus.zlibrary.core.options.*;

import org.geometerplus.zlibrary.text.hyphenation.ZLTextHyphenator;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Library;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Bookmark;
import org.geometerplus.fbreader.optionsDialog.OptionsDialog;

public final class FBReader extends ZLApplication {
	public final ZLStringOption BookSearchPatternOption =
		new ZLStringOption(""BookSearch"", ""Pattern"", """");
	public final ZLStringOption TextSearchPatternOption =
		new ZLStringOption(""TextSearch"", ""Pattern"", """");
	public final ZLStringOption BookmarkSearchPatternOption =
		new ZLStringOption(""BookmarkSearch"", ""Pattern"", """");

	public final ZLBooleanOption UseSeparateBindingsOption = 
		new ZLBooleanOption(""KeysOptions"", ""UseSeparateBindings"", false);

	public final ZLIntegerRangeOption LeftMarginOption =
		new ZLIntegerRangeOption(""Options"", ""LeftMargin"", 0, 1000, 4);
	public final ZLIntegerRangeOption RightMarginOption =
		new ZLIntegerRangeOption(""Options"", ""RightMargin"", 0, 1000, 4);
	public final ZLIntegerRangeOption TopMarginOption =
		new ZLIntegerRangeOption(""Options"", ""TopMargin"", 0, 1000, 0);
	public final ZLIntegerRangeOption BottomMarginOption =
		new ZLIntegerRangeOption(""Options"", ""BottomMargin"", 0, 1000, 4);

	public final ZLIntegerRangeOption ScrollbarTypeOption =
		new ZLIntegerRangeOption(""Options"", ""ScrollbarType"", 0, 2, FBView.SCROLLBAR_SHOW);

	final ZLBooleanOption SelectionEnabledOption =
		new ZLBooleanOption(""Options"", ""IsSelectionEnabled"", true);

	final ZLStringOption ColorProfileOption =
		new ZLStringOption(""Options"", ""ColorProfile"", ColorProfile.DAY);

	private final ZLKeyBindings myBindings = new ZLKeyBindings(""Keys"");

	public final FBView BookTextView;
	final FBView FootnoteView;

	public BookModel Model;

	private final String myArg0;

	public FBReader(String[] args) {
		myArg0 = (args.length > 0) ? args[0] : null;
		addAction(ActionCode.QUIT, new QuitAction(this));

		addAction(ActionCode.INCREASE_FONT, new ChangeFontSizeAction(this, +2));
		addAction(ActionCode.DECREASE_FONT, new ChangeFontSizeAction(this, -2));
		addAction(ActionCode.ROTATE, new RotateAction(this));

		addAction(ActionCode.SHOW_LIBRARY, new ShowLibraryAction(this));
		addAction(ActionCode.SHOW_PREFERENCES, new PreferencesAction(this));
		addAction(ActionCode.SHOW_BOOK_INFO, new BookInfoAction(this));
		addAction(ActionCode.SHOW_CONTENTS, new ShowTOCAction(this));
		addAction(ActionCode.SHOW_BOOKMARKS, new ShowBookmarksAction(this));
		addAction(ActionCode.SHOW_NETWORK_LIBRARY, new ShowNetworkLibraryAction(this));
		
		addAction(ActionCode.SEARCH, new SearchAction(this));
		addAction(ActionCode.FIND_NEXT, new FindNextAction(this));
		addAction(ActionCode.FIND_PREVIOUS, new FindPreviousAction(this));
		addAction(ActionCode.CLEAR_FIND_RESULTS, new ClearFindResultsAction(this));
		
		addAction(ActionCode.SHOW_NAVIGATION, new ShowNavigationAction(this));
		addAction(ActionCode.VOLUME_KEY_SCROLL_FORWARD, new VolumeKeyScrollingAction(this, true));
		addAction(ActionCode.VOLUME_KEY_SCROLL_BACKWARD, new VolumeKeyScrollingAction(this, false));
		addAction(ActionCode.TRACKBALL_SCROLL_FORWARD, new TrackballScrollingAction(this, true));
		addAction(ActionCode.TRACKBALL_SCROLL_BACKWARD, new TrackballScrollingAction(this, false));
		addAction(ActionCode.CANCEL, new CancelAction(this));
		//addAction(ActionCode.COPY_SELECTED_TEXT_TO_CLIPBOARD, new DummyAction(this));
		//addAction(ActionCode.OPEN_SELECTED_TEXT_IN_DICTIONARY, new DummyAction(this));
		//addAction(ActionCode.CLEAR_SELECTION, new DummyAction(this));
		addAction(ActionCode.FOLLOW_HYPERLINK, new FollowHyperlinkAction(this));

		addAction(ActionCode.SWITCH_TO_DAY_PROFILE, new SwitchProfileAction(this, ColorProfile.DAY));
		addAction(ActionCode.SWITCH_TO_NIGHT_PROFILE, new SwitchProfileAction(this, ColorProfile.NIGHT));

		BookTextView = new FBView(this);
		FootnoteView = new FBView(this);

		setView(BookTextView);
	}

	public void initWindow() {
		super.initWindow();
		ZLDialogManager.Instance().wait(""loadingBook"", new Runnable() {
			public void run() { 
				Book book = createBookForFile(ZLFile.createFileByPath(myArg0));
				if (book == null) {
					book = Library.Instance().getRecentBook();
				}
				if ((book == null) || !book.File.exists()) {
					book = Book.getByFile(Library.Instance().getHelpFile());
				}
				openBookInternal(book, null);
			}
		});
	}
	
	public void openBook(final Book book, final Bookmark bookmark) {
		ZLDialogManager.Instance().wait(""loadingBook"", new Runnable() {
			public void run() { 
				openBookInternal(book, bookmark); 
			}
		});
	}

	private ColorProfile myColorProfile;

	public ColorProfile getColorProfile() {
		if (myColorProfile == null) {
			myColorProfile = ColorProfile.get(getColorProfileName());
		}
		return myColorProfile;
	}

	public String getColorProfileName() {
		return ColorProfileOption.getValue();
	}

	public void setColorProfileName(String name) {
		ColorProfileOption.setValue(name);
		myColorProfile = null;
	}

	public ZLKeyBindings keyBindings() {
		return myBindings;
	}

	public FBView getTextView() {
		return (FBView)getCurrentView();
	}

	void tryOpenFootnote(String id) {
		if (Model != null) {
			BookModel.Label label = Model.getLabel(id);
			if (label != null) {
				if (label.ModelId == null) {
					BookTextView.gotoPosition(label.ParagraphIndex, 0, 0);
				} else {
					FootnoteView.setModel(Model.getFootnoteModel(label.ModelId));
					setView(FootnoteView);
					FootnoteView.gotoPosition(label.ParagraphIndex, 0, 0);
				}
				repaintView();
			}
		}
	}

	public void clearTextCaches() {
		BookTextView.clearCaches();
		FootnoteView.clearCaches();
	}
	
	void openBookInternal(Book book, Bookmark bookmark) {
		if (book != null) {
			onViewChanged();

			if (Model != null) {
				Model.Book.storePosition(BookTextView.getStartCursor());
			}
			BookTextView.setModel(null);
			FootnoteView.setModel(null);
			clearTextCaches();

			Model = null;
			System.gc();
			System.gc();
			Model = BookModel.createModel(book);
			if (Model != null) {
				ZLTextHyphenator.Instance().load(book.getLanguage());
				BookTextView.setModel(Model.BookTextModel);
				BookTextView.gotoPosition(book.getStoredPosition());
				if (bookmark == null) {
					setView(BookTextView);
				} else {
					gotoBookmark(bookmark);
				}
				Library.Instance().addBookToRecentList(book);
			}
		}
		repaintView();
	}

	public void gotoBookmark(Bookmark bookmark) {
		final String modelId = bookmark.getModelId();
		if (modelId == null) {
			BookTextView.gotoPosition(bookmark);
			setView(BookTextView);
		} else {
			FootnoteView.setModel(Model.getFootnoteModel(modelId));
			FootnoteView.gotoPosition(bookmark);
			setView(FootnoteView);
		}
		repaintView();
	}
	
	public void showBookTextView() {
		setView(BookTextView);
	}
	
	private Book createBookForFile(ZLFile file) {
		if (file == null) {
			return null;
		}
		Book book = Book.getByFile(file);
		if (book != null) {
			book.insertIntoBookList();
			return book;
		}
		if (file.isArchive()) {
			for (ZLFile child : file.children()) {
				book = Book.getByFile(child);
				if (book != null) {
					book.insertIntoBookList();
					return book;
				}
			}
		}
		return null;
	}

	@Override
	public void openFile(ZLFile file) {
		final Book book = createBookForFile(file);
		if (book != null) {
			openBook(book, null);
		}
	}

	public void onWindowClosing() {
		if ((Model != null) && (BookTextView != null)) {
			Model.Book.storePosition(BookTextView.getStartCursor());
		}
	}

	public void showOptionsDialog() {
		new OptionsDialog(this).getDialog().run();
	}
}
",False,377,1,3,9,82,31,37,L6
72,org.geometerplus.fbreader.fbreader.ShowBookmarks.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.android.fbreader.BookmarksActivity;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

class ShowBookmarksAction extends FBAction {
	ShowBookmarksAction(FBReader fbreader) {
		super(fbreader);
	}

	public void run() {
		final ZLAndroidDialogManager dialogManager =
			(ZLAndroidDialogManager)ZLAndroidDialogManager.Instance();
		dialogManager.runActivity(BookmarksActivity.class);
	}
}
",False,374,0,0,10,87,1,5,L6
73,org.geometerplus.fbreader.fbreader.ActionCode.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

public interface ActionCode {
	String SHOW_LIBRARY = ""library"";
	String SHOW_PREFERENCES = ""preferences"";
	String SHOW_BOOK_INFO = ""bookInfo"";
	String SHOW_CONTENTS = ""toc"";
	String SHOW_BOOKMARKS = ""bookmarks"";
	String SHOW_NETWORK_LIBRARY = ""networkLibrary"";

	String SWITCH_TO_NIGHT_PROFILE = ""night"";
	String SWITCH_TO_DAY_PROFILE = ""day"";

	String SEARCH = ""search"";
	String FIND_PREVIOUS = ""findPrevious"";
	String FIND_NEXT = ""findNext"";
	String CLEAR_FIND_RESULTS = ""clearFindResults"";

	String VOLUME_KEY_SCROLL_FORWARD = ""volumeKeyScrollForward"";
	String VOLUME_KEY_SCROLL_BACKWARD = ""volumeKeyScrollBackward"";
	String TRACKBALL_SCROLL_FORWARD = ""trackballScrollForward"";
	String TRACKBALL_SCROLL_BACKWARD = ""trackballScrollBackward"";
	String SHOW_NAVIGATION = ""navigate"";
	String CANCEL = ""cancel"";
	String ROTATE = ""rotate"";
	String INCREASE_FONT = ""increaseFont"";
	String DECREASE_FONT = ""decreaseFont"";
	String TOGGLE_FULLSCREEN = ""toggleFullscreen"";
	String FULLSCREEN_ON = ""onFullscreen"";
	String QUIT = ""quit"";
	String COPY_SELECTED_TEXT_TO_CLIPBOARD = ""copyToClipboard"";
	String CLEAR_SELECTION = ""clearSelection"";
	String OPEN_SELECTED_TEXT_IN_DICTIONARY = ""openInDictionary"";
	String FOLLOW_HYPERLINK = ""followHyperlink"";
};
",False,75,7,31,0,0,3,0,L6
74,org.geometerplus.fbreader.fbreader.FBAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.application.ZLApplication;

abstract class FBAction extends ZLApplication.ZLAction {
	protected final FBReader Reader;

	FBAction(FBReader fbreader) {
		Reader = fbreader;
	}
}
",False,374,0,0,10,80,19,2,L6
75,org.geometerplus.fbreader.fbreader.ShowNavigationAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class ShowNavigationAction extends FBAction {
	ShowNavigationAction(FBReader fbreader) {
		super(fbreader);
	}

	@Override
	public boolean isVisible() {
		return Reader.canNavigate();
	}

	public void run() {
		Reader.navigate();
	}
}
",False,374,0,0,10,80,1,3,L6
76,org.geometerplus.fbreader.fbreader.ShowNetworkLibraryAction.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.android.fbreader.network.NetworkLibraryActivity;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

class ShowNetworkLibraryAction extends FBAction {
	ShowNetworkLibraryAction(FBReader fbreader) {
		super(fbreader);
	}

	public void run() {
		final ZLAndroidDialogManager dialogManager =
			(ZLAndroidDialogManager)ZLAndroidDialogManager.Instance();
		dialogManager.runActivity(NetworkLibraryActivity.class);
	}
}
",False,374,0,0,8,120,1,5,L6
77,org.geometerplus.fbreader.fbreader.ShowLibraryAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.fbreader.library.Library;

import org.geometerplus.android.fbreader.LibraryTabActivity;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

class ShowLibraryAction extends FBAction {
	ShowLibraryAction(FBReader fbreader) {
		super(fbreader);
	}

	public void run() {
		final ZLAndroidDialogManager dialogManager =
			(ZLAndroidDialogManager)ZLAndroidDialogManager.Instance();
		Runnable action = new Runnable() {
			public void run() {
				Library library = Library.Instance();
				library.clear();
				library.synchronize();
				// TODO: select current book (author?)
				/*
				if (myBookModel != null) {
					CollectionView.selectBook(myBookModel.Description);
				}
				*/
				//setView(CollectionView);
				dialogManager.runActivity(LibraryTabActivity.class);
			}
		};
		dialogManager.wait(""loadingBookList"", action);
	}
}
",False,374,0,0,10,75,1,6,L6
78,org.geometerplus.fbreader.fbreader.QuitAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class QuitAction extends FBAction {
	QuitAction(FBReader fbreader) {
		super(fbreader);
	}
		
	public void run() {
		Reader.closeWindow();
	}		
}
",False,374,0,0,10,80,1,3,L6
79,org.geometerplus.fbreader.fbreader.FollowHyperlinkAction.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

public class FollowHyperlinkAction extends FBAction {
	FollowHyperlinkAction(FBReader fbreader) {
		super(fbreader);
	}

	public boolean isEnabled() {
		FBView view = Reader.getTextView();
		return (view != null) && (view.getCurrentHyperlink() != null);
	}

	public void run() {
		FBView view = Reader.getTextView();
		view.followHyperlink(view.getCurrentHyperlink());
	}
}
",False,374,0,0,10,73,1,4,L6
80,org.geometerplus.fbreader.fbreader.ChangeFontSizeAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;
import org.geometerplus.zlibrary.text.view.style.ZLTextStyleCollection;

class ChangeFontSizeAction extends FBAction {
	private final int myDelta;

	ChangeFontSizeAction(FBReader fbreader, int delta) {
		super(fbreader);
		myDelta = delta;
	}

	public void run() {
		ZLIntegerRangeOption option =
			ZLTextStyleCollection.Instance().getBaseStyle().FontSizeOption;
		option.setValue(option.getValue() + myDelta);
		Reader.clearTextCaches();
		Reader.repaintView();
	}
}
",False,374,0,0,10,77,1,6,L6
81,org.geometerplus.fbreader.fbreader.BookInfoAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.android.fbreader.preferences.BookInfoActivity;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

class BookInfoAction extends FBAction {
	BookInfoAction(FBReader fbreader) {
		super(fbreader);
	}

	public boolean isVisible() {
		return Reader.Model != null;
	}

	public void run() {
		final ZLAndroidDialogManager dialogManager =
			(ZLAndroidDialogManager)ZLAndroidDialogManager.Instance();
		dialogManager.runActivity(BookInfoActivity.class);
	}
}
",False,374,0,0,10,88,1,5,L6
82,org.geometerplus.fbreader.fbreader.SearchAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.dialogs.ZLDialogManager;

class SearchAction extends FBAction {
	SearchAction(FBReader fbreader) {
		super(fbreader);
	}

	public boolean isVisible() {
		return Reader.Model != null;
	}

	public void run() {
		ZLDialogManager.Instance().startSearch();
	}
}
",False,374,0,0,10,81,1,3,L6
83,org.geometerplus.fbreader.fbreader.VolumeKeyScrollingAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class VolumeKeyScrollingAction extends FBAction {
	private final boolean myForward;

	VolumeKeyScrollingAction(FBReader fbreader, boolean forward) {
		super(fbreader);
		myForward = forward;
	}
		
	public boolean isEnabled() {
		return ScrollingPreferences.Instance().VolumeKeysOption.getValue();
	}

	public void run() {
		boolean isInverted = ScrollingPreferences.Instance().InvertVolumeKeysOption.getValue();
		Reader.getTextView().doScrollPage(isInverted ? !myForward : myForward);
	}		
}
",False,374,0,0,10,76,1,5,L6
84,org.geometerplus.fbreader.fbreader.TrackballScrollingAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class TrackballScrollingAction extends FBAction {
	private final boolean myForward;

	TrackballScrollingAction(FBReader fbreader, boolean forward) {
		super(fbreader);
		myForward = forward;
	}
		
	public boolean isEnabled() {
		return true;
	}

	public void run() {
		Reader.getTextView().doShortScroll(myForward);
	}		
}
",False,374,0,0,10,77,1,3,L6
85,org.geometerplus.fbreader.fbreader.ClearFindResultsAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class ClearFindResultsAction extends FBAction {
	ClearFindResultsAction(FBReader fbreader) {
		super(fbreader);
	}

	public void run() {
		Reader.getTextView().clearFindResults();
	}
}
",False,374,0,0,10,73,1,3,L6
86,org.geometerplus.fbreader.fbreader.FindPreviousAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.text.view.ZLTextView;

class FindPreviousAction extends FBAction {
	FindPreviousAction(FBReader fbreader) {
		super(fbreader);
	}

	public boolean isEnabled() {
		ZLTextView view = Reader.getTextView();
		return (view != null) && view.canFindPrevious();
	}

	public void run() {
		Reader.getTextView().findPrevious();
	}
}
",False,374,0,0,10,73,1,3,L6
87,org.geometerplus.fbreader.fbreader.PreferencesAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.android.fbreader.preferences.PreferenceActivity;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

class PreferencesAction extends FBAction {
	PreferencesAction(FBReader fbreader) {
		super(fbreader);
	}

	public void run() {
		final ZLAndroidDialogManager dialogManager =
			(ZLAndroidDialogManager)ZLAndroidDialogManager.Instance();
		dialogManager.runActivity(PreferenceActivity.class);
	}
}
",False,374,0,0,10,87,1,5,L6
88,org.geometerplus.fbreader.fbreader.CancelAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class CancelAction extends FBAction {
	CancelAction(FBReader fbreader) {
		super(fbreader);
	}

	public void run() {
		if (Reader.getCurrentView() != Reader.BookTextView) {
			Reader.showBookTextView();
		} else {
			Reader.closeWindow();
		}
	}
}
",False,374,0,0,10,80,1,3,L6
89,org.geometerplus.fbreader.fbreader.FBView.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.application.ZLApplication;
import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.text.model.ZLTextModel;
import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.fbreader.bookmodel.FBHyperlinkType;

public final class FBView extends ZLTextView {
	private FBReader myReader;

	FBView(FBReader reader) {
		super(ZLibrary.Instance().getPaintContext());
		myReader = reader;
	}

	public void setModel(ZLTextModel model) {
		myIsManualScrollingActive = false;
		super.setModel(model);
	}

	final void doShortScroll(boolean forward) {
		if (!moveHyperlinkPointer(forward)) {
			scrollPage(forward, ZLTextView.ScrollingMode.SCROLL_LINES, 1);
		}

		ZLApplication.Instance().repaintView();
	}

	public void onScrollingFinished(int viewPage) {
		super.onScrollingFinished(viewPage);
	}

	final void doScrollPage(boolean forward) {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();
		if (preferences.AnimateOption.getValue()) {
			if (forward) {
				ZLTextWordCursor cursor = getEndCursor();
				if (cursor != null &&
					!cursor.isNull() &&
					(!cursor.isEndOfParagraph() || !cursor.getParagraphCursor().isLast())) {
					startAutoScrolling(preferences.HorizontalOption.getValue() ? PAGE_RIGHT : PAGE_BOTTOM);
				}
			} else {
				ZLTextWordCursor cursor = getStartCursor();
				if (cursor != null &&
					!cursor.isNull() &&
					(!cursor.isStartOfParagraph() || !cursor.getParagraphCursor().isFirst())) {
					startAutoScrolling(preferences.HorizontalOption.getValue() ? PAGE_LEFT : PAGE_TOP);
				}
			}
		} else {
			scrollPage(forward, ZLTextView.ScrollingMode.NO_OVERLAPPING, 0);
			ZLApplication.Instance().repaintView();
		}
	}

	void followHyperlink(ZLTextHyperlink hyperlink) {
		switch (hyperlink.Type) {
			case FBHyperlinkType.EXTERNAL:
				ZLibrary.Instance().openInBrowser(hyperlink.Id);
				break;
			case FBHyperlinkType.INTERNAL:
				((FBReader)ZLApplication.Instance()).tryOpenFootnote(hyperlink.Id);
				break;
		}
	}

	private int myStartX;
	private int myStartY;
	private boolean myIsManualScrollingActive;

	public boolean onStylusPress(int x, int y) {
		if (super.onStylusPress(x, y)) {
			return true;
		}

		if (isScrollingActive()) {
			return false;
		}

		final ZLTextHyperlink hyperlink = findHyperlink(x, y, 10);
		if (hyperlink != null) {
			selectHyperlink(hyperlink);
			ZLApplication.Instance().repaintView();
			followHyperlink(hyperlink);
			return true;
		}

		final ScrollingPreferences preferences = ScrollingPreferences.Instance();
		if (preferences.FlickOption.getValue()) {
			myStartX = x;
			myStartY = y;
			setScrollingActive(true);
			myIsManualScrollingActive = true;
		} else {
			if (preferences.HorizontalOption.getValue()) {
				if (x <= Context.getWidth() / 3) {
					doScrollPage(false);
				} else if (x >= Context.getWidth() * 2 / 3) {
					doScrollPage(true);
				}
			} else {
				if (y <= Context.getHeight() / 3) {
					doScrollPage(false);
				} else if (y >= Context.getHeight() * 2 / 3) {
					doScrollPage(true);
				}
			}
		}

		//activateSelection(x, y);
		return true;
	}

	public boolean onStylusMovePressed(int x, int y) {
		if (super.onStylusMovePressed(x, y)) {
			return true;
		}

		synchronized (this) {
			if (isScrollingActive() && myIsManualScrollingActive) {
				final boolean horizontal = ScrollingPreferences.Instance().HorizontalOption.getValue();
				final int diff = horizontal ? x - myStartX : y - myStartY;
				if (diff > 0) {
					ZLTextWordCursor cursor = getStartCursor();
					if (cursor == null || cursor.isNull()) {
						return false;
					}
					if (!cursor.isStartOfParagraph() || !cursor.getParagraphCursor().isFirst()) {
						ZLApplication.Instance().scrollViewTo(horizontal ? PAGE_LEFT : PAGE_TOP, diff);
					}
				} else if (diff < 0) {
					ZLTextWordCursor cursor = getEndCursor();
					if (cursor == null || cursor.isNull()) {
						return false;
					}
					if (!cursor.isEndOfParagraph() || !cursor.getParagraphCursor().isLast()) {
						ZLApplication.Instance().scrollViewTo(horizontal ? PAGE_RIGHT : PAGE_BOTTOM, -diff);
					}
				} else {
					ZLApplication.Instance().scrollViewTo(PAGE_CENTRAL, 0);
				}
				return true;
			}
		}

		return false;
	}

	public boolean onStylusRelease(int x, int y) {
		if (super.onStylusRelease(x, y)) {
			return true;
		}

		synchronized (this) {
			if (isScrollingActive() && myIsManualScrollingActive) {
				setScrollingActive(false);
				myIsManualScrollingActive = false;
				final boolean horizontal = ScrollingPreferences.Instance().HorizontalOption.getValue();
				final int diff = horizontal ? x - myStartX : y - myStartY;
				boolean doScroll = false;
				if (diff > 0) {
					ZLTextWordCursor cursor = getStartCursor();
					if (cursor != null && !cursor.isNull()) {
						doScroll = !cursor.isStartOfParagraph() || !cursor.getParagraphCursor().isFirst();
					}
				} else if (diff < 0) {
					ZLTextWordCursor cursor = getEndCursor();
					if (cursor != null && !cursor.isNull()) {
						doScroll = !cursor.isEndOfParagraph() || !cursor.getParagraphCursor().isLast();
					}
				}
				if (doScroll) {
					final int h = Context.getHeight();
					final int w = Context.getWidth();
					final int minDiff = horizontal ?
						((w > h) ? w / 4 : w / 3) :
						((h > w) ? h / 4 : h / 3);
					int viewPage = PAGE_CENTRAL;
					if (Math.abs(diff) > minDiff) {
						viewPage = horizontal ?
							((diff < 0) ? PAGE_RIGHT : PAGE_LEFT) :
							((diff < 0) ? PAGE_BOTTOM : PAGE_TOP);
					}
					if (ScrollingPreferences.Instance().AnimateOption.getValue()) {
						startAutoScrolling(viewPage);
					} else {
						ZLApplication.Instance().scrollViewTo(PAGE_CENTRAL, 0);
						onScrollingFinished(viewPage);
						ZLApplication.Instance().repaintView();
						setScrollingActive(false);
					}
				}
				return true;
			}
		}
		return false;
	}

	public boolean onTrackballRotated(int diffX, int diffY) {
		if (diffY > 0) {
			ZLApplication.Instance().doAction(ActionCode.TRACKBALL_SCROLL_FORWARD);
		} else if (diffY < 0) {
			ZLApplication.Instance().doAction(ActionCode.TRACKBALL_SCROLL_BACKWARD);
		}
		return true;
	}

	@Override
	public int getLeftMargin() {
		return myReader.LeftMarginOption.getValue();
	}

	@Override
	public int getRightMargin() {
		return myReader.RightMarginOption.getValue();
	}

	@Override
	public int getTopMargin() {
		return myReader.TopMarginOption.getValue();
	}

	@Override
	public int getBottomMargin() {
		return myReader.BottomMarginOption.getValue();
	}

	@Override
	public ZLColor getBackgroundColor() {
		return myReader.getColorProfile().BackgroundOption.getValue();
	}

	@Override
	public ZLColor getSelectedBackgroundColor() {
		return myReader.getColorProfile().SelectionBackgroundOption.getValue();
	}

	@Override
	public ZLColor getTextColor(byte hyperlinkType) {
		final ColorProfile profile = myReader.getColorProfile();
		switch (hyperlinkType) {
			default:
			case FBHyperlinkType.NONE:
				return profile.RegularTextOption.getValue();
			case FBHyperlinkType.INTERNAL:
			case FBHyperlinkType.EXTERNAL:
				return profile.HyperlinkTextOption.getValue();
		}
	}

	@Override
	public ZLColor getHighlightingColor() {
		return myReader.getColorProfile().HighlightingOption.getValue();
	}

	protected boolean isSelectionEnabled() {
		return myReader.SelectionEnabledOption.getValue();
	}
	
	@Override
	public int scrollbarType() {
		return myReader.ScrollbarTypeOption.getValue();
	}
}
",True,374,0,0,10,74,5,18,L6
90,org.geometerplus.fbreader.fbreader.RotateAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class RotateAction extends FBAction {
	RotateAction(FBReader fbreader) {
		super(fbreader);
	}

	public void run() {
		Reader.rotateScreen();
	}

	public boolean isVisible() {
		return Reader.canRotateScreen();
	}
}
",False,374,0,0,10,80,1,3,L6
91,org.geometerplus.fbreader.fbreader.ShowTOCAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.android.fbreader.TOCActivity;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

class ShowTOCAction extends FBAction {
	ShowTOCAction(FBReader fbreader) {
		super(fbreader);
	}

	public boolean isVisible() {
		return (Reader.Model != null) && Reader.Model.TOCTree.hasChildren();
	}

	public void run() {
		final ZLAndroidDialogManager dialogManager =
			(ZLAndroidDialogManager)ZLAndroidDialogManager.Instance();
		dialogManager.runActivity(TOCActivity.class);
	}
}
",False,374,0,0,10,88,1,7,L6
92,org.geometerplus.fbreader.fbreader.ColorProfile.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.options.*;

public class ColorProfile {
	public static final String DAY = ""defaultLight"";
	public static final String NIGHT = ""defaultDark"";

	private static final ArrayList<String> ourNames = new ArrayList<String>();
	private static final HashMap<String,ColorProfile> ourProfiles = new HashMap<String,ColorProfile>();

	public static List<String> names() {
		if (ourNames.isEmpty()) {
			final int size = new ZLIntegerOption(""Colors"", ""NumberOfSchemes"", 0).getValue();
			if (size == 0) {
				ourNames.add(DAY);
				ourNames.add(NIGHT);
			} else for (int i = 0; i < size; ++i) {
				ourNames.add(new ZLStringOption(""Colors"", ""Scheme"" + i, """").getValue());
			}
		}
		return Collections.unmodifiableList(ourNames);
	}

	public static ColorProfile get(String name) {
		ColorProfile profile = ourProfiles.get(name);
		if (profile == null) {
			profile = new ColorProfile(name);
			ourProfiles.put(name, profile);
		}
		return profile;
	}

	public final ZLColorOption BackgroundOption;
	public final ZLColorOption SelectionBackgroundOption;
	public final ZLColorOption HighlightingOption;
	public final ZLColorOption RegularTextOption;
	public final ZLColorOption HyperlinkTextOption;

	private ColorProfile(String name, ColorProfile base) {
		this(name);
		BackgroundOption.setValue(base.BackgroundOption.getValue());
		SelectionBackgroundOption.setValue(base.SelectionBackgroundOption.getValue());
		HighlightingOption.setValue(base.HighlightingOption.getValue());
		RegularTextOption.setValue(base.RegularTextOption.getValue());
		HyperlinkTextOption.setValue(base.HyperlinkTextOption.getValue());
	}

	private ColorProfile(String name) {
		if (NIGHT.equals(name)) {
			BackgroundOption =
				new ZLColorOption(""Colors"", name + "":Background"", new ZLColor(0, 0, 0));
			SelectionBackgroundOption =
				new ZLColorOption(""Colors"", name + "":SelectionBackground"", new ZLColor(82, 131, 194));
			HighlightingOption =
				new ZLColorOption(""Colors"", name + "":Highlighting"", new ZLColor(96, 96, 128));
			RegularTextOption =
				new ZLColorOption(""Colors"", name + "":Text"", new ZLColor(192, 192, 192));
			HyperlinkTextOption =
				new ZLColorOption(""Colors"", name + "":Hyperlink"", new ZLColor(60, 142, 224));
		} else {
			BackgroundOption =
				new ZLColorOption(""Colors"", name + "":Background"", new ZLColor(255, 255, 255));
			SelectionBackgroundOption =
				new ZLColorOption(""Colors"", name + "":SelectionBackground"", new ZLColor(82, 131, 194));
			HighlightingOption =
				new ZLColorOption(""Colors"", name + "":Highlighting"", new ZLColor(255, 192, 128));
			RegularTextOption =
				new ZLColorOption(""Colors"", name + "":Text"", new ZLColor(0, 0, 0));
			HyperlinkTextOption =
				new ZLColorOption(""Colors"", name + "":Hyperlink"", new ZLColor(60, 139, 255));
		}
	}
}
",True,82,8,29,3,4,3,4,L6
93,org.geometerplus.fbreader.fbreader.SwitchProfileAction.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class SwitchProfileAction extends FBAction {
	private String myProfileName;

	SwitchProfileAction(FBReader fbreader, String profileName) {
		super(fbreader);
		myProfileName = profileName;
	}

	public boolean isVisible() {
		return !myProfileName.equals(Reader.getColorProfileName());
	}

	public void run() {
		Reader.setColorProfileName(myProfileName);
		Reader.repaintView();
	}
}
",False,374,0,0,10,80,1,3,L6
94,org.geometerplus.fbreader.optionsDialog.OptionsDialog.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.optionsDialog;

import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.dialogs.*;
import org.geometerplus.zlibrary.core.optionEntries.*;
//import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.fbreader.*;

public class OptionsDialog {
	private ZLOptionsDialog myDialog;
	
	public OptionsDialog(FBReader fbreader) {
		myDialog = ZLDialogManager.Instance().createOptionsDialog(""OptionsDialog"", null, new OptionsApplyRunnable(fbreader), true);

		ZLDialogContent marginTab = myDialog.createTab(""Margins"");
		marginTab.addOptions(
			""left"", new ZLSimpleSpinOptionEntry(fbreader.LeftMarginOption, 1),
			""right"", new ZLSimpleSpinOptionEntry(fbreader.RightMarginOption, 1)
		);
		marginTab.addOptions(
			""top"", new ZLSimpleSpinOptionEntry(fbreader.TopMarginOption, 1),
			""bottom"", new ZLSimpleSpinOptionEntry(fbreader.BottomMarginOption, 1)
		);
		
		new FormatOptionsPage(myDialog.createTab(""Format""));
			
		new StyleOptionsPage(myDialog.createTab(""Styles""), ZLibrary.Instance().getPaintContext());
		
		final ZLDialogContent colorsTab = myDialog.createTab(""Colors"");
		final String colorKey = ""colorFor"";
		final ZLResource resource = colorsTab.getResource(colorKey);
		final ZLColorOptionBuilder builder = new ZLColorOptionBuilder();
		final String BACKGROUND = resource.getResource(""background"").getValue();
		final ColorProfile profile = fbreader.getColorProfile();
		builder.addOption(BACKGROUND, profile.BackgroundOption);
		builder.addOption(resource.getResource(""highlighting"").getValue(), profile.HighlightingOption);
		builder.addOption(resource.getResource(""text"").getValue(), profile.RegularTextOption);
		builder.addOption(resource.getResource(""hyperlink"").getValue(), profile.HyperlinkTextOption);
		builder.setInitial(BACKGROUND);
		colorsTab.addOption(colorKey, builder.comboEntry());
		colorsTab.addOption("""", builder.colorEntry());
	}
	
	public ZLOptionsDialog getDialog() {
		return myDialog;
	}
	
	private static class OptionsApplyRunnable implements Runnable {
		private final FBReader myFBReader;
		
		public OptionsApplyRunnable(FBReader fbreader) {
			myFBReader = fbreader;
		}
		
		public void run() {
			myFBReader.clearTextCaches();
			myFBReader.repaintView();
		}
	}
	
	/*private static class StateOptionEntry extends ZLToggleBooleanOptionEntry {
		private boolean myState;
		
		public StateOptionEntry(ZLBooleanOption option) {
			super(option);
			myState = option.getValue();
		}
	
		public void onStateChanged(boolean state) {
			myState = state;
			super.onStateChanged(state);
		}
	}

	private static class SpecialFontSizeEntry extends ZLSimpleSpinOptionEntry {
		private StateOptionEntry myFirst;
		private StateOptionEntry mySecond;
		
		public SpecialFontSizeEntry(ZLIntegerRangeOption option, int step, StateOptionEntry first, StateOptionEntry second) {
			super(option, step);
			myFirst = first;
			mySecond = second;
		}

		public void setVisible(boolean state) {
			super.setVisible(
					(myFirst.isVisible() && myFirst.myState) ||
					(mySecond.isVisible() && mySecond.myState)
			);
		}	
	}*/
}
",False,374,0,0,10,74,1,12,L6
95,org.geometerplus.fbreader.optionsDialog.ComboOptionEntry.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.optionsDialog;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map.Entry;

import org.geometerplus.zlibrary.core.dialogs.ZLComboOptionEntry;
import org.geometerplus.zlibrary.core.dialogs.ZLOptionEntry;

class ComboOptionEntry extends ZLComboOptionEntry {
	protected final OptionsPage myPage;
	protected final ArrayList<String> myValues = new ArrayList<String>();
	protected String myInitialValue;
	
	public ComboOptionEntry(final OptionsPage myPage, String myInitialValue) {
		this.myPage = myPage;
		this.myInitialValue = myInitialValue;
	}

	public ArrayList<String> getValues() {
		return myValues;
	}

	public String initialValue() {
		return myInitialValue;
	}

	public void onAccept(String value) {}

	@Override
	public void onReset() {
		onValueSelected(0);
	}

	@Override
	public void onValueSelected(int index) {
		final Object selectedValue = myValues.get(index);
		final LinkedHashMap<ZLOptionEntry, String> entries = myPage.getEntries();
/*		for (Iterator it = entries.keySet().iterator(); it.hasNext(); ) {
			ZLOptionEntry entry = (ZLOptionEntry) it.next();
			entry.setVisible(selectedValue != null && selectedValue.equals(entries.get(entry)));
			if (entry.isVisible())
				System.out.println(entry.getKind()+"" ""+entry.hashCode());
		} 
	*/
		for (Iterator<Entry<ZLOptionEntry, String>> it = entries.entrySet().iterator(); it.hasNext(); ) {
			Entry<ZLOptionEntry, String> entry = it.next();
			entry.getKey().setVisible(selectedValue != null && selectedValue.equals(entry.getValue()));
		} 
	}

	public void addValue(final String value) {
		myValues.add(value);
	}
}
",False,129,10,30,9,11,3,3,L6
96,org.geometerplus.fbreader.optionsDialog.FormatOptionsPage.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.optionsDialog;

import org.geometerplus.zlibrary.core.dialogs.ZLDialogContent;
import org.geometerplus.zlibrary.core.optionEntries.ZLSimpleSpinOptionEntry;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.text.view.ZLTextAlignmentOptionEntry;
import org.geometerplus.zlibrary.text.view.ZLTextLineSpaceOptionEntry;
import org.geometerplus.zlibrary.text.view.style.ZLTextBaseStyle;
import org.geometerplus.zlibrary.text.view.style.ZLTextStyleCollection;
import org.geometerplus.zlibrary.text.view.style.ZLTextStyleDecoration;
import org.geometerplus.zlibrary.text.view.style.ZLTextFullStyleDecoration;

import static org.geometerplus.fbreader.bookmodel.FBTextKind.*;

class FormatOptionsPage extends OptionsPage {
	private static final String KEY_STYLE = ""style"";
	private static final String KEY_BASE = ""Base"";

	private static final String KEY_DUMMY = """";
	private static final String KEY_LINESPACING = ""lineSpacing"";
	private static final String KEY_FIRSTLINEINDENT = ""firstLineIndent"";
	private static final String KEY_ALIGNMENT = ""alignment"";
	private static final String KEY_SPACEBEFORE = ""spaceBefore"";
	private static final String KEY_SPACEAFTER = ""spaceAfter"";
	private static final String KEY_LEFTINDENT = ""leftIndent"";
	private static final String KEY_RIGHTINDENT = ""rightIndent"";
	
	public FormatOptionsPage(ZLDialogContent dialogTab) {
		final ZLResource styleResource = ZLResource.resource(KEY_STYLE);

		myComboEntry = new ComboOptionEntry(this, styleResource.getResource(KEY_BASE).getValue());
		myComboEntry.addValue(myComboEntry.initialValue());

		ZLTextStyleCollection collection = ZLTextStyleCollection.Instance();
		byte styles[] = { REGULAR, TITLE, SECTION_TITLE, SUBTITLE, H1, H2, H3, H4, H5, H6, ANNOTATION, EPIGRAPH, PREFORMATTED, AUTHOR,/* DATEKIND,*/ POEM_TITLE, STANZA, VERSE };
		final int stylesNumber = styles.length;
		for (int i = 0; i < stylesNumber; ++i) {
			final ZLTextStyleDecoration decoration = collection.getDecoration(styles[i]);
			if (decoration != null) {
				myComboEntry.addValue(styleResource.getResource(decoration.getName()).getValue());
			}
		}
		dialogTab.addOption(""optionsFor"", myComboEntry);

		{
			final String name = myComboEntry.initialValue();
			ZLTextBaseStyle baseStyle = collection.getBaseStyle();

			registerEntries(dialogTab,
				KEY_LINESPACING, new ZLTextLineSpaceOptionEntry(baseStyle.LineSpacePercentOption, dialogTab.getResource(KEY_LINESPACING), false),
				KEY_DUMMY, null,//new ZLSimpleSpinOptionEntry(""First Line Indent"", baseStyle.firstLineIndentDeltaOption(), -300, 300, 1),
				name
			);

			registerEntries(dialogTab,
				KEY_ALIGNMENT, new ZLTextAlignmentOptionEntry(baseStyle.AlignmentOption, dialogTab.getResource(KEY_ALIGNMENT), false),
				KEY_DUMMY, null,
				name
			);
		}

		for (int i = 0; i < stylesNumber; ++i) {
			ZLTextStyleDecoration d = collection.getDecoration(styles[i]);
			if ((d != null) && (d.isFullDecoration())) {
				ZLTextFullStyleDecoration decoration = (ZLTextFullStyleDecoration) d;
				final String name = styleResource.getResource(decoration.getName()).getValue();
				
				registerEntries(dialogTab,
					KEY_SPACEBEFORE, new ZLSimpleSpinOptionEntry(decoration.SpaceBeforeOption, 1),
					KEY_LEFTINDENT, new ZLSimpleSpinOptionEntry(decoration.LeftIndentOption, 1),
					name
				);
				
				registerEntries(dialogTab,
					KEY_SPACEAFTER, new ZLSimpleSpinOptionEntry(decoration.SpaceAfterOption, 1),
					KEY_RIGHTINDENT, new ZLSimpleSpinOptionEntry(decoration.RightIndentOption, 1),
					name
				);
				
				registerEntries(dialogTab,
					KEY_LINESPACING, new ZLTextLineSpaceOptionEntry(decoration.LineSpacePercentOption, dialogTab.getResource(KEY_LINESPACING), true),
					KEY_FIRSTLINEINDENT, new ZLSimpleSpinOptionEntry(decoration.FirstLineIndentDeltaOption, 1),
					name
				);

				registerEntries(dialogTab,
					KEY_ALIGNMENT, new ZLTextAlignmentOptionEntry(decoration.AlignmentOption, dialogTab.getResource(KEY_ALIGNMENT), true),
					KEY_DUMMY, null,
					name
				);
			}
		}

		myComboEntry.onValueSelected(0);
	}
}
",False,145,9,30,7,24,1,12,L6
97,org.geometerplus.fbreader.optionsDialog.OptionsPage.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.optionsDialog;

import java.util.*;

import org.geometerplus.zlibrary.core.dialogs.*;

class OptionsPage {
	private final LinkedHashMap<ZLOptionEntry, String> myEntries = new LinkedHashMap<ZLOptionEntry, String>();
	protected ComboOptionEntry myComboEntry;

	protected OptionsPage() {
	}

	protected void registerEntry(ZLDialogContent tab, final String entryKey, ZLOptionEntry entry, final String name) {
		if (entry != null) {
			entry.setVisible(false);
			myEntries.put(entry, name);
		}
		tab.addOption(entryKey, entry);
	}
	
	protected void registerEntries(ZLDialogContent tab, final String entry0Key,
		ZLOptionEntry entry0, final String entry1Key, ZLOptionEntry entry1, final String name) {
		if (entry0 != null) {
			entry0.setVisible(false);
			myEntries.put(entry0, name);
		}
		if (entry1 != null) {
			entry1.setVisible(false);
			myEntries.put(entry1, name);
		}
		tab.addOptions(entry0Key, entry0, entry1Key, entry1);
	}

	LinkedHashMap<ZLOptionEntry, String> getEntries() {
		return myEntries;
	}
}
",False,129,10,30,8,11,3,3,L6
98,org.geometerplus.fbreader.optionsDialog.StyleOptionsPage.java,"/*
 * Copyright (C) 2007-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.optionsDialog;

import org.geometerplus.zlibrary.core.dialogs.ZLDialogContent;
import org.geometerplus.zlibrary.core.optionEntries.ZLFontFamilyOptionEntry;
import org.geometerplus.zlibrary.core.optionEntries.ZLSimpleBoolean3OptionEntry;
import org.geometerplus.zlibrary.core.optionEntries.ZLSimpleBooleanOptionEntry;
import org.geometerplus.zlibrary.core.optionEntries.ZLSimpleSpinOptionEntry;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.view.ZLPaintContext;
import org.geometerplus.zlibrary.text.view.ZLTextFontFamilyWithBaseOptionEntry;
import org.geometerplus.zlibrary.text.view.style.ZLTextBaseStyle;
import org.geometerplus.zlibrary.text.view.style.ZLTextStyleCollection;
import org.geometerplus.zlibrary.text.view.style.ZLTextStyleDecoration;

import org.geometerplus.fbreader.bookmodel.FBTextKind;

public class StyleOptionsPage extends OptionsPage implements FBTextKind {
	private final static String KEY_STYLE = ""style"";
	private final static String KEY_BASE = ""Base"";

	private final static String KEY_BOLD = ""bold"";
	private final static String KEY_ITALIC = ""italic"";
	private final static String KEY_FONTFAMILY = ""fontFamily"";
	private final static String KEY_FONTSIZE = ""fontSize"";
	private final static String KEY_FONTSIZEDIFFERENCE = ""fontSizeDifference"";
	private final static String KEY_ALLOWHYPHENATIONS = ""allowHyphenations"";
	private final static String KEY_AUTOHYPHENATIONS = ""autoHyphenations"";
	
	public StyleOptionsPage(ZLDialogContent dialogTab, ZLPaintContext context) {
		final ZLResource styleResource = ZLResource.resource(KEY_STYLE);

		myComboEntry = new ComboOptionEntry(this, styleResource.getResource(KEY_BASE).getValue());
		myComboEntry.addValue(myComboEntry.initialValue());

		ZLTextStyleCollection collection = ZLTextStyleCollection.Instance();
		byte styles[] = { REGULAR, TITLE, SECTION_TITLE, SUBTITLE, H1, H2, H3, H4, H5, H6, CONTENTS_TABLE_ENTRY, RECENT_BOOK_LIST, LIBRARY_AUTHOR_ENTRY, LIBRARY_BOOK_ENTRY, ANNOTATION, EPIGRAPH, AUTHOR,/* DATEKIND, */POEM_TITLE, STANZA, VERSE, CITE, INTERNAL_HYPERLINK, EXTERNAL_HYPERLINK, FOOTNOTE, ITALIC, EMPHASIS, BOLD, STRONG, DEFINITION, DEFINITION_DESCRIPTION, PREFORMATTED, CODE };
		final int STYLES_NUMBER = styles.length;
		for (int i = 0; i < STYLES_NUMBER; ++i) {
			final ZLTextStyleDecoration decoration = collection.getDecoration(styles[i]);
			if (decoration != null) {
				myComboEntry.addValue(styleResource.getResource(decoration.getName()).getValue());
			}
		}
		dialogTab.addOption(""optionsFor"", myComboEntry);

		{
			final String name = myComboEntry.initialValue();
			ZLTextBaseStyle baseStyle = collection.getBaseStyle();

			registerEntry(dialogTab,
				KEY_FONTFAMILY, new ZLFontFamilyOptionEntry(baseStyle.FontFamilyOption, context),
				name
			);

			registerEntry(dialogTab,
				KEY_FONTSIZE, new ZLSimpleSpinOptionEntry(baseStyle.FontSizeOption, 2),
				name
			);

			registerEntry(dialogTab,
				KEY_BOLD, new ZLSimpleBooleanOptionEntry(baseStyle.BoldOption),
				name
			);

			registerEntry(dialogTab,
				KEY_ITALIC, new ZLSimpleBooleanOptionEntry(baseStyle.ItalicOption),
				name
			);

			registerEntry(dialogTab,
				KEY_AUTOHYPHENATIONS, new ZLSimpleBooleanOptionEntry(baseStyle.AutoHyphenationOption),
				name
			);
		}

		for (int i = 0; i < STYLES_NUMBER; ++i) {
			ZLTextStyleDecoration decoration = collection.getDecoration(styles[i]);
			if (decoration != null) {
				final String name = styleResource.getResource(decoration.getName()).getValue();

				registerEntry(dialogTab,
					KEY_FONTFAMILY, new ZLTextFontFamilyWithBaseOptionEntry(decoration.FontFamilyOption, context,  dialogTab.getResource(KEY_FONTFAMILY)),
					name
				);

				registerEntry(dialogTab,
					KEY_FONTSIZEDIFFERENCE, new ZLSimpleSpinOptionEntry(decoration.FontSizeDeltaOption, 2),
					name
				);

				registerEntry(dialogTab,
					KEY_BOLD, new ZLSimpleBoolean3OptionEntry(decoration.BoldOption),
					name
				);

				registerEntry(dialogTab,
					KEY_ITALIC, new ZLSimpleBoolean3OptionEntry(decoration.ItalicOption),
					name
				);

				registerEntry(dialogTab,
					KEY_ALLOWHYPHENATIONS, new ZLSimpleBoolean3OptionEntry(decoration.AllowHyphenationsOption),
					name
				);
			}
		}

		myComboEntry.onValueSelected(0);
	}
}
",False,145,9,30,7,27,1,14,L6
99,org.geometerplus.fbreader.network.BookReference.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.File;
import java.net.URI;

import org.geometerplus.fbreader.Paths;

public class BookReference {

	public interface Type {
		int UNKNOWN = 0; // Unknown reference type
		int DOWNLOAD_FULL = 1; // reference for download full version of the book
		int DOWNLOAD_FULL_CONDITIONAL = 2; // reference for download full version of the book, useful only when book is bought
		int DOWNLOAD_DEMO = 3; // reference for downloading demo version of the book
		int DOWNLOAD_FULL_OR_DEMO = 4; // reference for downloading unknown version of the book
		int BUY = 5; // reference for buying the book (useful only when authentication is supported)
		int BUY_IN_BROWSER = 6; // reference to the site page, when it is possible to buy the book
	}
	// resolvedReferenceType -- reference type without any ambiguity (for example, DOWNLOAD_FULL_OR_DEMO is ambiguous)

	public interface Format {
		int NONE = 0;
		int MOBIPOCKET = 1;
		int FB2_ZIP = 2;
		int EPUB = 3;
	}

	public final String URL;
	public final int BookFormat;
	public final int ReferenceType;

	public BookReference(String url, int format, int type) {
		URL = url;
		BookFormat = format;
		ReferenceType = type;
	}

	// returns clean URL without any account/user-specific parts
	public String cleanURL() {
		return URL;
	}

	private static final String TOESCAPE = ""<>:\""|?*\\"";

	public static String makeBookFileName(String url, int format, int resolvedReferenceType) {
		URI uri;
		try {
			uri = new URI(url);
		} catch (java.net.URISyntaxException ex) {
			return null;
		}

		String host = uri.getHost();

		StringBuilder path = new StringBuilder(host);
		if (host.startsWith(""www."")) {
			path.delete(0, 4);
		}
		path.insert(0, File.separator);
		if (resolvedReferenceType == Type.DOWNLOAD_DEMO) {
			path.insert(0, ""Demos"");
			path.insert(0, File.separator);
		}
		path.insert(0, Paths.BooksDirectoryOption.getValue());

		int index = path.length();
		path.append(uri.getPath());
		int nameIndex = index;
		while (index < path.length()) {
			char ch = path.charAt(index);
			if (TOESCAPE.indexOf(ch) != -1) {
				path.setCharAt(index, '_');
			}
			if (ch == '/') {
				if (index + 1 == path.length()) {
					path.deleteCharAt(index);
				} else {
					path.setCharAt(index, File.separatorChar);
					nameIndex = index + 1;
				}
			}
			++index;
		}

		String ext = null;
		switch (format) {
			case Format.EPUB:
				ext = "".epub"";
				break;
			case Format.MOBIPOCKET:
				ext = "".mobi"";
				break;
			case Format.FB2_ZIP:
				ext = "".fb2.zip"";
				break;
		}

		if (ext == null) {
			int j = path.indexOf(""."", nameIndex); // using not lastIndexOf to preserve extensions like `.fb2.zip`
			if (j != -1) {
				ext = path.substring(j);
				path.delete(j, path.length());
			} else {
				return null;
			}
		} else if (path.length() > ext.length() && path.substring(path.length() - ext.length()).equals(ext)) {
			path.delete(path.length() - ext.length(), path.length());
		}

		String query = uri.getQuery();
		if (query != null) {
			index = 0;
			while (index < query.length()) {
				int j = query.indexOf(""&"", index);
				if (j == -1) {
					j = query.length();
				}
				String param = query.substring(index, j);
				if (!param.startsWith(""username="")
					&& !param.startsWith(""password="")
					&& !param.endsWith(""="")) {
					int k = path.length();
					path.append(""_"").append(param);
					while (k < path.length()) {
						char ch = path.charAt(k);
						if (TOESCAPE.indexOf(ch) != -1 || ch == '/') {
							path.setCharAt(k, '_');
						}
						++k;
					}
				}
				index = j + 1;
			}
		}
		return path.append(ext).toString();
	}

	public final String makeBookFileName(int resolvedReferenceType) {
		return makeBookFileName(cleanURL(), BookFormat, resolvedReferenceType);
	}

	public final String localCopyFileName(int resolvedReferenceType) {
		String fileName = makeBookFileName(resolvedReferenceType);
		if (fileName != null && new File(fileName).exists()) {
			return fileName;
		}
		return null;
	}

	public String toString() {
		return ""BookReference[type="" + ReferenceType + "";format="" + BookFormat + "";URL="" + URL + ""]"";
	}
}
",False,118,6,30,3,2,10,2,L6
100,org.geometerplus.fbreader.network.Base64EncodedImage.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.*;

import org.geometerplus.zlibrary.core.image.ZLBase64EncodedImage;

import org.geometerplus.fbreader.Paths;

final class Base64EncodedImage extends ZLBase64EncodedImage {

	private static final String ENCODED_SUFFIX = "".base64"";

	private String myDecodedFileName;

	// mimeType string MUST be interned
	public Base64EncodedImage(String mimeType) {
		super(mimeType);
		new File(makeImagesDir()).mkdirs();
	}

	public static String makeImagesDir() {
		return Paths.networkCacheDirectory() + ""/base64"";
	}

	public void setData(String data) {
		myDecodedFileName = makeImagesDir() + File.separator + Integer.toHexString(data.hashCode());
		String type = mimeType();
		if (type == NetworkImage.MIME_PNG) {
			myDecodedFileName += "".png"";
		} else if (type == NetworkImage.MIME_JPEG) {
			myDecodedFileName += "".jpg"";
		}

		if (isCacheValid(new File(myDecodedFileName))) {
			return;
		}

		File file = new File(encodedFileName());
		if (isCacheValid(file)) {
			return;
		}
		try {
			final OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), ""UTF-8"");
			try {
				writer.write(data, 0, data.length());
			} finally {
				writer.close();
			}
		} catch (IOException e) {
		}
	}

	@Override
	protected boolean isCacheValid(File file) {
		if (file.exists()) {
			final long diff = System.currentTimeMillis() - file.lastModified();
			final long valid = 24 * 60 * 60 * 1000; // one day in milliseconds; FIXME: hardcoded const
			if (diff >= 0 && diff <= valid) {
				return true;
			}
			file.delete();
		}
		return false;
	}

	@Override
	protected String encodedFileName() {
		return myDecodedFileName + ENCODED_SUFFIX;
	}

	@Override
	protected String decodedFileName() {
		return myDecodedFileName;
	}
}
",True,135,7,34,9,11,1,4,L6
101,org.geometerplus.fbreader.network.NetworkTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.LinkedList;
import java.util.Set;

import org.geometerplus.fbreader.tree.FBTree;

import org.geometerplus.zlibrary.core.image.ZLImage;

public abstract class NetworkTree extends FBTree {

	protected NetworkTree(int level) {
		super(level);
	}

	protected NetworkTree() {
		super();
	}

	protected NetworkTree(NetworkTree parent) {
		super(parent);
	}

	protected NetworkTree(NetworkTree parent, int position) {
		super(parent, position);
	}

	public static ZLImage createCover(NetworkLibraryItem item) {
		if (item.Cover == null) {
			return null;
		}
		return createCover(item.Cover, null);
	}

	public static ZLImage createCover(String url, String mimeType) {
		if (url == null) {
			return null;
		}
		if (mimeType == null) {
			mimeType = ""image/auto"";
		}
		if (url.startsWith(""http://"") || url.startsWith(""https://"") || url.startsWith(""ftp://"")) {
			return new NetworkImage(url, mimeType);
		} else if (url.startsWith(""data:"")) {
			int commaIndex = url.indexOf(',');
			if (commaIndex == -1) {
				return null;
			}
			if (mimeType == ""image/auto"") {
				int index = url.indexOf(';');
				if (index == -1 || index > commaIndex) {
					index = commaIndex;
				}
				if (url.startsWith(""image/"", 5)) { // 11 -- length of ""data:image/""; 5 -- length of ""data:""
					mimeType = url.substring(5, index);
				}
			}
			int key = url.indexOf(""base64"");
			if (key != -1 && key < commaIndex) {
				Base64EncodedImage img = new Base64EncodedImage(mimeType);
				img.setData(url.substring(commaIndex + 1));
				return img;
			}
		}
		return null;
	}


	public abstract NetworkLibraryItem getHoldedItem();

	public void removeItems(Set<NetworkLibraryItem> items) {
		if (items.isEmpty() || subTrees().isEmpty()) {
			return;
		}
		final LinkedList<FBTree> treesList = new LinkedList<FBTree>();
		for (FBTree tree: subTrees()) {
			final NetworkLibraryItem treeItem = ((NetworkTree)tree).getHoldedItem();
			if (treeItem != null && items.contains(treeItem)) {
				treesList.add(tree);
				items.remove(treeItem);
			}
		}
		for (FBTree tree: treesList) {
			tree.removeSelf();
		}
		if (items.isEmpty()) {
			return;
		}
		treesList.clear();
		treesList.addAll(subTrees());
		while (!treesList.isEmpty()) {
			final NetworkTree tree = (NetworkTree) treesList.remove(treesList.size() - 1);
			tree.removeItems(items);
		}
	}
}
",False,252,6,34,16,20,21,6,L6
102,org.geometerplus.fbreader.network.NetworkImage.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.*;
import java.net.*;

import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;

import org.geometerplus.fbreader.Paths;


public final class NetworkImage extends ZLSingleImage {

	public static final String MIME_PNG = ""image/png"";
	public static final String MIME_JPEG = ""image/jpeg"";

	public final String Url;
	private volatile boolean mySynchronized;

	// mimeType string MUST be interned
	public NetworkImage(String url, String mimeType) {
		super(mimeType);
		Url = url;
		new File(Paths.networkCacheDirectory()).mkdirs();
	}

	private static final String TOESCAPE = ""<>:\""|?*\\"";

	// mimeType string MUST be interned
	public static String makeImageFileName(String url, String mimeType) {
		URI uri;
		try {
			uri = new URI(url);
		} catch (java.net.URISyntaxException ex) {
			return null;
		}

		String host = uri.getHost();

		StringBuilder path = new StringBuilder(host);
		if (host.startsWith(""www."")) {
			path.delete(0, 4);
		}
		path.insert(0, File.separator);
		path.insert(0, Paths.networkCacheDirectory());

		int index = path.length();

		path.append(uri.getPath());

		int nameIndex = index;
		while (index < path.length()) {
			char ch = path.charAt(index);
			if (TOESCAPE.indexOf(ch) != -1) {
				path.setCharAt(index, '_');
			}
			if (ch == '/') {
				if (index + 1 == path.length()) {
					path.deleteCharAt(index);
				} else {
					path.setCharAt(index, '_');
					nameIndex = index + 1;
				}
			}
			++index;
		}

		String ext = null;
		if (mimeType == MIME_PNG) {
			ext = "".png"";
		} else if (mimeType == MIME_JPEG) {
			if (path.length() > 5 && path.substring(path.length() - 5).equals("".jpeg"")) {
				ext = "".jpeg"";
			} else {
				ext = "".jpg"";
			}
		}

		if (ext == null) {
			int j = path.lastIndexOf(""."");
			if (j > nameIndex) {
				ext = path.substring(j);
				path.delete(j, path.length());
			} else {
				ext = """";
			}
		} else if (path.length() > ext.length() && path.substring(path.length() - ext.length()).equals(ext)) {
			path.delete(path.length() - ext.length(), path.length());
		}

		String query = uri.getQuery();
		if (query != null) {
			index = 0;
			while (index < query.length()) {
				int j = query.indexOf(""&"", index);
				if (j == -1) {
					j = query.length();
				}
				String param = query.substring(index, j);
				if (!param.startsWith(""username="")
					&& !param.startsWith(""password="")
					&& !param.endsWith(""="")) {
					int k = path.length();
					path.append(""_"").append(param);
					while (k < path.length()) {
						char ch = path.charAt(k);
						if (TOESCAPE.indexOf(ch) != -1 || ch == '/') {
							path.setCharAt(k, '_');
						}
						++k;
					}
				}
				index = j + 1;
			}
		}
		return path.append(ext).toString();
	}

	public String getFileName() {
		return makeImageFileName(Url, mimeType());
	}

	public boolean isSynchronized() {
		return mySynchronized;
	}

	public void synchronize() {
		synchronizeInternal(false);
	}

	public void synchronizeFast() {
		synchronizeInternal(true);
	}

	private final void synchronizeInternal(boolean doFast) {
		if (mySynchronized) {
			return;
		}
		try {
			final String fileName = getFileName();
			if (fileName == null) {
				// TODO: error message ???
				return;
			}
			final int index = fileName.lastIndexOf(File.separator);
			if (index != -1) {
				final String dir = fileName.substring(0, index);
				final File dirFile = new File(dir);
				if (!dirFile.exists() && !dirFile.mkdirs()) {
					// TODO: error message ???
					return;
				}
				if (!dirFile.exists() || !dirFile.isDirectory()) {
					// TODO: error message ???
					return;
				}
			}
			final File imageFile = new File(fileName);
			if (imageFile.exists()) {
				final long diff = System.currentTimeMillis() - imageFile.lastModified();
				final long valid = 7 * 24 * 60 * 60 * 1000; // one week in milliseconds; FIXME: hardcoded const
				if (diff >= 0 && diff <= valid) {
					return;
				}
				imageFile.delete();
			}
			if (doFast) {
				return;
			}

			ZLNetworkManager.Instance().downloadToFile(Url, imageFile);
		} finally {
			mySynchronized = true;
		}
	}

	@Override
	public byte [] byteData() {
		if (!mySynchronized) {
			return null;
		}
		final String fileName = getFileName();
		if (fileName == null) {
			return null;
		}
		final File imageFile = new File(fileName);
		if (!imageFile.exists()) {
			return null;
		}
		try {
			final byte[] data = new byte[(int)imageFile.length()];
			final FileInputStream stream = new FileInputStream(imageFile);
			stream.read(data);
			stream.close();
			return data;
		} catch (IOException e) {
			return null;
		}
	}

}
",True,139,7,34,8,11,7,3,L6
103,org.geometerplus.fbreader.network.AbstractNetworkLink.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;


public abstract class AbstractNetworkLink implements INetworkLink {

	protected String mySiteName;
	protected String myTitle;
	protected String mySummary;
	protected String myIcon;
	protected TreeMap<String, String> myLinks;


	/**
	 * Creates new NetworkLink instance.
	 *
	 * @param siteName   name of the corresponding website. Must be not <code>null</code>.
	 * @param title      title of the corresponding library item. Must be not <code>null</code>.
	 * @param summary    description of the corresponding library item. Can be <code>null</code>.
	 * @param icon       string contains link's icon data/url. Can be <code>null</code>.
	 * @param links      map contains URLs with their identifiers; must always contain one URL with <code>URL_MAIN</code> identifier
	 */
	public AbstractNetworkLink(String siteName, String title, String summary, String icon, Map<String, String> links) {
		mySiteName = siteName;
		myTitle = title;
		mySummary = summary;
		myIcon = icon;
		myLinks = new TreeMap<String, String>(links);
	}

	public String getSiteName() {
		return mySiteName;
	}

	public String getTitle() {
		return myTitle;
	}

	public String getSummary() {
		return mySummary;
	}

	public String getIcon() {
		return myIcon;
	}

	public String getLink(String urlKey) {
		return myLinks.get(urlKey);
	}

	public Set<String> getLinkKeys() {
		return myLinks.keySet();
	}

	public NetworkOperationData createOperationData(INetworkLink link,
			NetworkOperationData.OnNewItemListener listener) {
		return new NetworkOperationData(link, listener);
	}

	@Override
	public String toString() {
		String icon = myIcon;
		if (icon.length() > 64) {
			icon = icon.substring(0, 61) + ""..."";
		}
		icon = icon.replaceAll(""\n"", """");
		return ""AbstractNetworkLink: {""
			+ ""siteName="" + mySiteName
			+ ""; title="" + myTitle
			+ ""; summary="" + mySummary
			+ ""; icon="" + icon
			+ ""; links="" + myLinks
			+ ""}"";
	}


	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof AbstractNetworkLink)) {
			return false;
		}
		final AbstractNetworkLink lnk = (AbstractNetworkLink) o;
		if (!mySiteName.equals(lnk.mySiteName)
				|| !myTitle.equals(lnk.myTitle)
				|| !ZLMiscUtil.equals(mySummary, lnk.mySummary)
				|| !ZLMiscUtil.equals(myIcon, lnk.myIcon)
				|| !ZLMiscUtil.mapsEquals(myLinks, lnk.myLinks)) {
			return false;
		}
		return true;
	}
}
",False,244,8,33,15,22,2,3,L6
104,org.geometerplus.fbreader.network.NetworkBookItemComparator.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Comparator;
import java.util.LinkedList;


public final class NetworkBookItemComparator implements Comparator<NetworkLibraryItem> {

	public int compare(NetworkLibraryItem item0, NetworkLibraryItem item1) {
		final boolean item0isABook = item0 instanceof NetworkBookItem;
		final boolean item1isABook = item1 instanceof NetworkBookItem;

		if (!item0isABook && !item1isABook) {
			return item0.Title.compareTo(item1.Title);
		}
		if (!item0isABook || !item1isABook) {
			return item0isABook ? 1 : -1;
		}

		final NetworkBookItem book0 = (NetworkBookItem) item0;
		final NetworkBookItem book1 = (NetworkBookItem) item1;

		final LinkedList<NetworkBookItem.AuthorData> authors0 = book0.Authors;
		final LinkedList<NetworkBookItem.AuthorData> authors1 = book1.Authors;
		
		final boolean authors0empty = authors0.size() == 0;
		final boolean authors1empty = authors1.size() == 0;

		if (authors0empty && !authors1empty) {
			return -1;
		}
		if (authors1empty && !authors0empty) {
			return 1;
		}
		if (!authors0empty && !authors1empty) {
			final int diff = authors0.get(0).SortKey.compareTo(authors1.get(0).SortKey);
			if (diff != 0) {
				return diff;
			}
		}

		/*if (book0.Index != book1.Index) {
			return book0.Index - book1.Index;
		}*/

		final boolean book0HasSeriesTitle = book0.SeriesTitle != null;
		final boolean book1HasSeriesTitle = book1.SeriesTitle != null;

		if (book0HasSeriesTitle && book1HasSeriesTitle) {
			final int comp = book0.SeriesTitle.compareTo(book1.SeriesTitle);
			if (comp != 0) {
				return comp;
			} else {
				final int diff = book0.IndexInSeries - book1.IndexInSeries;
				if (diff != 0) {
					return diff;
				}
			}
			return book0.Title.compareTo(book1.Title);
		}

		final String book0Key = book0HasSeriesTitle ? book0.SeriesTitle : book0.Title;
		final String book1Key = book1HasSeriesTitle ? book1.SeriesTitle : book1.Title;
		final int comp = book0Key.compareTo(book1Key);
		if (comp != 0) {
			return comp;
		}
		return book1HasSeriesTitle ? -1 : 1;
	}
}
",False,245,11,33,15,22,1,2,L6
105,org.geometerplus.fbreader.network.NetworkBookItem.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;
import java.io.File;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


public final class NetworkBookItem extends NetworkLibraryItem {

	public static class AuthorData implements Comparable<AuthorData> {
		public final String DisplayName;
		public final String SortKey;

		/**
		 * Creates new AuthorData instance. 
		 *
		 * @param displayName author's name. Must be not <code>null</code>.
		 * @param sortKey     string that defines sorting order of book's authors. Must be not <code>null</code>.
		 */
		public AuthorData(String displayName, String sortKey) {
			DisplayName = displayName.intern();
			SortKey = sortKey.intern();
		}

		public int compareTo(AuthorData data) {
			final int key = SortKey.compareTo(data.SortKey);
			if (key != 0) {
				return key;
			}
			return DisplayName.compareTo(data.DisplayName);
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof AuthorData)) {
				return false;
			}
			final AuthorData data = (AuthorData) o;
			return SortKey == data.SortKey && DisplayName == data.DisplayName;
		}

		@Override
		public int hashCode() {
			return SortKey.hashCode() + DisplayName.hashCode();
		}
	}

	public final int Index;
	public final String Id;
	//public final String Language;
	//public final String Date;
	public final LinkedList<AuthorData> Authors;
	public final LinkedList<String> Tags;
	public final String SeriesTitle;
	public final int IndexInSeries;

	private final LinkedList<BookReference> myReferences;

	/**
	 * Creates new NetworkLibraryItem instance.
	 *
	 * @param link          corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param id            string that uniquely identifies this book item. Must be not <code>null</code>.
	 * @param index         sequence number of this book in corresponding catalog
	 * @param title         title of this book. Must be not <code>null</code>.
	 * @param summary       description of this book. Can be <code>null</code>.
	 * //@param langage       string specifies language of this book. Can be <code>null</code>.
	 * //@param date          string specifies release date of this book. Can be <code>null</code>.
	 * @param authors       list of book authors. Should contain at least one author.
	 * @param tags          list of book tags. Must be not <code>null</code> (can be empty).
	 * @param seriesTitle   title of this book's series. Can be <code>null</code>.
	 * @param indexInSeries	sequence number of this book within book's series. Ignored if seriesTitle is <code>null</code>.
	 * @param cover         cover url. Can be <code>null</code>.
	 * @param references    list of references related to this book. Must be not <code>null</code>.
	 */
	public NetworkBookItem(INetworkLink link, String id, int index,
		String title, String summary, /*String language, String date,*/
		List<AuthorData> authors, List<String> tags, String seriesTitle, int indexInSeries,
		String cover,
		List<BookReference> references) {
		super(link, title, summary, cover);
		Index = index;
		Id = id;
		//Language = language;
		//Date = date;
		Authors = new LinkedList<AuthorData>(authors);
		Tags = new LinkedList<String>(tags);
		SeriesTitle = seriesTitle;
		IndexInSeries = indexInSeries;
		myReferences = new LinkedList<BookReference>(references);
	}

	public BookReference reference(int type) {
		BookReference reference = null;
		for (BookReference ref: myReferences) {
			if (ref.ReferenceType == type &&
					(reference == null || ref.BookFormat > reference.BookFormat)) {
				reference = ref;
			}
		}

		if (reference == null && type == BookReference.Type.DOWNLOAD_FULL) {
			reference = this.reference(BookReference.Type.DOWNLOAD_FULL_CONDITIONAL);
			if (reference != null) {
				NetworkAuthenticationManager authManager = Link.authenticationManager();
				if (authManager == null || authManager.needPurchase(this)) {
					return null;
				}
				reference = authManager.downloadReference(this);
			}
		}

		if (reference == null &&
				type == BookReference.Type.DOWNLOAD_FULL &&
				this.reference(BookReference.Type.BUY) == null &&
				this.reference(BookReference.Type.BUY_IN_BROWSER) == null) {
			reference = this.reference(BookReference.Type.DOWNLOAD_FULL_OR_DEMO);
		}

		if (reference == null &&
				type == BookReference.Type.DOWNLOAD_DEMO &&
				(this.reference(BookReference.Type.BUY) != null ||
				 this.reference(BookReference.Type.BUY_IN_BROWSER) != null)) {
			reference = this.reference(BookReference.Type.DOWNLOAD_FULL_OR_DEMO);
		}

		return reference;
	}

	public String localCopyFileName() {
		final boolean hasBuyReference =
			this.reference(BookReference.Type.BUY) != null ||
			this.reference(BookReference.Type.BUY_IN_BROWSER) != null;
		BookReference reference = null;
		String fileName = null;
		for (BookReference ref: myReferences) {
			final int type = ref.ReferenceType;
			if ((type == BookReference.Type.DOWNLOAD_FULL ||
					type == BookReference.Type.DOWNLOAD_FULL_CONDITIONAL ||
					(!hasBuyReference && type == BookReference.Type.DOWNLOAD_FULL_OR_DEMO)) &&
					(reference == null || ref.BookFormat > reference.BookFormat)) {
				String name = ref.localCopyFileName(BookReference.Type.DOWNLOAD_FULL);
				if (name != null) {
					reference = ref;
					fileName = name;
				}
			}
		}
		return fileName;
	}

	public void removeLocalFiles() {
		final boolean hasBuyReference =
			this.reference(BookReference.Type.BUY) != null ||
			this.reference(BookReference.Type.BUY_IN_BROWSER) != null;
		for (BookReference ref: myReferences) {
			final int type = ref.ReferenceType;
			if (type == BookReference.Type.DOWNLOAD_FULL ||
					type == BookReference.Type.DOWNLOAD_FULL_CONDITIONAL ||
					(!hasBuyReference && type == BookReference.Type.DOWNLOAD_FULL_OR_DEMO)) {
				String fileName = ref.localCopyFileName(BookReference.Type.DOWNLOAD_FULL);
				if (fileName != null) {
					// TODO: remove a book from the library
					// TODO: remove a record from the database
					new File(fileName).delete();
				}
			}
		}
	}

}
",False,254,8,34,14,22,15,4,L6
106,org.geometerplus.fbreader.network.NetworkDatabase.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Map;

public abstract class NetworkDatabase {
	private static NetworkDatabase ourInstance;

	public static NetworkDatabase Instance() {
		return ourInstance;
	}

	protected NetworkDatabase() {
		ourInstance = this;
	}

	protected abstract void executeAsATransaction(Runnable actions);

	public interface ICustomLinksHandler {
		void handleCustomLinkData(int id, String siteName, String title, String summary, String icon, Map<String, String> links);
	}

	protected abstract void loadCustomLinks(ICustomLinksHandler handler);
	protected abstract void saveCustomLink(ICustomNetworkLink link);
	protected abstract void deleteCustomLink(ICustomNetworkLink link);
}
",False,240,6,33,16,22,2,1,L6
107,org.geometerplus.fbreader.network.NetworkLibrary.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.tree.*;
import org.geometerplus.fbreader.network.opds.OPDSLinkReader;


public class NetworkLibrary {
	private static NetworkLibrary ourInstance;

	public static NetworkLibrary Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkLibrary();
		}
		return ourInstance;
	}

	private static class CompositeList extends AbstractSequentialList<INetworkLink> {

		private final ArrayList<ArrayList<? extends INetworkLink>> myLists;
		private Comparator<INetworkLink> myComparator;

		public CompositeList(ArrayList<ArrayList<? extends INetworkLink>> lists,
				Comparator<INetworkLink> comparator) {
			myLists = lists;
			myComparator = comparator;
		}

		private class Iterator implements ListIterator<INetworkLink> {
			private int myIndex;
			private ArrayList<Integer> myPositions;

			private final INetworkLink getNextByIndex(int index) {
				final int position = myPositions.get(index);
				return (position < myLists.get(index).size()) ?
						myLists.get(index).get(position) :
						null;
			}

			private final INetworkLink getPrevByIndex(int index) {
				final int position = myPositions.get(index);
				return (position > 0) ?
						myLists.get(index).get(position - 1) :
						null;
			}

			public Iterator() {
				myPositions = new ArrayList<Integer>(Collections.nCopies(myLists.size(), 0));
			}

			public Iterator(Iterator it) {
				myIndex = it.myIndex;
				myPositions = new ArrayList<Integer>(it.myPositions);
			}

			public boolean hasNext() {
				return myIndex < size();
			}

			public boolean hasPrevious() {
				return myIndex > 0;
			}

			public int nextIndex() {
				return myIndex;
			}

			public int previousIndex() {
				return myIndex - 1;
			}

			public INetworkLink next() {
				final int size = myLists.size();
				if (size == 0) {
					throw new NoSuchElementException();
				}
				int nextIndex = -1;
				INetworkLink nextLink = null;;
				for (nextIndex = 0; nextIndex < size; ++nextIndex) {
					nextLink = getNextByIndex(nextIndex);
					if (nextLink != null) {
						break;
					}
				}
				if (nextLink == null) {
					throw new NoSuchElementException();
				}
				for (int i = nextIndex + 1; i < size; ++i) {
					INetworkLink link = getNextByIndex(i);
					if (link != null && myComparator.compare(link, nextLink) < 0) {
						nextLink = link;
						nextIndex = i;
					}
				}
				myPositions.set(nextIndex, myPositions.get(nextIndex) + 1);
				++myIndex;
				return nextLink;
			}

			public INetworkLink previous() {
				final int size = myLists.size();
				if (size == 0) {
					throw new NoSuchElementException();
				}
				int prevIndex = -1;
				INetworkLink prevLink = null;;
				for (prevIndex = 0; prevIndex < size; ++prevIndex) {
					prevLink = getPrevByIndex(prevIndex);
					if (prevLink != null) {
						break;
					}
				}
				if (prevLink == null) {
					throw new NoSuchElementException();
				}
				for (int i = prevIndex + 1; i < size; ++i) {
					INetworkLink link = getPrevByIndex(i);
					if (link != null && myComparator.compare(link, prevLink) >= 0) {
						prevLink = link;
						prevIndex = i;
					}
				}
				myPositions.set(prevIndex, myPositions.get(prevIndex) - 1);
				--myIndex;
				return prevLink;
			}

			public void add(INetworkLink arg0) { throw new UnsupportedOperationException(); }
			public void remove() { throw new UnsupportedOperationException(); }
			public void set(INetworkLink arg0) { throw new UnsupportedOperationException(); }
		};

		@Override
		public ListIterator<INetworkLink> listIterator(int location) {
			if (location < 0 || location > size()) {
				throw new IndexOutOfBoundsException();
			}
			Iterator it = new Iterator();
			while (location-- > 0) {
				it.next();
			}
			return it;
		}

		// returns a copy of iterator
		public ListIterator<INetworkLink> listIterator(ListIterator<INetworkLink> it) {
			return new Iterator((Iterator)it);
		}

		@Override
		public int size() {
			int size = 0;
			for (ArrayList<? extends INetworkLink> list: myLists) {
				size += list.size();
			}
			return size;
		}
	}

	private static class LinksComparator implements Comparator<INetworkLink> {
		private static String filterLinkTitle(String title) {
			for (int index = 0; index < title.length(); ++index) {
				final char ch = title.charAt(index);
				if (ch < 128 && Character.isLetter(ch)) {
					return title.substring(index);
				}
			}
			return title;
		}

		public int compare(INetworkLink link1, INetworkLink link2) {
			final String title1 = filterLinkTitle(link1.getTitle());
			final String title2 = filterLinkTitle(link2.getTitle());
			return title1.compareToIgnoreCase(title2);
		}
	}

	
	public interface OnNewLinkListener {
		void onNewLink(INetworkLink link);
	}


	public final ZLStringOption NetworkSearchPatternOption = new ZLStringOption(""NetworkSearch"", ""Pattern"", """");

	private final ArrayList<INetworkLink> myLoadedLinks = new ArrayList<INetworkLink>();
	private final ArrayList<ICustomNetworkLink> myCustomLinks = new ArrayList<ICustomNetworkLink>();
	private final CompositeList myLinks;

	private final RootTree myRootTree = new RootTree();

	private boolean myUpdateChildren = true;
	private boolean myInvalidateChildren;
	private boolean myUpdateVisibility;

	private NetworkLibrary() {
		ArrayList<ArrayList<? extends INetworkLink>> linksList = new ArrayList<ArrayList<? extends INetworkLink>>();
		linksList.add(myLoadedLinks);
		linksList.add(myCustomLinks);
		myLinks = new CompositeList(linksList, new LinksComparator());
	}

	public String initialize() {
		final LinksComparator comparator = new LinksComparator(); 

		final String error = OPDSLinkReader.loadOPDSLinks(OPDSLinkReader.CACHE_LOAD, new OnNewLinkListener() {
			public void onNewLink(INetworkLink link) {
				addLinkInternal(myLoadedLinks, link, comparator);
			}
		});

		if (error != null) {
			synchronized (myLinks) {
				myLoadedLinks.clear();
			}
			return error;
		}

		NetworkDatabase.Instance().loadCustomLinks(
			new NetworkDatabase.ICustomLinksHandler() {
				public void handleCustomLinkData(int id, String siteName,
						String title, String summary, String icon, Map<String, String> links) {
					final ICustomNetworkLink link = OPDSLinkReader.createCustomLink(id, siteName, title, summary, icon, links);
					if (link != null) {
						addLinkInternal(myCustomLinks, link, comparator);
						link.setSaveLinkListener(myChangesListener);
					}
				}
			}
		);

		/*testDate(new ATOMUpdated(2010,  1,  1,  1,  0,  0,  0,  2,  0),
				 new ATOMUpdated(2009, 12, 31, 23,  0,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2010, 12, 31, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2011,  1,  1,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2010,  1, 31, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2010,  2,  1,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2010,  2, 28, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2010,  3,  1,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2012,  2, 28, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2012,  2, 29,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2012,  2, 16,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  1,  0,  3, 30),
				 new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0,  3, 30));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0,  3, 30),
				 new ATOMUpdated(2012,  2, 15, 23, 40,  1,  0,  3, 30));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0.001f,  3, 30),
				 new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0,  3, 30));*/

		return null;
	}

	/*private void testDate(ATOMDateConstruct date1, ATOMDateConstruct date2) {
		String sign = "" == "";
		final int diff = date1.compareTo(date2);
		if (diff > 0) {
			sign = "" > "";
		} else if (diff < 0) {
			sign = "" < "";
		}
		Log.w(""FBREADER"", """" + date1 + sign + date2);
	}*/

	private ArrayList<INetworkLink> myBackgroundLinks;
	private Object myBackgroundLock = new Object();

	// This method must be called from background thread
	public String runBackgroundUpdate(boolean clearCache) {
		synchronized (myBackgroundLock) {
			myBackgroundLinks = new ArrayList<INetworkLink>();

			final int cacheMode = clearCache ? OPDSLinkReader.CACHE_CLEAR : OPDSLinkReader.CACHE_UPDATE;
			final String error = OPDSLinkReader.loadOPDSLinks(cacheMode, new OnNewLinkListener() {
				public void onNewLink(INetworkLink link) {
					myBackgroundLinks.add(link);
				}
			});

			if (error != null || myBackgroundLinks.isEmpty()) {
				myBackgroundLinks = null;
			}

			if (myBackgroundLinks != null) {
				Collections.sort(myBackgroundLinks, new LinksComparator());
			}
			return error;
		}
	}

	// This method MUST be called from main thread
	// This method has effect only when runBackgroundUpdate method has returned null.
	//
	// synchronize() method MUST be called after this method
	public void finishBackgroundUpdate() {
		synchronized (myBackgroundLock) {
			if (myBackgroundLinks == null) {
				return;
			}
			synchronized (myLinks) {
				myLoadedLinks.clear();
				myLoadedLinks.addAll(myBackgroundLinks);
				updateChildren();
			}
		}
	}


	public String rewriteUrl(String url, boolean externalUrl) {
		final String host = ZLNetworkUtil.hostFromUrl(url).toLowerCase();
		synchronized (myLinks) {
			for (INetworkLink link: myLinks) {
				if (host.contains(link.getSiteName())) {
					url = link.rewriteUrl(url, externalUrl);
				}
			}
		}
		return url;
	}

	public void invalidateChildren() {
		myInvalidateChildren = true;
	}

	public void updateChildren() {
		myUpdateChildren = true;
	}

	public void invalidateVisibility() {
		myUpdateVisibility = true;
	}


	private static boolean linksEqual(INetworkLink l1, INetworkLink l2) {
		return l1 == l2 || l1.getSiteName().equals(l2.getSiteName());
	}

	private static boolean linkIsInvalid(INetworkLink link, INetworkLink nodeLink) {
		if (link instanceof ICustomNetworkLink) {
			if (link != nodeLink) {
				throw new RuntimeException(""Two equal custom links!!! That's impossible"");
			}
			return ((ICustomNetworkLink) link).hasChanges();
		}
		return !link.equals(nodeLink);
	}

	private static void makeValid(INetworkLink link) {
		if (link instanceof ICustomNetworkLink) {
			((ICustomNetworkLink) link).resetChanges();
		}
	}

	private void makeUpToDate() {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();

		ListIterator<FBTree> nodeIterator = myRootTree.subTrees().listIterator();
		FBTree currentNode = null;
		int nodeCount = 0;

		synchronized (myLinks) {
			ListIterator<INetworkLink> it = myLinks.listIterator();
			while (it.hasNext()) {
				INetworkLink link = it.next();
				/*if (!link.OnOption.getValue()) {
					continue;
				}*/
				boolean processed = false;
				while (currentNode != null || nodeIterator.hasNext()) {
					if (currentNode == null) {
						currentNode = nodeIterator.next();
					}
					if (!(currentNode instanceof NetworkCatalogTree)) {
						currentNode = null;
						++nodeCount;
						continue;
					}
					final INetworkLink nodeLink = ((NetworkCatalogTree) currentNode).Item.Link;
					if (linksEqual(link, nodeLink)) {
						if (linkIsInvalid(link, nodeLink)) {
							toRemove.add(currentNode);
						} else {
							processed = true;
						}
						currentNode = null;
						++nodeCount;
						break;
					} else {
						INetworkLink newNodeLink = null;
						ListIterator<INetworkLink> jt = myLinks.listIterator(it);
						while (jt.hasNext()) {
							final INetworkLink jlnk = jt.next();
							if (linksEqual(nodeLink, jlnk)) {
								newNodeLink = jlnk;
								break;
							}
						}
						if (newNodeLink == null || linkIsInvalid(newNodeLink, nodeLink)) {
							toRemove.add(currentNode);
							currentNode = null;
							++nodeCount;
						} else {
							break;
						}
					}
				}
				if (!processed) {
					makeValid(link);
					final int nextIndex = nodeIterator.nextIndex();
					new NetworkCatalogRootTree(myRootTree, link, nodeCount++).Item.onDisplayItem();
					nodeIterator = myRootTree.subTrees().listIterator(nextIndex + 1);
				}
			}
		}

		while (currentNode != null || nodeIterator.hasNext()) {
			if (currentNode == null) {
				currentNode = nodeIterator.next();
			}
			if (currentNode instanceof NetworkCatalogTree) {
				toRemove.add(currentNode);
			}
			currentNode = null;
		}

		for (FBTree tree: toRemove) {
			tree.removeSelf();
		}
	}

	private void updateVisibility() {
		for (FBTree tree: myRootTree.subTrees()) {
			if (!(tree instanceof NetworkCatalogTree)) {
				continue;
			}
			((NetworkCatalogTree) tree).updateVisibility();
		}
	}

	public void synchronize() {
		if (myUpdateChildren || myInvalidateChildren) {
			if (myInvalidateChildren) {
				final LinksComparator cmp = new LinksComparator();
				//Collections.sort(myLoadedLinks, cmp); // this collection is always sorted
				Collections.sort(myCustomLinks, cmp);
			}
			myUpdateChildren = false;
			myInvalidateChildren = false;
			makeUpToDate();
		}
		if (myUpdateVisibility) {
			myUpdateVisibility = false;
			updateVisibility();
		}
	}

	public NetworkTree getTree() {
		return myRootTree;
	}


	// returns Error Message
	public String simpleSearch(String pattern, final NetworkOperationData.OnNewItemListener listener) {
		LinkedList<ZLNetworkRequest> requestList = new LinkedList<ZLNetworkRequest>();
		LinkedList<NetworkOperationData> dataList = new LinkedList<NetworkOperationData>();

		final NetworkOperationData.OnNewItemListener synchronizedListener = new NetworkOperationData.OnNewItemListener() {
			public synchronized void onNewItem(INetworkLink link, NetworkLibraryItem item) {
				listener.onNewItem(link, item);
			}
			public synchronized boolean confirmInterrupt() {
				return listener.confirmInterrupt();
			}
			public synchronized void commitItems(INetworkLink link) {
				listener.commitItems(link);
			}
		};

		synchronized (myLinks) {
			for (INetworkLink link: myLinks) {
				//if (link.OnOption.getValue()) {
				// execute next code only if link is enabled
				//}
				final NetworkOperationData data = link.createOperationData(link, synchronizedListener);
				final ZLNetworkRequest request = link.simpleSearchRequest(pattern, data);
				if (request != null) {
					dataList.add(data);
					requestList.add(request);
				}
			}
		}

		while (requestList.size() != 0) {
			final String errorMessage = ZLNetworkManager.Instance().perform(requestList);
			if (errorMessage != null) {
				return errorMessage;
			}

			requestList.clear();

			if (listener.confirmInterrupt()) {
				return null;
			}
			for (NetworkOperationData data: dataList) {
				ZLNetworkRequest request = data.resume();
				if (request != null) {
					requestList.add(request);
				}
			}
		}

		return null;
	}

	private ICustomNetworkLink.SaveLinkListener myChangesListener = new ICustomNetworkLink.SaveLinkListener() {
		public void onSaveLink(ICustomNetworkLink link) {
			NetworkDatabase.Instance().saveCustomLink(link);
		}
	};

	private <T extends INetworkLink> void addLinkInternal(ArrayList<T> list, T link, LinksComparator comparator) {
		synchronized (myLinks) {
			final int index = Collections.binarySearch(list, link, comparator);
			if (index >= 0) {
				throw new RuntimeException(""Unable to add link with duplicated title to the library"");
			}
			final int insertAt = -index - 1;
			list.add(insertAt, link);
		}
	}

	public void addCustomLink(ICustomNetworkLink link) {
		addLinkInternal(myCustomLinks, link, new LinksComparator());
		link.setSaveLinkListener(myChangesListener);
		link.saveLink();
	}

	public void removeCustomLink(ICustomNetworkLink link) {
		synchronized (myLinks) {
			final int index = Collections.binarySearch(myCustomLinks, link, new LinksComparator());
			if (index < 0) {
				return;
			}
			myCustomLinks.remove(index);
		}
		NetworkDatabase.Instance().deleteCustomLink(link);
		link.setSaveLinkListener(null);
	}

	public boolean hasCustomLinkTitle(String title, ICustomNetworkLink exeptFor) {
		synchronized (myLinks) {
			for (INetworkLink link: myLinks) {
				if (link != exeptFor && link.getTitle().equals(title)) {
					return true;
				}
			}
		}
		return false;
	}

	public boolean hasCustomLinkSite(String siteName, ICustomNetworkLink exeptFor) {
		synchronized (myLinks) {
			for (INetworkLink link: myLinks) {
				if (link != exeptFor && link.getSiteName().equals(siteName)) {
					return true;
				}
			}
		}
		return false;
	}
}
",True,282,5,33,14,34,10,17,L6
108,org.geometerplus.fbreader.network.NetworkLibraryItem.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

public abstract class NetworkLibraryItem {

	public final INetworkLink Link;
	public final String Title;
	public final String Summary;
	public final String Cover;

	//public org.geometerplus.fbreader.network.atom.ATOMEntry dbgEntry;

	/**
	 * Creates new NetworkLibraryItem instance.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param cover      cover url. Can be <code>null</code>.
	 */
	protected NetworkLibraryItem(INetworkLink link, String title, String summary, String cover) {
		Link = link;
		Title = title;
		Summary = summary;
		Cover = cover;
	}
}
",False,258,6,33,15,22,29,1,L6
109,org.geometerplus.fbreader.network.NetworkOperationData.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;


public class NetworkOperationData {

	public interface OnNewItemListener {
		void onNewItem(INetworkLink link, NetworkLibraryItem item);

		void commitItems(INetworkLink link);

		// returns true to confirm interrupt reading; return false to continue reading.
		// once true has been returned, all next calls must return true.
		boolean confirmInterrupt();
	}

	public final INetworkLink Link;
	public OnNewItemListener Listener;
	public String ResumeURI;

	private int myResumeCount;

	public NetworkOperationData(INetworkLink link, OnNewItemListener listener) {
		Link = link;
		Listener = listener;
	}

	public void clear() {
		ResumeURI = null;
	}

	public ZLNetworkRequest resume() {
		final ZLNetworkRequest request = Link.resume(this);
		clear();
		return request;
	}
}
",False,246,6,33,15,22,11,3,L6
110,org.geometerplus.fbreader.network.SearchResult.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.LinkedHashMap;
import java.util.LinkedList;

public class SearchResult {

	public final String Summary;
	public final LinkedHashMap<NetworkBookItem.AuthorData, LinkedList<NetworkBookItem>> BooksMap;

	public SearchResult(String summary) {
		Summary = summary;
		BooksMap = new LinkedHashMap<NetworkBookItem.AuthorData, LinkedList<NetworkBookItem>>();
	}

	public void addBook(NetworkBookItem book) {
		for (NetworkBookItem.AuthorData author: book.Authors) {
			LinkedList<NetworkBookItem> list = BooksMap.get(author);
			if (list == null) {
				list = new LinkedList<NetworkBookItem>();
				BooksMap.put(author, list);
			}
			list.add(book);
		}
	}

	public boolean empty() {
		return BooksMap.size() == 0;
	}
}
",False,237,11,30,15,22,3,1,L6
111,org.geometerplus.fbreader.network.DecoratedBookReference.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;


public class DecoratedBookReference extends BookReference {

	private final String myCleanURL;

	public DecoratedBookReference(BookReference base, String url) {
		super(url, base.BookFormat, base.ReferenceType);
		myCleanURL = base.cleanURL();
	}

	public String cleanURL() {
		return myCleanURL;
	}
}
",False,117,9,33,4,2,1,1,L6
112,org.geometerplus.fbreader.network.NetworkErrors.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkErrors;

public final class NetworkErrors extends ZLNetworkErrors {

	public static final String ERROR_INTERNAL = ""internalError"";
	public static final String ERROR_PURCHASE_NOT_ENOUGH_MONEY = ""purchaseNotEnoughMoney"";
	public static final String ERROR_PURCHASE_MISSING_BOOK = ""purchaseMissingBook"";
	public static final String ERROR_PURCHASE_ALREADY_PURCHASED = ""purchaseAlreadyPurchased"";
	public static final String ERROR_BOOK_NOT_PURCHASED = ""bookNotPurchased"";
	public static final String ERROR_DOWNLOAD_LIMIT_EXCEEDED = ""downloadLimitExceeded"";

	public static final String ERROR_LOGIN_ALREADY_TAKEN = ""loginAlreadyTaken"";
	public static final String ERROR_LOGIN_WAS_NOT_SPECIFIED = ""loginNotSpecified"";
	public static final String ERROR_PASSWORD_WAS_NOT_SPECIFIED = ""passwordNotSpecified"";
	public static final String ERROR_EMAIL_WAS_NOT_SPECIFIED = ""emailNotSpecified"";
	public static final String ERROR_INVALID_EMAIL = ""invalidEMail"";
	public static final String ERROR_TOO_MANY_REGISTRATIONS = ""tooManyRegistrations"";

	public static final String ERROR_NO_USER_EMAIL = ""noUserEmail"";

	public static final String ERROR_UNSUPPORTED_OPERATION = ""unsupportedOperation"";

}
",False,150,7,33,8,11,10,1,L6
113,org.geometerplus.fbreader.network.NetworkCatalogItem.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;


public abstract class NetworkCatalogItem extends NetworkLibraryItem {

	// catalog types:
	public static final int CATALOG_OTHER = 0;
	public static final int CATALOG_BY_AUTHORS = 1;

	// catalog visibility types:
	public static final int VISIBLE_ALWAYS = 1;
	public static final int VISIBLE_LOGGED_USER = 2;

	// URL type values:
	public static final int URL_NONE = 0;
	public static final int URL_CATALOG = 1;
	public static final int URL_HTML_PAGE = 2;

	public final int Visibility;
	public final int CatalogType;
	public final TreeMap<Integer, String> URLByType;

	/**
	 * Creates new NetworkCatalogItem instance with <code>VISIBLE_ALWAYS</code> visibility and <code>CATALOG_OTHER</code> type.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param cover      cover url. Can be <code>null</code>.
	 * @param urlByType  map contains URLs and their types. Must be not <code>null</code>.
	 */
	public NetworkCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType) {
		this(link, title, summary, cover, urlByType, VISIBLE_ALWAYS, CATALOG_OTHER);
	}

	/**
	 * Creates new NetworkCatalogItem instance with specified visibility and <code>CATALOG_OTHER</code> type.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param cover      cover url. Can be <code>null</code>.
	 * @param urlByType  map contains URLs and their types. Must be not <code>null</code>.
	 * @param visibility value defines when this library item will be shown in the network library. 
	 *                   Can be one of the VISIBLE_* values.
	 */
	public NetworkCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, int visibility) {
		this(link, title, summary, cover, urlByType, visibility, CATALOG_OTHER);
	}

	/**
	 * Creates new NetworkCatalogItem instance with specified visibility and type.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param cover      cover url. Can be <code>null</code>.
	 * @param urlByType  map contains URLs and their types. Must be not <code>null</code>.
	 * @param visibility value defines when this library item will be shown in the network library. 
	 *                   Can be one of the VISIBLE_* values.
	 * @param catalogType value defines type of this catalog. Can be one of the CATALOG_* values.
	 */
	public NetworkCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, int visibility, int catalogType) {
		super(link, title, summary, cover);
		Visibility = visibility;
		CatalogType = catalogType;
		URLByType = new TreeMap<Integer, String>(urlByType);
	}

	public abstract String loadChildren(NetworkOperationData.OnNewItemListener listener); // returns Error Message

	public boolean supportsResumeLoading() {
		return false;
	}

	public String resumeLoading(NetworkOperationData.OnNewItemListener listener) { // returns Error Message
		return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
	}


	/**
	 * Method is called each time this item is displayed to the user.
	 *
	 * This method is called when UI-element corresponding to this item is shown to the User.
	 */
	public void onDisplayItem() {
	}

	public int getVisibility() {
		if (Visibility == VISIBLE_ALWAYS) {
			return ZLBoolean3.B3_TRUE;
		}
		if (Visibility == VISIBLE_LOGGED_USER) {
			if (Link.authenticationManager() == null) {
				return ZLBoolean3.B3_FALSE;
			}
			return (Link.authenticationManager().isAuthorised(false).Status == ZLBoolean3.B3_TRUE) ?
				ZLBoolean3.B3_TRUE : ZLBoolean3.B3_UNDEFINED;
		}
		return ZLBoolean3.B3_FALSE;
	}
}
",False,248,6,33,14,22,11,8,L6
114,org.geometerplus.fbreader.network.INetworkLink.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Set;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


public interface INetworkLink {

	String URL_MAIN = ""main"";
	String URL_SEARCH = ""search"";
	String URL_SIGN_IN = ""signIn"";
	String URL_SIGN_OUT = ""signOut"";
	String URL_SIGN_UP = ""signUp"";
	String URL_REFILL_ACCOUNT = ""refillAccount"";
	String URL_RECOVER_PASSWORD = ""recoverPassword"";

	String getSiteName();
	String getTitle();
	String getSummary();
	String getIcon();
	String getLink(String urlKey);

	Set<String> getLinkKeys();

	NetworkOperationData createOperationData(INetworkLink link,
			NetworkOperationData.OnNewItemListener listener);

	ZLNetworkRequest simpleSearchRequest(String pattern, NetworkOperationData data);
	ZLNetworkRequest resume(NetworkOperationData data);

	NetworkLibraryItem libraryItem();
	NetworkAuthenticationManager authenticationManager();

	String rewriteUrl(String url, boolean isUrlExternal);
}
",False,251,6,33,14,22,30,4,L6
115,org.geometerplus.fbreader.network.ICustomNetworkLink.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

public interface ICustomNetworkLink extends INetworkLink {

	public static final int INVALID_ID = -1;

	int getId();
	void setId(int id);

	interface SaveLinkListener {
		void onSaveLink(ICustomNetworkLink link);
	}

	void setSaveLinkListener(SaveLinkListener listener);
	void saveLink();

	void setSiteName(String name);
	void setTitle(String title);
	void setSummary(String summary);
	void setIcon(String icon);

	void setLink(String urlKey, String url);
	void removeLink(String urlKey);

	String reloadInfo();

	// returns true if next methods have changed link's data:
	//   setSiteName, setTitle, setSummary, setIcon, setLink, removeLink
	boolean hasChanges();

	// resets hasChanged() result
	void resetChanges();
}
",False,241,6,33,15,22,7,1,L6
116,org.geometerplus.fbreader.network.BuyBookReference.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

public class BuyBookReference extends BookReference {

	public final String Price;

	public BuyBookReference(String url, int format, int type, String price) {
		super(url, format, type);
		Price = price;
	}

	public static String price(String price, String currency) {
		if (price == null || currency == null) {
			return price;
		} else if (currency.equals(""RUB"")) {
			return price + "" \u0440."";
		} else if (currency.equals(""USD"")) {
			return ""$"" + price;
		} else if (currency.equals(""GBP"")) {
			return ""\u00A3"" + price;
		} else if (currency.equals(""EUR"")) {
			return ""\u20AC"" + price;
		} else if (currency.equals(""JPY"")) {
			return ""\u00A5"" + price;
		}
		return currency + "" "" + price;
	}

}
",False,117,9,34,4,2,3,1,L6
117,org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication;

import java.util.HashMap;

import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.fbreader.network.*;

import org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager;


public abstract class NetworkAuthenticationManager {

	private static final HashMap<String, NetworkAuthenticationManager> ourManagers = new HashMap<String, NetworkAuthenticationManager>();

	public static NetworkAuthenticationManager createManager(INetworkLink link, String sslCertificate, Class<? extends NetworkAuthenticationManager> managerClass) {
		NetworkAuthenticationManager mgr = ourManagers.get(link.getSiteName());
		if (mgr == null) {
			if (managerClass == LitResAuthenticationManager.class) {
				mgr = new LitResAuthenticationManager(link, sslCertificate);
			}
			if (mgr != null) {
				ourManagers.put(link.getSiteName(), mgr);
			}
		}
		return mgr;
	}


	public final INetworkLink Link;
	public final ZLStringOption UserNameOption;
	public final String SSLCertificate;

	protected NetworkAuthenticationManager(INetworkLink link, String sslCertificate) {
		Link = link;
		UserNameOption = new ZLStringOption(link.getSiteName(), ""userName"", """");
		SSLCertificate = sslCertificate;
	}

	/*
	 * Common manager methods
	 */
	public abstract AuthenticationStatus isAuthorised(boolean useNetwork /* = true */);
	public abstract String authorise(String password); // returns error message
	public abstract void logOut();
	public abstract BookReference downloadReference(NetworkBookItem book);

	/*
	 * Account specific methods (can be called only if authorised!!!)
	 */
	public abstract String currentUserName();

	public boolean needsInitialization() {
		return false;
	}

	// returns error message
	public String initialize() {
		return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
	}

	// returns true if link must be purchased before downloading
	public boolean needPurchase(NetworkBookItem book) {
		return true;
	}

	// returns error message
	public String purchaseBook(NetworkBookItem book) {
		return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
	}

	public String currentAccount() {
		return null;
	}

	//public abstract ZLNetworkSSLCertificate certificate();

	/*
	 * refill account
	 */

	public boolean refillAccountSupported() {
		return false;
	}

	public String refillAccountLink() {
		return null;
	}

	/*
	 * new User Registration
	 */
	public boolean registrationSupported() {
		return false;
	}

	public String registerUser(String login, String password, String email) {
		return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
	}

	/*
	 * Password Recovery
	 */
	public boolean passwordRecoverySupported() {
		return false;
	}

	public String recoverPassword(String email) {
		return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
	}
}
",True,244,8,34,13,22,13,8,L6
118,org.geometerplus.fbreader.network.authentication.AuthenticationStatus.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;

public class AuthenticationStatus {

	public final int Status; // ZLBoolean3 values
	public final String Message;

	public AuthenticationStatus(boolean status) {
		Status = status ? ZLBoolean3.B3_TRUE : ZLBoolean3.B3_FALSE;
		Message = null;
	}

	public AuthenticationStatus(String message) {
		Status = ZLBoolean3.B3_UNDEFINED;
		Message = message;
	}
}
",False,112,7,33,1,1,10,1,L6
119,org.geometerplus.fbreader.network.authentication.litres.LitResLoginXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.NetworkErrors;


class LitResLoginXMLReader extends LitResAuthenticationXMLReader {

	private static final String TAG_AUTHORIZATION_OK = ""catalit-authorization-ok"";
	private static final String TAG_AUTHORIZATION_FAILED = ""catalit-authorization-failed"";

	public String FirstName;
	public String LastName;
	public String Sid;

	public LitResLoginXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_AUTHORIZATION_FAILED == tag) {
			setErrorCode(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
		} else if (TAG_AUTHORIZATION_OK == tag) {
			FirstName = attributes.getValue(""first-name"");
			LastName = attributes.getValue(""first-name"");
			Sid = attributes.getValue(""sid"");
		} else {
			setErrorCode(NetworkErrors.ERROR_SOMETHING_WRONG, HostName);
		}
		return true;
	}
}
",True,146,9,33,7,7,1,4,L6
120,org.geometerplus.fbreader.network.authentication.litres.LitResPasswordRecoveryXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.NetworkErrors;


class LitResPasswordRecoveryXMLReader extends LitResAuthenticationXMLReader {

	private static final String TAG_PASSWORD_RECOVERY_OK = ""catalit-pass-recover-ok"";
	private static final String TAG_PASSWORD_RECOVERY_FAILED = ""catalit-pass-recover-failed"";

	public LitResPasswordRecoveryXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_PASSWORD_RECOVERY_FAILED == tag) {
			final String error = attributes.getValue(""error"");
			if (""1"".equals(error)) {
				setErrorCode(NetworkErrors.ERROR_NO_USER_EMAIL);
			} else if (""2"".equals(error)) {
				setErrorCode(NetworkErrors.ERROR_EMAIL_WAS_NOT_SPECIFIED);
			} else {
				setErrorCode(NetworkErrors.ERROR_INTERNAL);
			}
		} else if (TAG_PASSWORD_RECOVERY_OK == tag) {
			// NOP
		} else {
			setErrorCode(NetworkErrors.ERROR_SOMETHING_WRONG, HostName);
		}
		return true;
	}
}
",True,146,9,33,7,7,1,4,L6
121,org.geometerplus.fbreader.network.authentication.litres.LitResNetworkRequest.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.io.InputStream;
import java.io.IOException;
import java.net.URLConnection;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;


class LitResNetworkRequest extends ZLNetworkRequest {

	public final LitResAuthenticationXMLReader Reader;

	public LitResNetworkRequest(String url, String sslCertificate, LitResAuthenticationXMLReader reader) {
		super(url, sslCertificate);
		Reader = reader;
	}

	@Override
	public String handleStream(URLConnection connection, InputStream inputStream) throws IOException {
		Reader.read(inputStream);
		return Reader.getErrorMessage();
	}
}
",False,147,9,33,6,8,1,3,L6
122,org.geometerplus.fbreader.network.authentication.litres.LitResXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.HtmlToString;


class LitResXMLReader extends LitResAuthenticationXMLReader {

	public final INetworkLink Link;
	public final List<NetworkLibraryItem> Books;

	private int myIndex;

	private String myBookId;
	private String myTitle;
	//private String myLanguage;
	//private String myDate;
	private String mySeriesTitle;
	private int myIndexInSeries;

	private String mySummary;

	private String myCover;

	private String myAuthorFirstName;
	private String myAuthorMiddleName;
	private String myAuthorLastName;
	private LinkedList<NetworkBookItem.AuthorData> myAuthors = new LinkedList<NetworkBookItem.AuthorData>();

	private LinkedList<String> myTags = new LinkedList<String>();
	private HashMap<Integer, String> myURLByType = new HashMap<Integer, String>(); // TODO: remove
	private LinkedList<BookReference> myReferences = new LinkedList<BookReference>();

	public LitResXMLReader(INetworkLink link, List<NetworkLibraryItem> books) {
		super(link.getSiteName());
		Link = link;
		Books = books;
	}


	private static final int START = 0;
	private static final int CATALOG = 1;
	private static final int BOOK = 2;
	private static final int BOOK_DESCRIPTION = 3;
	private static final int HIDDEN = 4;
	private static final int TITLE_INFO = 5;
	private static final int GENRE = 6;
	private static final int AUTHOR = 7;
	private static final int FIRST_NAME = 8;
	private static final int MIDDLE_NAME = 9;
	private static final int LAST_NAME = 10;
	private static final int BOOK_TITLE = 11;
	private static final int ANNOTATION = 12;
	private static final int DATE = 13;
	private static final int LANGUAGE = 14;

	private static final String TAG_CATALOG = ""catalit-fb2-books"";
	private static final String TAG_BOOK = ""fb2-book"";
	private static final String TAG_TEXT_DESCRIPTION = ""text_description"";
	private static final String TAG_HIDDEN = ""hidden"";
	private static final String TAG_TITLE_INFO = ""title-info"";
	private static final String TAG_GENRE = ""genre"";
	private static final String TAG_AUTHOR = ""author"";
	private static final String TAG_FIRST_NAME = ""first-name"";
	private static final String TAG_MIDDLE_NAME = ""middle-name"";
	private static final String TAG_LAST_NAME = ""last-name"";
	private static final String TAG_BOOK_TITLE = ""book-title"";
	private static final String TAG_ANNOTATION = ""annotation"";
	private static final String TAG_DATE = ""date"";
	private static final String TAG_SEQUENCE = ""sequence"";
	private static final String TAG_LANGUAGE = ""lang"";

	private int myState = START;
	private final StringBuilder myBuffer = new StringBuilder();
	private HtmlToString myHtmlToString = new HtmlToString();

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.intern();

		final char[] bufferContentArray = myBuffer.toString().trim().toCharArray();
		final String bufferContent;
		if (bufferContentArray.length == 0) {
			bufferContent = null;
		} else {
			bufferContent = new String(bufferContentArray);
		}
		myBuffer.delete(0, myBuffer.length());

		switch(myState) {
		case START:
			if (TAG_CATALOG == tag) {
				myState = CATALOG;
			}
			break;
		case CATALOG:
			if (TAG_BOOK == tag) {
				myBookId = attributes.getValue(""hub_id"");
				myCover = attributes.getValue(""cover_preview"");

				final String url = attributes.getValue(""url"");
				if (url != null) {
					myURLByType.put(NetworkCatalogItem.URL_HTML_PAGE, url);
				}

				myReferences.add(new BookReference(
					""https://robot.litres.ru/pages/catalit_download_book/?art="" + myBookId,
					BookReference.Format.FB2_ZIP,
					BookReference.Type.DOWNLOAD_FULL_CONDITIONAL
				));
				myState = BOOK;
			}
			break;
		case BOOK:
			if (TAG_TEXT_DESCRIPTION == tag) {
				myState = BOOK_DESCRIPTION;
			}
			break;
		case BOOK_DESCRIPTION:
			if (TAG_HIDDEN == tag) {
				myState = HIDDEN;
			}
			break;
		case HIDDEN:
			if (TAG_TITLE_INFO == tag) {
				myState = TITLE_INFO;
			}
			break;
		case TITLE_INFO:
			if (TAG_GENRE == tag) {
				myState = GENRE;
			} else if (TAG_AUTHOR == tag) {
				myState = AUTHOR;
			} else if (TAG_BOOK_TITLE == tag) {
				myState = BOOK_TITLE;
			} else if (TAG_ANNOTATION == tag) {
				myHtmlToString.setupTextContent(""text/xhtml"");
				myState = ANNOTATION;
			} else if (TAG_DATE == tag) {
				myState = DATE;
			} else if (TAG_LANGUAGE == tag) {
				myState = LANGUAGE;
			} else if (TAG_SEQUENCE == tag) {
				mySeriesTitle = attributes.getValue(""name"");
				if (mySeriesTitle != null) {
					myIndexInSeries = 0;
					final String indexInSeries = attributes.getValue(""number"");
					if (indexInSeries != null) {
						try {
							myIndexInSeries = Integer.parseInt(indexInSeries);
						} catch (NumberFormatException e) {
						}
					}
				}
				//myState = SEQUENCE; // handled through attributes without state
			}
			break;
		case AUTHOR:
			if (TAG_FIRST_NAME == tag) {
				myState = FIRST_NAME;
			} else if (TAG_MIDDLE_NAME == tag) {
				myState = MIDDLE_NAME;
			} else if (TAG_LAST_NAME == tag) {
				myState = LAST_NAME;
			}
			break;
		case ANNOTATION:
			myHtmlToString.processTextContent(false, tag, attributes, bufferContent);
			break;
		}
		return false;
	}


	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.intern();

		final char[] bufferContentArray = myBuffer.toString().trim().toCharArray();
		final String bufferContent;
		if (bufferContentArray.length == 0) {
			bufferContent = null;
		} else {
			bufferContent = new String(bufferContentArray);
		}
		myBuffer.delete(0, myBuffer.length());

		switch (myState) {
		case CATALOG:
			if (TAG_CATALOG == tag) {
				myState = START;
			}
			break;
		case BOOK:
			if (TAG_BOOK == tag) {

				Books.add(new NetworkBookItem(
					Link,
					myBookId,
					myIndex++,
					myTitle,
					mySummary,
					//myLanguage,
					//myDate,
					myAuthors,
					myTags,
					mySeriesTitle,
					myIndexInSeries,
					myCover,
					myReferences
				));

				myBookId = myTitle = /*myLanguage = myDate = */mySeriesTitle = mySummary = myCover = null;
				myIndexInSeries = 0;
				myAuthors.clear();
				myTags.clear();
				myURLByType.clear();
				myReferences.clear();
				myState = CATALOG;
			}
			break;
		case BOOK_DESCRIPTION:
			if (TAG_TEXT_DESCRIPTION == tag) {
				myState = BOOK;
			}
			break;
		case HIDDEN:
			if (TAG_HIDDEN == tag) {
				myState = BOOK_DESCRIPTION;
			}
			break;
		case TITLE_INFO:
			if (TAG_TITLE_INFO == tag) {
				myState = HIDDEN;
			}
			break;
		case AUTHOR:
			if (TAG_AUTHOR == tag) {
				StringBuilder displayName = new StringBuilder();
				if (myAuthorFirstName != null) {
					displayName.append(myAuthorFirstName).append("" "");
				}
				if (myAuthorMiddleName != null) {
					displayName.append(myAuthorMiddleName).append("" "");
				}
				if (myAuthorLastName != null) {
					displayName.append(myAuthorLastName).append("" "");
				}
				myAuthors.add(new NetworkBookItem.AuthorData(displayName.toString().trim(), myAuthorLastName));
				myAuthorFirstName = null;
				myAuthorMiddleName = null;
				myAuthorLastName = null;
				myState = TITLE_INFO;
			}
			break;
		case FIRST_NAME:
			if (TAG_FIRST_NAME == tag) {
				myAuthorFirstName = bufferContent;
				myState = AUTHOR;
			}
			break;
		case MIDDLE_NAME:
			if (TAG_MIDDLE_NAME == tag) {
				myAuthorMiddleName = bufferContent;
				myState = AUTHOR;
			}
			break;
		case LAST_NAME:
			if (TAG_LAST_NAME == tag) {
				myAuthorLastName = bufferContent;
				myState = AUTHOR;
			}
			break;
		case GENRE:
			if (TAG_GENRE == tag) {
				/*if (bufferContent != null) {
					const std::map<std::string,shared_ptr<LitResGenre> > &genresMap =
						LitResGenreMap::Instance().genresMap();
					const std::map<shared_ptr<LitResGenre>,std::string> &genresTitles =
						LitResGenreMap::Instance().genresTitles();

					std::map<std::string, shared_ptr<LitResGenre> >::const_iterator it = genresMap.find(bufferContent);
					if (it != genresMap.end()) {
						std::map<shared_ptr<LitResGenre>, std::string>::const_iterator jt = genresTitles.find(it->second);
						if (jt != genresTitles.end()) {
							myTags.push_back(jt->second);
						}
					}
				}*/
				myState = TITLE_INFO;
			}
			break;
		case BOOK_TITLE:
			if (TAG_BOOK_TITLE == tag) {
				myTitle = bufferContent;
				myState = TITLE_INFO;
			}
			break;
		case ANNOTATION:
			if (TAG_ANNOTATION == tag) {
				mySummary = myHtmlToString.finishTextContent(bufferContent);
				myState = TITLE_INFO;
			} else {
				myHtmlToString.processTextContent(true, tag, null, bufferContent);
			}
			break;
		case DATE:
			if (TAG_DATE == tag) {
				//myDate = bufferContent;
				myState = TITLE_INFO;
			}
			break;
		case LANGUAGE:
			if (TAG_LANGUAGE == tag) {
				//myLanguage = bufferContent;
				myState = TITLE_INFO;
			}
			break;
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int length) {
		myBuffer.append(data, start, length);
	}
}
",True,161,0,0,11,28,1,8,L6
123,org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.authentication.*;


public class LitResAuthenticationManager extends NetworkAuthenticationManager {

	private boolean mySidChecked;

	private ZLStringOption mySidUserNameOption;
	private ZLStringOption mySidOption;

	private String myInitializedDataSid;
	private String myAccount;
	private final HashMap<String, NetworkLibraryItem> myPurchasedBooks = new HashMap<String, NetworkLibraryItem>();


	public LitResAuthenticationManager(INetworkLink link, String sslCertificate) {
		super(link, sslCertificate);
		mySidUserNameOption = new ZLStringOption(link.getSiteName(), ""sidUserName"", """");
		mySidOption = new ZLStringOption(link.getSiteName(), ""sid"", """");
	}

	@Override
	public AuthenticationStatus isAuthorised(boolean useNetwork /* = true */) {
		final String sid;
		synchronized (this) {
			boolean authState =
				mySidUserNameOption.getValue().length() != 0 &&
				mySidOption.getValue().length() != 0;

			if (mySidChecked || !useNetwork) {
				return new AuthenticationStatus(authState);
			}

			if (!authState) {
				mySidChecked = true;
				mySidUserNameOption.setValue("""");
				mySidOption.setValue("""");
				return new AuthenticationStatus(false);
			}
			sid = mySidOption.getValue();
		}

		String url = Link.getLink(INetworkLink.URL_SIGN_IN);
		if (url == null) {
			return new AuthenticationStatus(NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION));
		}
		url = ZLNetworkUtil.appendParameter(url, ""sid"", sid);

		final LitResLoginXMLReader xmlReader = new LitResLoginXMLReader(Link.getSiteName());
		final String error = ZLNetworkManager.Instance().perform(new LitResNetworkRequest(url, SSLCertificate, xmlReader));

		synchronized (this) {
			if (error != null) {
				if (!error.equals(NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED))) {
					return new AuthenticationStatus(error);
				}
				mySidChecked = true;
				mySidUserNameOption.setValue("""");
				mySidOption.setValue("""");
				return new AuthenticationStatus(false);
			}
			mySidChecked = true;
			mySidOption.setValue(xmlReader.Sid);
			return new AuthenticationStatus(true);
		}
	}

	@Override
	public String authorise(String password) {
		String url = Link.getLink(INetworkLink.URL_SIGN_IN);
		if (url == null) {
			return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
		}
		final String login;
		synchronized (this) {
			login = UserNameOption.getValue();
		}
		url = ZLNetworkUtil.appendParameter(url, ""login"", login);
		url = ZLNetworkUtil.appendParameter(url, ""pwd"", password);

		final LitResLoginXMLReader xmlReader = new LitResLoginXMLReader(Link.getSiteName());
		final String error = ZLNetworkManager.Instance().perform(new LitResNetworkRequest(url, SSLCertificate, xmlReader));

		synchronized (this) {
			mySidChecked = true;
			if (error != null) {
				mySidUserNameOption.setValue("""");
				mySidOption.setValue("""");
				return error;
			}
			mySidOption.setValue(xmlReader.Sid);
			mySidUserNameOption.setValue(UserNameOption.getValue());
			return null;
		}
	}

	@Override
	public synchronized void logOut() {
		mySidChecked = true;
		mySidUserNameOption.setValue("""");
		mySidOption.setValue("""");
	}

	@Override
	public BookReference downloadReference(NetworkBookItem book) {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			return null;
		}
		BookReference reference = book.reference(BookReference.Type.DOWNLOAD_FULL_CONDITIONAL);
		if (reference == null) {
			return null;
		}
		String url = reference.URL;
		url = ZLNetworkUtil.appendParameter(url, ""sid"", sid);
		return new DecoratedBookReference(reference, url);
	}


	@Override
	public String currentUserName() {
		final String value;
		synchronized (this) {
			value = mySidUserNameOption.getValue();
		}
		if (value.length() == 0) {
			return null;
		}
		return value;
	}


	@Override
	public synchronized boolean needPurchase(NetworkBookItem book) {
		return !myPurchasedBooks.containsKey(book.Id);
	}

	@Override
	public String purchaseBook(NetworkBookItem book) {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			return NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
		}

		BookReference reference = book.reference(BookReference.Type.BUY);
		if (reference == null) {
			return NetworkErrors.errorMessage(NetworkErrors.ERROR_BOOK_NOT_PURCHASED); // TODO: more correct error message???
		}
		String query = reference.URL;
		query = ZLNetworkUtil.appendParameter(query, ""sid"", sid);

		final LitResPurchaseXMLReader xmlReader = new LitResPurchaseXMLReader(Link.getSiteName());
		final String error = ZLNetworkManager.Instance().perform(new LitResNetworkRequest(query, SSLCertificate, xmlReader));

		synchronized (this) {
			if (xmlReader.Account != null) {
				myAccount = BuyBookReference.price(xmlReader.Account, ""RUB"");
			}
			final String authenticationError = NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
			if (authenticationError.equals(error)) {
				mySidChecked = true;
				mySidUserNameOption.setValue("""");
				mySidOption.setValue("""");
			}
			final String alreadyPurchasedError = NetworkErrors.errorMessage(NetworkErrors.ERROR_PURCHASE_ALREADY_PURCHASED);
			if (!alreadyPurchasedError.equals(error)) {
				if (error != null) {
					return error;
				}
				if (xmlReader.BookId == null || !xmlReader.BookId.equals(book.Id)) {
					return NetworkErrors.errorMessage(NetworkErrors.ERROR_SOMETHING_WRONG, Link.getSiteName());
				}
			}
			myPurchasedBooks.put(book.Id, book);
			return error;
		}
	}

	@Override
	public boolean refillAccountSupported() {
		return true;
	}

	@Override
	public String refillAccountLink() {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			return null;
		}
		final String url = Link.getLink(INetworkLink.URL_REFILL_ACCOUNT);
		if (url == null) {
			return null;
		}
		return ZLNetworkUtil.appendParameter(url, ""sid"", sid);
	}

	@Override
	public synchronized String currentAccount() {
		return myAccount;
	}

	String reloadPurchasedBooks() {
		final LitResNetworkRequest networkRequest;
		synchronized (this) {
			final String sid = mySidOption.getValue();
			if (sid.length() == 0) {
				return NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
			}
			if (!sid.equals(myInitializedDataSid)) {
				mySidChecked = true;
				mySidUserNameOption.setValue("""");
				mySidOption.setValue("""");		
				return NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
			}
			networkRequest = loadPurchasedBooks();
		}

		final String error = ZLNetworkManager.Instance().perform(networkRequest);

		synchronized (this) {
			if (error != null) {
				//loadPurchasedBooksOnError();
				if (error.equals(NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED))) {
					mySidChecked = true;
					mySidUserNameOption.setValue("""");
					mySidOption.setValue("""");
				}
				return error;
			}
			loadPurchasedBooksOnSuccess(networkRequest);
			return null;
		}
	}

	synchronized void collectPurchasedBooks(List<NetworkLibraryItem> list) {
		list.addAll(myPurchasedBooks.values());
	}


	@Override
	public synchronized boolean needsInitialization() {
		final String sid = mySidOption.getValue();
		if (sid.length() == 0) {
			return false;
		}
		return !sid.equals(myInitializedDataSid);
	}

	@Override
	public String initialize() {
		final String sid;
		final LitResNetworkRequest purchasedBooksRequest;
		final LitResNetworkRequest accountRequest;
		synchronized (this) {
			sid = mySidOption.getValue();
			if (sid.length() == 0) {
				return NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
			}
			if (sid.equals(myInitializedDataSid)) {
				return null;
			}

			purchasedBooksRequest = loadPurchasedBooks();
			accountRequest = loadAccount();
		}

		final LinkedList<ZLNetworkRequest> requests = new LinkedList<ZLNetworkRequest>();
		requests.add(purchasedBooksRequest);
		requests.add(accountRequest);
		final String error = ZLNetworkManager.Instance().perform(requests);

		synchronized (this) {
			if (error != null) {
				myInitializedDataSid = null;
				loadPurchasedBooksOnError();
				loadAccountOnError();
				return error;
			}
			myInitializedDataSid = sid;
			loadPurchasedBooksOnSuccess(purchasedBooksRequest);
			loadAccountOnSuccess(accountRequest);
			return null;
		}
	}

	private LitResNetworkRequest loadPurchasedBooks() {
		final String sid = mySidOption.getValue();

		String query = ""pages/catalit_browser/"";
		query = ZLNetworkUtil.appendParameter(query, ""my"", ""1"");
		query = ZLNetworkUtil.appendParameter(query, ""sid"", sid);

		return new LitResNetworkRequest(
			LitResUtil.url(Link, query),
			SSLCertificate,
			new LitResXMLReader(Link, new LinkedList<NetworkLibraryItem>())
		);
	}

	private void loadPurchasedBooksOnError() {
		myPurchasedBooks.clear();
	}

	private void loadPurchasedBooksOnSuccess(LitResNetworkRequest purchasedBooksRequest) {
		LitResXMLReader reader = (LitResXMLReader) purchasedBooksRequest.Reader;
		myPurchasedBooks.clear();
		for (NetworkLibraryItem item: reader.Books) {
			if (item instanceof NetworkBookItem) {
				NetworkBookItem book = (NetworkBookItem) item;
				myPurchasedBooks.put(book.Id, book);
			}
		}
	}

	private LitResNetworkRequest loadAccount() {
		final String sid = mySidOption.getValue();

		String query = ""pages/purchase_book/"";
		query = ZLNetworkUtil.appendParameter(query, ""sid"", sid);
		query = ZLNetworkUtil.appendParameter(query, ""art"", ""0"");

		return new LitResNetworkRequest(
			LitResUtil.url(Link, query),
			SSLCertificate,
			new LitResPurchaseXMLReader(Link.getSiteName())
		);
	}

	private void loadAccountOnError() {
		myAccount = null;
	}

	private void loadAccountOnSuccess(LitResNetworkRequest accountRequest) {
		LitResPurchaseXMLReader reader = (LitResPurchaseXMLReader) accountRequest.Reader;
		myAccount = BuyBookReference.price(reader.Account, ""RUB"");
	}


	@Override
	public boolean registrationSupported() {
		return true;
	}

	@Override
	public String registerUser(String login, String password, String email) {
		String url = Link.getLink(INetworkLink.URL_SIGN_UP);
		if (url == null) {
			return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
		}
		url = ZLNetworkUtil.appendParameter(url, ""new_login"", login);
		url = ZLNetworkUtil.appendParameter(url, ""new_pwd1"", password);
		url = ZLNetworkUtil.appendParameter(url, ""mail"", email);

		final LitResRegisterUserXMLReader xmlReader = new LitResRegisterUserXMLReader(Link.getSiteName());
		final String error = ZLNetworkManager.Instance().perform(new LitResNetworkRequest(url, SSLCertificate, xmlReader));

		synchronized (this) {
			mySidChecked = true;
			if (error != null) {
				mySidUserNameOption.setValue("""");
				mySidOption.setValue("""");
				return error;
			}
			mySidOption.setValue(xmlReader.Sid);
			mySidUserNameOption.setValue(login);
			return null;
		}
	}


	@Override
	public boolean passwordRecoverySupported() {
		return true;
	}

	@Override
	public String recoverPassword(String email) {
		String url = Link.getLink(INetworkLink.URL_RECOVER_PASSWORD);
		if (url == null) {
			return NetworkErrors.errorMessage(NetworkErrors.ERROR_UNSUPPORTED_OPERATION);
		}
		url = ZLNetworkUtil.appendParameter(url, ""mail"", email);
		final LitResPasswordRecoveryXMLReader xmlReader =  new LitResPasswordRecoveryXMLReader(Link.getSiteName());
		return ZLNetworkManager.Instance().perform(new LitResNetworkRequest(url, SSLCertificate, xmlReader));
	}
}
",False,244,8,33,12,22,3,21,L6
124,org.geometerplus.fbreader.network.authentication.litres.LitResRegisterUserXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.NetworkErrors;


class LitResRegisterUserXMLReader extends LitResAuthenticationXMLReader {

	private static final String TAG_AUTHORIZATION_OK = ""catalit-authorization-ok"";
	private static final String TAG_REGISTRATION_FAILED = ""catalit-registration-failed"";

	public String Sid;

	public LitResRegisterUserXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_REGISTRATION_FAILED == tag) {
			final String error = attributes.getValue(""error"");
			if (""1"".equals(error)) {
				setErrorCode(NetworkErrors.ERROR_LOGIN_ALREADY_TAKEN);
			} else if (""2"".equals(error)) {
				setErrorCode(NetworkErrors.ERROR_LOGIN_WAS_NOT_SPECIFIED);
			} else if (""3"".equals(error)) {
				setErrorCode(NetworkErrors.ERROR_PASSWORD_WAS_NOT_SPECIFIED);
			} else if (""4"".equals(error)) {
				setErrorCode(NetworkErrors.ERROR_INVALID_EMAIL);
			} else if (""5"".equals(error)) {
				setErrorCode(NetworkErrors.ERROR_TOO_MANY_REGISTRATIONS);
			} else {
				setErrorCode(NetworkErrors.ERROR_INTERNAL);
			}
		} else if (TAG_AUTHORIZATION_OK == tag) {
			Sid = attributes.getValue(""sid"");
		} else {
			setErrorCode(NetworkErrors.ERROR_SOMETHING_WRONG, HostName);
		}
		return true;
	}
}
",False,146,9,33,7,7,1,4,L6
125,org.geometerplus.fbreader.network.authentication.litres.LitResPurchaseXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.NetworkErrors;


class LitResPurchaseXMLReader extends LitResAuthenticationXMLReader {

	private static final String TAG_AUTHORIZATION_FAILED = ""catalit-authorization-failed"";
	private static final String TAG_PURCHASE_OK = ""catalit-purchase-ok"";
	private static final String TAG_PURCHASE_FAILED = ""catalit-purchase-failed"";

	public String Account;
	public String BookId;

	public LitResPurchaseXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_AUTHORIZATION_FAILED == tag) {
			setErrorCode(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
		} else {
			Account = attributes.getValue(""account"");
			BookId = attributes.getValue(""art"");
			if (TAG_PURCHASE_OK == tag) {
				// nop
			} else if (TAG_PURCHASE_FAILED == tag) {
				final String error = attributes.getValue(""error"");
				if (""1"".equals(error)) {
					setErrorCode(NetworkErrors.ERROR_PURCHASE_NOT_ENOUGH_MONEY);
				} else if (""2"".equals(error)) {
					setErrorCode(NetworkErrors.ERROR_PURCHASE_MISSING_BOOK);
				} else if (""3"".equals(error)) {
					setErrorCode(NetworkErrors.ERROR_PURCHASE_ALREADY_PURCHASED);
				} else {
					setErrorCode(NetworkErrors.ERROR_INTERNAL);
				}
			} else {
				setErrorCode(NetworkErrors.ERROR_SOMETHING_WRONG, HostName);
			}
		}
		return true;
	}
}
",True,146,9,33,7,7,1,4,L6
126,org.geometerplus.fbreader.network.authentication.litres.LitResGenre.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.LinkedList;

class LitResGenre {
	public String Id;
	public String Title;
	public LinkedList<LitResGenre> Children;
}
",False,1,0,0,0,0,0,0,I0
127,org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;

import org.geometerplus.fbreader.network.NetworkErrors;


class LitResAuthenticationXMLReader extends ZLXMLReaderAdapter {

	public final String HostName;

	private String myErrorMessage;


	public LitResAuthenticationXMLReader(String hostName) {
		HostName = hostName;
	}

	protected void setErrorCode(String code) {
		myErrorMessage = NetworkErrors.errorMessage(code);
	}

	protected void setErrorCode(String code, String arg) {
		myErrorMessage = NetworkErrors.errorMessage(code, arg);
	}

	public String getErrorMessage() {
		return myErrorMessage;
	}
}
",False,150,10,33,6,8,6,3,L6
128,org.geometerplus.fbreader.network.authentication.litres.LitResBookshelfItem.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.*;


public class LitResBookshelfItem extends NetworkCatalogItem {

	private boolean myForceReload;


	public LitResBookshelfItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType) {
		super(link, title, summary, cover, urlByType);
	}

	public LitResBookshelfItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, int visibility) {
		super(link, title, summary, cover, urlByType, visibility);
	}

	public LitResBookshelfItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, int visibility, int catalogType) {
		super(link, title, summary, cover, urlByType, visibility, catalogType);
	}

	@Override
	public void onDisplayItem() {
		myForceReload = false;
	}

	@Override
	public String loadChildren(NetworkOperationData.OnNewItemListener listener) {
		LitResAuthenticationManager mgr = (LitResAuthenticationManager) Link.authenticationManager();
		if (mgr.isAuthorised(true).Status == ZLBoolean3.B3_FALSE) {
			return NetworkErrors.errorMessage(NetworkErrors.ERROR_AUTHENTICATION_FAILED);
		}
		String error = null;
		if (myForceReload) {
			error = mgr.reloadPurchasedBooks();
		}
		myForceReload = true;
		// TODO: implement asynchronous loading
		LinkedList<NetworkLibraryItem> children = new LinkedList<NetworkLibraryItem>();
		mgr.collectPurchasedBooks(children);
		Collections.sort(children, new NetworkBookItemComparator());
		for (NetworkLibraryItem item: children) {
			listener.onNewItem(Link, item);
		}
		listener.commitItems(Link);
		return error;
	}
}
",False,245,10,33,13,22,1,9,L6
129,org.geometerplus.fbreader.network.authentication.litres.LitResUtil.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.INetworkLink;


class LitResUtil {

	public static String url(String path) {
		String url = ""://robot.litres.ru/"" + path;
		if (ZLNetworkUtil.hasParameter(url, ""sid"") ||
				ZLNetworkUtil.hasParameter(url, ""pwd"")) {
			url = ""https"" + url;
		} else {
			url = ""http"" + url;
		}
		return url;
	}

	public static String url(INetworkLink link, String path) {
		return link.rewriteUrl(url(path), false);
	}
}
",False,161,0,0,15,22,1,2,L6
130,org.geometerplus.fbreader.network.authentication.litres.LitResGenreMap.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

/*import java.util.LinkedList;
import java.util.HashMap;

class LitResGenreMap {

	private static LitResGenreMap ourInstance;

	LinkedList<LitResGenre> myGenresTree;
	HashMap<String, LitResGenre> myGenresMap;
	HashMap<LitResGenre, String> myGenresTitles;

	public static LitResGenreMap Instance() {
		if (ourInstance == null) {
			ourInstance = new LitResGenreMap();
		}
		return ourInstance;
	}

	private LitResGenreMap() {
	}
}
*/",False,1,0,0,0,0,0,0,I0
131,org.geometerplus.fbreader.network.atom.ATOMDateConstruct.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public abstract class ATOMDateConstruct extends ATOMCommonAttributes implements Comparable<ATOMDateConstruct> {

	public int Year;
	public int Month;
	public int Day;
	public int Hour;
	public int Minutes;
	public int Seconds;
	public float SecondFraction;
	public int TZHour;
	public int TZMinutes;

	public ATOMDateConstruct() {
	}

	public ATOMDateConstruct(int year) {
		Year = year;
	}

	public ATOMDateConstruct(int year, int month, int day) {
		Year = year;
		Month = month;
		Day = day;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
		SecondFraction = sfract;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
		TZHour = tzhour;
		TZMinutes = tzminutes;
		SecondFraction = sfract;
	}

	public static boolean parse(String str, ATOMDateConstruct dateTime) {
		dateTime.Year = 0;
		dateTime.Month = 0;
		dateTime.Day = 0;
		dateTime.Hour = 0;
		dateTime.Minutes = 0;
		dateTime.Seconds = 0;
		dateTime.SecondFraction = 0.0f;
		dateTime.TZHour = 0;
		dateTime.TZMinutes = 0;

		if (str == null || dateTime == null) {
			return false;
		}

		final int len = str.length();
		if (len != 4 && len != 7 && len != 10 && len != 17 && len != 20 && len < 22) {
			return false;
		}

		int num = 0, sign = 1;
		float fnum = 0.0f, fmult = 0.1f;
		int start, end, log;
		char ch;
		end = 4; start = 0; log = 0;
		while (start < len) {
			ch = str.charAt(start++);
			if (!Character.isDigit(ch)) {
				return false;
			}
			num = 10 * num + ((int) (ch - '0'));
			fnum += fmult * ((int) (ch - '0'));
			fmult *= 0.1f;
			if (start == end) {
				switch (log) {
				case 0: dateTime.Year = num; break;
				case 1: dateTime.Month = num; break;
				case 2: dateTime.Day = num; break;
				case 3: dateTime.Hour = num; break;
				case 4: dateTime.Minutes = num; break;
				case 5: dateTime.Seconds = num; break;
				case 6: dateTime.SecondFraction = fnum; break;
				case 7: dateTime.TZHour = sign * num; break;
				case 8: dateTime.TZMinutes = sign * num; break;
				default: return false;
				}
				num = 0; fnum = 0.0f; fmult = 0.1f;
				if (start == len) return true;
				switch (log) {
				case 0:
				case 1:
					if (str.charAt(start++) != '-') return false;
					end = start + 2;
					break;
				case 2:
					if (str.charAt(start++) != 'T') return false;
					end = start + 2;
					break;
				case 3:
				case 7:
					if (str.charAt(start++) != ':') return false;
					end = start + 2;
					break;
				case 4:
					ch = str.charAt(start++);
					if (ch == ':') {
						end = start + 2;
					} else if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						log += 2;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				case 5:
					ch = str.charAt(start++);
					if (ch == '.') {
						end = start;
						while (Character.isDigit(str.charAt(++end))) /* NOP */;
					} else if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						log += 1;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				case 6:
					ch = str.charAt(start++);
					if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				//case 8:
				default: return false;
				}
				++log;
			}
		}
		return false;
	}

	private static void appendChars(StringBuilder buffer, char ch, int count) {
		while (count-- > 0) {
			buffer.append(ch);
		}
	}

	public final String getDateTime(boolean brief) {
		StringBuilder timezone = new StringBuilder(""Z"");
		if (TZMinutes != 0 || TZHour != 0) {
			int tzminnum = TZMinutes;
			int tzhournum = TZHour;
			char sign;
			if (tzhournum == 0) {
				sign = (tzminnum >= 0) ? '+' : '-';
			} else {
				sign = (tzhournum > 0) ? '+' : '-';
				if (tzhournum > 0 && tzminnum < 0) {
					--tzhournum;
					tzminnum = 60 + tzminnum;
				} else if (tzhournum < 0 && tzminnum > 0) {
					++tzhournum;
					tzminnum = 60 - tzminnum;
				}
			}
			String tzmin = String.valueOf(tzminnum < 0 ? -tzminnum : tzminnum);
			String tzhour = String.valueOf(tzhournum < 0 ? -tzhournum : tzhournum);
			timezone.append(sign);
			appendChars(timezone, '0', 2 - tzhour.length());
			timezone.append(tzhour);
			timezone.append(':');
			appendChars(timezone, '0', 2 - tzmin.length());
			timezone.append(tzmin);
		}

		StringBuilder time = new StringBuilder();
		StringBuilder temp = new StringBuilder();
		if (SecondFraction >= 0.01f) {
			int sfrnum = Math.round(100 * SecondFraction);
			String sfr = String.valueOf(sfrnum);
			time.append('.');
			appendChars(time, '0', 2 - sfr.length());
			time.append(sfr);
		}
		if (!brief || time.length() != 0 || Seconds != 0) {
			String sec = String.valueOf(Seconds);
			temp.append(':');
			appendChars(temp, '0', 2 - sec.length());
			temp.append(sec);
			time.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}
		if (!brief || time.length() != 0 || Hour != 0 || Minutes != 0 || timezone.length() > 1) {
			String hour = String.valueOf(Hour);
			String min = String.valueOf(Minutes);
			appendChars(temp, '0', 2 - hour.length());
			temp.append(hour);
			temp.append(':');
			appendChars(temp, '0', 2 - min.length());
			temp.append(min);
			time.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}

		StringBuilder date = new StringBuilder();
		if (!brief || time.length() != 0 || Day != 0) {
			String day = String.valueOf(Day);
			date.append('-');
			appendChars(date, '0', 2 - day.length());
			date.append(day);
		}
		if (!brief || date.length() != 0 || Month != 0) {
			String month = String.valueOf(Month);
			temp.append('-');
			appendChars(temp, '0', 2 - month.length());
			temp.append(month);
			date.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}

		String year = String.valueOf(Year);
		appendChars(temp, '0', 4 - year.length());
		temp.append(year);
		date.insert(0, temp.toString());
		temp.delete(0, temp.length());

		if (!brief || time.length() != 0) {
			date.append('T');
			date.append(time.toString());
			date.append(timezone.toString());
		}
		return date.toString();
	}

	@Override
	public String toString() {
		return getDateTime(false);
	}

	private static final int[] DAYS_IN_MONTHS = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	private int daysInMonth(int month, int year) {
		--month;
		while (month > 11) month -= 12;
		while (month < 0) month += 12;
		if (month == 1 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) {
			return DAYS_IN_MONTHS[1] + 1;
		}
		return DAYS_IN_MONTHS[month];
	}

	public int compareTo(ATOMDateConstruct date) {
		int dateYear = date.Year;
		int dateMonth = date.Month;
		int dateDay = date.Day;
		int dateHour = date.Hour;
		int dateMinutes = date.Minutes;
		if (TZHour != date.TZHour || TZMinutes != date.TZMinutes) {
			dateMinutes += TZMinutes - date.TZMinutes;
			while (dateMinutes < 0) { dateMinutes += 60; --dateHour; }
			while (dateMinutes > 59) { dateMinutes -= 60; ++dateHour; }
			dateHour += TZHour - date.TZHour;
			while (dateHour < 0) { dateHour += 24; --dateDay; }
			while (dateHour > 23) { dateHour -= 24; ++dateDay; }
			while (dateDay < 1) dateDay += daysInMonth(--dateMonth, dateYear);
			while (dateDay > daysInMonth(dateMonth, dateYear)) dateDay -= daysInMonth(dateMonth++, dateYear);
			while (dateMonth < 1) { dateMonth += 12; --dateYear; }
			while (dateMonth > 12) { dateMonth -= 12; ++dateYear; }
		}
		if (Year != dateYear) return Year - dateYear;
		if (Month != dateMonth) return Month - dateMonth;
		if (Day != dateDay) return Day - dateDay;
		if (Hour != dateHour) return Hour - dateHour;
		if (Minutes != dateMinutes) return Minutes - dateMinutes;
		if (Seconds != date.Seconds) return Seconds - date.Seconds;
		return Math.round(100 * SecondFraction) - Math.round(100 * date.SecondFraction);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof ATOMDateConstruct)) {
			return false;
		}
		return compareTo((ATOMDateConstruct) obj) == 0;
	}
};

",True,95,8,33,3,1,5,1,L6
132,org.geometerplus.fbreader.network.atom.ATOMUpdated.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMUpdated extends ATOMDateConstruct {

	public ATOMUpdated() {
	}

	public ATOMUpdated(int year) {
		super(year);
	}

	public ATOMUpdated(int year, int month, int day) {
		super(year, month, day);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
}
",False,93,7,33,4,1,5,1,L6
133,org.geometerplus.fbreader.network.atom.ATOMLink.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


public class ATOMLink extends ATOMCommonAttributes {

	public static final String HREF = ""href"";
	public static final String REL = ""rel"";
	public static final String TYPE = ""type"";
	public static final String HREFLANG = ""hreflang"";
	public static final String TITLE = ""title"";
	public static final String LENGTH = ""length"";

	@Override
	public void readAttributes(ZLStringMap source) {
		super.readAttributes(source);
		readAttribute(HREF, source);
		readAttribute(REL, source);
		readAttribute(TYPE, source);
		readAttribute(HREFLANG, source);
		readAttribute(TITLE, source);
		readAttribute(LENGTH, source);
	}

	public final String getHref() {
		return getAttribute(HREF);
	}

	public final String getRel() {
		return getAttribute(REL);
	}

	public final String getType() {
		return getAttribute(TYPE);
	}

	public final String getHrefLang() {
		return getAttribute(HREFLANG);
	}

	public final String getTitle() {
		return getAttribute(TITLE);
	}

	public final String getLength() {
		return getAttribute(LENGTH);
	}
}
",False,93,8,33,2,2,7,2,L6
134,org.geometerplus.fbreader.network.atom.ATOMGenerator.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


public class ATOMGenerator extends ATOMCommonAttributes {

	public static final String URI = ""uri"";
	public static final String VERSION = ""version"";

	public String Text;

	@Override
	public void readAttributes(ZLStringMap source) {
		super.readAttributes(source);
		readAttribute(URI, source);
		readAttribute(VERSION, source);
	}

	public final String getUri() {
		return getAttribute(URI);
	}

	public final String getVersion() {
		return getAttribute(VERSION);
	}
}
",False,4,0,0,2,2,0,2,L8
135,org.geometerplus.fbreader.network.atom.ATOMIcon.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMIcon extends ATOMCommonAttributes {

	public String Uri;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,90,9,33,3,1,3,1,L6
136,org.geometerplus.fbreader.network.atom.ATOMId.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMId extends ATOMCommonAttributes {

	public String Uri;

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof ATOMId)) {
			return false;
		}
		ATOMId id = (ATOMId) o;
		return Uri.equals(id.Uri);
	}

	@Override
	public int hashCode() {
		return Uri.hashCode();
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,92,8,33,3,1,5,1,L6
137,org.geometerplus.fbreader.network.atom.ATOMEntry.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import java.util.*;


public class ATOMEntry extends ATOMCommonAttributes {

	public ATOMId Id;

	public LinkedList<ATOMAuthor> Authors = new LinkedList<ATOMAuthor>();
	public LinkedList<ATOMCategory> Categories = new LinkedList<ATOMCategory>();
	public LinkedList<ATOMContributor> Contributors = new LinkedList<ATOMContributor>();
	public LinkedList<ATOMLink> Links = new LinkedList<ATOMLink>();
	public ATOMPublished Published;
	//public String Rights;  // TODO: implement ATOMTextConstruct
	//public final ATOMSource Source; // TODO: implement ATOMSource
	public String Summary; // TODO: implement ATOMTextConstruct
	public String Content; // TODO: implement ATOMContent
	public String Title;   // TODO: implement ATOMTextConstruct
	public ATOMUpdated Updated;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["")
			.append(super.toString())
			.append("",\nId="").append(Id)
			.append("",\nAuthors:[\n"");

		boolean first = true;
		for (ATOMAuthor author: Authors) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(author.toString());
		}
		buf.append(""],\nCategories:[\n"");
		first = true;
		for (ATOMCategory category: Categories) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(category.toString());
		}
		buf.append(""],\nLinks:[\n"");
		first = true;
		for (ATOMLink link: Links) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(link.toString());
		}
		return buf
			.append(""]"")
			.append("",\nPublished="").append(Published)
			//.append("",\nRights="").append(Rights)
			.append("",\nSummary="").append(Summary)
			.append("",\nTitle="").append(Title)
			.append("",\nUpdated="").append(Updated)
			.append(""]"")
			.toString();
	}
}
",False,98,8,33,3,9,4,9,L6
138,org.geometerplus.fbreader.network.atom.ATOMPublished.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMPublished extends ATOMDateConstruct {

	public ATOMPublished() {
	}

	public ATOMPublished(int year) {
		super(year);
	}

	public ATOMPublished(int year, int month, int day) {
		super(year, month, day);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
}
",False,91,9,33,4,1,2,1,L6
139,org.geometerplus.fbreader.network.atom.ATOMCommonAttributes.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


abstract class ATOMCommonAttributes {
	public static final String XML_BASE = ""xml:base"";
	public static final String XML_LANG = ""xml:lang"";

	private ZLStringMap myAttributes;

	public void readAttributes(ZLStringMap source) {
		readAttribute(XML_BASE, source);
		readAttribute(XML_LANG, source);
	}

	protected final void readAttribute(String name, ZLStringMap source) {
		String value = source.getValue(name);
		if (value != null) {
			value = value.trim().intern();
			if (value.length() > 0) {
				if (myAttributes == null) {
					myAttributes = new ZLStringMap();
				}
				myAttributes.put(name, value);
			}
		}
	}

	public final String getAttribute(String name) {
		if (myAttributes == null) {
			return null;
		}
		return myAttributes.getValue(name);
	}

	public final String getLang() {
		return getAttribute(XML_LANG);
	}

	public final String getBase() {
		return getAttribute(XML_BASE);
	}

	// FIXME: HACK: addAttribute is used ONLY to add OPDSPrice to the ATOMLink... Must be killed + SEE NetworkOPDSFeedReader
	// name and value MUST BE not null AND MUST BE INTERNED String objects
	public void addAttribute(String name, String value) {
		if (value != null) {
			value = value.trim().intern();
			if (value.length() > 0) {
				if (myAttributes == null) {
					myAttributes = new ZLStringMap();
				}
				myAttributes.put(name, value);
			}
		}
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""[Attributes:\n"");
		if (myAttributes != null) {
			for (int i = 0; i < myAttributes.getSize(); ++i) {
				String key = myAttributes.getKey(i);
				String value = myAttributes.getValue(key);
				if (i != 0) {
					buf.append("",\n"");
				}
				buf.append(key).append(""="").append(value);
			}
		}
		buf.append(""]"");
		return buf.toString();
	}
}
",False,105,9,33,2,1,12,1,L1
140,org.geometerplus.fbreader.network.atom.ATOMConstants.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public interface ATOMConstants {

	String TYPE_TEXT = ""text"";
	String TYPE_HTML = ""html"";
	String TYPE_XHTML = ""xhtml"";
	String TYPE_DEFAULT = TYPE_TEXT;

	String REL_ALTERNATE = ""alternate"";
	String REL_RELATED = ""related"";
	String REL_SELF = ""self"";
	String REL_ENCLOSURE = ""enclosure"";
	String REL_VIA = ""via"";
}
",False,113,10,33,0,0,2,0,L6
141,org.geometerplus.fbreader.network.atom.ATOMFeedMetadata.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import java.util.*;


public class ATOMFeedMetadata extends ATOMCommonAttributes {

	public ATOMId Id;

	public LinkedList<ATOMAuthor> Authors = new LinkedList<ATOMAuthor>();
	public LinkedList<ATOMCategory> Categories = new LinkedList<ATOMCategory>();
	//public LinkedList<ATOMContributor> Contributors = new LinkedList<ATOMContributor>();
	//public ATOMGenerator Generator;
	public ATOMIcon Icon;
	public LinkedList<ATOMLink> Links = new LinkedList<ATOMLink>();
	//public ATOMLogo Logo;
	//public String Rights;   // TODO: implement ATOMTextConstruct
	public String Subtitle; // TODO: implement ATOMTextConstruct
	public String Title;    // TODO: implement ATOMTextConstruct
	public ATOMUpdated Updated;
}
",False,97,8,33,3,7,5,7,L6
142,org.geometerplus.fbreader.network.atom.ATOMCategory.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


public class ATOMCategory extends ATOMCommonAttributes {

	public static final String TERM = ""term"";
	public static final String SCHEME = ""scheme"";
	public static final String LABEL = ""label"";

	@Override
	public void readAttributes(ZLStringMap source) {
		super.readAttributes(source);
		readAttribute(TERM, source);
		readAttribute(SCHEME, source);
		readAttribute(LABEL, source);
	}

	public final String getTerm() {
		return getAttribute(TERM);
	}

	public final String getScheme() {
		return getAttribute(SCHEME);
	}

	public final String getLabel() {
		return getAttribute(LABEL);
	}
}
",False,92,9,33,2,2,4,2,L6
143,org.geometerplus.fbreader.network.atom.ATOMAuthor.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMAuthor extends ATOMPersonConstruct {
}
",False,93,9,33,4,1,4,1,L6
144,org.geometerplus.fbreader.network.atom.ATOMContributor.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMContributor extends ATOMPersonConstruct {
}
",False,91,9,33,4,1,1,1,L6
145,org.geometerplus.fbreader.network.atom.ATOMLogo.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMLogo extends ATOMCommonAttributes {

	public String Uri;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,4,0,0,3,1,0,1,L8
146,org.geometerplus.fbreader.network.atom.ATOMPersonConstruct.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

abstract class ATOMPersonConstruct extends ATOMCommonAttributes {

	public String Name;
	public String Uri;
	public String Email;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nName="").append(Name);
		buf.append("",\nUri="").append(Uri);
		buf.append("",\nEmail="").append(Email);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,94,9,33,3,1,5,1,L6
147,org.geometerplus.fbreader.network.opds.RelationAlias.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

class RelationAlias implements Comparable<RelationAlias> {
	final String Alias;
	final String Type;

	// `alias` and `type` parameters must be either null or interned String.
	RelationAlias(String alias, String type) {
		Alias = alias;
		Type = type;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof RelationAlias)) {
			return false;
		}
		RelationAlias r = (RelationAlias) o;
		return Alias == r.Alias && Type == r.Type;
	}

	@Override
	public int hashCode() {
		return (Alias == null ? 0 : Alias.hashCode()) +
			(Type == null ? 0 : Type.hashCode());
	}

	public int compareTo(RelationAlias r) {
		if (Alias != r.Alias) {
			if (Alias == null) {
				return -1;
			} else if (r.Alias == null) {
				return 1;
			}
			return Alias.compareTo(r.Alias);
		}
		if (Type != r.Type) {
			if (Type == null) {
				return -1;
			} else if (r.Type == null) {
				return 1;
			}
			return Type.compareTo(r.Type);
		}
		return 0;
	}

	@Override
	public String toString() {
		return ""Alias("" + Alias + ""; "" + Type + "")"";
	}
}

",True,83,8,33,0,0,2,0,L6
148,org.geometerplus.fbreader.network.opds.OpenSearchDescription.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

class OpenSearchDescription {

	public static OpenSearchDescription createDefault(String template) {
		return new OpenSearchDescription(template, 20, -1, -1);
	}

	public final String Template;
	public final int IndexOffset;
	public final int PageOffset;

	public final int ItemsPerPage;

	public OpenSearchDescription(String template, int itemsPerPage, int indexOffset, int pageOffset) {
		Template = template;
		IndexOffset = indexOffset;
		PageOffset = pageOffset;
		ItemsPerPage = itemsPerPage;
	}

	public boolean isValid() {
		return makeQuery("""") != null;
	}

	// searchTerms -- an HTML-encoded string
	public String makeQuery(String searchTerms) {
		final StringBuffer query = new StringBuffer();
		final Matcher m = Pattern.compile(""\\{(.*)\\}"").matcher(Template);
		while (m.find()) {
			String name = m.group(1);
			if (name == null || name.length() == 0 || name.contains("":"")) {
				return null;
			}
			final boolean optional = name.endsWith(""?"");
			if (optional) {
				name = name.substring(0, name.length() - 1);
			}
			name = name.intern();
			if (name == ""searchTerms"") {
				m.appendReplacement(query, searchTerms);
			} else if (name == ""count"") {
				if (ItemsPerPage > 0) {
					m.appendReplacement(query, String.valueOf(ItemsPerPage));
				} else if (optional) {
					m.appendReplacement(query, """");
				} else {
					return null;
				}
			} else if (optional) {
				m.appendReplacement(query, """");
			} else if (name == ""startIndex"") {
				if (IndexOffset > 0) {
					m.appendReplacement(query, String.valueOf(IndexOffset));
				} else {
					return null;
				}
			} else if (name == ""startPage"") {
				if (PageOffset > 0) {
					m.appendReplacement(query, String.valueOf(PageOffset));
				} else {
					return null;
				}
			} else if (name == ""language"") {
				m.appendReplacement(query, ZLNetworkUtil.htmlEncode(""*""));
			} else if (name == ""inputEncoding"" || name == ""outputEncoding"") {
				m.appendReplacement(query, ""UTF-8"");
			} else {
				return null;
			}
		}
		m.appendTail(query);
		return query.toString();
	}
}
",True,103,8,33,8,6,4,1,L6
149,org.geometerplus.fbreader.network.opds.OPDSCatalogItem.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.Map;
import java.util.HashSet;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;

import org.geometerplus.fbreader.network.*;

class OPDSCatalogItem extends NetworkCatalogItem {

	static class State extends NetworkOperationData {
		public String LastLoadedId;
		public final HashSet<String> LoadedIds = new HashSet<String>();

		public State(INetworkLink link, OnNewItemListener listener) {
			super(link, listener);
		}
	}
	private State myLoadingState;

	OPDSCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType) {
		super(link, title, summary, cover, urlByType);
	}

	OPDSCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, int visibility) {
		super(link, title, summary, cover, urlByType, visibility);
	}

	OPDSCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, int visibility, int catalogType) {
		super(link, title, summary, cover, urlByType, visibility, catalogType);
	}

	private String doLoadChildren(NetworkOperationData.OnNewItemListener listener,
			ZLNetworkRequest networkRequest) {
		while (networkRequest != null) {
			final String errorMessage = ZLNetworkManager.Instance().perform(networkRequest);
			if (errorMessage != null) {
				myLoadingState = null;
				return errorMessage;
			}
			if (listener.confirmInterrupt()) {
				return null;
			}
			networkRequest = myLoadingState.resume();
		}
		return null;
	}

	@Override
	public final String loadChildren(NetworkOperationData.OnNewItemListener listener) {
		OPDSNetworkLink opdsLink = (OPDSNetworkLink) Link;

		myLoadingState = opdsLink.createOperationData(Link, listener);

		ZLNetworkRequest networkRequest =
			opdsLink.createNetworkData(URLByType.get(URL_CATALOG), myLoadingState);

		return doLoadChildren(listener, networkRequest);
	}

	@Override
	public final boolean supportsResumeLoading() {
		return true;
	}

	@Override
	public final String resumeLoading(NetworkOperationData.OnNewItemListener listener) {
		if (myLoadingState == null) {
			return null;
		}
		myLoadingState.Listener = listener;
		ZLNetworkRequest networkRequest = myLoadingState.resume();
		return doLoadChildren(listener, networkRequest);
	}
}
",False,190,0,0,13,36,2,7,L6
150,org.geometerplus.fbreader.network.opds.OPDSNetworkLink.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;
import java.net.URLConnection;
import java.io.InputStream;
import java.io.IOException;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class OPDSNetworkLink extends AbstractNetworkLink {

	public interface FeedCondition {
		int REGULAR = 0;
		int NEVER = 1;
		int SIGNED_IN = 2;
	}

	private TreeMap<RelationAlias, String> myRelationAliases;

	private TreeMap<String, Integer> myUrlConditions;
	private LinkedList<URLRewritingRule> myUrlRewritingRules;
	private NetworkAuthenticationManager myAuthenticationManager;

	private final boolean myHasStableIdentifiers;

	OPDSNetworkLink(String siteName, String title, String summary, String icon,
			Map<String, String> links, boolean hasStableIdentifiers) {
		super(siteName, title, summary, icon, links);
		myHasStableIdentifiers = hasStableIdentifiers;
	}

	final void setRelationAliases(Map<RelationAlias, String> relationAliases) {
		if (relationAliases != null && relationAliases.size() > 0) {
			myRelationAliases = new TreeMap<RelationAlias, String>(relationAliases);
		} else {
			myRelationAliases = null;
		}
	}

	final void setUrlConditions(Map<String, Integer> conditions) {
		if (conditions != null && conditions.size() > 0) {
			myUrlConditions = new TreeMap<String, Integer>(conditions);
		} else {
			myUrlConditions = null;
		}
	}

	final void setUrlRewritingRules(List<URLRewritingRule> rules) {
		if (rules != null && rules.size() > 0) {
			myUrlRewritingRules = new LinkedList<URLRewritingRule>(rules);
		} else {
			myUrlRewritingRules = null;
		}
	}

	final void setAuthenticationManager(NetworkAuthenticationManager mgr) {
		myAuthenticationManager = mgr;
	}

	ZLNetworkRequest createNetworkData(String url, final OPDSCatalogItem.State result) {
		if (url == null) {
			return null;
		}
		url = rewriteUrl(url, false);
		return new ZLNetworkRequest(url) {
			@Override
			public String handleStream(URLConnection connection, InputStream inputStream) throws IOException {
				if (result.Listener.confirmInterrupt()) {
					return null;
				}

				new OPDSXMLReader(
					new NetworkOPDSFeedReader(URL, result)
				).read(inputStream);

				if (result.Listener.confirmInterrupt()) {
					if (!myHasStableIdentifiers && result.LastLoadedId != null) {
						// If current catalog doesn't have stable identifiers
						// and catalog wasn't completely loaded (i.e. LastLoadedIdentifier is not null)
						// then reset state to load current page from the beginning 
						result.LastLoadedId = null;
					} else {
						result.Listener.commitItems(OPDSNetworkLink.this);
					}
				} else {
					result.Listener.commitItems(OPDSNetworkLink.this);
				}
				return null;
			}
		};
	}

	private final String searchURL(String query) {
		return getLink(URL_SEARCH).replace(""%s"", query);
	}

	@Override
	public OPDSCatalogItem.State createOperationData(INetworkLink link,
			NetworkOperationData.OnNewItemListener listener) {
		return new OPDSCatalogItem.State(link, listener);
	}

	public ZLNetworkRequest simpleSearchRequest(String pattern, NetworkOperationData data) {
		if (getLink(URL_SEARCH) == null) {
			return null;
		}
		return createNetworkData(
			searchURL(ZLNetworkUtil.htmlEncode(pattern)),
			(OPDSCatalogItem.State) data
		);
	}

	public ZLNetworkRequest resume(NetworkOperationData data) {
		return createNetworkData(data.ResumeURI, (OPDSCatalogItem.State) data);
	}

	public NetworkLibraryItem libraryItem() {
		TreeMap<Integer, String> urlMap = new TreeMap<Integer, String>();
		urlMap.put(NetworkCatalogItem.URL_CATALOG, getLink(URL_MAIN));
		return new OPDSCatalogItem(this, getTitle(), getSummary(), getIcon(), urlMap);
	}

	public NetworkAuthenticationManager authenticationManager() {
		return myAuthenticationManager;
	}

	public String rewriteUrl(String url, boolean isUrlExternal) {
		if (myUrlRewritingRules == null) {
			return url;
		}
		for (URLRewritingRule rule: myUrlRewritingRules) {
			if (rule.Apply != URLRewritingRule.APPLY_ALWAYS) {
				if ((rule.Apply == URLRewritingRule.APPLY_EXTERNAL && !isUrlExternal)
					|| (rule.Apply == URLRewritingRule.APPLY_INTERNAL && isUrlExternal)) {
					continue;
				}
			}
			switch (rule.Type) {
			case URLRewritingRule.ADD_URL_PARAMETER:
				url = ZLNetworkUtil.appendParameter(url, rule.Name, rule.Value);
				break;
			}
		}
		return url;
	}

	int getCondition(String url) {
		if (myUrlConditions == null) {
			return FeedCondition.REGULAR;
		}
		Integer cond = myUrlConditions.get(url);
		if (cond == null) {
			return FeedCondition.REGULAR;
		}
		return cond.intValue();
	}

	// rel and type must be either null or interned String objects.
	String relation(String rel, String type) {
		if (myRelationAliases == null) {
			return rel;
		}
		RelationAlias alias = new RelationAlias(rel, type);
		String mapped = myRelationAliases.get(alias);
		if (mapped != null) {
			return mapped;
		}
		if (type != null) {
			alias = new RelationAlias(rel, null);
			mapped = myRelationAliases.get(alias);
			if (mapped != null) {
				return mapped;
			}
		}
		return rel;
	}

	@Override
	public String toString() {
		return ""OPDSNetworkLink: {super="" + super.toString()
			+ ""; stableIds="" + myHasStableIdentifiers
			+ ""; authManager="" + (myAuthenticationManager != null ? myAuthenticationManager.getClass().getName() : null)
			+ ""; relationAliases="" + myRelationAliases
			+ ""; urlConditions="" + myUrlConditions
			+ ""; rewritingRules="" + myUrlRewritingRules
			+ ""}"";
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof OPDSNetworkLink)) {
			return false;
		}
		if (!super.equals(o)) {
			return false;
		}
		final OPDSNetworkLink lnk = (OPDSNetworkLink) o;
		if (myHasStableIdentifiers != lnk.myHasStableIdentifiers
				|| !ZLMiscUtil.mapsEquals(myRelationAliases, lnk.myRelationAliases)
				|| !ZLMiscUtil.mapsEquals(myUrlConditions, lnk.myUrlConditions)
				|| !ZLMiscUtil.listsEquals(myUrlRewritingRules, lnk.myUrlRewritingRules)
				|| myAuthenticationManager != lnk.myAuthenticationManager) {
			return false;
		}
		return true;
	}
}
",True,269,8,33,12,38,5,15,L6
151,org.geometerplus.fbreader.network.opds.NetworkOPDSFeedReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.atom.*;
import org.geometerplus.fbreader.network.authentication.litres.LitResBookshelfItem;


class NetworkOPDSFeedReader implements OPDSFeedReader {

	private final String myBaseURL;
	private final OPDSCatalogItem.State myData;

	private int myIndex;

	private String myNextURL;
	private String mySkipUntilId;
	private boolean myFoundNewIds;

	private int myItemsToLoad = -1;

	/**
	 * Creates new OPDSFeedReader instance that can be used to get NetworkLibraryItem objects from OPDS feeds.
	 *
	 * @param baseURL    string that contains URL of the OPDS feed, that will be read using this instance of the reader
	 * @param result     network results buffer. Must be created using OPDSNetworkLink corresponding to the OPDS feed, 
	 *                   that will be read using this instance of the reader.
	 */
	NetworkOPDSFeedReader(String baseURL, OPDSCatalogItem.State result) {
		myBaseURL = baseURL;
		myData = result;
		mySkipUntilId = myData.LastLoadedId;
		myFoundNewIds = mySkipUntilId != null;
		if (!(result.Link instanceof OPDSNetworkLink)) {
			throw new IllegalArgumentException(""Parameter `result` has invalid `Link` field value: result.Link must be an instance of OPDSNetworkLink class."");
		}
	}

	public void processFeedStart() {
		myData.ResumeURI = myBaseURL;
	}

	public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
		if (beforeEntries) {
			myIndex = feed.OpensearchStartIndex - 1;
			if (feed.OpensearchItemsPerPage > 0) {
				myItemsToLoad = feed.OpensearchItemsPerPage;
				final int len = feed.OpensearchTotalResults - myIndex;
				if (len > 0 && len < myItemsToLoad) {
					myItemsToLoad = len;
				}
			}
			return false;
		}
		final OPDSNetworkLink opdsLink = (OPDSNetworkLink) myData.Link;
		for (ATOMLink link: feed.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (OPDSConstants.MIME_APP_ATOM.equals(type) && ""next"".equals(rel)) {
				myNextURL = ZLNetworkUtil.url(myBaseURL, link.getHref());
			}
		}
		return false;
	}

	public void processFeedEnd() {
		if (mySkipUntilId != null) {
			// Last loaded element was not found => resume error => DO NOT RESUME
			// TODO: notify user about error???
			// TODO: do reload???
			myNextURL = null;
		}
		myData.ResumeURI = myFoundNewIds ? myNextURL : null;
		myData.LastLoadedId = null;
	}


	// returns BookReference.Format value for specified String. String MUST BE interned.
	private static int formatByMimeType(String mimeType) {
		if (OPDSConstants.MIME_APP_FB2ZIP.equals(mimeType)) {
			return BookReference.Format.FB2_ZIP;
		} else if (OPDSConstants.MIME_APP_EPUB.equals(mimeType)) {
			return BookReference.Format.EPUB;
		} else if (OPDSConstants.MIME_APP_MOBI.equals(mimeType)) {
			return BookReference.Format.MOBIPOCKET;
		}
		return BookReference.Format.NONE;
	}

	// returns BookReference.Type value for specified String. String MUST BE interned.
	private static int typeByRelation(String rel) {
		if (rel == null || OPDSConstants.REL_ACQUISITION.equals(rel)
				|| OPDSConstants.REL_ACQUISITION_OPEN.equals(rel)) {
			return BookReference.Type.DOWNLOAD_FULL;
		} else if (OPDSConstants.REL_ACQUISITION_SAMPLE.equals(rel)) {
			return BookReference.Type.DOWNLOAD_DEMO;
		} else if (OPDSConstants.REL_ACQUISITION_CONDITIONAL.equals(rel)) {
			return BookReference.Type.DOWNLOAD_FULL_CONDITIONAL;
		} else if (OPDSConstants.REL_ACQUISITION_SAMPLE_OR_FULL.equals(rel)) {
			return BookReference.Type.DOWNLOAD_FULL_OR_DEMO;
		} else if (OPDSConstants.REL_ACQUISITION_BUY.equals(rel)) {
			return BookReference.Type.BUY;
		} else {
			return BookReference.Type.UNKNOWN;
		}
	}

	private boolean tryInterrupt() {
		final int noninterruptableRemainder = 10;
		return (myItemsToLoad < 0 || myItemsToLoad > noninterruptableRemainder)
				&& myData.Listener.confirmInterrupt();
	}

	private String calculateEntryId(OPDSEntry entry) {
		if (entry.Id != null) {
			return entry.Id.Uri;
		}

		String id = null;
		int idType = 0;

		final OPDSNetworkLink opdsLink = (OPDSNetworkLink) myData.Link;
		for (ATOMLink link: entry.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);

			if (rel == null && OPDSConstants.MIME_APP_ATOM.equals(type)) {
				return ZLNetworkUtil.url(myBaseURL, link.getHref());
			}
			int relType = BookReference.Format.NONE;
			if (rel == null || rel.startsWith(OPDSConstants.REL_ACQUISITION_PREFIX)
					|| rel.startsWith(OPDSConstants.REL_FBREADER_ACQUISITION_PREFIX)) {
				relType = formatByMimeType(type);
			}
			if (relType != BookReference.Format.NONE
					&& (id == null || idType < relType
							|| (idType == relType && OPDSConstants.REL_ACQUISITION.equals(rel)))) {
				id = ZLNetworkUtil.url(myBaseURL, link.getHref());
				idType = relType;
			}
		}
		return id;
	}

	public boolean processFeedEntry(OPDSEntry entry) {
		if (myItemsToLoad >= 0) {
			--myItemsToLoad;
		}

		if (entry.Id == null) {
			final String id = calculateEntryId(entry);
			if (id == null) {
				return tryInterrupt();
			}
			entry.Id = new ATOMId();
			entry.Id.Uri = id;
		}

		if (mySkipUntilId != null) {
			if (mySkipUntilId.equals(entry.Id.Uri)) {
				mySkipUntilId = null;
			}
			return tryInterrupt();
		}
		myData.LastLoadedId = entry.Id.Uri;
		if (!myFoundNewIds && !myData.LoadedIds.contains(entry.Id.Uri)) {
			myFoundNewIds = true;
		}
		myData.LoadedIds.add(entry.Id.Uri);

		final OPDSNetworkLink opdsLink = (OPDSNetworkLink) myData.Link;
		if (opdsLink.getCondition(entry.Id.Uri) == OPDSNetworkLink.FeedCondition.NEVER) {
			return tryInterrupt();
		}
		boolean hasBookLink = false;
		for (ATOMLink link: entry.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (rel == null
					? (formatByMimeType(type) != BookReference.Format.NONE)
					: (rel.startsWith(OPDSConstants.REL_ACQUISITION_PREFIX)
							|| rel.startsWith(OPDSConstants.REL_FBREADER_ACQUISITION_PREFIX))) {
				hasBookLink = true;
				break;
			}
		}

		NetworkLibraryItem item;
		if (hasBookLink) {
			item = readBookItem(entry);
		} else {
			item = readCatalogItem(entry);
		}
		if (item != null) {
			myData.Listener.onNewItem(myData.Link, item);
		}
		return tryInterrupt();
	}

	private static final String AuthorPrefix = ""author:"";
	private static final String AuthorsPrefix = ""authors:"";

	private NetworkLibraryItem readBookItem(OPDSEntry entry) {
		final OPDSNetworkLink opdsNetworkLink = (OPDSNetworkLink) myData.Link;
		/*final String date;
		if (entry.DCIssued != null) {
			date = entry.DCIssued.getDateTime(true);
		} else {
			date = null;
		}*/

		final LinkedList<String> tags = new LinkedList<String>();
		for (ATOMCategory category: entry.Categories) {
			String term = category.getTerm();
			if (term != null) {
				tags.add(term);
			}
		}

		String cover = null;
		LinkedList<BookReference> references = new LinkedList<BookReference>();
		for (ATOMLink link: entry.Links) {
			final String href = ZLNetworkUtil.url(myBaseURL, link.getHref());
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsNetworkLink.relation(link.getRel(), type);
			final int referenceType = typeByRelation(rel);
			if (OPDSConstants.REL_IMAGE_THUMBNAIL.equals(rel)
					|| OPDSConstants.REL_THUMBNAIL.equals(rel)) {
				if (NetworkImage.MIME_PNG.equals(type) ||
						NetworkImage.MIME_JPEG.equals(type)) {
					cover = href;
				}
			} else if ((rel != null && rel.startsWith(OPDSConstants.REL_IMAGE_PREFIX))
					|| OPDSConstants.REL_COVER.equals(rel)) {
				if (cover == null &&
						(NetworkImage.MIME_PNG.equals(type) ||
						 NetworkImage.MIME_JPEG.equals(type))) {
					cover = href;
				}
			} else if (BookReference.Type.BUY == referenceType) {
				final OPDSLink opdsLink = (OPDSLink) link; 
				String price = null;
				final OPDSPrice opdsPrice = opdsLink.selectBestPrice();
				if (opdsPrice != null) {
					price = BuyBookReference.price(opdsPrice.Price, opdsPrice.Currency);
				}
				if (price == null) {
					// FIXME: HACK: price handling must be implemented not through attributes!!!
					price = BuyBookReference.price(entry.getAttribute(OPDSXMLReader.KEY_PRICE), null);
				}
				if (price == null) {
					price = """";
				}
				if (OPDSConstants.MIME_TEXT_HTML.equals(type)) {
					collectReferences(references, opdsLink, href,
							BookReference.Type.BUY_IN_BROWSER, price, true);
				} else {
					collectReferences(references, opdsLink, href,
							BookReference.Type.BUY, price, false);
				}
			} else if (referenceType != BookReference.Type.UNKNOWN) {
				final int format = formatByMimeType(type);
				if (format != BookReference.Format.NONE) {
					references.add(new BookReference(href, format, referenceType));
				}
			}
		}

		LinkedList<NetworkBookItem.AuthorData> authors = new LinkedList<NetworkBookItem.AuthorData>();
		for (ATOMAuthor author: entry.Authors) {
			String name = author.Name;
			final String lowerCased = name.toLowerCase();
			int index = lowerCased.indexOf(AuthorPrefix);
			if (index != -1) {
				name = name.substring(index + AuthorPrefix.length());
			} else {
				index = lowerCased.indexOf(AuthorsPrefix);
				if (index != -1) {
					name = name.substring(index + AuthorsPrefix.length());
				}
			}
			index = name.indexOf(',');
			NetworkBookItem.AuthorData authorData;
			if (index != -1) {
				final String before = name.substring(0, index).trim();
				final String after = name.substring(index + 1).trim();
				authorData = new NetworkBookItem.AuthorData(after + ' ' + before, before);
			} else {
				name = name.trim();
				index = name.lastIndexOf(' ');
				authorData = new NetworkBookItem.AuthorData(name, name.substring(index + 1));
			}
			authors.add(authorData);
		}

		//entry.dcPublisher();
		//entry.updated();
		//entry.published();
		/*for (size_t i = 0; i < entry.contributors().size(); ++i) {
			ATOMContributor &contributor = *(entry.contributors()[i]);
			std::cerr << ""\t\t<contributor>"" << std::endl;
			std::cerr << ""\t\t\t<name>""  << contributor.name()  << ""</name>""  << std::endl;
			if (!contributor.uri().empty())   std::cerr << ""\t\t\t<uri>""   << contributor.uri()   << ""</uri>""   << std::endl;
			if (!contributor.email().empty()) std::cerr << ""\t\t\t<email>"" << contributor.email() << ""</email>"" << std::endl;
			std::cerr << ""\t\t</contributor>"" << std::endl;
		}*/
		//entry.rights();

		final String annotation;
		if (entry.Summary != null) {
			annotation = entry.Summary;
		} else if (entry.Content != null) {
			annotation = entry.Content;
		} else {
			annotation = null;
		}

		return new NetworkBookItem(
			opdsNetworkLink,
			entry.Id.Uri,
			myIndex++,
			entry.Title,
			annotation,
			//entry.DCLanguage,
			//date,
			authors,
			tags,
			entry.SeriesTitle,
			entry.SeriesIndex,
			cover,
			references
		);
	}

	private void collectReferences(LinkedList<BookReference> references,
			OPDSLink opdsLink, String href, int type, String price, boolean addWithoutFormat) {
		boolean added = false;
		for (String mime: opdsLink.Formats) {
			final int format = formatByMimeType(mime);
			if (format != BookReference.Format.NONE) {
				references.add(new BuyBookReference(
					href, format, type, price
				));
				added = true;
			}
		}
		if (!added && addWithoutFormat) {
			references.add(new BuyBookReference(
				href, BookReference.Format.NONE, type, price
			));
		}
	}

	private NetworkLibraryItem readCatalogItem(OPDSEntry entry) {
		final OPDSNetworkLink opdsLink = (OPDSNetworkLink) myData.Link;
		String coverURL = null;
		String url = null;
		boolean urlIsAlternate = false;
		String htmlURL = null;
		boolean litresCatalogue = false;
		int catalogType = NetworkCatalogItem.CATALOG_OTHER;
		for (ATOMLink link: entry.Links) {
			final String href = ZLNetworkUtil.url(myBaseURL, link.getHref());
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (NetworkImage.MIME_PNG.equals(type) ||
					NetworkImage.MIME_JPEG.equals(type)) {
				if (OPDSConstants.REL_IMAGE_THUMBNAIL.equals(rel) ||
						OPDSConstants.REL_THUMBNAIL.equals(rel) ||
						(coverURL == null && (OPDSConstants.REL_COVER.equals(rel) || 
								(rel != null && rel.startsWith(OPDSConstants.REL_IMAGE_PREFIX))))) {
					coverURL = href;
				}
			} else if (OPDSConstants.MIME_APP_ATOM.equals(type)) {
				if (ATOMConstants.REL_ALTERNATE.equals(rel)) {
					if (url == null) {
						url = href;
						urlIsAlternate = true;
					}
				} else if (url == null
						|| rel == null || rel.equals(OPDSConstants.REL_SUBSECTION)) {
					url = href;
					urlIsAlternate = false;
					if (OPDSConstants.REL_CATALOG_AUTHOR.equals(rel)) {
						catalogType = NetworkCatalogItem.CATALOG_BY_AUTHORS;
					}
				}
			} else if (OPDSConstants.MIME_TEXT_HTML.equals(type)) {
				if (OPDSConstants.REL_ACQUISITION.equals(rel) ||
						OPDSConstants.REL_ACQUISITION_OPEN.equals(rel) ||
						ATOMConstants.REL_ALTERNATE.equals(rel) ||
						rel == null) {
					htmlURL = href;
				}
			} else if (OPDSConstants.MIME_APP_LITRES.equals(type)) {
				if (OPDSConstants.REL_BOOKSHELF.equals(rel)) {
					litresCatalogue = true;
					url = href; // FIXME: mimeType ???
				}
			}
		}

		if (url == null && htmlURL == null) {
			return null;
		}

		if (url != null && !urlIsAlternate) {
			htmlURL = null;
		}

		final boolean dependsOnAccount =
			OPDSNetworkLink.FeedCondition.SIGNED_IN == opdsLink.getCondition(entry.Id.Uri);

		final String annotation;
		if (entry.Summary != null) {
			annotation = entry.Summary.replace(""\n"", """");
		} else if (entry.Content != null) {
			annotation = entry.Content.replace(""\n"", """");
		} else {
			annotation = null;
		}

		HashMap<Integer, String> urlMap = new HashMap<Integer, String>();
		if (url != null) {
			urlMap.put(NetworkCatalogItem.URL_CATALOG, url);
		}
		if (htmlURL != null) {
			urlMap.put(NetworkCatalogItem.URL_HTML_PAGE, htmlURL);
		}
		if (litresCatalogue) {
			return new LitResBookshelfItem(
				opdsLink,
				entry.Title,
				annotation,
				coverURL,
				urlMap,
				dependsOnAccount ? NetworkCatalogItem.VISIBLE_LOGGED_USER : NetworkCatalogItem.VISIBLE_ALWAYS
			);
		} else {
			return new OPDSCatalogItem(
				opdsLink,
				entry.Title,
				annotation,
				coverURL,
				urlMap,
				dependsOnAccount ? NetworkCatalogItem.VISIBLE_LOGGED_USER : NetworkCatalogItem.VISIBLE_ALWAYS,
				catalogType
			);
		}
	}
}
",False,190,0,0,12,28,1,26,L6
152,org.geometerplus.fbreader.network.opds.URLRewritingRule.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

class URLRewritingRule {

	// rule types:
	public static final int ADD_URL_PARAMETER = 0;

	// apply values:
	public static final int APPLY_ALWAYS = 0;
	public static final int APPLY_EXTERNAL = 1;
	public static final int APPLY_INTERNAL = 2;


	public final int Type;
	public final int Apply;
	public final String Name;
	public final String Value;

	public URLRewritingRule(int type, int apply, String name, String value) {
		Type = type;
		Apply = apply;
		Name = name;
		Value = value;
	}

	@Override
	public String toString() {
		return ""Rule: {type="" + Type
			+ ""; apply="" + Apply
			+ ""; name="" + Name
			+ ""; value="" + Value
			+ ""}"";
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof URLRewritingRule)) {
			return false;
		}
		final URLRewritingRule rule = (URLRewritingRule) o;
		if (Type != rule.Type
				|| Apply != rule.Apply
				|| !ZLMiscUtil.equals(Name, rule.Name)
				|| !ZLMiscUtil.equals(Value, rule.Value)) {
			return false;
		}
		return true;
	}
}
",False,84,8,33,1,1,2,1,L6
153,org.geometerplus.fbreader.network.opds.OPDSFeedMetadata.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.atom.*;

class OPDSFeedMetadata extends ATOMFeedMetadata {

	public int OpensearchTotalResults;
	public int OpensearchItemsPerPage;
	public int OpensearchStartIndex = 1;
}
",False,97,8,33,4,7,5,1,L6
154,org.geometerplus.fbreader.network.opds.OPDSXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.constants.XMLNamespace;

import org.geometerplus.fbreader.network.atom.*;


class OPDSXMLReader extends ZLXMLReaderAdapter {

	public static final String KEY_PRICE = ""price"";


	protected final OPDSFeedReader myFeedReader;

	private OPDSFeedMetadata myFeed;
	private OPDSEntry myEntry;

	private ATOMAuthor myAuthor;
	private ATOMId myId;
	private OPDSLink myLink;
	private ATOMCategory myCategory;
	private ATOMUpdated myUpdated;
	private ATOMPublished myPublished;
	private DCDate myDCIssued;
	private ATOMIcon myIcon;

	private String myPriceCurrency;

	//private ATOMTitle myTitle;      // TODO: implement ATOMTextConstruct & ATOMTitle
	//private ATOMSummary mySummary;  // TODO: implement ATOMTextConstruct & ATOMSummary


	public OPDSXMLReader(OPDSFeedReader feedReader) {
		myFeedReader = feedReader;
	}


	protected String myDublinCoreNamespaceId;
	protected String myAtomNamespaceId;
	protected String myOpenSearchNamespaceId;
	protected String myCalibreNamespaceId;
	protected String myOpdsNamespaceId;

	@Override
	public final boolean processNamespaces() {
		return true;
	}

	public static String intern(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		return str.intern();
	}

	@Override
	public void namespaceMapChangedHandler(HashMap<String,String> namespaceMap) {
		myDublinCoreNamespaceId = null;
		myAtomNamespaceId = null;
		myOpenSearchNamespaceId = null;
		myCalibreNamespaceId = null;
		myOpdsNamespaceId = null;

		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String value = entry.getValue();
			if (value == XMLNamespace.DublinCoreTerms) {
				myDublinCoreNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespace.Atom) {
				myAtomNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespace.OpenSearch) {
				myOpenSearchNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespace.CalibreMetadata) {
				myCalibreNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespace.Opds) {
				myOpdsNamespaceId = intern(entry.getKey());
			}
		}
	}


	protected static final int START = 0;
	protected static final int FEED = 1;
	protected static final int F_ENTRY = 2;
	protected static final int F_ID = 3;
	protected static final int F_LINK = 4;
	protected static final int F_CATEGORY = 5;
	protected static final int F_TITLE = 6;
	protected static final int F_UPDATED = 7;
	protected static final int F_AUTHOR = 8;
	protected static final int FA_NAME = 9;
	protected static final int FA_URI = 10;
	protected static final int FA_EMAIL = 11;
	protected static final int FE_AUTHOR = 12;
	protected static final int FE_ID = 13;
	protected static final int FE_CATEGORY = 14;
	protected static final int FE_LINK = 15;
	protected static final int FE_PUBLISHED = 16;
	protected static final int FE_SUMMARY = 17;
	protected static final int FE_CONTENT = 18;
	protected static final int FE_TITLE = 19;
	protected static final int FE_UPDATED = 20;
	protected static final int FE_DC_LANGUAGE = 21;
	protected static final int FE_DC_ISSUED = 22;
	protected static final int FE_DC_PUBLISHER = 23;
	protected static final int FE_CALIBRE_SERIES = 24;
	protected static final int FE_CALIBRE_SERIES_INDEX = 25;
	protected static final int FEL_PRICE = 26;
	protected static final int FEL_FORMAT = 27;
	protected static final int FEA_NAME = 28;
	protected static final int FEA_URI = 29;
	protected static final int FEA_EMAIL = 30;
	protected static final int OPENSEARCH_TOTALRESULTS = 31;
	protected static final int OPENSEARCH_ITEMSPERPAGE = 32;
	protected static final int OPENSEARCH_STARTINDEX = 33;
	protected static final int FEC_HACK_SPAN = 34;
	protected static final int F_SUBTITLE = 35;
	protected static final int F_ICON = 36;


	protected static final String TAG_FEED = ""feed"";
	protected static final String TAG_ENTRY = ""entry"";
	protected static final String TAG_AUTHOR = ""author"";
	protected static final String TAG_NAME = ""name"";
	protected static final String TAG_URI = ""uri"";
	protected static final String TAG_EMAIL = ""email"";
	protected static final String TAG_ID = ""id"";
	protected static final String TAG_CATEGORY = ""category"";
	protected static final String TAG_LINK = ""link"";
	protected static final String TAG_PUBLISHED = ""published"";
	protected static final String TAG_SUMMARY = ""summary"";
	protected static final String TAG_CONTENT = ""content"";
	protected static final String TAG_TITLE = ""title"";
	protected static final String TAG_UPDATED = ""updated"";
	protected static final String TAG_PRICE = ""price"";
	protected static final String TAG_SUBTITLE = ""subtitle"";
	protected static final String TAG_ICON = ""icon"";

	protected static final String TAG_HACK_SPAN = ""span"";

	protected static final String DC_TAG_LANGUAGE = ""language"";
	protected static final String DC_TAG_ISSUED = ""issued"";
	protected static final String DC_TAG_PUBLISHER = ""publisher"";
	protected static final String DC_TAG_FORMAT = ""format"";

	protected static final String CALIBRE_TAG_SERIES = ""series"";
	protected static final String CALIBRE_TAG_SERIES_INDEX = ""series_index"";

	protected static final String OPENSEARCH_TAG_TOTALRESULTS = ""totalResults"";
	protected static final String OPENSEARCH_TAG_ITEMSPERPAGE = ""itemsPerPage"";
	protected static final String OPENSEARCH_TAG_STARTINDEX = ""startIndex"";


	private int myState = START;

	private final StringBuffer myBuffer = new StringBuffer();
	private HtmlToString myHtmlToString = new HtmlToString();

	private boolean myFeedMetadataProcessed;

	protected final int getState() {
		return myState;
	}

	@Override
	public final boolean startElementHandler(String tag, ZLStringMap attributes) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}
		return startElementHandler(tagPrefix, tag, attributes, extractBufferContent());
	}

	@Override
	public final boolean endElementHandler(String tag) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}
		return endElementHandler(tagPrefix, tag, extractBufferContent());
	}

	private final String extractBufferContent() {
		final char[] bufferContentArray = myBuffer.toString().trim().toCharArray();
		myBuffer.delete(0, myBuffer.length());
		if (bufferContentArray.length == 0) {
			return null;
		}
		return new String(bufferContentArray);
	}

	public boolean startElementHandler(final String tagPrefix, final String tag,
			final ZLStringMap attributes, final String bufferContent) {
		boolean interruptReading = false;
		switch (myState) {
			case START:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_FEED) {
					myFeedReader.processFeedStart();
					myFeed = new OPDSFeedMetadata();
					myFeed.readAttributes(attributes);
					myState = FEED;
					myFeedMetadataProcessed = false;
				}
				break;
			case FEED:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_AUTHOR) {
						myAuthor = new ATOMAuthor();
						myAuthor.readAttributes(attributes);
						myState = F_AUTHOR;
					} else if (tag == TAG_ID) {
						myId = new ATOMId();
						myId.readAttributes(attributes);
						myState = F_ID;
					} else if (tag == TAG_ICON) {
						myIcon = new ATOMIcon();
						myIcon.readAttributes(attributes);
						myState = F_ICON;
					} else if (tag == TAG_LINK) {
						myLink = new OPDSLink();
						myLink.readAttributes(attributes);
						myState = F_LINK;
					} else if (tag == TAG_CATEGORY) {
						myCategory = new ATOMCategory();
						myCategory.readAttributes(attributes);
						myState = F_CATEGORY;
					} else if (tag == TAG_TITLE) {
						//myTitle = new ATOMTitle(); // TODO:implement ATOMTextConstruct & ATOMTitle
						//myTitle.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = F_TITLE;
					} else if (tag == TAG_SUBTITLE) {
						//mySubtitle = new ATOMTitle(); // TODO:implement ATOMTextConstruct & ATOMSubtitle
						//mySubtitle.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = F_SUBTITLE;
					} else if (tag == TAG_UPDATED) {
						myUpdated = new ATOMUpdated();
						myUpdated.readAttributes(attributes);
						myState = F_UPDATED;
					} else if (tag == TAG_ENTRY) {
						myEntry = new OPDSEntry();
						myEntry.readAttributes(attributes);
						myState = F_ENTRY;
						// Process feed metadata just before first feed entry
						if (myFeed != null && !myFeedMetadataProcessed) {
							interruptReading = myFeedReader.processFeedMetadata(myFeed, true);
							myFeedMetadataProcessed = true;
						}
					} 
				} else if (tagPrefix == myOpenSearchNamespaceId) {
					if (tag == OPENSEARCH_TAG_TOTALRESULTS) {
						myState = OPENSEARCH_TOTALRESULTS;
					} else if (tag == OPENSEARCH_TAG_ITEMSPERPAGE) {
						myState = OPENSEARCH_ITEMSPERPAGE;
					} else if (tag == OPENSEARCH_TAG_STARTINDEX) {
						myState = OPENSEARCH_STARTINDEX;
					} 
				} 
				break;
			case F_ENTRY:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_AUTHOR) {
						myAuthor = new ATOMAuthor();
						myAuthor.readAttributes(attributes);
						myState = FE_AUTHOR;
					} else if (tag == TAG_ID) {
						myId = new ATOMId();
						myId.readAttributes(attributes);
						myState = FE_ID;
					} else if (tag == TAG_CATEGORY) {
						myCategory = new ATOMCategory();
						myCategory.readAttributes(attributes);
						myState = FE_CATEGORY;
					} else if (tag == TAG_LINK) {
						myLink = new OPDSLink();
						myLink.readAttributes(attributes);
						myState = FE_LINK;
					} else if (tag == TAG_PUBLISHED) {
						myPublished = new ATOMPublished();
						myPublished.readAttributes(attributes);
						myState = FE_PUBLISHED;
					} else if (tag == TAG_SUMMARY) {
						//mySummary = new ATOMSummary(); // TODO:implement ATOMTextConstruct & ATOMSummary
						//mySummary.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = FE_SUMMARY;
					} else if (tag == TAG_CONTENT) {
						//myConent = new ATOMContent(); // TODO:implement ATOMContent
						//myConent.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = FE_CONTENT;
					} else if (tag == TAG_TITLE) {
						//myTitle = new ATOMTitle(); // TODO:implement ATOMTextConstruct & ATOMTitle
						//myTitle.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = FE_TITLE;
					} else if (tag == TAG_UPDATED) {
						myUpdated = new ATOMUpdated();
						myUpdated.readAttributes(attributes);
						myState = FE_UPDATED;
					}
				} else if (tagPrefix == myDublinCoreNamespaceId) {
					if (tag == DC_TAG_LANGUAGE) {
						myState = FE_DC_LANGUAGE;
					} else if (tag == DC_TAG_ISSUED) {
						myDCIssued = new DCDate();
						myDCIssued.readAttributes(attributes);
						myState = FE_DC_ISSUED;
					} else if (tag == DC_TAG_PUBLISHER) {
						myState = FE_DC_PUBLISHER;
					} 
				} else if (tagPrefix == myCalibreNamespaceId) {
					if (tag == CALIBRE_TAG_SERIES) {
						myState = FE_CALIBRE_SERIES;
					} else if (tag == CALIBRE_TAG_SERIES_INDEX) {
						myState = FE_CALIBRE_SERIES_INDEX;
					}
				}
				break;
			case F_AUTHOR:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_NAME) {
						myState = FA_NAME;
					} else if (tag == TAG_URI) {
						myState = FA_URI;
					} else if (tag == TAG_EMAIL) {
						myState = FA_EMAIL;
					} 
				} 
				break;
			case FE_AUTHOR:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_NAME) {
						myState = FEA_NAME;
					} else if (tag == TAG_URI) {
						myState = FEA_URI;
					} else if (tag == TAG_EMAIL) {
						myState = FEA_EMAIL;
					} 
				}
				break;
			case FE_LINK:
				if (tagPrefix == myOpdsNamespaceId && tag == TAG_PRICE) {
					myPriceCurrency = attributes.getValue(""currencycode"");
					myState = FEL_PRICE;
				} if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_FORMAT) {
					myState = FEL_FORMAT;
				}
				break;
			case FE_CONTENT:
				myHtmlToString.processTextContent(false, tag, attributes, bufferContent);
				// FIXME: HACK: html handling must be implemeted neatly
				if (tag == TAG_HACK_SPAN || attributes.getValue(""class"") == ""price"") {
					myState = FEC_HACK_SPAN;
				}
				break;
			case FE_SUMMARY:
			case FE_TITLE:
			case F_TITLE:
			case F_SUBTITLE:
				myHtmlToString.processTextContent(false, tag, attributes, bufferContent);
				break;
			default:
				break;
		}

		return interruptReading;
	}

	public boolean endElementHandler(final String tagPrefix, final String tag,
			final String bufferContent) {
		boolean interruptReading = false;
		switch (myState) {
			case START:
				break;
			case FEED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_FEED) {
					if (myFeed != null) {
						interruptReading = myFeedReader.processFeedMetadata(myFeed, false);
					}
					myFeed = null;
					myFeedReader.processFeedEnd();
					myState = START;
				} 
				break;
			case F_ENTRY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ENTRY) {
					if (myEntry != null) {
						interruptReading = myFeedReader.processFeedEntry(myEntry);
					}
					myEntry = null;
					myState = FEED;
				}
				break;
			case F_ID:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ID) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null && myFeed != null) {
						myId.Uri = bufferContent;
						myFeed.Id = myId;
					}
					myId = null;
					myState = FEED;
				} 
				break;
			case F_ICON:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ICON) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null && myFeed != null) {
						myIcon.Uri = bufferContent;
						myFeed.Icon = myIcon;
					}
					myIcon = null;
					myState = FEED;
				} 
				break;
			case F_LINK:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_LINK) {
					if (myFeed != null) {
						myFeed.Links.add(myLink);
					}
					myLink = null;
					myState = FEED;
				} 
				break;
			case F_CATEGORY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_CATEGORY) {
					if (myFeed != null) {
						myFeed.Categories.add(myCategory);
					}
					myCategory = null;
					myState = FEED;
				} 
				break;
			case F_TITLE:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_TITLE) {
					// TODO:implement ATOMTextConstruct & ATOMTitle
					final String title = myHtmlToString.finishTextContent(bufferContent);
					if (myFeed != null) {
						myFeed.Title = title;
					}
					myState = FEED;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				} 
				break;
			case F_SUBTITLE:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_SUBTITLE) {
					// TODO:implement ATOMTextConstruct & ATOMSubtitle
					final String subtitle = myHtmlToString.finishTextContent(bufferContent);
					if (myFeed != null) {
						myFeed.Subtitle = subtitle;
					}
					myState = FEED;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				} 
				break;
			case F_UPDATED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_UPDATED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myUpdated) && myFeed != null) {
						myFeed.Updated = myUpdated;
					}
					myUpdated = null;
					myState = FEED;
				} 
				break;
			case F_AUTHOR:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_AUTHOR) {
					if (myFeed != null && myAuthor.Name != null) {
						myFeed.Authors.add(myAuthor);
					}
					myAuthor = null;
					myState = FEED;
				} 
				break;
			case FA_NAME:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_NAME) {
					myAuthor.Name = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_NAME:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_NAME) {
					myAuthor.Name = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FA_URI:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_URI) {
					myAuthor.Uri = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_URI:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_URI) {
					myAuthor.Uri = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FA_EMAIL:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_EMAIL) {
					myAuthor.Email = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_EMAIL:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_EMAIL) {
					myAuthor.Email = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FEL_PRICE:
				if (tagPrefix == myOpdsNamespaceId && tag == TAG_PRICE) {
					if (bufferContent != null && myPriceCurrency != null) {
						myLink.Prices.add(new OPDSPrice(bufferContent.intern(), myPriceCurrency));
						myPriceCurrency = null;
					}
					myState = FE_LINK;
				}
				break;
			case FEL_FORMAT:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_FORMAT) {
					if (bufferContent != null) {
						myLink.Formats.add(bufferContent.intern());
					}
					myState = FE_LINK;
				}
				break;
			case FE_AUTHOR:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_AUTHOR) {
					if (myAuthor.Name != null) {
						myEntry.Authors.add(myAuthor);
					}
					myAuthor = null;
					myState = F_ENTRY;
				} 
				break;
			case FE_ID:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ID) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null) {
						myId.Uri = bufferContent;
						myEntry.Id = myId;
					}
					myId = null;
					myState = F_ENTRY;
				}
				break;
			case FE_CATEGORY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_CATEGORY) {
					myEntry.Categories.add(myCategory);
					myCategory = null;
					myState = F_ENTRY;
				}
				break;
			case FE_LINK:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_LINK) {
					myEntry.Links.add(myLink);
					myLink = null;
					myState = F_ENTRY;
				}
				break;
			case FE_PUBLISHED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_PUBLISHED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myPublished)) {
						myEntry.Published = myPublished;
					}
					myPublished = null;
					myState = F_ENTRY;
				}
				break;
			case FE_SUMMARY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_SUMMARY) {
					// TODO:implement ATOMTextConstruct & ATOMSummary
					myEntry.Summary = myHtmlToString.finishTextContent(bufferContent);
					myState = F_ENTRY;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				}
				break;
			case FE_CONTENT:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_CONTENT) {
					// TODO:implement ATOMContent
					myEntry.Content = myHtmlToString.finishTextContent(bufferContent);
					myState = F_ENTRY;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				}
				break;
			case FE_TITLE:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_TITLE) {
					// TODO:implement ATOMTextConstruct & ATOMTitle
					myEntry.Title = myHtmlToString.finishTextContent(bufferContent);
					myState = F_ENTRY;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				}
				break;
			case FE_UPDATED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_UPDATED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myUpdated)) {
						myEntry.Updated = myUpdated;
					}
					myUpdated = null;
					myState = F_ENTRY;
				}
				break;
			case FEC_HACK_SPAN:
				// FIXME: HACK
				myHtmlToString.processTextContent(true, tag, null, bufferContent);
				if (bufferContent != null) {
					myEntry.addAttribute(KEY_PRICE, bufferContent.intern());
				}
				myState = FE_CONTENT;
				break;
			case FE_DC_LANGUAGE:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_LANGUAGE) {
					// FIXME:language can be lost:buffer will be truncated, if there are extension tags inside the <dc:language> tag
					myEntry.DCLanguage = bufferContent;
					myState = F_ENTRY;
				}
				break;
			case FE_DC_ISSUED:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_ISSUED) {
					// FIXME:issued can be lost:buffer will be truncated, if there are extension tags inside the <dc:issued> tag
					if (ATOMDateConstruct.parse(bufferContent, myDCIssued)) {
						myEntry.DCIssued = myDCIssued;
					}
					myDCIssued = null;
					myState = F_ENTRY;
				}
				break;
			case FE_DC_PUBLISHER:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_PUBLISHER) {
					// FIXME:publisher can be lost:buffer will be truncated, if there are extension tags inside the <dc:publisher> tag
					myEntry.DCPublisher = bufferContent;
					myState = F_ENTRY;
				}
				break;
			case FE_CALIBRE_SERIES:
				if (tagPrefix == myCalibreNamespaceId && tag == CALIBRE_TAG_SERIES) {
					myEntry.SeriesTitle = bufferContent;
					myState = F_ENTRY;
				}
				break;
			case FE_CALIBRE_SERIES_INDEX:
				if (tagPrefix == myCalibreNamespaceId && tag == CALIBRE_TAG_SERIES_INDEX) {
					if (bufferContent != null) {
						try {
							myEntry.SeriesIndex = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = F_ENTRY;
				}
				break;
			case OPENSEARCH_TOTALRESULTS:
				if (tagPrefix == myOpenSearchNamespaceId &&
						tag == OPENSEARCH_TAG_TOTALRESULTS) {
					if (myFeed != null && bufferContent != null) {
						try {
							myFeed.OpensearchTotalResults = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				break;
			case OPENSEARCH_ITEMSPERPAGE:
				if (tagPrefix == myOpenSearchNamespaceId &&
						tag == OPENSEARCH_TAG_ITEMSPERPAGE) {
					if (myFeed != null && bufferContent != null) {
						try {
							myFeed.OpensearchItemsPerPage = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				break;
			case OPENSEARCH_STARTINDEX:
				if (tagPrefix == myOpenSearchNamespaceId &&
						tag == OPENSEARCH_TAG_STARTINDEX) {
					if (myFeed != null && bufferContent != null) {
						try {
							myFeed.OpensearchStartIndex = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				break;
		}

		return interruptReading;
	}

	@Override
	public final void characterDataHandler(char[] data, int start, int length) {
		final int startIndex = myBuffer.length();
		myBuffer.append(data, start, length);
		int index = startIndex;
		while ((index = myBuffer.indexOf(""\r\n"", index)) != -1) {
			myBuffer.replace(index, index + 2, ""\n"");
		}
		index = startIndex;
		while ((index = myBuffer.indexOf(""\r"", index)) != -1) {
			myBuffer.setCharAt(index, '\n');
		}
	}
}
",True,236,8,33,11,24,4,21,L6
155,org.geometerplus.fbreader.network.opds.OpenSearchXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;

import org.geometerplus.fbreader.constants.XMLNamespace;

class OpenSearchXMLReader extends ZLXMLReaderAdapter {

	private final List<OpenSearchDescription> myDescriptions;
	private final int myItemsPerPage;

	private final String myBaseURL;

	public OpenSearchXMLReader(String baseUrl, List<OpenSearchDescription> descriptions, int itemsPerPage) {
		myDescriptions = descriptions;
		myItemsPerPage = itemsPerPage;
		myBaseURL = baseUrl;
	}

	private String myOpenSearchNamespaceId;

	@Override
	public boolean processNamespaces() {
		return true;
	}

	private static String intern(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		return str.intern();
	}

	@Override
	public void namespaceMapChangedHandler(HashMap<String, String> namespaces) {
		myOpenSearchNamespaceId = null;

		for (Map.Entry<String,String> entry : namespaces.entrySet()) {
			final String value = entry.getValue();
			if (value == XMLNamespace.OpenSearch) {
				myOpenSearchNamespaceId = intern(entry.getKey());
			}
		}
	}

	private int parseInt(String value) {
		if (value == null || value.length() == 0) {
			return -1;
		}
		try {
			return Integer.valueOf(value);
		} catch (NumberFormatException e) {
			return -1;
		}
	}

	private static final int START = 0;
	private static final int DESCRIPTION = 1;

	private static final String TAG_DESCRIPTION = ""OpenSearchDescription"";
	private static final String TAG_URL = ""Url"";

	private int myState = START;

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}

		switch (myState) {
		case START:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_DESCRIPTION) {
				myState = DESCRIPTION;
			}
			break;
		case DESCRIPTION:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_URL) {
				final String type = attributes.getValue(""type"");
				final String rel = attributes.getValue(""rel"");
				if (type == OPDSConstants.MIME_APP_ATOM
						&& (rel == null || rel == ""results"")) {
					final String template = ZLNetworkUtil.url(myBaseURL, attributes.getValue(""template""));
					final int indexOffset = parseInt(attributes.getValue(""indexOffset""));
					final int pageOffset = parseInt(attributes.getValue(""pageOffset""));
					final OpenSearchDescription descr =
						new OpenSearchDescription(template, myItemsPerPage, indexOffset, pageOffset);
					if (descr.isValid()) {
						myDescriptions.add(descr);
					}
				}
			}
			break;
		}

		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}

		switch (myState) {
		case DESCRIPTION:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_DESCRIPTION) {
				myState = START;
			}
			break;
		}
		return false;
	}
}
",True,112,8,33,6,8,1,6,L6
156,org.geometerplus.fbreader.network.opds.OPDSFeedReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

interface OPDSFeedReader {

	void processFeedStart();

	// return true to interrupt reading; return false to continue reading
	boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries);

	// return true to interrupt reading; return false to continue reading
	boolean processFeedEntry(OPDSEntry entry);

	void processFeedEnd();
}
",False,102,8,33,5,11,4,2,L6
157,org.geometerplus.fbreader.network.opds.OPDSLink.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.Currency;
import java.util.LinkedList;
import java.util.Locale;

import org.geometerplus.fbreader.network.atom.ATOMLink;


class OPDSPrice {

	public final String Price;
	public final String Currency;

	// @param price     price value; must be not null
	// @param currency  currency code value; must be not null;
	//                  http://www.iso.org/iso/en/prods-services/popstds/currencycodeslist.html
	public OPDSPrice(String price, String currency) {
		Price = price;
		Currency = currency;
	}
}

class OPDSLink extends ATOMLink {

	public final LinkedList<OPDSPrice> Prices = new LinkedList<OPDSPrice>();
	public final LinkedList<String> Formats = new LinkedList<String>();

	private OPDSPrice getPrice(String currency) {
		for (OPDSPrice p: Prices) {
			if (currency.equals(p.Currency)) {
				return p;
			}
		}
		return null;
	}

	public OPDSPrice selectBestPrice() {
		if (Prices.isEmpty()) {
			return null;
		} else if (Prices.size() == 1) {
			return Prices.get(0);
		}
		OPDSPrice price;
		final Locale locale = Locale.getDefault();
		if (locale.getCountry().length() == 2) {
			final String bestCode = Currency.getInstance(locale).getCurrencyCode();
			if (bestCode != null) {
				price = getPrice(bestCode);
				if (price != null) {
					return price;
				}
			}
		}
		price = getPrice(""USD"");
		if (price != null) {
			return price;
		}
		price = getPrice(""EUR"");
		if (price != null) {
			return price;
		}
		return Prices.get(0);
	}
}
",False,88,9,33,3,2,2,1,L6
158,org.geometerplus.fbreader.network.opds.OPDSEntry.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.atom.*;

class OPDSEntry extends ATOMEntry {

	public String DCLanguage;
	public String DCPublisher;
	public DCDate DCIssued;

	public String SeriesTitle;
	public int SeriesIndex;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",DCLanguage="").append(DCLanguage);
		buf.append("",DCPublisher="").append(DCPublisher);
		buf.append("",DCIssued="").append(DCIssued);
		buf.append("",SeriesTitle="").append(SeriesTitle);
		buf.append("",SeriesIndex="").append(SeriesIndex);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,99,8,33,4,10,5,2,L6
159,org.geometerplus.fbreader.network.opds.DCDate.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.atom.*;

class DCDate extends ATOMDateConstruct {

	public DCDate() {
	}

	public DCDate(int year) {
		super(year);
	}

	public DCDate(int year, int month, int day) {
		super(year, month, day);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
}
",False,90,9,33,4,1,2,1,L6
160,org.geometerplus.fbreader.network.opds.OPDSCustomLink.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.io.IOException;
import java.io.InputStream;
import java.net.URLConnection;
import java.util.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;
import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

import org.geometerplus.fbreader.network.ICustomNetworkLink;
import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkErrors;


class OPDSCustomLink extends OPDSNetworkLink implements ICustomNetworkLink {

	private int myId;
	private SaveLinkListener myListener;

	private boolean myHasChanges;

	OPDSCustomLink(int id, String siteName, String title, String summary, String icon, Map<String, String> links) {
		super(siteName, title, summary, icon, links, false);
		myId = id;
	}

	public int getId() {
		return myId;
	}

	public void setId(int id) {
		myId = id;
	}

	public void setSaveLinkListener(SaveLinkListener listener) {
		myListener = listener;
	}

	public void saveLink() {
		if (myListener != null) {
			myListener.onSaveLink(this);
		} else {
			throw new RuntimeException(""Unable to save link: SaveLinkListener hasn't been set"");
		}
	}

	public boolean hasChanges() {
		return myHasChanges;
	}

	public void resetChanges() {
		myHasChanges = false;
	}


	public final void setIcon(String icon) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(myIcon, icon);
		myIcon = icon;
	}

	public final void setSiteName(String name) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(mySiteName, name);
		mySiteName = name;
	}

	public final void setSummary(String summary) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(mySummary, summary);
		mySummary = summary;
	}

	public final void setTitle(String title) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(myTitle, title);
		myTitle = title;
	}

	public final void setLink(String urlKey, String url) {
		if (url == null) {
			removeLink(urlKey);
		} else {
			final String oldUrl = myLinks.put(urlKey, url);
			myHasChanges = myHasChanges || !url.equals(oldUrl);
		}
	}

	public final void removeLink(String urlKey) {
		final String oldUrl = myLinks.remove(urlKey);
		myHasChanges = myHasChanges || oldUrl != null;
	}


	public String reloadInfo() {
		final LinkedList<String> opensearchDescriptionURLs = new LinkedList<String>();
		final List<OpenSearchDescription> descriptions = Collections.synchronizedList(new LinkedList<OpenSearchDescription>());

		String err = ZLNetworkManager.Instance().perform(new ZLNetworkRequest(getLink(INetworkLink.URL_MAIN)) {
			@Override
			public String handleStream(URLConnection connection, InputStream inputStream) throws IOException {
				final CatalogInfoReader info = new CatalogInfoReader(URL, OPDSCustomLink.this, opensearchDescriptionURLs);
				new OPDSXMLReader(info).read(inputStream);

				if (!info.FeedStarted) {
					return NetworkErrors.errorMessage(""notAnOPDS"");
				}
				if (info.Title == null) {
					return NetworkErrors.errorMessage(""noRequiredInformation"");
				}
				myTitle = info.Title;
				if (info.Icon != null) {
					myIcon = info.Icon;
				}
				if (info.Summary != null) {
					mySummary = info.Summary;
				}
				if (info.DirectOpenSearchDescription != null) {
					descriptions.add(info.DirectOpenSearchDescription);
				}
				return null;
			}
		});

		// TODO: Use ALL available descriptions and not only Direct
		if (descriptions.isEmpty() && !opensearchDescriptionURLs.isEmpty()) {
			LinkedList<ZLNetworkRequest> requests = new LinkedList<ZLNetworkRequest>();
			for (String url: opensearchDescriptionURLs) {
				requests.add(new ZLNetworkRequest(url) {
					@Override
					public String handleStream(URLConnection connection, InputStream inputStream) throws IOException {
						new OpenSearchXMLReader(URL, descriptions, 20).read(inputStream);
						return null;
					}
				});
			}
			final String err2 = ZLNetworkManager.Instance().perform(requests);
			if (err == null) {
				err = err2;
			}
		}

		if (!descriptions.isEmpty()) {
			// TODO: May be do not use '%s'??? Use Description instead??? (this needs to rewrite SEARCH engine logic a little)
			setLink(URL_SEARCH, descriptions.get(0).makeQuery(""%s""));
		}
		return err;
	}
}
",False,272,7,33,12,36,1,14,L6
161,org.geometerplus.fbreader.network.opds.HtmlToString.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.HashMap;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;

import org.geometerplus.zlibrary.core.html.*;

import org.geometerplus.zlibrary.core.xml.ZLXMLProcessor;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;

import org.geometerplus.fbreader.network.atom.ATOMConstants;


public class HtmlToString {

	private String myLastOpenedTag;
	private String myTextType;
	private StringBuilder myTextContent = new StringBuilder();

	private HtmlToStringReader myHtmlToStringReader = new HtmlToStringReader();

	public void setupTextContent(String type) {
		if (type == null) {
			myTextType = ATOMConstants.TYPE_DEFAULT;
		} else {
			myTextType = type;
		}
		myTextContent.delete(0, myTextContent.length());
	}

	public String finishTextContent(String bufferContent) {
		if (bufferContent != null) {
			myTextContent.append(bufferContent);
		}
		char[] contentArray = myTextContent.toString().trim().toCharArray();
		String result;
		if (contentArray.length == 0) {
			result = null;
		} else {
			result = new String(contentArray);
		}
		if (result != null) {
			if (myTextType == ATOMConstants.TYPE_HTML || myTextType == ATOMConstants.TYPE_XHTML
					|| myTextType == ""text/html"" || myTextType == ""text/xhtml"") {
				myHtmlToStringReader.readFromString(result);
				result = myHtmlToStringReader.getString();
			}
		}
		myTextType = null;
		myTextContent.delete(0, myTextContent.length());
		return result;
	}

	public void processTextContent(boolean closeTag, String tag, ZLStringMap attributes, String bufferContent) {
		if (myTextType == ATOMConstants.TYPE_XHTML || myTextType == ""text/xhtml"") {
			if (bufferContent != null) {
				myTextContent.append(bufferContent);
			}
			if (closeTag) {
				final int index = myTextContent.length() - 1;
				if (tag == myLastOpenedTag && bufferContent == null && myTextContent.charAt(index) == '>') {
					myTextContent.insert(index, '/'); // TODO: Is it necessary in HTML???????
				} else {
					myTextContent.append(""</"").append(tag).append("">"");
				}
				myLastOpenedTag = null;
			} else {
				myLastOpenedTag = tag;
				StringBuilder buffer = new StringBuilder(""<"").append(tag);
				for (int i = 0; i < attributes.getSize(); ++i) {
					final String key = attributes.getKey(i);
					final String value = attributes.getValue(key);
					buffer.append("" "").append(key).append(""=\"""");
					if (value != null) {
						buffer.append(value);
					}
					buffer.append(""\"""");
				}
				buffer.append("" >"");
				myTextContent.append(buffer.toString());
			}
		} else {
			if (bufferContent != null) {
				myTextContent.append(bufferContent);
			}
		}
	}

	private static class HtmlToStringReader implements ZLHtmlReader {

		private StringBuilder myBuffer = new StringBuilder();
		private byte[] myByteData;
		private int myByteDataLength;
		private HashMap<String,char[]> myEntityMap;

		public void readFromString(String htmlString) {
			final StringBuilder html = new StringBuilder();
			html.append(""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"">"")
				.append(""<html><head>"")
				.append(""<meta http-equiv=\""Content-Type\"" content=\""text/html; charset=utf-8\"" />"")
				.append(""<title></title>"")
				.append(""</head><body>"")
				.append(htmlString)
				.append(""</body></html>"");
			final byte[] bytes;
			try {
				bytes = html.toString().getBytes(""UTF-8"");
			} catch (UnsupportedEncodingException ex) {
				throw new RuntimeException(""It's impossible!!! UTF-8 charset is not supported!!!"", ex);
			}
			ZLHtmlProcessor.read(this, new ByteArrayInputStream(bytes));
		}

		public String getString() {
			return new String(myBuffer.toString().trim().toCharArray());
		}


		public void startDocumentHandler() {
			myBuffer.delete(0, myBuffer.length());
			myByteDataLength = 0;
		}

		public void endDocumentHandler() {
			processByteData();
		}

		public void startElementHandler(String tag, int offset, ZLHtmlAttributeMap attributes) {
			processByteData();
			tag = tag.toLowerCase().intern();
			if (tag == ""br"") {
				if (myBuffer.length() > 0) {
					myBuffer.append('\n');
				}
			} else if (tag == ""hr"") {
				if (myBuffer.length() > 0) {
					if (myBuffer.charAt(myBuffer.length() - 1) != '\n') {
						myBuffer.append('\n');
					}
					myBuffer.append('\n');
				}
			}
		}

		public void endElementHandler(String tag) {
			processByteData();
			tag = tag.toLowerCase().intern();
			if (tag == ""p"") {
				if (myBuffer.length() > 0) {
					myBuffer.append('\n');
				}
			}
		}

		private void processByteData() {
			if (myByteDataLength == 0) {
				return;
			}
			final String data;
			try {
				data = new String(myByteData, 0, myByteDataLength, ""UTF-8"");
			} catch (UnsupportedEncodingException ex) {
				throw new RuntimeException(""It's impossible!!! UTF-8 charset is not supported!!!"", ex);
			}
			myByteDataLength = 0;
			if (data.length() == 0) {
				return;
			}
			if (myBuffer.length() > 0 && !Character.isWhitespace(myBuffer.charAt(myBuffer.length() - 1))) {
				myBuffer.append(' ');
			}
			int index = 0;
			while (index < data.length() && Character.isWhitespace(data.charAt(index))) {
				++index;
			}
			boolean lastSpace = false;
			while (index < data.length()) {
				final char ch = data.charAt(index++);
				if (Character.isWhitespace(ch)) {
					lastSpace = true;
				} else {
					if (lastSpace) {
						myBuffer.append(' ');
						lastSpace = false;
					}
					myBuffer.append(ch);
				}
			}
		}

		public void entityDataHandler(String entity) {
			processByteData();

			if (entity.length() == 0) {
				return;
			}

			if (myEntityMap == null) {
				myEntityMap = new HashMap<String,char[]>(ZLXMLProcessor.getEntityMap(XHTMLReader.xhtmlDTDs()));
			}
			char[] data = myEntityMap.get(entity);
			if (data == null) {
				if (entity.charAt(0) == '#') {
					try {
						int number;
						if (entity.charAt(1) == 'x') {
							number = Integer.parseInt(entity.substring(2), 16);
						} else {
							number = Integer.parseInt(entity.substring(1));
						}
						data = new char[] { (char)number };
					} catch (NumberFormatException e) {
					}
				}
				if (data == null) {
					data = new char[0];
				}
				myEntityMap.put(entity, data);
			}
//System.err.println(""FBREADER -- ENTITY: &"" + entity + ""; --> "" + new String(data));
			myBuffer.append(data);
		}

		public void byteDataHandler(byte[] data, int start, int length) {
			if (length <= 0) {
				return;
			}
			if (myByteData == null) {
				myByteData = new byte[length];
				System.arraycopy(data, start, myByteData, 0, length);
				myByteDataLength = length;
			} else {
				if (myByteData.length < myByteDataLength + length) {
					final byte[] oldData = myByteData;
					myByteData = new byte[myByteDataLength + length];
					System.arraycopy(oldData, 0, myByteData, 0, myByteDataLength);
				}
				System.arraycopy(data, start, myByteData, myByteDataLength, length);
				myByteDataLength += length;
			}
		}
	}
}
",False,246,9,33,10,29,2,7,L6
162,org.geometerplus.fbreader.network.opds.OPDSLinkReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;

import org.geometerplus.fbreader.Paths;
import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.atom.ATOMUpdated;


public class OPDSLinkReader {

	static final String CATALOGS_URL = ""http://data.fbreader.org/catalogs/generic-1.0.xml"";

	public static ICustomNetworkLink createCustomLink(int id, String siteName, String title, String summary, String icon, Map<String, String> links) {
		if (siteName == null || title == null || links.get(INetworkLink.URL_MAIN) == null) {
			return null;
		}
		return new OPDSCustomLink(id, siteName, title, summary, icon, links);
	}

	public static ICustomNetworkLink createCustomLinkWithoutInfo(String siteName, String url) {
		final HashMap<String, String> links = new HashMap<String, String>();
		links.put(INetworkLink.URL_MAIN, url);
		return new OPDSCustomLink(ICustomNetworkLink.INVALID_ID, siteName, null, null, null, links);
	}

	public static final int CACHE_LOAD = 0;
	public static final int CACHE_UPDATE = 1;
	public static final int CACHE_CLEAR = 2;

	public static String loadOPDSLinks(int cacheMode, final NetworkLibrary.OnNewLinkListener listener) {
		final File dirFile = new File(Paths.networkCacheDirectory());
		if (!dirFile.exists() && !dirFile.mkdirs()) {
			return NetworkErrors.errorMessage(""cacheDirectoryError"");
		}

		final String fileName = ""fbreader_catalogs-""
			+ CATALOGS_URL.substring(CATALOGS_URL.lastIndexOf(File.separator) + 1);

		boolean goodCache = false;
		File oldCache = null;
		ATOMUpdated cacheUpdatedTime = null;
		final File catalogsFile = new File(dirFile, fileName);
		if (catalogsFile.exists()) {
			switch (cacheMode) {
			case CACHE_UPDATE:
				final long diff = System.currentTimeMillis() - catalogsFile.lastModified();
				final long valid = 7 * 24 * 60 * 60 * 1000; // one week in milliseconds; FIXME: hardcoded const
				if (diff >= 0 && diff <= valid) {
					return null;
				}
				/* FALLTHROUGH */
			case CACHE_CLEAR:
				try {
					final OPDSLinkXMLReader reader = new OPDSLinkXMLReader();
					reader.read(new FileInputStream(catalogsFile));
					cacheUpdatedTime = reader.getUpdatedTime();
				} catch (FileNotFoundException e) {
					throw new RuntimeException(""That's impossible!!!"", e); 
				}

				oldCache = new File(dirFile, ""_"" + fileName);
				oldCache.delete();
				if (!catalogsFile.renameTo(oldCache)) {
					catalogsFile.delete();
					oldCache = null;
				}
				break;
			case CACHE_LOAD:
				goodCache = true;
				break;
			default:
				throw new IllegalArgumentException(""Invalid cacheMode value ("" + cacheMode
						+ "") in OPDSLinkReader.loadOPDSLinks method"");
			}
		}

		String error = null;
		if (!goodCache) {
			error = ZLNetworkManager.Instance().downloadToFile(CATALOGS_URL, catalogsFile);
		}

		if (error != null) {
			if (oldCache == null) {
				return error;
			}
			catalogsFile.delete();
			if (!oldCache.renameTo(catalogsFile)) {
				oldCache.delete();
				return error;
			}
		} else if (oldCache != null) {
			oldCache.delete();
			oldCache = null;
		}

		try {
			new OPDSLinkXMLReader(listener, cacheUpdatedTime).read(new FileInputStream(catalogsFile));
		} catch (FileNotFoundException e) {
			throw new RuntimeException(""That's impossible!!!"", e); 
		}
		return null;
	}
}
",True,282,13,30,13,42,2,9,L6
163,org.geometerplus.fbreader.network.opds.OPDSConstants.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;


interface OPDSConstants {

	// Feed level
	String REL_BOOKSHELF = ""http://opds-spec.org/bookshelf"";
	//String REL_SUBSCRIPTIONS = ""http://opds-spec.org/subscriptions"";

	// Entry level / catalog types
	String REL_CATALOG_AUTHOR = ""http://data.fbreader.org/catalog/author"";
	String REL_SUBSECTION = ""subsection"";

	// Entry level / acquisition links
	String REL_ACQUISITION_PREFIX = ""http://opds-spec.org/acquisition"";
	String REL_FBREADER_ACQUISITION_PREFIX = ""http://data.fbreader.org/acquisition"";
	String REL_ACQUISITION = ""http://opds-spec.org/acquisition"";
	String REL_ACQUISITION_OPEN = ""http://opds-spec.org/acquisition/open-access"";
	String REL_ACQUISITION_SAMPLE = ""http://opds-spec.org/acquisition/sample"";
	String REL_ACQUISITION_BUY = ""http://opds-spec.org/acquisition/buy"";
	//String REL_ACQUISITION_BORROW = ""http://opds-spec.org/acquisition/borrow"";
	//String REL_ACQUISITION_SUBSCRIBE = ""http://opds-spec.org/acquisition/subscribe"";
	String REL_ACQUISITION_CONDITIONAL = ""http://data.fbreader.org/acquisition/conditional"";
	String REL_ACQUISITION_SAMPLE_OR_FULL = ""http://data.fbreader.org/acquisition/sampleOrFull"";

	// Entry level / other
	String REL_IMAGE_PREFIX = ""http://opds-spec.org/image"";
	//String REL_IMAGE = ""http://opds-spec.org/image"";
	String REL_IMAGE_THUMBNAIL = ""http://opds-spec.org/image/thumbnail"";
	// FIXME: This relations have been removed from OPDS-1.0 standard. Use RelationAlias instead???
	String REL_COVER = ""http://opds-spec.org/cover"";
	String REL_THUMBNAIL = ""http://opds-spec.org/thumbnail"";

	// Entry level / OPDS Link Relations
	String REL_LINK_SIGN_IN = ""http://data.fbreader.org/catalog/sign-in"";
	String REL_LINK_SIGN_OUT = ""http://data.fbreader.org/catalog/sign-out"";
	String REL_LINK_SIGN_UP = ""http://data.fbreader.org/catalog/sign-up"";
	String REL_LINK_REFILL_ACCOUNT = ""http://data.fbreader.org/catalog/refill-account"";
	String REL_LINK_RECOVER_PASSWORD = ""http://data.fbreader.org/catalog/recover-password"";

	// Entry level / OPDS Link Conditions
	String REL_CONDITION_NEVER = ""http://data.fbreader.org/condition/never"";
	String REL_CONDITION_SIGNED_IN = ""http://data.fbreader.org/condition/signed-in"";

	// MIME types / application
	String MIME_APP_FB2ZIP = ""application/fb2+zip"";
	String MIME_APP_EPUB = ""application/epub+zip"";
	String MIME_APP_MOBI = ""application/x-mobipocket-ebook"";
	String MIME_APP_PDF = ""application/pdf"";
	String MIME_APP_ATOM = ""application/atom+xml"";

	// MIME type for Opensearch Description XML document
	String MIME_APP_OPENSEARCHDESCRIPTION = ""application/opensearchdescription+xml"";

	// a special MIME type for the litres OPDS catalog
	String MIME_APP_LITRES = ""application/litres+xml"";

	// MIME types / text
	String MIME_TEXT_HTML = ""text/html"";
}
",True,84,8,33,0,0,4,0,L6
164,org.geometerplus.fbreader.network.opds.OPDSLinkXMLReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;

import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.constants.XMLNamespace;
import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkImage;
import org.geometerplus.fbreader.network.NetworkLibrary;
import org.geometerplus.fbreader.network.atom.ATOMLink;
import org.geometerplus.fbreader.network.atom.ATOMUpdated;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;
import org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager;

class OPDSLinkXMLReader extends OPDSXMLReader {

	private static class LinkReader implements OPDSFeedReader {

		private NetworkLibrary.OnNewLinkListener myListener;

		private String myAuthenticationType;
		private boolean myHasStableIdentifiers;
		private final LinkedList<URLRewritingRule> myUrlRewritingRules = new LinkedList<URLRewritingRule>();
		private HashMap<RelationAlias, String> myRelationAliases = new HashMap<RelationAlias, String>();

		private ATOMUpdated myUpdatedTime;
		private ATOMUpdated myReadAfterTime;

		public LinkReader(NetworkLibrary.OnNewLinkListener listener, ATOMUpdated readAfter) {
			myListener = listener;
			myReadAfterTime = readAfter;
		}

		public void setAuthenticationType(String type) {
			myAuthenticationType = type;
		}

		public void setHasStableIdentifiers(boolean value) {
			myHasStableIdentifiers = value;
		}

		public void addUrlRewritingRule(URLRewritingRule rule) {
			myUrlRewritingRules.add(rule);
		}

		public void addRelationAlias(RelationAlias alias, String relation) {
			myRelationAliases.put(alias, relation);
		}

		public void clear() {
			myAuthenticationType = null;
			myHasStableIdentifiers = false;
			myUrlRewritingRules.clear();
			myRelationAliases.clear();
		}

		public ATOMUpdated getUpdatedTime() {
			return myUpdatedTime;
		}

		private static final String ENTRY_ID_PREFIX = ""urn:fbreader-org-catalog:"";

		public boolean processFeedEntry(OPDSEntry entry) {
			final String id = entry.Id.Uri;
			if (id == null || id.length() <= ENTRY_ID_PREFIX.length()
					|| !id.startsWith(ENTRY_ID_PREFIX)) {
				return false;
			}
			final String siteName = id.substring(ENTRY_ID_PREFIX.length());
			final String title = entry.Title;
			final String summary = entry.Content;

			String icon = null; 
			final HashMap<String, String> links = new HashMap<String, String>();
			final HashMap<String, Integer> urlConditions = new HashMap<String, Integer>();
			for (ATOMLink link: entry.Links) {
				final String href = link.getHref();
				final String type = ZLNetworkUtil.filterMimeType(link.getType());
				final String rel = link.getRel();
				if (rel == OPDSConstants.REL_IMAGE_THUMBNAIL
						|| rel == OPDSConstants.REL_THUMBNAIL) {
					if (type == NetworkImage.MIME_PNG ||
							type == NetworkImage.MIME_JPEG) {
						icon = href;
					}
				} else if ((rel != null && rel.startsWith(OPDSConstants.REL_IMAGE_PREFIX))
						|| rel == OPDSConstants.REL_COVER) {
					if (icon == null &&
							(type == NetworkImage.MIME_PNG ||
							 type == NetworkImage.MIME_JPEG)) {
						icon = href;
					}
				} else if (rel == null) {
					if (type == OPDSConstants.MIME_APP_ATOM) {
						links.put(INetworkLink.URL_MAIN, href);
					}
				} else if (rel == ""search"") {
					if (type == OPDSConstants.MIME_APP_ATOM) {
						final OpenSearchDescription descr = OpenSearchDescription.createDefault(href);
						if (descr.isValid()) {
							// TODO: May be do not use '%s'??? Use Description instead??? (this needs to rewrite SEARCH engine logic a little)
							links.put(INetworkLink.URL_SEARCH, descr.makeQuery(""%s""));
						}
					}
				} else if (rel == OPDSConstants.REL_LINK_SIGN_IN) {
					links.put(INetworkLink.URL_SIGN_IN, href);
				} else if (rel == OPDSConstants.REL_LINK_SIGN_OUT) {
					links.put(INetworkLink.URL_SIGN_OUT, href);
				} else if (rel == OPDSConstants.REL_LINK_SIGN_UP) {
					links.put(INetworkLink.URL_SIGN_UP, href);
				} else if (rel == OPDSConstants.REL_LINK_REFILL_ACCOUNT) {
					links.put(INetworkLink.URL_REFILL_ACCOUNT, href);
				} else if (rel == OPDSConstants.REL_LINK_RECOVER_PASSWORD) {
					links.put(INetworkLink.URL_RECOVER_PASSWORD, href);
				} else if (rel == OPDSConstants.REL_CONDITION_NEVER) {
					urlConditions.put(href, OPDSNetworkLink.FeedCondition.NEVER);
				} else if (rel == OPDSConstants.REL_CONDITION_SIGNED_IN) {
					urlConditions.put(href, OPDSNetworkLink.FeedCondition.SIGNED_IN);
				}
			}

			final String sslCertificate;
			final String path = ""data/network/"" + siteName + "".crt"";
			if (ZLResourceFile.createResourceFile(path).exists()) {
				sslCertificate = path;
			} else {
				sslCertificate = null;
			}

			INetworkLink result = link(siteName, title, summary, icon, links, urlConditions, sslCertificate);
			if (result != null) {
				myListener.onNewLink(result);
			}
			return false; 
		}

		private INetworkLink link(String siteName, String title, String summary, String icon,
				Map<String, String> links, HashMap<String, Integer> urlConditions, String sslCertificate) {
			if (siteName == null || title == null || links.get(INetworkLink.URL_MAIN) == null) {
				return null;
			}

			OPDSNetworkLink opdsLink = new OPDSNetworkLink(
				siteName,
				title,
				summary,
				icon,
				links,
				myHasStableIdentifiers
			);

			/*if (!mySearchType.empty()) {
				opdsLink.setupAdvancedSearch(
					mySearchType,
					mySearchFields[""titleOrSeries""],
					mySearchFields[""author""],
					mySearchFields[""tag""],
					mySearchFields[""annotation""]
				);
			}*/
			opdsLink.setRelationAliases(myRelationAliases);
			opdsLink.setUrlConditions(urlConditions);
			opdsLink.setUrlRewritingRules(myUrlRewritingRules);

			NetworkAuthenticationManager authManager = null;
			if (myAuthenticationType == ""basic"") {
				//authManager = NetworkAuthenticationManager.createManager(opdsLink, sslCertificate, BasicAuthenticationManager.class);
			} else if (myAuthenticationType == ""litres"") {
				authManager = NetworkAuthenticationManager.createManager(opdsLink, sslCertificate, LitResAuthenticationManager.class);
			}
			opdsLink.setAuthenticationManager(authManager);

			return opdsLink;
		}

		public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
			myUpdatedTime = feed.Updated;
			if (myUpdatedTime != null && myReadAfterTime != null
					&& myUpdatedTime.compareTo(myReadAfterTime) <= 0) {
				return true;
			}
			return myListener == null; // no listener -- no need to proceed
		}

		public void processFeedStart() {
			myUpdatedTime = null;
		}

		public void processFeedEnd() {
		}
	}

	public OPDSLinkXMLReader() {
		super(new LinkReader(null, null));
	}

	public OPDSLinkXMLReader(NetworkLibrary.OnNewLinkListener listener, ATOMUpdated readAfter) {
		super(new LinkReader(listener, readAfter));
	}

	public ATOMUpdated getUpdatedTime() {
		return ((LinkReader) myFeedReader).getUpdatedTime();
	}

	private String myFBReaderNamespaceId;

	@Override
	public void namespaceMapChangedHandler(HashMap<String, String> namespaceMap) {
		super.namespaceMapChangedHandler(namespaceMap);

		myFBReaderNamespaceId = null;

		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String value = entry.getValue();
			if (value == XMLNamespace.FBReaderCatalogMetadata) {
				myFBReaderNamespaceId = intern(entry.getKey());
			}
		}
	}


	private static final String FBREADER_ADVANCED_SEARCH = ""advancedSearch"";
	private static final String FBREADER_AUTHENTICATION = ""authentication"";
	private static final String FBREADER_STABLE_IDENTIFIERS = ""hasStableIdentifiers"";
	private static final String FBREADER_REWRITING_RULE = ""urlRewritingRule"";
	private static final String FBREADER_RELATION_ALIAS = ""relationAlias"";

	@Override
	public boolean startElementHandler(final String tagPrefix, final String tag,
			final ZLStringMap attributes, final String bufferContent) {
		switch (getState()) {
		case FEED:
			if (tagPrefix == myAtomNamespaceId && tag == TAG_ENTRY) {
				((LinkReader) myFeedReader).clear();
			}
			break;
		case F_ENTRY:
			if (tagPrefix == myFBReaderNamespaceId) {
				if (tag == FBREADER_ADVANCED_SEARCH) {
					return false;
				} else if (tag == FBREADER_AUTHENTICATION) {
					final String type = attributes.getValue(""type"");
					((LinkReader) myFeedReader).setAuthenticationType(type);
					return false;
				} else if (tag == FBREADER_RELATION_ALIAS) {
					final String name = attributes.getValue(""name"");
					final String type = attributes.getValue(""type"");
					String alias = attributes.getValue(""alias"");
					if (alias != null && name != null) {
						if (alias.length() == 0) {
							alias = null;
						}
						((LinkReader) myFeedReader).addRelationAlias(new RelationAlias(alias, type), name);
					}
					return false;
				} else if (tag == FBREADER_REWRITING_RULE) {
					final String type = attributes.getValue(""type"");
					final String apply = attributes.getValue(""apply"");
					final String name = attributes.getValue(""name"");
					final String value = attributes.getValue(""value"");
					final int typeValue;
					if (type == ""addUrlParameter"") {
						typeValue = URLRewritingRule.ADD_URL_PARAMETER;
					} else {
						return false;
					}
					final int applyValue;
					if (apply == ""external"") {
						applyValue = URLRewritingRule.APPLY_EXTERNAL;
					} else if (apply == ""internal"") {
						applyValue = URLRewritingRule.APPLY_INTERNAL;
					} else {
						applyValue = URLRewritingRule.APPLY_ALWAYS;
					}
					((LinkReader) myFeedReader).addUrlRewritingRule(new URLRewritingRule(typeValue, applyValue, name, value));
					return false;
				} else if (tag == FBREADER_STABLE_IDENTIFIERS) {
					((LinkReader) myFeedReader).setHasStableIdentifiers(true);
					return false;
				}
			}
			break;
		}
		return super.startElementHandler(tagPrefix, tag, attributes, bufferContent);
	}
}
",True,208,0,0,12,51,1,25,L6
165,org.geometerplus.fbreader.network.opds.CatalogInfoReader.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.List;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.atom.ATOMLink;

class CatalogInfoReader implements OPDSFeedReader {

	public boolean FeedStarted;
	public String Icon;
	public String Title;
	public String Summary;

	public OpenSearchDescription DirectOpenSearchDescription;
	private final List<String> myOpensearchDescriptionURLs;

	private final String myBaseURL;
	private final OPDSNetworkLink myLink;

	public CatalogInfoReader(String baseUrl, OPDSNetworkLink link, List<String> opensearchDescriptionURLs) {
		myBaseURL = baseUrl;
		myLink = link;
		myOpensearchDescriptionURLs = opensearchDescriptionURLs;
	}

	public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
		Icon = (feed.Icon != null) ? feed.Icon.Uri : null;
		Title = feed.Title;
		Summary = feed.Subtitle;

		for (ATOMLink link: feed.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = myLink.relation(link.getRel(), type);
			if (rel == ""search"") {
				if (type == OPDSConstants.MIME_APP_OPENSEARCHDESCRIPTION) {
					myOpensearchDescriptionURLs.add(ZLNetworkUtil.url(myBaseURL, link.getHref()));
				} else if (type == OPDSConstants.MIME_APP_ATOM) {
					final String template = ZLNetworkUtil.url(myBaseURL, link.getHref());
					final OpenSearchDescription descr = OpenSearchDescription.createDefault(template);
					if (descr.isValid()) {
						DirectOpenSearchDescription = descr;
					}
				}
			}
		}
		return true;
	}

	public void processFeedStart() {
		FeedStarted = true;
	}

	public void processFeedEnd() {
	}

	public boolean processFeedEntry(OPDSEntry entry) {
		return true;
	}
}
",False,270,8,33,13,26,1,10,L6
166,org.geometerplus.fbreader.network.tree.NetworkTreeFactory.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.*;

public class NetworkTreeFactory {

	public static NetworkTree createNetworkTree(NetworkCatalogTree parent, NetworkLibraryItem item) {
		return createNetworkTree(parent, item, -1);
	}

	public static NetworkTree createNetworkTree(NetworkCatalogTree parent, NetworkLibraryItem item, int position) {
		final int subtreesSize = parent.subTrees().size();
		if (position == -1) {
			position = subtreesSize;
		} else if (position < 0 || position > subtreesSize) {
			throw new IndexOutOfBoundsException(""`position` value equals "" + position + "" but must be in range [0; "" + subtreesSize + ""]"");
		}

		if (item instanceof NetworkCatalogItem) {
			NetworkCatalogItem catalogItem = (NetworkCatalogItem) item;
			if (catalogItem.getVisibility() == ZLBoolean3.B3_FALSE) {
				return null;
			}
			NetworkCatalogTree tree = new NetworkCatalogTree(parent, catalogItem, position);
			catalogItem.onDisplayItem();
			return tree;
		} else if (item instanceof NetworkBookItem) {
			if (position != subtreesSize) {
				throw new RuntimeException(""Unable to insert NetworkBookItem to the middle of the catalog"");
			}

			final boolean showAuthors = parent.Item.CatalogType != NetworkCatalogItem.CATALOG_BY_AUTHORS;

			NetworkBookItem book = (NetworkBookItem) item;
			String seriesTitle = book.SeriesTitle;
			if (seriesTitle == null) {
				return new NetworkBookTree(parent, (NetworkBookItem) item, position, showAuthors);
			}

			if (position > 0) {
				final NetworkTree previous = (NetworkTree) parent.subTrees().get(position - 1);
				if (previous instanceof NetworkSeriesTree) {
					final NetworkSeriesTree seriesTree = (NetworkSeriesTree) previous;
					if (seriesTitle.equals(seriesTree.SeriesTitle)) {
						seriesTree.invalidateChildren(); // call to update secondString
						return new NetworkBookTree(seriesTree, book, showAuthors);
					}
				} else if (previous instanceof NetworkBookTree) {
					final NetworkBookTree bookTree = (NetworkBookTree) previous;
					final NetworkBookItem previousBook = bookTree.Book;
					if (seriesTitle.equals(previousBook.SeriesTitle)) {
						bookTree.removeSelf();
						final NetworkSeriesTree seriesTree = new NetworkSeriesTree(parent, seriesTitle, --position, showAuthors);
						new NetworkBookTree(seriesTree, previousBook, showAuthors);
						return new NetworkBookTree(seriesTree, book, showAuthors);
					}
				}
			}

			return new NetworkBookTree(parent, book, position, showAuthors);
		}
		return null;
	}
}
",False,244,12,30,15,25,2,10,L6
167,org.geometerplus.fbreader.network.tree.NetworkCatalogRootTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.fbreader.network.*;

public class NetworkCatalogRootTree extends NetworkCatalogTree {

	public NetworkCatalogRootTree(RootTree parent, INetworkLink link, int position) {
		super(parent, (NetworkCatalogItem) link.libraryItem(), position);
	}
}
",False,248,6,33,15,22,3,4,L6
168,org.geometerplus.fbreader.network.tree.NetworkBookTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.network.*;


public class NetworkBookTree extends NetworkTree {

	public final NetworkBookItem Book;

	private final boolean myShowAuthors;

	NetworkBookTree(NetworkTree parent, NetworkBookItem book, boolean showAuthors) {
		super(parent);
		Book = book;
		myShowAuthors = showAuthors;
	}

	NetworkBookTree(NetworkTree parent, NetworkBookItem book, int position, boolean showAuthors) {
		super(parent, position);
		Book = book;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return Book.Title;
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors && Book.Authors.size() < 2) {
			return null;
		}
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (NetworkBookItem.AuthorData author: Book.Authors) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(author.DisplayName);
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		return createCover(Book);
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return Book;
	}
}
",False,250,8,34,15,25,5,4,L6
169,org.geometerplus.fbreader.network.tree.NetworkCatalogTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;

public class NetworkCatalogTree extends NetworkTree {

	public final NetworkCatalogItem Item;
	public final ArrayList<NetworkLibraryItem> ChildrenItems = new ArrayList<NetworkLibraryItem>();

	private long myLoadedTime = -1;

	NetworkCatalogTree(RootTree parent, NetworkCatalogItem item, int position) {
		super(parent, position);
		Item = item;
	}

	NetworkCatalogTree(NetworkCatalogTree parent, NetworkCatalogItem item, int position) {
		super(parent, position);
		Item = item;
	}

	@Override
	public String getName() {
		return Item.Title;
	}

	@Override
	public String getSummary() {
		if (Item.Summary == null) {
			return """";
		}
		return Item.Summary;
	}

	@Override
	protected ZLImage createCover() {
		return createCover(Item);
	}


	public boolean isContentValid() {
		if (myLoadedTime < 0) {
			return false;
		}
		final int reloadTime = 15 * 60 * 1000; // 15 minutes in milliseconds
		return System.currentTimeMillis() - myLoadedTime < reloadTime;
	}

	public void updateLoadedTime() {
		myLoadedTime = System.currentTimeMillis();
		FBTree tree = Parent;
		while (tree instanceof NetworkCatalogTree) {
			((NetworkCatalogTree) tree).myLoadedTime = myLoadedTime;
			tree = tree.Parent;
		}
	}


	public void updateVisibility() {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();

		ListIterator<FBTree> nodeIterator = subTrees().listIterator();
		FBTree currentNode = null;
		int nodeCount = 0;

		for (int i = 0; i < ChildrenItems.size(); ++i) {
			NetworkLibraryItem currentItem = ChildrenItems.get(i);
			if (!(currentItem instanceof NetworkCatalogItem)) {
				continue;
			}
			boolean processed = false;
			while (currentNode != null || nodeIterator.hasNext()) {
				if (currentNode == null) {
					currentNode = nodeIterator.next();
				}
				if (!(currentNode instanceof NetworkCatalogTree)) {
					currentNode = null;
					++nodeCount;
					continue;
				}
				NetworkCatalogTree child = (NetworkCatalogTree) currentNode;
				if (child.Item == currentItem) {
					final int visibility = child.Item.getVisibility();
					if (visibility == ZLBoolean3.B3_TRUE) {
						child.updateVisibility();
					} else if (visibility == ZLBoolean3.B3_FALSE) {
						toRemove.add(child);
					} else {
						child.clear();
						child.ChildrenItems.clear();
					}
					currentNode = null;
					++nodeCount;
					processed = true;
					break;
				} else {
					boolean found = false;
					for (int j = i + 1; j < ChildrenItems.size(); ++j) {
						if (child.Item == ChildrenItems.get(j)) {
							found = true;
							break;
						}
					}
					if (!found) {
						toRemove.add(currentNode);
						currentNode = null;
						++nodeCount;
					} else {
						break;
					}
				}
			}
			final int nextIndex = nodeIterator.nextIndex();
			if (!processed && NetworkTreeFactory.createNetworkTree(this, currentItem, nodeCount) != null) {
				++nodeCount;
				nodeIterator = subTrees().listIterator(nextIndex + 1);
			}
		}

		while (currentNode != null || nodeIterator.hasNext()) {
			if (currentNode == null) {
				currentNode = nodeIterator.next();
			}
			if (currentNode instanceof NetworkCatalogTree) {
				toRemove.add(currentNode);
			}
			currentNode = null;
		}

		for (FBTree tree: toRemove) {
			tree.removeSelf();
		}
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return Item;
	}

	@Override
	public void removeItems(Set<NetworkLibraryItem> items) {
		ChildrenItems.removeAll(items);
		super.removeItems(items);
	}
}
",False,249,6,33,15,25,6,9,L6
170,org.geometerplus.fbreader.network.tree.RootTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.fbreader.network.NetworkLibraryItem;
import org.geometerplus.fbreader.network.NetworkTree;

public final class RootTree extends NetworkTree {
	@Override
	public String getName() {
		return null;
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}
}
",False,247,6,33,16,20,3,2,L6
171,org.geometerplus.fbreader.network.tree.NetworkSeriesTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;


public class NetworkSeriesTree extends NetworkTree {

	public final String SeriesTitle;

	private final boolean myShowAuthors;

	NetworkSeriesTree(NetworkTree parent, String seriesTitle, int position, boolean showAuthors) {
		super(parent, position);
		SeriesTitle = seriesTitle;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return SeriesTitle;
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors) {
			return super.getSummary();
		}

		StringBuilder builder = new StringBuilder();
		int count = 0;

		Set<NetworkBookItem.AuthorData> authorSet = new TreeSet<NetworkBookItem.AuthorData>();
		for (FBTree tree: subTrees()) {
			if (!(tree instanceof NetworkBookTree)) {
				continue;
			}
			final NetworkBookItem book = ((NetworkBookTree) tree).Book;

			for (NetworkBookItem.AuthorData author: book.Authors) {
				if (!authorSet.contains(author)) {
					authorSet.add(author);
					if (count++ > 0) {
						builder.append("",  "");
					}
					builder.append(author.DisplayName);
					if (count == 5) {
						return builder.toString();
					}
				}
			}
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		for (FBTree tree: subTrees()) {
			if (tree instanceof NetworkBookTree) {
				return ((NetworkBookTree) tree).createCover();
			}
		}
		return null;
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}

	@Override
	public void removeItems(Set<NetworkLibraryItem> items) {
		super.removeItems(items);
		if (subTrees().isEmpty()) {
			removeSelf();
		}
	}
}
",False,250,8,34,15,25,4,7,L6
172,org.geometerplus.fbreader.network.tree.NetworkAuthorTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;


public class NetworkAuthorTree extends NetworkTree {

	public final NetworkBookItem.AuthorData Author;

	private int myBooksNumber;
	private HashMap<String, Integer> mySeriesMap;

	public NetworkAuthorTree(NetworkTree parent, NetworkBookItem.AuthorData author) {
		super(parent);
		Author = author;
	}

	@Override
	public String getName() {
		return Author.DisplayName;
	}

	@Override
	protected String getSortKey() {
		return Author.SortKey;
	}

	private int getSeriesIndex(String seriesName) {
		if (mySeriesMap == null) {
			return -1;
		}
		Integer value = mySeriesMap.get(seriesName);
		if (value == null) {
			return -1;
		}
		return value.intValue();
	}

	private void setSeriesIndex(String seriesName, int index) {
		if (mySeriesMap == null) {
			mySeriesMap = new HashMap<String, Integer>();
		}
		mySeriesMap.put(seriesName, Integer.valueOf(index));
	}

	public void updateSubTrees(LinkedList<NetworkBookItem> books) {
		if (myBooksNumber >= books.size()) {
			return;
		}
		invalidateChildren(); // call to update secondString

		ListIterator<NetworkBookItem> booksIterator = books.listIterator(myBooksNumber);
		while (booksIterator.hasNext()) {
			NetworkBookItem book = booksIterator.next();

			if (book.SeriesTitle != null) {
				final int seriesPosition = getSeriesIndex(book.SeriesTitle);
				if (seriesPosition == -1) {
					final int insertAt = subTrees().size();
					setSeriesIndex(book.SeriesTitle, insertAt);
					new NetworkBookTree(this, book, false);
				} else {
					FBTree treeAtSeriesPosition = subTrees().get(seriesPosition);
					if (treeAtSeriesPosition instanceof NetworkBookTree) {
						final NetworkBookTree bookTree = (NetworkBookTree) treeAtSeriesPosition;
						bookTree.removeSelf();
						final NetworkSeriesTree seriesTree = new NetworkSeriesTree(this, book.SeriesTitle, seriesPosition, false);
						new NetworkBookTree(seriesTree, bookTree.Book, false);
						treeAtSeriesPosition = seriesTree;
					}

					if (!(treeAtSeriesPosition instanceof NetworkSeriesTree)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					final NetworkSeriesTree seriesTree = (NetworkSeriesTree) treeAtSeriesPosition;
					ListIterator<FBTree> nodesIterator = seriesTree.subTrees().listIterator();
					int insertAt = 0;
					while (nodesIterator.hasNext()) {
						FBTree tree = nodesIterator.next();
						if (!(tree instanceof NetworkBookTree)) {
							throw new RuntimeException(""That's impossible!!!"");
						}
						NetworkBookTree bookTree = (NetworkBookTree) tree;
						if (bookTree.Book.IndexInSeries > book.IndexInSeries) {
							break;
						}
						++insertAt;
					}
					seriesTree.invalidateChildren(); // call to update secondString
					new NetworkBookTree(seriesTree, book, insertAt, false);
				}
			} else {
				new NetworkBookTree(this, book, false);
			}
		}

		myBooksNumber = books.size();
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}
}
",False,243,12,30,15,25,3,7,L6
173,org.geometerplus.fbreader.tree.FBTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.tree.ZLTree;
import org.geometerplus.zlibrary.core.image.ZLImage;

public abstract class FBTree extends ZLTree<FBTree> implements Comparable<FBTree> {

	private ZLImage myCover;
	private boolean myCoverRequested;

	protected FBTree(int level) {
		super(level);
	}

	protected FBTree() {
		super();
	}

	protected FBTree(FBTree parent) {
		super(parent);
	}

	protected FBTree(FBTree parent, int position) {
		super(parent, position);
	}

	public abstract String getName();

	protected String getSortKey() {
		return getName();
	}

	public int compareTo(FBTree ct) {
		final String key0 = getSortKey();
		final String key1 = ct.getSortKey();
		if (key0 == null) {
			return (key1 == null) ? 0 : -1;
		}
		if (key1 == null) {
			return 1;
		}
		return key0.toLowerCase().compareTo(key1.toLowerCase());
	}

	public final void sortAllChildren() {
		List<FBTree> children = subTrees();
		if (!children.isEmpty()) {
			Collections.sort(children);
			for (FBTree tree : children) {
				tree.sortAllChildren();
			}
		}
	}

	private String mySecondString;

	public final void invalidateChildren() {
		mySecondString = null;
	}

	public final String getSecondString() {
		if (mySecondString == null) {
			mySecondString = getSummary();
			if (mySecondString == null) {
				mySecondString = """";
			}
		}
		return mySecondString;
	}

	protected String getSummary() {
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (FBTree subtree : subTrees()) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(subtree.getName());
			if (count == 5) {
				break;
			}
		}
		return builder.toString();
	}

	protected ZLImage createCover() {
		return null;
	}

	public final ZLImage getCover() {
		if (!myCoverRequested) {
			myCover = createCover();
			if (myCover == null && Parent != null) {
				myCover = Parent.getCover();
			}
			myCoverRequested = true;
		}
		return myCover;
	}
}
",False,99,6,34,1,2,20,2,L6
174,org.geometerplus.android.fbreader.BookmarkSearchActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.LinkedList;

import android.app.Activity;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.fbreader.fbreader.FBReader;
import org.geometerplus.fbreader.library.*;

public class BookmarkSearchActivity extends SearchActivity {
	private final LinkedList<Bookmark> myBookmarks = new LinkedList<Bookmark>();

	@Override
	void onSuccess() {
		BookmarksActivity.Instance.showSearchResultsTab(myBookmarks);
	}

	/*@Override
	void onFailure() {
	}*/

	@Override
	String getFailureMessageResourceKey() {
		return ""bookmarkNotFound"";
	}

	@Override
	String getWaitMessageResourceKey() {
		return ""search"";
	}

	@Override
	boolean runSearch(String pattern) {
		final FBReader fbreader = (FBReader)FBReader.Instance();
		fbreader.BookmarkSearchPatternOption.setValue(pattern);
		pattern = pattern.toLowerCase();
		myBookmarks.clear();
		for (Bookmark bookmark : BookmarksActivity.Instance.AllBooksBookmarks) {
			if (ZLMiscUtil.matchesIgnoreCase(bookmark.getText(), pattern)) {
				myBookmarks.add(bookmark);
			}
		}	
		return !myBookmarks.isEmpty();
	}

	@Override
	Activity getParentActivity() {
		return BookmarksActivity.Instance;
	}
}
",False,376,0,0,10,83,0,7,L8
175,org.geometerplus.android.fbreader.FBReader.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.LinkedList;

import android.app.SearchManager;
import android.content.Intent;
import android.os.Bundle;
import android.os.PowerManager;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.RelativeLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import org.geometerplus.zlibrary.core.application.ZLApplication;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.view.ZLView;
import org.geometerplus.zlibrary.text.model.ZLTextModel;
import org.geometerplus.zlibrary.text.view.ZLTextFixedPosition;
import org.geometerplus.zlibrary.text.view.ZLTextPosition;
import org.geometerplus.zlibrary.text.view.ZLTextView;
import org.geometerplus.zlibrary.ui.android.library.ZLAndroidActivity;
import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;
import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.fbreader.ActionCode;

public final class FBReader extends ZLAndroidActivity {
	static FBReader Instance;

	private int myFullScreenFlag;

	private static class NavigationButtonPanel extends ControlButtonPanel {
		public volatile boolean NavigateDragging;
		public ZLTextPosition StartPosition;

		@Override
		public void onShow() {
			if (FBReader.Instance != null && myControlPanel != null) {
				FBReader.Instance.setupNavigation(myControlPanel);
			}
		}

		@Override
		public void updateStates() {
			super.updateStates();
			if (!NavigateDragging && FBReader.Instance != null && myControlPanel != null) {
				FBReader.Instance.setupNavigation(myControlPanel);
			}
		}
	}

	private static class TextSearchButtonPanel extends ControlButtonPanel {
		@Override
		public void onHide() {
			final ZLTextView textView = (ZLTextView) ZLApplication.Instance().getCurrentView();
			textView.clearFindResults();
		}
	}

	private static TextSearchButtonPanel myTextSearchPanel;
	private static NavigationButtonPanel myNavigatePanel;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		/*
		android.telephony.TelephonyManager tele =
			(android.telephony.TelephonyManager)getSystemService(TELEPHONY_SERVICE);
		System.err.println(tele.getNetworkOperator());
		*/
		Instance = this;
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();
		myFullScreenFlag =
			application.ShowStatusBarOption.getValue() ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN;
		getWindow().setFlags(
			WindowManager.LayoutParams.FLAG_FULLSCREEN, myFullScreenFlag
		);
		if (myTextSearchPanel == null) {
			myTextSearchPanel = new TextSearchButtonPanel();
			myTextSearchPanel.register();
		}
		if (myNavigatePanel == null) {
			myNavigatePanel = new NavigationButtonPanel();
			myNavigatePanel.register();
		}
	}

	@Override
	public void onStart() {
		super.onStart();
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();

		final int fullScreenFlag =
			application.ShowStatusBarOption.getValue() ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN;
		if (fullScreenFlag != myFullScreenFlag) {
			finish();
			startActivity(new Intent(this, this.getClass()));
		}

		final RelativeLayout root = (RelativeLayout)FBReader.this.findViewById(R.id.root_view);
		if (!myTextSearchPanel.hasControlPanel()) {
			final ControlPanel panel = new ControlPanel(this);

			panel.addButton(ActionCode.FIND_PREVIOUS, false, R.drawable.text_search_previous);
			panel.addButton(ActionCode.CLEAR_FIND_RESULTS, true, R.drawable.text_search_close);
			panel.addButton(ActionCode.FIND_NEXT, false, R.drawable.text_search_next);

			myTextSearchPanel.setControlPanel(panel, root, false);
		}
		if (!myNavigatePanel.hasControlPanel()) {
			final ControlPanel panel = new ControlPanel(this);
			final View layout = getLayoutInflater().inflate(R.layout.navigate, panel, false);
			createNavigation(layout);
			panel.setExtension(layout);
			myNavigatePanel.setControlPanel(panel, root, true);
		}

		findViewById(R.id.main_view).setOnLongClickListener(new View.OnLongClickListener() {
			public boolean onLongClick(View v) {
				if (!myNavigatePanel.getVisibility()) {
					navigate();
					return true;
				}
				return false;
			}
		});
	}

	private PowerManager.WakeLock myWakeLock;

	@Override
	public void onResume() {
		super.onResume();
		ControlButtonPanel.restoreVisibilities();
		if (ZLAndroidApplication.Instance().DontTurnScreenOffOption.getValue()) {
			myWakeLock =
				((PowerManager)getSystemService(POWER_SERVICE)).
					newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, ""FBReader"");
			myWakeLock.acquire();
		} else {
			myWakeLock = null;
		}
	}

	@Override
	public void onPause() {
		if (myWakeLock != null) {
			myWakeLock.release();
		}
		ControlButtonPanel.saveVisibilities();
		super.onPause();
	}

	@Override
	public void onStop() {
		ControlButtonPanel.removeControlPanels();
		super.onStop();
	}

	void showTextSearchControls(boolean show) {
		if (show) {
			myTextSearchPanel.show(true);
		} else {
			myTextSearchPanel.hide(false);
		}
	}

	protected ZLApplication createApplication(String fileName) {
		new SQLiteBooksDatabase();
		String[] args = (fileName != null) ? new String[] { fileName } : new String[0];
		return new org.geometerplus.fbreader.fbreader.FBReader(args);
	}

	@Override
	public boolean onSearchRequested() {
		final LinkedList<Boolean> visibilities = new LinkedList<Boolean>();
		ControlButtonPanel.saveVisibilitiesTo(visibilities);
		ControlButtonPanel.hideAllPendingNotify();
		final SearchManager manager = (SearchManager)getSystemService(SEARCH_SERVICE);
		manager.setOnCancelListener(new SearchManager.OnCancelListener() {
			public void onCancel() {
				ControlButtonPanel.restoreVisibilitiesFrom(visibilities);
				manager.setOnCancelListener(null);
			}
		});
		final org.geometerplus.fbreader.fbreader.FBReader fbreader =
			(org.geometerplus.fbreader.fbreader.FBReader)ZLApplication.Instance();
		startSearch(fbreader.TextSearchPatternOption.getValue(), true, null, false);
		return true;
	}


	public void navigate() {
		final ZLTextView textView = (ZLTextView) ZLApplication.Instance().getCurrentView();
		myNavigatePanel.NavigateDragging = false;
		myNavigatePanel.StartPosition = new ZLTextFixedPosition(textView.getStartCursor());
		myNavigatePanel.show(true);
	}



	public final boolean canNavigate() {
		final org.geometerplus.fbreader.fbreader.FBReader fbreader =
			(org.geometerplus.fbreader.fbreader.FBReader)ZLApplication.Instance();
		final ZLView view = fbreader.getCurrentView();
		if (!(view instanceof ZLTextView)) {
			return false;
		}
		final ZLTextModel textModel = ((ZLTextView) view).getModel();
		if (textModel == null || textModel.getParagraphsNumber() == 0) {
			return false;
		}
		final BookModel bookModel = fbreader.Model;
		return bookModel != null && bookModel.Book != null;
	}

	private final void createNavigation(View layout) {
		final SeekBar slider = (SeekBar) layout.findViewById(R.id.book_position_slider);
		final TextView text = (TextView) layout.findViewById(R.id.book_position_text);

		slider.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			private void gotoPage(int page) {
				final ZLView view = ZLApplication.Instance().getCurrentView();
				if (view instanceof ZLTextView) {
					ZLTextView textView = (ZLTextView) view;
					if (page == 1) {
						textView.gotoHome();
					} else {
						textView.gotoPage(page);
					}
					ZLApplication.Instance().repaintView();
				}
			}

			public void onStopTrackingTouch(SeekBar seekBar) {
				myNavigatePanel.NavigateDragging = false;
			}

			public void onStartTrackingTouch(SeekBar seekBar) {
				myNavigatePanel.NavigateDragging = true;
			}

			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				if (fromUser) {
					final int page = progress + 1;
					final int pagesNumber = seekBar.getMax() + 1; 
					text.setText(makeProgressText(page, pagesNumber));
					gotoPage(page);
				}
			}
		});

		final Button btnOk = (Button) layout.findViewById(android.R.id.button1);
		final Button btnCancel = (Button) layout.findViewById(android.R.id.button3);
		View.OnClickListener listener = new View.OnClickListener() {
			public void onClick(View v) {
				final ZLTextPosition position = myNavigatePanel.StartPosition;
				myNavigatePanel.StartPosition = null;
				if (v == btnCancel && position != null) {
					((ZLTextView) ZLApplication.Instance().getCurrentView()).gotoPosition(position);
				}
				myNavigatePanel.hide(true);
			}
		};
		btnOk.setOnClickListener(listener);
		btnCancel.setOnClickListener(listener);
		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		btnOk.setText(buttonResource.getResource(""ok"").getValue());
		btnCancel.setText(buttonResource.getResource(""cancel"").getValue());
	}

	private final void setupNavigation(ControlPanel panel) {
		final SeekBar slider = (SeekBar) panel.findViewById(R.id.book_position_slider);
		final TextView text = (TextView) panel.findViewById(R.id.book_position_text);

		final ZLTextView textView = (ZLTextView) ZLApplication.Instance().getCurrentView();
		final int page = textView.computeCurrentPage();
		final int pagesNumber = textView.computePageNumber();

		if (slider.getMax() != (pagesNumber - 1)
				|| slider.getProgress() != (page - 1)) {
			slider.setMax(pagesNumber - 1);
			slider.setProgress(page - 1);
			text.setText(makeProgressText(page, pagesNumber));
		}
	}

	private static String makeProgressText(int page, int pagesNumber) {
		return """" + page + "" / "" + pagesNumber;
	}
}
",True,375,1,1,9,89,3,17,L6
176,org.geometerplus.android.fbreader.LibraryTabActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.*;
import android.os.Bundle;
import android.view.*;
import android.widget.*;
import android.content.DialogInterface;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.tree.ZLTree;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.fbreader.FBReader;
import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.*;
import org.geometerplus.fbreader.tree.FBTree;

public class LibraryTabActivity extends TabActivity implements MenuItem.OnMenuItemClickListener {
	static LibraryTabActivity Instance;

	final ZLStringOption mySelectedTabOption = new ZLStringOption(""TabActivity"", ""SelectedTab"", """");
	private final ZLResource myResource = ZLResource.resource(""libraryView"");
	private Book myCurrentBook;

	private ListView createTab(String tag, int viewId, int iconId) {
		final TabHost host = getTabHost();
		final String label = myResource.getResource(tag).getValue();
		host.addTab(host.newTabSpec(tag).setIndicator(label, getResources().getDrawable(iconId)).setContent(viewId));
		return (ListView)findViewById(viewId);
	}

	private void setCurrentBook() {
		final BookModel model = ((FBReader)FBReader.Instance()).Model;
		myCurrentBook = (model != null) ? model.Book : null;
	}

	private void createDefaultTabs() {
		new LibraryAdapter(createTab(""byAuthor"", R.id.by_author, R.drawable.ic_tab_library_author), Library.Instance().byAuthor(), Type.TREE);
		new LibraryAdapter(createTab(""byTag"", R.id.by_tag, R.drawable.ic_tab_library_tag), Library.Instance().byTag(), Type.TREE);
		new LibraryAdapter(createTab(""recent"", R.id.recent, R.drawable.ic_tab_library_recent), Library.Instance().recentBooks(), Type.FLAT);
		findViewById(R.id.search_results).setVisibility(View.GONE);
	}

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		setCurrentBook();

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);

		final TabHost host = getTabHost();
		LayoutInflater.from(this).inflate(R.layout.library, host.getTabContentView(), true);

		createDefaultTabs();

		host.setCurrentTabByTag(mySelectedTabOption.getValue());
	}

	private LibraryAdapter mySearchResultsAdapter;
	void showSearchResultsTab(LibraryTree tree) {
		if (mySearchResultsAdapter == null) {
			mySearchResultsAdapter =
				new LibraryAdapter(createTab(""searchResults"", R.id.search_results, R.drawable.ic_tab_library_results), tree, Type.FLAT);
		} else {
			mySearchResultsAdapter.resetTree(tree);
		}
		getTabHost().setCurrentTabByTag(""searchResults"");
	}

	@Override
	public void onResume() {
		super.onResume();
		Instance = this;
	}

	@Override
	public void onPause() {
		super.onPause();
	}

	@Override
	public void onStop() {
		mySelectedTabOption.setValue(getTabHost().getCurrentTabTag());
		Instance = null;
		super.onStop();
	}

	@Override
	public void onDestroy() {
		Library.Instance().clear();
		super.onDestroy();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		addMenuItem(menu, 1, ""localSearch"", R.drawable.ic_menu_search);
		return true;
	}

	private MenuItem addMenuItem(Menu menu, int index, String resourceKey, int iconId) {
		final String label = myResource.getResource(""menu"").getResource(resourceKey).getValue();
		final MenuItem item = menu.add(0, index, Menu.NONE, label);
		item.setOnMenuItemClickListener(this);
		item.setIcon(iconId);
		return item;
	}

	public boolean onMenuItemClick(MenuItem item) {
		switch (item.getItemId()) {
			case 1:
				return onSearchRequested();
			default:
				return true;
		}
	}

	@Override
	public boolean onSearchRequested() {
		final FBReader fbreader = (FBReader)FBReader.Instance();
		startSearch(fbreader.BookSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	interface Type {
		int TREE = 0;
		int FLAT = 1;
		int NETWORK = 2;
	}

	private final class LibraryAdapter extends ZLTreeAdapter {
		private final LibraryTree myLibraryTree;
			
		private final int myType;

		LibraryAdapter(ListView view, LibraryTree tree, int type) {
			super(view, tree);
			myLibraryTree = tree;
			myType = type;
			selectItem(findFirstSelectedItem());
		}

		@Override
		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final LibraryTree tree = (LibraryTree)getItem(position);
			if (tree instanceof BookTree) {
				menu.setHeaderTitle(tree.getName());
				final ZLResource resource = ZLResource.resource(""libraryView"");
				menu.add(0, OPEN_BOOK_ITEM_ID, 0, resource.getResource(""openBook"").getValue());
				if ((Library.Instance().getRemoveBookMode(((BookTree)tree).Book)
						& Library.REMOVE_FROM_DISK) != 0) {
					menu.add(0, DELETE_BOOK_ITEM_ID, 0, resource.getResource(""deleteBook"").getValue());
				}
			}
		}

		private ZLTree<?> findFirstSelectedItem() {
			if (myCurrentBook == null) {
				return null;
			}
			for (FBTree tree : myLibraryTree) {
				if ((tree instanceof BookTree) && ((BookTree)tree).Book.equals(myCurrentBook)) {
					return tree;
				}
			}
			return null;
		}

		public View getView(int position, View convertView, ViewGroup parent) {
			final View view = (convertView != null) ? convertView :
				LayoutInflater.from(parent.getContext()).inflate(R.layout.library_tree_item, parent, false);
			final LibraryTree tree = (LibraryTree)getItem(position);
			if ((tree instanceof BookTree) && ((BookTree)tree).Book.equals(myCurrentBook)) {
				view.setBackgroundColor(0xff808080);
			} else {
				view.setBackgroundColor(0);
			}
			final ImageView iconView = (ImageView)view.findViewById(R.id.library_tree_item_icon);
			switch (myType) {
				case Type.FLAT:
					iconView.setVisibility(View.GONE);
					break;
				case Type.TREE:
					setIcon(iconView, tree);
					break;
				case Type.NETWORK:
					switch (position % 3) {
						case 0:
							iconView.setImageResource(R.drawable.ic_list_buy);
							break;
						case 1:
							iconView.setImageResource(R.drawable.ic_list_download);
							break;
						case 2:
							iconView.setImageResource(R.drawable.ic_list_flag);
							break;
					}
					break;
			}
			((TextView)view.findViewById(R.id.library_tree_item_name)).setText(tree.getName());
			((TextView)view.findViewById(R.id.library_tree_item_childrenlist)).setText(tree.getSecondString());
			return view;
		}

		@Override
		protected boolean runTreeItem(ZLTree<?> tree) {
			if (super.runTreeItem(tree)) {
				return true;
			}
			finish();
			final Book book = ((BookTree)tree).Book;
			if (!book.equals(myCurrentBook)) {
				((FBReader)FBReader.Instance()).openBook(book, null);
			}
			return true;
		}
	}

	private static final int OPEN_BOOK_ITEM_ID = 0;
	private static final int DELETE_BOOK_ITEM_ID = 1;

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final LibraryAdapter adapter =
			(LibraryAdapter)((ListView)getTabHost().getCurrentView()).getAdapter();
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final BookTree tree = (BookTree)adapter.getItem(position);
		switch (item.getItemId()) {
			case OPEN_BOOK_ITEM_ID:
				adapter.runTreeItem(tree);
				return true;
			case DELETE_BOOK_ITEM_ID:
				tryToDeleteBook(tree.Book);
				return true;
		}
		return super.onContextItemSelected(item);
	}

	private class BookDeleter implements DialogInterface.OnClickListener {
		private final Book myBook;
		private final int myMode;

		BookDeleter(Book book, int removeMode) {
			myBook = book;
			myMode = removeMode;
		}

		private void invalidateView(View v) {
			ZLTreeAdapter adapter = (ZLTreeAdapter)((ListView)v).getAdapter();
			if (adapter != null) {
				adapter.resetTree();
			}
		}

		public void onClick(DialogInterface dialog, int which) {
			Library.Instance().removeBook(myBook, myMode);

			invalidateView(findViewById(R.id.by_author));
			invalidateView(findViewById(R.id.by_tag));
			invalidateView(findViewById(R.id.recent));
			invalidateView(findViewById(R.id.search_results));
		}
	}

	private void tryToDeleteBook(Book book) {
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource boxResource = dialogResource.getResource(""deleteBookBox"");
		new AlertDialog.Builder(this)
			.setTitle(book.getTitle())
			.setMessage(boxResource.getResource(""message"").getValue())
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new BookDeleter(book, Library.REMOVE_FROM_DISK))
			.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
			.create().show();
	}
}
",False,375,1,1,10,69,2,13,L6
177,org.geometerplus.android.fbreader.ControlPanel.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.ArrayList;

import android.os.Handler;
import android.os.Message;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.animation.AlphaAnimation;
import android.widget.*;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.application.ZLApplication;

class ActionButton extends ZoomButton {
	final String ActionId;
	final boolean IsCloseButton;

	ActionButton(Context context, String actionId, boolean isCloseButton) {
		super(context);
		ActionId = actionId;
		IsCloseButton = isCloseButton;
	}
}

public class ControlPanel extends LinearLayout implements View.OnClickListener {
	private final ArrayList<ActionButton> myButtons = new ArrayList<ActionButton>();
	private final LinearLayout myPlateLayout;

	public ControlPanel(Context context) {
		super(context);

		setFocusable(false);
		
		final LayoutInflater inflater =
			(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.control_panel, this, true);
		myPlateLayout = (LinearLayout)findViewById(R.id.tools_plate);
	}

	public void addButton(String actionId, boolean isCloseButton, int imageId) {
		final ActionButton button = new ActionButton(getContext(), actionId, isCloseButton);
		button.setImageResource(imageId);
		button.setOnClickListener(this);
		myPlateLayout.addView(button);
		myButtons.add(button);
	}

	public void onClick(View view) {
		final ActionButton button = (ActionButton)view;
		ZLApplication.Instance().doAction(button.ActionId);
		if (button.IsCloseButton) {
			hide(true);
		}
	}
	
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		return true;
	}

	private interface VisibilityAction {
		int SHOW_ANIMATED = 0;
		int SHOW_INSTANTLY = 1;
		int HIDE_ANIMATED = 2;
		int HIDE_INSTANTLY = 3;
	}
	
	private Handler myVisibilityHandler = new Handler() {
		public void handleMessage(Message message) {
			switch (message.what) {
				case VisibilityAction.SHOW_ANIMATED:
					fade(View.VISIBLE, 0.0f, 1.0f);
					break;
				case VisibilityAction.SHOW_INSTANTLY:
					setVisibility(View.VISIBLE);
					break;
				case VisibilityAction.HIDE_ANIMATED:
					fade(View.GONE, 1.0f, 0.0f);
					break;
				case VisibilityAction.HIDE_INSTANTLY:
					setVisibility(View.GONE);
					break;
			}
		}
	};

	public void show(boolean animate) {
		myVisibilityHandler.sendEmptyMessage(animate ? VisibilityAction.SHOW_ANIMATED : VisibilityAction.SHOW_INSTANTLY);
	}

	public void hide(boolean animate) {
		myVisibilityHandler.sendEmptyMessage(animate ? VisibilityAction.HIDE_ANIMATED : VisibilityAction.HIDE_INSTANTLY);
	}
	
	private void fade(int visibility, float startAlpha, float endAlpha) {
		final AlphaAnimation animation = new AlphaAnimation(startAlpha, endAlpha);
		animation.setDuration(500);
		startAnimation(animation);
		setVisibility(visibility);
	}
	
	public void updateStates() {
		final ZLApplication application = ZLApplication.Instance();
		for (ActionButton button : myButtons) {
			button.setEnabled(application.isActionEnabled(button.ActionId));
		}
	}
	
	@Override
	public boolean hasFocus() {
		for (ActionButton button : myButtons) {
			if (button.hasFocus()) {
				return true;
			}
		}
		return false;
	}

	public void setExtension(View view) {
		if (view != null) {
			myPlateLayout.removeAllViews();
			myPlateLayout.addView(view);
		}
	}
}
",False,118,7,30,6,13,2,1,L6
178,org.geometerplus.android.fbreader.SQLiteBooksDatabase.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import android.database.SQLException;
import android.database.Cursor;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.dialogs.ZLDialogManager;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.options.ZLIntegerOption;
import org.geometerplus.zlibrary.core.config.ZLConfig;
import org.geometerplus.zlibrary.text.view.ZLTextPosition;
import org.geometerplus.zlibrary.text.view.ZLTextFixedPosition;
import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.library.*;

final class SQLiteBooksDatabase extends BooksDatabase {
	private final SQLiteDatabase myDatabase;

	SQLiteBooksDatabase() {
		myDatabase = ZLAndroidApplication.Instance().openOrCreateDatabase(""books.db"", Context.MODE_PRIVATE, null);
		migrate();
	}

	protected void executeAsATransaction(Runnable actions) {
		myDatabase.beginTransaction();
		try {
			actions.run();
			myDatabase.setTransactionSuccessful();
		} finally {
			myDatabase.endTransaction();
		}
	}

	private void migrate() {
		final int version = myDatabase.getVersion();
		final int currentVersion = 10;
		if (version >= currentVersion) {
			return;
		}
		ZLDialogManager.Instance().wait((version == 0) ? ""creatingBooksDatabase"" : ""updatingBooksDatabase"", new Runnable() {
			public void run() {
				myDatabase.beginTransaction();

				switch (version) {
					case 0:
						createTables();
					case 1:
						updateTables1();
					case 2:
						updateTables2();
					case 3:
						updateTables3();
					case 4:
						updateTables4();
					case 5:
						updateTables5();
					case 6:
						updateTables6();
					case 7:
						updateTables7();
					case 8:
						updateTables8();
					case 9:
						updateTables9();
				}
				myDatabase.setTransactionSuccessful();
				myDatabase.endTransaction();

				myDatabase.execSQL(""VACUUM"");
				myDatabase.setVersion(currentVersion);
			}
		});
	}

	private static void bindString(SQLiteStatement statement, int index, String value) {
		if (value != null) {
			statement.bindString(index, value);
		} else {
			statement.bindNull(index);
		}
	}

	private static void bindDate(SQLiteStatement statement, int index, Date value) {
		if (value != null) {
			statement.bindLong(index, value.getTime());
		} else {
			statement.bindNull(index);
		}
	}

	private static Date getDate(Cursor cursor, int index) {
		if (cursor.isNull(index)) {
			return null;
		}
		return new Date(cursor.getLong(index));
	}

	protected Book loadBook(long bookId) {
		Book book = null;
		final Cursor cursor = myDatabase.rawQuery(""SELECT file_id,title,encoding,language FROM Books WHERE book_id = "" + bookId, null);
		if (cursor.moveToNext()) {
			book = createBook(
				bookId, cursor.getLong(0), cursor.getString(1), cursor.getString(2), cursor.getString(3)
			);
		}
		cursor.close();
		return book;
	}

	protected Book loadBookByFile(long fileId, ZLFile file) {
		if (fileId == -1) {
			return null;
		}
		Book book = null;
		final Cursor cursor = myDatabase.rawQuery(""SELECT book_id,title,encoding,language FROM Books WHERE file_id = "" + fileId, null);
		if (cursor.moveToNext()) {
			book = createBook(
				cursor.getLong(0), file, cursor.getString(1), cursor.getString(2), cursor.getString(3)
			);
		}
		cursor.close();
		return book;
	}

	private boolean myTagCacheIsInitialized;
	private final HashMap<Tag,Long> myIdByTag = new HashMap<Tag,Long>();
	private final HashMap<Long,Tag> myTagById = new HashMap<Long,Tag>();

	private void initTagCache() {
		if (myTagCacheIsInitialized) {
			return;
		}
		myTagCacheIsInitialized = true;
        
		Cursor cursor = myDatabase.rawQuery(""SELECT tag_id,parent_id,name FROM Tags ORDER BY tag_id"", null);
		while (cursor.moveToNext()) {
			long id = cursor.getLong(0);
			if (myTagById.get(id) == null) {
				final Tag tag = Tag.getTag(myTagById.get(cursor.getLong(1)), cursor.getString(2));
				myIdByTag.put(tag, id);
				myTagById.put(id, tag);
			}
		}
		cursor.close();
	}

	@Override
	protected Map<Long,Book> listBooks(FileInfoSet infos) {
		Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id,file_id,title,encoding,language FROM Books"", null
		);
		final int count = cursor.getCount();
		final HashMap<Long,Book> booksById = new HashMap<Long,Book>(count);
		final HashMap<Long,Book> booksByFileId = new HashMap<Long,Book>(count);
		while (cursor.moveToNext()) {
			final long id = cursor.getLong(0);
			final long fileId = cursor.getLong(1);
			final Book book = createBook(
				id, infos.getFile(fileId), cursor.getString(2), cursor.getString(3), cursor.getString(4)
			);
			if (book != null) {
				booksById.put(id, book);
				booksByFileId.put(fileId, book);
			}
		}
		cursor.close();

		initTagCache();

		cursor = myDatabase.rawQuery(
			""SELECT author_id,name,sort_key FROM Authors"", null
		);
		final HashMap<Long,Author> authorById = new HashMap<Long,Author>(cursor.getCount());
		while (cursor.moveToNext()) {
			authorById.put(cursor.getLong(0), new Author(cursor.getString(1), cursor.getString(2)));
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,author_id FROM BookAuthor ORDER BY author_index"", null
		);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				Author author = authorById.get(cursor.getLong(1));
				if (author != null) {
					addAuthor(book, author);
				}
			}
		}
		cursor.close();

		cursor = myDatabase.rawQuery(""SELECT book_id,tag_id FROM BookTag"", null);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				addTag(book, getTagById(cursor.getLong(1)));
			}
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT series_id,name FROM Series"", null
		);
		final HashMap<Long,String> seriesById = new HashMap<Long,String>(cursor.getCount());
		while (cursor.moveToNext()) {
			seriesById.put(cursor.getLong(0), cursor.getString(1));
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,series_id,book_index FROM BookSeries"", null
		);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				String series = seriesById.get(cursor.getLong(1));
				if (series != null) {
					setSeriesInfo(book, series, cursor.getLong(2));
				}
			}
		}
		cursor.close();
		return booksByFileId;
	}

	private SQLiteStatement myUpdateBookInfoStatement;
	protected void updateBookInfo(long bookId, long fileId, String encoding, String language, String title) {
		if (myUpdateBookInfoStatement == null) {
			myUpdateBookInfoStatement = myDatabase.compileStatement(
				""UPDATE Books SET file_id = ?, encoding = ?, language = ?, title = ? WHERE book_id = ?""
			);
		}
		myUpdateBookInfoStatement.bindLong(1, fileId);
		bindString(myUpdateBookInfoStatement, 2, encoding);
		bindString(myUpdateBookInfoStatement, 3, language);
		myUpdateBookInfoStatement.bindString(4, title);
		myUpdateBookInfoStatement.bindLong(5, bookId);
		myUpdateBookInfoStatement.execute();
	}

	private SQLiteStatement myInsertBookInfoStatement;
	protected long insertBookInfo(ZLFile file, String encoding, String language, String title) {
		if (myInsertBookInfoStatement == null) {
			myInsertBookInfoStatement = myDatabase.compileStatement(
				""INSERT INTO Books (encoding,language,title,file_id) VALUES (?,?,?,?)""
			);
		}
		bindString(myInsertBookInfoStatement, 1, encoding);
		bindString(myInsertBookInfoStatement, 2, language);
		myInsertBookInfoStatement.bindString(3, title);
		final FileInfoSet infoSet = new FileInfoSet(file);
		myInsertBookInfoStatement.bindLong(4, infoSet.getId(file));
		return myInsertBookInfoStatement.executeInsert();
	}

	private SQLiteStatement myDeleteBookAuthorsStatement;
	protected void deleteAllBookAuthors(long bookId) {
		if (myDeleteBookAuthorsStatement == null) {
			myDeleteBookAuthorsStatement = myDatabase.compileStatement(
				""DELETE FROM BookAuthor WHERE book_id = ?""
			);
		}
		myDeleteBookAuthorsStatement.bindLong(1, bookId);
		myDeleteBookAuthorsStatement.execute();
	}

	private SQLiteStatement myGetAuthorIdStatement;
	private SQLiteStatement myInsertAuthorStatement;
	private SQLiteStatement myInsertBookAuthorStatement;
	protected void saveBookAuthorInfo(long bookId, long index, Author author) {
		if (myGetAuthorIdStatement == null) {
			myGetAuthorIdStatement = myDatabase.compileStatement(
				""SELECT author_id FROM Authors WHERE name = ? AND sort_key = ?""
			);
			myInsertAuthorStatement = myDatabase.compileStatement(
				""INSERT INTO Authors (name,sort_key) VALUES (?,?)""
			);
			myInsertBookAuthorStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookAuthor (book_id,author_id,author_index) VALUES (?,?,?)""
			);
		}

		long authorId;
		try {
			myGetAuthorIdStatement.bindString(1, author.DisplayName);
			myGetAuthorIdStatement.bindString(2, author.SortKey);
			authorId = myGetAuthorIdStatement.simpleQueryForLong();
		} catch (SQLException e) {
			myInsertAuthorStatement.bindString(1, author.DisplayName);
			myInsertAuthorStatement.bindString(2, author.SortKey);
			authorId = myInsertAuthorStatement.executeInsert();
		}
		myInsertBookAuthorStatement.bindLong(1, bookId);
		myInsertBookAuthorStatement.bindLong(2, authorId);
		myInsertBookAuthorStatement.bindLong(3, index);
		myInsertBookAuthorStatement.execute();
	}

	protected List<Author> loadAuthors(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Authors.name,Authors.sort_key FROM BookAuthor INNER JOIN Authors ON Authors.author_id = BookAuthor.author_id WHERE BookAuthor.book_id = ?"", new String[] { """" + bookId });
		if (!cursor.moveToNext()) {
			return null;
		}
		final ArrayList<Author> list = new ArrayList<Author>(cursor.getCount());
		do {
			list.add(new Author(cursor.getString(0), cursor.getString(1)));
		} while (cursor.moveToNext());
		cursor.close();	
		return list;
	}

	private SQLiteStatement myGetTagIdStatement;
	private SQLiteStatement myCreateTagIdStatement;
	private long getTagId(Tag tag) {
		if (myGetTagIdStatement == null) {
			myGetTagIdStatement = myDatabase.compileStatement(
				""SELECT tag_id FROM Tags WHERE parent_id = ? AND name = ?""
			);
			myCreateTagIdStatement = myDatabase.compileStatement(
				""INSERT INTO Tags (parent_id,name) VALUES (?,?)""
			);
		}	
		{
			final Long id = myIdByTag.get(tag);
			if (id != null) {
				return id;
			}
		}
		if (tag.Parent != null) {
			myGetTagIdStatement.bindLong(1, getTagId(tag.Parent));
		} else {
			myGetTagIdStatement.bindNull(1);
		}
		myGetTagIdStatement.bindString(2, tag.Name);
		long id;
		try {
			id = myGetTagIdStatement.simpleQueryForLong();
		} catch (SQLException e) {
			if (tag.Parent != null) {
				myCreateTagIdStatement.bindLong(1, getTagId(tag.Parent));
			} else {
				myCreateTagIdStatement.bindNull(1);
			}
			myCreateTagIdStatement.bindString(2, tag.Name);
			id = myCreateTagIdStatement.executeInsert();
		}
		myIdByTag.put(tag, id);
		myTagById.put(id, tag);
		return id;
	}

	private SQLiteStatement myDeleteBookTagsStatement;
	protected void deleteAllBookTags(long bookId) {
		if (myDeleteBookTagsStatement == null) {
			myDeleteBookTagsStatement = myDatabase.compileStatement(
				""DELETE FROM BookTag WHERE book_id = ?""
			);
		}
		myDeleteBookTagsStatement.bindLong(1, bookId);
		myDeleteBookTagsStatement.execute();
	}

	private SQLiteStatement myInsertBookTagStatement;
	protected void saveBookTagInfo(long bookId, Tag tag) {
		if (myInsertBookTagStatement == null) {
			myInsertBookTagStatement = myDatabase.compileStatement(
				""INSERT INTO BookTag (book_id,tag_id) VALUES (?,?)""
			);
		}
		myInsertBookTagStatement.bindLong(1, bookId);
		myInsertBookTagStatement.bindLong(2, getTagId(tag));
		myInsertBookTagStatement.execute();
	}

	private Tag getTagById(long id) {
		Tag tag = myTagById.get(id);
		if (tag == null) {
			final Cursor cursor = myDatabase.rawQuery(""SELECT parent_id,name FROM Tags WHERE tag_id = ?"", new String[] { """" + id });
			if (cursor.moveToNext()) {
				final Tag parent = cursor.isNull(0) ? null : getTagById(cursor.getLong(0));
				tag = Tag.getTag(parent, cursor.getString(1));
				myIdByTag.put(tag, id);
				myTagById.put(id, tag);
			}
			cursor.close();
		}
		return tag;
	}

	protected List<Tag> loadTags(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Tags.tag_id FROM BookTag INNER JOIN Tags ON Tags.tag_id = BookTag.tag_id WHERE BookTag.book_id = ?"", new String[] { """" + bookId });
		if (!cursor.moveToNext()) {
			return null;
		}
		ArrayList<Tag> list = new ArrayList<Tag>(cursor.getCount());
		do {
			list.add(getTagById(cursor.getLong(0)));
		} while (cursor.moveToNext());
		cursor.close();	
		return list;
	}

	private SQLiteStatement myGetSeriesIdStatement;
	private SQLiteStatement myInsertSeriesStatement;
	private SQLiteStatement myInsertBookSeriesStatement;
	private SQLiteStatement myDeleteBookSeriesStatement;
	protected void saveBookSeriesInfo(long bookId, SeriesInfo seriesInfo) {
		if (myGetSeriesIdStatement == null) {
			myGetSeriesIdStatement = myDatabase.compileStatement(
				""SELECT series_id FROM Series WHERE name = ?""
			);
			myInsertSeriesStatement = myDatabase.compileStatement(
				""INSERT INTO Series (name) VALUES (?)""
			);
			myInsertBookSeriesStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookSeries (book_id,series_id,book_index) VALUES (?,?,?)""
			);
			myDeleteBookSeriesStatement = myDatabase.compileStatement(
				""DELETE FROM BookSeries WHERE book_id = ?""
			);
		}

		if (seriesInfo == null) {
			myDeleteBookSeriesStatement.bindLong(1, bookId);
			myDeleteBookSeriesStatement.execute();
		} else {
			long seriesId;
			try {
				myGetSeriesIdStatement.bindString(1, seriesInfo.Name);
				seriesId = myGetSeriesIdStatement.simpleQueryForLong();
			} catch (SQLException e) {
				myInsertSeriesStatement.bindString(1, seriesInfo.Name);
				seriesId = myInsertSeriesStatement.executeInsert();
			}
			myInsertBookSeriesStatement.bindLong(1, bookId);
			myInsertBookSeriesStatement.bindLong(2, seriesId);
			myInsertBookSeriesStatement.bindLong(3, seriesInfo.Index);
			myInsertBookSeriesStatement.execute();
		}
	}

	protected SeriesInfo loadSeriesInfo(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Series.name,BookSeries.book_index FROM BookSeries INNER JOIN Series ON Series.series_id = BookSeries.series_id WHERE BookSeries.book_id = ?"", new String[] { """" + bookId });
		SeriesInfo info = null;
		if (cursor.moveToNext()) {
			info = new SeriesInfo(cursor.getString(0), cursor.getLong(1));
		}
		cursor.close();	
		return info;
	}

	private SQLiteStatement myRemoveFileInfoStatement;
	protected void removeFileInfo(long fileId) {
		if (fileId == -1) {
			return;
		}
		if (myRemoveFileInfoStatement == null) {
			myRemoveFileInfoStatement = myDatabase.compileStatement(
				""DELETE FROM Files WHERE file_id = ?""
			);
		}
		myRemoveFileInfoStatement.bindLong(1, fileId);
		myRemoveFileInfoStatement.execute();
	}

	private SQLiteStatement myInsertFileInfoStatement;
	private SQLiteStatement myUpdateFileInfoStatement;
	protected void saveFileInfo(FileInfo fileInfo) {
		final long id = fileInfo.Id;
		SQLiteStatement statement;
		if (id == -1) {
			if (myInsertFileInfoStatement == null) {
				myInsertFileInfoStatement = myDatabase.compileStatement(
					""INSERT OR REPLACE INTO Files (name,parent_id,size) VALUES (?,?,?)""
				);
			}
			statement = myInsertFileInfoStatement;
		} else {
			if (myUpdateFileInfoStatement == null) {
				myUpdateFileInfoStatement = myDatabase.compileStatement(
					""UPDATE Files SET name = ?, parent_id = ?, size = ? WHERE file_id = ?""
				);
			}
			statement = myUpdateFileInfoStatement;
		}
		statement.bindString(1, fileInfo.Name);
		final FileInfo parent = fileInfo.Parent;
		if (parent != null) {
			statement.bindLong(2, parent.Id);
		} else {
			statement.bindNull(2);
		}
		final long size = fileInfo.FileSize;
		if (size != -1) {
			statement.bindLong(3, size);
		} else {
			statement.bindNull(3);
		}
		if (id == -1) {
			fileInfo.Id = statement.executeInsert();
		} else {
			statement.bindLong(4, id);
			statement.execute();
		}
	}

	protected Collection<FileInfo> loadFileInfos() {
		Cursor cursor = myDatabase.rawQuery(
			""SELECT file_id,name,parent_id,size FROM Files"", null
		);
		HashMap<Long,FileInfo> infosById = new HashMap<Long,FileInfo>(cursor.getCount());
		while (cursor.moveToNext()) {
			final long id = cursor.getLong(0);
			final FileInfo info = createFileInfo(id,
				cursor.getString(1),
				cursor.isNull(2) ? null : infosById.get(cursor.getLong(2))
			);
			if (!cursor.isNull(3)) {
				info.FileSize = cursor.getLong(3);
			}
			infosById.put(id, info);
		}
		cursor.close();
		return infosById.values();
	}

	protected Collection<FileInfo> loadFileInfos(ZLFile file) {
		final LinkedList<ZLFile> fileStack = new LinkedList<ZLFile>();
		for (; file != null; file = file.getParent()) {
			fileStack.addFirst(file);
		}

		final ArrayList<FileInfo> infos = new ArrayList<FileInfo>(fileStack.size());
		final String[] parameters = { null };
		FileInfo current = null;
		for (ZLFile f : fileStack) {
			parameters[0] = f.getName(false);
			final Cursor cursor = myDatabase.rawQuery(
				(current == null) ?
					""SELECT file_id,size FROM Files WHERE name = ?"" :
					""SELECT file_id,size FROM Files WHERE parent_id = "" + current.Id + "" AND name = ?"",
				parameters
			);
			if (cursor.moveToNext()) {
				current = createFileInfo(cursor.getLong(0), parameters[0], current);
				if (!cursor.isNull(1)) {
					current.FileSize = cursor.getLong(1);
				}
				infos.add(current);
				cursor.close();
			} else {
				cursor.close();
				break;
			}
		}

		return infos;
	}

	protected Collection<FileInfo> loadFileInfos(long fileId) {
		final ArrayList<FileInfo> infos = new ArrayList<FileInfo>();
		while (fileId != -1) {
			final Cursor cursor = myDatabase.rawQuery(
				""SELECT name,size,parent_id FROM Files WHERE file_id = "" + fileId, null
			);
			if (cursor.moveToNext()) {
				FileInfo info = createFileInfo(fileId, cursor.getString(0), null);
				if (!cursor.isNull(1)) {
					info.FileSize = cursor.getLong(1);
				}
				infos.add(0, info);
				fileId = cursor.isNull(2) ? -1 : cursor.getLong(2);
			} else {
				fileId = -1;
			}
			cursor.close();
		}
		for (int i = 1; i < infos.size(); ++i) {
			final FileInfo oldInfo = infos.get(i);
			final FileInfo newInfo = createFileInfo(oldInfo.Id, oldInfo.Name, infos.get(i - 1));
			newInfo.FileSize = oldInfo.FileSize;
			infos.set(i, newInfo);
		}
		return infos;
	}

	private SQLiteStatement mySaveRecentBookStatement;
	protected void saveRecentBookIds(final List<Long> ids) {
		if (mySaveRecentBookStatement == null) {
			mySaveRecentBookStatement = myDatabase.compileStatement(
				""INSERT INTO RecentBooks (book_id) VALUES (?)""
			);
		}
		executeAsATransaction(new Runnable() {
			public void run() {
				myDatabase.delete(""RecentBooks"", null, null);
				for (long id : ids) {
					mySaveRecentBookStatement.bindLong(1, id);
					mySaveRecentBookStatement.execute();
				}
			}
		});
	}

	protected List<Long> listRecentBookIds() {
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id FROM RecentBooks ORDER BY book_index"", null
		);
		final LinkedList<Long> ids = new LinkedList<Long>();
		while (cursor.moveToNext()) {
			ids.add(cursor.getLong(0));
		}
		cursor.close();
		return ids;
	}

	protected List<Bookmark> listBookmarks(long bookId) {
		LinkedList<Bookmark> list = new LinkedList<Bookmark>();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT Bookmarks.bookmark_id,Bookmarks.book_id,Books.title,Bookmarks.bookmark_text,Bookmarks.creation_time,Bookmarks.modification_time,Bookmarks.access_time,Bookmarks.access_counter,Bookmarks.model_id,Bookmarks.paragraph,Bookmarks.word,Bookmarks.char FROM Bookmarks INNER JOIN Books ON Books.book_id = Bookmarks.book_id WHERE book_id = ?"", new String[] { """" + bookId }
		);
		while (cursor.moveToNext()) {
			list.add(createBookmark(
				cursor.getLong(0),
				cursor.getLong(1),
				cursor.getString(2),
				cursor.getString(3),
				getDate(cursor, 4),
				getDate(cursor, 5),
				getDate(cursor, 6),
				(int)cursor.getLong(7),
				cursor.getString(8),
				(int)cursor.getLong(9),
				(int)cursor.getLong(10),
				(int)cursor.getLong(11)
			));
		}
		cursor.close();
		return list;
	}

	protected List<Bookmark> listAllBookmarks() {
		LinkedList<Bookmark> list = new LinkedList<Bookmark>();
		myDatabase.execSQL(""DELETE FROM Bookmarks WHERE book_id = -1"");
		Cursor cursor = myDatabase.rawQuery(
			""SELECT Bookmarks.bookmark_id,Bookmarks.book_id,Books.title,Bookmarks.bookmark_text,Bookmarks.creation_time,Bookmarks.modification_time,Bookmarks.access_time,Bookmarks.access_counter,Bookmarks.model_id,Bookmarks.paragraph,Bookmarks.word,Bookmarks.char FROM Bookmarks INNER JOIN Books ON Books.book_id = Bookmarks.book_id"", null
		);
		while (cursor.moveToNext()) {
			list.add(createBookmark(
				cursor.getLong(0),
				cursor.getLong(1),
				cursor.getString(2),
				cursor.getString(3),
				getDate(cursor, 4),
				getDate(cursor, 5),
				getDate(cursor, 6),
				(int)cursor.getLong(7),
				cursor.getString(8),
				(int)cursor.getLong(9),
				(int)cursor.getLong(10),
				(int)cursor.getLong(11)
			));
		}
		cursor.close();
		return list;
	}

	private SQLiteStatement myInsertBookmarkStatement;
	private SQLiteStatement myUpdateBookmarkStatement;
	protected long saveBookmark(Bookmark bookmark) {
		SQLiteStatement statement;
		if (bookmark.getId() == -1) {
			if (myInsertBookmarkStatement == null) {
				myInsertBookmarkStatement = myDatabase.compileStatement(
					""INSERT INTO Bookmarks (book_id,bookmark_text,creation_time,modification_time,access_time,access_counter,model_id,paragraph,word,char) VALUES (?,?,?,?,?,?,?,?,?,?)""
				);
			}
			statement = myInsertBookmarkStatement;
		} else {
			if (myUpdateBookmarkStatement == null) {
				myUpdateBookmarkStatement = myDatabase.compileStatement(
					""UPDATE Bookmarks SET book_id = ?, bookmark_text = ?, creation_time =?, modification_time = ?,access_time = ?, access_counter = ?, model_id = ?, paragraph = ?, word = ?, char = ? WHERE bookmark_id = ?""
				);
			}
			statement = myUpdateBookmarkStatement;
		}

		statement.bindLong(1, bookmark.getBookId());
		statement.bindString(2, bookmark.getText());
		bindDate(statement, 3, bookmark.getTime(Bookmark.CREATION));
		bindDate(statement, 4, bookmark.getTime(Bookmark.MODIFICATION));
		bindDate(statement, 5, bookmark.getTime(Bookmark.ACCESS));
		statement.bindLong(6, bookmark.getAccessCount());
		bindString(statement, 7, bookmark.getModelId());
		statement.bindLong(8, bookmark.ParagraphIndex);
		statement.bindLong(9, bookmark.ElementIndex);
		statement.bindLong(10, bookmark.CharIndex);

		if (statement == myInsertBookmarkStatement) {
			return statement.executeInsert();
		} else {
			final long id = bookmark.getId();
			statement.bindLong(11, id);
			statement.execute();
			return id;
		}
	}

	private SQLiteStatement myDeleteBookmarkStatement;
	protected void deleteBookmark(Bookmark bookmark) {
		if (myDeleteBookmarkStatement == null) {
			myDeleteBookmarkStatement = myDatabase.compileStatement(
				""DELETE FROM Bookmarks WHERE bookmark_id = ?""
			);
		}
		myDeleteBookmarkStatement.bindLong(1, bookmark.getId());
		myDeleteBookmarkStatement.execute();
	}

	protected ZLTextPosition getStoredPosition(long bookId) {
		ZLTextPosition position = null;
		Cursor cursor = myDatabase.rawQuery(
			""SELECT paragraph,word,char FROM BookState WHERE book_id = "" + bookId, null
		);
		if (cursor.moveToNext()) {
			position = new ZLTextFixedPosition(
				(int)cursor.getLong(0),
				(int)cursor.getLong(1),
				(int)cursor.getLong(2)
			);
		}
		cursor.close();
		return position;
	}

	private SQLiteStatement myStorePositionStatement;
	protected void storePosition(long bookId, ZLTextPosition position) {
		if (myStorePositionStatement == null) {
			myStorePositionStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookState (book_id,paragraph,word,char) VALUES (?,?,?,?)""
			);
		}
		myStorePositionStatement.bindLong(1, bookId);
		myStorePositionStatement.bindLong(2, position.getParagraphIndex());
		myStorePositionStatement.bindLong(3, position.getElementIndex());
		myStorePositionStatement.bindLong(4, position.getCharIndex());
		myStorePositionStatement.execute();
	}

	private SQLiteStatement myInsertIntoBookListStatement;
	protected boolean insertIntoBookList(long bookId) {
		if (myInsertIntoBookListStatement == null) {
			myInsertIntoBookListStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO BookList(book_id) VALUES (?)""
			);
		}
		myInsertIntoBookListStatement.bindLong(1, bookId);
		myInsertIntoBookListStatement.execute();
		return true;
	}

	private SQLiteStatement myDeleteFromBookListStatement;
	protected boolean deleteFromBookList(long bookId) {
		if (myDeleteFromBookListStatement == null) {
			myDeleteFromBookListStatement = myDatabase.compileStatement(
				""DELETE FROM BookList WHERE book_id = ?""
			);
		}
		myDeleteFromBookListStatement.bindLong(1, bookId);
		myDeleteFromBookListStatement.execute();
		return true;
	}

	private SQLiteStatement myCheckBookListStatement;
	protected boolean checkBookList(long bookId) {
		if (myCheckBookListStatement == null) {
			myCheckBookListStatement = myDatabase.compileStatement(
				""SELECT COUNT(*) FROM BookList WHERE book_id = ?""
			);
		}
		myCheckBookListStatement.bindLong(1, bookId);
		return myCheckBookListStatement.simpleQueryForLong() > 0;
	}


	private void createTables() {
		myDatabase.execSQL(
			""CREATE TABLE Books("" +
				""book_id INTEGER PRIMARY KEY,"" +
				""encoding TEXT,"" +
				""language TEXT,"" +
				""title TEXT NOT NULL,"" +
				""file_name TEXT UNIQUE NOT NULL)"");
		myDatabase.execSQL(
			""CREATE TABLE Authors("" +
				""author_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""sort_key TEXT NOT NULL,"" +
				""CONSTRAINT Authors_Unique UNIQUE (name, sort_key))"");
		myDatabase.execSQL(
			""CREATE TABLE BookAuthor("" +
				""author_id INTEGER NOT NULL REFERENCES Authors(author_id),"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""author_index INTEGER NOT NULL,"" +
				""CONSTRAINT BookAuthor_Unique0 UNIQUE (author_id, book_id),"" +
				""CONSTRAINT BookAuthor_Unique1 UNIQUE (book_id, author_index))"");
		myDatabase.execSQL(
			""CREATE TABLE Series("" +
				""series_id INTEGER PRIMARY KEY,"" +
				""name TEXT UNIQUE NOT NULL)"");
		myDatabase.execSQL(
			""CREATE TABLE BookSeries("" +
				""series_id INTEGER NOT NULL REFERENCES Series(series_id),"" +
				""book_id INTEGER NOT NULL UNIQUE REFERENCES Books(book_id),"" +
				""book_index INTEGER)"");
		myDatabase.execSQL(
			""CREATE TABLE Tags("" +
				""tag_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent INTEGER REFERENCES Tags(tag_id),"" +
				""CONSTRAINT Tags_Unique UNIQUE (name, parent))"");
		myDatabase.execSQL(
			""CREATE TABLE BookTag("" +
				""tag_id INTEGER REFERENCES Tags(tag_id),"" +
				""book_id INTEGER REFERENCES Books(book_id),"" +
				""CONSTRAINT BookTag_Unique UNIQUE (tag_id, book_id))"");
	}

	private void updateTables1() {
		myDatabase.execSQL(""ALTER TABLE Tags RENAME TO Tags_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE Tags("" +
				""tag_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent_id INTEGER REFERENCES Tags(tag_id),"" +
				""CONSTRAINT Tags_Unique UNIQUE (name, parent_id))"");
		myDatabase.execSQL(""INSERT INTO Tags (tag_id,name,parent_id) SELECT tag_id,name,parent FROM Tags_Obsolete"");
		myDatabase.execSQL(""DROP TABLE Tags_Obsolete"");

		myDatabase.execSQL(""ALTER TABLE BookTag RENAME TO BookTag_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE BookTag("" +
				""tag_id INTEGER NOT NULL REFERENCES Tags(tag_id),"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""CONSTRAINT BookTag_Unique UNIQUE (tag_id, book_id))"");
		myDatabase.execSQL(""INSERT INTO BookTag (tag_id,book_id) SELECT tag_id,book_id FROM BookTag_Obsolete"");
		myDatabase.execSQL(""DROP TABLE BookTag_Obsolete"");
	}

	private void updateTables2() {
		myDatabase.execSQL(""CREATE INDEX BookAuthor_BookIndex ON BookAuthor (book_id)"");
		myDatabase.execSQL(""CREATE INDEX BookTag_BookIndex ON BookTag (book_id)"");
		myDatabase.execSQL(""CREATE INDEX BookSeries_BookIndex ON BookSeries (book_id)"");
	}

	private void updateTables3() {
		myDatabase.execSQL(
			""CREATE TABLE Files("" +
				""file_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent_id INTEGER REFERENCES Files(file_id),"" +
				""size INTEGER,"" +
				""CONSTRAINT Files_Unique UNIQUE (name, parent_id))"");
	}

	private void updateTables4() {
		final FileInfoSet fileInfos = new FileInfoSet();
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT file_name FROM Books"", null
		);
		while (cursor.moveToNext()) {
			fileInfos.check(ZLFile.createFileByPath(cursor.getString(0)).getPhysicalFile());
		}
		cursor.close();
		fileInfos.save();

		myDatabase.execSQL(
			""CREATE TABLE RecentBooks("" +
				""book_index INTEGER PRIMARY KEY,"" +
				""book_id INTEGER REFERENCES Books(book_id))"");
		final ArrayList<Long> ids = new ArrayList<Long>();

		final SQLiteStatement statement = myDatabase.compileStatement(
			""SELECT book_id FROM Books WHERE file_name = ?""
		);

		for (int i = 0; i < 20; ++i) {
			final ZLStringOption option = new ZLStringOption(""LastOpenedBooks"", ""Book"" + i, """");
			final String fileName = option.getValue();
			option.setValue("""");
			try {
				statement.bindString(1, fileName);
				final long bookId = statement.simpleQueryForLong();
				if (bookId != -1) {
					ids.add(bookId);
				}
			} catch (SQLException e) {
			}
		}
		saveRecentBookIds(ids);
	}

	private void updateTables5() {
		myDatabase.execSQL(
			""CREATE TABLE Bookmarks("" +
				""bookmark_id INTEGER PRIMARY KEY,"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""bookmark_text TEXT NOT NULL,"" +
				""creation_time INTEGER NOT NULL,"" +
				""modification_time INTEGER,"" +
				""access_time INTEGER,"" +
				""access_counter INTEGER NOT NULL,"" +
				""paragraph INTEGER NOT NULL,"" +
				""word INTEGER NOT NULL,"" +
				""char INTEGER NOT NULL)"");

		myDatabase.execSQL(
			""CREATE TABLE BookState("" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books(book_id),"" +
				""paragraph INTEGER NOT NULL,"" +
				""word INTEGER NOT NULL,"" +
				""char INTEGER NOT NULL)"");
		Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id,file_name FROM Books"", null
		);
		final SQLiteStatement statement = myDatabase.compileStatement(""INSERT INTO BookState (book_id,paragraph,word,char) VALUES (?,?,?,?)"");
		while (cursor.moveToNext()) {
			final long bookId = cursor.getLong(0);
			final String fileName = cursor.getString(1);
			final int position = new ZLIntegerOption(fileName, ""PositionInBuffer"", 0).getValue();
			final int paragraph = new ZLIntegerOption(fileName, ""Paragraph_"" + position, 0).getValue();
			final int word = new ZLIntegerOption(fileName, ""Word_"" + position, 0).getValue();
			final int chr = new ZLIntegerOption(fileName, ""Char_"" + position, 0).getValue();
			if ((paragraph != 0) || (word != 0) || (chr != 0)) {
				statement.bindLong(1, bookId);
				statement.bindLong(2, paragraph);
				statement.bindLong(3, word);
				statement.bindLong(4, chr);
				statement.execute();
			}
			ZLConfig.Instance().removeGroup(fileName);
		}
		cursor.close();
	}

	private void updateTables6() {
		myDatabase.execSQL(
			""ALTER TABLE Bookmarks ADD COLUMN model_id TEXT""
		);

		myDatabase.execSQL(
			""ALTER TABLE Books ADD COLUMN file_id INTEGER""
		);

		myDatabase.execSQL(""DELETE FROM Files"");
		final FileInfoSet infoSet = new FileInfoSet();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT file_name FROM Books"", null
		);
		while (cursor.moveToNext()) {
			infoSet.check(ZLFile.createFileByPath(cursor.getString(0)).getPhysicalFile());
		}
		cursor.close();
		infoSet.save();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,file_name FROM Books"", null
		);
		final SQLiteStatement deleteStatement = myDatabase.compileStatement(""DELETE FROM Books WHERE book_id = ?"");
		final SQLiteStatement updateStatement = myDatabase.compileStatement(""UPDATE Books SET file_id = ? WHERE book_id = ?"");
		while (cursor.moveToNext()) {
			final long bookId = cursor.getLong(0);
			final long fileId = infoSet.getId(ZLFile.createFileByPath(cursor.getString(1)));

			if (fileId == -1) {
				deleteStatement.bindLong(1, bookId);
				deleteStatement.execute();
			} else {
				updateStatement.bindLong(1, fileId);
				updateStatement.bindLong(2, bookId);
				updateStatement.execute();
			}
		}
		cursor.close();

		myDatabase.execSQL(""ALTER TABLE Books RENAME TO Books_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE Books("" +
				""book_id INTEGER PRIMARY KEY,"" +
				""encoding TEXT,"" +
				""language TEXT,"" +
				""title TEXT NOT NULL,"" +
				""file_id INTEGER UNIQUE NOT NULL REFERENCES Files(file_id))"");
		myDatabase.execSQL(""INSERT INTO Books (book_id,encoding,language,title,file_id) SELECT book_id,encoding,language,title,file_id FROM Books_Obsolete"");
		myDatabase.execSQL(""DROP TABLE Books_Obsolete"");
	}

	private void updateTables7() {
		final ArrayList<Long> seriesIDs = new ArrayList<Long>();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT series_id,name FROM Series"", null
		);
		while (cursor.moveToNext()) {
			if (cursor.getString(1).length() > 200) {
				seriesIDs.add(cursor.getLong(0));
			}
		}
		cursor.close();
		if (seriesIDs.isEmpty()) {
			return;
		}

		final ArrayList<Long> bookIDs = new ArrayList<Long>();
		for (Long id : seriesIDs) {
			cursor = myDatabase.rawQuery(
				""SELECT book_id FROM BookSeries WHERE series_id="" + id, null
			);
			while (cursor.moveToNext()) {
				bookIDs.add(cursor.getLong(0));
			}
			cursor.close();
			myDatabase.execSQL(""DELETE FROM BookSeries WHERE series_id="" + id);
			myDatabase.execSQL(""DELETE FROM Series WHERE series_id="" + id);
		}

		for (Long id : bookIDs) {
			myDatabase.execSQL(""DELETE FROM Books WHERE book_id="" + id);
			myDatabase.execSQL(""DELETE FROM BookAuthor WHERE book_id="" + id);
			myDatabase.execSQL(""DELETE FROM BookTag WHERE book_id="" + id);
		}
	}

	private void updateTables8() {
		myDatabase.execSQL(
			""CREATE TABLE IF NOT EXISTS BookList ( "" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books (book_id))"");
	}

	private void updateTables9() {
		myDatabase.execSQL(""CREATE INDEX BookList_BookIndex ON BookList (book_id)"");
	}
}
",True,374,0,0,10,80,1,17,L6
179,org.geometerplus.android.fbreader.TOCActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.Bundle;
import android.view.*;
import android.widget.*;
import android.app.ListActivity;

import org.geometerplus.zlibrary.core.application.ZLApplication;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;
import org.geometerplus.fbreader.bookmodel.TOCTree;
import org.geometerplus.fbreader.fbreader.FBReader;

public class TOCActivity extends ListActivity {
	private TOCAdapter myAdapter;
	private ZLTree<?> mySelectedItem;

	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		requestWindowFeature(Window.FEATURE_NO_TITLE);

		final FBReader fbreader = (FBReader)ZLApplication.Instance();
		final TOCTree root = fbreader.Model.TOCTree;
		myAdapter = new TOCAdapter(root);
		final ZLTextWordCursor cursor = fbreader.BookTextView.getStartCursor();
		int index = cursor.getParagraphIndex();	
		if (cursor.isEndOfParagraph()) {
			++index;
		}
		TOCTree treeToSelect = null;
		// TODO: process multi-model texts
		for (TOCTree tree : root) {
			final TOCTree.Reference reference = tree.getReference();
			if (reference == null) {
				continue;
			}
			if (reference.ParagraphIndex > index) {
				break;
			}
			treeToSelect = tree;
		}
		myAdapter.selectItem(treeToSelect);
		mySelectedItem = treeToSelect;
	}

	private static final int PROCESS_TREE_ITEM_ID = 0;
	private static final int READ_BOOK_ITEM_ID = 1;

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final TOCTree tree = (TOCTree)myAdapter.getItem(position);
		switch (item.getItemId()) {
			case PROCESS_TREE_ITEM_ID:
				myAdapter.runTreeItem(tree);
				return true;
			case READ_BOOK_ITEM_ID:
				myAdapter.openBookText(tree);
				return true;
		}
		return super.onContextItemSelected(item);
	}

	private final class TOCAdapter extends ZLTreeAdapter {

		TOCAdapter(TOCTree root) {
			super(getListView(), root);
		}

		@Override
		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final TOCTree tree = (TOCTree)getItem(position);
			if (tree.hasChildren()) {
				menu.setHeaderTitle(tree.getText());
				final ZLResource resource = ZLResource.resource(""tocView"");
				menu.add(0, PROCESS_TREE_ITEM_ID, 0, resource.getResource(isOpen(tree) ? ""collapseTree"" : ""expandTree"").getValue());
				menu.add(0, READ_BOOK_ITEM_ID, 0, resource.getResource(""readText"").getValue());
			}
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			final View view = (convertView != null) ? convertView :
				LayoutInflater.from(parent.getContext()).inflate(R.layout.toc_tree_item, parent, false);
			final TOCTree tree = (TOCTree)getItem(position);
			view.setBackgroundColor((tree == mySelectedItem) ? 0xff808080 : 0);
			setIcon((ImageView)view.findViewById(R.id.toc_tree_item_icon), tree);
			((TextView)view.findViewById(R.id.toc_tree_item_text)).setText(tree.getText());
			return view;
		}

		void openBookText(TOCTree tree) {
			final TOCTree.Reference reference = tree.getReference();
			if (reference != null) {
				finish();
				final FBReader fbreader = (FBReader)ZLApplication.Instance();
				fbreader.BookTextView.gotoPosition(reference.ParagraphIndex, 0, 0);
				fbreader.showBookTextView();
			}
		}

		@Override
		protected boolean runTreeItem(ZLTree<?> tree) {
			if (super.runTreeItem(tree)) {
				return true;
			}
			openBookText((TOCTree)tree);
			return true;
		}
	}
}
",False,374,0,0,10,75,1,10,L6
180,org.geometerplus.android.fbreader.ControlButtonPanel.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import android.view.View;
import android.view.ViewGroup;
import android.widget.RelativeLayout;

import org.geometerplus.zlibrary.core.application.ZLApplication;

class ControlButtonPanel implements ZLApplication.ButtonPanel {
	private boolean myVisible;
	protected ControlPanel myControlPanel;

	private static LinkedList<ControlButtonPanel> ourPanels = new LinkedList<ControlButtonPanel>();


	public final void hide() {
		hide(false);
	}

	public void updateStates() {
		if (myControlPanel != null) {
			myControlPanel.updateStates();
		}
	}

	public final void register() {
		ZLApplication.Instance().registerButtonPanel(this);
		ourPanels.add(this);
	}

	public final boolean hasControlPanel() {
		return myControlPanel != null;
	}

	public final void setControlPanel(ControlPanel panel, RelativeLayout root, boolean fillWidth) {
		myControlPanel = panel;
		RelativeLayout.LayoutParams p = new RelativeLayout.LayoutParams(
			fillWidth ? ViewGroup.LayoutParams.FILL_PARENT : ViewGroup.LayoutParams.WRAP_CONTENT,
			RelativeLayout.LayoutParams.WRAP_CONTENT
		);
		p.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
		p.addRule(RelativeLayout.CENTER_HORIZONTAL);
		myControlPanel.setVisibility(View.GONE);
		root.addView(myControlPanel, p);
	}

	private final void removeControlPanel() {
		if (myControlPanel != null) {
			ViewGroup root = (ViewGroup) myControlPanel.getParent();
			myControlPanel.hide(false);
			root.removeView(myControlPanel);
			myControlPanel = null;
		}
	}

	public static void removeControlPanels() {
		for (ControlButtonPanel panel: ourPanels) {
			panel.removeControlPanel();
		}
	}

	public static void restoreVisibilities() {
		for (ControlButtonPanel panel: ourPanels) {
			panel.setVisibility(panel.myVisible);
		}
	}

	public static void saveVisibilities() {
		for (ControlButtonPanel panel: ourPanels) {
			panel.myVisible = panel.getVisibility();
		}
	}

	public static void restoreVisibilitiesFrom(List<Boolean> buffer) {
		Iterator<Boolean> it = buffer.iterator();
		for (ControlButtonPanel panel: ourPanels) {
			panel.setVisibility(it.next());
		}
	}

	public static void saveVisibilitiesTo(List<Boolean> buffer) {
		buffer.clear();
		for (ControlButtonPanel panel: ourPanels) {
			buffer.add(panel.getVisibility());
		}
	}

	public static void hideAllPendingNotify() {
		for (ControlButtonPanel panel: ourPanels) {
			if (panel.myControlPanel != null && panel.getVisibility()) {
				panel.myControlPanel.hide(false);
			}
		}
	}


	public final boolean getVisibility() {
		if (myControlPanel != null) {
			return myControlPanel.getVisibility() == View.VISIBLE;
		}
		return false;
	}

	public final void setVisibility(boolean visible) {
		if (visible) {
			show(false);
		} else {
			hide(false);
		}
	}

	private void hideOthers() {
		for (ControlButtonPanel panel: ourPanels) {
			if (panel != this) {
				panel.hide(false);
			}
		}
	}

	public final void show(boolean animate) {
		if (myControlPanel != null && !getVisibility()) {
			myVisible = true;
			hideOthers();
			onShow();
			myControlPanel.show(animate);
		}
	}

	public final void hide(boolean animate) {
		myVisible = false;
		if (myControlPanel != null && getVisibility()) {
			onHide();
			myControlPanel.hide(animate);
		}
	}


	// callback methods
	public void onShow() {}
	public void onHide() {}
}
",False,118,7,30,6,13,1,2,L6
181,org.geometerplus.android.fbreader.BookmarksActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.os.*;
import android.view.*;
import android.widget.*;
import android.content.*;
import android.app.TabActivity;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.fbreader.FBReader;
import org.geometerplus.fbreader.library.*;

public class BookmarksActivity extends TabActivity implements MenuItem.OnMenuItemClickListener {
	static BookmarksActivity Instance;

	private static final int OPEN_ITEM_ID = 0;
	private static final int EDIT_ITEM_ID = 1;
	private static final int DELETE_ITEM_ID = 2;

	List<Bookmark> AllBooksBookmarks;
	private final List<Bookmark> myThisBookBookmarks = new LinkedList<Bookmark>();
	private final List<Bookmark> mySearchResults = new LinkedList<Bookmark>();

	private ListView myThisBookView;
	private ListView myAllBooksView;
	private ListView mySearchResultsView;

	private final ZLResource myResource = ZLResource.resource(""bookmarksView"");

	private ListView createTab(String tag, int id) {
		final TabHost host = getTabHost();
		final String label = myResource.getResource(tag).getValue();
		host.addTab(host.newTabSpec(tag).setIndicator(label).setContent(id));
		return (ListView)findViewById(id);
	}

	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);

		final TabHost host = getTabHost();
		LayoutInflater.from(this).inflate(R.layout.bookmarks, host.getTabContentView(), true);

		AllBooksBookmarks = Bookmark.bookmarks();
		Collections.sort(AllBooksBookmarks, new Bookmark.ByTimeComparator());
		final FBReader fbreader = (FBReader)FBReader.Instance();

		if (fbreader.Model != null) {
			final long bookId = fbreader.Model.Book.getId();
			for (Bookmark bookmark : AllBooksBookmarks) {
				if (bookmark.getBookId() == bookId) {
					myThisBookBookmarks.add(bookmark);
				}
			}
        
			myThisBookView = createTab(""thisBook"", R.id.this_book);
			new BookmarksAdapter(myThisBookView, myThisBookBookmarks, true);
		} else {
			findViewById(R.id.this_book).setVisibility(View.GONE);
		}

		myAllBooksView = createTab(""allBooks"", R.id.all_books);
		new BookmarksAdapter(myAllBooksView, AllBooksBookmarks, false);

		findViewById(R.id.search_results).setVisibility(View.GONE);
	}

	@Override
	public void onResume() {
		super.onResume();
		Instance = this;
	}

	@Override
	public void onPause() {
		for (Bookmark bookmark : AllBooksBookmarks) {
			bookmark.save();
		}
		super.onPause();
	}

	@Override
	public void onStop() {
		Instance = null;
		super.onStop();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		final MenuItem item = menu.add(
			0, 1, Menu.NONE,
			myResource.getResource(""menu"").getResource(""search"").getValue()
		);
		item.setOnMenuItemClickListener(this);
		item.setIcon(R.drawable.ic_menu_search);
		return true;
	}

	@Override
	public boolean onSearchRequested() {
		final FBReader fbreader = (FBReader)FBReader.Instance();
		startSearch(fbreader.BookmarkSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	void showSearchResultsTab(LinkedList<Bookmark> results) {
		if (mySearchResultsView == null) {
			mySearchResultsView = createTab(""searchResults"", R.id.search_results);
			new BookmarksAdapter(mySearchResultsView, mySearchResults, false);
		} else {
			mySearchResults.clear();
		}
		mySearchResults.addAll(results);
		mySearchResultsView.invalidateViews();
		mySearchResultsView.requestLayout();
		getTabHost().setCurrentTabByTag(""searchResults"");
	}

	public boolean onMenuItemClick(MenuItem item) {
		switch (item.getItemId()) {
			case 1:
				return onSearchRequested();
			default:
				return true;
		}
	}

	private void invalidateAllViews() {
		myThisBookView.invalidateViews();
		myThisBookView.requestLayout();
		myAllBooksView.invalidateViews();
		myAllBooksView.requestLayout();
		if (mySearchResultsView != null) {
			mySearchResultsView.invalidateViews();
			mySearchResultsView.requestLayout();
		}
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final ListView view = (ListView)getTabHost().getCurrentView();
		final Bookmark bookmark = ((BookmarksAdapter)view.getAdapter()).getItem(position);
		switch (item.getItemId()) {
			case OPEN_ITEM_ID:
				gotoBookmark(bookmark);
				return true;
			case EDIT_ITEM_ID:
        		final Intent intent = new Intent(this, BookmarkEditActivity.class);
        		startActivityForResult(intent, 1);
				// TODO: implement
				return true;
			case DELETE_ITEM_ID:
				bookmark.delete();
				myThisBookBookmarks.remove(bookmark);
				AllBooksBookmarks.remove(bookmark);
				mySearchResults.remove(bookmark);
				invalidateAllViews();
				return true;
		}
		return super.onContextItemSelected(item);
	}

	private String createBookmarkText(ZLTextWordCursor cursor) {
		cursor = new ZLTextWordCursor(cursor);

		final StringBuilder builder = new StringBuilder();
		final StringBuilder sentenceBuilder = new StringBuilder();
		final StringBuilder phraseBuilder = new StringBuilder();

		int wordCounter = 0;
		int sentenceCounter = 0;
		int storedWordCounter = 0;
		boolean lineIsNonEmpty = false;
		boolean appendLineBreak = false;
mainLoop:
		while ((wordCounter < 20) && (sentenceCounter < 3)) {
			while (cursor.isEndOfParagraph()) {
				if (!cursor.nextParagraph()) {
					break mainLoop;
				}
				if ((builder.length() > 0) && cursor.getParagraphCursor().isEndOfSection()) {
					break mainLoop;
				}
				if (phraseBuilder.length() > 0) {
					sentenceBuilder.append(phraseBuilder);
					phraseBuilder.delete(0, phraseBuilder.length());
				}
				if (sentenceBuilder.length() > 0) {
					if (appendLineBreak) {
						builder.append(""\n"");
					}
					builder.append(sentenceBuilder);
					sentenceBuilder.delete(0, sentenceBuilder.length());
					++sentenceCounter;
					storedWordCounter = wordCounter;
				}
				lineIsNonEmpty = false;
				if (builder.length() > 0) {
					appendLineBreak = true;
				}
			}
			final ZLTextElement element = cursor.getElement();
			if (element instanceof ZLTextWord) {
				final ZLTextWord word = (ZLTextWord)element;
				if (lineIsNonEmpty) {
					phraseBuilder.append("" "");
				}
				phraseBuilder.append(word.Data, word.Offset, word.Length);
				++wordCounter;
				lineIsNonEmpty = true;
				switch (word.Data[word.Offset + word.Length - 1]) {
					case ',':
					case ':':
					case ';':
					case ')':
						sentenceBuilder.append(phraseBuilder);
						phraseBuilder.delete(0, phraseBuilder.length());
						break;
					case '.':
					case '!':
					case '?':
						++sentenceCounter;
						if (appendLineBreak) {
							builder.append(""\n"");
							appendLineBreak = false;
						}
						sentenceBuilder.append(phraseBuilder);
						phraseBuilder.delete(0, phraseBuilder.length());
						builder.append(sentenceBuilder);
						sentenceBuilder.delete(0, sentenceBuilder.length());
						storedWordCounter = wordCounter;
						break;
				}
			}
			cursor.nextWord();
		}
		if (storedWordCounter < 4) {
			if (sentenceBuilder.length() == 0) {
				sentenceBuilder.append(phraseBuilder);
			}
			if (appendLineBreak) {
				builder.append(""\n"");
			}
			builder.append(sentenceBuilder);
		}
		return builder.toString();
	}

	private void addBookmark() {
		final FBReader fbreader = (FBReader)FBReader.Instance();
		final ZLTextView textView = fbreader.getTextView();
		final ZLTextWordCursor cursor = textView.getStartCursor();

		if (cursor.isNull()) {
			// TODO: implement
			return;
		}

		// TODO: text edit dialog
		final Bookmark bookmark = new Bookmark(
			fbreader.Model.Book,
			createBookmarkText(cursor),
			textView.getModel().getId(),
			cursor
		);
		myThisBookBookmarks.add(0, bookmark);
		AllBooksBookmarks.add(0, bookmark);
		invalidateAllViews();
	}

	private void gotoBookmark(Bookmark bookmark) {
		bookmark.onOpen();
		final FBReader fbreader = (FBReader)FBReader.Instance();
		final long bookId = bookmark.getBookId();
		if ((fbreader.Model == null) || (fbreader.Model.Book.getId() != bookId)) {
			final Book book = Book.getById(bookId);
			if (book != null) {
				finish();
				fbreader.openBook(book, bookmark);
			} else {
				Toast.makeText(
					this,
					ZLResource.resource(""errorMessage"").getResource(""cannotOpenBook"").getValue(),
					Toast.LENGTH_SHORT
				).show();
			}
		} else {
			finish();
			fbreader.gotoBookmark(bookmark);
		}
	}

	private final class BookmarksAdapter extends BaseAdapter implements AdapterView.OnItemClickListener, View.OnCreateContextMenuListener {
		private final List<Bookmark> myBookmarks;
		private final boolean myCurrentBook;

		BookmarksAdapter(ListView listView, List<Bookmark> bookmarks, boolean currentBook) {
			myBookmarks = bookmarks;
			myCurrentBook = currentBook;
			listView.setAdapter(this);
			listView.setOnItemClickListener(this);
			listView.setOnCreateContextMenuListener(this);
		}

		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			if (getItem(position) != null) {
				menu.setHeaderTitle(getItem(position).getText());
				final ZLResource resource = ZLResource.resource(""bookmarksView"");
				menu.add(0, OPEN_ITEM_ID, 0, resource.getResource(""open"").getValue());
				//menu.add(0, EDIT_ITEM_ID, 0, resource.getResource(""edit"").getValue());
				menu.add(0, DELETE_ITEM_ID, 0, resource.getResource(""delete"").getValue());
			}
		}

		public View getView(int position, View convertView, ViewGroup parent) {
			final View view = (convertView != null) ? convertView :
				LayoutInflater.from(parent.getContext()).inflate(R.layout.bookmark_item, parent, false);
			final ImageView imageView = (ImageView)view.findViewById(R.id.bookmark_item_icon);
			final TextView textView = (TextView)view.findViewById(R.id.bookmark_item_text);
			final TextView bookTitleView = (TextView)view.findViewById(R.id.bookmark_item_booktitle);

			final Bookmark bookmark = getItem(position);
			if (bookmark == null) {
				imageView.setVisibility(View.VISIBLE);
				imageView.setImageResource(R.drawable.ic_list_plus);
				textView.setText(ZLResource.resource(""bookmarksView"").getResource(""new"").getValue());
				bookTitleView.setVisibility(View.GONE);
			} else {
				imageView.setVisibility(View.GONE);
				textView.setText(bookmark.getText());
				if (myCurrentBook) {
					bookTitleView.setVisibility(View.GONE);
				} else {
					bookTitleView.setVisibility(View.VISIBLE);
					bookTitleView.setText(bookmark.getBookTitle());
				}
			}
			return view;
		}

		public final boolean areAllItemsEnabled() {
			return true;
		}

		public final boolean isEnabled(int position) {
			return true;
		}

		public final long getItemId(int position) {
			return position;
		}
	
		public final Bookmark getItem(int position) {
			if (myCurrentBook) {
				--position;
			}
			return (position >= 0) ? myBookmarks.get(position) : null;
		}

		public final int getCount() {
			return myCurrentBook ? myBookmarks.size() + 1 : myBookmarks.size();
		}

		public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
			final Bookmark bookmark = getItem(position);
			if (bookmark != null) {
				gotoBookmark(bookmark);
			} else {
				addBookmark();
			}
		}
	}
}
",True,375,1,1,10,85,2,14,L6
182,org.geometerplus.android.fbreader.BookSearchActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.Activity;

import org.geometerplus.fbreader.fbreader.FBReader;
import org.geometerplus.fbreader.library.*;

public class BookSearchActivity extends SearchActivity {
	private LibraryTree myTree;

	@Override
	void onSuccess() {
		LibraryTabActivity.Instance.showSearchResultsTab(myTree);
	}

	/*@Override
	void onFailure() {
	}*/

	@Override
	String getFailureMessageResourceKey() {
		return ""bookNotFound"";
	}

	@Override
	String getWaitMessageResourceKey() {
		return ""search"";
	}

	@Override
	boolean runSearch(final String pattern) {
		final FBReader fbreader = (FBReader)FBReader.Instance();
		fbreader.BookSearchPatternOption.setValue(pattern);
		myTree = Library.Instance().searchBooks(pattern);
		return myTree.hasChildren();
	}

	@Override
	Activity getParentActivity() {
		return LibraryTabActivity.Instance;
	}
}
",False,376,0,0,10,81,0,8,L8
183,org.geometerplus.android.fbreader.TextSearchActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.Activity;

public class TextSearchActivity extends SearchActivity {
	@Override
	void onSuccess() {
		FBReader.Instance.showTextSearchControls(true);
	}

	/*@Override
	void onFailure() {
		FBReader.Instance.showTextSearchControls(false);
	}*/

	@Override
	String getFailureMessageResourceKey() {
		return ""textNotFound"";
	}

	@Override
	String getWaitMessageResourceKey() {
		return ""search"";
	}

	@Override
	boolean runSearch(final String pattern) {
		final org.geometerplus.fbreader.fbreader.FBReader fbreader =
			(org.geometerplus.fbreader.fbreader.FBReader)org.geometerplus.fbreader.fbreader.FBReader.Instance();
		fbreader.TextSearchPatternOption.setValue(pattern);
		return fbreader.getTextView().search(pattern, true, false, false, false) != 0;
	}

	@Override
	Activity getParentActivity() {
		return FBReader.Instance;
	}
}
",False,376,0,0,10,79,0,6,L8
184,org.geometerplus.android.fbreader.SearchActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.*;
import android.app.*;
import android.content.Intent;
import android.widget.Toast;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

abstract class SearchActivity extends Activity {
	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		final SearchManager manager = (SearchManager)getSystemService(SEARCH_SERVICE);
		manager.setOnCancelListener(null);

		final Intent intent = getIntent();
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
	   		final String pattern = intent.getStringExtra(SearchManager.QUERY);
			final Handler successHandler = new Handler() {
				public void handleMessage(Message message) {
					onSuccess();
				}
			};
			final Handler failureHandler = new Handler() {
				public void handleMessage(Message message) {
					Toast.makeText(
						getParentActivity(),
						ZLResource.resource(""errorMessage"").getResource(
							getFailureMessageResourceKey()
						).getValue(),
						Toast.LENGTH_SHORT
					).show();
				}
			};
			final Runnable runnable = new Runnable() {
				public void run() {
					if (runSearch(pattern)) {
						successHandler.sendEmptyMessage(0);
					} else {
						failureHandler.sendEmptyMessage(0);
					}
				}
			};
			((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(getWaitMessageResourceKey(), runnable, getParentActivity());
		}
		finish();
	}

	abstract boolean runSearch(String pattern);
	abstract void onSuccess();
	//abstract void onFailure();
	abstract String getWaitMessageResourceKey();
	abstract String getFailureMessageResourceKey();
	abstract Activity getParentActivity();
}
",False,378,1,3,11,89,3,4,L7
185,org.geometerplus.android.fbreader.BookmarkEditActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.Bundle;
import android.app.Activity;
import android.view.*;
import android.widget.*;
import android.content.Context;


class SimpleContainer extends ViewGroup {
	private final View myEditText;
	private final Button myOkButton;
	private final Button myCancelButton;

	SimpleContainer(Context context) {
		super(context);
		myEditText = new EditText(context);
		myOkButton = new Button(context);
		myOkButton.setText(""ok"");
		myCancelButton = new Button(context);
		myCancelButton.setText(""cancel"");
		addView(myOkButton);
		addView(myCancelButton);
		addView(myEditText);
	}

	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
		final int buttonHeight = Math.max(54, Math.max(myOkButton.getHeight(), myCancelButton.getHeight()));
		myEditText.layout(left + 8, top + 8, right - 8, bottom - buttonHeight - 16);
		myOkButton.layout(left + 8, bottom - buttonHeight - 8, (left + right) / 2 - 4, bottom - 8);
		myCancelButton.layout((left + right) / 2 + 4, bottom - buttonHeight - 8, right - 8, bottom - 8);
	}
}

public class BookmarkEditActivity extends Activity {
	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		final SimpleContainer container = new SimpleContainer(this);
		setContentView(container);
	}
}
",False,1,0,0,0,0,0,0,I0
186,org.geometerplus.android.fbreader.ZLTreeAdapter.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.HashSet;

import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.ui.android.R;

abstract class ZLTreeAdapter extends BaseAdapter implements AdapterView.OnItemClickListener, View.OnCreateContextMenuListener {
	private final ListView myParent;
	private ZLTree<?> myTree;
	private ZLTree<?>[] myItems;
	private final HashSet<ZLTree<?>> myOpenItems = new HashSet<ZLTree<?>>();

	protected ZLTreeAdapter(ListView parent, ZLTree<?> tree) {
		myParent = parent;
		myTree = tree;
		myItems = new ZLTree[tree.getSize() - 1];
		myOpenItems.add(tree);

		parent.setAdapter(this);
		parent.setOnItemClickListener(this);
		parent.setOnCreateContextMenuListener(this);
	}

	protected final void openTree(ZLTree<?> tree) {
		if (tree == null) {
			return;
		}
		while (!myOpenItems.contains(tree)) {
			myOpenItems.add(tree);
			tree = tree.Parent;
		}
	}

	public final void expandOrCollapseTree(ZLTree<?> tree) {
		if (!tree.hasChildren()) {
			return;
		}
		if (isOpen(tree)) {
			myOpenItems.remove(tree);
		} else {
			myOpenItems.add(tree);
		}
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public final boolean isOpen(ZLTree<?> tree) {
		return myOpenItems.contains(tree);
	}

	public final void selectItem(ZLTree<?> tree) {
		if (tree == null) {
			return;
		}
		openTree(tree.Parent);
		int index = 0;
		while (true) {
			ZLTree<?> parent = tree.Parent;
			if (parent == null) {
				break;
			}
			for (ZLTree<?> sibling : parent.subTrees()) {
				if (sibling == tree) {
					break;
				}
				index += getCount(sibling);
			}
			tree = parent;
			++index;
		}
		if (index > 0) {
			myParent.setSelection(index - 1);
		}
	}

	private int getCount(ZLTree<?> tree) {
		int count = 1;
		if (isOpen(tree)) {
			for (ZLTree<?> subtree : tree.subTrees()) {
				count += getCount(subtree);
			}
		}
		return count;
	}

	public final int getCount() {
		return getCount(myTree) - 1;
	}

	private final int indexByPosition(int position, ZLTree<?> tree) {
		if (position == 0) {
			return 0;
		}
		--position;
		int index = 1;
		for (ZLTree<?> subtree : tree.subTrees()) {
			int count = getCount(subtree);
			if (count <= position) {
				position -= count;
				index += subtree.getSize();
			} else {
				return index + indexByPosition(position, subtree);
			}
		}
		throw new RuntimeException(""That's impossible!!!"");
	}

	public final ZLTree<?> getItem(int position) {
		final int index = indexByPosition(position + 1, myTree) - 1;
		ZLTree<?> item = myItems[index];
		if (item == null) {
			item = myTree.getTreeByParagraphNumber(index + 1);
			myItems[index] = item;
		}
		return item;
	}

	public final boolean areAllItemsEnabled() {
		return true;
	}

	public final boolean isEnabled(int position) {
		return true;
	}

	public final long getItemId(int position) {
		return indexByPosition(position + 1, myTree);
	}

	protected boolean runTreeItem(ZLTree<?> tree) {
		if (!tree.hasChildren()) {
			return false;
		}
		expandOrCollapseTree(tree);
		return true;
	}

	protected void resetTree(ZLTree<?> tree) {
		myTree = tree;
		myItems = new ZLTree[tree.getSize() - 1];
		myOpenItems.clear();
		myOpenItems.add(tree);
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public void resetTree() {
		myItems = new ZLTree[myTree.getSize() - 1];
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
		runTreeItem(getItem(position));
	}

	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
	}

	public abstract View getView(int position, View convertView, ViewGroup parent);

	protected final void setIcon(ImageView imageView, ZLTree<?> tree) {
		if (tree.hasChildren()) {
			if (isOpen(tree)) {
				imageView.setImageResource(R.drawable.ic_list_group_open);
			} else {
				imageView.setImageResource(R.drawable.ic_list_group_closed);
			}
		} else {
			imageView.setImageResource(R.drawable.ic_list_group_empty);
		}
		imageView.setPadding(25 * (tree.Level - 1), imageView.getPaddingTop(), 0, imageView.getPaddingBottom());
	}
}
",False,76,10,26,1,1,2,1,L6
187,org.geometerplus.android.fbreader.preferences.ZLPreference.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

interface ZLPreference {
	void onAccept();
}
",False,82,11,27,0,0,6,0,L0
188,org.geometerplus.android.fbreader.preferences.PreferenceActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.Preference;
import android.preference.PreferenceScreen;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.fbreader.*;
import org.geometerplus.fbreader.Paths;

public class PreferenceActivity extends ZLPreferenceActivity {
	public PreferenceActivity() {
		super(""Preferences"");
	}

	/*private static final class ColorProfilePreference extends ZLSimplePreference {
		private final FBReader myFBReader;
		private final Screen myScreen;
		private final String myKey;

		static final String createTitle(ZLResource resource, String resourceKey) {
			final ZLResource r = resource.getResource(resourceKey);
			return r.hasValue() ? r.getValue() : resourceKey;
		}

		ColorProfilePreference(Context context, FBReader fbreader, Screen screen, String key, String title) {
			super(context);
			myFBReader = fbreader;
			myScreen = screen;
			myKey = key;
			setTitle(title);
		}

		@Override
		public void onAccept() {
		}

		@Override
		public void onClick() {
			myScreen.setSummary(getTitle());
			myFBReader.setColorProfileName(myKey);
			myScreen.close();
		}
	}*/

	@Override
	protected void init() {
		final Category libraryCategory = createCategory(""Library"");
		/*
		libraryCategory.addPreference(new InfoPreference(
			this,
			libraryCategory.Resource.getResource(""path"").getValue(),
			Constants.BOOKS_DIRECTORY)
		);
		*/
		libraryCategory.addPreference(new ZLStringOptionPreference(
			this,
			Paths.BooksDirectoryOption,
			libraryCategory.Resource,
			""path"")
		);
		final Category lookNFeelCategory = createCategory(""LookNFeel"");

		final Screen appearanceScreen = lookNFeelCategory.createPreferenceScreen(""appearanceSettings"");
		appearanceScreen.setSummary( appearanceScreen.Resource.getResource(""summary"").getValue() );
		appearanceScreen.setOnPreferenceClickListener(
				new PreferenceScreen.OnPreferenceClickListener() {
					public boolean onPreferenceClick(Preference preference) {
						((FBReader) FBReader.Instance()).showOptionsDialog();
						return true;
					}
				}
		);

		lookNFeelCategory.addOption(ZLAndroidApplication.Instance().AutoOrientationOption, ""autoOrientation"");
		if (!ZLAndroidApplication.Instance().isAlwaysShowStatusBar()) {
			lookNFeelCategory.addOption(ZLAndroidApplication.Instance().ShowStatusBarOption, ""showStatusBar"");
		}
		lookNFeelCategory.addOption(ZLAndroidApplication.Instance().DontTurnScreenOffOption, ""dontTurnScreenOff"");
		lookNFeelCategory.addPreference(new ScrollbarTypePreference(this, lookNFeelCategory.Resource, ""scrollbarType""));

		/*
		final FBReader fbreader = (FBReader)FBReader.Instance();
		final Screen colorProfileScreen = lookNFeelCategory.createPreferenceScreen(""colorProfile"");
		final Category colorProfileCategory = colorProfileScreen.createCategory(null);
		final ZLResource resource = colorProfileCategory.Resource;
		colorProfileScreen.setSummary(ColorProfilePreference.createTitle(resource, fbreader.getColorProfileName()));
		for (String key : ColorProfile.names()) {
			colorProfileCategory.addPreference(new ColorProfilePreference(
				this, fbreader, colorProfileScreen, key, ColorProfilePreference.createTitle(resource, key)
			));
		}
		*/

		final Category scrollingCategory = createCategory(""Scrolling"");
		final ScrollingPreferences scrollingPreferences = ScrollingPreferences.Instance();
		scrollingCategory.addOption(scrollingPreferences.FlickOption, ""flick"");
		scrollingCategory.addOption(scrollingPreferences.VolumeKeysOption, ""volumeKeys"");
		scrollingCategory.addOption(scrollingPreferences.InvertVolumeKeysOption, ""invertVolumeKeys"");
		scrollingCategory.addOption(scrollingPreferences.AnimateOption, ""animated"");
		scrollingCategory.addOption(scrollingPreferences.HorizontalOption, ""horizontal"");
	}
}

class ScrollbarTypePreference extends ZLStringListPreference {
	private static final String[] ourCodes = { ""hide"", ""show"", ""showAsProgress"" };

	private FBReader myReader;

	ScrollbarTypePreference(Context context, ZLResource rootResource, String resourceKey) {
		super(context, rootResource, resourceKey);
		myReader = (FBReader)FBReader.Instance();
		final String[] names = new String[ourCodes.length];
		final ZLResource r = rootResource.getResource(resourceKey);
		for (int i = 0; i < ourCodes.length; ++i) {
			names[i] = r.getResource(ourCodes[i]).getValue();
		}
		setLists(ourCodes, names);
		setInitialValue(ourCodes[
			Math.max(0, Math.min(ourCodes.length - 1, myReader.ScrollbarTypeOption.getValue()))
		]);
	}

	public void onAccept() {
		final String value = getValue();
		int intValue = 0;
		for (int i = 0; i < ourCodes.length; ++i) {
			if (value == ourCodes[i]) {
				intValue = i;
				break;
			}
		}
		myReader.ScrollbarTypeOption.setValue(intValue);
	}
}
",False,374,0,0,9,89,1,10,L6
189,org.geometerplus.android.fbreader.preferences.BookInfoActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.Map;
import java.util.TreeMap;

import android.content.Context;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.language.ZLLanguageList;

import org.geometerplus.zlibrary.text.hyphenation.ZLTextHyphenator;

import org.geometerplus.fbreader.fbreader.FBReader;
import org.geometerplus.fbreader.library.Book;

class BookTitlePreference extends ZLStringPreference {
	private final Book myBook;

	BookTitlePreference(Context context, ZLResource rootResource, String resourceKey, Book book) {
		super(context, rootResource, resourceKey);
		myBook = book;
		setValue(book.getTitle());
	}

	public void onAccept() {
		myBook.setTitle(getValue());
	}
}

class LanguagePreference extends ZLStringListPreference {
	private final Book myBook;

	LanguagePreference(Context context, ZLResource rootResource, String resourceKey, Book book) {
		super(context, rootResource, resourceKey);
		myBook = book;
		final TreeMap<String,String> map = new TreeMap<String,String>();
		for (String code : ZLLanguageList.languageCodes()) {
			map.put(ZLLanguageList.languageName(code), code);
		}
		final int size = map.size();
		String[] codes = new String[size + 1];
		String[] names = new String[size + 1];
		int index = 0;
		for (Map.Entry<String,String> entry : map.entrySet()) {
			codes[index] = entry.getValue();
			names[index] = entry.getKey();
			++index;
		}
		codes[size] = ""other"";
		names[size] = ZLLanguageList.languageName(codes[size]);
		setLists(codes, names);
		String language = myBook.getLanguage();
		if (language == null) {
			language = ""other"";
		}
		if (!setInitialValue(language)) {
			setInitialValue(""other"");
		}
	}

	public void onAccept() {
		final String value = getValue();
		myBook.setLanguage((value.length() != 0) ? value : null);
	}
}

public class BookInfoActivity extends ZLPreferenceActivity {
	private Book myBook;

	public BookInfoActivity() {
		super(""BookInfo"");
	}

	@Override
	protected void init() {
		final Category commonCategory = createCategory(null);
		myBook = ((FBReader)FBReader.Instance()).Model.Book;
		if (myBook.File.getPhysicalFile() != null) {
			commonCategory.addPreference(new InfoPreference(
				this,
				commonCategory.Resource.getResource(""fileName"").getValue(),
				myBook.File.getPath())
			);
		}
		commonCategory.addPreference(new BookTitlePreference(this, commonCategory.Resource, ""title"", myBook));
		commonCategory.addPreference(new LanguagePreference(this, commonCategory.Resource, ""language"", myBook));
	}

	@Override
	protected void onPause() {
		super.onPause();
		if (myBook.save()) {
			((FBReader)FBReader.Instance()).clearTextCaches();
			ZLTextHyphenator.Instance().load(myBook.getLanguage());
		}
	}
}
",False,374,0,0,10,68,1,12,L6
190,org.geometerplus.android.fbreader.preferences.ZLPreferenceActivity.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.ArrayList;

import android.os.Bundle;
import android.preference.*;

import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLPreferenceActivity extends android.preference.PreferenceActivity {
	private final ArrayList<ZLPreference> myPreferences = new ArrayList<ZLPreference>();

	protected class Screen {
		public final ZLResource Resource;
		private final PreferenceScreen myScreen;

		private Screen(ZLResource root, String resourceKey) {
			Resource = root.getResource(resourceKey);
			myScreen = getPreferenceManager().createPreferenceScreen(ZLPreferenceActivity.this);
			myScreen.setTitle(Resource.getValue());
		}

		public void setSummary(CharSequence summary) {
			myScreen.setSummary(summary);
		}

		protected Category createCategory(String resourceKey) {
			return new Category(myScreen, Resource, resourceKey);
		}

		public void close() {
			myScreen.getDialog().dismiss();
			ZLPreferenceActivity.this.getListView().invalidateViews();
		}

		public void setOnPreferenceClickListener(PreferenceScreen.OnPreferenceClickListener onPreferenceClickListener) {
			myScreen.setOnPreferenceClickListener(onPreferenceClickListener);
		}
	}

	protected class Category {
		public final ZLResource Resource;
		private final PreferenceGroup myGroup;

		private Category(PreferenceScreen screen, ZLResource root, String resourceKey) {
			if (resourceKey != null) {
				Resource = root.getResource(resourceKey);
				myGroup = new PreferenceCategory(ZLPreferenceActivity.this);
				myGroup.setTitle(Resource.getValue());
				screen.addPreference(myGroup);
			} else {
				Resource = root;
				myGroup = screen;
			}
		}

		Screen createPreferenceScreen(String resourceKey) {
			Screen screen = new Screen(Resource, resourceKey);
			myGroup.addPreference(screen.myScreen);
			return screen;
		}

		void addPreference(ZLPreference preference) {
			myGroup.addPreference((Preference)preference);
			myPreferences.add(preference);
		}

		void addOption(ZLBooleanOption option, String resourceKey) {
			ZLBooleanPreference preference =
				new ZLBooleanPreference(ZLPreferenceActivity.this, option, Resource, resourceKey);
			myGroup.addPreference(preference);
			myPreferences.add(preference);
		}
	}

	private PreferenceScreen myScreen;
	private final ZLResource myResource;

	ZLPreferenceActivity(String resourceKey) {
		myResource = ZLResource.resource(""dialog"").getResource(resourceKey);
	}

	protected Category createCategory(String resourceKey) {
		return new Category(myScreen, myResource, resourceKey);
	}

	protected abstract void init();

	@Override
	protected void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		myScreen = getPreferenceManager().createPreferenceScreen(this);

		init();

		setPreferenceScreen(myScreen);
	}

	@Override
	protected void onPause() {
		for (ZLPreference preference : myPreferences) {
			preference.onAccept();
		}
		super.onPause();
	}
}
",False,115,10,27,7,11,2,5,L6
191,org.geometerplus.android.fbreader.preferences.ZLStringOptionPreference.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import android.content.Context;

class ZLStringOptionPreference extends ZLStringPreference {
	private final ZLStringOption myOption;

	ZLStringOptionPreference(Context context, ZLStringOption option, ZLResource rootResource, String resourceKey) {
		super(context, rootResource, resourceKey);
		myOption = option;
		setValue(myOption.getValue());
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,113,10,29,7,11,1,3,L6
192,org.geometerplus.android.fbreader.preferences.InfoPreference.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.Preference;

class InfoPreference extends Preference implements ZLPreference {
	InfoPreference(Context context, String title, String value) {
		super(context);
		setTitle(title);
		setSummary(value);
		setEnabled(false);
	}

	public void onAccept() {
	}
}
",False,76,10,29,1,1,1,1,L6
193,org.geometerplus.android.fbreader.preferences.ZLStringListPreference.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.ListPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLStringListPreference extends ListPreference implements ZLPreference {
	private final ZLResource myResource;

	ZLStringListPreference(Context context, ZLResource rootResource, String resourceKey) {
		super(context);

		myResource = rootResource.getResource(resourceKey);
		setTitle(myResource.getValue());
	}

	protected final void setList(String[] values) {
		String[] texts = new String[values.length];
		for (int i = 0; i < values.length; ++i) {
			final ZLResource resource = myResource.getResource(values[i]);
			texts[i] = (resource.hasValue()) ? resource.getValue() : values[i];
		}
		setLists(values, texts);
	}

	protected final void setLists(String[] values, String[] texts) {
		assert(values.length == texts.length);
		setEntries(texts);
		setEntryValues(values);
	}

	protected final boolean setInitialValue(String value) {
		final int index = findIndexOfValue(value);
		if (index >= 0) {
			setValueIndex(index);
			setSummary(getEntry());
			return true;
		}
		return false;
	}

	@Override
	protected void onDialogClosed(boolean result) {
		super.onDialogClosed(result);
		if (result) {
			setSummary(getEntry());
		}
	}
}
",False,108,10,27,7,11,2,2,L6
194,org.geometerplus.android.fbreader.preferences.ZLBooleanPreference.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.CheckBoxPreference;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLBooleanPreference extends CheckBoxPreference implements ZLPreference {
	private final ZLBooleanOption myOption;

	ZLBooleanPreference(Context context, ZLBooleanOption option, ZLResource rootResource, String resourceKey) {
		super(context);
		myOption = option;

		ZLResource resource = rootResource.getResource(resourceKey);
		setTitle(resource.getValue());
		setSummaryOn(resource.getResource(""summaryOn"").getValue());
		setSummaryOff(resource.getResource(""summaryOff"").getValue());
		setChecked(option.getValue());
	}

	public void onAccept() {
		myOption.setValue(isChecked());
	}
}
",False,113,11,27,7,11,1,3,L6
195,org.geometerplus.android.fbreader.preferences.ZLStringPreference.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.EditTextPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLStringPreference extends EditTextPreference implements ZLPreference {
	private String myValue;

	ZLStringPreference(Context context, ZLResource rootResource, String resourceKey) {
		super(context);

		ZLResource resource = rootResource.getResource(resourceKey);
		setTitle(resource.getValue());
	}

	protected final void setValue(String value) {
		setSummary(value);
		setText(value);
		myValue = value;
	}

	protected final String getValue() {
		return myValue;
	}

	@Override
	protected void onDialogClosed(boolean result) {
		if (result) {
			setValue(getEditText().getText().toString());
		}
		super.onDialogClosed(result);
	}
}
",False,109,10,27,7,11,2,2,L6
196,org.geometerplus.android.fbreader.preferences.ZLSimplePreference.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.Preference;

abstract class ZLSimplePreference extends Preference implements ZLPreference, Preference.OnPreferenceClickListener {
	ZLSimplePreference(Context context) {
		super(context);
		setOnPreferenceClickListener(this);
	}

	public abstract void onAccept();

	public boolean onPreferenceClick(Preference preference) {
		onClick();
		return true;
	}

	public abstract void onClick();
}
",False,2,0,0,1,1,0,1,L8
197,org.geometerplus.android.fbreader.network.RefillAccountActions.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class RefillAccountActions extends NetworkTreeActions {

	public static final int REFILL_ITEM_ID = 0;


	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof RefillAccountTree;
	}

	@Override
	public void buildContextMenu(NetworkBaseActivity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(getTitleValue(""refillTitle""));

		addMenuItem(menu, REFILL_ITEM_ID, ""refillTitle"");
	}

	@Override
	public int getDefaultActionCode(NetworkTree tree) {
		return REFILL_ITEM_ID;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		switch (actionCode) {
			case REFILL_ITEM_ID:
				doRefill(activity, (RefillAccountTree) tree);
				return true;
		}
		return false;
	}

	private void doRefill(final NetworkBaseActivity activity, final RefillAccountTree tree) {
		final NetworkAuthenticationManager mgr = tree.Link.authenticationManager();
		if (mgr.isAuthorised(false).Status != ZLBoolean3.B3_FALSE) {
			NetworkView.Instance().openInBrowser(
				activity,
				tree.Link.authenticationManager().refillAccountLink()
			);
		} else {
			NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, tree.Link, new Runnable() {
				public void run() {
					if (mgr.isAuthorised(false).Status != ZLBoolean3.B3_FALSE) {
						NetworkView.Instance().openInBrowser(
							activity,
							tree.Link.authenticationManager().refillAccountLink()
						);
					}
				}
			});
		}
	}
}
",False,374,0,0,9,103,1,10,L6
198,org.geometerplus.android.fbreader.network.NetworkBookInfoActivity.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Set;

import android.app.Activity;
import android.app.Dialog;
import android.os.Bundle;
//import android.util.StringBuilderPrinter;
import android.view.View;
import android.widget.ImageView;
//import android.widget.LinearLayout;
import android.widget.TextView;
import android.content.Intent;
import android.graphics.Bitmap;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;

import org.geometerplus.fbreader.network.*;


public class NetworkBookInfoActivity extends Activity implements NetworkView.EventListener {

	private NetworkBookItem myBook;

	private final ZLResource myResource = ZLResource.resource(""networkBookView"");
	private BookDownloaderServiceConnection myConnection;

	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);

		if (!NetworkView.Instance().isInitialized()) {
			finish();
			return;
		}

		myBook = NetworkView.Instance().getBookInfoItem();
		if (myBook == null) {
			finish();
			return;
		}

		myConnection = new BookDownloaderServiceConnection();
		bindService(
			new Intent(getApplicationContext(), BookDownloaderService.class),
			myConnection,
			BIND_AUTO_CREATE
		);

		setTitle(myBook.Title);
		setContentView(R.layout.network_book);

		setupDescription();
		setupInfo();
		setupCover();
		setupButtons();

		/*LinearLayout layout = (LinearLayout) findViewById(R.id.network_book_cover).getParent();
		TextView detailsTitle = new TextView(this, null, android.R.attr.listSeparatorTextViewStyle);
		TextView details = new TextView(this);
		detailsTitle.setText(""Debug Details"");

		StringBuilder builder = new StringBuilder();
		StringBuilderPrinter printer = new StringBuilderPrinter(builder);
		
		printer.println(""Id = "" + myBook.Id);
		printer.println(""Index = "" + myBook.Index);
		printer.println(""Cover = "" + myBook.Cover);
		printer.println(""References ("" + myBook.myReferences.size() + ""):"");
		for (BookReference ref: myBook.myReferences) {
			printer.println( ref.toString() );
		}

		details.setText(builder.toString());

		layout.addView(detailsTitle);
		layout.addView(details);*/
	}

	@Override
	public void onDestroy() {
		if (myConnection != null) {
			unbindService(myConnection);
			myConnection = null;
		}
		super.onDestroy();
	}

	private final void setupDescription() {
		((TextView) findViewById(R.id.network_book_description_title)).setText(myResource.getResource(""description"").getValue());

		final TextView descriptionView = (TextView) findViewById(R.id.network_book_description);
		final String description;
		if (myBook.Summary != null) {
			description = myBook.Summary;
		} else {
			description = myResource.getResource(""noDescription"").getValue();
		}
		descriptionView.setText(description);
	}

	private void setupInfo() {
		((TextView) findViewById(R.id.network_book_info_title)).setText(myResource.getResource(""bookInfo"").getValue());

		((TextView) findViewById(R.id.network_book_title_key)).setText(myResource.getResource(""title"").getValue());
		((TextView) findViewById(R.id.network_book_authors_key)).setText(myResource.getResource(""authors"").getValue());
		((TextView) findViewById(R.id.network_book_series_key)).setText(myResource.getResource(""series"").getValue());
		((TextView) findViewById(R.id.network_book_series_index_key)).setText(myResource.getResource(""indexInSeries"").getValue());
		((TextView) findViewById(R.id.network_book_tags_key)).setText(myResource.getResource(""tags"").getValue());


		((TextView) findViewById(R.id.network_book_title_value)).setText(myBook.Title);

		if (myBook.Authors.size() > 0) {
			findViewById(R.id.network_book_authors).setVisibility(View.VISIBLE);
			final StringBuilder authorsText = new StringBuilder();
			for (NetworkBookItem.AuthorData author: myBook.Authors) {
				if (authorsText.length() > 0) {
					authorsText.append("", "");
				}
				authorsText.append(author.DisplayName);
			}
			((TextView) findViewById(R.id.network_book_authors_value)).setText(authorsText);
		} else {
			findViewById(R.id.network_book_authors).setVisibility(View.GONE);
		}

		if (myBook.SeriesTitle != null) {
			findViewById(R.id.network_book_series).setVisibility(View.VISIBLE);
			((TextView) findViewById(R.id.network_book_series_value)).setText(myBook.SeriesTitle);
			if (myBook.IndexInSeries > 0) {
				((TextView) findViewById(R.id.network_book_series_index_value)).setText(String.valueOf(myBook.IndexInSeries));
				findViewById(R.id.network_book_series_index).setVisibility(View.VISIBLE);
			} else {
				findViewById(R.id.network_book_series_index).setVisibility(View.GONE);
			}
		} else {
			findViewById(R.id.network_book_series).setVisibility(View.GONE);
			findViewById(R.id.network_book_series_index).setVisibility(View.GONE);
		}

		if (myBook.Tags.size() > 0) {
			findViewById(R.id.network_book_tags).setVisibility(View.VISIBLE);
			final StringBuilder tagsText = new StringBuilder();
			for (String tag: myBook.Tags) {
				if (tagsText.length() > 0) {
					tagsText.append("", "");
				}
				tagsText.append(tag);
			}
			((TextView) findViewById(R.id.network_book_tags_value)).setText(tagsText);
		} else {
			findViewById(R.id.network_book_tags).setVisibility(View.GONE);
		}
	}

	private final void setupCover() {
		final View rootView = findViewById(R.id.network_book_root);
		final ImageView coverView = (ImageView) findViewById(R.id.network_book_cover);

		final int maxHeight = 300; // FIXME: hardcoded constant
		final int maxWidth = maxHeight * 2 / 3;
		Bitmap coverBitmap = null;
		final ZLImage cover = NetworkTree.createCover(myBook);
		if (cover != null) {
			ZLAndroidImageData data = null;
			final ZLAndroidImageManager mgr = (ZLAndroidImageManager) ZLAndroidImageManager.Instance();
			if (cover instanceof NetworkImage) {
				final NetworkImage img = (NetworkImage) cover;
				final NetworkView networkView = NetworkView.Instance();
				if (networkView.isInitialized()
						&& networkView.isCoverLoading(img.Url)) {
					networkView.addCoverSynchronizationRunnable(img.Url, new Runnable() {
						public void run() {
							img.synchronizeFast();
							final ZLAndroidImageData data = mgr.getImageData(img);
							if (data != null) {
								final Bitmap coverBitmap = data.getBitmap(maxWidth, maxHeight);
								if (coverBitmap != null) {
									coverView.setImageBitmap(coverBitmap);
									coverView.setVisibility(View.VISIBLE);
									rootView.invalidate();
									rootView.requestLayout();
								}
							}
						}
					});
				} else {
					img.synchronizeFast();
					data = mgr.getImageData(img);
				}
			} else {
				data = mgr.getImageData(cover);
			}
			if (data != null) {
				coverBitmap = data.getBitmap(maxWidth, maxHeight);
			}
		}
		if (coverBitmap != null) {
			coverView.setImageBitmap(coverBitmap);
			coverView.setVisibility(View.VISIBLE);
		} else {
			coverView.setVisibility(View.GONE);
		}
	}

	private final void setupButtons() {
		final ZLResource resource = ZLResource.resource(""networkView"");
		final int buttons[] = new int[] {
				R.id.network_book_button0,
				R.id.network_book_button1,
				R.id.network_book_button2,
				R.id.network_book_button3,
		};
		final Set<NetworkBookActions.Action> actions = NetworkBookActions.getContextMenuActions(myBook, myConnection);

		final boolean skipSecondButton = actions.size() < buttons.length && (actions.size() % 2) == 1;
		int buttonNumber = 0;
		for (final NetworkBookActions.Action a: actions) {
			if (skipSecondButton && buttonNumber == 1) {
				++buttonNumber;
			}
			if (buttonNumber >= buttons.length) {
				break;
			}

			final String text;
			if (a.Arg == null) {
				text = resource.getResource(a.Key).getValue();
			} else {
				text = resource.getResource(a.Key).getValue().replace(""%s"", a.Arg);
			}

			final int buttonId = buttons[buttonNumber++];
			TextView button = (TextView) findViewById(buttonId);
			button.setText(text);
			button.setVisibility(View.VISIBLE);
			button.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					NetworkBookActions.runAction(NetworkBookInfoActivity.this, myBook, a.Id);
					NetworkBookInfoActivity.this.updateView();
				}
			});
			button.setEnabled(a.Id != NetworkTreeActions.TREE_NO_ACTION);
		}
		findViewById(R.id.network_book_left_spacer).setVisibility(skipSecondButton ? View.VISIBLE : View.GONE);
		findViewById(R.id.network_book_right_spacer).setVisibility(skipSecondButton ? View.VISIBLE : View.GONE);
		if (skipSecondButton) {
			final int buttonId = buttons[1];
			View button = findViewById(buttonId);
			button.setVisibility(View.GONE);
			button.setOnClickListener(null);
		}
		while (buttonNumber < buttons.length) {
			final int buttonId = buttons[buttonNumber++];
			View button = findViewById(buttonId);
			button.setVisibility(View.GONE);
			button.setOnClickListener(null);
		}
	}

	private void updateView() {
		setupButtons();
		final View rootView = findViewById(R.id.network_book_root);
		rootView.invalidate();
		rootView.requestLayout();
	}

	@Override
	protected void onStart() {
		super.onStart();
		NetworkView.Instance().addEventListener(this);
	}

	@Override
	protected void onStop() {
		NetworkView.Instance().removeEventListener(this);
		super.onStop();
	}

	public void onModelChanged() {
		updateView();
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		if (!NetworkView.Instance().isInitialized()) {
			return null;
		}
		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			return dlg.createDialog(this);
		}
		return null;
	}

	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		super.onPrepareDialog(id, dialog);

		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			dlg.prepareDialog(this, dialog);
		}		
	}
}
",False,375,0,0,8,94,0,14,L8
199,org.geometerplus.android.fbreader.network.LibraryInitializationService.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.app.Service;
import android.content.Intent;


public class LibraryInitializationService extends Service {

	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);

		final NetworkView view = NetworkView.Instance();
		if (!view.isInitialized()) {
			stopSelf();
			return;
		}

		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				if (msg.what > 0 && msg.obj == null) {
					view.finishBackgroundUpdate();
				}
				stopSelf();
			}
		};

		final Thread thread = new Thread(new Runnable() {
			public void run() {
				int code = 0;
				String result = null;
				try {
					result = view.runBackgroundUpdate(false);
					code = 1;
				} finally {
					handler.sendMessage(handler.obtainMessage(code, result));
				}
			}
		});
		thread.setPriority(Thread.MIN_PRIORITY);
		thread.start();
	}
}
",True,375,0,0,9,104,0,1,L8
200,org.geometerplus.android.fbreader.network.NetworkBookActions.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Set;
import java.util.LinkedHashSet;
import java.io.File;

import android.app.AlertDialog;
import android.app.Activity;
import android.os.Message;
import android.os.Handler;
import android.net.Uri;
import android.content.Intent;
import android.content.DialogInterface;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.zlibrary.ui.android.R;
import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;
import org.geometerplus.fbreader.network.tree.NetworkAuthorTree;
import org.geometerplus.fbreader.network.tree.NetworkSeriesTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class NetworkBookActions extends NetworkTreeActions {

	private static final String PACKAGE = ""org.geometerplus.android.fbreader.network"";

	public static final int DOWNLOAD_BOOK_ITEM_ID = 0;
	public static final int DOWNLOAD_DEMO_ITEM_ID = 1;
	public static final int READ_BOOK_ITEM_ID = 2;
	public static final int READ_DEMO_ITEM_ID = 3;
	public static final int DELETE_BOOK_ITEM_ID = 4;
	public static final int DELETE_DEMO_ITEM_ID = 5;
	public static final int BUY_DIRECTLY_ITEM_ID = 6;
	public static final int BUY_IN_BROWSER_ITEM_ID = 7;
	public static final int SHOW_BOOK_ACTIVITY_ITEM_ID = 8;

	public static final int SHOW_BOOKS_ITEM_ID = 9;

	private static boolean useFullReferences(NetworkBookItem book) {
		return book.reference(BookReference.Type.DOWNLOAD_FULL) != null ||
			book.reference(BookReference.Type.DOWNLOAD_FULL_CONDITIONAL) != null;
	}

	private static boolean useDemoReferences(NetworkBookItem book) {
		return book.reference(BookReference.Type.DOWNLOAD_DEMO) != null &&
			book.localCopyFileName() == null &&
			book.reference(BookReference.Type.DOWNLOAD_FULL) == null;
	}

	private static boolean useBuyReferences(NetworkBookItem book) {
		return book.localCopyFileName() == null &&
			book.reference(BookReference.Type.DOWNLOAD_FULL) == null;
	}

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof NetworkBookTree
			|| tree instanceof NetworkAuthorTree
			|| tree instanceof NetworkSeriesTree;
	}

	@Override
	public void buildContextMenu(NetworkBaseActivity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(tree.getName());
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			addMenuItem(menu, SHOW_BOOKS_ITEM_ID, ""showBooks"");
			return;
		}

		final NetworkBookTree bookTree = (NetworkBookTree) tree;
		final NetworkBookItem book = bookTree.Book;

		Set<Action> actions = getContextMenuActions(book, activity.Connection);
		for (Action a: actions) {
			if (a.Arg == null) {
				addMenuItem(menu, a.Id, a.Key);
			} else {
				addMenuItem(menu, a.Id, a.Key, a.Arg);
			}
		}
	}

	static class Action {
		public final int Id;
		public final String Key;
		public final String Arg;

		public Action(int id, String key) {
			Id = id;
			Key = key;
			Arg = null;
		}

		public Action(int id, String key, String arg) {
			Id = id;
			Key = key;
			Arg = arg;
		}
	}

	static int getBookStatus(NetworkBookItem book, BookDownloaderServiceConnection connection) {
		if (useFullReferences(book)) {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_FULL);
			if (reference != null
					&& connection != null && connection.isBeingDownloaded(reference.URL)) {
				return R.drawable.ic_list_download;
			} else if (book.localCopyFileName() != null) {
				return R.drawable.ic_list_flag;
			} else if (reference != null) {
				return R.drawable.ic_list_download;
			}
		}
		if (useBuyReferences(book)
				&& book.reference(BookReference.Type.BUY) != null
				|| book.reference(BookReference.Type.BUY_IN_BROWSER) != null) {
			return R.drawable.ic_list_buy;
		}
		return 0;
	}

	static Set<Action> getContextMenuActions(NetworkBookItem book, BookDownloaderServiceConnection connection) {
		LinkedHashSet<Action> actions = new LinkedHashSet<Action>();
		if (useFullReferences(book)) {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_FULL);
			if (reference != null
					&& connection != null && connection.isBeingDownloaded(reference.URL)) {
				actions.add(new Action(TREE_NO_ACTION, ""alreadyDownloading""));
			} else if (book.localCopyFileName() != null) {
				actions.add(new Action(READ_BOOK_ITEM_ID, ""read""));
				actions.add(new Action(DELETE_BOOK_ITEM_ID, ""delete""));
			} else if (reference != null) {
				actions.add(new Action(DOWNLOAD_BOOK_ITEM_ID, ""download""));
			}
		}
		if (useDemoReferences(book)) {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_DEMO);
			if (connection != null && connection.isBeingDownloaded(reference.URL)) {
				actions.add(new Action(TREE_NO_ACTION, ""alreadyDownloadingDemo""));
			} else if (reference.localCopyFileName(BookReference.Type.DOWNLOAD_DEMO) != null) {
				actions.add(new Action(READ_DEMO_ITEM_ID, ""readDemo""));
				actions.add(new Action(DELETE_DEMO_ITEM_ID, ""deleteDemo""));
			} else {
				actions.add(new Action(DOWNLOAD_DEMO_ITEM_ID, ""downloadDemo""));
			}
		}
		if (useBuyReferences(book)) {
			int id = TREE_NO_ACTION;
			BookReference reference = null;
			if (book.reference(BookReference.Type.BUY) != null) {
				reference = book.reference(BookReference.Type.BUY);
				id = BUY_DIRECTLY_ITEM_ID;
			} else if (book.reference(BookReference.Type.BUY_IN_BROWSER) != null) {
				reference = book.reference(BookReference.Type.BUY_IN_BROWSER);
				id = BUY_IN_BROWSER_ITEM_ID;
			}
			if (reference != null) {
				final String price = ((BuyBookReference) reference).Price;
				actions.add(new Action(id, ""buy"", price));
			}
		}
		return actions;
	}

	@Override
	public int getDefaultActionCode(NetworkTree tree) {
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			return SHOW_BOOKS_ITEM_ID;
		}
		return SHOW_BOOK_ACTIVITY_ITEM_ID;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			switch (actionCode) {
			case SHOW_BOOKS_ITEM_ID:
				showBooks(activity, tree);
				return true;
			}
			return false;
		}
		return runAction(activity, ((NetworkBookTree) tree).Book, actionCode);
	}


	private void showBooks(NetworkBaseActivity activity, NetworkTree tree) {
		String key = null;
		if (tree instanceof NetworkAuthorTree) {
			key = PACKAGE + "".Authors:"" + ((NetworkAuthorTree) tree).Author.DisplayName;
		} else if (tree instanceof NetworkSeriesTree) {
			key = PACKAGE + "".Series:"" + ((NetworkSeriesTree) tree).SeriesTitle;
		}
		if (key != null) {
			NetworkView.Instance().openTree(activity, tree, key);
		}
	}

	static boolean runAction(Activity activity, NetworkBookItem book, int actionCode) {
		switch (actionCode) {
			case DOWNLOAD_BOOK_ITEM_ID:
				doDownloadBook(activity, book, false);
				return true;
			case DOWNLOAD_DEMO_ITEM_ID:
				doDownloadBook(activity, book, true);
				return true;
			case READ_BOOK_ITEM_ID:
				doReadBook(activity, book, false);
				return true;
			case READ_DEMO_ITEM_ID:
				doReadBook(activity, book, true);
				return true;
			case DELETE_BOOK_ITEM_ID:
				tryToDeleteBook(activity, book, false);
				return true;
			case DELETE_DEMO_ITEM_ID:
				tryToDeleteBook(activity, book, true);
				return true;
			case BUY_DIRECTLY_ITEM_ID:
				doBuyDirectly(activity, book);
				return true;
			case BUY_IN_BROWSER_ITEM_ID:
				doBuyInBrowser(activity, book);
				return true;
			case SHOW_BOOK_ACTIVITY_ITEM_ID:
				NetworkView.Instance().showBookInfoActivity(activity, book);
				return true;
		}
		return false;
	}

	private static void doDownloadBook(Activity activity, final NetworkBookItem book, boolean demo) {
		int resolvedType = demo ? BookReference.Type.DOWNLOAD_DEMO : BookReference.Type.DOWNLOAD_FULL;
		BookReference ref = book.reference(resolvedType);
		if (ref != null) {
			final String sslCertificate;
			if (book.Link.authenticationManager() != null) {
				sslCertificate = book.Link.authenticationManager().SSLCertificate;
			} else {
				sslCertificate = null;
			}
			activity.startService(
				new Intent(Intent.ACTION_VIEW, Uri.parse(ref.URL), 
						activity.getApplicationContext(), BookDownloaderService.class)
					.putExtra(BookDownloaderService.BOOK_FORMAT_KEY, ref.BookFormat)
					.putExtra(BookDownloaderService.REFERENCE_TYPE_KEY, resolvedType)
					.putExtra(BookDownloaderService.CLEAN_URL_KEY, ref.cleanURL())
					.putExtra(BookDownloaderService.TITLE_KEY, book.Title)
					.putExtra(BookDownloaderService.SSL_CERTIFICATE_KEY, sslCertificate)
			);
		}
	}

	private static void doReadBook(Activity activity, final NetworkBookItem book, boolean demo) {
		String local = null;
		if (!demo) {
			local = book.localCopyFileName();
		} else {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_DEMO);
			if (reference != null) {
				local = reference.localCopyFileName(BookReference.Type.DOWNLOAD_DEMO);
			}
		}
		if (local != null) {
			activity.startActivity(
				new Intent(Intent.ACTION_VIEW,
					Uri.fromFile(new File(local)),
					activity.getApplicationContext(),
					org.geometerplus.android.fbreader.FBReader.class
				).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
			);
		}
	}

	private static void tryToDeleteBook(Activity activity, final NetworkBookItem book, final boolean demo) {
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource boxResource = dialogResource.getResource(""deleteBookBox"");
		new AlertDialog.Builder(activity)
			.setTitle(book.Title)
			.setMessage(boxResource.getResource(""message"").getValue())
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
					// TODO: remove information about book from Library???
					if (!demo) {
						book.removeLocalFiles();
					} else {
						final BookReference reference = book.reference(BookReference.Type.DOWNLOAD_DEMO);
						if (reference != null) {
							final String fileName = reference.localCopyFileName(BookReference.Type.DOWNLOAD_DEMO);
							if (fileName != null) {
								new File(fileName).delete();
							}
						}
					}
					if (NetworkView.Instance().isInitialized()) {
						NetworkView.Instance().fireModelChangedAsync();
					}
				}
			})
			.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
			.create().show();
	}

	private static void doBuyDirectly(final Activity activity, final NetworkBookItem book) {
		final NetworkAuthenticationManager mgr = book.Link.authenticationManager();
		if (mgr == null) {
			return;
		}
		/*if (!NetworkOperationRunnable::tryConnect()) {
			return;
		}*/


		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");

		final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				if (which == DialogInterface.BUTTON_NEGATIVE) {
					return;
				}
				if (!mgr.needPurchase(book)) {
					return;
				}
				final boolean downloadBook = which == DialogInterface.BUTTON_NEUTRAL;
				final Handler handler = new Handler() {
					public void handleMessage(Message message) {
						String err = (String) message.obj;
						if (err != null) {
							final ZLResource boxResource = dialogResource.getResource(""networkError"");
							new AlertDialog.Builder(activity)
								.setTitle(boxResource.getResource(""title"").getValue())
								.setMessage(err)
								.setIcon(0)
								.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
								.create().show();
						} else if (downloadBook) {
							doDownloadBook(activity, book, false);
						}
						if (mgr.isAuthorised(true).Status == ZLBoolean3.B3_FALSE) {
							final NetworkLibrary library = NetworkLibrary.Instance();
							library.invalidateVisibility();
							library.synchronize();
						}
						if (NetworkView.Instance().isInitialized()) {
							NetworkView.Instance().fireModelChangedAsync();
						}
					}
				}; // end Handler
				final Runnable runnable = new Runnable() {
					public void run() {
						String err = mgr.purchaseBook(book);
						handler.sendMessage(handler.obtainMessage(0, err));
					}
				}; // end Runnable
				((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""purchaseBook"", runnable, activity);
			} // end onClick
		}; // end listener

		final Runnable buyRunnable = new Runnable() {
			public void run() {
				if (!mgr.needPurchase(book)) {
					final ZLResource boxResource = dialogResource.getResource(""alreadyPurchasedBox"");
					new AlertDialog.Builder(activity)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage(boxResource.getResource(""message"").getValue())
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
					return;
				}
				final ZLResource boxResource = dialogResource.getResource(""purchaseConfirmBox"");
				new AlertDialog.Builder(activity)
					.setTitle(boxResource.getResource(""title"").getValue())
					.setMessage(boxResource.getResource(""message"").getValue().replace(""%s"", book.Title))
					.setIcon(0)
					.setPositiveButton(buttonResource.getResource(""buy"").getValue(), listener)
					.setNeutralButton(buttonResource.getResource(""buyAndDownload"").getValue(), listener)
					.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
					.create().show();
			}
		};

		if (mgr.isAuthorised(true).Status != ZLBoolean3.B3_TRUE) {
			NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, book.Link, buyRunnable);
			return;
		} else {
			buyRunnable.run();
		}
	}

	private static void doBuyInBrowser(Activity activity, final NetworkBookItem book) {
		BookReference reference = book.reference(BookReference.Type.BUY_IN_BROWSER);
		if (reference != null) {
			NetworkView.Instance().openInBrowser(activity, reference.URL);
		}
	}

}
",True,375,1,1,7,101,3,24,L6
201,org.geometerplus.android.fbreader.network.BookDownloaderServiceConnection.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.IBinder;
import android.content.ServiceConnection;
import android.content.ComponentName;

class BookDownloaderServiceConnection implements ServiceConnection {

	private BookDownloaderInterface myInterface;

	public synchronized void onServiceConnected(ComponentName className, IBinder service) {
		myInterface = BookDownloaderInterface.Stub.asInterface(service);
	}

	public synchronized void onServiceDisconnected(ComponentName name) {
		myInterface = null;
	}

	public synchronized boolean isBeingDownloaded(String url) {
		if (myInterface != null) {
			try {
				return myInterface.isBeingDownloaded(url);
			} catch (android.os.RemoteException e) {
			}
		}
		return false;
	}
}
",True,75,11,30,0,0,3,0,L6
202,org.geometerplus.android.fbreader.network.BookDownloaderCallback.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class BookDownloaderCallback extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent) {
		if (NetworkView.Instance().isInitialized()) {
			NetworkView.Instance().fireModelChangedAsync();
		}
	}
}
",False,375,0,0,9,104,0,1,L8
203,org.geometerplus.android.fbreader.network.ItemsLoadingHandler.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import android.os.Message;
import android.os.Handler;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkLibraryItem;


abstract class ItemsLoadingHandler extends Handler {

	private static final int WHAT_UPDATE_ITEMS = 0;
	private static final int WHAT_FINISHED = 1;

	private final LinkedList<NetworkLibraryItem> myItems = new LinkedList<NetworkLibraryItem>();
	private final HashMap<INetworkLink, LinkedList<NetworkLibraryItem>> myUncommitedItems = new HashMap<INetworkLink, LinkedList<NetworkLibraryItem>>();
	private final Object myItemsMonitor = new Object();

	private volatile boolean myFinishProcessed;
	private final Object myFinishMonitor = new Object();


	public final void addItem(INetworkLink link, NetworkLibraryItem item) {
		synchronized (myItemsMonitor) {
			myItems.add(item);
			LinkedList<NetworkLibraryItem> uncommited = myUncommitedItems.get(link);
			if (uncommited == null) {
				uncommited = new LinkedList<NetworkLibraryItem>();
				myUncommitedItems.put(link, uncommited);
			}
			uncommited.add(item);
		}
	}

	public final void commitItems(INetworkLink link) {
		synchronized (myItemsMonitor) {
			LinkedList<NetworkLibraryItem> uncommited = myUncommitedItems.get(link);
			if (uncommited != null) {
				uncommited.clear();
			}
		}
	}

	public final void ensureItemsProcessed() {
		synchronized (myItemsMonitor) {
			while (myItems.size() > 0) {
				try {
					myItemsMonitor.wait();
				} catch (InterruptedException e) {
				}
			}
		}
	}

	private final void doUpdateItems() {
		synchronized (myItemsMonitor) {
			onUpdateItems(myItems);
			myItems.clear();
			myItemsMonitor.notifyAll(); // wake up process, that waits for finish condition (see ensureFinish() method)
		}
		afterUpdateItems();
	}

	public final void ensureFinishProcessed() {
		synchronized (myFinishMonitor) {
			while (!myFinishProcessed) {
				try {
					myFinishMonitor.wait();
				} catch (InterruptedException e) {
				}
			}
		}
	}

	private final void doProcessFinish(String errorMessage, boolean interrupted) {
		HashSet<NetworkLibraryItem> uncommitedItems = new HashSet<NetworkLibraryItem>();
		synchronized (myUncommitedItems) {
			for (LinkedList<NetworkLibraryItem> items: myUncommitedItems.values()) {
				uncommitedItems.addAll(items);
			}
		}
		synchronized (myFinishMonitor) {
			onFinish(errorMessage, interrupted, uncommitedItems);
			myFinishProcessed = true;
			myFinishMonitor.notifyAll(); // wake up process, that waits for finish condition (see ensureFinish() method)
		}
	}


	// sending messages methods
	public final void sendUpdateItems() {
		sendEmptyMessage(WHAT_UPDATE_ITEMS);
	}

	public final void sendFinish(String errorMessage, boolean interrupted) {
		int arg1 = interrupted ? 1 : 0;
		sendMessage(obtainMessage(WHAT_FINISHED, arg1, 0, errorMessage));
	}


	// callbacks
	public abstract void onUpdateItems(List<NetworkLibraryItem> items);
	public abstract void afterUpdateItems();
	public abstract void onFinish(String errorMessage, boolean interrupted, Set<NetworkLibraryItem> uncommitedItems);


	@Override
	public final void handleMessage(Message message) {
		switch (message.what) {
		case WHAT_UPDATE_ITEMS:
			doUpdateItems();
			break;
		case WHAT_FINISHED:
			doProcessFinish((String) message.obj, message.arg1 != 0);
			break;
		}
	}
}
",False,237,11,30,15,22,3,2,L6
204,org.geometerplus.android.fbreader.network.AuthenticationDialog.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Dialog;
import android.app.AlertDialog;
import android.view.View;
import android.widget.TextView;
import android.content.DialogInterface;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class AuthenticationDialog extends NetworkDialog {

	public AuthenticationDialog() {
		super(""AuthenticationDialog"");
	}

	@Override
	protected void clearData() {
	}

	@Override
	public View createLayout() {
		final View layout = myActivity.getLayoutInflater().inflate(R.layout.network_authentication_dialog, null);

		((TextView) layout.findViewById(R.id.network_authentication_login_text)).setText(myResource.getResource(""login"").getValue());
		((TextView) layout.findViewById(R.id.network_authentication_password_text)).setText(myResource.getResource(""password"").getValue());

		final TextView registerText = (TextView) layout.findViewById(R.id.network_authentication_register);
		registerText.setText(myResource.getResource(""register"").getValue());
		registerText.setOnClickListener(new View.OnClickListener() {
			public void onClick(View view) {
				final NetworkAuthenticationManager mgr = myLink.authenticationManager();
				if (mgr.registrationSupported()) {
					myActivity.dismissDialog(NetworkDialog.DIALOG_AUTHENTICATION);
					NetworkDialog.show(myActivity, NetworkDialog.DIALOG_REGISTER_USER, myLink, new Runnable() {
						public void run() {
							if (mgr.isAuthorised(true).Status == ZLBoolean3.B3_TRUE) {
								if (myOnSuccessRunnable != null) {
									myOnSuccessRunnable.run();
								}
							} else {
								NetworkDialog.show(myActivity, NetworkDialog.DIALOG_AUTHENTICATION, myLink, myOnSuccessRunnable);
							}
						}
					});
				}
			}
		});
		return layout;
	}

	@Override
	protected void onPositive(DialogInterface dialog) {
		AlertDialog alert = (AlertDialog) dialog;
		final String login = ((TextView) alert.findViewById(R.id.network_authentication_login)).getText().toString().trim();
		final String password = ((TextView) alert.findViewById(R.id.network_authentication_password)).getText().toString();

		if (login.length() == 0) {
			final String err = myResource.getResource(""loginIsEmpty"").getValue();
			sendError(true, false, err);
			return;
		}

		final NetworkAuthenticationManager mgr = myLink.authenticationManager();
		mgr.UserNameOption.setValue(login);
		final Runnable runnable = new Runnable() {
			public void run() {
				String err = mgr.authorise(password);
				if (err != null) {
					mgr.logOut();
					sendError(true, false, err);
					return;
				}
				if (mgr.needsInitialization()) {
					err = mgr.initialize();
					if (err != null) {
						mgr.logOut();
						sendError(true, false, err);
						return;
					}
				}
				sendSuccess(false);
			}
		};
		((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""authentication"", runnable, myActivity);
	}

	@Override
	protected void onNegative(DialogInterface dialog) {
		final NetworkAuthenticationManager mgr = myLink.authenticationManager();
		final Runnable runnable = new Runnable() {
			public void run() {
				if (mgr.isAuthorised(false).Status != ZLBoolean3.B3_FALSE) {
					mgr.logOut();
					sendCancel(false);
				}
			}
		};
		((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""signOut"", runnable, myActivity);
	}

	@Override
	public void prepareDialogInternal(Dialog dialog) {
		final NetworkAuthenticationManager mgr = myLink.authenticationManager();

		((TextView) dialog.findViewById(R.id.network_authentication_login)).setText(mgr.UserNameOption.getValue());
		((TextView) dialog.findViewById(R.id.network_authentication_password)).setText("""");

		final TextView error = (TextView) dialog.findViewById(R.id.network_authentication_error);
		if (myErrorMessage == null) {
			error.setVisibility(View.GONE);
			error.setText("""");
		} else {
			error.setVisibility(View.VISIBLE);
			error.setText(myErrorMessage);
		}

		dialog.findViewById(R.id.network_authentication_register).setVisibility(mgr.registrationSupported() ? View.VISIBLE : View.GONE);

		View dlgView = dialog.findViewById(R.id.network_authentication_dialog);
		dlgView.invalidate();
		dlgView.requestLayout();
	}
}
",False,374,0,0,10,97,1,9,L6
205,org.geometerplus.android.fbreader.network.NetworkCatalogActivity.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.ArrayList;

import android.os.Bundle;
import android.view.*;
import android.widget.BaseAdapter;
import android.content.Intent;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.NetworkCatalogItem;
import org.geometerplus.fbreader.network.tree.*;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


public class NetworkCatalogActivity extends NetworkBaseActivity {

	public static final String CATALOG_LEVEL_KEY = ""org.geometerplus.android.fbreader.network.CatalogLevel"";
	public static final String CATALOG_KEY_KEY = ""org.geometerplus.android.fbreader.network.CatalogKey"";

	private NetworkTree myTree;
	private String myCatalogKey;
	private boolean myInProgress;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

		final NetworkView networkView = NetworkView.Instance();
		if (!networkView.isInitialized()) {
			finish();
			return;
		}

		final Intent intent = getIntent();
		final int level = intent.getIntExtra(CATALOG_LEVEL_KEY, -1);
		if (level == -1) {
			throw new RuntimeException(""Catalog's Level was not specified!!!"");
		}

		myCatalogKey = intent.getStringExtra(CATALOG_KEY_KEY);
		if (myCatalogKey == null) {
			throw new RuntimeException(""Catalog's Key was not specified!!!"");
		}

		myTree = networkView.getOpenedTree(level);
		if (myTree == null) {
			finish();
			return;
		}

		networkView.setOpenedActivity(myCatalogKey, this);

		setListAdapter(new CatalogAdapter());
		getListView().invalidateViews();
		setupTitle();
	}

	private final void setupTitle() {
		String title = null;
		final NetworkView networkView = NetworkView.Instance();
		if (networkView.isInitialized()) {
			final NetworkTreeActions actions = networkView.getActions(myTree);
			if (actions != null) {
				title = actions.getTreeTitle(myTree);
			}
		}
		if (title == null) {
			title = myTree.getName();
		}
		setTitle(title);
		setProgressBarIndeterminateVisibility(myInProgress);
	}

	private static String getNetworkTreeKey(NetworkTree tree, boolean recursive) {
		if (tree instanceof NetworkCatalogTree) {
			return ((NetworkCatalogTree) tree).Item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		} else if (tree instanceof SearchItemTree) {
			return NetworkSearchActivity.SEARCH_RUNNABLE_KEY;
		} else if (recursive && tree.Parent instanceof NetworkTree) {
			if (tree instanceof NetworkAuthorTree
					|| tree instanceof NetworkSeriesTree) {
				return getNetworkTreeKey((NetworkTree) tree.Parent, true);
			}
		}
		return null;
	}


	@Override
	public void onDestroy() {
		if (myTree != null && myCatalogKey != null && NetworkView.Instance().isInitialized()) {
			NetworkView.Instance().setOpenedActivity(myCatalogKey, null);
		}
		super.onDestroy();
	}

	@Override
	public void onResume() {
		super.onResume();
	}


	private final class CatalogAdapter extends BaseAdapter {

		private ArrayList<NetworkTree> mySpecialItems;

		public CatalogAdapter() {
			if (myTree instanceof NetworkCatalogRootTree) {
				NetworkCatalogTree tree = (NetworkCatalogTree) myTree;
				NetworkAuthenticationManager mgr = tree.Item.Link.authenticationManager();
				if (mgr != null) {
					mySpecialItems = new ArrayList<NetworkTree>();
					if (mgr.refillAccountSupported()) {
						mySpecialItems.add(new RefillAccountTree(tree));
					}
					if (mySpecialItems.size() > 0) {
						mySpecialItems.trimToSize();
					} else {
						mySpecialItems = null;
					}
				}
			}
		}

		public final int getCount() {
			return myTree.subTrees().size() +
				((mySpecialItems != null && !myInProgress) ? mySpecialItems.size() : 0);
		}

		public final NetworkTree getItem(int position) {
			if (position < 0) {
				return null;
			}
			if (position < myTree.subTrees().size()) {
				return (NetworkTree) myTree.subTrees().get(position);
			}
			if (myInProgress) {
				return null;
			}
			position -= myTree.subTrees().size();
			if (mySpecialItems != null && position < mySpecialItems.size()) {
				return mySpecialItems.get(position);
			}
			return null;
		}

		public final long getItemId(int position) {
			return position;
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final NetworkTree tree = getItem(position);
			return setupNetworkTreeItemView(convertView, parent, tree);
		}

		void onModelChanged() {
			notifyDataSetChanged();
			if (mySpecialItems != null) {
				for (NetworkTree tree: mySpecialItems) {
					tree.invalidateChildren(); // call to update secondString
				}
			}
		}
	}

	@Override
	public void onModelChanged() {
		final NetworkView networkView = NetworkView.Instance();
		final String key = getNetworkTreeKey(myTree, true);
		myInProgress = key != null && networkView.isInitialized() && networkView.containsItemsLoadingRunnable(key);
		getListView().invalidateViews();

		/*
		 * getListAdapter() always returns CatalogAdapter because onModelChanged() 
		 * can be called only after Activity's onStart() method (where NetworkView's 
		 * addEventListener() is called). Therefore CatalogAdapter will be set as 
		 * adapter in onCreate() method before any calls to onModelChanged().
		 */
		((CatalogAdapter) getListAdapter()).onModelChanged();

		setupTitle();
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event)  {
		if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
			doStopLoading();
		}
		return super.onKeyDown(keyCode, event);
	}

	private void doStopLoading() {
		final String key = getNetworkTreeKey(myTree, false);
		if (key != null && NetworkView.Instance().isInitialized()) {
			final ItemsLoadingRunnable runnable = NetworkView.Instance().getItemsLoadingRunnable(key);
			if (runnable != null) {
				runnable.interruptLoading();
			}
		}
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		return NetworkView.Instance().createOptionsMenu(menu, myTree);
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		super.onPrepareOptionsMenu(menu);
		return NetworkView.Instance().prepareOptionsMenu(menu, myTree);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		if (NetworkView.Instance().runOptionsMenu(this, item, myTree)) {
			return true;
		}
		return super.onOptionsItemSelected(item);
	}
}
",True,374,0,0,9,103,3,18,L6
206,org.geometerplus.android.fbreader.network.AddCustomCatalogItemTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.NetworkLibraryItem;
import org.geometerplus.fbreader.network.NetworkTree;


public class AddCustomCatalogItemTree extends NetworkTree {

	public AddCustomCatalogItemTree() {
		super(1);
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""addCustomCatalog"").getValue();
	}

	@Override
	public String getSummary() {
		return ZLResource.resource(""networkView"").getResource(""addCustomCatalogSummary"").getValue();
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}

	@Override
	protected ZLImage createCover() {
		ZLResourceFile file = ZLResourceFile.createResourceFile(""R.drawable.ic_list_plus"");
		return new ZLFileImage(""image/png"", file);
	}
}
",False,240,11,30,16,20,2,6,L6
207,org.geometerplus.android.fbreader.network.ItemsLoadingRunnable.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.Message;
import android.os.Handler;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkOperationData;
import org.geometerplus.fbreader.network.NetworkLibraryItem;


abstract class ItemsLoadingRunnable implements Runnable {

	private final ItemsLoadingHandler myHandler;

	public final long UpdateInterval; // in milliseconds
	public final int ItemsLimit;

	private boolean myInterruptRequested;
	private boolean myInterruptConfirmed;
	private Object myInterruptLock = new Object();

	private boolean myFinished;
	private Handler myFinishedHandler;
	private Object myFinishedLock = new Object();


	public void interruptLoading() {
		synchronized (myInterruptLock) {
			myInterruptRequested = true;
		}
	}

	private boolean confirmInterruptLoading() {
		synchronized (myInterruptLock) {
			if (myInterruptRequested) {
				myInterruptConfirmed = true;
			}
			return myInterruptConfirmed;
		}
	}

	public boolean tryResumeLoading() {
		synchronized (myInterruptLock) {
			if (!myInterruptConfirmed) {
				myInterruptRequested = false;
			}
			return !myInterruptRequested;
		}
	}

	private boolean isLoadingInterrupted() {
		synchronized (myInterruptLock) {
			return myInterruptConfirmed;
		}
	}


	public ItemsLoadingRunnable(ItemsLoadingHandler handler) {
		this(handler, 1000, 500);
	}

	public ItemsLoadingRunnable(ItemsLoadingHandler handler, long updateIntervalMillis, int itemsLimit) {
		myHandler = handler;
		UpdateInterval = updateIntervalMillis;
		ItemsLimit = itemsLimit;
	}

	public abstract String doBefore();
	public abstract String doLoading(NetworkOperationData.OnNewItemListener doWithListener);

	public abstract String getResourceKey();


	public final void run() {
		String err = doBefore();
		if (err != null) {
			myHandler.sendFinish(err, false);
			return;
		}
		err = doLoading(new NetworkOperationData.OnNewItemListener() {
			private long myUpdateTime;
			private int myItemsNumber;
			public void onNewItem(INetworkLink link, NetworkLibraryItem item) {
				myHandler.addItem(link, item);
				++myItemsNumber;
				final long now = System.currentTimeMillis();
				if (now > myUpdateTime) {
					myHandler.sendUpdateItems();
					myUpdateTime = now + UpdateInterval;
				}
			}
			public boolean confirmInterrupt() {
				return confirmInterruptLoading() || myItemsNumber >= ItemsLimit;
			}
			public void commitItems(INetworkLink link) {
				myHandler.commitItems(link);
			}
		});
		myHandler.sendUpdateItems();
		myHandler.ensureItemsProcessed();
		myHandler.sendFinish(err, isLoadingInterrupted());
		myHandler.ensureFinishProcessed();
	}

	void runFinishHandler() {
		synchronized (myFinishedLock) {
			if (myFinishedHandler != null) {
				myFinishedHandler.sendEmptyMessage(0);
			}
			myFinished = true;
		}
	}


	public void runOnFinish(final Runnable runnable) {
		if (myFinishedHandler != null) {
			return;
		}
		synchronized (myFinishedLock) {
			if (myFinished) {
				runnable.run();
			} else {
				myFinishedHandler = new Handler() {
					public void handleMessage(Message message) {
						runnable.run();
					}
				};
			}
		}
	}
}
",False,237,11,30,15,22,5,4,L6
208,org.geometerplus.android.fbreader.network.RefillAccountTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkLibraryItem;
import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.tree.NetworkCatalogTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class RefillAccountTree extends NetworkTree {

	public final INetworkLink Link;
	public final ZLImage Cover;

	public RefillAccountTree(NetworkCatalogTree parentTree) {
		super(parentTree.Level + 1);
		Link = parentTree.Item.Link;
		Cover = parentTree.getCover();
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""refillTitle"").getValue();
	}

	@Override
	public String getSummary() {
		final NetworkAuthenticationManager mgr = Link.authenticationManager();
		if (mgr.isAuthorised(false).Status == ZLBoolean3.B3_TRUE) {
			final String account = mgr.currentAccount();
			if (account != null) {
				return ZLResource.resource(""networkView"").getResource(""refillSummary"").getValue().replace(""%s"", account);
			}
		}
		return null;
	}

	@Override
	protected ZLImage createCover() {
		return Cover;
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}
}
",False,245,12,30,14,26,2,11,L6
209,org.geometerplus.android.fbreader.network.SearchItemActions.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.SearchResult;


class SearchItemActions extends NetworkTreeActions {

	public static final int RUN_SEARCH_ITEM_ID = 0;


	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof SearchItemTree;
	}

	@Override
	public String getTreeTitle(NetworkTree tree) {
		final SearchResult result = ((SearchItemTree) tree).getSearchResult();
		if (result != null) {
			return result.Summary;
		}
		return tree.getName();
	}

	@Override
	public void buildContextMenu(NetworkBaseActivity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(tree.getName());

		final boolean isLoading = NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY);

		if (!isLoading) {
			addMenuItem(menu, RUN_SEARCH_ITEM_ID, ""search"");
		} else {
			addMenuItem(menu, TREE_NO_ACTION, ""stoppingNetworkSearch"");
		}
	}

	@Override
	public int getDefaultActionCode(NetworkTree tree) {
		final boolean isLoading = NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY);
		if (!isLoading) {
			return RUN_SEARCH_ITEM_ID;
		}
		return TREE_NO_ACTION;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		switch (actionCode) {
			case RUN_SEARCH_ITEM_ID:
				activity.onSearchRequested();
				return true;
		}
		return false;
	}
}
",False,374,0,0,9,106,1,8,L6
210,org.geometerplus.android.fbreader.network.SearchItemTree.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Set;
import java.util.LinkedList;
import java.util.ListIterator;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkAuthorTree;


public class SearchItemTree extends NetworkTree {

	private SearchResult myResult;

	public SearchItemTree() {
		super(1);
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""search"").getValue();
	}

	@Override
	public String getSummary() {
		return ZLResource.resource(""networkView"").getResource(""searchSummary"").getValue();
	}

	@Override
	protected ZLImage createCover() {
		ZLResourceFile file = ZLResourceFile.createResourceFile(""R.drawable.ic_list_searchresult"");
		return new ZLFileImage(""image/png"", file);
	}

	public void setSearchResult(SearchResult result) {
		myResult = result;
		clear();
	}

	public SearchResult getSearchResult() {
		return myResult;
	}

	public void updateSubTrees() {
		ListIterator<FBTree> nodeIterator = subTrees().listIterator();

		final Set<NetworkBookItem.AuthorData> authorsSet = myResult.BooksMap.keySet();

		for (NetworkBookItem.AuthorData author: authorsSet) {
			if (nodeIterator != null) {
				if (nodeIterator.hasNext()) {
					FBTree currentNode = nodeIterator.next();
					if (!(currentNode instanceof NetworkAuthorTree)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					NetworkAuthorTree child = (NetworkAuthorTree) currentNode;
					if (!child.Author.equals(author)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					LinkedList<NetworkBookItem> authorBooks = myResult.BooksMap.get(author);
					child.updateSubTrees(authorBooks);
					continue;
				}
				nodeIterator = null;
			}

			LinkedList<NetworkBookItem> authorBooks = myResult.BooksMap.get(author);
			if (authorBooks.size() != 0) {
				NetworkAuthorTree child = new NetworkAuthorTree(this, author);
				child.updateSubTrees(authorBooks);
			}
		}
		if (nodeIterator != null && nodeIterator.hasNext()) {
			throw new RuntimeException(""That's impossible!!!"");
		}
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}
}
",False,244,11,30,15,23,4,11,L6
211,org.geometerplus.android.fbreader.network.NetworkNotifications.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

class NetworkNotifications {
	private static NetworkNotifications ourInstance;

	public static NetworkNotifications Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkNotifications();
		}
		return ourInstance;
	}

	//private static final int CATALOG_LOADING = 0;
	//private static final int NETWORK_SEARCH = 1;

	private static final int BOOK_DOWNLOADING_START = 0x10000000;
	private static final int BOOK_DOWNLOADING_END   = 0x1fffffff;

	private volatile int myBookDownloadingId = BOOK_DOWNLOADING_START;

	private NetworkNotifications() {
	}

	/*public int getCatalogLoadingId() {
		return CATALOG_LOADING;
	}*/

	/*public int getNetworkSearchId() {
		return NETWORK_SEARCH;
	}*/

	public synchronized int getBookDownloadingId() {
		final int id = myBookDownloadingId;
		if (myBookDownloadingId == BOOK_DOWNLOADING_END) {
			myBookDownloadingId = BOOK_DOWNLOADING_START;
		} else {
			++myBookDownloadingId;
		}
		return id;
	}
}
",False,75,7,20,0,0,1,0,L6
212,org.geometerplus.android.fbreader.network.NetworkSearchActivity.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.List;
import java.util.Set;

import android.app.AlertDialog;
import android.app.Activity;
import android.app.SearchManager;
import android.os.Bundle;
import android.content.Intent;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.*;


public class NetworkSearchActivity extends Activity {

	public static final String SEARCH_RUNNABLE_KEY = ""org.geometerplus.android.fbreader.network.NetworkSearchActivity"";

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		if (!NetworkView.Instance().isInitialized()) {
			finish();
		}

		final Intent intent = getIntent();
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			final String pattern = intent.getStringExtra(SearchManager.QUERY);
			runSearch(pattern);
		}
		finish();
	}

	private class SearchHandler extends ItemsLoadingHandler {

		private final SearchItemTree myTree;

		public SearchHandler(SearchItemTree tree) {
			myTree = tree;
		}

		@Override
		public void onUpdateItems(List<NetworkLibraryItem> items) {
			SearchResult result = myTree.getSearchResult();
			for (NetworkLibraryItem item: items) {
				if (item instanceof NetworkBookItem) {
					result.addBook((NetworkBookItem) item);
				}
			}
		}

		@Override
		public void afterUpdateItems() {
			myTree.updateSubTrees();
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		@Override
		public void onFinish(String errorMessage, boolean interrupted,
				Set<NetworkLibraryItem> uncommitedItems) {
			if (interrupted) {
				myTree.setSearchResult(null);
			} else {
				myTree.updateSubTrees();
				afterUpdateCatalog(errorMessage, myTree.getSearchResult().empty());
			}
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
			final ZLResource dialogResource = ZLResource.resource(""dialog"");
			ZLResource boxResource = null;
			String msg = null;
			if (errorMessage != null) {
				boxResource = dialogResource.getResource(""networkError"");
				msg = errorMessage;
			} else if (childrenEmpty) {
				boxResource = dialogResource.getResource(""emptySearchResults"");
				msg = boxResource.getResource(""message"").getValue();
			}
			if (msg != null) {
				if (NetworkView.Instance().isInitialized()) {
					final NetworkCatalogActivity activity = NetworkView.Instance().getOpenedActivity(SEARCH_RUNNABLE_KEY);
					if (activity != null) {
						final ZLResource buttonResource = dialogResource.getResource(""button"");
						new AlertDialog.Builder(activity)
							.setTitle(boxResource.getResource(""title"").getValue())
							.setMessage(msg)
							.setIcon(0)
							.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
							.create().show();
					}
				}
			}
		}
	}

	private static class SearchRunnable extends ItemsLoadingRunnable {

		private final String myPattern;

		public SearchRunnable(ItemsLoadingHandler handler, String pattern) {
			super(handler);
			myPattern = pattern;
		}

		public String getResourceKey() {
			return ""searchingNetwork"";
		}

		public String doBefore() {
			return null;
		}

		public String doLoading(NetworkOperationData.OnNewItemListener doWithListener) {
			return NetworkLibrary.Instance().simpleSearch(myPattern, doWithListener);
		}
	}

	protected void runSearch(final String pattern) {
		final NetworkLibrary library = NetworkLibrary.Instance();
		library.NetworkSearchPatternOption.setValue(pattern);

		if (NetworkView.Instance().containsItemsLoadingRunnable(SEARCH_RUNNABLE_KEY)) {
			return;
		}

		final String summary = ZLResource.resource(""networkView"").getResource(""searchResults"").getValue().replace(""%s"", pattern);
		final SearchResult result = new SearchResult(summary);

		final SearchItemTree tree = NetworkView.Instance().getSearchItemTree();

		tree.setSearchResult(result);
		NetworkView.Instance().fireModelChangedAsync();

		final SearchHandler handler = new SearchHandler(tree);
		NetworkView.Instance().startItemsLoading(
			this,
			SEARCH_RUNNABLE_KEY,
			new SearchRunnable(handler, pattern)
		);
		NetworkView.Instance().openTree(this, tree, SEARCH_RUNNABLE_KEY);
	}
}
",True,374,0,0,9,90,3,13,L6
213,org.geometerplus.android.fbreader.network.NetworkDialog.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.TreeMap;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Handler;
import android.os.Message;
import android.view.View;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkLibrary;


abstract class NetworkDialog {

	// dialog identifiers
	public static final int DIALOG_AUTHENTICATION = 0;
	public static final int DIALOG_REGISTER_USER = 1;
	public static final int DIALOG_CUSTOM_CATALOG = 2;

	private static final TreeMap<Integer, NetworkDialog> ourInstances = new TreeMap<Integer, NetworkDialog>();

	public static NetworkDialog getDialog(int id) {
		NetworkDialog dlg = ourInstances.get(Integer.valueOf(id));
		if (dlg == null) {
			switch (id) {
			case DIALOG_AUTHENTICATION:
				dlg = new AuthenticationDialog();
				break;
			case DIALOG_REGISTER_USER:
				dlg = new RegisterUserDialog();
				break;
			case DIALOG_CUSTOM_CATALOG:
				dlg = new CustomCatalogDialog();
				break;
			}
			if (dlg != null) {
				dlg.myId = id;
				ourInstances.put(Integer.valueOf(id), dlg);
			}
		}
		return dlg;
	}


	private class DialogHandler extends Handler {

		public Message obtainMessage(int code, boolean invalidateLibrary, String message) {
			return obtainMessage(code, invalidateLibrary ? 1 : 0, 0, message);
		}

		@Override
		public void handleMessage(Message message) {
			if (!NetworkView.Instance().isInitialized()) {
				return;
			}
			final NetworkLibrary library = NetworkLibrary.Instance();
			if (message.arg1 != 0) {
				library.invalidateChildren();
			}
			library.invalidateVisibility();
			library.synchronize();
			NetworkView.Instance().fireModelChanged();
			if (message.what < 0) {
				if (message.what == -2) {
					final ZLResource dialogResource = ZLResource.resource(""dialog"");
					final ZLResource boxResource = dialogResource.getResource(""networkError"");
					final ZLResource buttonResource = dialogResource.getResource(""button"");
					new AlertDialog.Builder(myActivity)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage((String) message.obj)
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
				} else {
					myErrorMessage = (String) message.obj;
					myActivity.showDialog(myId);
					return;
				}
			} else if (message.what > 0) {
				if (myOnSuccessRunnable != null) {
					myOnSuccessRunnable.run();
				}
			}
			clearData();
		}
	};


	protected final ZLResource myResource;

	protected int myId; 

	protected INetworkLink myLink;
	protected String myErrorMessage;
	protected Runnable myOnSuccessRunnable;
	protected Activity myActivity;

	protected final DialogHandler myHandler = new DialogHandler();

	public NetworkDialog(String key) {
		myResource = ZLResource.resource(""dialog"").getResource(key);
	}

	public static void show(Activity activity, int id, INetworkLink link, Runnable onSuccessRunnable) {
		getDialog(id).showInternal(activity, link, onSuccessRunnable);
	}

	private void showInternal(Activity activity, INetworkLink link, Runnable onSuccessRunnable) {
		myLink = link;
		myErrorMessage = null;
		myOnSuccessRunnable = onSuccessRunnable;
		activity.showDialog(myId);
	}


	protected void sendSuccess(boolean invalidateLibrary) {
		myHandler.sendMessage(myHandler.obtainMessage(1, invalidateLibrary, null));
	}

	protected void sendCancel(boolean invalidateLibrary) {
		myHandler.sendMessage(myHandler.obtainMessage(0, invalidateLibrary, null));
	}

	protected void sendError(boolean restart, boolean invalidateLibrary, String message) {
		myHandler.sendMessage(myHandler.obtainMessage(restart ? -1 : -2, invalidateLibrary, message));
	}

	protected abstract View createLayout();
	protected abstract void clearData();

	protected abstract void onPositive(DialogInterface dialog);
	protected abstract void onNegative(DialogInterface dialog);

	public final Dialog createDialog(final Activity activity) {
		myActivity = activity;
		final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				if (which == DialogInterface.BUTTON_POSITIVE) {
					onPositive(dialog);
				} else {
					onNegative(dialog);
				}
			}
		};

		final View layout = createLayout();
		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		return new AlertDialog.Builder(activity)
			.setView(layout)
			.setTitle(myResource.getResource(""title"").getValue())
			.setPositiveButton(buttonResource.getResource(""ok"").getValue(), listener)
			.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
			.setOnCancelListener(new DialogInterface.OnCancelListener() {
				public void onCancel(DialogInterface dialog) {
					onNegative(dialog);
				}
			})
			.create();
	}

	public final void prepareDialog(final Activity activity, Dialog dialog) {
		myActivity = activity;
		prepareDialogInternal(dialog);
	}

	protected abstract void prepareDialogInternal(Dialog dialog);
}
",False,375,1,1,9,108,9,7,L6
214,org.geometerplus.android.fbreader.network.ItemsLoadingService.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.IBinder;
import android.os.Handler;
import android.os.Message;
import android.app.Service;
import android.content.Intent;


public class ItemsLoadingService extends Service {

	public static final String ITEMS_LOADING_RUNNABLE_KEY = ""org.geometerplus.android.fbreader.network.ItemsLoadingRunnable"";

	private volatile int myServiceCounter;

	private void doStart() {
		++myServiceCounter;
	}

	private void doStop() {
		if (--myServiceCounter == 0) {
			stopSelf();
		}
	}


	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		doStart();

		final String key = intent.getStringExtra(ITEMS_LOADING_RUNNABLE_KEY);
		if (key == null) {
			doStop();
			return;
		}
		intent.removeExtra(ITEMS_LOADING_RUNNABLE_KEY);

		if (!NetworkView.Instance().isInitialized()) {
			doStop();
			return;
		}
		final ItemsLoadingRunnable runnable = NetworkView.Instance().getItemsLoadingRunnable(key);
		if (runnable == null) {
			doStop();
			return;
		}

		final Handler finishHandler = new Handler() {
			public void handleMessage(Message message) {
				doStop();
				if (NetworkView.Instance().isInitialized()) {
					NetworkView.Instance().removeItemsLoadingRunnable(key);
					NetworkView.Instance().fireModelChangedAsync();
				}
			}
		};

		NetworkView.Instance().fireModelChangedAsync(); // this call is needed to show indeterminate progress bar in title right on downloading start

		final Thread loader = new Thread(new Runnable() {
			public void run() {
				try {
					runnable.run();
				} finally {
					finishHandler.sendEmptyMessage(0);
				}
			}
		});
		loader.setPriority(Thread.MIN_PRIORITY);
		loader.start();
	}
}
",True,374,0,0,9,104,1,2,L6
215,org.geometerplus.android.fbreader.network.NetworkView.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;

import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Handler;
import android.os.Message;
import android.view.MenuItem;
import android.view.Menu;

import org.geometerplus.fbreader.network.*;


class NetworkView {
	private static NetworkView ourInstance;

	public static NetworkView Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkView();
		}
		return ourInstance;
	}

	private NetworkView() {
	}


	private volatile boolean myInitialized;

	public boolean isInitialized() {
		return myInitialized;
	}

	public String initialize() {
		new SQLiteNetworkDatabase();

		final NetworkLibrary library = NetworkLibrary.Instance();
		final String error = library.initialize();
		if (error != null) {
			return error;
		}

		library.synchronize();

		myActions.add(new NetworkBookActions());
		myActions.add(new NetworkCatalogActions());
		myActions.add(new SearchItemActions());
		myActions.add(new RefillAccountActions());
		myActions.add(new AddCustomCatalogItemActions());
		myActions.trimToSize();

		myInitialized = true;
		return null;
	}

	// This method must be called from background thread
	public String runBackgroundUpdate(boolean clearCache) {
		return NetworkLibrary.Instance().runBackgroundUpdate(clearCache);
	}

	// This method MUST be called from main thread
	// This method has effect only when runBackgroundUpdate method has returned null
	public void finishBackgroundUpdate() {
		NetworkLibrary library = NetworkLibrary.Instance();
		library.finishBackgroundUpdate();
		library.synchronize();
		fireModelChanged();
	}

	/*
	 * NetworkLibraryItem's actions
	 */

	private final ArrayList<NetworkTreeActions> myActions = new ArrayList<NetworkTreeActions>();

	public NetworkTreeActions getActions(NetworkTree tree) {
		for (NetworkTreeActions actions: myActions) {
			if (actions.canHandleTree(tree)) {
				return actions;
			}
		}
		return null;
	}

	/*
	 * OptionsMenu methods
	 */

	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		if (!isInitialized()) {
			return false;
		}
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.createOptionsMenu(menu, tree);
		}
		return false;
	}

	public boolean prepareOptionsMenu(Menu menu, NetworkTree tree) {
		if (!isInitialized()) {
			return false;
		}
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.prepareOptionsMenu(menu, tree);
		}
		return false;
	}

	public boolean runOptionsMenu(NetworkBaseActivity activity, MenuItem item, NetworkTree tree) {
		if (!isInitialized()) {
			return false;
		}
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.runAction(activity, tree, item.getItemId());
		}
		return false;
	}

	/*
	 * Code for loading network items (running items-loading service and managing items-loading runnables).
	 */

	private final HashMap<String, ItemsLoadingRunnable> myItemsLoadingRunnables = new HashMap<String, ItemsLoadingRunnable>();

	public void startItemsLoading(Context context, String key, ItemsLoadingRunnable runnable) {
		boolean doDownload = false;
		synchronized (myItemsLoadingRunnables) {
			if (!myItemsLoadingRunnables.containsKey(key)) {
				myItemsLoadingRunnables.put(key, runnable);
				doDownload = true;
			}
		}
		if (doDownload) {
			context.startService(
				new Intent(context.getApplicationContext(), ItemsLoadingService.class)
					.putExtra(ItemsLoadingService.ITEMS_LOADING_RUNNABLE_KEY, key)
			);
		}
	}

	ItemsLoadingRunnable getItemsLoadingRunnable(String key) {
		synchronized (myItemsLoadingRunnables) {
			return myItemsLoadingRunnables.get(key);
		}
	}

	void removeItemsLoadingRunnable(String key) {
		synchronized (myItemsLoadingRunnables) {
			ItemsLoadingRunnable runnable = myItemsLoadingRunnables.remove(key);
			if (runnable != null) {
				runnable.runFinishHandler();
			}
		}
	}

	public final boolean containsItemsLoadingRunnable(String key) {
		return getItemsLoadingRunnable(key) != null;
	}

	public void tryResumeLoading(NetworkBaseActivity activity, NetworkTree tree, String key, Runnable expandRunnable) {
		final ItemsLoadingRunnable runnable = getItemsLoadingRunnable(key);
		if (runnable != null && runnable.tryResumeLoading()) {
			openTree(activity, tree, key);
			return;
		}
		if (runnable == null) {
			expandRunnable.run();
		} else {
			runnable.runOnFinish(expandRunnable);
		}
	}

	/*
	 * Loading covers
	 */

	private static class MinPriorityThreadFactory implements ThreadFactory {

		private final ThreadFactory myDefaultThreadFactory = Executors.defaultThreadFactory();

		public Thread newThread(Runnable r) {
			final Thread th = myDefaultThreadFactory.newThread(r);
			th.setPriority(Thread.MIN_PRIORITY);
			return th;
		}
	}

	private static final int COVER_LOADING_THREADS_NUMBER = 3; // TODO: how many threads ???

	private final ExecutorService myPool = Executors.newFixedThreadPool(COVER_LOADING_THREADS_NUMBER, new MinPriorityThreadFactory());

	private final HashMap<String, LinkedList<Runnable>> myOnCoverSyncRunnables = new HashMap<String, LinkedList<Runnable>>();

	private class CoverSynchronizedHandler extends Handler {
		@Override
		public void handleMessage(Message message) {
			final String imageUrl = (String) message.obj;
			final LinkedList<Runnable> runables = myOnCoverSyncRunnables.remove(imageUrl);
			for (Runnable runnable: runables) {
				runnable.run();
			}
		}

		public void fireMessage(String imageUrl) {
			sendMessage(obtainMessage(0, imageUrl));
		}
	};

	private final CoverSynchronizedHandler myCoverSynchronizedHandler = new CoverSynchronizedHandler();

	public void performCoverSynchronization(final NetworkImage image, Runnable finishRunnable) {
		if (myOnCoverSyncRunnables.containsKey(image.Url)) {
			return;
		}
		final LinkedList<Runnable> runnables = new LinkedList<Runnable>();
		if (finishRunnable != null) {
			runnables.add(finishRunnable);
		}
		myOnCoverSyncRunnables.put(image.Url, runnables);
		myPool.execute(new Runnable() {
			public void run() {
				image.synchronize();
				myCoverSynchronizedHandler.fireMessage(image.Url);
			}
		});
	}

	public final boolean isCoverLoading(String coverUrl) {
		return myOnCoverSyncRunnables.containsKey(coverUrl);
	}

	public void addCoverSynchronizationRunnable(String coverUrl, Runnable finishRunnable) {
		final LinkedList<Runnable> runnables = myOnCoverSyncRunnables.get(coverUrl);
		if (runnables != null && finishRunnable != null) {
			runnables.add(finishRunnable);
		}
	}


	/*
	 * Open Network URL in browser
	 */

	public void openInBrowser(Context context, String url) {
		if (url != null) {
			url = NetworkLibrary.Instance().rewriteUrl(url, true);
			context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
		}
	}


	/*
	 * Notifying view's components from services
	 */

	public interface EventListener {
		void onModelChanged();
	}

	private Handler myEventHandler;
	private LinkedList<EventListener> myEventListeners = new LinkedList<EventListener>();

	/*
	 * This method must be called only from main thread
	 */
	public final void addEventListener(EventListener listener) {
		synchronized (myEventListeners) {
			if (myEventHandler == null) {
				myEventHandler = new Handler() {
					@Override
					public void handleMessage(Message msg) {
						fireModelChanged();
					}
				};
			}
			if (listener != null) {
				myEventListeners.add(listener);
			}
		}
	}

	public final void removeEventListener(EventListener listener) {
		synchronized (myEventListeners) {
			myEventListeners.remove(listener);
		}
	}

	final void fireModelChangedAsync() {
		synchronized (myEventListeners) {
			if (myEventHandler != null) {
				myEventHandler.sendEmptyMessage(0);
			}
		}
	}

	final void fireModelChanged() {
		for (EventListener listener: myEventListeners) {
			listener.onModelChanged();
		}
	}


	/*
	 * Starting BookInfo activity
	 */

	private NetworkBookItem myBookInfoItem;

	public void showBookInfoActivity(Context context, NetworkBookItem book) {
		myBookInfoItem = book;
		context.startActivity(
			new Intent(context.getApplicationContext(), NetworkBookInfoActivity.class)
		);
	}

	NetworkBookItem getBookInfoItem() {
		return myBookInfoItem;
	}


	/*
	 * Opening Catalogs & managing opened catalogs stack
	 */

	private final LinkedList<NetworkTree> myOpenedStack = new LinkedList<NetworkTree>();
	private final HashMap<String, NetworkCatalogActivity> myOpenedActivities = new HashMap<String, NetworkCatalogActivity>();

	public void openTree(Context context, NetworkTree tree, String key) {
		final int level = tree.Level - 1; // tree.Level == 1 for catalog's root element
		if (level > myOpenedStack.size()) {
			throw new RuntimeException(""Unable to open catalog with Level greater than the number of opened catalogs.\n""
				+ ""Catalog: "" + tree.getName() + ""\n""
				+ ""Level: "" + level + ""\n""
				+ ""Opened catalogs: "" + myOpenedStack.size());
		}
		while (level < myOpenedStack.size()) {
			myOpenedStack.removeLast();
		}
		myOpenedStack.add(tree);

		context.startActivity(
			new Intent(context.getApplicationContext(), NetworkCatalogActivity.class)
				.putExtra(NetworkCatalogActivity.CATALOG_LEVEL_KEY, level)
				.putExtra(NetworkCatalogActivity.CATALOG_KEY_KEY, key)
		);
	}

	void setOpenedActivity(String key, NetworkCatalogActivity activity) {
		if (activity == null) {
			myOpenedActivities.remove(key);
		} else {
			myOpenedActivities.put(key, activity);
		}
	}

	public NetworkCatalogActivity getOpenedActivity(String key) {
		return myOpenedActivities.get(key);
	}

	public NetworkTree getOpenedTree(int level) {
		if (level < 0 || level >= myOpenedStack.size()) {
			return null;
		}
		return myOpenedStack.get(level);
	}

	/*
	 * Special view items item
	 */

	private final SearchItemTree mySearchItem = new SearchItemTree();
	private final AddCustomCatalogItemTree myAddCustomCatalogItem = new AddCustomCatalogItemTree();

	public SearchItemTree getSearchItemTree() {
		return mySearchItem;
	}

	public AddCustomCatalogItemTree getAddCustomCatalogItemTree() {
		return myAddCustomCatalogItem;
	}
}
",True,377,1,3,8,104,13,19,L6
216,org.geometerplus.android.fbreader.network.BookDownloaderService.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;
import java.io.*;
import java.net.URLConnection;

import android.os.IBinder;
import android.os.Handler;
import android.os.Message;
import android.app.Service;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.net.Uri;
import android.content.Intent;
import android.widget.RemoteViews;
import android.widget.Toast;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.*;

import org.geometerplus.fbreader.network.BookReference;


public class BookDownloaderService extends Service {

	public static final String BOOK_FORMAT_KEY = ""org.geometerplus.android.fbreader.network.BookFormat"";
	public static final String REFERENCE_TYPE_KEY = ""org.geometerplus.android.fbreader.network.ReferenceType"";
	public static final String CLEAN_URL_KEY = ""org.geometerplus.android.fbreader.network.CleanURL"";
	public static final String TITLE_KEY = ""org.geometerplus.android.fbreader.network.Title"";
	public static final String SSL_CERTIFICATE_KEY = ""org.geometerplus.android.fbreader.network.SSLCertificate"";

	public static final String SHOW_NOTIFICATIONS_KEY = ""org.geometerplus.android.fbreader.network.ShowNotifications"";

	public interface Notifications {
		int DOWNLOADING_STARTED = 0x0001;
		int ALREADY_DOWNLOADING = 0x0002;

		int ALL = 0x0003;
	}


	private Set<String> myDownloadingURLs = Collections.synchronizedSet(new HashSet<String>());
	private Set<Integer> myOngoingNotifications = new HashSet<Integer>();

	private volatile int myServiceCounter;

	private void doStart() {
		++myServiceCounter;
	}

	private void doStop() {
		if (--myServiceCounter == 0) {
			stopSelf();
		}
	}

	public static ZLResource getResource() {
		return ZLResource.resource(""bookDownloader"");
	}

	@Override
	public IBinder onBind(Intent intent) {
		return new BookDownloaderInterface.Stub() {
			public boolean isBeingDownloaded(String url) {
				return myDownloadingURLs.contains(url);
			}
		};
	}

	@Override
	public void onDestroy() {
		final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		for (int notificationId: myOngoingNotifications) {
			notificationManager.cancel(notificationId);
		}
		myOngoingNotifications.clear();
		super.onDestroy();
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		doStart();

		final Uri uri = intent.getData();
		if (uri == null) {
			doStop();
			return;
		}
		intent.setData(null);

		final int notifications = intent.getIntExtra(SHOW_NOTIFICATIONS_KEY, 0);

		final String url = uri.toString();
		final int bookFormat = intent.getIntExtra(BOOK_FORMAT_KEY, BookReference.Format.NONE);
		final int referenceType = intent.getIntExtra(REFERENCE_TYPE_KEY, BookReference.Type.UNKNOWN);
		String cleanURL = intent.getStringExtra(CLEAN_URL_KEY);
		if (cleanURL == null) {
			cleanURL = url;
		}

		if (myDownloadingURLs.contains(url)) {
			if ((notifications & Notifications.ALREADY_DOWNLOADING) != 0) {
				Toast.makeText(
					getApplicationContext(),
					getResource().getResource(""alreadyDownloading"").getValue(),
					Toast.LENGTH_SHORT
				).show();
			}
			doStop();
			return;
		}

		String fileName = BookReference.makeBookFileName(cleanURL, bookFormat, referenceType);
		if (fileName == null) {
			doStop();
			return;
		}

		int index = fileName.lastIndexOf(File.separator);
		if (index != -1) {
			final String dir = fileName.substring(0, index);
			final File dirFile = new File(dir);
			if (!dirFile.exists() && !dirFile.mkdirs()) {
				// TODO: error message
				doStop();
				return;
			}
			if (!dirFile.exists() || !dirFile.isDirectory()) {
				// TODO: error message
				doStop();
				return;
			}
		}

		final File fileFile = new File(fileName);
		if (fileFile.exists()) {
			if (!fileFile.isFile()) {
				// TODO: error message
				doStop();
				return;
			}
			// TODO: question box: redownload?
			/*
			ZLDialogManager.Instance().showQuestionBox(
				""redownloadBox"", ""Redownload?"",
				""no"", null,
				""yes"", null,
				null, null
			);
			*/
			doStop();
			startActivity(getFBReaderIntent(fileFile));
			return;
		}
		String title = intent.getStringExtra(TITLE_KEY);
		if (title == null || title.length() == 0) {
			title = fileFile.getName();
		}
		if ((notifications & Notifications.DOWNLOADING_STARTED) != 0) {
			Toast.makeText(
				getApplicationContext(),
				getResource().getResource(""downloadingStarted"").getValue(),
				Toast.LENGTH_SHORT
			).show();
		}
		final String sslCertificate = intent.getStringExtra(SSL_CERTIFICATE_KEY);
		startFileDownload(url, sslCertificate, fileFile, title);
	}

	private Intent getFBReaderIntent(final File file) {
		final Intent intent = new Intent(getApplicationContext(), org.geometerplus.android.fbreader.FBReader.class);
		if (file != null) {
			intent.setAction(Intent.ACTION_VIEW).setData(Uri.fromFile(file));
		}
		return intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
	}

	private Notification createDownloadFinishNotification(File file, String title, boolean success) {
		final ZLResource resource = getResource();
		final String tickerText = success ?
			resource.getResource(""tickerSuccess"").getValue() :
			resource.getResource(""tickerError"").getValue();
		final String contentText = success ?
			resource.getResource(""contentSuccess"").getValue() :
			resource.getResource(""contentError"").getValue();
		final Notification notification = new Notification(
			android.R.drawable.stat_sys_download_done,
			tickerText,
			System.currentTimeMillis()
		);
		notification.flags |= Notification.FLAG_AUTO_CANCEL;
		final Intent intent = success ? getFBReaderIntent(file) : new Intent();
		final PendingIntent contentIntent = PendingIntent.getActivity(this, 0, intent, 0);
		notification.setLatestEventInfo(getApplicationContext(), title, contentText, contentIntent);
		return notification;
	}

	private Notification createDownloadProgressNotification(String title) {
		final RemoteViews contentView = new RemoteViews(getPackageName(), R.layout.download_notification);
		contentView.setTextViewText(R.id.download_notification_title, title);
		contentView.setTextViewText(R.id.download_notification_progress_text, """");
		contentView.setProgressBar(R.id.download_notification_progress_bar, 100, 0, true);

		final PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(), 0);

		final Notification notification = new Notification();
		notification.icon = android.R.drawable.stat_sys_download;
		notification.flags |= Notification.FLAG_ONGOING_EVENT;
		notification.contentView = contentView;
		notification.contentIntent = contentIntent;

		return notification;
	}

	private void sendDownloaderCallback() {
		sendBroadcast(
			new Intent(getApplicationContext(), BookDownloaderCallback.class)
		);
	}

	private void startFileDownload(final String urlString, final String sslCertificate, final File file, final String title) {
		myDownloadingURLs.add(urlString);
		sendDownloaderCallback();

		final int notificationId = NetworkNotifications.Instance().getBookDownloadingId();
		final Notification progressNotification = createDownloadProgressNotification(title);

		final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		myOngoingNotifications.add(Integer.valueOf(notificationId));
		notificationManager.notify(notificationId, progressNotification);

		final Handler progressHandler = new Handler() {
			public void handleMessage(Message message) {
				final int progress = message.what;
				final RemoteViews contentView = (RemoteViews)progressNotification.contentView;

				if (progress < 0) {
					contentView.setTextViewText(R.id.download_notification_progress_text, """");
					contentView.setProgressBar(R.id.download_notification_progress_bar, 100, 0, true);
				} else {
					contentView.setTextViewText(R.id.download_notification_progress_text, """" + progress + ""%"");
					contentView.setProgressBar(R.id.download_notification_progress_bar, 100, progress, false);
				}
				final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
				notificationManager.notify(notificationId, progressNotification);
			}
		};

		final Handler downloadFinishHandler = new Handler() {
			public void handleMessage(Message message) {
				myDownloadingURLs.remove(urlString);
				final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
				notificationManager.cancel(notificationId);
				myOngoingNotifications.remove(Integer.valueOf(notificationId));
				notificationManager.notify(
					notificationId,
					createDownloadFinishNotification(file, title, message.what != 0)
				);
				sendDownloaderCallback();
				doStop();
			}
		};

		final ZLNetworkRequest request = new ZLNetworkRequest(urlString, sslCertificate) {

			public String handleStream(URLConnection connection, InputStream inputStream) throws IOException {
				final int updateIntervalMillis = 1000; // FIXME: remove hardcoded time constant

				final int fileLength = connection.getContentLength();
				int downloadedPart = 0;
				long progressTime = System.currentTimeMillis() + updateIntervalMillis;
				if (fileLength <= 0) {
					progressHandler.sendEmptyMessage(-1);
				}
				OutputStream outStream;
				try {
					outStream = new FileOutputStream(file);
				} catch (FileNotFoundException ex) {
					return ZLNetworkErrors.errorMessage(ZLNetworkErrors.ERROR_CREATE_FILE, file.getPath());
				}
				try {
					final byte[] buffer = new byte[8192];
					while (true) {
						final int size = inputStream.read(buffer);
						if (size <= 0) {
							break;
						}
						downloadedPart += size;
						if (fileLength > 0) {
							final long currentTime = System.currentTimeMillis();
							if (currentTime > progressTime) {
								progressTime = currentTime + updateIntervalMillis;
								progressHandler.sendEmptyMessage(downloadedPart * 100 / fileLength);
							}
							/*if (downloadedPart * 100 / fileLength > 95) {
								throw new IOException(""debug exception"");
							}*/
						}
						outStream.write(buffer, 0, size);
						/*try {
							Thread.currentThread().sleep(200);
						} catch (InterruptedException ex) {
						}*/
					}
				} finally {
					outStream.close();
				}
				return null;
			}
		};

		final Thread downloader = new Thread(new Runnable() {
			public void run() {
				final String err = ZLNetworkManager.Instance().perform(request);
				// TODO: show error message to User
				final boolean success = (err == null);
				if (!success) {
					file.delete();
				}
				downloadFinishHandler.sendEmptyMessage(success ? 1 : 0);
			}
		});
		downloader.setPriority(Thread.MIN_PRIORITY);
		downloader.start();
	}
}
",True,374,0,0,10,86,3,7,L6
217,org.geometerplus.android.fbreader.network.AddCustomCatalogItemActions.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.NetworkTree;


class AddCustomCatalogItemActions extends NetworkTreeActions {

	public static final int RUN_ITEM_ID = 0;

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof AddCustomCatalogItemTree;
	}

	@Override
	public void buildContextMenu(NetworkBaseActivity activity, ContextMenu menu, NetworkTree tree) {
	}

	@Override
	public int getDefaultActionCode(NetworkTree tree) {
		return RUN_ITEM_ID;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		switch (actionCode) {
			case RUN_ITEM_ID:
				addCustomCatalog(activity);
				return true;
		}
		return false;
	}

	public static void addCustomCatalog(Activity activity) {
		NetworkDialog.show(activity, NetworkDialog.DIALOG_CUSTOM_CATALOG, null, null);
	}
}
",False,374,0,0,9,107,2,5,L6
218,org.geometerplus.android.fbreader.network.RegisterUserDialog.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;

import android.app.Dialog;
import android.app.AlertDialog;
import android.view.View;
import android.widget.Button;
import android.widget.TextView;
import android.content.Context;
import android.content.DialogInterface;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.NetworkErrors;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class RegisterUserDialog extends NetworkDialog {

	private String myLogin;
	private String myPassword;
	private String myConfirmPassword;
	private String myEmail;

	private ArrayList<String> mySystemEmails = new ArrayList<String>();

	public RegisterUserDialog() {
		super(""RegisterUserDialog"");
	}

	@Override
	protected void clearData() {
		myLogin = myPassword = myConfirmPassword = myEmail = null;
	}

	@Override
	public View createLayout() {
		final View layout = myActivity.getLayoutInflater().inflate(R.layout.network_register_user_dialog, null);

		((TextView) layout.findViewById(R.id.network_register_login_text)).setText(myResource.getResource(""login"").getValue());
		((TextView) layout.findViewById(R.id.network_register_password_text)).setText(myResource.getResource(""password"").getValue());
		((TextView) layout.findViewById(R.id.network_register_confirm_password_text)).setText(myResource.getResource(""confirmPassword"").getValue());
		((TextView) layout.findViewById(R.id.network_register_email_text)).setText(myResource.getResource(""email"").getValue());

		mySystemEmails.clear();
		collectEMails(myActivity.getApplicationContext(), mySystemEmails);

		if (!mySystemEmails.isEmpty()) {
			final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
					if (which >= 0 && which < mySystemEmails.size()) {
						myEmail = mySystemEmails.get(which);
					}
					dialog.dismiss();
				}
			};

			((Button) layout.findViewById(R.id.network_register_email_button)).setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					myLogin = ((TextView) layout.findViewById(R.id.network_register_login)).getText().toString().trim();
					myPassword = ((TextView) layout.findViewById(R.id.network_register_password)).getText().toString();
					myConfirmPassword = ((TextView) layout.findViewById(R.id.network_register_confirm_password)).getText().toString();
					myEmail = ((TextView) layout.findViewById(R.id.network_register_email)).getText().toString().trim();

					final int selected = mySystemEmails.indexOf(myEmail);
					final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
					final AlertDialog dialog = new AlertDialog.Builder(myActivity)
						.setSingleChoiceItems(mySystemEmails.toArray(new String[mySystemEmails.size()]), selected, listener)
						.setTitle(myResource.getResource(""email"").getValue())
						.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), null)
						.create();

					dialog.setOnDismissListener(new DialogInterface.OnDismissListener() {
						public void onDismiss(DialogInterface dialog) {
							myActivity.showDialog(myId);
						}
					});

					myActivity.dismissDialog(myId);
					dialog.show();
				}
			});
		}

		return layout;
	}

	@Override
	protected void onPositive(DialogInterface dialog) {
		AlertDialog alert = (AlertDialog) dialog;
		myLogin = ((TextView) alert.findViewById(R.id.network_register_login)).getText().toString().trim();
		myPassword = ((TextView) alert.findViewById(R.id.network_register_password)).getText().toString();
		myConfirmPassword = ((TextView) alert.findViewById(R.id.network_register_confirm_password)).getText().toString();
		myEmail = ((TextView) alert.findViewById(R.id.network_register_email)).getText().toString().trim();

		if (myLogin.length() == 0) {
			myLogin = null;
			final String err = NetworkErrors.errorMessage(NetworkErrors.ERROR_LOGIN_WAS_NOT_SPECIFIED);
			sendError(true, false, err);
			return;
		}
		if (!myPassword.equals(myConfirmPassword)) {
			final String err = myResource.getResource(""differentPasswords"").getValue();
			myPassword = null;
			myConfirmPassword = null;
			sendError(true, false, err);
			return;
		}
		if (myEmail.length() == 0) {
			myEmail = null;
			final String err = NetworkErrors.errorMessage(NetworkErrors.ERROR_EMAIL_WAS_NOT_SPECIFIED);
			sendError(true, false, err);
			return;
		}
		final int atPos = myEmail.indexOf(""@"");
		if (atPos == -1 || myEmail.indexOf(""."", atPos) == -1) {
			final String err = NetworkErrors.errorMessage(NetworkErrors.ERROR_INVALID_EMAIL);
			sendError(true, false, err);
			return;
		}
		final NetworkAuthenticationManager mgr = myLink.authenticationManager();
		final Runnable runnable = new Runnable() {
			public void run() {
				String err = mgr.registerUser(myLogin, myPassword, myEmail);
				if (err != null) {
					mgr.logOut();
					sendError(true, false, err);
					return;
				}
				if (mgr.isAuthorised(true).Status != ZLBoolean3.B3_FALSE && mgr.needsInitialization()) {
					err = mgr.initialize();
					if (err != null) {
						mgr.logOut();
						sendError(false, false, err);
						return;
					}
				}
				sendSuccess(false);
			}
		};
		((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""registerUser"", runnable, myActivity);
	}

	@Override
	protected void onNegative(DialogInterface dialog) {
		sendCancel(false);
	}

	@Override
	public void prepareDialogInternal(Dialog dialog) {
		dialog.findViewById(R.id.network_register_email_button).setVisibility((mySystemEmails.size() > 1) ? View.VISIBLE : View.GONE);
		if (!mySystemEmails.isEmpty() && (myEmail == null || myEmail.length() == 0)) {
			myEmail = mySystemEmails.get(0);
		}

		((TextView) dialog.findViewById(R.id.network_register_login)).setText(myLogin);
		((TextView) dialog.findViewById(R.id.network_register_password)).setText(myPassword);
		((TextView) dialog.findViewById(R.id.network_register_confirm_password)).setText(myConfirmPassword);
		((TextView) dialog.findViewById(R.id.network_register_email)).setText(myEmail);

		final TextView error = (TextView) dialog.findViewById(R.id.network_register_error);
		if (myErrorMessage == null) {
			error.setVisibility(View.GONE);
			error.setText("""");
		} else {
			error.setVisibility(View.VISIBLE);
			error.setText(myErrorMessage);
		}

		View dlgView = dialog.findViewById(R.id.network_register_user_dialog);
		dlgView.invalidate();
		dlgView.requestLayout();
	}


	private static void collectEMails(Context context, List<String> emails) {
		try {
			final Class<?> cls$AccountManager = Class.forName(""android.accounts.AccountManager"");
			final Class<?> cls$Account = Class.forName(""android.accounts.Account"");

			final Method meth$AccountManager$get = cls$AccountManager.getMethod(""get"", Context.class);
			final Method meth$AccountManager$getAccountsByType = cls$AccountManager.getMethod(""getAccountsByType"", String.class);
			final Field fld$Account$name = cls$Account.getField(""name"");

			if (meth$AccountManager$get.getReturnType() == cls$AccountManager
					&& meth$AccountManager$getAccountsByType.getReturnType().getComponentType() == cls$Account
					&& fld$Account$name.getType() == String.class) {
				final Object mgr = meth$AccountManager$get.invoke(null, context);
				final Object[] accountsByType = (Object[]) meth$AccountManager$getAccountsByType.invoke(mgr, ""com.google""); 
				for (Object a: accountsByType) {
					final String value = (String) fld$Account$name.get(a);
					if (value != null && value.length() > 0) {
						emails.add(value);
					}
				}
			}
		} catch (ClassNotFoundException e) {
		} catch (NoSuchMethodException e) {
		} catch (NoSuchFieldException e) {
		} catch (IllegalAccessException e) {
		} catch (IllegalArgumentException e) {
		} catch (InvocationTargetException e) {
		}
	}
}
",False,374,0,0,10,97,1,10,L6
219,org.geometerplus.android.fbreader.network.NetworkTreeActions.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.view.Menu;
import android.view.ContextMenu;
import android.view.MenuItem;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.NetworkTree;


abstract class NetworkTreeActions {

	// special values to return from getDefaultActionCode(NetworkTree)
	public static final int TREE_NO_ACTION = -1;
	public static final int TREE_SHOW_CONTEXT_MENU = -2;


	protected final ZLResource myResource = ZLResource.resource(""networkView"");

	protected final String getTitleValue(String key) {
		return myResource.getResource(key).getValue();
	}

	protected final String getTitleValue(String key, String arg) {
		return myResource.getResource(key).getValue().replace(""%s"", arg);
	}

	protected final String getConfirmValue(String key) {
		return myResource.getResource(""confirmQuestions"").getResource(key).getValue();
	}

	protected final String getConfirmValue(String key, String arg) {
		return myResource.getResource(""confirmQuestions"").getResource(key).getValue().replace(""%s"", arg);
	}

	protected final String getOptionsValue(String key) {
		return myResource.getResource(""menu"").getResource(key).getValue();
	}

	protected final String getOptionsValue(String key, String arg) {
		return myResource.getResource(""menu"").getResource(key).getValue().replace(""%s"", arg);
	}

	protected final MenuItem addMenuItem(ContextMenu menu, int id, String key) {
		return menu.add(0, id, 0, getTitleValue(key)).setEnabled(id != TREE_NO_ACTION);
	}

	protected final MenuItem addMenuItem(ContextMenu menu, int id, String key, String arg) {
		return menu.add(0, id, 0, getTitleValue(key, arg)).setEnabled(id != TREE_NO_ACTION);
	}

	protected final MenuItem addOptionsItem(Menu menu, int id, String key/*, int iconId*/) {
		final MenuItem item = menu.add(0, id, 0, getOptionsValue(key));
		//item.setIcon(iconId);
		return item;
	}

	protected final MenuItem addOptionsItem(Menu menu, int id, String key, String arg/*, int iconId*/) {
		final MenuItem item = menu.add(0, id, 0, getOptionsValue(key, arg));
		//item.setIcon(iconId);
		return item;
	}

	protected final MenuItem prepareOptionsItem(Menu menu, int id, boolean state) {
		return menu.findItem(id).setVisible(state).setEnabled(state);
	}

	protected final MenuItem prepareOptionsItem(Menu menu, int id, boolean state, String key, String arg) {
		final MenuItem item = prepareOptionsItem(menu, id, state);
		if (state) {
			item.setTitle(getOptionsValue(key, arg));
		}
		return item;
	}


	public abstract boolean canHandleTree(NetworkTree tree);

	public String getTreeTitle(NetworkTree tree) {
		return tree.getName();
	}

	public abstract void buildContextMenu(NetworkBaseActivity activity, ContextMenu menu, NetworkTree tree);

	public abstract int getDefaultActionCode(NetworkTree tree);
	public abstract String getConfirmText(NetworkTree tree, int actionCode);

	public abstract boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode);

	public abstract boolean createOptionsMenu(Menu menu, NetworkTree tree);
	public abstract boolean prepareOptionsMenu(Menu menu, NetworkTree tree);
}
",False,375,1,1,9,91,9,4,L6
220,org.geometerplus.android.fbreader.network.SQLiteNetworkDatabase.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.HashMap;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.network.ICustomNetworkLink;
import org.geometerplus.fbreader.network.NetworkDatabase;

class SQLiteNetworkDatabase extends NetworkDatabase {
	private final SQLiteDatabase myDatabase;

	SQLiteNetworkDatabase() {
		myDatabase = ZLAndroidApplication.Instance().openOrCreateDatabase(""network.db"", Context.MODE_PRIVATE, null);
		migrate();
	}

	private void migrate() {
		final int version = myDatabase.getVersion();
		final int currentCodeVersion = 1;
		if (version >= currentCodeVersion) {
			return;
		}
		myDatabase.beginTransaction();
		switch (version) {
			case 0:
				createTables();
		}
		myDatabase.setTransactionSuccessful();
		myDatabase.endTransaction();

		myDatabase.execSQL(""VACUUM"");
		myDatabase.setVersion(currentCodeVersion);
	}

	protected void executeAsATransaction(Runnable actions) {
		myDatabase.beginTransaction();
		try {
			actions.run();
			myDatabase.setTransactionSuccessful();
		} finally {
			myDatabase.endTransaction();
		}
	}

	private static void bindString(SQLiteStatement statement, int index, String value) {
		if (value != null) {
			statement.bindString(index, value);
		} else {
			statement.bindNull(index);
		}
	}

	@Override
	protected void loadCustomLinks(ICustomLinksHandler handler) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT link_id,title,site_name,summary,icon FROM CustomLinks"", null);
		final HashMap<String,String> linksMap = new HashMap<String,String>();
		while (cursor.moveToNext()) {
			final int id = cursor.getInt(0);
			final String title = cursor.getString(1);
			final String siteName = cursor.getString(2);
			final String summary = cursor.getString(3);
			final String icon = cursor.getString(4);

			linksMap.clear();
			final Cursor linksCursor = myDatabase.rawQuery(""SELECT key,url FROM CustomLinkUrls WHERE link_id = "" + id, null);
			while (linksCursor.moveToNext()) {
				linksMap.put(linksCursor.getString(0), linksCursor.getString(1));
			}
			linksCursor.close();

			handler.handleCustomLinkData(id, siteName, title, summary, icon, linksMap);
		}
		cursor.close();
	}

	private SQLiteStatement myInsertCustomLinkStatement;
	private SQLiteStatement myUpdateCustomLinkStatement;
	private SQLiteStatement myInsertCustomLinkUrlStatement;
	private SQLiteStatement myUpdateCustomLinkUrlStatement;
	private SQLiteStatement myDeleteCustomLinkUrlStatement;
	@Override
	protected void saveCustomLink(final ICustomNetworkLink link) {
		executeAsATransaction(new Runnable() {
			public void run() {
				final SQLiteStatement statement;
				if (link.getId() == ICustomNetworkLink.INVALID_ID) {
					if (myInsertCustomLinkStatement == null) {
						myInsertCustomLinkStatement = myDatabase.compileStatement(
							""INSERT INTO CustomLinks (title,site_name,summary,icon) VALUES (?,?,?,?)""
						);
					}
					statement = myInsertCustomLinkStatement;
				} else {
					if (myUpdateCustomLinkStatement == null) {
						myUpdateCustomLinkStatement = myDatabase.compileStatement(
							""UPDATE CustomLinks SET title = ?, site_name = ?, summary =?, icon = ? ""
								+ ""WHERE link_id = ?""
						);
					}
					statement = myUpdateCustomLinkStatement;
				}

				statement.bindString(1, link.getTitle());
				statement.bindString(2, link.getSiteName());
				bindString(statement, 3, link.getSummary());
				bindString(statement, 4, link.getIcon());

				final long id;
				final HashMap<String,String> linksMap = new HashMap<String,String>();

				if (statement == myInsertCustomLinkStatement) {
					id = statement.executeInsert();
					link.setId((int) id);
				} else {
					id = link.getId();
					statement.bindLong(5, id);
					statement.execute();
					
					final Cursor linksCursor = myDatabase.rawQuery(""SELECT key,url FROM CustomLinkUrls WHERE link_id = "" + link.getId(), null);
					while (linksCursor.moveToNext()) {
						linksMap.put(linksCursor.getString(0), linksCursor.getString(1));
					}
					linksCursor.close();
				}

				for (String key: link.getLinkKeys()) {
					final String value = link.getLink(key);
					final String dbValue = linksMap.remove(key);
					final SQLiteStatement urlStatement;
					if (dbValue == null) {
						if (myInsertCustomLinkUrlStatement == null) {
							myInsertCustomLinkUrlStatement = myDatabase.compileStatement(
									""INSERT INTO CustomLinkUrls(url,link_id,key) VALUES (?,?,?)"");
						}
						urlStatement = myInsertCustomLinkUrlStatement;
					} else if (!value.equals(dbValue)) {
						if (myUpdateCustomLinkUrlStatement == null) {
							myUpdateCustomLinkUrlStatement = myDatabase.compileStatement(
									""UPDATE CustomLinkUrls SET url = ? WHERE link_id = ? AND key = ?"");
						}
						urlStatement = myUpdateCustomLinkUrlStatement;
					} else {
						continue;
					}
					urlStatement.bindString(1, value);
					urlStatement.bindLong(2, id);
					urlStatement.bindString(3, key);
					urlStatement.execute();
				}
				for (String key: linksMap.keySet()) {
					if (myDeleteCustomLinkUrlStatement == null) {
						myDeleteCustomLinkUrlStatement = myDatabase.compileStatement(
								""DELETE FROM CustomLinkUrls WHERE link_id = ? AND key = ?"");
					}
					myDeleteCustomLinkUrlStatement.bindLong(1, id);
					myDeleteCustomLinkUrlStatement.bindString(2, key);
					myDeleteCustomLinkUrlStatement.execute();
				}
			}
		});
	}

	private SQLiteStatement myDeleteAllCustomLinksStatement;
	private SQLiteStatement myDeleteCustomLinkStatement;
	@Override
	protected void deleteCustomLink(final ICustomNetworkLink link) {
		if (link.getId() == ICustomNetworkLink.INVALID_ID) {
			return;
		}
		executeAsATransaction(new Runnable() {
			public void run() {
				final long id = link.getId();
				if (myDeleteAllCustomLinksStatement == null) {
					myDeleteAllCustomLinksStatement = myDatabase.compileStatement(
							""DELETE FROM CustomLinkUrls WHERE link_id = ?"");
				}
				myDeleteAllCustomLinksStatement.bindLong(1, id);
				myDeleteAllCustomLinksStatement.execute();

				if (myDeleteCustomLinkStatement == null) {
					myDeleteCustomLinkStatement = myDatabase.compileStatement(
						""DELETE FROM CustomLinks WHERE link_id = ?""
					);
				}
				myDeleteCustomLinkStatement.bindLong(1, id);
				myDeleteCustomLinkStatement.execute();

				link.setId(ICustomNetworkLink.INVALID_ID);
			}
		});
	}
	
	private void createTables() {
		myDatabase.execSQL(
				""CREATE TABLE CustomLinks("" +
					""link_id INTEGER PRIMARY KEY,"" +
					""title TEXT UNIQUE NOT NULL,"" +
					""site_name TEXT NOT NULL,"" +
					""summary TEXT,"" +
					""icon TEXT)"");
		myDatabase.execSQL(
				""CREATE TABLE CustomLinkUrls("" +
					""key TEXT NOT NULL,"" +
					""link_id INTEGER NOT NULL REFERENCES CustomLinks(link_id),"" +
					""url TEXT NOT NULL,"" +
					""CONSTRAINT CustomLinkUrls_PK PRIMARY KEY (key, link_id))"");
	}
}
",True,374,0,0,10,95,1,4,L6
221,org.geometerplus.android.fbreader.network.BookDownloader.java,"/*
 * Copyright (C) 2009-2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.List;

import android.os.Bundle;
import android.app.Activity;
import android.net.Uri;
import android.content.Intent;

import org.geometerplus.fbreader.network.BookReference;


public class BookDownloader extends Activity {

	public static boolean acceptsUri(Uri uri) {
		final List<String> path = uri.getPathSegments();
		if ((path == null) || path.isEmpty()) {
			return false;
		}

		if (""epub"".equals(uri.getScheme())) {
			return true;
		}

		final String fileName = path.get(path.size() - 1).toLowerCase();
		return
			fileName.endsWith("".fb2.zip"") ||
			fileName.endsWith("".fb2"") ||
			fileName.endsWith("".epub"") ||
			fileName.endsWith("".mobi"") ||
			fileName.endsWith("".prc"");
	}

	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		final Intent intent = getIntent();
		Uri uri = intent.getData();
		intent.setData(null);
		if (uri == null || !acceptsUri(uri)) {
			finish();
			return;
		}

		if (!intent.hasExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY)) {
			intent.putExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY, 
				BookDownloaderService.Notifications.ALREADY_DOWNLOADING);
		}
		if (""epub"".equals(uri.getScheme())) {
			uri = uri.buildUpon().scheme(""http"").build();
			intent.putExtra(BookDownloaderService.BOOK_FORMAT_KEY,
					BookReference.Format.EPUB);
		}

		startService(
			new Intent(Intent.ACTION_DEFAULT, uri, this, BookDownloaderService.class)
				.putExtras(intent.getExtras())
		);
		finish();
	}
}
",False,374,0,0,11,83,1,3,L6
222,org.geometerplus.android.fbreader.network.NetworkCatalogActions.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.List;
import java.util.Set;

import android.app.AlertDialog;
import android.os.Message;
import android.os.Handler;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkTreeFactory;
import org.geometerplus.fbreader.network.tree.NetworkCatalogTree;
import org.geometerplus.fbreader.network.tree.NetworkCatalogRootTree;
import org.geometerplus.fbreader.network.authentication.*;


class NetworkCatalogActions extends NetworkTreeActions {

	public static final int OPEN_CATALOG_ITEM_ID = 0;
	public static final int OPEN_IN_BROWSER_ITEM_ID = 1;
	public static final int RELOAD_ITEM_ID = 2;
	public static final int SIGNIN_ITEM_ID = 4;
	public static final int SIGNOUT_ITEM_ID = 5;
	public static final int REFILL_ACCOUNT_ITEM_ID = 6;

	public static final int CUSTOM_CATALOG_EDIT = 7;
	public static final int CUSTOM_CATALOG_REMOVE = 8;

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof NetworkCatalogTree;
	}

	@Override
	public String getTreeTitle(NetworkTree tree) {
		if (tree instanceof NetworkCatalogRootTree) {
			return tree.getName();
		}
		return tree.getName() + "" - "" + ((NetworkCatalogTree) tree).Item.Link.getSiteName();
	}

	@Override
	public void buildContextMenu(NetworkBaseActivity activity, ContextMenu menu, NetworkTree tree) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		final NetworkCatalogItem item = catalogTree.Item;
		menu.setHeaderTitle(tree.getName());

		final boolean isVisible = item.getVisibility() == ZLBoolean3.B3_TRUE;
		boolean hasItems = false;

		final String catalogUrl = item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		if (catalogUrl != null) {
			addMenuItem(menu, OPEN_CATALOG_ITEM_ID, ""openCatalog"");
			hasItems = true;
		}

		if (tree instanceof NetworkCatalogRootTree) {
			if (isVisible) {
				final NetworkAuthenticationManager mgr = item.Link.authenticationManager();
				if (mgr != null) {
					final boolean maybeSignedIn = mgr.isAuthorised(false).Status != ZLBoolean3.B3_FALSE;
					if (maybeSignedIn) {
						addMenuItem(menu, SIGNOUT_ITEM_ID, ""signOut"", mgr.currentUserName());
						if (mgr.refillAccountLink() != null) {
							final String account = mgr.currentAccount();
							if (account != null) {
								addMenuItem(menu, REFILL_ACCOUNT_ITEM_ID, ""refillAccount"", account);
							}
						}
					} else {
						addMenuItem(menu, SIGNIN_ITEM_ID, ""signIn"");
						//if (mgr.passwordRecoverySupported()) {
						//	registerAction(new PasswordRecoveryAction(mgr), true);
						//}
					}
				}
			}
			INetworkLink link = catalogTree.Item.Link; 
			if (link instanceof ICustomNetworkLink) {
				addMenuItem(menu, CUSTOM_CATALOG_EDIT, ""editCustomCatalog"");
				addMenuItem(menu, CUSTOM_CATALOG_REMOVE, ""removeCustomCatalog"");
			}
		} else {
			if (item.URLByType.get(NetworkCatalogItem.URL_HTML_PAGE) != null) {
				addMenuItem(menu, OPEN_IN_BROWSER_ITEM_ID, ""openInBrowser"");
				hasItems = true;
			}
		}

		if (!isVisible && !hasItems) {
			switch (item.Visibility) {
			case NetworkCatalogItem.VISIBLE_LOGGED_USER:
				if (item.Link.authenticationManager() != null) {
					addMenuItem(menu, SIGNIN_ITEM_ID, ""signIn"");
				}
				break;
			}
		}
	}

	@Override
	public int getDefaultActionCode(NetworkTree tree) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		final NetworkCatalogItem item = catalogTree.Item;
		if (item.URLByType.get(NetworkCatalogItem.URL_CATALOG) != null) {
			return OPEN_CATALOG_ITEM_ID;
		}
		if (item.URLByType.get(NetworkCatalogItem.URL_HTML_PAGE) != null) {
			return OPEN_IN_BROWSER_ITEM_ID;
		}
		if (item.getVisibility() != ZLBoolean3.B3_TRUE) {
			switch (item.Visibility) {
			case NetworkCatalogItem.VISIBLE_LOGGED_USER:
				if (item.Link.authenticationManager() != null) {
					return SIGNIN_ITEM_ID;
				}
				break;
			}
			return TREE_NO_ACTION;
		}
		return TREE_NO_ACTION;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		if (actionCode == OPEN_IN_BROWSER_ITEM_ID) {
			return getConfirmValue(""openInBrowser"");
		}
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		addOptionsItem(menu, RELOAD_ITEM_ID, ""reload"");
		addOptionsItem(menu, SIGNIN_ITEM_ID, ""signIn"");
		addOptionsItem(menu, SIGNOUT_ITEM_ID, ""signOut"", """");
		addOptionsItem(menu, REFILL_ACCOUNT_ITEM_ID, ""refillAccount"");
		return true;
	}

	@Override
	public boolean prepareOptionsMenu(Menu menu, NetworkTree tree) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		final NetworkCatalogItem item = catalogTree.Item;

		final String catalogUrl = item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		final boolean isLoading = (catalogUrl != null) ?
			NetworkView.Instance().containsItemsLoadingRunnable(catalogUrl) : false;

		prepareOptionsItem(menu, RELOAD_ITEM_ID, catalogUrl != null && !isLoading);

		boolean signIn = false;
		boolean signOut = false;
		boolean refill = false;
		String userName = null;
		String account = null;
		NetworkAuthenticationManager mgr = item.Link.authenticationManager();
		if (mgr != null) {
			if (mgr.isAuthorised(false).Status != ZLBoolean3.B3_FALSE) {
				userName = mgr.currentUserName();
				signOut = true;
				account = mgr.currentAccount();
				if (mgr.refillAccountLink() != null && account != null) {
					refill = true;
				}
			} else {
				signIn = true;
				//if (mgr.passwordRecoverySupported()) {
				//	registerAction(new PasswordRecoveryAction(mgr), true);
				//}
			}
		}
		prepareOptionsItem(menu, SIGNIN_ITEM_ID, signIn);
		prepareOptionsItem(menu, SIGNOUT_ITEM_ID, signOut, ""signOut"", userName);
		prepareOptionsItem(menu, REFILL_ACCOUNT_ITEM_ID, refill);
		return true;
	}

	private boolean consumeByVisibility(final NetworkBaseActivity activity, final NetworkTree tree, final int actionCode) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		if (catalogTree.Item.getVisibility() == ZLBoolean3.B3_TRUE) {
			return false;
		}
		switch (catalogTree.Item.Visibility) {
		case NetworkCatalogItem.VISIBLE_LOGGED_USER:
			NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, ((NetworkCatalogTree)tree).Item.Link, new Runnable() {
				public void run() {
					if (catalogTree.Item.getVisibility() != ZLBoolean3.B3_TRUE) {
						return;
					}
					if (actionCode != SIGNIN_ITEM_ID) {
						runAction(activity, tree, actionCode);
					}
				}
			});
			break;
		}
		return true;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		if (consumeByVisibility(activity, tree, actionCode)) {
			return true;
		}
		switch (actionCode) {
			case OPEN_CATALOG_ITEM_ID:
				doExpandCatalog(activity, (NetworkCatalogTree)tree);
				return true;
			case OPEN_IN_BROWSER_ITEM_ID:
				NetworkView.Instance().openInBrowser(
					activity,
					((NetworkCatalogTree)tree).Item.URLByType.get(NetworkCatalogItem.URL_HTML_PAGE)
				);
				return true;
			case RELOAD_ITEM_ID:
				doReloadCatalog(activity, (NetworkCatalogTree)tree);
				return true;
			case SIGNIN_ITEM_ID:
				NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, ((NetworkCatalogTree)tree).Item.Link, null);
				return true;
			case SIGNOUT_ITEM_ID:
				doSignOut(activity, (NetworkCatalogTree)tree);
				return true;
			case REFILL_ACCOUNT_ITEM_ID:
				NetworkView.Instance().openInBrowser(
					activity,
					((NetworkCatalogTree)tree).Item.Link.authenticationManager().refillAccountLink()
				);
				return true;
			case CUSTOM_CATALOG_EDIT:
				NetworkDialog.show(activity, NetworkDialog.DIALOG_CUSTOM_CATALOG, ((NetworkCatalogTree)tree).Item.Link, null);
				return true;
			case CUSTOM_CATALOG_REMOVE:
				removeCustomLink((ICustomNetworkLink)((NetworkCatalogTree)tree).Item.Link);
				return true;
		}
		return false;
	}


	private static class ExpandCatalogHandler extends ItemsLoadingHandler {

		private final String myKey;
		private final NetworkCatalogTree myTree;

		ExpandCatalogHandler(NetworkCatalogTree tree, String key) {
			myTree = tree;
			myKey = key;
		}

		@Override
		public void onUpdateItems(List<NetworkLibraryItem> items) {
			for (NetworkLibraryItem item: items) {
				myTree.ChildrenItems.add(item);
				NetworkTreeFactory.createNetworkTree(myTree, item);
			}
		}

		@Override
		public void afterUpdateItems() {
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		@Override
		public void onFinish(String errorMessage, boolean interrupted,
				Set<NetworkLibraryItem> uncommitedItems) {
			if (interrupted &&
					(!myTree.Item.supportsResumeLoading() || errorMessage != null)) {
				myTree.ChildrenItems.clear();
				myTree.clear();
			} else {
				myTree.removeItems(uncommitedItems);
				myTree.updateLoadedTime();
				if (!interrupted) {
					afterUpdateCatalog(errorMessage, myTree.ChildrenItems.size() == 0);
				}
				final NetworkLibrary library = NetworkLibrary.Instance();
				library.invalidateVisibility();
				library.synchronize();
			}
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
			final ZLResource dialogResource = ZLResource.resource(""dialog"");
			ZLResource boxResource = null;
			String msg = null;
			if (errorMessage != null) {
				boxResource = dialogResource.getResource(""networkError"");
				msg = errorMessage;
			} else if (childrenEmpty) {
				// TODO: make ListView's empty view instead
				boxResource = dialogResource.getResource(""emptyCatalogBox"");
				msg = boxResource.getResource(""message"").getValue();
			}
			if (msg != null) {
				if (NetworkView.Instance().isInitialized()) {
					final NetworkCatalogActivity activity = NetworkView.Instance().getOpenedActivity(myKey);
					if (activity != null) {
						final ZLResource buttonResource = dialogResource.getResource(""button"");
						new AlertDialog.Builder(activity)
							.setTitle(boxResource.getResource(""title"").getValue())
							.setMessage(msg)
							.setIcon(0)
							.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
							.create().show();
					}
				}
			}
		}
	}

	private static class ExpandCatalogRunnable extends ItemsLoadingRunnable {

		private final NetworkCatalogTree myTree;
		private final boolean myCheckAuthentication;
		private final boolean myResumeNotLoad;

		public ExpandCatalogRunnable(ItemsLoadingHandler handler,
				NetworkCatalogTree tree, boolean checkAuthentication, boolean resumeNotLoad) {
			super(handler);
			myTree = tree;
			myCheckAuthentication = checkAuthentication;
			myResumeNotLoad = resumeNotLoad;
		}

		public String getResourceKey() {
			return ""downloadingCatalogs"";
		}

		public String doBefore() {
			/*if (!NetworkOperationRunnable::tryConnect()) {
				return;
			}*/
			final INetworkLink link = myTree.Item.Link;
			if (myCheckAuthentication && link.authenticationManager() != null) {
				NetworkAuthenticationManager mgr = link.authenticationManager();
				AuthenticationStatus auth = mgr.isAuthorised(true);
				if (auth.Message != null) {
					return auth.Message;
				}
				if (auth.Status == ZLBoolean3.B3_TRUE && mgr.needsInitialization()) {
					final String err = mgr.initialize();
					if (err != null) {
						mgr.logOut();
					}
				}
			}
			return null;
		}

		public String doLoading(NetworkOperationData.OnNewItemListener doWithListener) {
			if (myResumeNotLoad) {
				return myTree.Item.resumeLoading(doWithListener);
			}
			return myTree.Item.loadChildren(doWithListener);
		}
	}

	public void doExpandCatalog(final NetworkBaseActivity activity, final NetworkCatalogTree tree) {
		final String url = tree.Item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		if (url == null) {
			throw new RuntimeException(""That's impossible!!!"");
		}
		NetworkView.Instance().tryResumeLoading(activity, tree, url, new Runnable() {
			public void run() {
				boolean resumeNotLoad = false;
				if (tree.hasChildren()) {
					if (tree.isContentValid()) {
						if (tree.Item.supportsResumeLoading()) {
							resumeNotLoad = true;
						} else {
							NetworkView.Instance().openTree(activity, tree, url);
							return;
						}
					} else {
						tree.ChildrenItems.clear();
						tree.clear();
						NetworkView.Instance().fireModelChangedAsync();
					}
				}
				final ExpandCatalogHandler handler = new ExpandCatalogHandler(tree, url);
				NetworkView.Instance().startItemsLoading(
					activity,
					url,
					new ExpandCatalogRunnable(handler, tree, true, resumeNotLoad)
				);
				NetworkView.Instance().openTree(activity, tree, url);
			}
		});
	}

	public void doReloadCatalog(NetworkBaseActivity activity, final NetworkCatalogTree tree) {
		final String url = tree.Item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		if (url == null) {
			throw new RuntimeException(""That's impossible!!!"");
		}
		if (NetworkView.Instance().containsItemsLoadingRunnable(url)) {
			return;
		}
		tree.ChildrenItems.clear();
		tree.clear();
		NetworkView.Instance().fireModelChangedAsync();
		final ExpandCatalogHandler handler = new ExpandCatalogHandler(tree, url);
		NetworkView.Instance().startItemsLoading(
			activity,
			url,
			new ExpandCatalogRunnable(handler, tree, false, false)
		);
	}

	private void doSignOut(NetworkBaseActivity activity, NetworkCatalogTree tree) {
		final Handler handler = new Handler() {
			public void handleMessage(Message message) {
				final NetworkLibrary library = NetworkLibrary.Instance();
				library.invalidateVisibility();
				library.synchronize();
				if (NetworkView.Instance().isInitialized()) {
					NetworkView.Instance().fireModelChanged();
				}
			}
		};
		final NetworkAuthenticationManager mgr = tree.Item.Link.authenticationManager();
		final Runnable runnable = new Runnable() {
			public void run() {
				if (mgr.isAuthorised(false).Status != ZLBoolean3.B3_FALSE) {
					mgr.logOut();
					handler.sendEmptyMessage(0);
				}
			}
		};
		((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""signOut"", runnable, activity);
	}

	private void removeCustomLink(ICustomNetworkLink link) {
		final NetworkLibrary library = NetworkLibrary.Instance();
		library.removeCustomLink(link);
		library.updateChildren();
		library.synchronize();
		NetworkView.Instance().fireModelChangedAsync();
	}
}
",True,374,0,0,9,86,1,25,L6
223,org.geometerplus.android.fbreader.network.NetworkBaseActivity.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.HashSet;

import android.app.ListActivity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.os.Bundle;
import android.view.*;
import android.widget.ListView;
import android.widget.AdapterView;
import android.widget.ImageView;
import android.widget.TextView;
import android.content.Intent;
import android.content.DialogInterface;
import android.graphics.Bitmap;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.NetworkImage;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;


abstract class NetworkBaseActivity extends ListActivity 
		implements NetworkView.EventListener, View.OnCreateContextMenuListener {

	protected final ZLResource myResource = ZLResource.resource(""networkView"");

	public BookDownloaderServiceConnection Connection;


	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		Connection = new BookDownloaderServiceConnection();
		bindService(
			new Intent(getApplicationContext(), BookDownloaderService.class),
			Connection,
			BIND_AUTO_CREATE
		);
	}

	@Override
	public void onDestroy() {
		if (Connection != null) {
			unbindService(Connection);
			Connection = null;
		}
		super.onDestroy();
	}

	@Override
	protected void onStart() {
		super.onStart();

		/*
		 * Set listener in onStart() to give descendants initialize itself in
		 * onCreate methods before onModelChanged() will be called.
		 */
		NetworkView.Instance().addEventListener(this);
	}

	@Override
	protected void onStop() {
		NetworkView.Instance().removeEventListener(this);
		super.onStop();
	}

	@Override
	public void onResume() {
		super.onResume();
		getListView().setOnCreateContextMenuListener(this);
		onModelChanged(); // do the same update actions as upon onModelChanged
	}


	// method from NetworkView.EventListener
	public void onModelChanged() {
	}


	// this set is used to track whether this activity will be notified, when specific cover will be synchronized.
	private HashSet<String> myAwaitedCovers = new HashSet<String>();
	private ZLFileImage myFBReaderIcon = new ZLFileImage(""image/auto"", ZLResourceFile.createResourceFile(""R.drawable.fbreader""));

	private void setupCover(final ImageView coverView, NetworkTree tree, int width, int height) {
		Bitmap coverBitmap = null;
		ZLImage cover = tree.getCover();
		if (cover == null) { 
			cover = myFBReaderIcon;
		}
		if (cover != null) {
			ZLAndroidImageData data = null;
			final ZLAndroidImageManager mgr = (ZLAndroidImageManager) ZLAndroidImageManager.Instance();
			if (cover instanceof NetworkImage) {
				final NetworkImage img = (NetworkImage) cover;
				if (img.isSynchronized()) {
					data = mgr.getImageData(img);
				} else {
					final Runnable runnable = new Runnable() {
						public void run() {
							myAwaitedCovers.remove(img.Url);
							final ListView view = NetworkBaseActivity.this.getListView();
							view.invalidateViews();
						}
					};
					final NetworkView networkView = NetworkView.Instance();
					if (!networkView.isCoverLoading(img.Url)) {
						networkView.performCoverSynchronization(img, runnable);
						myAwaitedCovers.add(img.Url);
					} else if (!myAwaitedCovers.contains(img.Url)) {
						networkView.addCoverSynchronizationRunnable(img.Url, runnable);
						myAwaitedCovers.add(img.Url);
					}
				}
			} else {
				data = mgr.getImageData(cover);
			}
			if (data != null) {
				coverBitmap = data.getBitmap(2 * width, 2 * height);
			}
		}
		if (coverBitmap != null) {
			coverView.setImageBitmap(coverBitmap);
		} else {
			coverView.setImageDrawable(null);
		}
	}

	private int myCoverWidth = -1;
	private int myCoverHeight = -1;

	protected View setupNetworkTreeItemView(View convertView, final ViewGroup parent, NetworkTree tree) {
		final View view = (convertView != null) ? convertView :
			LayoutInflater.from(parent.getContext()).inflate(R.layout.network_tree_item, parent, false);

		((TextView)view.findViewById(R.id.network_tree_item_name)).setText(tree.getName());
		((TextView)view.findViewById(R.id.network_tree_item_childrenlist)).setText(tree.getSecondString());

		if (myCoverWidth == -1) {
			view.measure(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
			myCoverHeight = view.getMeasuredHeight();
			myCoverWidth = myCoverHeight * 15 / 32;
			view.requestLayout();
		}

		final ImageView coverView = (ImageView)view.findViewById(R.id.network_tree_item_icon);
		coverView.getLayoutParams().width = myCoverWidth;
		coverView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
		coverView.requestLayout();
		setupCover(coverView, tree, myCoverWidth, myCoverWidth);

		final ImageView statusView = (ImageView)view.findViewById(R.id.network_tree_item_status);
		final int status = (tree instanceof NetworkBookTree) ?
				NetworkBookActions.getBookStatus(((NetworkBookTree) tree).Book, Connection) : 0;
		if (status != 0) {
			statusView.setVisibility(View.VISIBLE);
			statusView.setImageResource(status);
		} else {
			statusView.setVisibility(View.GONE);
		}
		statusView.requestLayout();

		return view;
	}


	// from View.OnCreateContextMenuListener
	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
		final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
		final NetworkTree tree = (NetworkTree) getListAdapter().getItem(position);
		final NetworkTreeActions actions = NetworkView.Instance().getActions(tree);
		if (actions != null) {
			actions.buildContextMenu(this, menu, tree);
		}
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final NetworkTree tree = (NetworkTree) getListAdapter().getItem(position);
		final NetworkTreeActions actions = NetworkView.Instance().getActions(tree);
		if (actions != null &&
				actions.runAction(this, tree, item.getItemId())) {
			return true;
		}
		return super.onContextItemSelected(item);
	}

	@Override
	public void onListItemClick(ListView listView, View view, int position, long rowId) {
		final NetworkTree networkTree = (NetworkTree) getListAdapter().getItem(position);
		final NetworkView networkView = NetworkView.Instance();
		final NetworkTreeActions actions = networkView.getActions(networkTree);
		if (actions == null) {
			return;
		}
		final int actionCode = actions.getDefaultActionCode(networkTree);
		final String confirm = actions.getConfirmText(networkTree, actionCode);
		if (actionCode == NetworkTreeActions.TREE_SHOW_CONTEXT_MENU) {
			listView.showContextMenuForChild(view);
			return;
		}
		if (actionCode < 0) {
			return;
		}
		if (confirm != null) {
			//final ZLResource resource = myResource.getResource(""confirmQuestions"");
			final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
			new AlertDialog.Builder(this)
				.setTitle(networkTree.getName())
				.setMessage(confirm)
				.setIcon(0)
				.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface dialog, int which) {
						actions.runAction(NetworkBaseActivity.this, networkTree, actionCode);
					}
				})
				.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
				.create().show();
		} else {
			actions.runAction(this, networkTree, actionCode);
		}
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		if (!NetworkView.Instance().isInitialized()) {
			return null;
		}
		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			return dlg.createDialog(this);
		}
		return null;
	}

	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		super.onPrepareDialog(id, dialog);

		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			dlg.prepareDialog(this, dialog);
		}		
	}

	@Override
	public boolean onSearchRequested() {
		return false;
	}
}
",False,374,0,0,8,93,9,17,L6
224,org.geometerplus.android.fbreader.network.CustomCatalogDialog.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Dialog;
import android.app.AlertDialog;
import android.net.Uri;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.TextView;
import android.content.DialogInterface;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.OPDSLinkReader;


class CustomCatalogDialog extends NetworkDialog {

	private String myTitle;
	private String myUrl;
	private String mySummary;

	private boolean myLinkWithoutInfo;

	public CustomCatalogDialog() {
		super(""CustomCatalogDialog"");
	}

	@Override
	protected void clearData() {
		myTitle = myUrl = mySummary = null;
		myLinkWithoutInfo = false;
	}

	@Override
	protected View createLayout() {
		final View layout = myActivity.getLayoutInflater().inflate(R.layout.network_custom_catalog_dialog, null);

		((TextView) layout.findViewById(R.id.network_catalog_title_text)).setText(myResource.getResource(""catalogTitle"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_url_text)).setText(myResource.getResource(""catalogUrl"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_summary_text)).setText(myResource.getResource(""catalogSummary"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_title_example)).setText(myResource.getResource(""catalogTitleExample"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_url_example)).setText(myResource.getResource(""catalogUrlExample"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_summary_example)).setText(myResource.getResource(""catalogSummaryExample"").getValue());

		return layout;
	}

	@Override
	protected void onPositive(DialogInterface dialog) {
		AlertDialog alert = (AlertDialog) dialog;
		myTitle = ((TextView) alert.findViewById(R.id.network_catalog_title)).getText().toString().trim();
		myUrl = ((TextView) alert.findViewById(R.id.network_catalog_url)).getText().toString().trim();
		mySummary = ((TextView) alert.findViewById(R.id.network_catalog_summary)).getText().toString().trim();

		if (myTitle.length() == 0) {
			myTitle = null;
			if (myLink != null) {
				final String err = myResource.getResource(""titleIsEmpty"").getValue();
				sendError(true, false, err);
				return;
			}
		}
		if (myUrl.length() == 0) {
			myUrl = null;
			final String err = myResource.getResource(""urlIsEmpty"").getValue();
			sendError(true, false, err);
			return;
		}
		if (mySummary.length() == 0) {
			mySummary = null;
		}

		Uri uri = Uri.parse(myUrl);
		if (uri.getScheme() == null) {
			myUrl = ""http://"" + myUrl;
			uri = Uri.parse(myUrl);
		}

		String siteName = uri.getHost();
		if (siteName == null) {
			final String err = myResource.getResource(""invalidUrl"").getValue();
			sendError(true, false, err);
			return;
		}
		if (siteName.startsWith(""www."")) {
			siteName = siteName.substring(4);
		}

		final NetworkLibrary library = NetworkLibrary.Instance();
		if (myLink != null && library.hasCustomLinkTitle(myTitle, (ICustomNetworkLink) myLink)) {
			final String err = myResource.getResource(""titleAlreadyExists"").getValue();
			sendError(true, false, err);
			return;
		}
		if (library.hasCustomLinkSite(siteName, (ICustomNetworkLink) myLink)) {
			final String err = myResource.getResource(""siteAlreadyExists"").getValue();
			sendError(true, false, err);
			return;
		}

		if (myLink != null) {
			final ICustomNetworkLink link = (ICustomNetworkLink) myLink;
			link.setSiteName(siteName);
			link.setTitle(myTitle);
			link.setSummary(mySummary);
			link.setLink(INetworkLink.URL_MAIN, myUrl);

			if (myLinkWithoutInfo) {
				NetworkLibrary.Instance().addCustomLink(link);
				myLinkWithoutInfo = false;
			} else {
				link.saveLink();
			}
			sendSuccess(true);
			return;
		}

		myLinkWithoutInfo = true;
		myLink = OPDSLinkReader.createCustomLinkWithoutInfo(siteName, myUrl);

		final Handler handler = new Handler() {
			public void handleMessage(Message msg) {
				final String err = (String) msg.obj;
				if (err != null) {
					final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
						public void onClick(DialogInterface dialog, int which) {
							if (which == DialogInterface.BUTTON_NEGATIVE) {
								sendSuccess(true);
							} else {
								if (which == DialogInterface.BUTTON_NEUTRAL) {
									myLinkWithoutInfo = false;
									myLink = null;
								}
								sendError(true, false, null);
							}
						}
					};
					final ZLResource dialogResource = ZLResource.resource(""dialog"");
					final ZLResource boxResource = dialogResource.getResource(""networkError"");
					final ZLResource buttonResource = dialogResource.getResource(""button"");
					new AlertDialog.Builder(myActivity)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage(err)
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""continue"").getValue(), listener)
						.setNeutralButton(buttonResource.getResource(""editUrl"").getValue(), listener)
						.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
						.setOnCancelListener(new DialogInterface.OnCancelListener() {
							public void onCancel(DialogInterface dialog) {
								listener.onClick(dialog, DialogInterface.BUTTON_NEGATIVE);
							}
						})
						.create().show();
				} else {
					sendError(true, false, null);
				}
			}
		};

		final Runnable loadInfoRunnable = new Runnable() {
			public void run() {
				final ICustomNetworkLink link = (ICustomNetworkLink) myLink;
				final String err = link.reloadInfo();
				handler.sendMessage(handler.obtainMessage(0, err));
			}
		}; 
		((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""loadingCatalogInfo"", loadInfoRunnable, myActivity);
	}

	@Override
	protected void onNegative(DialogInterface dialog) {
		sendCancel(false);
	}

	@Override
	public void prepareDialogInternal(Dialog dialog) {
		if (myLink != null) {
			if (myTitle == null) myTitle = myLink.getTitle();
			if (myUrl == null) myUrl = myLink.getLink(INetworkLink.URL_MAIN);
			if (mySummary == null) mySummary = myLink.getSummary();
		}
		((TextView) dialog.findViewById(R.id.network_catalog_title)).setText(myTitle);
		((TextView) dialog.findViewById(R.id.network_catalog_url)).setText(myUrl);
		((TextView) dialog.findViewById(R.id.network_catalog_summary)).setText(mySummary);

		final int examplesVisibility = (myLink == null || myLinkWithoutInfo) ? View.VISIBLE : View.GONE;
		dialog.findViewById(R.id.network_catalog_title_example).setVisibility(examplesVisibility);
		dialog.findViewById(R.id.network_catalog_url_example).setVisibility(examplesVisibility);
		dialog.findViewById(R.id.network_catalog_summary_example).setVisibility(examplesVisibility);

		final int groupsVisibility = (myLink != null) ? View.VISIBLE : View.GONE;
		dialog.findViewById(R.id.network_catalog_title_group).setVisibility(groupsVisibility);
		dialog.findViewById(R.id.network_catalog_summary_group).setVisibility(groupsVisibility);

		final TextView error = (TextView) dialog.findViewById(R.id.network_catalog_error);
		if (myErrorMessage == null) {
			error.setVisibility(View.GONE);
			error.setText("""");
		} else {
			error.setVisibility(View.VISIBLE);
			error.setText(myErrorMessage);
		}

		View dlgView = dialog.findViewById(R.id.network_custom_catalog_dialog);
		dlgView.invalidate();
		dlgView.requestLayout();
	}
}
",False,374,0,0,10,87,1,8,L6
225,org.geometerplus.android.fbreader.network.NetworkLibraryActivity.java,"/*
 * Copyright (C) 2010 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.*;
import android.widget.BaseAdapter;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.ui.android.dialogs.ZLAndroidDialogManager;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.NetworkLibrary;


public class NetworkLibraryActivity extends NetworkBaseActivity {

	private NetworkTree myTree;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
	}

	private void prepareView() {
		if (myTree == null) {
			myTree = NetworkLibrary.Instance().getTree();
			setListAdapter(new LibraryAdapter());
			getListView().invalidateViews();
		}
	}

	private static Initializator myInitializator; 

	@Override
	public void onResume() {
		super.onResume();
		if (!NetworkView.Instance().isInitialized()) {
			if (myInitializator == null) {
				myInitializator = new Initializator(this);
				myInitializator.start();
			} else {
				myInitializator.setActivity(this);
			}
		} else {
			prepareView();
		}
	}

	@Override
	public void onDestroy() {
		if (!NetworkView.Instance().isInitialized()
				&& myInitializator != null) {
			myInitializator.setActivity(null);
		}
		super.onDestroy();
	}

	private static class Initializator extends Handler {

		private NetworkLibraryActivity myActivity;

		public Initializator(NetworkLibraryActivity activity) {
			myActivity = activity;
		}

		public void setActivity(NetworkLibraryActivity activity) {
			myActivity = activity;
		}

		final DialogInterface.OnClickListener myListener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				if (which == DialogInterface.BUTTON_POSITIVE) {
					Initializator.this.start();
				} else if (myActivity != null) {
					myActivity.finish();
				}
			}
		};

		// run this method only if myActivity != null
		private void runInitialization() {
			((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""loadingNetworkLibrary"", new Runnable() {
				public void run() {
					final String error = NetworkView.Instance().initialize();
					Initializator.this.end(error);
				}
			}, myActivity);
		}

		// run this method only if myActivity != null
		private void processResults(String error) {
			final ZLResource dialogResource = ZLResource.resource(""dialog"");
			final ZLResource boxResource = dialogResource.getResource(""networkError"");
			final ZLResource buttonResource = dialogResource.getResource(""button"");
			new AlertDialog.Builder(myActivity)
				.setTitle(boxResource.getResource(""title"").getValue())
				.setMessage(error)
				.setIcon(0)
				.setPositiveButton(buttonResource.getResource(""tryAgain"").getValue(), myListener)
				.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), myListener)
				.setOnCancelListener(new DialogInterface.OnCancelListener() {
					public void onCancel(DialogInterface dialog) {
						myListener.onClick(dialog, DialogInterface.BUTTON_NEGATIVE);
					}
				})
				.create().show();
		}

		@Override
		public void handleMessage(Message message) {
			if (myActivity == null) {
				return;
			} else if (message.what == 0) {
				runInitialization(); // run initialization process
			} else if (message.obj == null) {
				myActivity.startService(new Intent(myActivity.getApplicationContext(), LibraryInitializationService.class));
				myActivity.prepareView(); // initialization is complete successfully
			} else {
				processResults((String) message.obj); // handle initialization error
			}
		}

		public void start() {
			sendEmptyMessage(0);
		}

		private void end(String error) {
			sendMessage(obtainMessage(1, error));
		}
	}


	private final class LibraryAdapter extends BaseAdapter {

		public final int getCount() {
			if (!NetworkView.Instance().isInitialized()) {
				return 0;
			}
			return myTree.subTrees().size() + 2; // subtrees + <search item>
		}

		public final NetworkTree getItem(int position) {
			final int size = myTree.subTrees().size();
			if (position == 0) {
				return NetworkView.Instance().getSearchItemTree();
			} else if (position > 0 && position <= size) {
				return (NetworkTree) myTree.subTrees().get(position - 1);
			} else if (position == size + 1) {
				return NetworkView.Instance().getAddCustomCatalogItemTree();
			}
			return null;
		}

		public final long getItemId(int position) {
			return position;
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final NetworkTree tree = getItem(position);
			return setupNetworkTreeItemView(convertView, parent, tree);
		}
	}


	protected MenuItem addMenuItem(Menu menu, int index, String resourceKey, int iconId) {
		final String label = myResource.getResource(""menu"").getResource(resourceKey).getValue();
		return menu.add(0, index, Menu.NONE, label).setIcon(iconId);
	}


	private static final int MENU_SEARCH = 1;
	private static final int MENU_REFRESH = 2;
	private static final int MENU_ADD_CATALOG = 3;

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		addMenuItem(menu, MENU_SEARCH, ""networkSearch"", R.drawable.ic_menu_networksearch);
		addMenuItem(menu, MENU_ADD_CATALOG, ""addCustomCatalog"", android.R.drawable.ic_menu_add);
		addMenuItem(menu, MENU_REFRESH, ""refreshCatalogsList"", R.drawable.ic_menu_refresh);
		return true;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		super.onPrepareOptionsMenu(menu);
		final boolean searchInProgress = NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY);
		menu.findItem(MENU_SEARCH).setEnabled(!searchInProgress);
		return true;
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
			case MENU_SEARCH:
				return onSearchRequested();
			case MENU_ADD_CATALOG:
				AddCustomCatalogItemActions.addCustomCatalog(this);
				return true;
			case MENU_REFRESH:
				refreshCatalogsList();
				return true;
			default:
				return true;
		}
	}

	@Override
	public boolean onSearchRequested() {
		if (NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY)) {
			return false;
		}
		final NetworkLibrary library = NetworkLibrary.Instance();
		startSearch(library.NetworkSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	@Override
	public void onModelChanged() {
		getListView().invalidateViews();
	}

	private void refreshCatalogsList() {
		final NetworkView view = NetworkView.Instance();

		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				if (msg.obj == null) {
					view.finishBackgroundUpdate();
				} else {
					final ZLResource dialogResource = ZLResource.resource(""dialog"");
					final ZLResource boxResource = dialogResource.getResource(""networkError"");
					final ZLResource buttonResource = dialogResource.getResource(""button"");
					new AlertDialog.Builder(NetworkLibraryActivity.this)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage((String) msg.obj)
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
				}
			}
		};

		((ZLAndroidDialogManager)ZLAndroidDialogManager.Instance()).wait(""updatingCatalogsList"", new Runnable() {
			public void run() {
				final String result = view.runBackgroundUpdate(true);
				handler.sendMessage(handler.obtainMessage(0, result));
			}
		}, this);
	}
}
",False,374,0,0,9,90,1,11,L6
