,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.geometerplus.fbreader.Paths.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader;

import org.geometerplus.zlibrary.core.options.ZLStringOption;

import android.os.Environment;

public abstract class Paths {
	public static ZLStringOption BooksDirectoryOption() {
		return new ZLStringOption(""Files"", ""BooksDirectory"", Environment.getExternalStorageDirectory() + ""/Books"");
	}

	public static ZLStringOption FontsDirectoryOption() {
		return new ZLStringOption(""Files"", ""FontsDirectory"", Environment.getExternalStorageDirectory() + ""/Fonts"");
	}

	public static ZLStringOption WallpapersDirectoryOption() {
		return new ZLStringOption(""Files"", ""WallpapersDirectory"", Environment.getExternalStorageDirectory() + ""/Wallpapers"");
	}

	public static String cacheDirectory() {
		return BooksDirectoryOption().getValue() + ""/.FBReader"";
	}

	public static String networkCacheDirectory() {
		return cacheDirectory() + ""/cache"";
	}
}
",False,198,7,82,3,1,12,1,L4
1,org.geometerplus.fbreader.formats.FormatPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public abstract class FormatPlugin {
	public abstract boolean acceptsFile(ZLFile file);
	public abstract	boolean readMetaInfo(Book book);
	public abstract boolean readModel(BookModel model);
	public abstract ZLImage readCover(ZLFile file);
	public abstract String readAnnotation(ZLFile file);

	/*
	public static void detectEncodingAndLanguage(Book book, InputStream stream) throws IOException {	
		String language = book.getLanguage();
		String encoding = book.getEncoding();
		if (encoding.length() == 0 || language.length() == 0) {
			PluginCollection collection = PluginCollection.Instance();
			if (language.length() == 0) {
				language = collection.DefaultLanguageOption.getValue();
			}
			if (encoding.length() == 0) {
				encoding = collection.DefaultEncodingOption.getValue();
			}
			if (collection.LanguageAutoDetectOption.getValue() && stream != null) {
				int BUFSIZE = 65536;
				byte[] buffer = new byte[BUFSIZE];
				int size = stream.read(buffer, 0, BUFSIZE);
				stream.close();
				ZLLanguageDetector.LanguageInfo info =
					new ZLLanguageDetector().findInfo(buffer, 0, size);
				buffer = null;
				if (info != null) {
					language = info.Language;
					encoding = info.Encoding;
					if ((encoding == ""US-ASCII"") || (encoding == ""ISO-8859-1"")) {
						encoding = ""windows-1252"";
					}
				}
			}
			book.setEncoding(encoding);
			book.setLanguage(language);
		}
	}
	//Last working version
	public static void detectEncodingAndLanguage(Book book, InputStream stream) {	
		String encoding = book.getEncoding();
		if (encoding.length() == 0) {
			encoding = EncodingDetector.detect(stream, PluginCollection.Instance().DefaultLanguageOption.getValue());
			if (encoding == ""unknown"") {
				encoding = ""windows-1252"";
			}
			book.setEncoding(encoding);
		}

		if (book.getLanguage() == """") {
			if ((encoding.equals(""US-ASCII"")) ||
					(encoding.equals(""ISO-8859-1""))) {
				book.setLanguage(""en"");
			} else if ((book.getEncoding().equals(""KOI8-R"")) ||
					(encoding.equals(""windows-1251"")) ||
					(encoding.equals(""ISO-8859-5"")) ||
					(encoding.equals(""IBM866""))) {
				book.setLanguage(""ru"");
			} /*else if (
	                (PluginCollection.Instance().DefaultLanguageOption.getValue() == EncodingDetector.Language.CZECH) &&
					((encoding == ""windows-1250"") ||
					 (encoding == ""ISO-8859-2"") ||
					 (encoding == ""IBM852""))) {
				book.setLanguage(""cs"");
			}*/
		/*}

	}*/
}
",False,223,7,46,7,39,8,4,L4
2,org.geometerplus.fbreader.formats.PluginCollection.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats;

import java.util.*;

import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.formats.fb2.FB2Plugin;
import org.geometerplus.fbreader.formats.oeb.OEBPlugin;
import org.geometerplus.fbreader.formats.pdb.MobipocketPlugin;

public class PluginCollection {
	private static PluginCollection ourInstance;

	private final ArrayList<FormatPlugin> myPlugins = new ArrayList<FormatPlugin>();
	public ZLStringOption DefaultLanguageOption;
	public ZLStringOption DefaultEncodingOption;
	public ZLBooleanOption LanguageAutoDetectOption;
	
	public static PluginCollection Instance() {
		if (ourInstance == null) {
			ourInstance = new PluginCollection();
			ourInstance.myPlugins.add(new FB2Plugin());
			//ourInstance.myPlugins.add(new PluckerPlugin());
			//ourInstance->myPlugins.push_back(new DocBookPlugin());
			//ourInstance.myPlugins.add(new HtmlPlugin());
			//ourInstance.myPlugins.add(new TxtPlugin());
			//ourInstance.myPlugins.add(new PalmDocPlugin());
			ourInstance.myPlugins.add(new MobipocketPlugin());
			//ourInstance.myPlugins.add(new ZTXTPlugin());
			//ourInstance.myPlugins.add(new TcrPlugin());
			//ourInstance.myPlugins.add(new CHMPlugin());
			ourInstance.myPlugins.add(new OEBPlugin());
			//ourInstance.myPlugins.add(new RtfPlugin());
			//ourInstance.myPlugins.add(new OpenReaderPlugin());
		}
		return ourInstance;
	}
	
	public static void deleteInstance() {
		if (ourInstance != null) {
			ourInstance = null;
		}
	}

	private PluginCollection() {
		LanguageAutoDetectOption = new ZLBooleanOption(""Format"", ""AutoDetect"", true);
		DefaultLanguageOption = new ZLStringOption(""Format"", ""DefaultLanguage"", ""en""); 
		DefaultEncodingOption = new ZLStringOption(""Format"", ""DefaultEncoding"", ""windows-1252"");
	}
		
	public FormatPlugin getPlugin(ZLFile file) {
		for (FormatPlugin plugin : myPlugins) {
			if (plugin.acceptsFile(file)) {
				return plugin;
			}
		}
		return null;
	}
}
",False,222,7,46,7,47,4,7,L4
3,org.geometerplus.fbreader.formats.html.HtmlMetaInfoReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;

public class HtmlMetaInfoReader extends ZLXMLReaderAdapter {
	private final Book myBook;

	private boolean myReadTitle;

	public HtmlMetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle("""");
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}

	public boolean readMetaInfo() {
		myReadTitle = false;
		return readDocument(myBook.File);
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (HtmlTag.getTagByName(tagName)) {
			case HtmlTag.TITLE:
				myReadTitle = true;
				break;
			default:
				break;
		}
		return false;
	}

	public boolean endElementHandler(String tag) {
		switch (HtmlTag.getTagByName(tag)) {
			case HtmlTag.TITLE:
				myReadTitle = false;
				break;
			default:
				break;
		}
		return false;
	}

	public void characterDataHandler(char[] ch, int start, int length) {
		// TODO + length -- remove
		final String text = new String(ch).substring(start, start + length);
		if (myReadTitle) {
			myBook.setTitle(myBook.getTitle() + text);
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file);
	}

}
",False,143,1,1,6,39,1,6,L7
4,org.geometerplus.fbreader.formats.html.HtmlPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.io.IOException;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class HtmlPlugin extends FormatPlugin {
	
	@Override
	public boolean acceptsFile(ZLFile file) {
		return ""htm"".equals(file.getExtension()) 
			|| ""html"".equals(file.getExtension());
	}

	@Override
	public boolean readMetaInfo(Book book) {
		return new HtmlMetaInfoReader(book).readMetaInfo();
	}

	@Override
	public boolean readModel(BookModel model) {
		try {
			return new HtmlReader(model).readBook();
		} catch (IOException e) {
			return false;
		}
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		return null;
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return null;
	}
}
",False,143,0,0,6,37,0,7,L7
5,org.geometerplus.fbreader.formats.html.HtmlTag.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.util.*;

public final class HtmlTag {
	public static final byte UNKNOWN = 0;
	public static final byte HTML = 1;
	public static final byte HEAD = 2;
	public static final byte BODY = 3;
	public static final byte TITLE = 4;
	public static final byte P = 5;
	public static final byte H1 = 6;
	public static final byte H2 = 7;
	public static final byte H3 = 8;
	public static final byte H4 = 9;
	public static final byte H5 = 10;
	public static final byte H6 = 11;
	public static final byte A = 12;
	public static final byte B = 13;
	public static final byte I = 14;
	public static final byte BR = 15;
	public static final byte STRONG = 16;
	public static final byte IMG = 17;
	public static final byte SCRIPT = 18;
	public static final byte OL = 19;
	public static final byte UL = 20;
	public static final byte LI = 21;
	public static final byte SELECT = 22;
	public static final byte DIV = 23;
	public static final byte TR = 24;
	public static final byte STYLE = 25;
	
	public static final byte S = 26;
	public static final byte SUB = 27;
	public static final byte SUP = 28;
	public static final byte PRE = 29;
	public static final byte CODE = 30;
	public static final byte EM = 31;
	public static final byte DFN = 32;
	public static final byte CITE = 33;

	public static final byte HR = 34;
	
	// mobipocket specific tags
	public static final byte REFERENCE = 35;
	public static final byte GUIDE = 36;

	public static final byte TAG_NUMBER = 37;
	
	private static final HashMap<String,Byte> ourTagByName = new HashMap<String,Byte>(256, 0.2f);
	private static final Byte ourUnknownTag;

	static {
		ourTagByName.put(""unknown"", UNKNOWN);
		ourUnknownTag = (Byte)ourTagByName.get(""unknown"");
		ourTagByName.put(""html"", HTML);
		ourTagByName.put(""head"", HEAD);
		ourTagByName.put(""body"", BODY);
		ourTagByName.put(""title"", TITLE);
		ourTagByName.put(""p"", P);
		ourTagByName.put(""h1"", H1);
		ourTagByName.put(""h2"", H2);
		ourTagByName.put(""h3"", H3);
		ourTagByName.put(""h4"", H4);
		ourTagByName.put(""h5"", H5);
		ourTagByName.put(""h6"", H6);
		ourTagByName.put(""a"", A);
		ourTagByName.put(""b"", B);
		ourTagByName.put(""i"", I);
		ourTagByName.put(""br"", BR);
		ourTagByName.put(""strong"", STRONG);
		ourTagByName.put(""img"", IMG);
		ourTagByName.put(""script"", SCRIPT);
		ourTagByName.put(""ol"", OL);
		ourTagByName.put(""ul"", UL);
		ourTagByName.put(""li"", LI);
		ourTagByName.put(""select"", SELECT);
		ourTagByName.put(""tr"", TR);
		ourTagByName.put(""style"", STYLE);
		ourTagByName.put(""s"", S);
		ourTagByName.put(""sub"", SUB);
		ourTagByName.put(""sup"", SUP);
		ourTagByName.put(""pre"", PRE);
		ourTagByName.put(""code"", CODE);
		ourTagByName.put(""em"", EM);
		ourTagByName.put(""def"", DFN);
		ourTagByName.put(""cite"", CITE);
		ourTagByName.put(""hr"", HR);
		ourTagByName.put(""guide"", GUIDE);
		ourTagByName.put(""reference"", REFERENCE);
	}

	public static byte getTagByName(String name) {
		final HashMap<String,Byte> tagByName = ourTagByName;
		Byte num = tagByName.get(name);
		if (num == null) {
			final String lowerCaseName = name.toLowerCase().intern();
			num = (Byte)tagByName.get(lowerCaseName);
			if (num == null) {
				num = ourUnknownTag;
				tagByName.put(lowerCaseName, num);
			}
			tagByName.put(name, num);
		}
		return num.byteValue();
	}
}
",False,119,9,50,0,0,3,0,L4
6,org.geometerplus.fbreader.formats.html.HtmlReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.util.HashMap;
import java.io.*;
import java.nio.charset.*;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.bookmodel.BookReader;
import org.geometerplus.fbreader.bookmodel.FBTextKind;
import org.geometerplus.zlibrary.core.html.*;
import org.geometerplus.zlibrary.core.util.ZLArrayUtils;
import org.geometerplus.zlibrary.text.model.ZLTextParagraph;

import org.geometerplus.zlibrary.core.xml.ZLXMLProcessor;
import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;

public class HtmlReader extends BookReader implements ZLHtmlReader {
	private final byte[] myStyleTable = new byte[HtmlTag.TAG_NUMBER];
	{
		myStyleTable[HtmlTag.H1] = FBTextKind.H1;
		myStyleTable[HtmlTag.H2] = FBTextKind.H2;
		myStyleTable[HtmlTag.H3] = FBTextKind.H3;
		myStyleTable[HtmlTag.H4] = FBTextKind.H4;
		myStyleTable[HtmlTag.H5] = FBTextKind.H5;
		myStyleTable[HtmlTag.H6] = FBTextKind.H6;
		myStyleTable[HtmlTag.B] = FBTextKind.BOLD;
		myStyleTable[HtmlTag.SUB] = FBTextKind.SUB;
		myStyleTable[HtmlTag.SUP] = FBTextKind.SUP;
		myStyleTable[HtmlTag.S] = FBTextKind.STRIKETHROUGH;
		myStyleTable[HtmlTag.PRE] = FBTextKind.PREFORMATTED;
		myStyleTable[HtmlTag.EM] = FBTextKind.EMPHASIS;
		myStyleTable[HtmlTag.DFN] = FBTextKind.DEFINITION;
		myStyleTable[HtmlTag.CITE] = FBTextKind.CITE;
		myStyleTable[HtmlTag.CODE] = FBTextKind.CODE;
		myStyleTable[HtmlTag.STRONG] = FBTextKind.STRONG;
		myStyleTable[HtmlTag.I] = FBTextKind.ITALIC;
	}

	protected final CharsetDecoder myAttributeDecoder;

	private boolean myInsideTitle = false;
	private boolean mySectionStarted = false;
	private byte myHyperlinkType;
	private final char[] SPACE = { ' ' };
	private String myHrefAttribute = ""href"";
	private boolean myOrderedListIsStarted = false;
	//private boolean myUnorderedListIsStarted = false;
	private int myOLCounter = 0;
	private byte[] myControls = new byte[10];
	private byte myControlsNumber = 0;
	
	public HtmlReader(BookModel model) throws UnsupportedEncodingException {
		super(model);
		try {	
			//String encoding = model.Book.getEncoding();
			myAttributeDecoder = createDecoder();
			setByteDecoder(createDecoder());
		} catch (UnsupportedCharsetException e) {
			throw new UnsupportedEncodingException(e.getMessage());
		}
	}

	protected final CharsetDecoder createDecoder() throws UnsupportedEncodingException {
		return Charset.forName(Model.Book.getEncoding()).newDecoder()
			.onMalformedInput(CodingErrorAction.REPLACE)
			.onUnmappableCharacter(CodingErrorAction.REPLACE);
	}

	public boolean readBook() throws IOException {
		return ZLHtmlProcessor.read(this, getInputStream());
	}

	public InputStream getInputStream() throws IOException {
		return Model.Book.File.getInputStream();
	}

	public void startDocumentHandler() {
	}

	public void endDocumentHandler() {
		unsetCurrentTextModel();
	}

	public void byteDataHandler(byte[] data, int start, int length) {
		addByteData(data, start, length);
	}

	private HashMap<String,char[]> myEntityMap;
	public void entityDataHandler(String entity) {
		if (myEntityMap == null) {
			myEntityMap = new HashMap<String,char[]>(ZLXMLProcessor.getEntityMap(XHTMLReader.xhtmlDTDs()));
		}
		char[] data = myEntityMap.get(entity);
		if (data == null) {
			if ((entity.length() > 0) && (entity.charAt(0) == '#')) {
				try {
					int number;
					if (entity.charAt(1) == 'x') {
						number = Integer.parseInt(entity.substring(2), 16);
					} else {
						number = Integer.parseInt(entity.substring(1));
					}
					data = new char[] { (char)number };
				} catch (NumberFormatException e) {
				}
			}
			if (data == null) {
				data = new char[0];
			}
			myEntityMap.put(entity, data);
		}
		addData(data);
	}

	private void openControl(byte control) {
		addControl(control, true);
		if (myControlsNumber == myControls.length) {
			myControls = ZLArrayUtils.createCopy(myControls, myControlsNumber, 2 * myControlsNumber);
		}
		myControls[myControlsNumber++] = control;
	}
	
	private void closeControl(byte control) {
		for (int i = 0; i < myControlsNumber; i++) {
			addControl(myControls[i], false);
		}
		boolean flag = false;
		int removedControl = myControlsNumber;
		for (int i = 0; i < myControlsNumber; i++) {
			if (!flag && (myControls[i] == control)) {
				flag = true;
				removedControl = i;
				continue;
			}
			addControl(myControls[i], true);
		}
		if (removedControl == myControlsNumber) {
			return;
		}
		--myControlsNumber;
		for (int i = removedControl; i < myControlsNumber; i++) {
			myControls[i] = myControls[i + 1];
		}
	}
	
	private void startNewParagraph() {
		endParagraph();
		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
	}
	
	public final void endElementHandler(String tagName) {
		endElementHandler(HtmlTag.getTagByName(tagName));
	}

	public void endElementHandler(byte tag) {
		switch (tag) {
			case HtmlTag.SCRIPT:
			case HtmlTag.SELECT:
			case HtmlTag.STYLE:
			case HtmlTag.P:
				startNewParagraph();
				break;

			case HtmlTag.H1:
			case HtmlTag.H2:
			case HtmlTag.H3:
			case HtmlTag.H4:
			case HtmlTag.H5:
			case HtmlTag.H6:
			case HtmlTag.PRE:
				closeControl(myStyleTable[tag]);
				startNewParagraph();
				break;

			case HtmlTag.A:
				closeControl(myHyperlinkType);
				break;

			case HtmlTag.BODY:
				break;

			case HtmlTag.HTML:
				//unsetCurrentTextModel();
				break;
				
			case HtmlTag.B:
			case HtmlTag.S:
			case HtmlTag.SUB:
			case HtmlTag.SUP:
			case HtmlTag.EM:
			case HtmlTag.DFN:
			case HtmlTag.CITE:
			case HtmlTag.CODE:
			case HtmlTag.STRONG:
			case HtmlTag.I:
				closeControl(myStyleTable[tag]);
				break;

			case HtmlTag.OL:
				myOrderedListIsStarted = false;
				myOLCounter = 0;
				break;
				
			case HtmlTag.UL:
				//myUnorderedListIsStarted = false;
				break;
				
			default:
				break;
		}
	}

	public final void startElementHandler(String tagName, int offset, ZLHtmlAttributeMap attributes) {
		startElementHandler(HtmlTag.getTagByName(tagName), offset, attributes);
	}

	public void startElementHandler(byte tag, int offset, ZLHtmlAttributeMap attributes) {
		switch (tag) {
			case HtmlTag.HTML:
				break;

			case HtmlTag.BODY:
				setMainTextModel();
				pushKind(FBTextKind.REGULAR);
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;

			case HtmlTag.P:
				if (mySectionStarted) {
					mySectionStarted = false;
				} else if (myInsideTitle) {
					addContentsData(SPACE);
				}
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;

			case HtmlTag.A:{
				String ref = attributes.getStringValue(myHrefAttribute, myAttributeDecoder);
				if ((ref != null) && (ref.length() != 0)) {
					if (ref.charAt(0) == '#') {
						myHyperlinkType = FBTextKind.FOOTNOTE;
						ref = ref.substring(1);
					} else if (ref.charAt(0) == '&') {
						myHyperlinkType = FBTextKind.INTERNAL_HYPERLINK;
						ref = ref.substring(1);
					} else {
						myHyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
					}
					addHyperlinkControl(myHyperlinkType, ref);
					myControls[myControlsNumber] = myHyperlinkType;
					myControlsNumber++;
				}
				break;
			}
			
			case HtmlTag.IMG: {
				/*
				String ref = attributes.getStringValue(mySrcAttribute, myAttributeDecoder);
				if ((ref != null) && (ref.length() != 0)) {
					addImageReference(ref, (short)0);
					String filePath = ref;
					if (!"":\\"".equals(ref.substring(1, 3))) {
						filePath = Model.Book.File.getPath();
						filePath = filePath.substring(0, filePath.lastIndexOf('\\') + 1) + ref;
					}
					addImage(ref, new ZLFileImage(MimeTypes.MIME_IMAGE_AUTO, ZLFile.createFileByPath(filePath)));
				}
				*/
				break;
			}
			
			case HtmlTag.B:
			case HtmlTag.S:
			case HtmlTag.SUB:
			case HtmlTag.SUP:
			case HtmlTag.PRE:
			case HtmlTag.STRONG:
			case HtmlTag.CODE:
			case HtmlTag.EM:
			case HtmlTag.CITE:
			case HtmlTag.DFN:
			case HtmlTag.I:
				openControl(myStyleTable[tag]);
				break;
				
			case HtmlTag.H1:
			case HtmlTag.H2:
			case HtmlTag.H3:
			case HtmlTag.H4:
			case HtmlTag.H5:
			case HtmlTag.H6:
				startNewParagraph();
				openControl(myStyleTable[tag]);
				break;
				
			case HtmlTag.OL:
				myOrderedListIsStarted = true;
				break;
				
			case HtmlTag.UL:
				//myUnorderedListIsStarted = true;
				break;
				
			case HtmlTag.LI:
				startNewParagraph();
				if (myOrderedListIsStarted) {
					char[] number = (new Integer(++myOLCounter)).toString().toCharArray();
					addData(number);
					addData(new char[] {'.', ' '});
				} else {
					addData(new char[] {'*', ' '});
				}
				break;
				
			case HtmlTag.SCRIPT:
			case HtmlTag.SELECT:
			case HtmlTag.STYLE:
				endParagraph();
				break;
				
			case HtmlTag.TR: 
			case HtmlTag.BR:
				startNewParagraph();
				break;
			default:
				break;
		}
	}
}
",True,142,1,1,6,45,3,13,L4
7,org.geometerplus.fbreader.formats.util.MiscUtil.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.util;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class MiscUtil {
	public static String htmlDirectoryPrefix(ZLFile file) {
		String shortName = file.getShortName();
		String path = file.getPath();
		return path.substring(0, path.length() - shortName.length());
	}

	public static String archiveEntryName(String fullPath) {
		final int index = fullPath.lastIndexOf(':');
		return (index >= 2) ? fullPath.substring(index + 1) : fullPath;
	}

	private static boolean isHexDigit(char ch) {
		return
			(ch >= '0' && ch <= '9') ||
			(ch >= 'a' && ch <= 'f') ||
			(ch >= 'A' && ch <= 'F');
	}

	public static String decodeHtmlReference(String name) {
		if (name == null) {
			return null;
		}

		int index = 0;
		while (true) {
			index = name.indexOf('%', index);
			if (index == -1 || index >= name.length() - 2) {
				break;
			}
			if (isHexDigit(name.charAt(index + 1)) &&
				isHexDigit(name.charAt(index + 2))) {
				char c = 0;
				try {
					c = (char)Integer.decode(""0x"" + name.substring(index + 1, index + 3)).intValue();
				} catch (NumberFormatException e) {
				}
				name = name.substring(0, index) + c + name.substring(index + 3);
			}
			index = index + 1;
		}
		return name;
	}
}
",True,138,9,40,5,6,5,1,L4
8,org.geometerplus.fbreader.formats.oeb.OEBCoverBackgroundReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.formats.util.MiscUtil;

class OEBCoverBackgroundReader extends ZLXMLReaderAdapter implements XMLNamespaces {
	private class XHTMLImageFinder extends ZLXMLReaderAdapter {
		@Override
		public boolean processNamespaces() {
			return true;
		}

		@Override
		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			tag = tag.toLowerCase();
			String href = null;
			if (""img"".equals(tag)) {
				href = attributes.getValue(""src"");
			} else if (""image"".equals(tag)) {
				href = getAttributeValue(attributes, XLink, ""href"");
			}

			if (href != null) {
				myImage = new ZLFileImage(
					MimeType.IMAGE_AUTO,
					ZLFile.createFileByPath(myXHTMLPathPrefix + MiscUtil.decodeHtmlReference(href))
				);
				return true;
			}

			return false;
		}
	}

	private ZLFileImage myImage;
	private String myPathPrefix;
	private String myXHTMLPathPrefix;
	private String myCoverXHTML;
	private boolean myReadGuide;

	public ZLFileImage readCover(ZLFile file) {
		myPathPrefix = MiscUtil.htmlDirectoryPrefix(file);
		myReadGuide = false;
		myImage = null;
		myCoverXHTML = null;
		read(file);
		if (myCoverXHTML != null) {
			final ZLFile coverFile = ZLFile.createFileByPath(myCoverXHTML);
			if (coverFile != null) {
				final String ext = coverFile.getExtension();
				if (""gif"".equals(ext) || ""jpg"".equals(ext) || ""jpeg"".equals(ext)) {
					myImage = new ZLFileImage(MimeType.IMAGE_AUTO, coverFile);
				} else {
					myXHTMLPathPrefix = MiscUtil.htmlDirectoryPrefix(coverFile);
					new XHTMLImageFinder().read(coverFile);
				}
			}
		}
		return myImage;
	}

	private static final String GUIDE = ""guide"";
	private static final String REFERENCE = ""reference"";
	private static final String COVER = ""cover"";
	private static final String COVER_IMAGE = ""other.ms-coverimage-standard"";

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (GUIDE == tag) {
			myReadGuide = true;
		} else if (myReadGuide && REFERENCE == tag) {
			final String type = attributes.getValue(""type"");
			if (COVER == type) {
				final String href = attributes.getValue(""href"");
				if (href != null) {
					myCoverXHTML = myPathPrefix + MiscUtil.decodeHtmlReference(href);
					return true;
				}
			} else if (COVER_IMAGE == type) {
				final String href = attributes.getValue(""href"");
				if (href != null) {
					myImage = new ZLFileImage(
						MimeType.IMAGE_AUTO,
						ZLFile.createFileByPath(myPathPrefix + MiscUtil.decodeHtmlReference(href))
					);
					return true;
				}
			}
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if (GUIDE == tag) {
			myReadGuide = false;
			return true;
		}
		return false;
	}
}
",True,155,9,50,5,11,1,7,L4
9,org.geometerplus.fbreader.formats.oeb.OEBPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class OEBPlugin extends FormatPlugin {
	public boolean acceptsFile(ZLFile file) {
		final String extension = file.getExtension();
		return
			""oebzip"".equals(extension) ||
			""epub"".equals(extension) ||
			""opf"".equals(extension);
	}

	private ZLFile getOpfFile(ZLFile oebFile) {
		if (""opf"".equals(oebFile.getExtension())) {
			return oebFile;
		}

		final ZLFile containerInfoFile = ZLFile.createFile(oebFile, ""META-INF/container.xml"");
		if (containerInfoFile.exists()) {
			final ContainerFileReader reader = new ContainerFileReader();
			reader.read(containerInfoFile);
			final String opfPath = reader.getRootPath();
			if (opfPath != null) {
				return ZLFile.createFile(oebFile, opfPath);
			}
		}

		for (ZLFile child : oebFile.children()) {
			if (child.getExtension().equals(""opf"")) {
				return child;
			}
		}
		return null;
	}

	@Override
	public boolean readMetaInfo(Book book) {
		final ZLFile opfFile = getOpfFile(book.File);
		return (opfFile != null) ? new OEBMetaInfoReader(book).readMetaInfo(opfFile) : false;
	}
	
	@Override
	public boolean readModel(BookModel model) {
		model.Book.File.setCached(true);
		final ZLFile opfFile = getOpfFile(model.Book.File);
		return (opfFile != null) ? new OEBBookReader(model).readBook(opfFile) : false;
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		final ZLFile opfFile = getOpfFile(file);
		return (opfFile != null) ? new OEBCoverReader().readCover(opfFile) : null;
	}

	@Override
	public String readAnnotation(ZLFile file) {
		final ZLFile opfFile = getOpfFile(file);
		return (opfFile != null) ? new OEBAnnotationReader().readAnnotation(opfFile) : null;
	}
}
",False,141,0,0,6,35,1,11,L4
10,org.geometerplus.fbreader.formats.oeb.ContainerFileReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.zlibrary.core.xml.*;

class ContainerFileReader extends ZLXMLReaderAdapter {
	private String myRootPath;

	public String getRootPath() {
		return myRootPath;
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap xmlattributes) {
		if (""rootfile"".equalsIgnoreCase(tag)) {
			myRootPath = xmlattributes.getValue(""full-path"");
			if (myRootPath != null) {
				return true;
			}
		}
		return false;
	}
}
",False,144,8,50,6,6,1,2,L4
11,org.geometerplus.fbreader.formats.oeb.OEBCoverReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.image.ZLImageProxy;

class OEBCoverReader {
	private static class OEBCoverImage extends ZLImageProxy {
		private final ZLFile myFile;

		OEBCoverImage(ZLFile file) {
			myFile = file;
		}

		@Override
		public ZLSingleImage getRealImage() {
			return new OEBCoverBackgroundReader().readCover(myFile);
		}

		@Override
		public int sourceType() {
			return SourceType.DISK;
		}

		@Override
		public String getId() {
			return myFile.getPath();
		}
	}

	public ZLImageProxy readCover(ZLFile file) {
		return new OEBCoverImage(file);
	}
}
",False,159,8,50,5,12,1,4,L4
12,org.geometerplus.fbreader.formats.oeb.OEBBookReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;
import org.geometerplus.fbreader.formats.util.MiscUtil;

class Reference {
	public final String Title;
	public final String HRef;

	public Reference(String title, String href) {
		Title = title;
		HRef = href;
	}
}

class OEBBookReader extends ZLXMLReaderAdapter implements XMLNamespaces {
	private static final char[] Dots = new char[] {'.', '.', '.'};

	private final BookReader myModelReader;
	private final HashMap<String,String> myIdToHref = new HashMap<String,String>();
	private final ArrayList<String> myHtmlFileNames = new ArrayList<String>();
	private final ArrayList<Reference> myTourTOC = new ArrayList<Reference>();
	private final ArrayList<Reference> myGuideTOC = new ArrayList<Reference>();

	private String myOPFSchemePrefix;
	private String myFilePrefix;
	private String myNCXTOCFileName;

	OEBBookReader(BookModel model) {
		myModelReader = new BookReader(model);
	}

	private TreeMap<String,Integer> myFileNumbers = new TreeMap<String,Integer>();
	private TreeMap<String,Integer> myTOCLabels = new TreeMap<String,Integer>();

	boolean readBook(ZLFile file) {
		myFilePrefix = MiscUtil.htmlDirectoryPrefix(file);

		myIdToHref.clear();
		myHtmlFileNames.clear();
		myNCXTOCFileName = null;
		myTourTOC.clear();
		myGuideTOC.clear();
		myState = READ_NONE;

		if (!read(file)) {
			return false;
		}

		myModelReader.setMainTextModel();
		myModelReader.pushKind(FBTextKind.REGULAR);

		for (String name : myHtmlFileNames) {
			final ZLFile xhtmlFile = ZLFile.createFileByPath(myFilePrefix + name);
			final XHTMLReader reader = new XHTMLReader(myModelReader, myFileNumbers);
			final String referenceName = reader.getFileAlias(MiscUtil.archiveEntryName(xhtmlFile.getPath()));

			myModelReader.addHyperlinkLabel(referenceName);
			myTOCLabels.put(referenceName, myModelReader.Model.BookTextModel.getParagraphsNumber());
			reader.readFile(xhtmlFile, referenceName + '#');
			myModelReader.insertEndOfSectionParagraph();
		}

		generateTOC();

		return true;
	}

	private BookModel.Label getTOCLabel(String id) {
		final int index = id.indexOf('#');
		final String path = (index >= 0) ? id.substring(0, index) : id;
		Integer num = myFileNumbers.get(path);
		if (num == null) {
			return null;
		}
		if (index == -1) {
			final Integer para = myTOCLabels.get(num.toString());
			if (para == null) {
				return null;
			}
			return new BookModel.Label(null, para);
		}
		return myModelReader.Model.getLabel(num + id.substring(index));
	}

	private void generateTOC() {
		if (myNCXTOCFileName != null) {
			final NCXReader ncxReader = new NCXReader(myModelReader);
			if (ncxReader.readFile(myFilePrefix + myNCXTOCFileName)) {
				final Map<Integer,NCXReader.NavPoint> navigationMap = ncxReader.navigationMap();
				if (!navigationMap.isEmpty()) {
					int level = 0;
					for (NCXReader.NavPoint point : navigationMap.values()) {
						final BookModel.Label label = getTOCLabel(point.ContentHRef);
						int index = (label != null) ? label.ParagraphIndex : -1;
						while (level > point.Level) {
							myModelReader.endContentsParagraph();
							--level;
						}
						while (++level <= point.Level) {
							myModelReader.beginContentsParagraph(-2);
							myModelReader.addContentsData(Dots);
						}
						myModelReader.beginContentsParagraph(index);
						myModelReader.addContentsData(point.Text.toCharArray());
					}
					while (level > 0) {
						myModelReader.endContentsParagraph();
						--level;
					}
					return;
				}
			}
		}

		for (Reference ref : myTourTOC.isEmpty() ? myGuideTOC : myTourTOC) {
			final BookModel.Label label = getTOCLabel(ref.HRef);
			if (label != null) {
				final int index = label.ParagraphIndex;
				if (index != -1) {
					myModelReader.beginContentsParagraph(index);
					myModelReader.addContentsData(ref.Title.toCharArray());
					myModelReader.endContentsParagraph();
				}
			}
		}
	}

	private static final String MANIFEST = ""manifest"";
	private static final String SPINE = ""spine"";
	private static final String GUIDE = ""guide"";
	private static final String TOUR = ""tour"";
	private static final String SITE = ""site"";
	private static final String REFERENCE = ""reference"";
	private static final String ITEMREF = ""itemref"";
	private static final String ITEM = ""item"";

	private static final String COVER_IMAGE = ""other.ms-coverimage-standard"";

	private static final int READ_NONE = 0;
	private static final int READ_MANIFEST = 1;
	private static final int READ_SPINE = 2;
	private static final int READ_GUIDE = 3;
	private static final int READ_TOUR = 4;
	
	private int myState;

	@Override
	public boolean startElementHandler(String tag, ZLStringMap xmlattributes) {
		tag = tag.toLowerCase();
		if (myOPFSchemePrefix != null && tag.startsWith(myOPFSchemePrefix)) {
			tag = tag.substring(myOPFSchemePrefix.length());
		}
		tag = tag.intern();
		if (MANIFEST == tag) {
			myState = READ_MANIFEST;
		} else if (SPINE == tag) {
			myNCXTOCFileName = myIdToHref.get(xmlattributes.getValue(""toc""));
			myState = READ_SPINE;
		} else if (GUIDE == tag) {
			myState = READ_GUIDE;
		} else if (TOUR == tag) {
			myState = READ_TOUR;
		} else if (myState == READ_MANIFEST && ITEM == tag) {
			final String id = xmlattributes.getValue(""id"");
			String href = xmlattributes.getValue(""href"");
			if ((id != null) && (href != null)) {
				href = MiscUtil.decodeHtmlReference(href);
				myIdToHref.put(id, href);
			}
		} else if (myState == READ_SPINE && ITEMREF == tag) {
			final String id = xmlattributes.getValue(""idref"");
			if (id != null) {
				final String fileName = myIdToHref.get(id);
				if (fileName != null) {
					myHtmlFileNames.add(fileName);
				}
			}
		} else if (myState == READ_GUIDE && REFERENCE == tag) {
			final String type = xmlattributes.getValue(""type"");
			final String title = xmlattributes.getValue(""title"");
			String href = xmlattributes.getValue(""href"");
			if (href != null) {
				href = MiscUtil.decodeHtmlReference(href);
				if (title != null) {
					myGuideTOC.add(new Reference(title, href));
				}
				if (type != null && COVER_IMAGE.equals(type)) {
					myModelReader.setMainTextModel();
					final ZLFile imageFile = ZLFile.createFileByPath(myFilePrefix + href);
					final String imageName = imageFile.getLongName();
					myModelReader.addImageReference(imageName, (short)0);
					myModelReader.addImage(imageName, new ZLFileImage(MimeType.IMAGE_AUTO, imageFile));
				}
			}
		} else if (myState == READ_TOUR && SITE == tag) {
			final String title = xmlattributes.getValue(""title"");
			String href = xmlattributes.getValue(""href"");
			if ((title != null) && (href != null)) {
				href = MiscUtil.decodeHtmlReference(href);
				myTourTOC.add(new Reference(title, href));
			}
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if (myOPFSchemePrefix != null && tag.startsWith(myOPFSchemePrefix)) {
			tag = tag.substring(myOPFSchemePrefix.length());
		}
		tag = tag.intern();
		if (MANIFEST == tag || SPINE == tag || GUIDE == tag || TOUR == tag) {
			myState = READ_NONE;
		}
		return false;
	}

	@Override
	public boolean processNamespaces() {
		return true;
	}

	@Override
	public void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myOPFSchemePrefix = null;
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			if (OpenPackagingFormat.equals(entry.getValue())) {
				myOPFSchemePrefix = entry.getKey() + "":"";
				break;
			}
		}
	}

	@Override
	public boolean dontCacheAttributeValues() {
		return true;
	}
}
",True,141,0,0,7,36,1,13,L4
13,org.geometerplus.fbreader.formats.oeb.OEBAnnotationReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

class OEBAnnotationReader extends ZLXMLReaderAdapter implements XMLNamespaces {
	private String myDescriptionTag;
	
	private static final int READ_NONE = 0;
	private static final int READ_DESCRIPTION = 1;
	private int myReadState;

	private final StringBuilder myBuffer = new StringBuilder();

	String readAnnotation(ZLFile file) {
		myReadState = READ_NONE;
		myBuffer.delete(0, myBuffer.length());

		if (ZLXMLProcessor.read(this, file, 512)) {
			final int len = myBuffer.length();
			if (len > 1) {
				if (myBuffer.charAt(len - 1) == '\n') {
					myBuffer.delete(len - 1, len);
				}
				return myBuffer.toString();
			}
		}
		return null;
	}

	@Override
	public boolean processNamespaces() {
		return true;
	}

	@Override
	public void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myDescriptionTag = null;
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String id = entry.getValue();
			if (id.startsWith(DublinCorePrefix) || id.startsWith(DublinCoreLegacyPrefix)) {
				myDescriptionTag = entry.getKey() + "":description"";
			}
		}
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		if (tag.equalsIgnoreCase(myDescriptionTag)) {
			myReadState = READ_DESCRIPTION;
		} else if (myReadState == READ_DESCRIPTION) {
			// TODO: process tags
			myBuffer.append("" "");
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int len) {
		if (myReadState == READ_DESCRIPTION) {
			myBuffer.append(new String(data, start, len).trim());
		}
	}

	@Override
	public boolean endElementHandler(String tag) {
		if (myReadState != READ_DESCRIPTION) {
			return false;
		}
		tag = tag.toLowerCase();
		if (tag.equalsIgnoreCase(myDescriptionTag)) {
			return true;
		}
		// TODO: process tags
		myBuffer.append("" "");
		return false;
	}
}
",False,145,8,50,5,7,1,5,L4
14,org.geometerplus.fbreader.formats.oeb.NCXReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.filesystem.ZLArchiveEntryFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.util.MiscUtil;

class NCXReader extends ZLXMLReaderAdapter {
	static class NavPoint {
		final int Order;
		final int Level;
		String Text = """";
		String ContentHRef = """";

		NavPoint(int order, int level) {
			Order = order;
			Level = level;
		}
	}

	private final TreeMap<Integer,NavPoint> myNavigationMap = new TreeMap<Integer,NavPoint>();
	private final ArrayList<NavPoint> myPointStack = new ArrayList<NavPoint>();

	private static final int READ_NONE = 0;
	private static final int READ_MAP = 1;
	private static final int READ_POINT = 2;
	private static final int READ_LABEL = 3;
	private static final int READ_TEXT = 4;

	int myReadState = READ_NONE;
	int myPlayIndex = -65535;
	private String myLocalPathPrefix;

	NCXReader(BookReader modelReader) {
	}

	boolean readFile(String filePath) {
		final ZLFile file = ZLFile.createFileByPath(filePath);
		myLocalPathPrefix = MiscUtil.archiveEntryName(MiscUtil.htmlDirectoryPrefix(file));
		return read(file);
	}

	Map<Integer,NavPoint> navigationMap() {
		return myNavigationMap;
	}

	private static final String TAG_NAVMAP = ""navmap"";
	private static final String TAG_NAVPOINT = ""navpoint"";
	private static final String TAG_NAVLABEL = ""navlabel"";
	private static final String TAG_CONTENT = ""content"";
	private static final String TAG_TEXT = ""text"";

	private static final String ATTRIBUTE_PLAYORDER = ""playOrder"";

	private int atoi(String number) {
		try {
			return Integer.parseInt(number);
		} catch (NumberFormatException e) {
			return 0;
		}
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		switch (myReadState) {
			case READ_NONE:
				if (tag == TAG_NAVMAP) {
					myReadState = READ_MAP;
				}
				break;
			case READ_MAP:
				if (tag == TAG_NAVPOINT) {
					final String order = attributes.getValue(ATTRIBUTE_PLAYORDER);
					final int index = (order != null) ? atoi(order) : myPlayIndex++;
					myPointStack.add(new NavPoint(index, myPointStack.size()));
					myReadState = READ_POINT;
				}
				break;
			case READ_POINT:
				if (tag == TAG_NAVPOINT) {
					final String order = attributes.getValue(ATTRIBUTE_PLAYORDER);
					final int index = (order != null) ? atoi(order) : myPlayIndex++;
					myPointStack.add(new NavPoint(index, myPointStack.size()));
				} else if (tag == TAG_NAVLABEL) {
					myReadState = READ_LABEL;
				} else if (tag == TAG_CONTENT) {
					final int size = myPointStack.size();
					if (size > 0) {
						myPointStack.get(size - 1).ContentHRef =
							ZLArchiveEntryFile.normalizeEntryName(
								myLocalPathPrefix + MiscUtil.decodeHtmlReference(attributes.getValue(""src""))
							);
					}
				}
				break;
			case READ_LABEL:
				if (TAG_TEXT == tag) {
					myReadState = READ_TEXT;
				}
				break;
			case READ_TEXT:
				break;
		}
		return false;
	}
	
	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase().intern();
		switch (myReadState) {
			case READ_NONE:
				break;
			case READ_MAP:
				if (TAG_NAVMAP == tag) {
					myReadState = READ_NONE;
				}
				break;
			case READ_POINT:
				if (TAG_NAVPOINT == tag) {
					NavPoint last = myPointStack.get(myPointStack.size() - 1);
					if (last.Text.length() == 0) {
						last.Text = ""..."";
					}
					myNavigationMap.put(last.Order, last);
					myPointStack.remove(myPointStack.size() - 1);
					myReadState = (myPointStack.isEmpty()) ? READ_MAP : READ_POINT;
				}
			case READ_LABEL:
				if (TAG_NAVLABEL == tag) {
					myReadState = READ_POINT;
				}
				break;
			case READ_TEXT:
				if (TAG_TEXT == tag) {
					myReadState = READ_LABEL;
				}
				break;
		}
		return false;
	}
	
	@Override
	public void characterDataHandler(char[] ch, int start, int length) {
		if (myReadState == READ_TEXT) {
			final ArrayList<NavPoint> stack = myPointStack;
			final NavPoint last = stack.get(stack.size() - 1);
			last.Text += new String(ch, start, length);
		}
	}

	@Override
	public boolean dontCacheAttributeValues() {
		return true;
	}
}
",True,141,0,0,8,31,1,6,L4
15,org.geometerplus.fbreader.formats.oeb.OEBMetaInfoReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;

class OEBMetaInfoReader extends ZLXMLReaderAdapter implements XMLNamespaces {
	private final Book myBook;

	private String myDCMetadataTag = ""dc-metadata"";
	private String myMetadataTag = ""metadata"";
	private String myOpfMetadataTag = ""metadata"";
	private String myMetadataTagRealName;
	private String myTitleTag;
	private String myAuthorTag;
	private String mySubjectTag;
	private String myLanguageTag;
	private String myMetaTag = ""meta"";

	private String mySeriesTitle = """";
	private float mySeriesIndex = 0;
	
	private final ArrayList<String> myAuthorList = new ArrayList<String>();
	private final ArrayList<String> myAuthorList2 = new ArrayList<String>();

	OEBMetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle(null);
		myBook.setLanguage(null);
	}

	boolean readMetaInfo(ZLFile file) {
		myReadMetaData = false;
		myReadState = READ_NONE;

		if (!ZLXMLProcessor.read(this, file, 512)) {
			return false;
		}

		final ArrayList<String> authors = myAuthorList.isEmpty() ? myAuthorList2 : myAuthorList;
		for (String a : authors) {
			final int index = a.indexOf(',');
			if (index >= 0) {
				a = a.substring(index + 1).trim() + ' ' + a.substring(0, index).trim();
			} else {
				a = a.trim();
			}
			myBook.addAuthor(a);
		}

		return true;
	}

	private static final int READ_NONE = 0;
	private static final int READ_AUTHOR = 1;
	private static final int READ_AUTHOR2 = 2;
	private static final int READ_TITLE = 3;
	private static final int READ_SUBJECT = 4;
	private static final int READ_LANGUAGE = 5;
	private int myReadState;
	private boolean myReadMetaData;

	private final StringBuilder myBuffer = new StringBuilder();

	@Override
	public boolean processNamespaces() {
		return true;
	}

	@Override
	public void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myTitleTag = null;
		myAuthorTag = null;
		mySubjectTag = null;
		myLanguageTag = null;
		myOpfMetadataTag = ""metadata"";
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String id = entry.getValue();
			if (id.startsWith(DublinCorePrefix) || id.startsWith(DublinCoreLegacyPrefix)) {
				final String name = entry.getKey();
				myTitleTag = (name + "":title"").intern();
				myAuthorTag = (name + "":creator"").intern();
				mySubjectTag = (name + "":subject"").intern();
				myLanguageTag = (name + "":language"").intern();
			} else if (id.equals(OpenPackagingFormat)) {
				final String name = entry.getKey();
				myOpfMetadataTag = (name + "":metadata"").intern();
			}
		}
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (tag == myMetadataTag || tag == myDCMetadataTag || tag == myOpfMetadataTag) {
			myMetadataTagRealName = tag;
			myReadMetaData = true;
		} else if (myReadMetaData) {
			if (tag == myTitleTag) {
				myReadState = READ_TITLE;
			} else if (tag == myAuthorTag) {
				final String role = attributes.getValue(""role"");
				if (role == null) {
					myReadState = READ_AUTHOR2;
				} else if (role.equals(""aut"")) {
					myReadState = READ_AUTHOR;
				}
			} else if (tag == mySubjectTag) {
				myReadState = READ_SUBJECT;
			} else if (tag == myLanguageTag) {
				myReadState = READ_LANGUAGE;
			} else if (tag == myMetaTag) {
				if (attributes.getValue(""name"").equals(""calibre:series"")) {
					mySeriesTitle = attributes.getValue(""content"");
				} else if (attributes.getValue(""name"").equals(""calibre:series_index"")) {
					final String strIndex = attributes.getValue(""content"");
					try {
						mySeriesIndex = Float.parseFloat(strIndex);
					} catch (NumberFormatException e) {
					}
				}
			}
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int len) {
		switch (myReadState) {
			case READ_NONE:
				break;
			case READ_AUTHOR:
			case READ_AUTHOR2:
			case READ_TITLE:
			case READ_SUBJECT:
			case READ_LANGUAGE:
				myBuffer.append(data, start, len);
				break;
		}
	}

	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if (tag.equals(myMetadataTagRealName)) {
			return true;
		}

		String bufferContent = myBuffer.toString().trim();
		if (bufferContent.length() != 0) {
			switch (myReadState) {
				case READ_TITLE:
					myBook.setTitle(bufferContent);
					break;
				case READ_AUTHOR:
					myAuthorList.add(bufferContent);
					break;
				case READ_AUTHOR2:
					myAuthorList2.add(bufferContent);
					break;
				case READ_SUBJECT:
					myBook.addTag(bufferContent);
					break;
				case READ_LANGUAGE:
					{
						int index = bufferContent.indexOf('_');
						if (index >= 0) {
							bufferContent = bufferContent.substring(0, index);
						}
						index = bufferContent.indexOf('-');
						if (index >= 0) {
							bufferContent = bufferContent.substring(0, index);
						}
						myBook.setLanguage(""cz"".equals(bufferContent) ? ""cs"" : bufferContent);
					}
					break;
			}
		} else {
			if (tag.equals(myMetaTag)) {
				if (!"""".equals(mySeriesTitle) && mySeriesIndex > 0) {
					myBook.setSeriesInfo(mySeriesTitle, mySeriesIndex);
				}
			}
		}
		myBuffer.delete(0, myBuffer.length());
		myReadState = READ_NONE;
		return false;
	}
}
",True,141,0,0,6,39,1,6,L4
16,org.geometerplus.fbreader.formats.fb2.FB2AnnotationReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

public class FB2AnnotationReader extends ZLXMLReaderAdapter {
	private final static int READ_NOTHING = 0;
	private final static int READ_ANNOTATION = 1;

	private int myReadState = READ_NOTHING;
	private final StringBuilder myBuffer = new StringBuilder();

	public FB2AnnotationReader() {
	}
	
	public boolean dontCacheAttributeValues() {
		return true;
	}
	
	public String readAnnotation(ZLFile file) {
		myReadState = READ_NOTHING;
		myBuffer.delete(0, myBuffer.length());
		if (readDocument(file)) {
			final int len = myBuffer.length();
			if (len > 1) {
				if (myBuffer.charAt(len - 1) == '\n') {
					myBuffer.delete(len - 1, len);
				}
				return myBuffer.toString();
			}
		}
		return null;
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (FB2Tag.getTagByName(tagName)) {
			case FB2Tag.BODY:
				return true;
			case FB2Tag.ANNOTATION:
				myReadState = READ_ANNOTATION;
				break;
			default:
				if (myReadState == READ_ANNOTATION) {
					// TODO: add tag to buffer
					myBuffer.append("" "");
				}
				break;
		}
		return false;
	}
	
	public boolean endElementHandler(String tag) {
		if (myReadState != READ_ANNOTATION) {
			return false;
		}
		switch (FB2Tag.getTagByName(tag)) {
			case FB2Tag.ANNOTATION:
				return true;
			case FB2Tag.P:
				myBuffer.append(""\n"");
				break;
			default:
				// TODO: add tag to buffer
				myBuffer.append("" "");
				break;
		}
		return false;
	}
	
	public void characterDataHandler(char[] data, int start, int length) {
		if (myReadState == READ_ANNOTATION) {
			myBuffer.append(new String(data, start, length).trim());
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file, 512);
	}
}
",False,145,8,50,5,7,1,5,L4
17,org.geometerplus.fbreader.formats.fb2.Base64EncodedImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.io.*;

import org.geometerplus.zlibrary.core.image.ZLBase64EncodedImage;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.fbreader.Paths;

final class Base64EncodedImage extends ZLBase64EncodedImage {
	private static int ourCounter;

	static void resetCounter() {
		ourCounter = 0;
	}

	private final String myDirName;
	private final int myFileNumber;
	private OutputStreamWriter myStreamWriter;
	
	public Base64EncodedImage(MimeType mimeType) {
		// TODO: use contentType
		super(mimeType);
		myDirName = Paths.cacheDirectory();
		new File(myDirName).mkdirs();
		myFileNumber = ourCounter++;
		try {
			myStreamWriter = new OutputStreamWriter(new FileOutputStream(encodedFileName()), ""UTF-8"");
		} catch (IOException e) {
		}
	}

	@Override
	protected String encodedFileName() {
		return myDirName + ""/image"" + myFileNumber;
	}

	@Override
	protected String decodedFileName() {
		return myDirName + ""/dimage"" + myFileNumber;
	}

	void addData(char[] data, int offset, int length) {
		if (myStreamWriter != null) {
			try {
				myStreamWriter.write(data, offset, length);
			} catch (IOException e) {
			}
		}
	}

	void close() {
		try {
			if (myStreamWriter != null) {
				myStreamWriter.close();
			}
		} catch (IOException e) {
		}
	}
}
",True,151,9,50,7,6,2,3,L4
18,org.geometerplus.fbreader.formats.fb2.FB2Tag.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

final class FB2Tag {
	public static final byte UNKNOWN = 0;
	public static final byte P = 1;
	public static final byte V = 2;
	public static final byte SUBTITLE = 3;
	public static final byte TEXT_AUTHOR = 4;
	public static final byte DATE = 5;
	public static final byte CITE = 6;
	public static final byte SECTION = 7;
	public static final byte POEM = 8;
	public static final byte STANZA = 9;
	public static final byte EPIGRAPH = 10;
	public static final byte ANNOTATION = 11;
	public static final byte COVERPAGE = 12;
	public static final byte A = 13;
	public static final byte EMPTY_LINE = 14;
	public static final byte SUP = 15;
	public static final byte SUB = 16;
	public static final byte EMPHASIS = 17;
	public static final byte STRONG = 18;
	public static final byte CODE = 19;
	public static final byte STRIKETHROUGH = 20;
	public static final byte TITLE = 21;
	public static final byte BODY = 22;
	public static final byte IMAGE = 23;
	public static final byte BINARY = 24;
	public static final byte FICTIONBOOK = 25;
	
	public static final byte TITLE_INFO = 26;
	public static final byte BOOK_TITLE = 27;
	public static final byte AUTHOR = 28;
	public static final byte LANG = 29;
	public static final byte FIRST_NAME = 30;
	public static final byte MIDDLE_NAME = 31;
	public static final byte LAST_NAME = 32;
	public static final byte SEQUENCE = 33;
	public static final byte GENRE = 34;

	public static final byte DESCRIPTION = 35;


	private static final HashMap<String, Byte> ourTagByName = new HashMap<String, Byte>(256, 0.2f);
	private static final Byte ourUnknownTag;

	static {	
		ourTagByName.put(""unknown"", UNKNOWN);
		ourUnknownTag = (Byte)ourTagByName.get(""unknown"");
		ourTagByName.put(""p"", P);
		ourTagByName.put(""v"", V);
		ourTagByName.put(""subtitle"", SUBTITLE);
		ourTagByName.put(""text-author"", TEXT_AUTHOR);
		ourTagByName.put(""date"", DATE);
		ourTagByName.put(""cite"", CITE);
		ourTagByName.put(""section"", SECTION);
		ourTagByName.put(""poem"", POEM);
		ourTagByName.put(""stanza"", STANZA);
		ourTagByName.put(""epigraph"", EPIGRAPH);
		ourTagByName.put(""annotation"", ANNOTATION);
		ourTagByName.put(""coverpage"", COVERPAGE);
		ourTagByName.put(""a"", A);
		ourTagByName.put(""empty-line"", EMPTY_LINE);
		ourTagByName.put(""sup"", SUP);
		ourTagByName.put(""sub"", SUB);
		ourTagByName.put(""emphasis"", EMPHASIS);
		ourTagByName.put(""strong"", STRONG);
		ourTagByName.put(""code"", CODE);
		ourTagByName.put(""strikethrough"", STRIKETHROUGH);
		ourTagByName.put(""title"", TITLE);
		ourTagByName.put(""title-info"", TITLE_INFO);
		ourTagByName.put(""body"", BODY);
		ourTagByName.put(""image"", IMAGE);
		ourTagByName.put(""binary"", BINARY);
		ourTagByName.put(""fictionbook"", FICTIONBOOK);
		ourTagByName.put(""book-title"", BOOK_TITLE);
		ourTagByName.put(""sequence"", SEQUENCE);
		ourTagByName.put(""first-name"", FIRST_NAME);
		ourTagByName.put(""middle-name"", MIDDLE_NAME);
		ourTagByName.put(""last-name"", LAST_NAME);
		ourTagByName.put(""book-title"", BOOK_TITLE);
		ourTagByName.put(""author"", AUTHOR);
		ourTagByName.put(""lang"", LANG);
		ourTagByName.put(""genre"", GENRE);
		ourTagByName.put(""description"", DESCRIPTION);
	}

	public static byte getTagByName(String name) {
		final HashMap<String,Byte> tagByName = ourTagByName;
		Byte num = tagByName.get(name);
		if (num == null) {
			final String upperCaseName = name.toLowerCase().intern();
			num = (Byte)tagByName.get(upperCaseName);
			if (num == null) {
				num = ourUnknownTag;
				tagByName.put(upperCaseName, num);
			}
			tagByName.put(name, num);
		}
		return num.byteValue();
	}

	private FB2Tag() {
	}
}
",False,122,9,50,0,0,4,0,L4
19,org.geometerplus.fbreader.formats.fb2.FB2MetaInfoReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Tag;

public class FB2MetaInfoReader extends ZLXMLReaderAdapter {
	private final static int READ_NOTHING = 0;
	private final static int READ_SOMETHING = 1;
	private final static int READ_TITLE = 2;
	private final static int READ_AUTHOR = 3;
	private final static int READ_AUTHOR_NAME_0 = 4;
	private final static int READ_AUTHOR_NAME_1 = 5;
	private final static int READ_AUTHOR_NAME_2 = 6;
	private final static int READ_LANGUAGE = 7;
	private final static int READ_GENRE = 8;

	private final Book myBook;
	private int myReadState = READ_NOTHING;

	private	final String[] myAuthorNames = new String[3];
	private final StringBuilder myBuffer = new StringBuilder();

	public FB2MetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle(null);
		myBook.setLanguage(null);
	}
	
	public boolean dontCacheAttributeValues() {
		return true;
	}
	
	public boolean readMetaInfo() {
		myReadState = READ_NOTHING;
		myAuthorNames[0] = """";
		myAuthorNames[1] = """";
		myAuthorNames[2] = """";
		myBuffer.delete(0, myBuffer.length());
		return readDocument(myBook.File);
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (FB2Tag.getTagByName(tagName)) {
			case FB2Tag.BODY:
				return true;
			case FB2Tag.TITLE_INFO:
				myReadState = READ_SOMETHING;
				break;
			case FB2Tag.BOOK_TITLE:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_TITLE;
				}
				break;
			case FB2Tag.GENRE:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_GENRE;
				}
				break;
			case FB2Tag.AUTHOR:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.LANG:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_LANGUAGE;
				}
				break;
			case FB2Tag.FIRST_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_0;
				}
				break;
			case FB2Tag.MIDDLE_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_1;
				}
				break;
			case FB2Tag.LAST_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_2;
				}
				break;
			case FB2Tag.SEQUENCE:
				if (myReadState == READ_SOMETHING) {
					String name = attributes.getValue(""name"");
					if (name != null) {
						name.trim();
						if (name.length() != 0) {
							int index = 0;
							try {
								final String sIndex = attributes.getValue(""number"");
								if (sIndex != null) {
									index = Integer.parseInt(sIndex);
								}
							} catch (NumberFormatException e) {
							}
							myBook.setSeriesInfo(name, index);
						}
					}
				}
				break;
		}
		return false;
	}
	
	public boolean endElementHandler(String tag) {
		switch (FB2Tag.getTagByName(tag)) {
			case FB2Tag.TITLE_INFO:
				myReadState = READ_NOTHING;
				break;
			case FB2Tag.BOOK_TITLE:
				if (myReadState == READ_TITLE) {
					myBook.setTitle(myBuffer.toString().trim());
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.GENRE:
				if (myReadState == READ_GENRE) {
					final String genre = myBuffer.toString().trim();
					if (genre.length() > 0) {
						final ArrayList<Tag> tags = FB2TagManager.humanReadableTags(genre);
						if (tags != null) {
							for (Tag t : tags) {
								myBook.addTag(t);
							}
						} else {
							myBook.addTag(genre);
						}
					}
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.AUTHOR:
				if (myReadState == READ_AUTHOR) {
					myAuthorNames[0] = myAuthorNames[0].trim();
					myAuthorNames[1] = myAuthorNames[1].trim();
					myAuthorNames[2] = myAuthorNames[2].trim();
					String fullName = myAuthorNames[0];
					if (fullName.length() != 0 && myAuthorNames[1].length() != 0) {
						fullName += ' ';
					}
					fullName += myAuthorNames[1];
					if (fullName.length() != 0 && myAuthorNames[2].length() != 0) {
						fullName += ' ';
					}
					fullName += myAuthorNames[2];
					myBook.addAuthor(fullName, myAuthorNames[2]);
					myAuthorNames[0] = """";
					myAuthorNames[1] = """";
					myAuthorNames[2] = """";
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.LANG:
				if (myReadState == READ_LANGUAGE) {
					myBook.setLanguage(myBuffer.toString().trim());
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.FIRST_NAME:
				if (myReadState == READ_AUTHOR_NAME_0) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.MIDDLE_NAME:
				if (myReadState == READ_AUTHOR_NAME_1) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.LAST_NAME:
				if (myReadState == READ_AUTHOR_NAME_2) {
					myReadState = READ_AUTHOR;
				}
				break;
			default:
				break;
		}	
		myBuffer.delete(0, myBuffer.length());
		return false;
	}
	
	public void characterDataHandler(char[] data, int start, int length) {
		switch (myReadState) {
			case READ_AUTHOR_NAME_0:
				myAuthorNames[0] += new String(data, start, length);
				break;
			case READ_AUTHOR_NAME_1:
				myAuthorNames[1] += new String(data, start, length);
				break;
			case READ_AUTHOR_NAME_2:
				myAuthorNames[2] += new String(data, start, length);
				break;
			case READ_TITLE:
			case READ_LANGUAGE:
			case READ_GENRE:
				myBuffer.append(data, start, length);
				break;
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file, 512);
	}
}
",True,141,0,0,6,38,1,8,L4
20,org.geometerplus.fbreader.formats.fb2.FB2Reader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.util.*;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.zlibrary.text.model.ZLTextParagraph;

import org.geometerplus.fbreader.bookmodel.*;

public final class FB2Reader extends ZLXMLReaderAdapter {
	private final BookReader myBookReader;

	private boolean myInsidePoem = false;
	private boolean myInsideTitle = false;
	private int myBodyCounter = 0;
	private boolean myReadMainText = false;
	private int mySectionDepth = 0;
	private boolean mySectionStarted = false;
	
	private byte myHyperlinkType;
	
	private Base64EncodedImage myCurrentImage;
	private boolean myInsideCoverpage = false;
	private String myCoverImageReference;
	private int myParagraphsBeforeBodyNumber = Integer.MAX_VALUE;

	private final char[] SPACE = { ' ' }; 

	private byte[] myTagStack = new byte[10];
	private int myTagStackSize = 0;

	public FB2Reader(BookModel model) {
 		myBookReader = new BookReader(model);
	}

	boolean readBook() {
		Base64EncodedImage.resetCounter();
		return ZLXMLProcessor.read(this, myBookReader.Model.Book.File);
	}

	public void startDocumentHandler() {
	}

	public void endDocumentHandler() {
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}

	public void characterDataHandler(char[] ch, int start, int length) {
		if (length == 0) {
			return;
		}
		final Base64EncodedImage image = myCurrentImage;
		if (image != null) {
			image.addData(ch, start, length);
		} else {
			myBookReader.addData(ch, start, length, false);
		}		
	}

	public void characterDataHandlerFinal(char[] ch, int start, int length) {
		if (length == 0) {
			return;
		}
		final Base64EncodedImage image = myCurrentImage;
		if (image != null) {
			image.addData(ch, start, length);
		} else {
			myBookReader.addData(ch, start, length, true);
		}		
	}

	public boolean endElementHandler(String tagName) {
		final byte tag = myTagStack[--myTagStackSize];
		switch (tag) {
			case FB2Tag.P:
				myBookReader.endParagraph();		
				break;
			case FB2Tag.SUB:
				myBookReader.addControl(FBTextKind.SUB, false);
				break;
			case FB2Tag.SUP:
				myBookReader.addControl(FBTextKind.SUP, false);
				break;
			case FB2Tag.CODE:
				myBookReader.addControl(FBTextKind.CODE, false);
				break;
			case FB2Tag.EMPHASIS:
				myBookReader.addControl(FBTextKind.EMPHASIS, false);
				break;
			case FB2Tag.STRONG:
				myBookReader.addControl(FBTextKind.STRONG, false);
				break;
			case FB2Tag.STRIKETHROUGH:
				myBookReader.addControl(FBTextKind.STRIKETHROUGH, false);
				break;
			
			case FB2Tag.V:
			case FB2Tag.SUBTITLE:
			case FB2Tag.TEXT_AUTHOR:
			case FB2Tag.DATE:
				myBookReader.popKind();
				myBookReader.endParagraph();
				break;	
			
			case FB2Tag.CITE:
			case FB2Tag.EPIGRAPH:
				myBookReader.popKind();
				break;	
			
			case FB2Tag.POEM:
				myInsidePoem = false;
				break;
			
			case FB2Tag.STANZA:
				myBookReader.beginParagraph(ZLTextParagraph.Kind.AFTER_SKIP_PARAGRAPH);
				myBookReader.endParagraph();
				myBookReader.beginParagraph(ZLTextParagraph.Kind.EMPTY_LINE_PARAGRAPH);
				myBookReader.endParagraph();
				myBookReader.popKind();
				break;
				
			case FB2Tag.SECTION:
				if (myReadMainText) {
					myBookReader.endContentsParagraph();
					--mySectionDepth;
					mySectionStarted = false;
				} else {
					myBookReader.unsetCurrentTextModel();
				}
				break;
			
			case FB2Tag.ANNOTATION:
				myBookReader.popKind();
				if (myBodyCounter == 0) {
					myBookReader.insertEndOfSectionParagraph();
					myBookReader.unsetCurrentTextModel();
				}
				break;
			
			case FB2Tag.TITLE:
				myBookReader.popKind();
				myBookReader.exitTitle();
				myInsideTitle = false;
				break;
				
			case FB2Tag.BODY:
				myBookReader.popKind();
				myReadMainText = false;
				if (myReadMainText) {
					myBookReader.insertEndOfSectionParagraph();
				}
				if (mySectionDepth > 0) {
					myBookReader.endContentsParagraph();
					mySectionDepth = 0;
				}
				myBookReader.unsetCurrentTextModel();
				break;
			
			case FB2Tag.A:
				myBookReader.addControl(myHyperlinkType, false);
				break;
			
			case FB2Tag.COVERPAGE:
				if (myBodyCounter == 0) {
					myInsideCoverpage = false;
					myBookReader.insertEndOfSectionParagraph();
					myBookReader.unsetCurrentTextModel();
				}
				break;	
			
			case FB2Tag.BINARY:
				if (myCurrentImage != null) {
					myCurrentImage.close();
					myCurrentImage = null;
				}
				break;	
				
			default:
				break;
		}		
		return false;
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		String id = attributes.getValue(""id"");
		if (id != null) {
			if (!myReadMainText) {
				myBookReader.setFootnoteTextModel(id);
			}
			myBookReader.addHyperlinkLabel(id);
		}
		final byte tag = FB2Tag.getTagByName(tagName);
		byte[] tagStack = myTagStack;
		if (tagStack.length == myTagStackSize) {
			tagStack = ZLArrayUtils.createCopy(tagStack, myTagStackSize, myTagStackSize * 2);
			myTagStack = tagStack;
		}
		tagStack[myTagStackSize++] = tag;
		switch (tag) {
			case FB2Tag.P:
				if (mySectionStarted) {
					mySectionStarted = false;
				} else if (myInsideTitle) {
					myBookReader.addContentsData(SPACE);
				}
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			
			case FB2Tag.SUB:
				myBookReader.addControl(FBTextKind.SUB, true);
				break;
			case FB2Tag.SUP:
				myBookReader.addControl(FBTextKind.SUP, true);
				break;
			case FB2Tag.CODE:
				myBookReader.addControl(FBTextKind.CODE, true);
				break;
			case FB2Tag.EMPHASIS:
				myBookReader.addControl(FBTextKind.EMPHASIS, true);
				break;
			case FB2Tag.STRONG:
				myBookReader.addControl(FBTextKind.STRONG, true);
				break;
			case FB2Tag.STRIKETHROUGH:
				myBookReader.addControl(FBTextKind.STRIKETHROUGH, true);
				break;
			
			case FB2Tag.V:
				myBookReader.pushKind(FBTextKind.VERSE);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
				
			case FB2Tag.TEXT_AUTHOR:
				myBookReader.pushKind(FBTextKind.AUTHOR);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
				
			case FB2Tag.SUBTITLE:
				myBookReader.pushKind(FBTextKind.SUBTITLE);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			case FB2Tag.DATE:
				myBookReader.pushKind(FBTextKind.DATE);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			
			case FB2Tag.EMPTY_LINE:
				myBookReader.beginParagraph(ZLTextParagraph.Kind.EMPTY_LINE_PARAGRAPH);
				myBookReader.endParagraph();
				break;
			
			case FB2Tag.CITE:
				myBookReader.pushKind(FBTextKind.CITE);
				break;
			case FB2Tag.EPIGRAPH:
				myBookReader.pushKind(FBTextKind.EPIGRAPH);
				break;
			
			case FB2Tag.POEM:
				myInsidePoem = true;
				break;	
			
			case FB2Tag.STANZA:
				myBookReader.pushKind(FBTextKind.STANZA);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.BEFORE_SKIP_PARAGRAPH);
				myBookReader.endParagraph();
				break;
				
			case FB2Tag.SECTION:
				if (myReadMainText) {
					myBookReader.insertEndOfSectionParagraph();
					++mySectionDepth;
					myBookReader.beginContentsParagraph();
					mySectionStarted = true;
				}
				break;
			
			case FB2Tag.ANNOTATION:
				if (myBodyCounter == 0) {
					myBookReader.setMainTextModel();
				}
				myBookReader.pushKind(FBTextKind.ANNOTATION);
				break;
			
			case FB2Tag.TITLE:
				if (myInsidePoem) {
					myBookReader.pushKind(FBTextKind.POEM_TITLE);
				} else if (mySectionDepth == 0) {
					myBookReader.insertEndOfSectionParagraph();
					myBookReader.pushKind(FBTextKind.TITLE);
				} else {
					myBookReader.pushKind(FBTextKind.SECTION_TITLE);
					if (!myBookReader.hasContentsData()) {
						myInsideTitle = true;
						myBookReader.enterTitle();
					}
				}
				break;
				
			case FB2Tag.BODY:
				++myBodyCounter;
				myParagraphsBeforeBodyNumber = myBookReader.Model.BookTextModel.getParagraphsNumber();
				final String name = attributes.getValue(""name"");
				if (myBodyCounter == 1 || !""notes"".equals(name)) {
					myBookReader.setMainTextModel();
					if (name != null) {
						myBookReader.beginContentsParagraph();
						myBookReader.addContentsData(name.toCharArray());
						++mySectionDepth;
					}
					myReadMainText = true;
				}
				myBookReader.pushKind(FBTextKind.REGULAR);
				break;
			
			case FB2Tag.A:
			{
				String ref = getAttributeValue(attributes, XMLNamespaces.XLink, ""href"");
				if ((ref != null) && (ref.length() != 0)) {
					final String type = attributes.getValue(""type"");
					if (ref.charAt(0) == '#') {
						myHyperlinkType = ""note"".equals(type) ? FBTextKind.FOOTNOTE : FBTextKind.INTERNAL_HYPERLINK;
						ref = ref.substring(1);
					} else {
						myHyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
					}
					myBookReader.addHyperlinkControl(myHyperlinkType, ref);
				} else {
					myHyperlinkType = FBTextKind.FOOTNOTE;
					myBookReader.addControl(myHyperlinkType, true);
				}
				break;
			}
			case FB2Tag.COVERPAGE:
				if (myBodyCounter == 0) {
					myInsideCoverpage = true;
					myBookReader.setMainTextModel();
				}
				break;	

			case FB2Tag.IMAGE:
			{
				String imgRef = getAttributeValue(attributes, XMLNamespaces.XLink, ""href"");
				if ((imgRef != null) && (imgRef.length() != 0) && (imgRef.charAt(0) == '#')) {
					String vOffset = attributes.getValue(""voffset"");
					short offset = 0;
					try {
						offset = Short.parseShort(vOffset);
					} catch (NumberFormatException e) {
					}
					imgRef = imgRef.substring(1);
					if (!imgRef.equals(myCoverImageReference) ||
							myParagraphsBeforeBodyNumber != myBookReader.Model.BookTextModel.getParagraphsNumber()) {
						myBookReader.addImageReference(imgRef, offset);
					}
					if (myInsideCoverpage) {
						myCoverImageReference = imgRef;
					}
				}
				break;
			}
			case FB2Tag.BINARY:			
				final String contentType = attributes.getValue(""content-type"");
				final String imgId = attributes.getValue(""id"");
				if (contentType != null && id != null) {
					myCurrentImage = new Base64EncodedImage(MimeType.get(contentType));
					myBookReader.addImage(imgId, myCurrentImage);
				}
				break;	

			default:
				break;
		}
		return false;
	}

	public boolean processNamespaces() {
		return true;
	}

	public void addExternalEntities(HashMap<String,char[]> entityMap) {
		entityMap.put(""FBReaderVersion"", ZLibrary.Instance().getVersionName().toCharArray());
	}

	public List<String> externalDTDs() {
		return Collections.emptyList();
	}
}
",True,142,1,1,6,31,2,16,L4
21,org.geometerplus.fbreader.formats.fb2.FB2TagManager.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Tag;

abstract class FB2TagManager {
	private static final HashMap<String,ArrayList<Tag>> ourMap = new HashMap<String,ArrayList<Tag>>();

	static ArrayList<Tag> humanReadableTags(String id) {
		if (ourMap.isEmpty()) {
			new FB2TagInfoReader().read(
				ZLResourceFile.createResourceFile(""formats/fb2/fb2genres.xml"")
			);
		}
		return ourMap.get(id);
	}

	private FB2TagManager() {
	}

	private static class FB2TagInfoReader extends ZLXMLReaderAdapter {
		private final String myLanguage;
		private Tag myCategoryTag;
		private Tag mySubCategoryTag;
		private final ArrayList<String> myGenreIds = new ArrayList<String>();

		FB2TagInfoReader() {
			final String language = Locale.getDefault().getLanguage();
			myLanguage = (""ru"".equals(language)) ? ""ru"" : ""en"";
		}

		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			if ((tag == ""subgenre"") || (tag == ""genre-alt"")) {
				final String id = attributes.getValue(""value"");
				if (id != null) {
					myGenreIds.add(id);
				}
			} else if (tag == ""root-descr"") {
				if (myLanguage == attributes.getValue(""lang"")) {
					myCategoryTag = Tag.getTag(null, attributes.getValue(""genre-title""));
				}
			} else if (tag == ""genre-descr"") {
				if (myLanguage == attributes.getValue(""lang"")) {
					mySubCategoryTag = Tag.getTag(myCategoryTag, attributes.getValue(""title""));
				}
			}
			return false;
		}

		public boolean endElementHandler(String tag) {
			if (tag == ""genre"") {
				myCategoryTag = null;
				mySubCategoryTag = null;
				myGenreIds.clear();
			} else if (tag == ""subgenre"") {
				if (mySubCategoryTag != null) {
					for (String id : myGenreIds) {
						ArrayList<Tag> list = ourMap.get(id);
						if (list == null) {
							list = new ArrayList<Tag>();
							ourMap.put(id, list);
						}
						list.add(mySubCategoryTag);
					}
				}
				mySubCategoryTag = null;
				myGenreIds.clear();
			}
			return false;
		}
	}
}
",True,145,9,50,6,6,1,4,L4
22,org.geometerplus.fbreader.formats.fb2.FB2Plugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class FB2Plugin extends FormatPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		return ""fb2"".equals(file.getExtension());
	}
	
	@Override
	public boolean readMetaInfo(Book book) {
		return new FB2MetaInfoReader(book).readMetaInfo();
	}
	
	@Override
	public boolean readModel(BookModel model) {
		return new FB2Reader(model).readBook();
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		return new FB2CoverReader().readCover(file);
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return new FB2AnnotationReader().readAnnotation(file);
	}
}
",False,141,0,0,6,36,1,9,L4
23,org.geometerplus.fbreader.formats.fb2.FB2CoverReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class FB2CoverReader {
	public FB2CoverImage readCover(ZLFile file) {
		return new FB2CoverImage(file);
	}
}
",False,165,8,50,6,13,1,2,L4
24,org.geometerplus.fbreader.formats.fb2.FB2CoverImage.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.image.ZLImageProxy;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.xml.*;

class FB2CoverImage extends ZLImageProxy {
	private final ZLFile myFile;

	FB2CoverImage(ZLFile file) {
		myFile = file;
	}

	@Override
	public ZLSingleImage getRealImage() {
		return new BackgroundReader().readCover(myFile);
	}

	@Override
	public int sourceType() {
		return SourceType.DISK;
	}

	@Override
	public String getId() {
		return myFile.getPath();
	}

	private static class BackgroundReader extends ZLXMLReaderAdapter {
		private boolean myReadCoverPage;
		private String myImageReference;
		private Base64EncodedImage myImage;

		Base64EncodedImage readCover(ZLFile file) {
			myReadCoverPage = false;
			myImageReference = null;
			read(file);
			return myImage;
		}

		@Override
		public boolean processNamespaces() {
			return true;
		}

		@Override
		public boolean startElementHandler(String tagName, ZLStringMap attributes) {
			switch (FB2Tag.getTagByName(tagName)) {
			case FB2Tag.COVERPAGE:
				myReadCoverPage = true;
				break;
			case FB2Tag.IMAGE:
				if (myReadCoverPage) {
					final String href = getAttributeValue(attributes, XMLNamespaces.XLink, ""href"");
					if (href != null && href.length() > 1 && href.charAt(0) == '#') {
						myImageReference = href.substring(1);
					}
				}
				break;
			case FB2Tag.BINARY:
				if (myImageReference != null) {
					final String id = attributes.getValue(""id"");
					final String contentType = attributes.getValue(""content-type"");
					if (id != null && contentType != null && myImageReference.equals(id)) {
						// FIXME: make different Base64EncodedImage constructor to use another cache for covers
						myImage = new Base64EncodedImage(contentType != null ? MimeType.get(contentType) : MimeType.IMAGE_AUTO);
					}
				}
				break;
			}
			return false;
		}

		@Override
		public boolean endElementHandler(String tag) {
			switch (FB2Tag.getTagByName(tag)) {
			case FB2Tag.COVERPAGE:
				myReadCoverPage = false;
				break;
			case FB2Tag.DESCRIPTION:
				if (myImageReference == null) {
					return true;
				}
				break;
			case FB2Tag.BINARY:
				if (myImage != null) {
					myImage.close();
					return true;
				}
				break;
			}	
			return false;
		}

		@Override
		public void characterDataHandler(char[] data, int start, int length) {
			if (length > 0 && myImage != null) {
				myImage.addData(data, start, length);
			}
		}
	}
}
",False,165,9,50,5,13,1,9,L4
25,org.geometerplus.fbreader.formats.pdb.MobipocketHtmlBookReader.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.util.*;
import java.io.*;
import java.nio.charset.CharsetDecoder;

import org.geometerplus.zlibrary.core.html.ZLByteBuffer;
import org.geometerplus.zlibrary.core.html.ZLHtmlAttributeMap;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.fbreader.formats.html.HtmlReader;
import org.geometerplus.fbreader.formats.html.HtmlTag;
import org.geometerplus.fbreader.bookmodel.BookModel;

public class MobipocketHtmlBookReader extends HtmlReader {
	private final CharsetDecoder myTocDecoder;
	private MobipocketStream myMobipocketStream;

	MobipocketHtmlBookReader(BookModel model) throws UnsupportedEncodingException {
		super(model);
		myTocDecoder = createDecoder();
	}

	public InputStream getInputStream() throws IOException {
		myMobipocketStream = new MobipocketStream(Model.Book.File);
		return myMobipocketStream;
	}

	private boolean myReadGuide;
	private int myTocStartOffset = Integer.MAX_VALUE;
	private int myTocEndOffset = Integer.MAX_VALUE;
	private final TreeMap<Integer,String> myTocEntries = new TreeMap<Integer,String>();
	private final TreeMap<Integer,Integer> myPositionToParagraph = new TreeMap<Integer,Integer>();
	private final TreeSet<Integer> myFileposReferences = new TreeSet<Integer>();
	private int myCurrentTocPosition = -1;
	private final ZLByteBuffer myTocBuffer = new ZLByteBuffer();

	private boolean tocRangeContainsPosition(int position) {
		return (myTocStartOffset <= position) && (position < myTocEndOffset);
	}

	@Override
	public void startElementHandler(byte tag, int offset, ZLHtmlAttributeMap attributes) {
		final int paragraphIndex = Model.BookTextModel.getParagraphsNumber();
		myPositionToParagraph.put(offset, paragraphIsOpen() ? paragraphIndex - 1 : paragraphIndex);
		switch (tag) {
			case HtmlTag.IMG:
			{
				final ZLByteBuffer recIndex = attributes.getValue(""recindex"");
				if (recIndex != null) {
					try {
						final int index = Integer.parseInt(recIndex.toString());
						if (paragraphIsOpen()) {
							endParagraph();
							addImageReference("""" + index);
							beginParagraph();
						} else {
							addImageReference("""" + index);
						}
					} catch (NumberFormatException e) {
					}
				}
				break;
			}
			case HtmlTag.GUIDE:
				myReadGuide = true;
				break;
			case HtmlTag.REFERENCE:
				if (myReadGuide) {
					final ZLByteBuffer fp = attributes.getValue(""filepos"");
					final ZLByteBuffer title = attributes.getValue(""title"");
					if ((fp != null) && (title != null)) {
						try {
							int filePosition = Integer.parseInt(fp.toString());
							myTocEntries.put(filePosition, title.toString(myAttributeDecoder));
							if (tocRangeContainsPosition(filePosition)) {
								myTocEndOffset = filePosition;
							}
							if (attributes.getValue(""type"").equalsToLCString(""toc"")) {
								myTocStartOffset = filePosition;
								final SortedMap<Integer,String> subMap =
									myTocEntries.tailMap(filePosition + 1);
								if (!subMap.isEmpty()) {
									myTocEndOffset = subMap.firstKey();
								}
							}
						} catch (NumberFormatException e) {
						}
					}
				}
				break;
			case HtmlTag.A:
			{
				final ZLByteBuffer fp = attributes.getValue(""filepos"");
				if (fp != null) {
					try {
						int filePosition = Integer.parseInt(fp.toString());
						if (tocRangeContainsPosition(offset)) {
							myCurrentTocPosition = filePosition;
							if (tocRangeContainsPosition(filePosition)) {
								myTocEndOffset = filePosition;
							}
						}
						myFileposReferences.add(filePosition);
						attributes.put(new ZLByteBuffer(""href""), new ZLByteBuffer(""&filepos"" + filePosition));
					} catch (NumberFormatException e) {
					}
				}
				super.startElementHandler(tag, offset, attributes);
				break;
			}
			default:
				super.startElementHandler(tag, offset, attributes);
				break;
		}
	}

	@Override
	public void endElementHandler(byte tag) {
		switch (tag) {
			case HtmlTag.IMG:
				break;
			case HtmlTag.GUIDE:
				myReadGuide = false;
				break;
			case HtmlTag.REFERENCE:
				break;
			case HtmlTag.A:
				if (myCurrentTocPosition != -1) {
					if (!myTocBuffer.isEmpty()) {
						myTocEntries.put(myCurrentTocPosition, myTocBuffer.toString(myTocDecoder));
						myTocBuffer.clear();
					}
					myCurrentTocPosition = -1;
				}
				super.endElementHandler(tag);
				break;
			default:
				super.endElementHandler(tag);
				break;
		}
	}

	@Override
	public void byteDataHandler(byte[] data, int start, int length) {
		if (myCurrentTocPosition != -1) {
			myTocBuffer.append(data, start, length);
		}
		super.addByteData(data, start, length);
	}

	@Override
	public void startDocumentHandler() {
		super.startDocumentHandler();

		for (int index = 0; ; ++index) {
			final int offset = myMobipocketStream.getImageOffset(index);
			if (offset < 0) {
				break;
			}
			final int length = myMobipocketStream.getImageLength(index);
			if (length <= 0) {
				break;
			}
			addImage("""" + (index + 1), new ZLFileImage(MimeType.IMAGE_AUTO, Model.Book.File, offset, length));
		}
	}

	@Override
	public void endDocumentHandler() {
		for (Integer entry: myFileposReferences) {
			final SortedMap<Integer,Integer> subMap =
				myPositionToParagraph.tailMap(entry);
			if (subMap.isEmpty()) {
				break;
			}
			addHyperlinkLabel(""filepos"" + entry, subMap.get(subMap.firstKey()));
		}

		for (Map.Entry<Integer,String> entry : myTocEntries.entrySet()) {
			final SortedMap<Integer,Integer> subMap =
				myPositionToParagraph.tailMap(entry.getKey());
			if (subMap.isEmpty()) {
				break;
			}
			beginContentsParagraph(subMap.get(subMap.firstKey()));
			addContentsData(entry.getValue().toCharArray());
			endContentsParagraph();
		}
		super.endDocumentHandler();
	}
}
",True,141,0,0,6,38,1,11,L4
26,org.geometerplus.fbreader.formats.pdb.PdbStream.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.util.ZLInputStreamWithOffset;

public abstract class PdbStream extends InputStream {
	protected final ZLInputStreamWithOffset myBase;
	public PdbHeader myHeader;
	protected byte[] myBuffer;

	protected short myBufferLength;
	protected short myBufferOffset;

	public PdbStream(ZLFile file) throws IOException {
		myBase = new ZLInputStreamWithOffset(file.getInputStream());

		myHeader = new PdbHeader(myBase);

		myBase.skip(myHeader.Offsets[0] - myHeader.length());

		myBufferLength = 0;
		myBufferOffset = 0;
	}
	
	public int read() {
		if (!fillBuffer()) {
			return -1;
		}
		return myBuffer[myBufferOffset++];
	}

	public int read(byte[] buffer, int offset, int maxSize) {
		int realSize = 0;
		while (realSize < maxSize) {
			if (!fillBuffer()) {
				break;
			}
			int size = Math.min(maxSize - realSize, myBufferLength - myBufferOffset);
			if (size > 0) {
				if (buffer != null) {
					System.arraycopy(myBuffer, myBufferOffset, buffer, offset + realSize, size);
				}
				realSize += size;
				myBufferOffset += size;
			}
		}
		return (realSize > 0) ? realSize : -1;
	}
	
	public void close() throws IOException {
		if (myBase != null) {
			myBase.close();
		}
		if (myBuffer != null) {
			myBuffer = null;
		}
	}

	public void skip(int offset) throws IOException {
		if (offset > 0) {
			read(null, 0, offset);
		} else {
			throw new IOException(""Cannot skip: "" + offset + "" bytes"");
		}
	}

	protected abstract boolean fillBuffer();
}
",True,142,9,50,5,6,3,3,L4
27,org.geometerplus.fbreader.formats.pdb.PdbPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.fbreader.formats.FormatPlugin;

public abstract class PdbPlugin extends FormatPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		final String extension = file.getExtension();
		return (extension == ""prc"") || (extension == ""pdb"") || (extension == ""mobi"");
	}

	protected static String fileType(final ZLFile file) {
		// TODO: use database instead of option (?)
		ZLStringOption palmTypeOption = new ZLStringOption(file.getPath(), ""PalmType"", """");
		String palmType = palmTypeOption.getValue();
		if (palmType.length() != 8) {
			byte[] id = new byte[8];
			try {
				final InputStream stream = file.getInputStream();
				if (stream == null) {
					return null;
				}
				stream.skip(60);
				stream.read(id);
				stream.close();
			} catch (IOException e) {
			}
			palmType = new String(id).intern();
			palmTypeOption.setValue(palmType);
		}
		return palmType.intern();
	}
}
",True,142,1,1,8,34,2,3,L4
28,org.geometerplus.fbreader.formats.pdb.MobipocketPlugin.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

import org.geometerplus.zlibrary.core.encoding.ZLEncodingCollection;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.bookmodel.BookModel;

public class MobipocketPlugin extends PdbPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		return super.acceptsFile(file) && (fileType(file) == ""BOOKMOBI"");
	}

	@Override
	public boolean readMetaInfo(Book book) {
		InputStream stream = null;
		try {
			stream = book.File.getInputStream();
			final PdbHeader header = new PdbHeader(stream);
			PdbUtil.skip(stream, header.Offsets[0] + 16 - header.length());
			if (PdbUtil.readInt(stream) != 0x4D4F4249) /* ""MOBI"" */ {
				return false;
			}
			final int length = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 4);
			final int encodingCode = (int)PdbUtil.readInt(stream);
			String encodingName = ZLEncodingCollection.Instance().getEncodingName(encodingCode);
			if (encodingName == null) {
				encodingName = ""utf-8"";
			}
			book.setEncoding(encodingName);
			PdbUtil.skip(stream, 52);
			final int fullNameOffset = (int)PdbUtil.readInt(stream);
			final int fullNameLength = (int)PdbUtil.readInt(stream);
			final int languageCode = (int)PdbUtil.readInt(stream);
			book.setLanguage(ZLLanguageUtil.languageByIntCode(languageCode & 0xFF, (languageCode >> 8) & 0xFF));
			PdbUtil.skip(stream, 32);
			int offset = 132;
			if ((PdbUtil.readInt(stream) & 0x40) != 0) {
				PdbUtil.skip(stream, length - 116);
				offset = length + 20;
				if (PdbUtil.readInt(stream) == 0x45585448) /* ""EXTH"" */ {
					PdbUtil.skip(stream, 4);
					final int recordsNumber = (int)PdbUtil.readInt(stream);
					offset += 8;
					for (int i = 0; i < recordsNumber; ++i) {
						final int type = (int)PdbUtil.readInt(stream);
						final int size = (int)PdbUtil.readInt(stream);
						offset += size;
						if (size <= 8) {
							continue;
						}
						switch (type) {
							default:
								PdbUtil.skip(stream, size - 8);
								break;
							case 100:
							{
								final byte[] buffer = new byte[size - 8];
								stream.read(buffer);
								String author = new String(buffer, encodingName);
								final int index = author.indexOf(',');
								if (index != -1) {
									author = author.substring(index + 1).trim() +
											 ' ' +
											 author.substring(0, index).trim(); 
								} else {
									author = author.trim();
								}
								book.addAuthor(author);
								break;
							}
							case 105:
							{
								final byte[] buffer = new byte[size - 8];
								stream.read(buffer);
								book.addTag(new String(buffer, encodingName));
								break;
							}
						}
					}
				}
			}
			PdbUtil.skip(stream, fullNameOffset - offset);
			final byte[] titleBuffer = new byte[fullNameLength];
			stream.read(titleBuffer);
			book.setTitle(new String(titleBuffer, encodingName));
			return true;
		} catch (IOException e) {
			return false;
		} finally {
			if (stream != null) {
				try {
					stream.close();
				} catch (IOException e) {
				}
			}
		}
	}

	@Override
	public boolean readModel(BookModel model) {
		try {
			return new MobipocketHtmlBookReader(model).readBook();
		} catch (IOException e) {
			//e.printStackTrace();
			return false;
		}
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		InputStream stream = null;
		try {
			stream = file.getInputStream();
			final PdbHeader header = new PdbHeader(stream);
			PdbUtil.skip(stream, header.Offsets[0] + 16 - header.length());
			if (PdbUtil.readInt(stream) != 0x4D4F4249) /* ""MOBI"" */ {
				return null;
			}
			final int length = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 104);

			final int exthFlags = (int)PdbUtil.readInt(stream);
			int coverIndex = -1;
			int thumbIndex = -1;

			int offset = 132;
			if ((exthFlags & 0x40) != 0) {
				PdbUtil.skip(stream, length - 116);
				offset = length + 20;
				if (PdbUtil.readInt(stream) != 0x45585448) /* ""EXTH"" */ {
					return null;
				}
				PdbUtil.skip(stream, 4);
				final int recordsNumber = (int)PdbUtil.readInt(stream);
				offset += 8;
				for (int i = 0; i < recordsNumber; ++i) {
					final int type = (int)PdbUtil.readInt(stream);
					final int size = (int)PdbUtil.readInt(stream);
					offset += size;
					if (size <= 8) {
						continue;
					}
					switch (type) {
						default:
							PdbUtil.skip(stream, size - 8);
							break;
						case 201:
						{
							if (size == 12) {
								coverIndex = (int)PdbUtil.readInt(stream);
							} else {
								PdbUtil.skip(stream, size - 8);
							}
							break;
						}
						case 202:
						{
							if (size == 12) {
								thumbIndex = (int)PdbUtil.readInt(stream);
							} else {
								PdbUtil.skip(stream, size - 8);
							}
							break;
						}
					}
				}
			}
			final InputStream tempStream = stream;
			stream = null;
			tempStream.close();

			if (coverIndex == -1) {
				if (thumbIndex == -1) {
					return null;
				}
				coverIndex = thumbIndex;
			}

			MobipocketStream myMobipocketStream = new MobipocketStream(file);
			int start = myMobipocketStream.getImageOffset(coverIndex);
			if (start >= 0) {
				int len = myMobipocketStream.getImageLength(coverIndex);
				if (len > 0) {
					return new ZLFileImage(MimeType.IMAGE_AUTO, file, start, len);
				}
			}
			return null; 
		} catch (IOException e) {
			return null;
		} finally {
			if (stream != null) {
				try {
					stream.close();
				} catch (IOException e) {
				}
			}
		}
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return null;
	}
}
",True,141,0,0,6,40,1,14,L4
29,org.geometerplus.fbreader.formats.pdb.PdbUtil.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class PdbUtil {
	public static void skip(InputStream stream, int numBytes) throws IOException {
		numBytes -= stream.skip(numBytes);
		for (; numBytes > 0; --numBytes) {
			if (stream.read() == -1) {
				throw new IOException(""Unexpected end of stream"");
			}
		}
	}

	public static int readShort(InputStream stream) throws IOException {
		final byte[] tmp = new byte[2];
		stream.read(tmp, 0, 2);
		return (tmp[1] & 0xFF) + ((tmp[0] & 0xFF) << 8);
	}

	public static long readInt(InputStream stream) throws IOException {
		final byte[] tmp = new byte[4];
		stream.read(tmp, 0, 4);
		return (((long)(tmp[0] & 0xFF)) << 24) +
			  + ((tmp[1] & 0xFF) << 16) +
			  + ((tmp[2] & 0xFF) << 8) +
			  + (tmp[3] & 0xFF);
	}
}
",True,124,8,50,0,0,5,0,L4
30,org.geometerplus.fbreader.formats.pdb.MobipocketStream.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

class MobipocketStream extends PalmDocLikeStream {
	private final int myFileSize;
	private final int myImageStartIndex;

	MobipocketStream(ZLFile file) throws IOException {
		super(file);
		myFileSize = (int)file.size();

		myCompressionType = PdbUtil.readShort(myBase);
		PdbUtil.skip(myBase, 6);
		myMaxRecordIndex = Math.min(PdbUtil.readShort(myBase), myHeader.Offsets.length - 1);
		final int maxRecordSize = PdbUtil.readShort(myBase);
		if (maxRecordSize == 0) {
			throw new IOException(""The records are too short"");
		}
		myBuffer = new byte[maxRecordSize];
		myRecordIndex = 0;

		PdbUtil.skip(myBase, 96);
		myImageStartIndex = (int)PdbUtil.readInt(myBase);
	}

	int getImageOffset(int index) {
		try {
			return myHeader.Offsets[index + myImageStartIndex];
		} catch (ArrayIndexOutOfBoundsException e) {
			return -1;
		}
	}

	int getImageLength(int index) {
		try {
			final int i = index + myImageStartIndex;
			final int start = myHeader.Offsets[i];
			final int end = (i == myHeader.Offsets.length) ? myFileSize : myHeader.Offsets[i + 1];
			return end - start;
		} catch (ArrayIndexOutOfBoundsException e) {
			return -1;
		}
	}
}
",False,142,8,50,5,6,2,5,L4
31,org.geometerplus.fbreader.formats.pdb.PdbHeader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

public class PdbHeader {
	public final String DocName;
	public final int Flags;
	public final String Id;
	public final int[] Offsets;

	public PdbHeader(InputStream stream) throws IOException {
		final byte[] buffer = new byte[32];
		if (stream.read(buffer, 0, 32) != 32) {
			throw new IOException(""PdbHeader: cannot reader document name"");
		}
		DocName = new String(buffer);
		Flags = PdbUtil.readShort(stream);

		PdbUtil.skip(stream, 26);
		
		if (stream.read(buffer, 0, 8) != 8) {
			throw new IOException(""PdbHeader: cannot reader palm id"");
		}
		Id = new String(buffer, 0, 8);

		PdbUtil.skip(stream, 8);

		int numRecords = PdbUtil.readShort(stream);
		if (numRecords <= 0) {
			throw new IOException(""PdbHeader: record number = "" + numRecords);
		}
		Offsets = new int[numRecords];

		for (int i = 0; i < numRecords; ++i) {
			Offsets[i] = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 4);
		}
	}

	public final int length() {
		return 78 + Offsets.length * 8;
	}
}
",False,124,8,50,1,1,6,1,L4
32,org.geometerplus.fbreader.formats.pdb.PalmDocLikeStream.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

abstract class PalmDocLikeStream extends PdbStream {
	protected int myMaxRecordIndex;
	protected int myRecordIndex;
	protected interface CompressionType {
		int NONE = 1;
		int DOC = 2;
		int HUFFDIC = 17480;
	}
	protected int myCompressionType;

	private final long myFileSize;

	PalmDocLikeStream(ZLFile file) throws IOException {
		super(file);
		myFileSize = file.size();
	}

	protected final boolean fillBuffer() {
		while (myBufferOffset == myBufferLength) {
			if (myRecordIndex + 1 > myMaxRecordIndex) {
				return false;
			}
			++myRecordIndex;
			final int currentOffset = myHeader.Offsets[myRecordIndex];

			try {
				myBase.skip(currentOffset - myBase.offset());
				final int nextOffset =
					(myRecordIndex + 1 < myHeader.Offsets.length) ?
						myHeader.Offsets[myRecordIndex + 1] :
						(int)myFileSize;
				if (nextOffset < currentOffset) {
					return false;
				}
				final short recordSize = (short)Math.min(nextOffset - currentOffset, myBuffer.length);

				switch (myCompressionType) {
					case CompressionType.NONE:
						myBase.read(myBuffer, 0, recordSize);
						myBufferLength = recordSize;
						break;
					case CompressionType.DOC:
						myBufferLength = (short)DocDecompressor.decompress(myBase, myBuffer, recordSize);
						break;
					//case CompressionType.HUFFDIC:
					//	myBufferLength = (short)HuffdicDecompressor.decompress(myBase, myBuffer, recordSize);
					//	break;
					default:
						// Unsupported compression type
						return false;
				}
			} catch (IOException e) {
				return false;
			}
			myBufferOffset = 0;
		}
		
		return true;
	}
}
",True,142,9,50,5,6,1,5,L4
33,org.geometerplus.fbreader.formats.pdb.HuffdicDecompressor.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class HuffdicDecompressor {
	public static int decompress(InputStream stream, byte[] targetBuffer, int compressedSize) throws IOException {
		final byte[] sourceBuffer = new byte[compressedSize];

		if (stream.read(sourceBuffer) != compressedSize) {
			return 0;
		}

		int sourceIndex = 0;
		int targetIndex = 0;

		int count0 = 0;
		int count1 = 0;
		int count2 = 0;
		int count3 = 0;
		try {
			while (true) {
				final byte token = sourceBuffer[sourceIndex++];
				switch (token) {
					default:
						++count0;
						targetBuffer[targetIndex++] = token;
						break;
					case 1: case 2: case 3: case 4:
					case 5: case 6: case 7: case 8:
						++count1;
						System.arraycopy(sourceBuffer, sourceIndex, targetBuffer, targetIndex, token);
						sourceIndex += token;
						targetIndex += token;
						break;
					case -64: case -63: case -62: case -61:
					case -60: case -59: case -58: case -57:
					case -56: case -55: case -54: case -53:
					case -52: case -51: case -50: case -49:
					case -48: case -47: case -46: case -45:
					case -44: case -43: case -42: case -41:
					case -40: case -39: case -38: case -37:
					case -36: case -35: case -34: case -33:
					case -32: case -31: case -30: case -29:
					case -28: case -27: case -26: case -25:
					case -24: case -23: case -22: case -21:
					case -20: case -19: case -18: case -17:
					case -16: case -15: case -14: case -13:
					case -12: case -11: case -10: case -9:
					case -8: case -7: case -6: case -5:
					case -4: case -3: case -2: case -1:
						++count2;
						targetBuffer[targetIndex++] = ' ';
						targetBuffer[targetIndex++] = (byte)(token ^ 0x80);
						break;
					case -128: case -127: case -126: case -125:
					case -124: case -123: case -122: case -121:
					case -120: case -119: case -118: case -117:
					case -116: case -115: case -114: case -113:
					case -112: case -111: case -110: case -109:
					case -108: case -107: case -106: case -105:
					case -104: case -103: case -102: case -101:
					case -100: case -99: case -98: case -97:
					case -96: case -95: case -94: case -93:
					case -92: case -91: case -90: case -89:
					case -88: case -87: case -86: case -85:
					case -84: case -83: case -82: case -81:
					case -80: case -79: case -78: case -77:
					case -76: case -75: case -74: case -73:
					case -72: case -71: case -70: case -69:
					case -68: case -67: case -66: case -65:
						++count3;
						final int N = ((token & 0x3F) << 8) + (sourceBuffer[sourceIndex++] & 0xFF);
						int copyLength = (N & 7) + 3;
						int srcIndex = targetIndex - (N >> 3);
						if (targetIndex >= srcIndex + copyLength) {
							System.arraycopy(targetBuffer, srcIndex, targetBuffer, targetIndex, copyLength);
							targetIndex += copyLength;
						} else {
							while (copyLength-- > 0) {
								targetBuffer[targetIndex++] = targetBuffer[srcIndex++];
							}
						}
						break;
				}
			}
		} catch (Exception e) {
			if (targetIndex > targetBuffer.length) {
				targetIndex = targetBuffer.length;
			}
		}

		return targetIndex;
	}
}
",True,1,0,0,0,0,0,0,I0
34,org.geometerplus.fbreader.formats.pdb.DocDecompressor.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class DocDecompressor {
	public static int decompress(InputStream stream, byte[] targetBuffer, int compressedSize) throws IOException {
		final byte[] sourceBuffer = new byte[compressedSize];

		if (stream.read(sourceBuffer) != compressedSize) {
			return 0;
		}

		int sourceIndex = 0;
		int targetIndex = 0;

		int count0 = 0;
		int count1 = 0;
		int count2 = 0;
		int count3 = 0;
		try {
			while (true) {
				final byte token = sourceBuffer[sourceIndex++];
				switch (token) {
					default:
						++count0;
						targetBuffer[targetIndex++] = token;
						break;
					case 1: case 2: case 3: case 4:
					case 5: case 6: case 7: case 8:
						++count1;
						System.arraycopy(sourceBuffer, sourceIndex, targetBuffer, targetIndex, token);
						sourceIndex += token;
						targetIndex += token;
						break;
					case -64: case -63: case -62: case -61:
					case -60: case -59: case -58: case -57:
					case -56: case -55: case -54: case -53:
					case -52: case -51: case -50: case -49:
					case -48: case -47: case -46: case -45:
					case -44: case -43: case -42: case -41:
					case -40: case -39: case -38: case -37:
					case -36: case -35: case -34: case -33:
					case -32: case -31: case -30: case -29:
					case -28: case -27: case -26: case -25:
					case -24: case -23: case -22: case -21:
					case -20: case -19: case -18: case -17:
					case -16: case -15: case -14: case -13:
					case -12: case -11: case -10: case -9:
					case -8: case -7: case -6: case -5:
					case -4: case -3: case -2: case -1:
						++count2;
						targetBuffer[targetIndex++] = ' ';
						targetBuffer[targetIndex++] = (byte)(token ^ 0x80);
						break;
					case -128: case -127: case -126: case -125:
					case -124: case -123: case -122: case -121:
					case -120: case -119: case -118: case -117:
					case -116: case -115: case -114: case -113:
					case -112: case -111: case -110: case -109:
					case -108: case -107: case -106: case -105:
					case -104: case -103: case -102: case -101:
					case -100: case -99: case -98: case -97:
					case -96: case -95: case -94: case -93:
					case -92: case -91: case -90: case -89:
					case -88: case -87: case -86: case -85:
					case -84: case -83: case -82: case -81:
					case -80: case -79: case -78: case -77:
					case -76: case -75: case -74: case -73:
					case -72: case -71: case -70: case -69:
					case -68: case -67: case -66: case -65:
						++count3;
						final int N = ((token & 0x3F) << 8) + (sourceBuffer[sourceIndex++] & 0xFF);
						int copyLength = (N & 7) + 3;
						int srcIndex = targetIndex - (N >> 3);
						if (targetIndex >= srcIndex + copyLength) {
							System.arraycopy(targetBuffer, srcIndex, targetBuffer, targetIndex, copyLength);
							targetIndex += copyLength;
						} else {
							while (copyLength-- > 0) {
								targetBuffer[targetIndex++] = targetBuffer[srcIndex++];
							}
						}
						break;
				}
			}
		} catch (Exception e) {
			if (targetIndex > targetBuffer.length) {
				targetIndex = targetBuffer.length;
			}
		}

		return targetIndex;
	}
}
",True,122,10,50,0,0,3,0,L4
35,org.geometerplus.fbreader.formats.xhtml.XHTMLTagParagraphWithControlAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagParagraphWithControlAction extends XHTMLTagAction {
	final byte myControl;

	XHTMLTagParagraphWithControlAction(byte control) {
		myControl = control;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		switch (myControl) {
			case FBTextKind.TITLE:
			case FBTextKind.H1:
			case FBTextKind.H2:
				if (modelReader.Model.BookTextModel.getParagraphsNumber() > 1) {
					modelReader.insertEndOfSectionParagraph();
				}
				modelReader.enterTitle();
				break;
		}
		modelReader.pushKind(myControl);
		modelReader.beginParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.endParagraph();
		modelReader.popKind();
		switch (myControl) {
			case FBTextKind.TITLE:
			case FBTextKind.H1:
			case FBTextKind.H2:
				modelReader.exitTitle();
				break;
		}
	}
}
/*
void XHTMLTagParagraphWithControlAction::doAtStart(XHTMLReader &reader, const char**) {
	if ((myControl == TITLE) && (bookReader(reader).model().bookTextModel()->paragraphsNumber() > 1)) {
		bookReader(reader).insertEndOfSectionParagraph();
	}
	bookReader(reader).pushKind(myControl);
	bookReader(reader).beginParagraph();
}
*/
",False,141,0,0,7,36,1,7,L4
36,org.geometerplus.fbreader.formats.xhtml.XHTMLTagAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public abstract class XHTMLTagAction {
	protected abstract void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes);
	protected abstract void doAtEnd(XHTMLReader reader);
};
",False,141,0,0,9,29,10,2,L4
37,org.geometerplus.fbreader.formats.xhtml.XHTMLTagItemAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagItemAction extends XHTMLTagAction {
	private final char[] BULLET = { '\u2022', '\240' };

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.endParagraph();
		// TODO: increase left indent
		modelReader.beginParagraph();
		// TODO: replace bullet sign by number inside OL tag
		modelReader.addData(BULLET);
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
	}
}
",False,141,0,0,8,34,1,4,L4
38,org.geometerplus.fbreader.formats.xhtml.XHTMLReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.filesystem.ZLArchiveEntryFile;
import org.geometerplus.zlibrary.core.constants.XMLNamespaces;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.util.MiscUtil;

public class XHTMLReader extends ZLXMLReaderAdapter {
	private static final HashMap<String,XHTMLTagAction> ourTagActions = new HashMap<String,XHTMLTagAction>();

	public static XHTMLTagAction addAction(String tag, XHTMLTagAction action) {
		XHTMLTagAction old = (XHTMLTagAction)ourTagActions.get(tag);
		ourTagActions.put(tag, action);
		return old;
	}

	public static void fillTagTable() {
		if (!ourTagActions.isEmpty()) {
			return;
		}

		//addAction(""html"", new XHTMLTagAction());
		addAction(""body"", new XHTMLTagBodyAction());
		//addAction(""title"", new XHTMLTagAction());
		//addAction(""meta"", new XHTMLTagAction());
		//addAction(""script"", new XHTMLTagAction());

		//addAction(""font"", new XHTMLTagAction());
		//addAction(""style"", new XHTMLTagAction());

		addAction(""p"", new XHTMLTagParagraphAction());
		addAction(""h1"", new XHTMLTagParagraphWithControlAction(FBTextKind.H1));
		addAction(""h2"", new XHTMLTagParagraphWithControlAction(FBTextKind.H2));
		addAction(""h3"", new XHTMLTagParagraphWithControlAction(FBTextKind.H3));
		addAction(""h4"", new XHTMLTagParagraphWithControlAction(FBTextKind.H4));
		addAction(""h5"", new XHTMLTagParagraphWithControlAction(FBTextKind.H5));
		addAction(""h6"", new XHTMLTagParagraphWithControlAction(FBTextKind.H6));

		//addAction(""ol"", new XHTMLTagAction());
		//addAction(""ul"", new XHTMLTagAction());
		//addAction(""dl"", new XHTMLTagAction());
		addAction(""li"", new XHTMLTagItemAction());

		addAction(""strong"", new XHTMLTagControlAction(FBTextKind.STRONG));
		addAction(""b"", new XHTMLTagControlAction(FBTextKind.BOLD));
		addAction(""em"", new XHTMLTagControlAction(FBTextKind.EMPHASIS));
		addAction(""i"", new XHTMLTagControlAction(FBTextKind.ITALIC));
		final XHTMLTagAction codeControlAction = new XHTMLTagControlAction(FBTextKind.CODE);
		addAction(""code"", codeControlAction);
		addAction(""tt"", codeControlAction);
		addAction(""kbd"", codeControlAction);
		addAction(""var"", codeControlAction);
		addAction(""samp"", codeControlAction);
		addAction(""cite"", new XHTMLTagControlAction(FBTextKind.CITE));
		addAction(""sub"", new XHTMLTagControlAction(FBTextKind.SUB));
		addAction(""sup"", new XHTMLTagControlAction(FBTextKind.SUP));
		addAction(""dd"", new XHTMLTagControlAction(FBTextKind.DEFINITION_DESCRIPTION));
		addAction(""dfn"", new XHTMLTagControlAction(FBTextKind.DEFINITION));
		addAction(""strike"", new XHTMLTagControlAction(FBTextKind.STRIKETHROUGH));

		addAction(""a"", new XHTMLTagHyperlinkAction());

		addAction(""img"", new XHTMLTagImageAction(null, ""src""));
		addAction(""image"", new XHTMLTagImageAction(XMLNamespaces.XLink, ""href""));
		addAction(""object"", new XHTMLTagImageAction(null, ""data""));

		//addAction(""area"", new XHTMLTagAction());
		//addAction(""map"", new XHTMLTagAction());

		//addAction(""base"", new XHTMLTagAction());
		//addAction(""blockquote"", new XHTMLTagAction());
		addAction(""br"", new XHTMLTagRestartParagraphAction());
		//addAction(""center"", new XHTMLTagAction());
		addAction(""div"", new XHTMLTagParagraphAction());
		addAction(""dt"", new XHTMLTagParagraphAction());
		//addAction(""head"", new XHTMLTagAction());
		//addAction(""hr"", new XHTMLTagAction());
		//addAction(""link"", new XHTMLTagAction());
		//addAction(""param"", new XHTMLTagAction());
		//addAction(""q"", new XHTMLTagAction());
		//addAction(""s"", new XHTMLTagAction());

		addAction(""pre"", new XHTMLTagPreAction());
		//addAction(""big"", new XHTMLTagAction());
		//addAction(""small"", new XHTMLTagAction());
		//addAction(""u"", new XHTMLTagAction());

		//addAction(""table"", new XHTMLTagAction());
		addAction(""td"", new XHTMLTagParagraphAction());
		addAction(""th"", new XHTMLTagParagraphAction());
		//addAction(""tr"", new XHTMLTagAction());
		//addAction(""caption"", new XHTMLTagAction());
		//addAction(""span"", new XHTMLTagAction());
	}

	private final BookReader myModelReader;
	String myPathPrefix;
	String myLocalPathPrefix;
	String myReferencePrefix;
	boolean myPreformatted;
	boolean myInsideBody;
	private final Map<String,Integer> myFileNumbers;

	public XHTMLReader(BookReader modelReader, Map<String,Integer> fileNumbers) {
		myModelReader = modelReader;
		myFileNumbers = fileNumbers;
	}

	final BookReader getModelReader() {
		return myModelReader;
	}

	public final String getFileAlias(String fileName) {
		fileName = MiscUtil.decodeHtmlReference(fileName);
		fileName = ZLArchiveEntryFile.normalizeEntryName(fileName);
		Integer num = myFileNumbers.get(fileName);
		if (num == null) {
			num = myFileNumbers.size();
			myFileNumbers.put(fileName, num);
		}
		return num.toString();
	}

	public boolean readFile(ZLFile file, String referencePrefix) {
		fillTagTable();

		myReferencePrefix = referencePrefix;

		myPathPrefix = MiscUtil.htmlDirectoryPrefix(file);
		myLocalPathPrefix = MiscUtil.archiveEntryName(myPathPrefix);

		myPreformatted = false;
		myInsideBody = false;

		return read(file);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		String id = attributes.getValue(""id"");
		if (id != null) {
			myModelReader.addHyperlinkLabel(myReferencePrefix + id);
		}

		XHTMLTagAction action = (XHTMLTagAction)ourTagActions.get(tag.toLowerCase());
		if (action != null) {
			action.doAtStart(this, attributes);
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		XHTMLTagAction action = (XHTMLTagAction)ourTagActions.get(tag.toLowerCase());
		if (action != null) {
			action.doAtEnd(this);
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int len) {
		if (myPreformatted) {
			final char first = data[start]; 
			if ((first == '\r') || (first == '\n')) {
				myModelReader.addControl(FBTextKind.CODE, false);
				myModelReader.endParagraph();
				myModelReader.beginParagraph();
				myModelReader.addControl(FBTextKind.CODE, true);
			}
			int spaceCounter = 0;
cycle:
			while (spaceCounter < len) {
				switch (data[start + spaceCounter]) {
					case 0x08:
					case 0x09:
					case 0x0A:
					case 0x0B:
					case 0x0C:
					case 0x0D:
					case ' ':
						break;
					default:
						break cycle;
				}
				++spaceCounter;
			}
			myModelReader.addFixedHSpace((short)spaceCounter);
			start += spaceCounter;
			len -= spaceCounter;
		}
		if (len > 0) {
			if (myInsideBody && !myModelReader.paragraphIsOpen()) {
				myModelReader.beginParagraph();
			}
			myModelReader.addData(data, start, len, false);
		}
	}

	private static ArrayList<String> ourExternalDTDs = new ArrayList<String>();

	public static List<String> xhtmlDTDs() {
		if (ourExternalDTDs.isEmpty()) {
			ourExternalDTDs.add(""formats/xhtml/xhtml-lat1.ent"");
			ourExternalDTDs.add(""formats/xhtml/xhtml-special.ent"");
			ourExternalDTDs.add(""formats/xhtml/xhtml-symbol.ent"");
		}
		return ourExternalDTDs;
	}

	@Override
	public List<String> externalDTDs() {
		return xhtmlDTDs();
	}

	@Override
	public boolean dontCacheAttributeValues() {
		return true;
	}

	@Override
	public boolean processNamespaces() {
		return true;
	}
}
",False,141,0,0,8,29,12,18,L4
39,org.geometerplus.fbreader.formats.xhtml.XHTMLTagImageAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.formats.util.MiscUtil;
import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagImageAction extends XHTMLTagAction {
	private final String myNamespace;
	private final String myNameAttribute;

	XHTMLTagImageAction(String namespace, String nameAttribute) {
		myNamespace = namespace;
		myNameAttribute = nameAttribute;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		String fileName = reader.getAttributeValue(xmlattributes, myNamespace, myNameAttribute);
		if (fileName != null) {
			fileName = MiscUtil.decodeHtmlReference(fileName);
			final ZLFile imageFile = ZLFile.createFileByPath(reader.myPathPrefix + fileName);
			if (imageFile != null) {
				final BookReader modelReader = reader.getModelReader();
				boolean flag = modelReader.paragraphIsOpen() && !modelReader.paragraphIsNonEmpty();
				if (flag) {
					modelReader.endParagraph();
				}
				final String imageName = imageFile.getLongName();
				modelReader.addImageReference(imageName, (short)0);
				modelReader.addImage(imageName, new ZLFileImage(MimeType.IMAGE_AUTO, imageFile));
				if (flag) {
					modelReader.beginParagraph();
				}
			}
		}
	}

	protected void doAtEnd(XHTMLReader reader) {
	}
}
",False,141,0,0,8,29,1,9,L4
40,org.geometerplus.fbreader.formats.xhtml.XHTMLTagHyperlinkAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.util.ZLArrayUtils;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagHyperlinkAction extends XHTMLTagAction {
	private byte[] myHyperlinkStack = new byte[10];
	private int myHyperlinkStackSize;

	private static boolean isReference(String text) {
		return
			text.startsWith(""fbreader-action://"") ||
			text.startsWith(""http://"") ||
			text.startsWith(""https://"") ||
			text.startsWith(""mailto:"") ||
			text.startsWith(""ftp://"");
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		final String href = xmlattributes.getValue(""href"");
		if (myHyperlinkStackSize == myHyperlinkStack.length) {
			myHyperlinkStack = ZLArrayUtils.createCopy(myHyperlinkStack, myHyperlinkStackSize, 2 * myHyperlinkStackSize);
		}
		if ((href != null) && (href.length() > 0)) {
			String link = href;
			final byte hyperlinkType;
			if (isReference(link)) {
				hyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
			} else {
				hyperlinkType = FBTextKind.INTERNAL_HYPERLINK;
				final int index = href.indexOf('#');
				if (index == 0) {
					link = reader.myReferencePrefix + href.substring(1);
				} else if (index > 0) {
					link = reader.getFileAlias(reader.myLocalPathPrefix + href.substring(0, index)) + href.substring(index);
				} else {
					link = reader.getFileAlias(reader.myLocalPathPrefix + href);
				}
			}
			myHyperlinkStack[myHyperlinkStackSize++] = hyperlinkType;
			modelReader.addHyperlinkControl(hyperlinkType, link);
		} else {
			myHyperlinkStack[myHyperlinkStackSize++] = FBTextKind.REGULAR;
		}
		final String name = xmlattributes.getValue(""name"");
		if (name != null) {
			modelReader.addHyperlinkLabel(reader.myReferencePrefix + name);
		}
	}

	protected void doAtEnd(XHTMLReader reader) {
		byte kind = myHyperlinkStack[--myHyperlinkStackSize];
		if (kind != FBTextKind.REGULAR) {
			reader.getModelReader().addControl(kind, false);
		}
	}
}
",False,141,0,0,8,34,1,6,L4
41,org.geometerplus.fbreader.formats.xhtml.XHTMLTagParagraphAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagParagraphAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.getModelReader().beginParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
	}
}
",False,141,0,0,8,34,1,4,L4
42,org.geometerplus.fbreader.formats.xhtml.XHTMLTagRestartParagraphAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagRestartParagraphAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.getModelReader().beginParagraph();
		reader.getModelReader().endParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
	}
}
",False,141,0,0,8,34,1,4,L4
43,org.geometerplus.fbreader.formats.xhtml.XHTMLTagPreAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagPreAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.myPreformatted = true;
		final BookReader modelReader = reader.getModelReader();
		modelReader.beginParagraph();
		modelReader.addControl(FBTextKind.CODE, true);
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.addControl(FBTextKind.CODE, false);
		modelReader.endParagraph();
		reader.myPreformatted = false;
	}
}
",False,141,0,0,8,34,1,5,L4
44,org.geometerplus.fbreader.formats.xhtml.XHTMLTagBodyAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagBodyAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.myInsideBody = true;
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
		reader.myInsideBody = false;
	}
}
",False,141,0,0,8,34,1,4,L4
45,org.geometerplus.fbreader.formats.xhtml.XHTMLTagControlAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagControlAction extends XHTMLTagAction {
	final byte myControl;

	XHTMLTagControlAction(byte control) {
		myControl = control;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.pushKind(myControl);
		modelReader.addControl(myControl, true);
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.addControl(myControl, false);
		modelReader.popKind();
	}
}
",False,141,0,0,8,34,1,4,L4
46,org.geometerplus.fbreader.formats.plucker.PluckerTextStream.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;

import org.geometerplus.fbreader.formats.pdb.PdbStream;
import org.geometerplus.fbreader.formats.pdb.PdbUtil;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class PluckerTextStream extends PdbStream {
	private short myCompressionVersion;
	private	byte[] myFullBuffer;
	private	int myRecordIndex;

	public PluckerTextStream(ZLFile file) throws IOException {
		super(file);
		myFullBuffer = null;
	}
	
	public int read() {
		return 0;
	}
	
	public boolean open() throws IOException {
		//if (!super.open()) {
		//	return false;
		//}

		myCompressionVersion = (short) PdbUtil.readShort(myBase);

		myBuffer = new byte[65536];
		myFullBuffer = new byte[65536];

		myRecordIndex = 0;

		return true;
	}
	
	public	void close() throws IOException {
		if (myFullBuffer != null) {
			myFullBuffer = null;
		}
		super.close();
	}

	protected boolean fillBuffer() {
		while (myBufferOffset == myBufferLength) {
			if (myRecordIndex + 1 > myHeader.Offsets.length - 1) {
				return false;
			}
			++myRecordIndex;
			int currentOffset = myHeader.Offsets[myRecordIndex];
			//if (currentOffset < myBase.offset()) {
			//	return false;
			//}
			//((PdbStream)myBase).seek(currentOffset, true);
			int nextOffset =
				(myRecordIndex + 1 < myHeader.Offsets.length) ?
						myHeader.Offsets[myRecordIndex + 1] : 0;//myBase.sizeOfOpened();
			if (nextOffset < currentOffset) {
				return false;
			}
			try {
				processRecord(nextOffset - currentOffset);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return true;
	}

	private void processRecord(int recordSize) throws IOException {
		myBase.skip(2);

		int paragraphs = PdbUtil.readShort(myBase);
		int size = PdbUtil.readShort(myBase);
		
		char type = (char)myBase.read(); 
		if (type > 1) { // this record is not text record
			return;
		}

		myBase.skip(1);

		final int[] pars = new int[paragraphs];
		for (int i = 0; i < paragraphs; ++i) {
			pars[i] = PdbUtil.readShort(myBase);
			myBase.skip(2);
		}

		boolean doProcess = false;
		if (type == 0) {
			doProcess = myBase.read(myFullBuffer, 0, size) == size;
		} else if (myCompressionVersion == 1) {
			//doProcess =
				//DocDecompressor().decompress(myBase, myFullBuffer, recordSize - 8 - 4 * paragraphs, size) == size;
		} else if (myCompressionVersion == 2) {
			myBase.skip(2);
			//doProcess =
				//ZLZDecompressor(recordSize - 10 - 4 * paragraphs).decompress(myBase, myFullBuffer, size) == size;
		}
		if (doProcess) {
			myBufferLength = 0;
			myBufferOffset = 0;

			int start = 0;
			int end = 0;

			for (int i = 0; i < paragraphs; ++i) {
				start = end;
				end = start + pars[i];
				if (end > myFullBuffer[size]) {
					break;
				}
				processTextParagraph(myFullBuffer.toString().toCharArray(), start, end);
			}
		}
	}
	
	private	void processTextParagraph(char[] data, int start, int end) {
		int textStart = start;
		boolean functionFlag = false;
		for (int ptr = start; ptr < end; ++ptr) {
			if (data[ptr] == 0) {
				functionFlag = true;
				if (ptr != textStart) {
					//memcpy(myBuffer + myBufferLength, textStart, ptr - textStart);
					myBufferLength += ptr - textStart;
				}
			} else if (functionFlag) {
				int paramCounter = (data[ptr]) % 8;
				if (end - ptr > paramCounter + 1) {
					ptr += paramCounter;
				} else {
					ptr = end - 1;
				}
				functionFlag = false;
				textStart = ptr + 1;
			}
		}
		if (end != textStart) {
			//memcpy(myBuffer + myBufferLength, textStart, end - textStart);
			myBufferLength += end - textStart;
		}
	}
}
",True,23,1,1,5,6,1,5,L7
47,org.geometerplus.fbreader.formats.plucker.PluckerPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.pdb.PdbPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class PluckerPlugin extends PdbPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {		
		return ""DataPlkr"".equals(fileType(file));
	}
	
	@Override
	public boolean readMetaInfo(Book book) {
		try {
			PluckerTextStream stream = new PluckerTextStream(book.File);
			if (stream.open()) {
				//detectEncodingAndLanguage(book, stream);
				stream.close();
			}
		} catch (IOException e) {
		}
		
		if (book.getEncoding().length() == 0) {
			return false;
		}

		return true;
	}
	
	@Override
	public boolean readModel(BookModel model)  {
		return new PluckerBookReader(model.Book.File, model, model.Book.getEncoding()).readDocument();
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		return null;
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return null;
	}
}
",True,147,0,0,7,34,0,7,L7
48,org.geometerplus.fbreader.formats.plucker.PluckerBookReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.util.*;
import java.util.zip.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.*;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.ZLInputStreamWithOffset;

import org.geometerplus.zlibrary.text.model.*;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.pdb.*;

public class PluckerBookReader extends BookReader {
	private final ZLFile myFile;
	private final int myFileSize;
	private ZLInputStreamWithOffset myStream;
	private	int myFont;
	private	char[] myCharBuffer;
	private	String myConvertedTextBuffer;
	private	boolean myParagraphStarted = false;
	private	boolean myBufferIsEmpty;
	//private	ZLTextForcedControlEntry myForcedEntry;
	private	final ArrayList/*<std::pair<FBTextKind,bool> >*/ myDelayedControls = new ArrayList();
	private	final ArrayList/*<std::string> */myDelayedHyperlinks = new ArrayList();
	private	short myCompressionVersion;
	private	char myBytesToSkip;

	private	final ArrayList/*<std::pair<int, int> >*/ myReferencedParagraphs = new ArrayList();
	private	final HashMap/*<int, std::vector<int> >*/ myParagraphMap = new HashMap(); /*<int, vector<pair<int, int>>>*/
	private	ArrayList/*<Integer, Integer>*/ myParagraphVector = new ArrayList();
	private	boolean myParagraphStored;
	
	public PluckerBookReader(ZLFile file, BookModel model, String encoding) {
		super(model);
		//myConverter = new EncodedTextReader(encoding).getConverter(); 
		myFile = file; 
		myFileSize = (int)file.size();
		myFont = FontType.FT_REGULAR;
		myCharBuffer = new char[65535];
		//myForcedEntry = null;
	}

	public boolean readDocument() {
		try {
			myStream = new ZLInputStreamWithOffset(myFile.getInputStream());
        
			PdbHeader header = new PdbHeader(myStream);
        
			setMainTextModel();
			myFont = FontType.FT_REGULAR;
        
			for (int index = 0; index < header.Offsets.length; ++index) {
				int currentOffset = myStream.offset();
				int pit = header.Offsets[index];
				if (currentOffset > pit) {
					break;
				}
				//myStream.seek(pit - currentOffset, false);
				myStream.skip(pit - currentOffset);
				
				if (myStream.offset() != pit) {
					break;
				}
				int recordSize = ((index != header.Offsets.length - 1) ? header.Offsets[index + 1] : myFileSize) - pit;
				readRecord(recordSize);
			}
			myStream.close();
		} catch (IOException e) {
			return false;
		}

		for (Iterator it = myReferencedParagraphs.iterator(); it.hasNext();) {
			Pair pair = (Pair)it.next();
			int first = (Integer)pair.myFirst;
			int second = (Integer)pair.mySecond;
			ArrayList/*<Integer>*/ list = (ArrayList)myParagraphMap.get(first);
			if (list != null) {
				for(int k = second; k < list.size(); ++k) {
					if (((Integer) ((Pair)list.get(k)).myFirst) != -1) {
						//addHyperlinkLabel(fromNumber(first) + '#' + fromNumber(second), (Integer)list.get(k));
						final Pair p = (Pair)list.get(k);
						//addHyperlinkLabel(fromNumber(first) + '#' + fromNumber(second), (Integer) p.mySecond, (Integer) p.myFirst);
						break;						
					}
				}
			}
		}
		myReferencedParagraphs.clear();
		myParagraphMap.clear();
		return true;
	}

	private class FontType {
			public static final int FT_REGULAR = 0;
			public static final int FT_H1 = 1;
			public static final int FT_H2 = 2;
			public static final int FT_H3 = 3;
			public static final int FT_H4 = 4;
			public static final int FT_H5 = 5;
			public static final int FT_H6 = 6;
			public static final int FT_BOLD = 7;
			public static final int FT_TT = 8;
			public static final int FT_SMALL = 9;
			public static final int FT_SUB = 10;
			public static final int FT_SUP = 11;
		};

	private	void readRecord(int recordSize) throws IOException {
		int uid = PdbUtil.readShort(myStream);
		if (uid == 1) {
			myCompressionVersion = (short) PdbUtil.readShort(myStream );
		} else {
			int paragraphs = PdbUtil.readShort(myStream);

			int size = PdbUtil.readShort(myStream);
            //TODO ??????  
			int type = myStream.read();

			int flags = myStream.read();

			switch (type) {
				case 0: // text (TODO: found sample file and test this code)
				case 1: // compressed text
				{
					ArrayList/*<Integer>*/ pars = new ArrayList();
					for (int i = 0; i < paragraphs; ++i) {
						int pSize = PdbUtil.readShort(myStream);
						pars.add(pSize);
						myStream.skip(2);
					}

					boolean doProcess = false;
					if (type == 0) {//?
						byte[] buf = new byte[size];
						doProcess = myStream.read(buf, 0, (int)size) == size;
						if (doProcess) {
							// TODO: use encoding!!!!
							// TODO: don't create any new objects!!!!
							myCharBuffer = new String(buf).toCharArray();
						}
					} else if (myCompressionVersion == 1) {
						byte[] buf = new byte[size];
						doProcess =
							DocDecompressor.decompress(myStream, buf, recordSize - 8 - 4 * paragraphs) == size;
						if (doProcess) {
							myCharBuffer = new String(buf).toCharArray();
						}
					} else if (myCompressionVersion == 2) {
						byte input [] = new byte[(int) (recordSize - 10 - 4 * paragraphs)];
						final int inputSize = myStream.read(input);
						Inflater decompressor = new Inflater();
						decompressor.setInput(input, 0, inputSize);
						byte output [] = new byte[size];
						try {
							doProcess = decompressor.inflate(output) == size;
							decompressor.end();
							myCharBuffer = new String(output, 0, size).toCharArray();
						} catch (DataFormatException e) {
							// TODO Auto-generated catch block
							//e.printStackTrace();
						}
						//doProcess =
							//ZLZDecompressor(recordSize - 10 - 4 * paragraphs).
								//decompress(myStream, myCharBuffer, size) == size;
					}
					if (doProcess) {
						addHyperlinkLabel(fromNumber(uid));
						myParagraphMap.put(uid, new ArrayList());
						myParagraphVector = (ArrayList)myParagraphMap.get(uid);
						processTextRecord(size, pars);
						if ((flags & 0x1) == 0) {
//							insertEndOfTextParagraph();
							//setNewTextModel();
						}
					}
					break;
				}
				case 2: // image
				case 3: // compressed image
				{
					ZLImage image = null;
					if (type == 2) {
						image = new PluckerFileImage(MimeType.IMAGE_PALM, myFile, myStream.offset(), recordSize - 8);
					} else if (myCompressionVersion == 1) {
						image = new DocCompressedFileImage(MimeType.IMAGE_PALM, myFile, myStream.offset(), recordSize - 8);
					} else if (myCompressionVersion == 2) {
						image = new ZCompressedFileImage(MimeType.IMAGE_PALM, myFile, myStream.offset() + 2, recordSize - 10);
					}
					if (image != null) {
						addImage(fromNumber(uid), image);
					}
					break;
				}
				case 9: // category record is ignored
					break;
				case 10:
					short typeCode = (short) PdbUtil.readShort(myStream);
					break;
				case 11: // style sheet record is ignored
					break;
				case 12: // font page record is ignored
					break;
				case 13: // TODO: process tables
				case 14: // TODO: process tables
					break;
				case 15: // multiimage
				{
					short columns = (short) PdbUtil.readShort(myStream);
					short rows = (short) PdbUtil.readShort(myStream);
					/*PluckerMultiImage image = new PluckerMultiImage(rows, columns, Model.getImageMap());
					for (int i = 0; i < size / 2 - 2; ++i) {
						short us = (short)myStream.read();
						PdbUtil.readShort(myStream, us);
						image.addId(fromNumber(us));
					}
					addImage(fromNumber(uid), image);
					*/break;
				}
				default:
					//std::cerr << ""type = "" << (int)type << ""\n"";
					break;
			}
		}	
	}
	
    private	void processTextRecord(int size, ArrayList/*<Integer>*/ pars) {
    	int start = 0;
    	int end = 0;

    	for (Iterator it = pars.iterator(); it.hasNext();) {
    		start = end;
    		end = start + (Integer)it.next();
    		if (end > size) {
    			return;
    		}
    		myParagraphStored = false;
    		processTextParagraph(myCharBuffer, start, end);
    		if (!myParagraphStored) {
    			myParagraphVector.add(new Pair(-1, -1));
    		}
    	}
    }
    
    private	void processTextParagraph(char[] data, int start, int end) {
    	changeFont(FontType.FT_REGULAR);
    	while (popKind()) {}

    	myParagraphStarted = false;
    	myBytesToSkip = 0;

    	int textStart = start;
    	boolean functionFlag = false;
    	for (int ptr = start; ptr < end; ++ptr) {
    		if (data[ptr] == 0) {
    			functionFlag = true;
    			if (ptr > textStart) {
    				safeBeginParagraph();
    	//			myConvertedTextBuffer = """";//.erase();
    				myConvertedTextBuffer = """";//myConverter.convert(data, textStart, ptr);
    				addData(myConvertedTextBuffer.toCharArray());
    				myBufferIsEmpty = false;
    			}
    		} else if (functionFlag) {
    			int paramCounter = (data[ptr]) % 8;
    			if (end - ptr > paramCounter) {
    				processTextFunction(data, ptr);
    				ptr += paramCounter;
    			} else {
    				ptr = end - 1;
    			}
    			functionFlag = false;
    			if (myBytesToSkip > 0) {
    				ptr += myBytesToSkip;
    				myBytesToSkip = 0;
    			}
    			textStart = ptr + 1;
    		} else {
    			if (data[ptr] == 0xA0) {
    				data[ptr] = 0x20;
    			}
    			if (!myParagraphStarted && (textStart == ptr) && (data[ptr] == ' ')) {
    				++textStart;
    			}
    		}
    	}
    	if (end > textStart) {
    		safeBeginParagraph();
    	//	myConvertedTextBuffer = """";//erase();
    		myConvertedTextBuffer = """";//myConverter.convert(data, textStart, end);
    		addData(myConvertedTextBuffer.toCharArray());
    		myBufferIsEmpty = false;
    	}
    	safeEndParagraph();
    	//if (myForcedEntry != null) {
    	//	myForcedEntry = null;
    	//}
    	myDelayedControls.clear();
    }
    
    private	void processTextFunction(char[] ptr, int cur) {
			switch (ptr[cur]) {
				case 0x08:
					safeAddControl(FBTextKind.INTERNAL_HYPERLINK, false);
					break;
				case 0x0A:
					safeAddHyperlinkControl(fromNumber(twoBytes(ptr, cur+ 1)));
					break;
				case 0x0C:
				{
					int sectionNum = twoBytes(ptr, cur + 1);
					int paragraphNum = twoBytes(ptr, cur + 3);
					safeAddHyperlinkControl(fromNumber(sectionNum) + '#' + fromNumber(paragraphNum));
					myReferencedParagraphs.add(new Pair(sectionNum, paragraphNum));
					break;
				}
				case 0x11:
					changeFont((ptr[cur + 1]));
					break;
				case 0x1A:
					safeBeginParagraph();
					addImageReference(fromNumber(twoBytes(ptr, cur + 1)), (short) 0);
					break;
				case 0x22:
					if (!myParagraphStarted) {
						//if (myForcedEntry == null) {
						//	myForcedEntry = new ZLTextForcedControlEntry();
						//}
						//myForcedEntry.setLeftIndent((short)ptr[cur + 1]);
						//myForcedEntry.setRightIndent((short)ptr[cur + 2]);
					}
					break;
				case 0x29:
					if (!myParagraphStarted) {
						//if (myForcedEntry == null) {
						//	myForcedEntry = new ZLTextForcedControlEntry();
						//}
						//switch (ptr[cur + 1]) {
						//	case 0: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_LEFT); break;
						//	case 1: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_RIGHT); break;
						//	case 2: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_CENTER); break;
						//	case 3: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_JUSTIFY); break;
						//}
					}
					break;
				case 0x33: // just break line instead of horizontal rule (TODO: draw horizontal rule?)
					safeEndParagraph();
					break;
				case 0x38:
					safeEndParagraph();
					break;
				case 0x40: 
					safeAddControl(FBTextKind.EMPHASIS, true);
					break;
				case 0x48:
					safeAddControl(FBTextKind.EMPHASIS, false);
					break;
				case 0x53: // color setting is ignored
					break;
				case 0x5C:
					addImageReference(fromNumber(twoBytes(ptr, cur + 3)), (short) 0);
					break;
				case 0x60: // underlined text is ignored
					break;
				case 0x68: // underlined text is ignored
					break;
				case 0x70: // strike-through text is ignored
					break;
				case 0x78: // strike-through text is ignored
					break;
				case 0x83: 
				{
					safeBeginParagraph();
					addData(new char[] { (char)twoBytes(ptr, cur + 2) });
					myBufferIsEmpty = false;
					myBytesToSkip = ptr[cur+1];
					break;
				}
				case 0x85: // TODO: process 4-byte unicode character
					break;
				case 0x8E: // custom font operations are ignored
				case 0x8C:
				case 0x8A:
				case 0x88:
					break;
				case 0x90: // TODO: add table processing
				case 0x92: // TODO: process table
				case 0x97: // TODO: process table
					break;
				default: // this should be impossible
					//std::cerr << ""Oops... function #"" << (int)(unsigned char)*ptr << ""\n"";
					break;
	}	
    }
    
    private	void setFont(int font, boolean start) {
			switch (font) {
				case FontType.FT_REGULAR:
					break;
				case FontType.FT_H1:
				case FontType.FT_H2:
				case FontType.FT_H3:
				case FontType.FT_H4:
				case FontType.FT_H5:
				case FontType.FT_H6:
					processHeader(font, start);
					break;
				case FontType.FT_BOLD:
					safeAddControl(FBTextKind.BOLD, start);
					break;
				case FontType.FT_TT:
					safeAddControl(FBTextKind.CODE, start);
					break;
				case FontType.FT_SMALL:
					break;
				case FontType.FT_SUB:
					safeAddControl(FBTextKind.SUB, start);
					break;
				case FontType.FT_SUP:
					safeAddControl(FBTextKind.SUP, start);
					break;
	    }
    }

    private	void changeFont(int font) {
    	if (myFont == font) {
    		return;
    	}
    	setFont(myFont, false);
    	myFont = font;
    	setFont(myFont, true);
    }

    private void safeAddControl(byte kind, boolean start) {
    	if (myParagraphStarted) {
    		addControl((Byte)kind, (Boolean)start);
    	} else {
    		myDelayedControls.add(new Pair(kind, start));
    	}
    }
    private void safeAddHyperlinkControl(String id) {
    	if (myParagraphStarted) {
    		addHyperlinkControl(FBTextKind.INTERNAL_HYPERLINK, id);
    	} else {
    		myDelayedHyperlinks.add(id);
    	}
    }
    
    private void safeBeginParagraph() {
    	if (!myParagraphStarted) {
    		myParagraphStarted = true;
    		myBufferIsEmpty = true;
    		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
    		if (!myParagraphStored) {
    			//final ArrayList models = Model.getBookTextModels();
    			//myParagraphVector.add(new Pair(((ZLTextPlainModel) models.get(models.size()-1)/*BookTextModel*/).getParagraphsNumber() - 1, models.size() - 1));
    			myParagraphStored = true;
    		}
    		for (Iterator it = myDelayedControls.iterator(); it.hasNext(); ) {
    			Pair pit = (Pair)it.next();
    			addControl((Byte)pit.myFirst, (Boolean)pit.mySecond);
    		}
    		//if (myForcedEntry != null) {
    		//	addControl(myForcedEntry);
    		//} else {
    			addControl(FBTextKind.REGULAR, true);
    		//}
    		for (Iterator it = myDelayedHyperlinks.iterator(); it.hasNext(); ) {
    			addHyperlinkControl(FBTextKind.INTERNAL_HYPERLINK, (String)it.next());
    		}
    		myDelayedHyperlinks.clear();
    	}
    }
    
    private void safeEndParagraph() {
    	if (myParagraphStarted) {
    		if (myBufferIsEmpty) {
    			final String SPACE = "" "";
    			addData(SPACE.toCharArray());
    		}
    		endParagraph();
    		myParagraphStarted = false;
    	}
    }

    private void processHeader(int font, boolean start) {
    	if (start) {
    		enterTitle();
    		int kind;
    		switch (font) {
    			case FontType.FT_H1:
    				kind = FBTextKind.H1;
    				break;
    			case FontType.FT_H2:
    				kind = FBTextKind.H2;
    				break;
    			case FontType.FT_H3:
    				kind = FBTextKind.H3;
    				break;
    			case FontType.FT_H4:
    				kind = FBTextKind.H4;
    				break;
    			case FontType.FT_H5:
    				kind = FBTextKind.H5;
    				break;
    			case FontType.FT_H6:
    			default:
    				kind = FBTextKind.H6;
    				break;
    		}
    		pushKind((byte)kind);
    	} else {
    		popKind();
    		exitTitle();
    	}
    }
	
	static private class Pair {
		public Object myFirst;
		public Object mySecond;
		Pair(Object first, Object second) {
			this.myFirst = first;
			this.mySecond = second;
		}
	}

	static private int twoBytes(char[] ptr, int offset) {
		return 256 * ptr[offset] + ptr[offset+1];
	}

	static String fromNumber(int num) {
		String str = """";
		str += num;
		//ZLStringUtil.appendNumber(str, num);
		return str;
	}
}
",True,146,1,1,7,33,1,14,L7
49,org.geometerplus.fbreader.formats.plucker.PluckerFileImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.SliceInputStream;

public class PluckerFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int mySize;

	public PluckerFileImage(MimeType mimeType, final ZLFile file, final int offset, final int size) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		mySize = size;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	@Override
	public InputStream inputStream() {
		try {
			return new SliceInputStream(myFile.getInputStream(), myOffset, mySize);
		} catch (IOException e) {
			return null;
		}
	}
}
",True,27,2,1,5,8,1,4,L7
50,org.geometerplus.fbreader.formats.plucker.DocCompressedFileImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.fbreader.formats.pdb.DocDecompressor;

public class DocCompressedFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int myCompressedSize;
	
	public DocCompressedFileImage(MimeType mimeType, final ZLFile file, final int offset, final int compressedSize) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		myCompressedSize = compressedSize;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	@Override
	public InputStream inputStream() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return null;
			}

			stream.skip(myOffset);
			final byte[] buffer = new byte[65535];
			final int size = DocDecompressor.decompress(stream, buffer, myCompressedSize);
			if (size > 0) {
				return new ByteArrayInputStream(buffer, 0, size);
			}
		} catch (IOException e) {
		}
		return null;
	}
}
",True,26,2,1,5,7,1,4,L7
51,org.geometerplus.fbreader.formats.plucker.ZCompressedFileImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.*;
import java.util.ArrayList;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.util.MimeType;

public class ZCompressedFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int myCompressedSize;
	
	public ZCompressedFileImage(MimeType mimeType, final ZLFile file, final int offset, final int compressedSize) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		myCompressedSize = compressedSize;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	@Override
	public InputStream inputStream() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return null;
			}
			
			final ArrayList<byte[]> data = new ArrayList<byte[]>();
			byte[] buffer;
			int sizeOfBufferData;

			stream.skip(myOffset);
			byte [] targetBuffer = new byte[myCompressedSize];
			stream.read(targetBuffer, 0, myCompressedSize);
			Inflater decompressor = new Inflater();
			decompressor.setInput(targetBuffer, 0, myCompressedSize);
			do {
				buffer = new byte[4096];
				sizeOfBufferData = decompressor.inflate(buffer);
				data.add(buffer);
			} while (sizeOfBufferData == 4096);
			decompressor.end();
			final int dataSizeMinus1 = data.size() - 1;
			buffer = new byte[dataSizeMinus1 * 4096 + sizeOfBufferData];
			for (int i = 0; i < dataSizeMinus1; ++i) {
				System.arraycopy(data.get(i), 0, buffer, i * 4096, 4096);
			}
			System.arraycopy(data.get(dataSizeMinus1), 0, buffer, dataSizeMinus1 * 4096, sizeOfBufferData);
			return new ByteArrayInputStream(buffer);
		} catch (IOException e) {
			return null;
		} catch (DataFormatException e) {
			return null;
		}
	}
}
",True,25,2,1,5,7,1,3,L7
52,org.geometerplus.fbreader.library.SeriesInfo.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class SeriesInfo {
	public final String Name;
	public final float Index;

	public SeriesInfo(String name, float index) {
		Name = name;
		Index = index;
	}
}
",False,119,6,49,0,0,7,0,L4
53,org.geometerplus.fbreader.library.BookInSeriesTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.fbreader.tree.FBTree;

public final class BookInSeriesTree extends BookTree {
	BookInSeriesTree(LibraryTree parent, Book book) {
		super(parent, book, false);
	}

	@Override
	public int compareTo(FBTree tree) {
		if (tree instanceof BookInSeriesTree) {
			final float difference =
				Book.getSeriesInfo().Index - ((BookTree)tree).Book.getSeriesInfo().Index;
			if (difference != 0) {
				return difference > 0 ? 1 : -1;
			}
		}
		return super.compareTo(tree);
	}
}
",False,151,0,0,7,47,1,5,L5
54,org.geometerplus.fbreader.library.BooksDatabase.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.zlibrary.text.view.ZLTextPosition;

public abstract class BooksDatabase {
	private static BooksDatabase ourInstance;

	public static BooksDatabase Instance() {
		return ourInstance;
	}

	protected BooksDatabase() {
		ourInstance = this;
	}

	protected Book createBook(long id, long fileId, String title, String encoding, String language) {
		final FileInfoSet infos = new FileInfoSet(fileId);
		return createBook(id, infos.getFile(fileId), title, encoding, language);
	}
	protected Book createBook(long id, ZLFile file, String title, String encoding, String language) {
		return (file != null) ? new Book(id, file, title, encoding, language) : null;
	}
	protected void addAuthor(Book book, Author author) {
		book.addAuthorWithNoCheck(author);
	}
	protected void addTag(Book book, Tag tag) {
		book.addTagWithNoCheck(tag);
	}
	protected void setSeriesInfo(Book book, String series, float index) {
		book.setSeriesInfoWithNoCheck(series, index);
	}

	protected abstract void executeAsATransaction(Runnable actions);

	// returns map fileId -> book
	protected abstract Map<Long,Book> loadBooks(FileInfoSet infos);
	protected abstract Book loadBook(long bookId);
	protected abstract void reloadBook(Book book);
	protected abstract Book loadBookByFile(long fileId, ZLFile file);

	protected abstract List<Author> loadAuthors(long bookId);
	protected abstract List<Tag> loadTags(long bookId);
	protected abstract SeriesInfo loadSeriesInfo(long bookId);
	protected abstract void updateBookInfo(long bookId, long fileId, String encoding, String language, String title);
	protected abstract long insertBookInfo(ZLFile file, String encoding, String language, String title);
	protected abstract void deleteAllBookAuthors(long bookId);
	protected abstract void saveBookAuthorInfo(long bookId, long index, Author author);
	protected abstract void deleteAllBookTags(long bookId);
	protected abstract void saveBookTagInfo(long bookId, Tag tag);
	protected abstract void saveBookSeriesInfo(long bookId, SeriesInfo seriesInfo);

	protected FileInfo createFileInfo(long id, String name, FileInfo parent) {
		return new FileInfo(name, parent, id);
	}

	protected abstract Collection<FileInfo> loadFileInfos();
	protected abstract Collection<FileInfo> loadFileInfos(ZLFile file);
	protected abstract Collection<FileInfo> loadFileInfos(long fileId);
	protected abstract void removeFileInfo(long fileId);
	protected abstract void saveFileInfo(FileInfo fileInfo);

	protected abstract List<Long> loadRecentBookIds();
	protected abstract void saveRecentBookIds(final List<Long> ids);

	protected abstract List<Long> loadFavoritesIds();
	protected abstract void addToFavorites(long bookId);
	protected abstract void removeFromFavorites(long bookId);

	protected Bookmark createBookmark(long id, long bookId, String bookTitle, String text, Date creationDate, Date modificationDate, Date accessDate, int accessCounter, String modelId, int paragraphIndex, int wordIndex, int charIndex, boolean isVisible) {
		return new Bookmark(id, bookId, bookTitle, text, creationDate, modificationDate, accessDate, accessCounter, modelId, paragraphIndex, wordIndex, charIndex, isVisible);
	}

	protected abstract List<Bookmark> loadBookmarks(long bookId, boolean isVisible);
	protected abstract List<Bookmark> loadAllVisibleBookmarks();
	protected abstract long saveBookmark(Bookmark bookmark);
	protected abstract void deleteBookmark(Bookmark bookmark);

	protected abstract ZLTextPosition getStoredPosition(long bookId);
	protected abstract void storePosition(long bookId, ZLTextPosition position);

	protected abstract boolean insertIntoBookList(long bookId);
	protected abstract boolean deleteFromBookList(long bookId);
	protected abstract boolean checkBookList(long bookId);

	protected abstract Collection<String> loadVisitedHyperlinks(long bookId);
	protected abstract void addVisitedHyperlink(long bookId, String hyperlinkId);
}
",False,223,5,32,7,35,10,9,L4
55,org.geometerplus.fbreader.library.Book.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.text.view.ZLTextPosition;

import org.geometerplus.fbreader.formats.*;

import org.geometerplus.fbreader.Paths;

public class Book {
	public static Book getById(long bookId) {
		final Book book = BooksDatabase.Instance().loadBook(bookId);
		if (book == null) {
			return null;
		}
		book.loadLists();

		final ZLFile bookFile = book.File;
		final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
		if (physicalFile == null) {
			return book;
		}
		if (!physicalFile.exists()) {
			return null;
		}

		FileInfoSet fileInfos = new FileInfoSet(physicalFile);
		if (fileInfos.check(physicalFile, physicalFile != bookFile)) {
			return book;
		}
		fileInfos.save();

		return book.readMetaInfo() ? book : null;
	}

	public static Book getByFile(ZLFile bookFile) {
		if (bookFile == null) {
			return null;
		}

		final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
		if (physicalFile != null && !physicalFile.exists()) {
			return null;
		}

		final FileInfoSet fileInfos = new FileInfoSet(bookFile);

		Book book = BooksDatabase.Instance().loadBookByFile(fileInfos.getId(bookFile), bookFile);
		if (book != null) {
			book.loadLists();
		}

		if (book != null && fileInfos.check(physicalFile, physicalFile != bookFile)) {
			return book;
		}
		fileInfos.save();

		if (book == null) {
			book = new Book(bookFile);
		}
		if (book.readMetaInfo()) {
			book.save();
			return book;
		}
		return null;
	}

	public final ZLFile File;

	private long myId;

	private String myEncoding;
	private String myLanguage;
	private String myTitle;
	private List<Author> myAuthors;
	private List<Tag> myTags;
	private SeriesInfo mySeriesInfo;

	private boolean myIsSaved;

	Book(long id, ZLFile file, String title, String encoding, String language) {
		myId = id;
		File = file;
		myTitle = title;
		myEncoding = encoding;
		myLanguage = language;
		myIsSaved = true;
	}

	Book(ZLFile file) {
		myId = -1;
		File = file;
	}

	public void reloadInfoFromFile() {
		if (readMetaInfo()) {
			save();
		}
	}

	public void reloadInfoFromDatabase() {
		final BooksDatabase database = BooksDatabase.Instance();
		database.reloadBook(this);
		myAuthors = database.loadAuthors(myId);
		myTags = database.loadTags(myId);
		mySeriesInfo = database.loadSeriesInfo(myId);
		myIsSaved = true;
	}

	boolean readMetaInfo() {
		final FormatPlugin plugin = PluginCollection.Instance().getPlugin(File);
		if ((plugin == null) || !plugin.readMetaInfo(this)) {
			return false;
		}
		if ((myTitle == null) || (myTitle.length() == 0)) {
			final String fileName = File.getShortName();
			final int index = fileName.lastIndexOf('.');
			setTitle(index > 0 ? fileName.substring(0, index) : fileName);
		}
		final String demoPathPrefix = Paths.BooksDirectoryOption().getValue() + java.io.File.separator + ""Demos"" + java.io.File.separator;
		if (File.getPath().startsWith(demoPathPrefix)) {
			final String demoTag = ZLResource.resource(""library"").getResource(""demo"").getValue();
			setTitle(getTitle() + "" ("" + demoTag + "")"");
			addTag(demoTag);
		}
		return true;
	}

	private void loadLists() {
		final BooksDatabase database = BooksDatabase.Instance();
		myAuthors = database.loadAuthors(myId);
		myTags = database.loadTags(myId);
		mySeriesInfo = database.loadSeriesInfo(myId);
		myIsSaved = true;
	}

	public List<Author> authors() {
		return (myAuthors != null) ? Collections.unmodifiableList(myAuthors) : Collections.<Author>emptyList();
	}

	void addAuthorWithNoCheck(Author author) {
		if (myAuthors == null) {
			myAuthors = new ArrayList<Author>();
		}
		myAuthors.add(author);
	}

	private void addAuthor(Author author) {
		if (author == null) {
			return;
		}
		if (myAuthors == null) {
			myAuthors = new ArrayList<Author>();
			myAuthors.add(author);
			myIsSaved = false;
		} else if (!myAuthors.contains(author)) {
			myAuthors.add(author);
			myIsSaved = false;
		}
	}

	public void addAuthor(String name) {
		addAuthor(name, """");
	}

	public void addAuthor(String name, String sortKey) {
		String strippedName = name;
		strippedName.trim();
		if (strippedName.length() == 0) {
			return;
		}

		String strippedKey = sortKey;
		strippedKey.trim();
		if (strippedKey.length() == 0) {
			int index = strippedName.lastIndexOf(' ');
			if (index == -1) {
				strippedKey = strippedName;
			} else {
				strippedKey = strippedName.substring(index + 1);
				while ((index >= 0) && (strippedName.charAt(index) == ' ')) {
					--index;
				}
				strippedName = strippedName.substring(0, index + 1) + ' ' + strippedKey;
			}
		}

		addAuthor(new Author(strippedName, strippedKey));
	}

	public long getId() {
		return myId;
	}

	public String getTitle() {
		return myTitle;
	}

	public void setTitle(String title) {
		if (!ZLMiscUtil.equals(myTitle, title)) {
			myTitle = title;
			myIsSaved = false;
		}
	}

	public SeriesInfo getSeriesInfo() {
		return mySeriesInfo;
	}

	void setSeriesInfoWithNoCheck(String name, float index) {
		mySeriesInfo = new SeriesInfo(name, index);
	}

	public void setSeriesInfo(String name, float index) {
		if (mySeriesInfo == null) {
			if (name != null) {
				mySeriesInfo = new SeriesInfo(name, index);
				myIsSaved = false;
			}
		} else if (name == null) {
			mySeriesInfo = null;
			myIsSaved = false;
		} else if (!name.equals(mySeriesInfo.Name) || mySeriesInfo.Index != index) {
			mySeriesInfo = new SeriesInfo(name, index);
			myIsSaved = false;
		}
	}

	public String getLanguage() {
		return myLanguage;
	}

	public void setLanguage(String language) {
		if (!ZLMiscUtil.equals(myLanguage, language)) {
			myLanguage = language;
			myIsSaved = false;
		}
	}

	public String getEncoding() {
		return myEncoding;
	}

	public void setEncoding(String encoding) {
		if (!ZLMiscUtil.equals(myEncoding, encoding)) {
			myEncoding = encoding;
			myIsSaved = false;
		}
	}

	public List<Tag> tags() {
		return (myTags != null) ? Collections.unmodifiableList(myTags) : Collections.<Tag>emptyList();
	}

	void addTagWithNoCheck(Tag tag) {
		if (myTags == null) {
			myTags = new ArrayList<Tag>();
		}
		myTags.add(tag);
	}

	public void addTag(Tag tag) {
		if (tag != null) {
			if (myTags == null) {
				myTags = new ArrayList<Tag>();
			}
			if (!myTags.contains(tag)) {
				myTags.add(tag);
				myIsSaved = false;
			}
		}
	}

	public void addTag(String tagName) {
		addTag(Tag.getTag(null, tagName));
	}

	boolean matches(String pattern) {
		if ((myTitle != null) && ZLMiscUtil.matchesIgnoreCase(myTitle, pattern)) {
			return true;
		}
		if ((mySeriesInfo != null) && ZLMiscUtil.matchesIgnoreCase(mySeriesInfo.Name, pattern)) {
			return true;
		}
		if (myAuthors != null) {
			for (Author author : myAuthors) {
				if (ZLMiscUtil.matchesIgnoreCase(author.DisplayName, pattern)) {
					return true;
				}
			}
		}
		if (myTags != null) {
			for (Tag tag : myTags) {
				if (ZLMiscUtil.matchesIgnoreCase(tag.Name, pattern)) {
					return true;
				}
			}
		}
		return false;
	}

	public boolean save() {
		if (myIsSaved) {
			return false;
		}
		final BooksDatabase database = BooksDatabase.Instance();
		database.executeAsATransaction(new Runnable() {
			public void run() {
				if (myId >= 0) {
					final FileInfoSet fileInfos = new FileInfoSet(File);
					database.updateBookInfo(myId, fileInfos.getId(File), myEncoding, myLanguage, myTitle);
				} else {
					myId = database.insertBookInfo(File, myEncoding, myLanguage, myTitle);
					storeAllVisitedHyperinks();
				}

				long index = 0;
				database.deleteAllBookAuthors(myId);
				for (Author author : authors()) {
					database.saveBookAuthorInfo(myId, index++, author);
				}
				database.deleteAllBookTags(myId);
				for (Tag tag : tags()) {
					database.saveBookTagInfo(myId, tag);
				}
				database.saveBookSeriesInfo(myId, mySeriesInfo);
			}
		});

		myIsSaved = true;
		return true;
	}

	public ZLTextPosition getStoredPosition() {
		return BooksDatabase.Instance().getStoredPosition(myId);
	}

	public void storePosition(ZLTextPosition position) {
		if (myId != -1) {
			BooksDatabase.Instance().storePosition(myId, position);
		}
	}

	private Set<String> myVisitedHyperlinks;
	private void initHyperlinkSet() {
		if (myVisitedHyperlinks == null) {
			myVisitedHyperlinks = new TreeSet<String>();
			if (myId != -1) {
				myVisitedHyperlinks.addAll(BooksDatabase.Instance().loadVisitedHyperlinks(myId));
			}
		}
	}

	public boolean isHyperlinkVisited(String linkId) {
		initHyperlinkSet();
		return myVisitedHyperlinks.contains(linkId);
	}

	public void markHyperlinkAsVisited(String linkId) {
		initHyperlinkSet();
		if (!myVisitedHyperlinks.contains(linkId)) {
			myVisitedHyperlinks.add(linkId);
			if (myId != -1) {
				BooksDatabase.Instance().addVisitedHyperlink(myId, linkId);
			}
		}
	}

	private void storeAllVisitedHyperinks() {
		if (myId != -1 && myVisitedHyperlinks != null) {
			for (String linkId : myVisitedHyperlinks) {
				BooksDatabase.Instance().addVisitedHyperlink(myId, linkId);
			}
		}
	}

	public void insertIntoBookList() {
		if (myId != -1) {
			BooksDatabase.Instance().insertIntoBookList(myId);
		}
	}

	@Override
	public int hashCode() {
		return (int)myId;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof Book)) {
			return false;
		}
		return myId == ((Book)o).myId;
	}
}
",True,226,5,43,6,47,36,14,L4
56,org.geometerplus.fbreader.library.Bookmark.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.text.view.*;

public final class Bookmark extends ZLTextFixedPosition {
	public final static int CREATION = 0;
	public final static int MODIFICATION = 1;
	public final static int ACCESS = 2;
	public final static int LATEST = 3;

	public static List<Bookmark> bookmarks() {
		return BooksDatabase.Instance().loadAllVisibleBookmarks();
	}

	public static List<Bookmark> invisibleBookmarks(Book book) {
		final List<Bookmark> list = BooksDatabase.Instance().loadBookmarks(book.getId(), false);
		Collections.sort(list, new ByTimeComparator());
		return list;
	}

	private long myId;
	private final long myBookId;
	private final String myBookTitle;
	private String myText;
	private final Date myCreationDate;
	private Date myModificationDate;
	private Date myAccessDate;
	private int myAccessCount;
	private Date myLatestDate;

	public final String ModelId;
	public final boolean IsVisible;

	private boolean myIsChanged;

	Bookmark(long id, long bookId, String bookTitle, String text, Date creationDate, Date modificationDate, Date accessDate, int accessCount, String modelId, int paragraphIndex, int elementIndex, int charIndex, boolean isVisible) {
		super(paragraphIndex, elementIndex, charIndex);

		myId = id;
		myBookId = bookId;
		myBookTitle = bookTitle;
		myText = text;
		myCreationDate = creationDate;
		myModificationDate = modificationDate;
		myLatestDate = (modificationDate != null) ? modificationDate : creationDate;
		if (accessDate != null) {
			myAccessDate = accessDate;
			if (myLatestDate.compareTo(accessDate) < 0) {
				myLatestDate = accessDate;
			}
		}
		myAccessCount = accessCount;
		ModelId = modelId;
		IsVisible = isVisible;
		myIsChanged = false;
	}

	public Bookmark(Book book, String modelId, ZLTextWordCursor cursor, int maxLength, boolean isVisible) {
		this(book, modelId, cursor, createBookmarkText(cursor, maxLength), isVisible);
	}

	public Bookmark(Book book, String modelId, ZLTextPosition position, String text, boolean isVisible) {
		super(position);

		myId = -1;
		myBookId = book.getId();
		myBookTitle = book.getTitle();
		myText = text;
		myCreationDate = new Date();
		ModelId = modelId;
		IsVisible = isVisible;
		myIsChanged = true;
	}

	public long getId() {
		return myId;
	}

	public long getBookId() {
		return myBookId;
	}

	public String getText() {
		return myText;
	}

	public String getBookTitle() {
		return myBookTitle;
	}

	public Date getTime(int timeStamp) {
		switch (timeStamp) {
			default:
			case CREATION:
				return myCreationDate;
			case MODIFICATION:
				return myModificationDate;
			case ACCESS:
				return myAccessDate;
			case LATEST:
				return myLatestDate;
		}
	}

	public int getAccessCount() {
		return myAccessCount;
	}

	public void setText(String text) {
		if (!text.equals(myText)) {
			myText = text;
			myModificationDate = new Date();
			myLatestDate = myModificationDate;
			myIsChanged = true;
		}
	}

	public void onOpen() {
		myAccessDate = new Date();
		++myAccessCount;
		myLatestDate = myAccessDate;
		myIsChanged = true;
	}

	public void save() {
		if (myIsChanged) {
			myId = BooksDatabase.Instance().saveBookmark(this);
			myIsChanged = false;
		}
	}

	public void delete() {
		if (myId != -1) {
			BooksDatabase.Instance().deleteBookmark(this);
		}
	}

	public static class ByTimeComparator implements Comparator<Bookmark> {
		public int compare(Bookmark bm0, Bookmark bm1) {
			return bm1.getTime(LATEST).compareTo(bm0.getTime(LATEST));
		}
	}

	private static String createBookmarkText(ZLTextWordCursor cursor, int maxWords) {
		cursor = new ZLTextWordCursor(cursor);

		final StringBuilder builder = new StringBuilder();
		final StringBuilder sentenceBuilder = new StringBuilder();
		final StringBuilder phraseBuilder = new StringBuilder();

		int wordCounter = 0;
		int sentenceCounter = 0;
		int storedWordCounter = 0;
		boolean lineIsNonEmpty = false;
		boolean appendLineBreak = false;
mainLoop:
		while (wordCounter < maxWords && sentenceCounter < 3) {
			while (cursor.isEndOfParagraph()) {
				if (!cursor.nextParagraph()) {
					break mainLoop;
				}
				if ((builder.length() > 0) && cursor.getParagraphCursor().isEndOfSection()) {
					break mainLoop;
				}
				if (phraseBuilder.length() > 0) {
					sentenceBuilder.append(phraseBuilder);
					phraseBuilder.delete(0, phraseBuilder.length());
				}
				if (sentenceBuilder.length() > 0) {
					if (appendLineBreak) {
						builder.append(""\n"");
					}
					builder.append(sentenceBuilder);
					sentenceBuilder.delete(0, sentenceBuilder.length());
					++sentenceCounter;
					storedWordCounter = wordCounter;
				}
				lineIsNonEmpty = false;
				if (builder.length() > 0) {
					appendLineBreak = true;
				}
			}
			final ZLTextElement element = cursor.getElement();
			if (element instanceof ZLTextWord) {
				final ZLTextWord word = (ZLTextWord)element;
				if (lineIsNonEmpty) {
					phraseBuilder.append("" "");
				}
				phraseBuilder.append(word.Data, word.Offset, word.Length);
				++wordCounter;
				lineIsNonEmpty = true;
				switch (word.Data[word.Offset + word.Length - 1]) {
					case ',':
					case ':':
					case ';':
					case ')':
						sentenceBuilder.append(phraseBuilder);
						phraseBuilder.delete(0, phraseBuilder.length());
						break;
					case '.':
					case '!':
					case '?':
						++sentenceCounter;
						if (appendLineBreak) {
							builder.append(""\n"");
							appendLineBreak = false;
						}
						sentenceBuilder.append(phraseBuilder);
						phraseBuilder.delete(0, phraseBuilder.length());
						builder.append(sentenceBuilder);
						sentenceBuilder.delete(0, sentenceBuilder.length());
						storedWordCounter = wordCounter;
						break;
				}
			}
			cursor.nextWord();
		}
		if (storedWordCounter < 4) {
			if (sentenceBuilder.length() == 0) {
				sentenceBuilder.append(phraseBuilder);
			}
			if (appendLineBreak) {
				builder.append(""\n"");
			}
			builder.append(sentenceBuilder);
		}
		return builder.toString();
	}
}
",False,214,6,43,7,33,5,8,L4
57,org.geometerplus.fbreader.library.FileInfo.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.tree.ZLTree;

public final class FileInfo extends ZLTree<FileInfo> {
	public final String Name;
	public long Id;
	public long FileSize = -1;

	FileInfo(String name, FileInfo parent) {
		this(name, parent, -1);
	}

	FileInfo(String name, FileInfo parent, long id) {
		super(parent);
		Name = name;
		Id = id;
	}
}
",False,120,6,51,1,1,3,1,L4
58,org.geometerplus.fbreader.library.Author.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class Author {
	public final String DisplayName;
	public final String SortKey;

	public Author(String displayName, String sortKey) {
		DisplayName = displayName;
		SortKey = sortKey;
	}
		
	public static int hashCode(Author author) {
		return author == null ? 0 : author.hashCode();
	}

	@Override
	public boolean equals(Object o) {
		if (o == this) {
			return true;
		}
		if (!(o instanceof Author)) {
			return false;
		}
		Author a = (Author)o;
		return SortKey.equals(a.SortKey) && DisplayName.equals(a.DisplayName);
	}

	@Override
	public int hashCode() {
		return SortKey.hashCode() + DisplayName.hashCode();
	}
}
",False,119,6,45,0,0,8,0,L4
59,org.geometerplus.fbreader.library.TagTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.resources.ZLResource;

public final class TagTree extends LibraryTree {
	public final Tag Tag;

	TagTree(LibraryTree parent, Tag tag) {
		super(parent);
		Tag = tag;
	}

	@Override
	public String getName() {
		return
			(Tag != null) ?
				Tag.Name :
				ZLResource.resource(""library"").getResource(""booksWithNoTags"").getValue();
	}

	protected String getSortKey() {
		return (Tag != null) ? Tag.Name : null;
	}
}
",False,205,8,27,7,46,3,3,L5
60,org.geometerplus.fbreader.library.BookTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.image.ZLImage;

public class BookTree extends LibraryTree {
	public final Book Book;
	private final boolean myShowAuthors;

	BookTree(LibraryTree parent, Book book, boolean showAuthors) {
		super(parent);
		Book = book;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return Book.getTitle();
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors) {
			return super.getSummary();
		}
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (Author author : Book.authors()) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(author.DisplayName);
			if (count == 5) {
				break;
			}
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		return Library.getCover(Book.File);
	}
}
",False,205,8,27,7,45,5,6,L5
61,org.geometerplus.fbreader.library.RootTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

final class RootTree extends LibraryTree {
	public String getName() {
		return null;
	}
}
",False,151,0,0,8,47,1,1,L5
62,org.geometerplus.fbreader.library.TitleTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class TitleTree extends LibraryTree {
	public final String Title;

	TitleTree(LibraryTree parent, String title) {
		super(parent);
		Title = title;
	}

	@Override
	public String getName() {
		return Title;
	}
}
",False,205,8,27,8,47,3,1,L5
63,org.geometerplus.fbreader.library.FileInfoSet.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.filesystem.*;

public final class FileInfoSet {
	private static final class Pair {
		private final String myName;
		private final FileInfo myParent;

		Pair(String name, FileInfo parent) {
			myName = name;
			myParent = parent;
		}

		@Override
		public int hashCode() {
			return (myParent == null) ? myName.hashCode() : myParent.hashCode() + myName.hashCode();
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof Pair)) {
				return false;
			}
			Pair p = (Pair)o;
			return (myName.equals(p.myName)) && ZLMiscUtil.equals(myParent, p.myParent);
		}
	}

	private final HashMap<ZLFile,FileInfo> myInfosByFile = new HashMap<ZLFile,FileInfo>();
	private final HashMap<FileInfo,ZLFile> myFilesByInfo = new HashMap<FileInfo,ZLFile>();
	private final HashMap<Pair,FileInfo> myInfosByPair = new HashMap<Pair,FileInfo>();
	private final HashMap<Long,FileInfo> myInfosById = new HashMap<Long,FileInfo>();

	private final LinkedHashSet<FileInfo> myInfosToSave = new LinkedHashSet<FileInfo>();
	private final LinkedHashSet<FileInfo> myInfosToRemove = new LinkedHashSet<FileInfo>();

	public FileInfoSet() {
		load(BooksDatabase.Instance().loadFileInfos());
	}

	public FileInfoSet(ZLFile file) {
		load(BooksDatabase.Instance().loadFileInfos(file));
	}

	FileInfoSet(long fileId) {
		load(BooksDatabase.Instance().loadFileInfos(fileId));
	}

	private void load(Collection<FileInfo> infos) {
		for (FileInfo info : infos) {
			myInfosByPair.put(new Pair(info.Name, info.Parent), info);
			myInfosById.put(info.Id, info);
		}
	}

	public void save() {
		final BooksDatabase database = BooksDatabase.Instance();
		database.executeAsATransaction(new Runnable() {
			public void run() {
				for (FileInfo info : myInfosToRemove) {
					database.removeFileInfo(info.Id);
					myInfosByPair.remove(new Pair(info.Name, info.Parent));
				}
				myInfosToRemove.clear();
				for (FileInfo info : myInfosToSave) {
					database.saveFileInfo(info);
				}
				myInfosToSave.clear();
			}
		});
	}

	public boolean check(ZLPhysicalFile file, boolean processChildren) {
		if (file == null) {
			return true;
		}
		final long fileSize = file.size();
		FileInfo info = get(file);
		if (info.FileSize == fileSize) {
			return true;
		} else {
			info.FileSize = fileSize;
			if (processChildren) {
				removeChildren(info);
				myInfosToSave.add(info);
				addChildren(file);
			} else {
				myInfosToSave.add(info);
			}
			return false;
		}
	}

	public List<ZLFile> archiveEntries(ZLFile file) {
		final FileInfo info = get(file);
		if (!info.hasChildren()) {
			return Collections.emptyList();
		}
		final LinkedList<ZLFile> entries = new LinkedList<ZLFile>();
		for (FileInfo child : info.subTrees()) {
			if (!myInfosToRemove.contains(child)) {
				entries.add(ZLArchiveEntryFile.createArchiveEntryFile(file, child.Name));
			}
		}
		return entries;
	}

	private FileInfo get(String name, FileInfo parent) {
		final Pair pair = new Pair(name, parent);
		FileInfo info = myInfosByPair.get(pair);
		if (info == null) {
			info = new FileInfo(name, parent);
			myInfosByPair.put(pair, info);
			myInfosToSave.add(info);
		}
		return info;
	}


	private FileInfo get(ZLFile file) {
		if (file == null) {
			return null;
		}
		FileInfo info = myInfosByFile.get(file);
		if (info == null) {
			info = get(file.getLongName(), get(file.getParent()));
			myInfosByFile.put(file, info);
		}
		return info;
	}

	public long getId(ZLFile file) {
		final FileInfo info = get(file);
		if (info == null) {
			return -1;
		}
		if (info.Id == -1) {
			save();
		}
		return info.Id;
	}	

	private ZLFile getFile(FileInfo info) {
		if (info == null) {
			return null;
		}
		ZLFile file = myFilesByInfo.get(info);
		if (file == null) {
			file = ZLFile.createFile(getFile(info.Parent), info.Name);
			myFilesByInfo.put(info, file);
		}
		return file;
	}

	public ZLFile getFile(long id) {
		return getFile(myInfosById.get(id));
	}

	private void removeChildren(FileInfo info) {
		for (FileInfo child : info.subTrees()) {
			if (myInfosToSave.contains(child)) {
				myInfosToSave.remove(child);
			} else {
				myInfosToRemove.add(child);
			}
			removeChildren(child);
		}
	}

	private void addChildren(ZLFile file) {
		for (ZLFile child : file.children()) {
			final FileInfo info = get(child);
			if (myInfosToRemove.contains(info)) {
				myInfosToRemove.remove(info);
			} else {
				myInfosToSave.add(info);
			}
			addChildren(child);
		}
	}
}
",False,223,6,46,8,31,4,7,L4
64,org.geometerplus.fbreader.library.AuthorTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.resources.ZLResource;

public class AuthorTree extends LibraryTree {
	public final Author Author;

	AuthorTree(LibraryTree parent, Author author) {
		super(parent);
		Author = author;
	}

	SeriesTree createSeriesSubTree(String series) {
		return new SeriesTree(this, series);
	}

	@Override
	public String getName() {
		return
			(Author != null) ?
				Author.DisplayName :
				ZLResource.resource(""library"").getResource(""unknownAuthor"").getValue();
	}

	protected String getSortKey() {
		return (Author != null) ? Author.SortKey : null;
	}
}
",False,205,8,27,7,46,3,4,L5
65,org.geometerplus.fbreader.library.Library.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.io.File;
import java.lang.ref.WeakReference;
import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.fbreader.formats.PluginCollection;
import org.geometerplus.fbreader.Paths;

public final class Library {
	public static final int STATE_NOT_INITIALIZED = 0;
	public static final int STATE_FULLY_INITIALIZED = 1;

	private final LinkedList<Book> myBooks = new LinkedList<Book>();
	private final HashSet<Book> myExternalBooks = new HashSet<Book>();
	private final LibraryTree myLibraryByAuthor = new RootTree();
	private final LibraryTree myLibraryByTitle = new RootTree();
	private final LibraryTree myLibraryByTag = new RootTree();
	private final LibraryTree myRecentBooks = new RootTree();
	private final LibraryTree myFavorites = new RootTree();
	private LibraryTree mySearchResult = new RootTree();

	private volatile int myState = STATE_NOT_INITIALIZED;
	private volatile boolean myInterrupted = false;

	public Library() {
	}

	public boolean hasState(int state) {
		return myState >= state || myInterrupted;
	}

	public void waitForState(int state) {
		while (myState < state && !myInterrupted) {
			synchronized(this) {
				if (myState < state && !myInterrupted) {
					try {
						wait();
					} catch (InterruptedException e) {
					}
				}
			}
		}
	}

	public static ZLResourceFile getHelpFile() {
		final Locale locale = Locale.getDefault();

		ZLResourceFile file = ZLResourceFile.createResourceFile(
			""data/help/MiniHelp."" + locale.getLanguage() + ""_"" + locale.getCountry() + "".fb2""
		);
		if (file.exists()) {
			return file;
		}

		file = ZLResourceFile.createResourceFile(
			""data/help/MiniHelp."" + locale.getLanguage() + "".fb2""
		);
		if (file.exists()) {
			return file;
		}

		return ZLResourceFile.createResourceFile(""data/help/MiniHelp.en.fb2"");
	}

	private static Book getBook(ZLFile bookFile, FileInfoSet fileInfos, Map<Long,Book> saved, boolean doReadMetaInfo) {
		Book book = saved.remove(fileInfos.getId(bookFile));
		if (book == null) {
			doReadMetaInfo = true;
			book = new Book(bookFile);
		}

		if (doReadMetaInfo && !book.readMetaInfo()) {
			return null;
		}
		return book;
	}

	private void collectBooks(
		ZLFile file,
		FileInfoSet fileInfos,
		Map<Long,Book> savedBooks,
		boolean doReadMetaInfo
	) {
		Book book = getBook(file, fileInfos, savedBooks, doReadMetaInfo);
		if (book != null) {
			myBooks.add(book);
		} else if (file.isArchive()) {
			for (ZLFile entry : fileInfos.archiveEntries(file)) {
				collectBooks(entry, fileInfos, savedBooks, doReadMetaInfo);
			}
		}
	}

	private void collectExternalBooks(FileInfoSet fileInfos, Map<Long,Book> savedBooks) {
		final HashSet<ZLPhysicalFile> myUpdatedFiles = new HashSet<ZLPhysicalFile>();
		final HashSet<Long> files = new HashSet<Long>(savedBooks.keySet());
		for (Long fileId: files) {
			final ZLFile bookFile = fileInfos.getFile(fileId);
			if (bookFile == null) {
				continue;
			}
			final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
			if (physicalFile == null || !physicalFile.exists()) {
				continue;
			}
			boolean reloadMetaInfo = false; 
			if (myUpdatedFiles.contains(physicalFile)) {
				reloadMetaInfo = true;
			} else if (!fileInfos.check(physicalFile, physicalFile != bookFile)) {
				reloadMetaInfo = true;
				myUpdatedFiles.add(physicalFile);
			}
			final Book book = getBook(bookFile, fileInfos, savedBooks, reloadMetaInfo);
			if (book == null) {
				continue;
			}
			final long bookId = book.getId();
			if (bookId != -1 && BooksDatabase.Instance().checkBookList(bookId)) {
				myBooks.add(book);
				myExternalBooks.add(book);
			}
		}
	}

	private List<ZLPhysicalFile> collectPhysicalFiles() {
		final Queue<ZLFile> dirQueue = new LinkedList<ZLFile>();
		final HashSet<ZLFile> dirSet = new HashSet<ZLFile>();
		final LinkedList<ZLPhysicalFile> fileList = new LinkedList<ZLPhysicalFile>();

		dirQueue.offer(new ZLPhysicalFile(new File(Paths.BooksDirectoryOption().getValue())));

		while (!dirQueue.isEmpty()) {
			for (ZLFile file : dirQueue.poll().children()) {
				if (file.isDirectory()) {
					if (!dirSet.contains(file)) {
						dirQueue.add(file);
						dirSet.add(file);
					}
				} else {
					file.setCached(true);
					fileList.add((ZLPhysicalFile)file);
				}
			}
		}
		return fileList;
	}

	private void collectBooks() {
		final List<ZLPhysicalFile> physicalFilesList = collectPhysicalFiles();

		FileInfoSet fileInfos = new FileInfoSet();

		final Map<Long,Book> savedBooks = BooksDatabase.Instance().loadBooks(fileInfos);

		for (ZLPhysicalFile file : physicalFilesList) {
			// TODO: better value for this flag
			final boolean flag = !""epub"".equals(file.getExtension());
			collectBooks(file, fileInfos, savedBooks, !fileInfos.check(file, flag));
			file.setCached(false);
		}
		final Book helpBook = getBook(getHelpFile(), fileInfos, savedBooks, false);
		if (helpBook != null) {
			myBooks.add(helpBook);
		}

		collectExternalBooks(fileInfos, savedBooks);

		fileInfos.save();
	}

	private static class AuthorSeriesPair {
		private final Author myAuthor;
		private final String mySeries;

		AuthorSeriesPair(Author author, String series) {
			myAuthor = author;
			mySeries = series;
		}

		public boolean equals(Object object) {
			if (this == object) {
				return true;
			}
			if (!(object instanceof AuthorSeriesPair)) {
				return false;
			}
			AuthorSeriesPair pair = (AuthorSeriesPair)object;
			return ZLMiscUtil.equals(myAuthor, pair.myAuthor) && mySeries.equals(pair.mySeries);
		}

		public int hashCode() {
			return Author.hashCode(myAuthor) + mySeries.hashCode();
		}
	}

	private final ArrayList<?> myNullList = new ArrayList<Object>(1);
	{
		myNullList.add(null);
	}

	private TagTree getTagTree(Tag tag, HashMap<Tag,TagTree> tagTreeMap) {
		TagTree tagTree = tagTreeMap.get(tag);
		if (tagTree == null) {
			LibraryTree parent =
				((tag != null) && (tag.Parent != null)) ?
					getTagTree(tag.Parent, tagTreeMap) : myLibraryByTag;
			tagTree = parent.createTagSubTree(tag);
			tagTreeMap.put(tag, tagTree);
		}
		return tagTree;
	}

	private void build() {
		final HashMap<Tag,TagTree> tagTreeMap = new HashMap<Tag,TagTree>();
		final HashMap<Author,AuthorTree> authorTreeMap = new HashMap<Author,AuthorTree>();
		final HashMap<AuthorSeriesPair,SeriesTree> seriesTreeMap = new HashMap<AuthorSeriesPair,SeriesTree>();
		final HashMap<Long,Book> bookById = new HashMap<Long,Book>();

		collectBooks();

		for (Book book : myBooks) {
			bookById.put(book.getId(), book);
			List<Author> authors = book.authors();
			if (authors.isEmpty()) {
				authors = (List<Author>)myNullList;
			}
			final SeriesInfo seriesInfo = book.getSeriesInfo();
			for (Author a : authors) {
				AuthorTree authorTree = authorTreeMap.get(a);
				if (authorTree == null) {
					authorTree = myLibraryByAuthor.createAuthorSubTree(a);
					authorTreeMap.put(a, authorTree);
				}
				if (seriesInfo == null) {
					authorTree.createBookSubTree(book, false);
				} else {
					final String series = seriesInfo.Name;
					final AuthorSeriesPair pair = new AuthorSeriesPair(a, series);
					SeriesTree seriesTree = seriesTreeMap.get(pair);
					if (seriesTree == null) {
						seriesTree = authorTree.createSeriesSubTree(series);
						seriesTreeMap.put(pair, seriesTree);
					}
					seriesTree.createBookInSeriesSubTree(book);
				}
			}

			List<Tag> tags = book.tags();
			if (tags.isEmpty()) {
				tags = (List<Tag>)myNullList;
			}
			for (Tag t : tags) {
				getTagTree(t, tagTreeMap).createBookSubTree(book, true);
			}
		}

		boolean doGroupTitlesByFirstLetter = false;
		if (myBooks.size() > 10) {
			final HashSet<Character> letterSet = new HashSet<Character>();
			for (Book book : myBooks) {
				String title = book.getTitle();
				if (title != null) {
					title = title.trim();
					if (!"""".equals(title)) {
						letterSet.add(title.charAt(0));
					}
				}
			}
			doGroupTitlesByFirstLetter = letterSet.size() > myBooks.size() + 4;
		}
		if (doGroupTitlesByFirstLetter) {
			final HashMap<Character,TitleTree> letterTrees = new HashMap<Character,TitleTree>();
			for (Book book : myBooks) {
				String title = book.getTitle();
				if (title == null) {
					continue;
				}
				title = title.trim();
				if ("""".equals(title)) {
					continue;
				}
				Character c = title.charAt(0);
				TitleTree tree = letterTrees.get(c);
				if (tree == null) {
					tree = myLibraryByTitle.createTitleSubTree(c.toString());
					letterTrees.put(c, tree);
				}
				tree.createBookSubTree(book, true);
			}
		} else {
			for (Book book : myBooks) {
				myLibraryByTitle.createBookSubTree(book, true);
			}
		}

		final BooksDatabase db = BooksDatabase.Instance();
		for (long id : db.loadRecentBookIds()) {
			Book book = bookById.get(id);
			if (book != null) {
				myRecentBooks.createBookSubTree(book, true);
			}
		}

		for (long id : db.loadFavoritesIds()) {
			Book book = bookById.get(id);
			if (book != null) {
				myFavorites.createBookSubTree(book, true);
			}
		}

		myFavorites.sortAllChildren();
		myLibraryByAuthor.sortAllChildren();
		myLibraryByTitle.sortAllChildren();
		myLibraryByTag.sortAllChildren();

		db.executeAsATransaction(new Runnable() {
			public void run() {
				for (Book book : myBooks) {
					book.save();
				}
			}
		});

		myState = STATE_FULLY_INITIALIZED;
	}

	public synchronized void synchronize() {
		if (myState == STATE_NOT_INITIALIZED) {
			try {
				myInterrupted = false;
				build();
			} catch (Throwable t) {
				myInterrupted = true;
			}
			notifyAll();
		}
	}

	public LibraryTree byAuthor() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myLibraryByAuthor;
	}

	public LibraryTree byTitle() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myLibraryByTitle;
	}

	public LibraryTree byTag() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myLibraryByTag;
	}

	public LibraryTree recentBooks() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myRecentBooks;
	}

	public static Book getRecentBook() {
		List<Long> recentIds = BooksDatabase.Instance().loadRecentBookIds();
		return (recentIds.size() > 0) ? Book.getById(recentIds.get(0)) : null;
	}

	public static Book getPreviousBook() {
		List<Long> recentIds = BooksDatabase.Instance().loadRecentBookIds();
		return (recentIds.size() > 1) ? Book.getById(recentIds.get(1)) : null;
	}

	public LibraryTree favorites() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myFavorites;
	}

	public LibraryTree searchResults() {
		return mySearchResult;
	}

	public LibraryTree searchBooks(String pattern) {
		waitForState(STATE_FULLY_INITIALIZED);
		final RootTree newSearchResults = new RootTree();
		if (pattern != null) {
			pattern = pattern.toLowerCase();
			for (Book book : myBooks) {
				if (book.matches(pattern)) {
					newSearchResults.createBookSubTree(book, true);
				}
			}
			newSearchResults.sortAllChildren();
			if (newSearchResults.hasChildren()) {
				mySearchResult = newSearchResults;
			}
		}
		return newSearchResults;
	}

	public static void addBookToRecentList(Book book) {
		final BooksDatabase db = BooksDatabase.Instance();
		final List<Long> ids = db.loadRecentBookIds();
		final Long bookId = book.getId();
		ids.remove(bookId);
		ids.add(0, bookId);
		if (ids.size() > 12) {
			ids.remove(12);
		}
		db.saveRecentBookIds(ids);
	}

	public boolean isBookInFavorites(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		return myFavorites.containsBook(book);
	}

	public void addBookToFavorites(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		if (!myFavorites.containsBook(book)) {
			myFavorites.createBookSubTree(book, true);
			myFavorites.sortAllChildren();
			BooksDatabase.Instance().addToFavorites(book.getId());
		}
	}

	public void removeBookFromFavorites(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		if (myFavorites.removeBook(book)) {
			BooksDatabase.Instance().removeFromFavorites(book.getId());
		}
	}

	public static final int REMOVE_DONT_REMOVE = 0x00;
	public static final int REMOVE_FROM_LIBRARY = 0x01;
	public static final int REMOVE_FROM_DISK = 0x02;
	public static final int REMOVE_FROM_LIBRARY_AND_DISK = REMOVE_FROM_LIBRARY | REMOVE_FROM_DISK;

	public int getRemoveBookMode(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		return (myExternalBooks.contains(book) ? REMOVE_FROM_LIBRARY : REMOVE_DONT_REMOVE)
			| (canDeleteBookFile(book) ? REMOVE_FROM_DISK : REMOVE_DONT_REMOVE);
	}

	private boolean canDeleteBookFile(Book book) {
		ZLFile file = book.File;
		if (file.getPhysicalFile() == null) {
			return false;
		}
		while (file instanceof ZLArchiveEntryFile) {
			file = file.getParent();
			if (file.children().size() != 1) {
				return false;
			}
		}
		return true;
	}

	public void removeBook(Book book, int removeMode) {
		if (removeMode == REMOVE_DONT_REMOVE) {
			return;
		}
		waitForState(STATE_FULLY_INITIALIZED);
		myBooks.remove(book);
		myLibraryByAuthor.removeBook(book);
		myLibraryByTag.removeBook(book);
		if (myRecentBooks.removeBook(book)) {
			final BooksDatabase db = BooksDatabase.Instance();
			final List<Long> ids = db.loadRecentBookIds();
			ids.remove(book.getId());
			db.saveRecentBookIds(ids);
		}
		mySearchResult.removeBook(book);
		myFavorites.removeBook(book);

		BooksDatabase.Instance().deleteFromBookList(book.getId());
		if ((removeMode & REMOVE_FROM_DISK) != 0) {
			book.File.getPhysicalFile().delete();
		}
	}

	private static final HashMap<String,WeakReference<ZLImage>> ourCoverMap =
		new HashMap<String,WeakReference<ZLImage>>();
	private static final WeakReference<ZLImage> NULL_IMAGE = new WeakReference<ZLImage>(null);

	public static ZLImage getCover(ZLFile file) {
		if (file == null) {
			return null;
		}
		synchronized(ourCoverMap) {
			final String path = file.getPath();
			final WeakReference<ZLImage> ref = ourCoverMap.get(path);
			if (ref == NULL_IMAGE) {
				return null;
			} else if (ref != null) {
				final ZLImage image = ref.get();
				if (image != null) {
					return image;
				}
			}
			ZLImage image = null;
			final FormatPlugin plugin = PluginCollection.Instance().getPlugin(file);
			if (plugin != null) {
				image = plugin.readCover(file);
			}
			if (image == null) {
				ourCoverMap.put(path, NULL_IMAGE);
			} else {
				ourCoverMap.put(path, new WeakReference<ZLImage>(image));
			}
			return image;
		}
	}

	public static String getAnnotation(ZLFile file) {
		final FormatPlugin plugin = PluginCollection.Instance().getPlugin(file);
		return plugin != null ? plugin.readAnnotation(file) : null;
	}
}
",True,223,6,43,6,46,9,24,L5
66,org.geometerplus.fbreader.library.LibraryTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

//import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.fbreader.tree.FBTree;

public abstract class LibraryTree extends FBTree {
	protected LibraryTree() {
		super();
	}

	protected LibraryTree(LibraryTree parent) {
		super(parent);
	}

	TagTree createTagSubTree(Tag tag) {
		return new TagTree(this, tag);
	}

	TitleTree createTitleSubTree(String title) {
		return new TitleTree(this, title);
	}

	AuthorTree createAuthorSubTree(Author author) {
		return new AuthorTree(this, author);
	}

	BookTree createBookSubTree(Book book, boolean showAuthors) {
		return new BookTree(this, book, showAuthors);
	}

	public boolean containsBook(Book book) {
		for (FBTree tree : this) {
			if ((tree instanceof BookTree) && ((BookTree)tree).Book.equals(book)) {
				return true;
			}
		}
		return false;
	}

	public boolean removeBook(Book book) {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();
		for (FBTree tree : this) {
			if ((tree instanceof BookTree) && ((BookTree)tree).Book.equals(book)) {
				toRemove.add(tree);
			}
		}
		for (FBTree tree : toRemove) {
			tree.removeSelf();
			FBTree parent = tree.Parent;
			for (; (parent != null) && !parent.hasChildren(); parent = parent.Parent) {
				parent.removeSelf();
			}
			for (; parent != null; parent = parent.Parent) {
				((LibraryTree)parent).invalidateChildren();
			}
		}
		return !toRemove.isEmpty();
	}
}
",False,205,8,27,7,47,9,9,L5
67,org.geometerplus.fbreader.library.SeriesTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class SeriesTree extends LibraryTree {
	public final String Series;

	SeriesTree(LibraryTree parent, String series) {
		super(parent);
		Series = series;
	}

	@Override
	public String getName() {
		return Series;
	}

	BookTree createBookInSeriesSubTree(Book book) {
		return new BookInSeriesTree(this, book);
	}
}
",False,205,8,27,7,47,3,4,L5
68,org.geometerplus.fbreader.library.Tag.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.HashMap;

public final class Tag {
	private static final HashMap<Tag,Tag> ourTagSet = new HashMap<Tag,Tag>();

	public static Tag getTag(Tag parent, String name) {
		if (name == null) {
			return parent;
		}
		name = name.trim();
		if (name.length() == 0) {
			return parent;
		}
		Tag tag = new Tag(parent, name);
		Tag stored = ourTagSet.get(tag);
		if (stored != null) {
			return stored;
		}
		ourTagSet.put(tag, tag);
		return tag;
	}

	public final Tag Parent;
	public final String Name;

	private Tag(Tag parent, String name) {
		Parent = parent;
		Name = name;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof Tag)) {
			return false;
		}
		Tag t = (Tag)o;
		return (Parent == t.Parent) && Name.equals(t.Name);
	}

	@Override
	public int hashCode() {
		return (Parent == null) ? Name.hashCode() : Parent.hashCode() + Name.hashCode();
	}
}
",False,120,6,45,0,0,10,0,L4
69,org.geometerplus.fbreader.bookmodel.FBTextKind.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

public interface FBTextKind {
	byte REGULAR = 0;
	byte TITLE = 1;
	byte SECTION_TITLE = 2;
	byte POEM_TITLE = 3;
	byte SUBTITLE = 4;
	byte ANNOTATION = 5;
	byte EPIGRAPH = 6;
	byte STANZA = 7;
	byte VERSE = 8;
	byte PREFORMATTED = 9;
	byte IMAGE = 10;
	//byte END_OF_SECTION = 11;
	byte CITE = 12;
	byte AUTHOR = 13;
	byte DATE = 14;
	byte INTERNAL_HYPERLINK = 15;
	byte FOOTNOTE = 16;
	byte EMPHASIS = 17;
	byte STRONG = 18;
	byte SUB = 19;
	byte SUP = 20;
	byte CODE = 21;
	byte STRIKETHROUGH = 22;
	//byte CONTENTS_TABLE_ENTRY = 23;
	//byte LIBRARY_AUTHOR_ENTRY = 24;
	//byte LIBRARY_BOOK_ENTRY = 25;
	//byte RECENT_BOOK_LIST = 26;
	byte ITALIC = 27;
	byte BOLD = 28;
	byte DEFINITION = 29;
	byte DEFINITION_DESCRIPTION = 30;
	byte H1 = 31;
	byte H2 = 32;
	byte H3 = 33;
	byte H4 = 34;
	byte H5 = 35;
	byte H6 = 36;
	byte EXTERNAL_HYPERLINK = 37;
};
",False,119,7,31,0,0,10,0,L4
70,org.geometerplus.fbreader.bookmodel.TOCTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.text.model.ZLTextModel;

public class TOCTree extends ZLTree<TOCTree> {
	private String myText;
	private Reference myReference;

	protected TOCTree() {
		super();
	}

	public TOCTree(TOCTree parent) {
		super(parent);
	}

	public final String getText() {
		return myText;
	}

	public final void setText(String text) {
		myText = text;
	}
	
	public Reference getReference() {
		return myReference;
	}
	
	public void setReference(ZLTextModel model, int reference) {
		myReference = new Reference(reference, model);
	}

	public static class Reference {
		public final int ParagraphIndex;
		public final ZLTextModel Model;
		
		public Reference(final int paragraphIndex, final ZLTextModel model) {
			ParagraphIndex = paragraphIndex;
			Model = model;
		}
	}
}
",False,126,6,38,4,2,4,2,L4
71,org.geometerplus.fbreader.bookmodel.BookModel.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import java.util.*;

import org.geometerplus.zlibrary.core.image.*;

import org.geometerplus.zlibrary.text.model.*;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.*;
import org.geometerplus.fbreader.Paths;

public final class BookModel {
	public static BookModel createModel(Book book) {
		FormatPlugin plugin = PluginCollection.Instance().getPlugin(book.File);
		if (plugin == null) {
			return null;
		}
		BookModel model = new BookModel(book);
		if (plugin.readModel(model)) {
			return model;
		}
		return null;
	}

	private final ZLImageMap myImageMap = new ZLImageMap(); 
	
	public final Book Book;
	public final ZLTextModel BookTextModel;
	public final TOCTree TOCTree = new TOCTree();

	private final HashMap<String,ZLTextModel> myFootnotes = new HashMap<String,ZLTextModel>();

	public static final class Label {
		public final String ModelId;
		public final int ParagraphIndex;
		
		public Label(String modelId, int paragraphIndex) {
			ModelId = modelId;
			ParagraphIndex = paragraphIndex;
		}
	}
	
	//private static String linksFileName(int index) {
	//	return Constants.CACHE_DIRECTORY + ""/links"" + index + "".cache"";
	//}

	private BookModel(Book book) {
		Book = book;
		BookTextModel = new ZLTextWritablePlainModel(null, book.getLanguage(), 1024, 65536, Paths.cacheDirectory(), ""cache"", myImageMap);
		//for (int i = 0; i < 50; ++i) {
		//	new File(linksFileName(i)).delete();
		//}
	}

	public ZLTextModel getFootnoteModel(String id) {
		ZLTextModel model = myFootnotes.get(id);
		if (model == null) {
			model = new ZLTextWritablePlainModel(id, Book.getLanguage(), 8, 512, Paths.cacheDirectory(), ""cache"" + myFootnotes.size(), myImageMap); 
			myFootnotes.put(id, model); 
		}
		return model;
	}
	
	private final CharStorage myInternalHyperlinks = new CachedCharStorage(32768, Paths.cacheDirectory(), ""links"");
	private char[] myCurrentLinkBlock;
	private int myCurrentLinkBlockOffset;

	void addHyperlinkLabel(String label, ZLTextModel model, int paragraphNumber) {
		final String modelId = model.getId();
		final int labelLength = label.length();
		final int idLength = (modelId != null) ? modelId.length() : 0;
		final int len = 4 + labelLength + idLength;

		/*
		try {
			final OutputStreamWriter writer =
				new OutputStreamWriter(
					new FileOutputStream(linksFileName(label.hashCode() % 50), true),
					""UTF-16LE""
				);
			writer.write(labelLength);
			writer.write(label);
			writer.write(idLength);
			if (idLength > 0) {
				writer.write(modelId);
			}
			writer.write(paragraphNumber >> 16);
			writer.write(paragraphNumber);
			writer.close();
		} catch (IOException e) {
		}
		*/

		char[] block = myCurrentLinkBlock;
		int offset = myCurrentLinkBlockOffset;
		if ((block == null) || (offset + len > block.length)) {
			if (block != null) {
				myInternalHyperlinks.freezeLastBlock();
			}
			block = myInternalHyperlinks.createNewBlock(len);
			myCurrentLinkBlock = block;
			offset = 0;
		}
		block[offset++] = (char)labelLength;
		label.getChars(0, labelLength, block, offset);
		offset += labelLength;
		block[offset++] = (char)idLength;
		if (idLength > 0) {
			modelId.getChars(0, idLength, block, offset);
			offset += idLength;
		}
		block[offset++] = (char)(paragraphNumber >> 16);
		block[offset++] = (char)paragraphNumber;
		myCurrentLinkBlockOffset = offset;
	}

	public Label getLabel(String id) {
		final int len = id.length();
		final int size = myInternalHyperlinks.size();
		/*
		try {
			final File file = new File(linksFileName(id.hashCode() % 50));
			if (!file.exists()) {
				return null;
			}
			final char[] block = new char[(int)file.length()];
			final InputStreamReader reader =
				new InputStreamReader(
					new FileInputStream(file),
					""UTF-16LE""
				);
			reader.read(block);
			reader.close();
			for (int offset = 0; offset < block.length; ) {
				final int labelLength = (int)block[offset++];
				if (labelLength == 0) {
					break;
				}
				final int idLength = (int)block[offset + labelLength];
				if ((labelLength != len) || !id.equals(new String(block, offset, labelLength))) {
					offset += labelLength + idLength + 3;
					continue;
				}
				offset += labelLength + 1;
				final String modelId = (idLength > 0) ? new String(block, offset, idLength) : null;
				offset += idLength;
				final int paragraphNumber = (((int)block[offset++]) << 16) + (int)block[offset];
				return new Label(modelId, paragraphNumber);
			}
		} catch (IOException e) {
		}
		*/
		for (int i = 0; i < size; ++i) {
			final char[] block = myInternalHyperlinks.block(i);
			for (int offset = 0; offset < block.length; ) {
				final int labelLength = (int)block[offset++];
				if (labelLength == 0) {
					break;
				}
				final int idLength = (int)block[offset + labelLength];
				if ((labelLength != len) || !id.equals(new String(block, offset, labelLength))) {
					offset += labelLength + idLength + 3;
					continue;
				}
				offset += labelLength + 1;
				final String modelId = (idLength > 0) ? new String(block, offset, idLength) : null;
				offset += idLength;
				final int paragraphNumber = (((int)block[offset++]) << 16) + (int)block[offset];
				return new Label(modelId, paragraphNumber);
			}
		}
		return null;
	}
	
	void addImage(String id, ZLImage image) {
		myImageMap.put(id, image);
	}
}
",False,218,5,36,6,35,27,11,L4
72,org.geometerplus.fbreader.bookmodel.BookReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import org.geometerplus.zlibrary.core.util.*;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharsetDecoder;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.text.model.*;

public class BookReader {
	public final BookModel Model;

	private ZLTextWritableModel myCurrentTextModel = null;
	
	private boolean myTextParagraphExists = false;
	private boolean myTextParagraphIsNonEmpty = false;
	
	private char[] myTextBuffer = new char[4096];
	private int myTextBufferLength;
	private StringBuilder myContentsBuffer = new StringBuilder();

	private byte[] myKindStack = new byte[20];
	private int myKindStackSize;
	
	private byte myHyperlinkKind;
	private String myHyperlinkReference = """";
	
	private boolean myInsideTitle = false;
	private boolean mySectionContainsRegularContents = false;
	
	private TOCTree myCurrentContentsTree;

	private CharsetDecoder myByteDecoder;

	public BookReader(BookModel model) {
		Model = model;
		myCurrentContentsTree = model.TOCTree;
	}

	public final void setByteDecoder(CharsetDecoder decoder) {
		myByteDecoder = decoder;
	}
	
	private final void flushTextBufferToParagraph() {
		if (myTextBufferLength > 0) {
			myCurrentTextModel.addText(myTextBuffer, 0, myTextBufferLength);
			myTextBufferLength = 0;
			if (myByteDecoder != null) {
				myByteDecoder.reset();
			}
		}
	}
	
	public final void addControl(byte kind, boolean start) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addControl(kind, start);
		}
		if (!start && myHyperlinkReference.length() != 0 && kind == myHyperlinkKind) {
			myHyperlinkReference = """";
		}
	}
	
	/*
	public final void addControl(ZLTextForcedControlEntry entry) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addControl(entry);
		}
	}
	*/
	
	public final void pushKind(byte kind) {
		byte[] stack = myKindStack;
		if (stack.length == myKindStackSize) {
			stack = ZLArrayUtils.createCopy(stack, myKindStackSize, myKindStackSize << 1);
			myKindStack = stack;
		}
		stack[myKindStackSize++] = kind;
	}
	
	public final boolean popKind() {
		if (myKindStackSize != 0) {
			--myKindStackSize;
			return true;
		}
		return false;
	}
	
	public final void beginParagraph() {
		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
	}

	public final void beginParagraph(byte kind) {
		endParagraph();
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			textModel.createParagraph(kind);
			final byte[] stack = myKindStack;
			final int size = myKindStackSize;
			for (int i = 0; i < size; ++i) {
				textModel.addControl(stack[i], true);
			}
			if (myHyperlinkReference.length() != 0) {
				textModel.addHyperlinkControl(myHyperlinkKind, hyperlinkType(myHyperlinkKind), myHyperlinkReference);
			}
			myTextParagraphExists = true;
		}		
	}
	
	public final void endParagraph() {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myTextParagraphExists = false;
			myTextParagraphIsNonEmpty = false;
		}
	}
	
	private final void insertEndParagraph(byte kind) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null && mySectionContainsRegularContents) {
			int size = textModel.getParagraphsNumber();
			if (size > 0 && textModel.getParagraph(size - 1).getKind() != kind) {
				textModel.createParagraph(kind);
				mySectionContainsRegularContents = false;
			}
		}
	}
	
	public final void insertEndOfSectionParagraph() {
		insertEndParagraph(ZLTextParagraph.Kind.END_OF_SECTION_PARAGRAPH);
	}
	
/*	public final void insertEndOfTextParagraph() {
		insertEndParagraph(ZLTextParagraph.Kind.END_OF_TEXT_PARAGRAPH);
	}
*/	
	public final void unsetCurrentTextModel() {
		if (myCurrentTextModel != null) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = null;
	}
	
	public final void enterTitle() {
		myInsideTitle = true;
	}
	
	public final void exitTitle() {
		myInsideTitle = false;
	}
	
	public final void setMainTextModel() {
		if ((myCurrentTextModel != null) && (myCurrentTextModel != Model.BookTextModel)) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = (ZLTextWritableModel)Model.BookTextModel;
	}
	
	public final void setFootnoteTextModel(String id) {
		if ((myCurrentTextModel != null) && (myCurrentTextModel != Model.BookTextModel)) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = (ZLTextWritableModel)Model.getFootnoteModel(id);
	}
	
	public final void addData(char[] data) {
		addData(data, 0, data.length, false);
	}

	public final void addData(char[] data, int offset, int length, boolean direct) {
		if (!myTextParagraphExists || length == 0) {
			return;
		}
		if (!myInsideTitle && !mySectionContainsRegularContents) {
			while (length > 0 && Character.isWhitespace(data[offset])) {
				--length;
				++offset;
			}
			if (length == 0) {
				return;
			}
		}

		myTextParagraphIsNonEmpty = true;

		if (direct && (myTextBufferLength == 0) && !myInsideTitle) {
			myCurrentTextModel.addText(data, offset, length);
		} else {
			final int oldLength = myTextBufferLength;
			final int newLength = oldLength + length;
			if (myTextBuffer.length < newLength) {
				myTextBuffer = ZLArrayUtils.createCopy(myTextBuffer, oldLength, newLength);
			}
			System.arraycopy(data, offset, myTextBuffer, oldLength, length);
			myTextBufferLength = newLength;
			if (myInsideTitle) {
				addContentsData(myTextBuffer, oldLength, length);
			}
		}
		if (!myInsideTitle) {
			mySectionContainsRegularContents = true;
		}
	}

	private byte[] myUnderflowByteBuffer = new byte[4];
	private int myUnderflowLength;

	public final void addByteData(byte[] data, int start, int length) {
		if (!myTextParagraphExists || (length == 0)) {
			return;
		}
		myTextParagraphIsNonEmpty = true;

		final int oldLength = myTextBufferLength;
		if (myTextBuffer.length < oldLength + length) {
			myTextBuffer = ZLArrayUtils.createCopy(myTextBuffer, oldLength, oldLength + length);
		}
		final CharBuffer cb = CharBuffer.wrap(myTextBuffer, myTextBufferLength, length);

		if (myUnderflowLength > 0) {
			int l = myUnderflowLength;
			while (length-- > 0) {
				myUnderflowByteBuffer[l++] = data[start++];
				final ByteBuffer ubb = ByteBuffer.wrap(myUnderflowByteBuffer);
				myByteDecoder.decode(ubb, cb, false);
				if (cb.position() != oldLength) {
					myUnderflowLength = 0;
					break;
				}
			}
			if (length == 0) {
				myUnderflowLength = l;
				return;
			}
		}

		ByteBuffer bb = ByteBuffer.wrap(data, start, length);
		myByteDecoder.decode(bb, cb, false);
		myTextBufferLength = cb.position();
		int rem = bb.remaining();
		if (rem > 0) {
			for (int i = 0, j = start + length - rem; i < rem;) {
				myUnderflowByteBuffer[i++] = data[j++];
			}
			myUnderflowLength = rem;
		}

		if (myInsideTitle) {
			addContentsData(myTextBuffer, oldLength, myTextBufferLength - oldLength);
		} else {
			mySectionContainsRegularContents = true;
		}
	}
	
	private static byte hyperlinkType(byte kind) {
		return (kind == FBTextKind.EXTERNAL_HYPERLINK) ?
			FBHyperlinkType.EXTERNAL : FBHyperlinkType.INTERNAL;
	}

	public final void addHyperlinkControl(byte kind, String label) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addHyperlinkControl(kind, hyperlinkType(kind), label);
		}
		myHyperlinkKind = kind;
		myHyperlinkReference = label;
	}
	
	public final void addHyperlinkLabel(String label) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			int paragraphNumber = textModel.getParagraphsNumber();
			if (myTextParagraphExists) {
				--paragraphNumber;
			}
			Model.addHyperlinkLabel(label, textModel, paragraphNumber);
		}
	}
	
	public final void addHyperlinkLabel(String label, int paragraphIndex) {
		Model.addHyperlinkLabel(label, myCurrentTextModel, paragraphIndex);
	}
	
	public final void addContentsData(char[] data) {
		addContentsData(data, 0, data.length);
	}

	public final void addContentsData(char[] data, int offset, int length) {
		if ((length != 0) && (myCurrentContentsTree != null)) {
			myContentsBuffer.append(data, offset, length);
		}
	}

	public final boolean hasContentsData() {
		return myContentsBuffer.length() > 0;
	}
	
	public final void beginContentsParagraph(int referenceNumber) {
		beginContentsParagraph(Model.BookTextModel, referenceNumber);
	}

	public final void beginContentsParagraph(ZLTextModel bookTextModel, int referenceNumber) {
		final ZLTextModel textModel = myCurrentTextModel;
		if (textModel == bookTextModel) {
			if (referenceNumber == -1) {
				referenceNumber = textModel.getParagraphsNumber();
			}
			TOCTree parentTree = myCurrentContentsTree;
			if (parentTree.Level > 0) {
				if (myContentsBuffer.length() > 0) {
					parentTree.setText(myContentsBuffer.toString());
					myContentsBuffer.delete(0, myContentsBuffer.length());
				} else if (parentTree.getText() == null) {
					parentTree.setText(""..."");
				}
			} else {
				myContentsBuffer.delete(0, myContentsBuffer.length());
			}
			TOCTree tree = new TOCTree(parentTree);
			tree.setReference(myCurrentTextModel, referenceNumber);
			myCurrentContentsTree = tree;
		}
	}
	
	public final void endContentsParagraph() {
		final TOCTree tree = myCurrentContentsTree;
		if (tree.Level == 0) {
			myContentsBuffer.delete(0, myContentsBuffer.length());
			return;
		}
		if (myContentsBuffer.length() > 0) {
			tree.setText(myContentsBuffer.toString());
			myContentsBuffer.delete(0, myContentsBuffer.length());
		} else if (tree.getText() == null) {
			tree.setText(""..."");
		}
		myCurrentContentsTree = tree.Parent;
	}

	public final void setReference(int contentsParagraphNumber, int referenceNumber) {
		setReference(contentsParagraphNumber, myCurrentTextModel, referenceNumber);
	}
	
	public final void setReference(int contentsParagraphNumber, ZLTextWritableModel textModel, int referenceNumber) {
		final TOCTree contentsTree = Model.TOCTree;
		if (contentsParagraphNumber < contentsTree.getSize()) {
			contentsTree.getTreeByParagraphNumber(contentsParagraphNumber).setReference(
				textModel, referenceNumber
			);
		}
	}
	
	public final boolean paragraphIsOpen() {
		return myTextParagraphExists;
	}
	
	public boolean paragraphIsNonEmpty() {
		return myTextParagraphIsNonEmpty;
	}

	public final boolean contentsParagraphIsOpen() {
		return myCurrentContentsTree.Level > 0;
	}

	public final void beginContentsParagraph() {
		beginContentsParagraph(-1);
	}
	
	public final void addImageReference(String ref) {
		addImageReference(ref, (short)0);
	}

	public final void addImageReference(String ref, short vOffset) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			mySectionContainsRegularContents = true;
			if (myTextParagraphExists) {
				flushTextBufferToParagraph();
				textModel.addImage(ref, vOffset);
			} else {
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				textModel.addControl(FBTextKind.IMAGE, true);
				textModel.addImage(ref, vOffset);
				textModel.addControl(FBTextKind.IMAGE, false);
				endParagraph();
			}
		}
	}

	public final void addImage(String id, ZLImage image) {
		Model.addImage(id, image);
	}

	public final void addFixedHSpace(short length) {
		if (myTextParagraphExists) {
			myCurrentTextModel.addFixedHSpace(length);
		}
	}
}
",False,143,2,1,7,33,16,10,L4
73,org.geometerplus.fbreader.bookmodel.FBHyperlinkType.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

public interface FBHyperlinkType {
	byte NONE = 0;
	byte INTERNAL = 1;
	byte EXTERNAL = 2;
}
",False,119,7,44,0,0,3,0,L4
74,org.geometerplus.fbreader.fbreader.ScrollingPreferences.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.options.ZLEnumOption;
import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;
import org.geometerplus.zlibrary.core.view.ZLView;

public class ScrollingPreferences {
	private static ScrollingPreferences ourInstance;

	public static ScrollingPreferences Instance() {
		return (ourInstance != null) ? ourInstance : new ScrollingPreferences();
	}

	public static enum FingerScrolling {
		byTap, byFlick, byTapAndFlick
	}
	public final ZLEnumOption<FingerScrolling> FingerScrollingOption =
		new ZLEnumOption<FingerScrolling>(""Scrolling"", ""Finger"", FingerScrolling.byTapAndFlick);

	public final ZLBooleanOption VolumeKeysOption =
		new ZLBooleanOption(""Scrolling"", ""VolumeKeys"", true);
	public final ZLBooleanOption InvertVolumeKeysOption =
		new ZLBooleanOption(""Scrolling"", ""InvertVolumeKeys"", false);

	public final ZLEnumOption<ZLView.Animation> AnimationOption =
		new ZLEnumOption<ZLView.Animation>(""Scrolling"", ""Animation"", ZLView.Animation.slide);
	public final ZLIntegerRangeOption AnimationSpeedOption =
		new ZLIntegerRangeOption(""Scrolling"", ""AnimationSpeed"", 1, 10, 4);

	public final ZLBooleanOption HorizontalOption =
		new ZLBooleanOption(""Scrolling"", ""Horizontal"", true);
	public static enum TapZonesScheme {
		left_to_right, right_to_left, up, down, custom
	}
	public final ZLEnumOption<TapZonesScheme> TapZonesSchemeOption =
		new ZLEnumOption<TapZonesScheme>(""Scrolling"", ""TapZonesScheme"", TapZonesScheme.right_to_left);

	private ScrollingPreferences() {
		ourInstance = this;
	}
}
",False,114,7,32,7,8,4,4,L5
75,org.geometerplus.fbreader.fbreader.FindNextAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class FindNextAction extends FBAction {
	FindNextAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public boolean isEnabled() {
		FBView view = Reader.getTextView();
		return (view != null) && view.canFindNext();
	}

	public void run() {
		Reader.getTextView().findNext();
	}
}
",False,216,0,0,7,71,1,4,L5
76,org.geometerplus.fbreader.fbreader.ActionCode.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

public interface ActionCode {
	String SHOW_LIBRARY = ""library"";
	String SHOW_PREFERENCES = ""preferences"";
	String SHOW_BOOK_INFO = ""bookInfo"";
	String SHOW_TOC = ""toc"";
	String SHOW_BOOKMARKS = ""bookmarks"";
	String SHOW_NETWORK_LIBRARY = ""networkLibrary"";

	String SWITCH_TO_NIGHT_PROFILE = ""night"";
	String SWITCH_TO_DAY_PROFILE = ""day"";

	String SEARCH = ""search"";
	String FIND_PREVIOUS = ""findPrevious"";
	String FIND_NEXT = ""findNext"";
	String CLEAR_FIND_RESULTS = ""clearFindResults"";

	String SET_TEXT_VIEW_MODE_VISIT_HYPERLINKS = ""hyperlinksOnlyMode"";
	String SET_TEXT_VIEW_MODE_VISIT_ALL_WORDS = ""dictionaryMode"";

	String TURN_PAGE_BACK = ""previousPage"";
	String TURN_PAGE_FORWARD = ""nextPage"";

	String VOLUME_KEY_SCROLL_FORWARD = ""volumeKeyScrollForward"";
	String VOLUME_KEY_SCROLL_BACK = ""volumeKeyScrollBackward"";
	String SHOW_MENU = ""menu"";
	String SHOW_NAVIGATION = ""navigate"";

	String GO_BACK = ""goBack"";
	String EXIT = ""exit"";
	String SHOW_CANCEL_MENU = ""cancelMenu"";

	String ROTATE = ""rotate"";
	String INCREASE_FONT = ""increaseFont"";
	String DECREASE_FONT = ""decreaseFont"";

	String PROCESS_HYPERLINK = ""processHyperlink"";

	String SELECTION_SHOW_PANEL = ""selectionShowPanel"";
	String SELECTION_HIDE_PANEL = ""selectionHidePanel"";
	String SELECTION_CLEAR = ""selectionClear"";
	String SELECTION_COPY_TO_CLIPBOARD = ""selectionCopyToClipboard"";
	String SELECTION_SHARE = ""selectionShare"";
	String SELECTION_TRANSLATE = ""selectionTranslate"";
	String SELECTION_BOOKMARK = ""selectionBookmark"";
}
",False,73,5,41,0,0,6,0,L5
77,org.geometerplus.fbreader.fbreader.FBAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.application.ZLApplication;

public abstract class FBAction extends ZLApplication.ZLAction {
	protected final FBReaderApp Reader;

	public FBAction(FBReaderApp fbreader) {
		Reader = fbreader;
	}
}
",False,270,6,13,7,74,23,2,L5
78,org.geometerplus.fbreader.fbreader.ExitAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class ExitAction extends FBAction {
	ExitAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public void run() {
		if (Reader.getCurrentView() != Reader.BookTextView) {
			Reader.showBookTextView();
		} else {
			Reader.closeWindow();
		}
	}
}
",False,216,0,0,7,74,1,3,L5
79,org.geometerplus.fbreader.fbreader.TapZoneMap.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.HashMap;

import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class TapZoneMap {
	public static enum Tap {
		singleTap,
		singleNotDoubleTap,
		doubleTap
	};

	private int myVerticalSize = 3;
	private int myHorizontalSize = 3;
	private final HashMap<Zone,String> myZoneMap = new HashMap<Zone,String>();
	private final HashMap<Zone,String> myZoneMap2 = new HashMap<Zone,String>();

	TapZoneMap(int v, int h) {
		myVerticalSize = v;
		myHorizontalSize = h;
	}

	TapZoneMap(String name) {
		final ZLFile mapFile = ZLFile.createFileByPath(
			""default/tapzones/"" + name.toLowerCase() + "".xml""
		);
		new Reader().read(mapFile);
	}

	public String getActionByCoordinates(int x, int y, int width, int height, Tap tap) {
		if (width == 0 || height == 0) {
			return null;
		}
		final Zone zone = new Zone(myHorizontalSize * x / width, myVerticalSize * y / height);
		switch (tap) {
			case singleTap:
			{
				final String action = myZoneMap.get(zone);
				return action != null ? action : myZoneMap2.get(zone);
			}
			case singleNotDoubleTap:
				return myZoneMap.get(zone);
			case doubleTap:
				return myZoneMap2.get(zone);
		}
		return null;
	}

	private static class Zone {
		int HIndex;
		int VIndex;

		Zone(int h, int v) {
			HIndex = h;
			VIndex = v;
		}

		/*void mirror45() {
			final int swap = HIndex;
			HIndex = VIndex;
			VIndex = swap;
		}*/

		@Override
		public boolean equals(Object o) {
			if (o == this) {
				return true;
			}

			if (!(o instanceof Zone)) {
				return false;
			}

			final Zone tz = (Zone)o;
			return HIndex == tz.HIndex && VIndex == tz.VIndex;
		}

		@Override
		public int hashCode() {
			return (HIndex << 5) + VIndex;
		}
	}

	private class Reader extends ZLXMLReaderAdapter {
		@Override
		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			try {
				if (""zone"".equals(tag)) {
					final int x = Integer.parseInt(attributes.getValue(""x""));
					final int y = Integer.parseInt(attributes.getValue(""y""));
					final String action = attributes.getValue(""action"");
					final String action2 = attributes.getValue(""action2"");
					if (action != null) {
						myZoneMap.put(new Zone(x, y), action);
					}
					if (action2 != null) {
						myZoneMap2.put(new Zone(x, y), action2);
					}
				} else if (""tapZones"".equals(tag)) {
					final String v = attributes.getValue(""v"");
					if (v != null) {
						myVerticalSize = Integer.parseInt(v);
					}
					final String h = attributes.getValue(""h"");
					if (h != null) {
						myHorizontalSize = Integer.parseInt(h);
					}
				}
			} catch (Throwable e) {
			}
			return false;
		}
	}
}
",True,98,7,35,5,8,1,3,L5
80,org.geometerplus.fbreader.fbreader.FBReaderApp.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.*;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.application.*;
import org.geometerplus.zlibrary.core.dialogs.ZLDialogManager;
import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.util.ZLColor;

import org.geometerplus.zlibrary.text.hyphenation.ZLTextHyphenator;
import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Library;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Bookmark;

public final class FBReaderApp extends ZLApplication {
	public final ZLBooleanOption AllowScreenBrightnessAdjustmentOption =
		new ZLBooleanOption(""LookNFeel"", ""AllowScreenBrightnessAdjustment"", true);
	public final ZLStringOption TextSearchPatternOption =
		new ZLStringOption(""TextSearch"", ""Pattern"", """");

	public final ZLBooleanOption UseSeparateBindingsOption =
		new ZLBooleanOption(""KeysOptions"", ""UseSeparateBindings"", false);

	public final ZLBooleanOption EnableDoubleTapOption =
		new ZLBooleanOption(""Options"", ""EnableDoubleTap"", false);
	public final ZLBooleanOption NavigateAllWordsOption =
		new ZLBooleanOption(""Options"", ""NavigateAllWords"", false);

	public static enum WordTappingAction {
		doNothing, selectSingleWord, startSelecting, openDictionary
	}
	public final ZLEnumOption<WordTappingAction> WordTappingActionOption =
		new ZLEnumOption<WordTappingAction>(""Options"", ""WordTappingAction"", WordTappingAction.startSelecting);

	public final ZLColorOption ImageViewBackgroundOption =
		new ZLColorOption(""Colors"", ""ImageViewBackground"", new ZLColor(127, 127, 127));
	public static enum ImageTappingAction {
		doNothing, selectImage, openImageView
	}
	public final ZLEnumOption<ImageTappingAction> ImageTappingActionOption =
		new ZLEnumOption<ImageTappingAction>(""Options"", ""ImageTappingAction"", ImageTappingAction.openImageView);

	public final ZLIntegerRangeOption LeftMarginOption =
		new ZLIntegerRangeOption(""Options"", ""LeftMargin"", 0, 30, 4);
	public final ZLIntegerRangeOption RightMarginOption =
		new ZLIntegerRangeOption(""Options"", ""RightMargin"", 0, 30, 4);
	public final ZLIntegerRangeOption TopMarginOption =
		new ZLIntegerRangeOption(""Options"", ""TopMargin"", 0, 30, 0);
	public final ZLIntegerRangeOption BottomMarginOption =
		new ZLIntegerRangeOption(""Options"", ""BottomMargin"", 0, 30, 4);

	public final ZLIntegerRangeOption ScrollbarTypeOption =
		new ZLIntegerRangeOption(""Options"", ""ScrollbarType"", 0, 3, FBView.SCROLLBAR_SHOW_AS_FOOTER);
	public final ZLIntegerRangeOption FooterHeightOption =
		new ZLIntegerRangeOption(""Options"", ""FooterHeight"", 8, 20, 9);
	public final ZLBooleanOption FooterShowTOCMarksOption =
		new ZLBooleanOption(""Options"", ""FooterShowTOCMarks"", true);
	public final ZLBooleanOption FooterShowClockOption =
		new ZLBooleanOption(""Options"", ""ShowClockInFooter"", true);
	public final ZLBooleanOption FooterShowBatteryOption =
		new ZLBooleanOption(""Options"", ""ShowBatteryInFooter"", true);
	public final ZLBooleanOption FooterShowProgressOption =
		new ZLBooleanOption(""Options"", ""ShowProgressInFooter"", true);
	public final ZLStringOption FooterFontOption =
		new ZLStringOption(""Options"", ""FooterFont"", ""Droid Sans"");

	final ZLStringOption ColorProfileOption =
		new ZLStringOption(""Options"", ""ColorProfile"", ColorProfile.DAY);

	public final ZLBooleanOption ShowPreviousBookInCancelMenuOption =
		new ZLBooleanOption(""CancelMenu"", ""previousBook"", false);
	public final ZLBooleanOption ShowPositionsInCancelMenuOption =
		new ZLBooleanOption(""CancelMenu"", ""positions"", true);

	private final ZLKeyBindings myBindings = new ZLKeyBindings(""Keys"");

	public final FBView BookTextView;
	public final FBView FootnoteView;

	public BookModel Model;

	private final String myArg0;

	public FBReaderApp(String arg) {
		myArg0 = arg;

		addAction(ActionCode.INCREASE_FONT, new ChangeFontSizeAction(this, +2));
		addAction(ActionCode.DECREASE_FONT, new ChangeFontSizeAction(this, -2));
		addAction(ActionCode.ROTATE, new RotateAction(this));

		addAction(ActionCode.FIND_NEXT, new FindNextAction(this));
		addAction(ActionCode.FIND_PREVIOUS, new FindPreviousAction(this));
		addAction(ActionCode.CLEAR_FIND_RESULTS, new ClearFindResultsAction(this));

		addAction(ActionCode.SELECTION_CLEAR, new SelectionClearAction(this));

		addAction(ActionCode.TURN_PAGE_FORWARD, new TurnPageAction(this, true));
		addAction(ActionCode.TURN_PAGE_BACK, new TurnPageAction(this, false));

		addAction(ActionCode.VOLUME_KEY_SCROLL_FORWARD, new VolumeKeyTurnPageAction(this, true));
		addAction(ActionCode.VOLUME_KEY_SCROLL_BACK, new VolumeKeyTurnPageAction(this, false));

		addAction(ActionCode.SWITCH_TO_DAY_PROFILE, new SwitchProfileAction(this, ColorProfile.DAY));
		addAction(ActionCode.SWITCH_TO_NIGHT_PROFILE, new SwitchProfileAction(this, ColorProfile.NIGHT));

		addAction(ActionCode.EXIT, new ExitAction(this));

		BookTextView = new FBView(this);
		FootnoteView = new FBView(this);

		setView(BookTextView);
	}

	public void initWindow() {
		super.initWindow();
		ZLDialogManager.Instance().wait(""loadingBook"", new Runnable() {
			public void run() {
				Book book = createBookForFile(ZLFile.createFileByPath(myArg0));
				if (book == null) {
					book = Library.getRecentBook();
				}
				if ((book == null) || !book.File.exists()) {
					book = Book.getByFile(Library.getHelpFile());
				}
				openBookInternal(book, null);
			}
		});
	}

	public void openBook(final Book book, final Bookmark bookmark) {
		if (book == null) {
			return;
		}
		if (Model != null) {
			if (bookmark == null & book.File.getPath().equals(Model.Book.File.getPath())) {
				return;
			}
		}
		ZLDialogManager.Instance().wait(""loadingBook"", new Runnable() {
			public void run() {
				openBookInternal(book, bookmark);
			}
		});
	}

	private ColorProfile myColorProfile;

	public ColorProfile getColorProfile() {
		if (myColorProfile == null) {
			myColorProfile = ColorProfile.get(getColorProfileName());
		}
		return myColorProfile;
	}

	public String getColorProfileName() {
		return ColorProfileOption.getValue();
	}

	public void setColorProfileName(String name) {
		ColorProfileOption.setValue(name);
		myColorProfile = null;
	}

	public ZLKeyBindings keyBindings() {
		return myBindings;
	}

	public FBView getTextView() {
		return (FBView)getCurrentView();
	}

	public void tryOpenFootnote(String id) {
		if (Model != null) {
			BookModel.Label label = Model.getLabel(id);
			if (label != null) {
				addInvisibleBookmark();
				if (label.ModelId == null) {
					BookTextView.gotoPosition(label.ParagraphIndex, 0, 0);
				} else {
					FootnoteView.setModel(Model.getFootnoteModel(label.ModelId));
					setView(FootnoteView);
					FootnoteView.gotoPosition(label.ParagraphIndex, 0, 0);
				}
				getViewWidget().repaint();
			}
		}
	}

	public void clearTextCaches() {
		BookTextView.clearCaches();
		FootnoteView.clearCaches();
	}

	void openBookInternal(Book book, Bookmark bookmark) {
		if (book != null) {
			onViewChanged();

			if (Model != null) {
				Model.Book.storePosition(BookTextView.getStartCursor());
			}
			BookTextView.setModel(null);
			FootnoteView.setModel(null);
			clearTextCaches();

			Model = null;
			System.gc();
			System.gc();
			Model = BookModel.createModel(book);
			if (Model != null) {
				ZLTextHyphenator.Instance().load(book.getLanguage());
				BookTextView.setModel(Model.BookTextModel);
				BookTextView.gotoPosition(book.getStoredPosition());
				if (bookmark == null) {
					setView(BookTextView);
				} else {
					gotoBookmark(bookmark);
				}
				Library.addBookToRecentList(book);
			}
		}
		getViewWidget().repaint();
	}

	public void gotoBookmark(Bookmark bookmark) {
		addInvisibleBookmark();
		final String modelId = bookmark.ModelId;
		if (modelId == null) {
			BookTextView.gotoPosition(bookmark);
			setView(BookTextView);
		} else {
			FootnoteView.setModel(Model.getFootnoteModel(modelId));
			FootnoteView.gotoPosition(bookmark);
			setView(FootnoteView);
		}
		getViewWidget().repaint();
	}

	public void showBookTextView() {
		setView(BookTextView);
	}

	private Book createBookForFile(ZLFile file) {
		if (file == null) {
			return null;
		}
		Book book = Book.getByFile(file);
		if (book != null) {
			book.insertIntoBookList();
			return book;
		}
		if (file.isArchive()) {
			for (ZLFile child : file.children()) {
				book = Book.getByFile(child);
				if (book != null) {
					book.insertIntoBookList();
					return book;
				}
			}
		}
		return null;
	}

	@Override
	public void openFile(ZLFile file) {
		final Book book = createBookForFile(file);
		if (book != null) {
			openBook(book, null);
		}
	}

	public void onWindowClosing() {
		if (Model != null && BookTextView != null) {
			Model.Book.storePosition(BookTextView.getStartCursor());
		}
	}

	static enum CancelActionType {
		previousBook,
		returnTo,
		close
	}

	public static class CancelActionDescription {
		final CancelActionType Type;
		public final String Title;
		public final String Summary;

		CancelActionDescription(CancelActionType type, String summary) {
			final ZLResource resource = ZLResource.resource(""cancelMenu"");
			Type = type;
			Title = resource.getResource(type.toString()).getValue();
			Summary = summary;
		}
	}

	private static class BookmarkDescription extends CancelActionDescription {
		final Bookmark Bookmark;
		
		BookmarkDescription(Bookmark b) {
			super(CancelActionType.returnTo, b.getText());
			Bookmark = b;
		}
	}

	private final ArrayList<CancelActionDescription> myCancelActionsList =
		new ArrayList<CancelActionDescription>();

	public List<CancelActionDescription> getCancelActionsList() {
		myCancelActionsList.clear();
		if (ShowPreviousBookInCancelMenuOption.getValue()) {
			final Book previousBook = Library.getPreviousBook();
			if (previousBook != null) {
				myCancelActionsList.add(new CancelActionDescription(
					CancelActionType.previousBook, previousBook.getTitle()
				));
			}
		}
		if (ShowPositionsInCancelMenuOption.getValue()) {
			if (Model != null && Model.Book != null) {
				for (Bookmark bookmark : Bookmark.invisibleBookmarks(Model.Book)) {
					myCancelActionsList.add(new BookmarkDescription(bookmark));
				}
			}
		}
		myCancelActionsList.add(new CancelActionDescription(
			CancelActionType.close, null
		));
		return myCancelActionsList;
	}

	public void runCancelAction(int index) {
		if (index < 0 || index >= myCancelActionsList.size()) {
			return;
		}

		final CancelActionDescription description = myCancelActionsList.get(index);
		switch (description.Type) {
			case previousBook:
				openBook(Library.getPreviousBook(), null);
				break;
			case returnTo:
			{
				final Bookmark b = ((BookmarkDescription)description).Bookmark;
				b.delete();
				gotoBookmark(b);
				break;
			}
			case close:
				closeWindow();
				break;
		}
	}

	private void updateInvisibleBookmarksList(Bookmark b) {
		if (Model.Book != null && b != null) {
			for (Bookmark bm : Bookmark.invisibleBookmarks(Model.Book)) {
				if (b.equals(bm)) {
					bm.delete();
				}
			}
			b.save();
			final List<Bookmark> bookmarks = Bookmark.invisibleBookmarks(Model.Book);
			for (int i = 3; i < bookmarks.size(); ++i) {
				bookmarks.get(i).delete();
			}
		}
	}

	public void addInvisibleBookmark(ZLTextWordCursor cursor) {
		if (cursor != null && Model != null && Model.Book != null && getTextView() == BookTextView) {
			updateInvisibleBookmarksList(new Bookmark(
				Model.Book,
				getTextView().getModel().getId(),
				cursor,
				6,
				false
			));
		}
	}

	public void addInvisibleBookmark() {
		if (Model.Book != null && getTextView() == BookTextView) {
			updateInvisibleBookmarksList(addBookmark(6, false));
		}
	}

	public Bookmark addBookmark(int maxLength, boolean visible) {
		final FBView view = getTextView();
		final ZLTextWordCursor cursor = view.getStartCursor();

		if (cursor.isNull()) {
			return null;
		}

		return new Bookmark(
			Model.Book,
			view.getModel().getId(),
			cursor,
			maxLength,
			visible
		);
	}
}
",True,275,5,30,6,76,42,34,L5
81,org.geometerplus.fbreader.fbreader.TurnPageAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class TurnPageAction extends FBAction {
	private final boolean myForward;

	TurnPageAction(FBReaderApp fbreader, boolean forward) {
		super(fbreader);
		myForward = forward;
	}

	public boolean isEnabled() {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();

		final ScrollingPreferences.FingerScrolling fingerScrolling =
			preferences.FingerScrollingOption.getValue();
		return
			fingerScrolling == ScrollingPreferences.FingerScrolling.byTap ||
			fingerScrolling == ScrollingPreferences.FingerScrolling.byTapAndFlick;
	}

	public void run() {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();
		Reader.getViewWidget().startAnimatedScrolling(
			myForward ? FBView.PageIndex.next : FBView.PageIndex.previous,
			preferences.HorizontalOption.getValue()
				? FBView.Direction.rightToLeft : FBView.Direction.up,
			preferences.AnimationSpeedOption.getValue()
		);
	}

	public void runWithCoordinates(int x, int y) {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();
		Reader.getViewWidget().startAnimatedScrolling(
			myForward ? FBView.PageIndex.next : FBView.PageIndex.previous,
			x, y,
			preferences.HorizontalOption.getValue()
				? FBView.Direction.rightToLeft : FBView.Direction.up,
			preferences.AnimationSpeedOption.getValue()
		);
	}
}
",False,216,0,0,7,72,1,9,L5
82,org.geometerplus.fbreader.fbreader.ChangeFontSizeAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;
import org.geometerplus.zlibrary.text.view.style.ZLTextStyleCollection;

class ChangeFontSizeAction extends FBAction {
	private final int myDelta;

	ChangeFontSizeAction(FBReaderApp fbreader, int delta) {
		super(fbreader);
		myDelta = delta;
	}

	public void run() {
		ZLIntegerRangeOption option =
			ZLTextStyleCollection.Instance().getBaseStyle().FontSizeOption;
		option.setValue(option.getValue() + myDelta);
		Reader.clearTextCaches();
		Reader.getViewWidget().repaint();
	}
}
",False,216,0,0,7,71,1,7,L5
83,org.geometerplus.fbreader.fbreader.WallpapersUtil.java,"/*
 * Copyright (C) 2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.List;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.Paths;

public abstract class WallpapersUtil {
	public static List<ZLFile> predefinedWallpaperFiles() {
		return ZLFile.createFileByPath(""wallpapers"").children();
	}

	public static List<ZLFile> externalWallpaperFiles() {
		return ZLFile.createFileByPath(Paths.WallpapersDirectoryOption().getValue()).children();
	}
}
",False,78,8,27,5,6,1,3,L6
84,org.geometerplus.fbreader.fbreader.WordCountTraverser.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.text.view.*;

class WordCountTraverser extends ZLTextTraverser {
	protected int myCount;

	WordCountTraverser(ZLTextView view) {
		super(view);
	}

	@Override
	protected void processWord(ZLTextWord word) {
		++myCount;
	}

	@Override
	protected void processControlElement(ZLTextControlElement control) {
		// does nothing
	}

	@Override
	protected void processSpace() {
		// does nothing
	}

	@Override
	protected void processEndOfParagraph() {
		// does nothing
	}

	public int getCount() {
		return myCount;
	}
}
",False,173,7,35,6,35,1,4,L5
85,org.geometerplus.fbreader.fbreader.TextBuildTraverser.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.text.view.*;

class TextBuildTraverser extends ZLTextTraverser {
	protected final StringBuilder myBuffer = new StringBuilder();

	TextBuildTraverser(ZLTextView view) {
		super(view);
	}

	@Override
	protected void processWord(ZLTextWord word) {
		myBuffer.append(word.Data, word.Offset, word.Length);
	}

	@Override
	protected void processControlElement(ZLTextControlElement control) {
		// does nothing
	}

	@Override
	protected void processSpace() {
		myBuffer.append("" "");
	}

	@Override
	protected void processEndOfParagraph() {
		myBuffer.append(""\n"");
	}

	public String getText() {
		return myBuffer.toString();
	}
}
",False,173,7,35,6,35,1,4,L5
86,org.geometerplus.fbreader.fbreader.ClearFindResultsAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class ClearFindResultsAction extends FBAction {
	ClearFindResultsAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public void run() {
		Reader.getTextView().clearFindResults();
	}
}
",False,216,0,0,7,60,1,3,L5
87,org.geometerplus.fbreader.fbreader.SelectionClearAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

public class SelectionClearAction extends FBAction {
	SelectionClearAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	@Override
	protected void run() {
		Reader.getTextView().clearSelection();
	}
}
",False,216,0,0,7,60,1,3,L5
88,org.geometerplus.fbreader.fbreader.FindPreviousAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.text.view.ZLTextView;

class FindPreviousAction extends FBAction {
	FindPreviousAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public boolean isEnabled() {
		ZLTextView view = Reader.getTextView();
		return (view != null) && view.canFindPrevious();
	}

	public void run() {
		Reader.getTextView().findPrevious();
	}
}
",False,216,0,0,7,60,1,3,L5
89,org.geometerplus.fbreader.fbreader.FBView.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.view.ZLPaintContext;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;

import org.geometerplus.zlibrary.text.model.ZLTextModel;
import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.bookmodel.FBHyperlinkType;
import org.geometerplus.fbreader.bookmodel.TOCTree;

public final class FBView extends ZLTextView {
	private FBReaderApp myReader;

	FBView(FBReaderApp reader) {
		super(reader);
		myReader = reader;
	}

	public void setModel(ZLTextModel model) {
		super.setModel(model);
		if (myFooter != null) {
			myFooter.resetTOCMarks();
		}
	}

	private int myStartY;
	private boolean myIsBrightnessAdjustmentInProgress;
	private int myStartBrightness;

	private String myZoneMapId;
	private TapZoneMap myZoneMap;

	private TapZoneMap getZoneMap() {
		//final String id =
		//	ScrollingPreferences.Instance().TapZonesSchemeOption.getValue().toString();
		final String id =
			ScrollingPreferences.Instance().HorizontalOption.getValue()
				? ""right_to_left"" : ""up"";
		if (!id.equals(myZoneMapId)) {
			myZoneMap = new TapZoneMap(id);
			myZoneMapId = id;
		}
		return myZoneMap;
	}

	public boolean onFingerSingleTap(int x, int y) {
		if (super.onFingerSingleTap(x, y)) {
			return true;
		}

		final ZLTextRegion region = findRegion(x, y, MAX_SELECTION_DISTANCE, ZLTextRegion.HyperlinkFilter);
		if (region != null) {
			selectRegion(region);
			myReader.getViewWidget().reset();
			myReader.getViewWidget().repaint();
			myReader.doAction(ActionCode.PROCESS_HYPERLINK);
			return true;
		}

		myReader.doActionWithCoordinates(getZoneMap().getActionByCoordinates(
			x, y, myContext.getWidth(), myContext.getHeight(),
			isDoubleTapSupported() ? TapZoneMap.Tap.singleNotDoubleTap : TapZoneMap.Tap.singleTap
		), x, y);

		return true;
	}

	@Override
	public boolean isDoubleTapSupported() {
		return myReader.EnableDoubleTapOption.getValue();
	}

	@Override
	public boolean onFingerDoubleTap(int x, int y) {
		if (super.onFingerDoubleTap(x, y)) {
			return true;
		}
		myReader.doActionWithCoordinates(getZoneMap().getActionByCoordinates(
			x, y, myContext.getWidth(), myContext.getHeight(), TapZoneMap.Tap.doubleTap
		), x, y);
		return true;
	}

	public boolean onFingerPress(int x, int y) {
		if (super.onFingerPress(x, y)) {
			return true;
		}

		final ZLTextSelectionCursor cursor = findSelectionCursor(x, y, MAX_SELECTION_DISTANCE);
		if (cursor != ZLTextSelectionCursor.None) {
			myReader.doAction(ActionCode.SELECTION_HIDE_PANEL);
			moveSelectionCursorTo(cursor, x, y);
			return true;
		}

		if (myReader.AllowScreenBrightnessAdjustmentOption.getValue() && x < myContext.getWidth() / 10) {
			myIsBrightnessAdjustmentInProgress = true;
			myStartY = y;
			myStartBrightness = ZLibrary.Instance().getScreenBrightness();
			return true;
		}

		startManualScrolling(x, y);
		return true;
	}

	private boolean isFlickScrollingEnabled() {
		final ScrollingPreferences.FingerScrolling fingerScrolling =
			ScrollingPreferences.Instance().FingerScrollingOption.getValue();
		return
			fingerScrolling == ScrollingPreferences.FingerScrolling.byFlick ||
			fingerScrolling == ScrollingPreferences.FingerScrolling.byTapAndFlick;
	}

	private void startManualScrolling(int x, int y) {
		if (!isFlickScrollingEnabled()) {
			return;
		}

		final boolean horizontal = ScrollingPreferences.Instance().HorizontalOption.getValue();
		final Direction direction = horizontal ? Direction.rightToLeft : Direction.up;
		myReader.getViewWidget().startManualScrolling(x, y, direction);
	}

	public boolean onFingerMove(int x, int y) {
		if (super.onFingerMove(x, y)) {
			return true;
		}

		final ZLTextSelectionCursor cursor = getSelectionCursorInMovement();
		if (cursor != ZLTextSelectionCursor.None) {
			moveSelectionCursorTo(cursor, x, y);
			return true;
		}

		synchronized (this) {
			if (myIsBrightnessAdjustmentInProgress) {
				if (x >= myContext.getWidth() / 5) {
					myIsBrightnessAdjustmentInProgress = false;
					startManualScrolling(x, y);
				} else {
					final int delta = (myStartBrightness + 30) * (myStartY - y) / myContext.getHeight();
					ZLibrary.Instance().setScreenBrightness(myStartBrightness + delta);
					return true;
				}
			}

			if (isFlickScrollingEnabled()) {
				myReader.getViewWidget().scrollManuallyTo(x, y);
			}
		}
		return true;
	}

	public boolean onFingerRelease(int x, int y) {
		if (super.onFingerRelease(x, y)) {
			return true;
		}

		final ZLTextSelectionCursor cursor = getSelectionCursorInMovement();
		if (cursor != ZLTextSelectionCursor.None) {
			releaseSelectionCursor();
			return true;
		}

		if (myIsBrightnessAdjustmentInProgress) {
			myIsBrightnessAdjustmentInProgress = false;
			return true;
		}

		if (isFlickScrollingEnabled()) {
			myReader.getViewWidget().startAnimatedScrolling(
				x, y, ScrollingPreferences.Instance().AnimationSpeedOption.getValue()
			);
			return true;
		}

		return true;
	}

	public boolean onFingerLongPress(int x, int y) {
		if (super.onFingerLongPress(x, y)) {
			return true;
		}

		final ZLTextRegion region = findRegion(x, y, MAX_SELECTION_DISTANCE, ZLTextRegion.AnyRegionFilter);
		if (region != null) {
			final ZLTextRegion.Soul soul = region.getSoul();
			boolean doSelectRegion = false;
			if (soul instanceof ZLTextWordRegionSoul) {
				switch (myReader.WordTappingActionOption.getValue()) {
					case startSelecting:
						myReader.doAction(ActionCode.SELECTION_HIDE_PANEL);
						initSelection(x, y);
						final ZLTextSelectionCursor cursor = findSelectionCursor(x, y);
						if (cursor != ZLTextSelectionCursor.None) {
							moveSelectionCursorTo(cursor, x, y);
						}
						return true;
					case selectSingleWord:
					case openDictionary:
						doSelectRegion = true;
						break;
				}
			} else if (soul instanceof ZLTextImageRegionSoul) {
				doSelectRegion =
					myReader.ImageTappingActionOption.getValue() !=
					FBReaderApp.ImageTappingAction.doNothing;
			} else if (soul instanceof ZLTextHyperlinkRegionSoul) {
				doSelectRegion = true;
			}
        
			if (doSelectRegion) {
				selectRegion(region);
				myReader.getViewWidget().reset();
				myReader.getViewWidget().repaint();
				return true;
			}
		}

		return false;
	}

	public boolean onFingerMoveAfterLongPress(int x, int y) {
		if (super.onFingerMoveAfterLongPress(x, y)) {
			return true;
		}

		final ZLTextSelectionCursor cursor = getSelectionCursorInMovement();
		if (cursor != ZLTextSelectionCursor.None) {
			moveSelectionCursorTo(cursor, x, y);
			return true;
		}

		ZLTextRegion region = getSelectedRegion();
		if (region != null) {
			ZLTextRegion.Soul soul = region.getSoul();
			if (soul instanceof ZLTextHyperlinkRegionSoul ||
				soul instanceof ZLTextWordRegionSoul) {
				if (myReader.WordTappingActionOption.getValue() !=
					FBReaderApp.WordTappingAction.doNothing) {
					region = findRegion(x, y, MAX_SELECTION_DISTANCE, ZLTextRegion.AnyRegionFilter);
					if (region != null) {
						soul = region.getSoul();
						if (soul instanceof ZLTextHyperlinkRegionSoul
							 || soul instanceof ZLTextWordRegionSoul) {
							selectRegion(region);
							myReader.getViewWidget().reset();
							myReader.getViewWidget().repaint();
						}
					}
				}
			}
		}
		return true;
	}

	public boolean onFingerReleaseAfterLongPress(int x, int y) {
		if (super.onFingerReleaseAfterLongPress(x, y)) {
			return true;
		}

		final ZLTextSelectionCursor cursor = getSelectionCursorInMovement();
		if (cursor != ZLTextSelectionCursor.None) {
			releaseSelectionCursor();
			return true;
		}

		final ZLTextRegion region = getSelectedRegion();
		if (region != null) {
			final ZLTextRegion.Soul soul = region.getSoul();

			boolean doRunAction = false;
			if (soul instanceof ZLTextWordRegionSoul) {
				doRunAction =
					myReader.WordTappingActionOption.getValue() ==
					FBReaderApp.WordTappingAction.openDictionary;
			} else if (soul instanceof ZLTextImageRegionSoul) {
				doRunAction =
					myReader.ImageTappingActionOption.getValue() ==
					FBReaderApp.ImageTappingAction.openImageView;
			}

			if (doRunAction) {
				myReader.doAction(ActionCode.PROCESS_HYPERLINK);
				return true;
			}
		}

		return false;
	}

	public boolean onTrackballRotated(int diffX, int diffY) {
		if (diffX == 0 && diffY == 0) {
			return true;
		}

		final Direction direction = (diffY != 0) ?
			(diffY > 0 ? Direction.down : Direction.up) :
			(diffX > 0 ? Direction.leftToRight : Direction.rightToLeft);

		ZLTextRegion region = getSelectedRegion();
		final ZLTextRegion.Filter filter =
			(region != null && region.getSoul() instanceof ZLTextWordRegionSoul)
				|| myReader.NavigateAllWordsOption.getValue()
					? ZLTextRegion.AnyRegionFilter : ZLTextRegion.ImageOrHyperlinkFilter;
		region = nextRegion(direction, filter);
		if (region != null) {
			selectRegion(region);
		} else {
			if (direction == Direction.down) {
				scrollPage(true, ZLTextView.ScrollingMode.SCROLL_LINES, 1);
			} else if (direction == Direction.up) {
				scrollPage(false, ZLTextView.ScrollingMode.SCROLL_LINES, 1);
			}
		}

		myReader.getViewWidget().reset();
		myReader.getViewWidget().repaint();

		return true;
	}

	@Override
	public int getLeftMargin() {
		return myReader.LeftMarginOption.getValue();
	}

	@Override
	public int getRightMargin() {
		return myReader.RightMarginOption.getValue();
	}

	@Override
	public int getTopMargin() {
		return myReader.TopMarginOption.getValue();
	}

	@Override
	public int getBottomMargin() {
		return myReader.BottomMarginOption.getValue();
	}

	@Override
	public ZLFile getWallpaperFile() {
		final String filePath = myReader.getColorProfile().WallpaperOption.getValue();
		if ("""".equals(filePath)) {
			return null;
		}
		
		final ZLFile file = ZLFile.createFileByPath(filePath);
		if (file == null || !file.exists()) {
			return null;
		}
		return file;
	}

	@Override
	public ZLColor getBackgroundColor() {
		return myReader.getColorProfile().BackgroundOption.getValue();
	}

	@Override
	public ZLColor getSelectedBackgroundColor() {
		return myReader.getColorProfile().SelectionBackgroundOption.getValue();
	}

	@Override
	public ZLColor getSelectedForegroundColor() {
		return myReader.getColorProfile().SelectionForegroundOption.getValue();
	}

	@Override
	public ZLColor getTextColor(ZLTextHyperlink hyperlink) {
		final ColorProfile profile = myReader.getColorProfile();
		switch (hyperlink.Type) {
			default:
			case FBHyperlinkType.NONE:
				return profile.RegularTextOption.getValue();
			case FBHyperlinkType.INTERNAL:
				return myReader.Model.Book.isHyperlinkVisited(hyperlink.Id)
					? profile.VisitedHyperlinkTextOption.getValue()
					: profile.HyperlinkTextOption.getValue();
			case FBHyperlinkType.EXTERNAL:
				return profile.HyperlinkTextOption.getValue();
		}
	}

	@Override
	public ZLColor getHighlightingColor() {
		return myReader.getColorProfile().HighlightingOption.getValue();
	}

	private class Footer implements FooterArea {
		private Runnable UpdateTask = new Runnable() {
			public void run() {
				myReader.getViewWidget().repaint();
			}
		};

		private ArrayList<TOCTree> myTOCMarks;

		public int getHeight() {
			return myReader.FooterHeightOption.getValue();
		}

		public synchronized void resetTOCMarks() {
			myTOCMarks = null;
		}

		private final int MAX_TOC_MARKS_NUMBER = 100;
		private synchronized void updateTOCMarks(BookModel model) {
			myTOCMarks = new ArrayList<TOCTree>();
			TOCTree toc = model.TOCTree;
			if (toc == null) {
				return;
			}
			int maxLevel = Integer.MAX_VALUE;
			if (toc.getSize() >= MAX_TOC_MARKS_NUMBER) {
				final int[] sizes = new int[10];
				for (TOCTree tocItem : toc) {
					if (tocItem.Level < 10) {
						++sizes[tocItem.Level];
					}
				}
				for (int i = 1; i < sizes.length; ++i) {
					sizes[i] += sizes[i - 1];
				}
				for (maxLevel = sizes.length - 1; maxLevel >= 0; --maxLevel) {
					if (sizes[maxLevel] < MAX_TOC_MARKS_NUMBER) {
						break;
					}
				}
			}
			for (TOCTree tocItem : toc.allSubTrees(maxLevel)) {
				myTOCMarks.add(tocItem);
			}
		}

		public synchronized void paint(ZLPaintContext context) {
			final FBReaderApp reader = myReader;
			if (reader == null) {
				return;
			}
			final BookModel model = reader.Model;
			if (model == null) {
				return;
			}

			//final ZLColor bgColor = getBackgroundColor();
			// TODO: separate color option for footer color
			final ZLColor fgColor = getTextColor(ZLTextHyperlink.NO_LINK);
			final ZLColor fillColor = reader.getColorProfile().FooterFillOption.getValue();

			final int left = getLeftMargin();
			final int right = context.getWidth() - getRightMargin();
			final int height = getHeight();
			final int lineWidth = height <= 10 ? 1 : 2;
			final int delta = height <= 10 ? 0 : 1;
			context.setFont(
				reader.FooterFontOption.getValue(),
				height <= 10 ? height + 3 : height + 1,
				height > 10, false, false
			);

			final int pagesProgress = computeCurrentPage();
			final int bookLength = computePageNumber();

			final StringBuilder info = new StringBuilder();
			if (reader.FooterShowProgressOption.getValue()) {
				info.append(pagesProgress);
				info.append(""/"");
				info.append(bookLength);
			}
			if (reader.FooterShowBatteryOption.getValue()) {
				if (info.length() > 0) {
					info.append("" "");
				}
				info.append(reader.getBatteryLevel());
				info.append(""%"");
			}
			if (reader.FooterShowClockOption.getValue()) {
				if (info.length() > 0) {
					info.append("" "");
				}
				info.append(ZLibrary.Instance().getCurrentTimeString());
			}
			final String infoString = info.toString();

			final int infoWidth = context.getStringWidth(infoString);
			final ZLFile wallpaper = getWallpaperFile();
			if (wallpaper != null) {
				context.clear(wallpaper, wallpaper instanceof ZLResourceFile);
			} else {
				context.clear(getBackgroundColor());
			}

			// draw info text
			context.setTextColor(fgColor);
			context.drawString(right - infoWidth, height - delta, infoString);

			// draw gauge
			final int gaugeRight = right - (infoWidth == 0 ? 0 : infoWidth + 10);
			myGaugeWidth = gaugeRight - left - 2 * lineWidth;

			context.setLineColor(fgColor);
			context.setLineWidth(lineWidth);
			context.drawLine(left, lineWidth, left, height - lineWidth);
			context.drawLine(left, height - lineWidth, gaugeRight, height - lineWidth);
			context.drawLine(gaugeRight, height - lineWidth, gaugeRight, lineWidth);
			context.drawLine(gaugeRight, lineWidth, left, lineWidth);

			final int gaugeInternalRight =
				left + lineWidth + (int)(1.0 * myGaugeWidth * pagesProgress / bookLength);

			context.setFillColor(fillColor);
			context.fillRectangle(left + 1, height - 2 * lineWidth, gaugeInternalRight, lineWidth + 1);

			if (reader.FooterShowTOCMarksOption.getValue()) {
				if (myTOCMarks == null) {
					updateTOCMarks(model);
				}
				final int fullLength = sizeOfFullText();
				for (TOCTree tocItem : myTOCMarks) {
					TOCTree.Reference reference = tocItem.getReference();
					if (reference != null) {
						final int refCoord = sizeOfTextBeforeParagraph(reference.ParagraphIndex);
						final int xCoord =
							left + 2 * lineWidth + (int)(1.0 * myGaugeWidth * refCoord / fullLength);
						context.drawLine(xCoord, height - lineWidth, xCoord, lineWidth);
					}
				}
			}
		}

		// TODO: remove
		int myGaugeWidth = 1;
		/*public int getGaugeWidth() {
			return myGaugeWidth;
		}*/

		/*public void setProgress(int x) {
			// set progress according to tap coordinate
			int gaugeWidth = getGaugeWidth();
			float progress = 1.0f * Math.min(x, gaugeWidth) / gaugeWidth;
			int page = (int)(progress * computePageNumber());
			if (page <= 1) {
				gotoHome();
			} else {
				gotoPage(page);
			}
			myReader.getViewWidget().reset();
			myReader.getViewWidget().repaint();
		}*/
	}

	private Footer myFooter;

	@Override
	public Footer getFooterArea() {
		if (myReader.ScrollbarTypeOption.getValue() == SCROLLBAR_SHOW_AS_FOOTER) {
			if (myFooter == null) {
				myFooter = new Footer();
				myReader.addTimerTask(myFooter.UpdateTask, 15000);
			}
		} else {
			if (myFooter != null) {
				myReader.removeTimerTask(myFooter.UpdateTask);
				myFooter = null;
			}
		}
		return myFooter;
	}

	@Override
	protected void releaseSelectionCursor() {
		super.releaseSelectionCursor();
		if (getCountOfSelectedWords() > 0) {
			myReader.doAction(ActionCode.SELECTION_SHOW_PANEL);
		}
	}

	public String getSelectedText() {
		final TextBuildTraverser traverser = new TextBuildTraverser(this);
		if (!isSelectionEmpty()) {
			traverser.traverse(getSelectionStartPosition(), getSelectionEndPosition());
		}
		return traverser.getText();
	}

	public int getCountOfSelectedWords() {
		final WordCountTraverser traverser = new WordCountTraverser(this);
		if (!isSelectionEmpty()) {
			traverser.traverse(getSelectionStartPosition(), getSelectionEndPosition());
		}
		return traverser.getCount();
	}

	public static final int SCROLLBAR_SHOW_AS_FOOTER = 3;

	@Override
	public int scrollbarType() {
		return myReader.ScrollbarTypeOption.getValue();
	}

	@Override
	public Animation getAnimationType() {
		return ScrollingPreferences.Instance().AnimationOption.getValue();
	}
}
",True,271,6,23,6,66,7,34,L5
90,org.geometerplus.fbreader.fbreader.RotateAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class RotateAction extends FBAction {
	RotateAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public void run() {
		Reader.rotateScreen();
	}

	public boolean isVisible() {
		return Reader.canRotateScreen();
	}
}
",False,216,0,0,7,74,1,3,L5
91,org.geometerplus.fbreader.fbreader.ColorProfile.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.options.*;

public class ColorProfile {
	public static final String DAY = ""defaultLight"";
	public static final String NIGHT = ""defaultDark"";

	private static final ArrayList<String> ourNames = new ArrayList<String>();
	private static final HashMap<String,ColorProfile> ourProfiles = new HashMap<String,ColorProfile>();

	public static List<String> names() {
		if (ourNames.isEmpty()) {
			final int size = new ZLIntegerOption(""Colors"", ""NumberOfSchemes"", 0).getValue();
			if (size == 0) {
				ourNames.add(DAY);
				ourNames.add(NIGHT);
			} else for (int i = 0; i < size; ++i) {
				ourNames.add(new ZLStringOption(""Colors"", ""Scheme"" + i, """").getValue());
			}
		}
		return Collections.unmodifiableList(ourNames);
	}

	public static ColorProfile get(String name) {
		ColorProfile profile = ourProfiles.get(name);
		if (profile == null) {
			profile = new ColorProfile(name);
			ourProfiles.put(name, profile);
		}
		return profile;
	}

	public final ZLStringOption WallpaperOption;
	public final ZLColorOption BackgroundOption;
	public final ZLColorOption SelectionBackgroundOption;
	public final ZLColorOption SelectionForegroundOption;
	public final ZLColorOption HighlightingOption;
	public final ZLColorOption RegularTextOption;
	public final ZLColorOption HyperlinkTextOption;
	public final ZLColorOption VisitedHyperlinkTextOption;
	public final ZLColorOption FooterFillOption;

	private ColorProfile(String name, ColorProfile base) {
		this(name);
		BackgroundOption.setValue(base.BackgroundOption.getValue());
		SelectionBackgroundOption.setValue(base.SelectionBackgroundOption.getValue());
		SelectionForegroundOption.setValue(base.SelectionForegroundOption.getValue());
		HighlightingOption.setValue(base.HighlightingOption.getValue());
		RegularTextOption.setValue(base.RegularTextOption.getValue());
		HyperlinkTextOption.setValue(base.HyperlinkTextOption.getValue());
		VisitedHyperlinkTextOption.setValue(base.VisitedHyperlinkTextOption.getValue());
		FooterFillOption.setValue(base.FooterFillOption.getValue());
	}

	private static ZLColorOption createOption(String profileName, String optionName, int r, int g, int b) {
		return new ZLColorOption(""Colors"", profileName + ':' + optionName, new ZLColor(r, g, b));
	}

	private ColorProfile(String name) {
		if (NIGHT.equals(name)) {
			WallpaperOption =
				new ZLStringOption(""Colors"", name + "":Wallpaper"", """");
			BackgroundOption =
				createOption(name, ""Background"", 0, 0, 0);
			SelectionBackgroundOption =
				createOption(name, ""SelectionBackground"", 82, 131, 194);
			SelectionForegroundOption =
				createOption(name, ""SelectionForeground"", 255, 255, 220);
			HighlightingOption =
				createOption(name, ""Highlighting"", 96, 96, 128);
			RegularTextOption =
				createOption(name, ""Text"", 192, 192, 192);
			HyperlinkTextOption =
				createOption(name, ""Hyperlink"", 60, 142, 224);
			VisitedHyperlinkTextOption =
				createOption(name, ""VisitedHyperlink"", 200, 139, 255);
			FooterFillOption =
				createOption(name, ""FooterFillOption"", 85, 85, 85);
		} else {
			WallpaperOption =
				new ZLStringOption(""Colors"", name + "":Wallpaper"", ""wallpapers/sepia.jpg"");
			BackgroundOption =
				createOption(name, ""Background"", 255, 255, 255);
			SelectionBackgroundOption =
				createOption(name, ""SelectionBackground"", 82, 131, 194);
			SelectionForegroundOption =
				createOption(name, ""SelectionForeground"", 255, 255, 220);
			HighlightingOption =
				createOption(name, ""Highlighting"", 255, 192, 128);
			RegularTextOption =
				createOption(name, ""Text"", 0, 0, 0);
			HyperlinkTextOption =
				createOption(name, ""Hyperlink"", 60, 139, 255);
			VisitedHyperlinkTextOption =
				createOption(name, ""VisitedHyperlink"", 200, 139, 255);
			FooterFillOption =
				createOption(name, ""FooterFillOption"", 170, 170, 170);
		}
	}
}
",True,80,6,40,3,4,4,4,L5
92,org.geometerplus.fbreader.fbreader.VolumeKeyTurnPageAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class VolumeKeyTurnPageAction extends FBAction {
	private final boolean myForward;

	VolumeKeyTurnPageAction(FBReaderApp fbreader, boolean forward) {
		super(fbreader);
		myForward = forward;
	}

	public boolean isEnabled() {
		return ScrollingPreferences.Instance().VolumeKeysOption.getValue();
	}

	public void run() {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();

		boolean forward = myForward;
		if (preferences.InvertVolumeKeysOption.getValue()) {
			forward = !forward;
		}

		Reader.getViewWidget().startAnimatedScrolling(
			forward ? FBView.PageIndex.next : FBView.PageIndex.previous,
			preferences.HorizontalOption.getValue()
				? FBView.Direction.rightToLeft : FBView.Direction.up,
			preferences.AnimationSpeedOption.getValue()
		);
	}
}
",False,216,0,0,7,72,1,8,L5
93,org.geometerplus.fbreader.fbreader.SwitchProfileAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class SwitchProfileAction extends FBAction {
	private String myProfileName;

	SwitchProfileAction(FBReaderApp fbreader, String profileName) {
		super(fbreader);
		myProfileName = profileName;
	}

	public boolean isVisible() {
		return !myProfileName.equals(Reader.getColorProfileName());
	}

	public void run() {
		Reader.setColorProfileName(myProfileName);
		Reader.getViewWidget().reset();
		Reader.getViewWidget().repaint();
	}
}
",False,216,0,0,7,74,1,4,L5
94,org.geometerplus.fbreader.network.NetworkItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.fbreader.network.urlInfo.UrlInfo;
import org.geometerplus.fbreader.network.urlInfo.UrlInfoCollection;

public abstract class NetworkItem {
	public final INetworkLink Link;
	public final CharSequence Title;

	private CharSequence mySummary;
	private final UrlInfoCollection<UrlInfo> myURLs;

	/**
	 * Creates new NetworkItem instance.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param urls       collection of item-related urls (like icon link, opds catalog link, etc. Can be <code>null</code>.
	 */
	protected NetworkItem(INetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls) {
		Link = link;
		Title = title != null ? title : """";
		setSummary(summary);
		if (urls != null && !urls.isEmpty()) {
 			myURLs = new UrlInfoCollection<UrlInfo>(urls);
		} else {
			myURLs = null;
		}
	}

	protected void setSummary(CharSequence summary) {
		mySummary = summary;
	}

	public final CharSequence getSummary() {
		return mySummary;
	}

	protected void addUrls(UrlInfoCollection<?> urls) {
		myURLs.upgrade(urls);
	}

	public List<UrlInfo> getAllInfos() {
		if (myURLs == null) {
			return Collections.emptyList();
		}
		return myURLs.getAllInfos();
	}

	public List<UrlInfo> getAllInfos(UrlInfo.Type type) {
		if (myURLs == null) {
			return Collections.emptyList();
		}
		return myURLs.getAllInfos(type);
	}

	public String getUrl(UrlInfo.Type type) {
		if (myURLs == null) {
			return null;
		}
		return myURLs.getUrl(type);
	}

	public String getImageUrl() {
		if (myURLs == null) {
			return null;
		}
		final String cover = myURLs.getUrl(UrlInfo.Type.Image);
		return cover != null ? cover : myURLs.getUrl(UrlInfo.Type.Thumbnail);
	}
}
",False,196,7,26,12,33,32,3,L6
95,org.geometerplus.fbreader.network.Base64EncodedImage.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.*;

import org.geometerplus.zlibrary.core.image.ZLBase64EncodedImage;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.fbreader.Paths;

final class Base64EncodedImage extends ZLBase64EncodedImage {
	private static final String ENCODED_SUFFIX = "".base64"";

	private String myDecodedFileName;

	public Base64EncodedImage(MimeType mimeType) {
		super(mimeType);
		new File(makeImagesDir()).mkdirs();
	}

	public static String makeImagesDir() {
		return Paths.networkCacheDirectory() + ""/base64"";
	}

	public void setData(String data) {
		myDecodedFileName = makeImagesDir() + File.separator + Integer.toHexString(data.hashCode());
		final MimeType type = mimeType();
		if (MimeType.IMAGE_PNG.equals(type)) {
			myDecodedFileName += "".png"";
		} else if (MimeType.IMAGE_JPEG.equals(type)) {
			myDecodedFileName += "".jpg"";
		}

		if (isCacheValid(new File(myDecodedFileName))) {
			return;
		}

		File file = new File(encodedFileName());
		if (isCacheValid(file)) {
			return;
		}
		try {
			final OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), ""UTF-8"");
			try {
				writer.write(data, 0, data.length());
			} finally {
				writer.close();
			}
		} catch (IOException e) {
		}
	}

	@Override
	protected boolean isCacheValid(File file) {
		if (file.exists()) {
			final long diff = System.currentTimeMillis() - file.lastModified();
			final long valid = 24 * 60 * 60 * 1000; // one day in milliseconds; FIXME: hardcoded const
			if (diff >= 0 && diff <= valid) {
				return true;
			}
			file.delete();
		}
		return false;
	}

	@Override
	protected String encodedFileName() {
		return myDecodedFileName + ENCODED_SUFFIX;
	}

	@Override
	protected String decodedFileName() {
		return myDecodedFileName;
	}
}
",True,133,9,28,7,6,1,4,L6
96,org.geometerplus.fbreader.network.NetworkTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;
import java.io.Serializable;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

import org.geometerplus.fbreader.tree.FBTree;

public abstract class NetworkTree extends FBTree {
	public static class Key implements Serializable {
		private static final long serialVersionUID = -6500763093522202052L;

		final Key Parent;
		final String Id;

		private Key(Key parent, String id) {
			if (id == null) {
				throw new IllegalArgumentException(""NetworkTree string id must be non-null"");
			}
			Parent = parent;
			Id = id;
		}

		@Override
		public boolean equals(Object other) {
			if (other == this) {
				return true;
			}
			if (!(other instanceof NetworkTree.Key)) {
				return false;
			}
			final NetworkTree.Key key = (NetworkTree.Key)other;
			return Id.equals(key.Id) && ZLMiscUtil.equals(Parent, key.Parent);
		}

		@Override
		public int hashCode() {
			return Id.hashCode();
		}

		@Override
		public String toString() {
			return Parent == null ? Id : Parent.toString() + "" :: "" + Id;
		}
	}

	private Key myKey;
	private Map<String,Object> myUserData;

	protected NetworkTree() {
		super();
	}

	protected NetworkTree(NetworkTree parent) {
		super(parent);
	}

	protected NetworkTree(NetworkTree parent, int position) {
		super(parent, position);
	}

	public static ZLImage createCover(NetworkItem item) {
		final String imageUrl = item.getImageUrl();
		if (imageUrl == null) {
			return null;
		}
		return createCover(imageUrl, null);
	}

	private static final String DATA_PREFIX = ""data:"";

	public static ZLImage createCover(String url, MimeType mimeType) {
		if (url == null) {
			return null;
		}
		if (mimeType == null) {
			mimeType = MimeType.IMAGE_AUTO;
		}
		if (url.startsWith(""http://"") || url.startsWith(""https://"") || url.startsWith(""ftp://"")) {
			return new NetworkImage(url, mimeType);
		} else if (url.startsWith(DATA_PREFIX)) {
			int commaIndex = url.indexOf(',');
			if (commaIndex == -1) {
				return null;
			}
			if (mimeType == MimeType.IMAGE_AUTO) {
				int index = url.indexOf(';');
				if (index == -1 || index > commaIndex) {
					index = commaIndex;
				}
	 			// string starts with ""data:image/""
				if (url.startsWith(MimeType.IMAGE_PREFIX, DATA_PREFIX.length())) {
					mimeType = MimeType.get(url.substring(DATA_PREFIX.length(), index));
				}
			}
			int key = url.indexOf(""base64"");
			if (key != -1 && key < commaIndex) {
				Base64EncodedImage img = new Base64EncodedImage(mimeType);
				img.setData(url.substring(commaIndex + 1));
				return img;
			}
		}
		return null;
	}

	public abstract NetworkItem getHoldedItem();

	/**
	 * Returns unique identifier which can be used in NetworkView methods
	 * @return unique Key instance
	 */
	public final Key getUniqueKey() {
		if (myKey == null) {
			//final ZLTree parentTree = getParent();
			final Key parentKey = Parent instanceof NetworkTree ?
				((NetworkTree)Parent).getUniqueKey() : null;
			myKey = new Key(parentKey, getStringId());
		}
		return myKey;
	}

	public final synchronized void setUserData(String key, Object data) {
		if (myUserData == null) {
			myUserData = new HashMap<String,Object>();
		}
		if (data != null) {
			myUserData.put(key, data);
		} else {
			myUserData.remove(key);
		}
	}

	public final synchronized Object getUserData(String key) {
		return myUserData != null ? myUserData.get(key) : null;
	}

	/**
	 * Returns id used as a part of unique key above. This string must be
	 *    not null
     * and
     *    be unique for all children of same tree
	 */
	protected abstract String getStringId();

	public void removeItems(Set<NetworkItem> items) {
		if (items.isEmpty() || subTrees().isEmpty()) {
			return;
		}
		final LinkedList<FBTree> treesList = new LinkedList<FBTree>();
		for (FBTree tree: subTrees()) {
			final NetworkItem treeItem = ((NetworkTree)tree).getHoldedItem();
			if (treeItem != null && items.contains(treeItem)) {
				treesList.add(tree);
				items.remove(treeItem);
			}
		}
		for (FBTree tree: treesList) {
			tree.removeSelf();
		}
		if (items.isEmpty()) {
			return;
		}
		treesList.clear();
		treesList.addAll(subTrees());
		while (!treesList.isEmpty()) {
			final NetworkTree tree = (NetworkTree) treesList.remove(treesList.size() - 1);
			tree.removeItems(items);
		}
	}
}
",False,194,5,26,11,28,23,8,L6
97,org.geometerplus.fbreader.network.NetworkImage.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.*;
import java.net.URI;
import java.net.URISyntaxException;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.fbreader.Paths;

public final class NetworkImage extends ZLLoadableImage {
	public final String Url;

	public NetworkImage(String url, MimeType mimeType) {
		super(mimeType);
		Url = url;
		new File(Paths.networkCacheDirectory()).mkdirs();
	}

	private static final String TOESCAPE = ""<>:\""|?*\\"";

	public static String makeImageFilePath(String url, MimeType mimeType) {
		URI uri;
		try {
			uri = new URI(url);
		} catch (URISyntaxException ex) {
			return null;
		}

		String host = uri.getHost();

		StringBuilder path = new StringBuilder(host);
		if (host.startsWith(""www."")) {
			path.delete(0, 4);
		}
		path.insert(0, File.separator);
		path.insert(0, Paths.networkCacheDirectory());

		int index = path.length();

		path.append(uri.getPath());

		int nameIndex = index;
		while (index < path.length()) {
			char ch = path.charAt(index);
			if (TOESCAPE.indexOf(ch) != -1) {
				path.setCharAt(index, '_');
			}
			if (ch == '/') {
				if (index + 1 == path.length()) {
					path.deleteCharAt(index);
				} else {
					path.setCharAt(index, '_');
					nameIndex = index + 1;
				}
			}
			++index;
		}

		String ext = null;
		if (MimeType.IMAGE_PNG.equals(mimeType)) {
			ext = "".png"";
		} else if (MimeType.IMAGE_JPEG.equals(mimeType)) {
			if (path.length() > 5 && path.substring(path.length() - 5).equals("".jpeg"")) {
				ext = "".jpeg"";
			} else {
				ext = "".jpg"";
			}
		}

		if (ext == null) {
			int j = path.lastIndexOf(""."");
			if (j > nameIndex) {
				ext = path.substring(j);
				path.delete(j, path.length());
			} else {
				ext = """";
			}
		} else if (path.length() > ext.length() && path.substring(path.length() - ext.length()).equals(ext)) {
			path.delete(path.length() - ext.length(), path.length());
		}

		String query = uri.getQuery();
		if (query != null) {
			index = 0;
			while (index < query.length()) {
				int j = query.indexOf(""&"", index);
				if (j == -1) {
					j = query.length();
				}
				String param = query.substring(index, j);
				if (!param.startsWith(""username="")
					&& !param.startsWith(""password="")
					&& !param.endsWith(""="")) {
					int k = path.length();
					path.append(""_"").append(param);
					while (k < path.length()) {
						char ch = path.charAt(k);
						if (TOESCAPE.indexOf(ch) != -1 || ch == '/') {
							path.setCharAt(k, '_');
						}
						++k;
					}
				}
				index = j + 1;
			}
		}
		return path.append(ext).toString();
	}

	public String getFilePath() {
		return makeImageFilePath(Url, mimeType());
	}

	@Override
	public int sourceType() {
		return SourceType.NETWORK;
	}

	@Override
	public String getId() {
		return Url;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	@Override
	public void synchronize() {
		synchronizeInternal(false);
	}

	@Override
	public void synchronizeFast() {
		synchronizeInternal(true);
	}

	private final void synchronizeInternal(boolean doFast) {
		if (isSynchronized()) {
			return;
		}
		try {
			final String path = getFilePath();
			if (path == null) {
				// TODO: error message ???
				return;
			}
			final int index = path.lastIndexOf(File.separator);
			if (index != -1) {
				final String dir = path.substring(0, index);
				final File dirFile = new File(dir);
				if (!dirFile.exists() && !dirFile.mkdirs()) {
					// TODO: error message ???
					return;
				}
				if (!dirFile.exists() || !dirFile.isDirectory()) {
					// TODO: error message ???
					return;
				}
			}
			final File imageFile = new File(path);
			if (imageFile.exists()) {
				final long diff = System.currentTimeMillis() - imageFile.lastModified();
				final long valid = 7 * 24 * 60 * 60 * 1000; // one week in milliseconds; FIXME: hardcoded const
				if (diff >= 0 && diff <= valid) {
					return;
				}
				imageFile.delete();
			}
			if (doFast) {
				return;
			}

			try {
				ZLNetworkManager.Instance().downloadToFile(Url, imageFile);
			} catch (ZLNetworkException e) {
			}
		} finally {
			setSynchronized();
		}
	}

	private ZLFileImage myFileImage;
	@Override
	public InputStream inputStream() {
		if (myFileImage == null) {
			if (!isSynchronized()) {
				return null;
			}
			final String path = getFilePath();
			if (path == null) {
				return null;
			}
			myFileImage = new ZLFileImage(mimeType(), ZLFile.createFileByPath(path));
		}
		return myFileImage.inputStream();
	}
}
",True,151,9,28,7,14,1,8,L6
98,org.geometerplus.fbreader.network.AbstractNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.options.ZLStringListOption;

import org.geometerplus.fbreader.network.urlInfo.*;

public abstract class AbstractNetworkLink implements INetworkLink, Basket {
	private int myId;

	protected String mySiteName;
	protected String myTitle;
	protected String mySummary;
	protected final String myLanguage;
	protected final UrlInfoCollection<UrlInfoWithDate> myInfos;

	private ZLStringListOption myBooksInBasketOption;

	/**
	 * Creates new NetworkLink instance.
	 *
	 * @param siteName   name of the corresponding website. Must be not <code>null</code>.
	 * @param title      title of the corresponding library item. Must be not <code>null</code>.
	 * @param summary    description of the corresponding library item. Can be <code>null</code>.
	 * @param language   language of the catalog. If <code>null</code> we assume this catalog is multilanguage.
	 * @param infos      collection of URL infos; must always contain one URL with <code>UrlInfo.Type.Catalog</code> identifier
	 */
	public AbstractNetworkLink(int id, String siteName, String title, String summary, String language, UrlInfoCollection<UrlInfoWithDate> infos) {
		myId = id;
		mySiteName = siteName;
		myTitle = title;
		mySummary = summary;
		myLanguage = language != null ? language : ""multi"";
		myInfos = new UrlInfoCollection<UrlInfoWithDate>(infos);
	}

	public int getId() {
		return myId;
	}

	public void setId(int id) {
		myId = id;
	}

	public final String getSiteName() {
		return mySiteName;
	}

	public final String getTitle() {
		return myTitle;
	}

	public final String getSummary() {
		return mySummary;
	}

	public final String getLanguage() {
		return myLanguage;
	}

	public final UrlInfoCollection<UrlInfoWithDate> urlInfoMap() {
		return new UrlInfoCollection<UrlInfoWithDate>(myInfos);
	}

	public final String getUrl(UrlInfo.Type type) {
		return getUrlInfo(type).Url;
	}

	public final UrlInfoWithDate getUrlInfo(UrlInfo.Type type) {
		final UrlInfoWithDate info = myInfos.getInfo(type);
		return info != null ? info : UrlInfoWithDate.NULL;
	}

	public final Set<UrlInfo.Type> getUrlKeys() {
		final HashSet<UrlInfo.Type> set = new HashSet<UrlInfo.Type>();
		for (UrlInfo info : myInfos.getAllInfos()) {
			set.add(info.InfoType);
		}
		return set;
	}

	public final void setSupportsBasket() {
		if (myBooksInBasketOption == null) {
			myBooksInBasketOption = new ZLStringListOption(mySiteName, ""Basket"", null);
		}
	}

	public final Basket basket() {
		return myBooksInBasketOption != null ? this : null;
	}

	// method from Basket interface
	public final void add(NetworkBookItem book) {
		if (book.Id != null && !"""".equals(book.Id)) {
			List<String> ids = myBooksInBasketOption.getValue();
			if (!ids.contains(book.Id)) {
				ids = new ArrayList<String>(ids);
				ids.add(book.Id);
				myBooksInBasketOption.setValue(ids);
			}
		}
	}

	// method from Basket interface
	public final void remove(NetworkBookItem book) {
		if (book.Id != null && !"""".equals(book.Id)) {
			List<String> ids = myBooksInBasketOption.getValue();
			if (ids.contains(book.Id)) {
				ids = new ArrayList<String>(ids);
				ids.remove(book.Id);
				myBooksInBasketOption.setValue(ids);
			}
		}
	}

	// method from Basket interface
	public final void clear() {
		myBooksInBasketOption.setValue(null);
	}

	// method from Basket interface
	public final boolean contains(NetworkBookItem book) {
		return myBooksInBasketOption.getValue().contains(book.Id);
	}

	// method from Basket interface
	public final List<String> bookIds() {
		return myBooksInBasketOption.getValue();
	}

	public NetworkOperationData createOperationData(NetworkOperationData.OnNewItemListener listener) {
		return new NetworkOperationData(this, listener);
	}

	@Override
	public String toString() {
		String icon = getUrl(UrlInfo.Type.Catalog);
		if (icon != null) {
			if (icon.length() > 64) {
				icon = icon.substring(0, 61) + ""..."";
			}
			icon = icon.replaceAll(""\n"", """");
		}
		return ""AbstractNetworkLink: {""
			+ ""siteName="" + mySiteName
			+ ""; title="" + myTitle
			+ ""; summary="" + mySummary
			+ ""; icon="" + icon
			+ ""; infos="" + myInfos
			+ ""}"";
	}
}
",False,195,8,26,12,29,5,8,L6
99,org.geometerplus.fbreader.network.NetworkBookItemComparator.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Comparator;
import java.util.LinkedList;

public final class NetworkBookItemComparator implements Comparator<NetworkItem> {
	public int compare(NetworkItem item0, NetworkItem item1) {
		final boolean item0isABook = item0 instanceof NetworkBookItem;
		final boolean item1isABook = item1 instanceof NetworkBookItem;

		final String title0 = item0.Title.toString();
		final String title1 = item1.Title.toString();

		if (!item0isABook && !item1isABook) {
			return title0.compareTo(title1);
		}
		if (!item0isABook || !item1isABook) {
			return item0isABook ? 1 : -1;
		}

		final NetworkBookItem book0 = (NetworkBookItem)item0;
		final NetworkBookItem book1 = (NetworkBookItem)item1;

		final LinkedList<NetworkBookItem.AuthorData> authors0 = book0.Authors;
		final LinkedList<NetworkBookItem.AuthorData> authors1 = book1.Authors;
		
		final boolean authors0empty = authors0.size() == 0;
		final boolean authors1empty = authors1.size() == 0;

		if (authors0empty && !authors1empty) {
			return -1;
		}
		if (authors1empty && !authors0empty) {
			return 1;
		}
		if (!authors0empty && !authors1empty) {
			final int diff = authors0.get(0).SortKey.compareTo(authors1.get(0).SortKey);
			if (diff != 0) {
				return diff;
			}
		}

		/*if (book0.Index != book1.Index) {
			return book0.Index - book1.Index;
		}*/

		final boolean book0HasSeriesTitle = book0.SeriesTitle != null;
		final boolean book1HasSeriesTitle = book1.SeriesTitle != null;

		if (book0HasSeriesTitle && book1HasSeriesTitle) {
			final int comp = book0.SeriesTitle.compareTo(book1.SeriesTitle);
			if (comp != 0) {
				return comp;
			} else {
				final float diff = book0.IndexInSeries - book1.IndexInSeries;
				if (diff != 0) {
					return diff > 0 ? 1 : -1;
				}
			}
			return title0.compareTo(title1);
		}

		final String book0Key = book0HasSeriesTitle ? book0.SeriesTitle : title0;
		final String book1Key = book1HasSeriesTitle ? book1.SeriesTitle : title1;
		final int comp = book0Key.compareTo(book1Key);
		if (comp != 0) {
			return comp;
		}
		return book1HasSeriesTitle ? -1 : 1;
	}
}
",False,140,0,0,12,31,1,2,L6
100,org.geometerplus.fbreader.network.Basket.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

public interface Basket {
	void add(NetworkBookItem book);
	void remove(NetworkBookItem book);
	boolean contains(NetworkBookItem book);
	List<String> bookIds();
	void clear();
}
",False,195,7,26,12,31,7,1,L6
101,org.geometerplus.fbreader.network.NetworkBookItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;
import java.io.File;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.urlInfo.*;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

public class NetworkBookItem extends NetworkItem {
	public static class AuthorData implements Comparable<AuthorData> {
		public final String DisplayName;
		public final String SortKey;

		/**
		 * Creates new AuthorData instance. 
		 *
		 * @param displayName author's name. Must be not <code>null</code>.
		 * @param sortKey     string that defines sorting order of book's authors.
		 */
		public AuthorData(String displayName, String sortKey) {
			DisplayName = displayName.intern();
			SortKey = sortKey != null ? sortKey.intern() : DisplayName.toLowerCase().intern();
		}

		public int compareTo(AuthorData data) {
			final int key = SortKey.compareTo(data.SortKey);
			if (key != 0) {
				return key;
			}
			return DisplayName.compareTo(data.DisplayName);
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof AuthorData)) {
				return false;
			}
			final AuthorData data = (AuthorData) o;
			return SortKey.equals(data.SortKey) && DisplayName.equals(data.DisplayName);
		}

		@Override
		public int hashCode() {
			return SortKey.hashCode() + DisplayName.hashCode();
		}
	}

	public final int Index;
	public final String Id;
	//public final String Language;
	//public final String Date;
	public final LinkedList<AuthorData> Authors;
	public final LinkedList<String> Tags;
	public final String SeriesTitle;
	public final float IndexInSeries;

	/**
	 * Creates new NetworkBookItem instance.
	 *
	 * @param link          corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param id            string that uniquely identifies this book item. Must be not <code>null</code>.
	 * @param index         sequence number of this book in corresponding catalog
	 * @param title         title of this book. Must be not <code>null</code>.
	 * @param summary       description of this book. Can be <code>null</code>.
	 * //@param langage       string specifies language of this book. Can be <code>null</code>.
	 * //@param date          string specifies release date of this book. Can be <code>null</code>.
	 * @param authors       list of book authors. Should contain at least one author.
	 * @param tags          list of book tags. Must be not <code>null</code> (can be empty).
	 * @param seriesTitle   title of this book's series. Can be <code>null</code>.
	 * @param indexInSeries	sequence number of this book within book's series. Ignored if seriesTitle is <code>null</code>.
	 * @param urls          list of urls related to this book. Can be <code>null</code>.
	 */
	public NetworkBookItem(INetworkLink link, String id, int index,
		CharSequence title, CharSequence summary, /*String language, String date,*/
		List<AuthorData> authors, List<String> tags, String seriesTitle, float indexInSeries,
		UrlInfoCollection<?> urls) {
		super(link, title, summary, urls);
		Index = index;
		Id = id;
		//Language = language;
		//Date = date;
		Authors = new LinkedList<AuthorData>(authors);
		Tags = new LinkedList<String>(tags);
		SeriesTitle = seriesTitle;
		IndexInSeries = indexInSeries;
	}

	public boolean isFullyLoaded() {
		return true;
	}

	public void loadFullInformation() throws ZLNetworkException {
	}

	public NetworkCatalogItem createRelatedCatalogItem(RelatedUrlInfo info) {
		return null;
	}

	public BookUrlInfo reference(UrlInfo.Type type) {
		BookUrlInfo reference = null;
		for (UrlInfo r : getAllInfos(type)) {
			if (!(r instanceof BookUrlInfo)) {
				continue;
			}
			final BookUrlInfo br = (BookUrlInfo)r;
			if (reference == null || br.BookFormat > reference.BookFormat) {
				reference = br;
			}
		}

		if (reference == null && type == UrlInfo.Type.Book) {
			reference = this.reference(UrlInfo.Type.BookConditional);
			if (reference != null) {
				NetworkAuthenticationManager authManager = Link.authenticationManager();
				if (authManager == null || authManager.needPurchase(this)) {
					return null;
				}
				reference = authManager.downloadReference(this);
			}
		}

		if (reference == null &&
				type == UrlInfo.Type.Book &&
				this.reference(UrlInfo.Type.BookBuy) == null &&
				this.reference(UrlInfo.Type.BookBuyInBrowser) == null) {
			reference = this.reference(UrlInfo.Type.BookFullOrDemo);
		}

		if (reference == null &&
				type == UrlInfo.Type.BookDemo &&
				(this.reference(UrlInfo.Type.BookBuy) != null ||
				 this.reference(UrlInfo.Type.BookBuyInBrowser) != null)) {
			reference = this.reference(UrlInfo.Type.BookFullOrDemo);
		}

		return reference;
	}

	public String localCopyFileName() {
		final boolean hasBuyReference =
			this.reference(UrlInfo.Type.BookBuy) != null ||
			this.reference(UrlInfo.Type.BookBuyInBrowser) != null;
		BookUrlInfo reference = null;
		String fileName = null;
		for (UrlInfo r : getAllInfos()) {
			if (!(r instanceof BookUrlInfo)) {
				continue;
			}
			final BookUrlInfo br = (BookUrlInfo)r;
			final UrlInfo.Type type = br.InfoType;
			if ((type == UrlInfo.Type.Book ||
				 type == UrlInfo.Type.BookConditional ||
				 (!hasBuyReference && type == UrlInfo.Type.BookFullOrDemo)) &&
				(reference == null || br.BookFormat > reference.BookFormat)) {
				String name = br.localCopyFileName(UrlInfo.Type.Book);
				if (name != null) {
					reference = br;
					fileName = name;
				}
			}
		}
		return fileName;
	}

	public void removeLocalFiles() {
		final boolean hasBuyReference =
			this.reference(UrlInfo.Type.BookBuy) != null ||
			this.reference(UrlInfo.Type.BookBuyInBrowser) != null;
		for (UrlInfo r : getAllInfos()) {
			if (!(r instanceof BookUrlInfo)) {
				continue;
			}
			final BookUrlInfo br = (BookUrlInfo)r;
			final UrlInfo.Type type = br.InfoType;
			if (type == UrlInfo.Type.Book ||
				type == UrlInfo.Type.BookConditional ||
				(!hasBuyReference && type == UrlInfo.Type.BookFullOrDemo)) {
				String fileName = br.localCopyFileName(UrlInfo.Type.Book);
				if (fileName != null) {
					// TODO: remove a book from the library
					// TODO: remove a record from the database
					new File(fileName).delete();
				}
			}
		}
	}
}
",False,194,7,26,11,31,18,9,L6
102,org.geometerplus.fbreader.network.NetworkDatabase.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Map;
import java.util.List;

import org.geometerplus.fbreader.network.urlInfo.*;
import org.geometerplus.fbreader.network.opds.OPDSCustomNetworkLink;
import org.geometerplus.fbreader.network.opds.OPDSPredefinedNetworkLink;

public abstract class NetworkDatabase {
	private static NetworkDatabase ourInstance;

	public static NetworkDatabase Instance() {
		return ourInstance;
	}

	protected NetworkDatabase() {
		ourInstance = this;
	}

	protected abstract void executeAsATransaction(Runnable actions);

	protected INetworkLink createLink(int id, String predefinedId, String siteName, String title, String summary, String language, UrlInfoCollection<UrlInfoWithDate> infos) {
		if (siteName == null || title == null || infos.getInfo(UrlInfo.Type.Catalog) == null) {
			return null;
		}
		return
			predefinedId != null
			? new OPDSPredefinedNetworkLink(id, predefinedId, siteName, title, summary, language, infos)
			: new OPDSCustomNetworkLink(id, siteName, title, summary, language, infos);
	}

	protected abstract List<INetworkLink> listLinks();
	protected abstract void saveLink(INetworkLink link);
	protected abstract void deleteLink(INetworkLink link);

	protected abstract Map<String,String> getLinkExtras(INetworkLink link);
	protected abstract void setLinkExtras(INetworkLink link, Map<String,String> extras);
}
",False,195,7,26,10,37,2,6,L6
103,org.geometerplus.fbreader.network.NetworkLibrary.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.tree.*;
import org.geometerplus.fbreader.network.opds.OPDSLinkReader;
import org.geometerplus.fbreader.network.urlInfo.*;

public class NetworkLibrary {
	private static NetworkLibrary ourInstance;

	public static NetworkLibrary Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkLibrary();
		}
		return ourInstance;
	}

	private static class LinksComparator implements Comparator<INetworkLink> {
		private static String filterLinkTitle(String title) {
			for (int index = 0; index < title.length(); ++index) {
				final char ch = title.charAt(index);
				if (ch < 128 && Character.isLetter(ch)) {
					return title.substring(index);
				}
			}
			return title;
		}

		private static int languageOrder(String language) {
			if (language == ZLLanguageUtil.MULTI_LANGUAGE_CODE) {
				return 1;
			}
			if (language.equals(Locale.getDefault().getLanguage())) {
				return 0;
			}
			return 2;
		}

		public int compare(INetworkLink link1, INetworkLink link2) {
			final int languageOrder1 = languageOrder(link1.getLanguage());
			final int languageOrder2 = languageOrder(link2.getLanguage());
			if (languageOrder1 != languageOrder2) {
				return languageOrder1 - languageOrder2;
			}
			final String title1 = filterLinkTitle(link1.getTitle());
			final String title2 = filterLinkTitle(link2.getTitle());
			return title1.compareToIgnoreCase(title2);
		}
	}

	
	public interface OnNewLinkListener {
		void onNewLink(INetworkLink link);
	}

	public final ZLStringOption NetworkSearchPatternOption =
		new ZLStringOption(""NetworkSearch"", ""Pattern"", """");

	// that's important to keep this list synchronized
	// it can be used from background thread
	private final List<INetworkLink> myLinks =
		Collections.synchronizedList(new ArrayList<INetworkLink>());

	public List<String> languageCodes() {
		final TreeSet<String> languageSet = new TreeSet<String>();
		for (INetworkLink link : myLinks) {
			languageSet.add(link.getLanguage());
		}
		return new ArrayList<String>(languageSet);
	}

	private ZLStringOption myActiveLanguageCodesOption;
	private ZLStringOption activeLanguageCodesOption() {
 		if (myActiveLanguageCodesOption == null) {
			final TreeSet<String> defaultCodes = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
			defaultCodes.addAll(ZLibrary.Instance().defaultLanguageCodes());
			myActiveLanguageCodesOption =
				new ZLStringOption(
					""Options"",
					""ActiveLanguages"",
					commaSeparatedString(defaultCodes)
				);
		}
		return myActiveLanguageCodesOption;
	}

	public Collection<String> activeLanguageCodes() {
		return Arrays.asList(activeLanguageCodesOption().getValue().split("",""));
	}

	public void setActiveLanguageCodes(Collection<String> codes) {
		final TreeSet<String> allCodes = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
		allCodes.addAll(ZLibrary.Instance().defaultLanguageCodes());
		allCodes.removeAll(languageCodes());
		allCodes.addAll(codes);
		activeLanguageCodesOption().setValue(commaSeparatedString(allCodes));
		invalidateChildren();
	}

	private String commaSeparatedString(Collection<String> codes) {
		final StringBuilder builder = new StringBuilder();
		for (String code : codes) {
			builder.append(code);
			builder.append("","");
		}
		if (builder.length() > 0) {
			builder.delete(builder.length() - 1, builder.length());
		}
		return builder.toString();
	}

	private List<INetworkLink> activeLinks() {
		final LinkedList<INetworkLink> filteredList = new LinkedList<INetworkLink>();
		final Collection<String> codes = activeLanguageCodes();
		for (INetworkLink link : myLinks) {
			if (link instanceof ICustomNetworkLink ||
				codes.contains(link.getLanguage())) {
				filteredList.add(link);
			}
		}
		return filteredList;
	}

	private final RootTree myRootTree = new RootTree(""@Root"");
	private final RootTree myFakeRootTree = new RootTree(""@FakeRoot"");
	private SearchItemTree mySearchItemTree;

	private boolean myChildrenAreInvalid = true;
	private boolean myUpdateVisibility;

	private NetworkLibrary() {
	}

	private boolean myIsAlreadyInitialized;
	public synchronized void initialize() throws ZLNetworkException {
		if (myIsAlreadyInitialized) {
			return;
		}

		try {
			OPDSLinkReader.loadOPDSLinks(OPDSLinkReader.CACHE_LOAD, new OnNewLinkListener() {
				public void onNewLink(INetworkLink link) {
					myLinks.add(link);
				}
			});
		} catch (ZLNetworkException e) {
			removeAllLoadedLinks();
			throw e;
		}

		final NetworkDatabase db = NetworkDatabase.Instance();
		if (db != null) {
			myLinks.addAll(db.listLinks());
		}

		myIsAlreadyInitialized = true;
	}

	private void removeAllLoadedLinks() {
		final LinkedList<INetworkLink> toRemove = new LinkedList<INetworkLink>();
		for (INetworkLink link : myLinks) {
			if (!(link instanceof ICustomNetworkLink)) {
				toRemove.add(link);
			}
		}
		myLinks.removeAll(toRemove);
	}

	/*private void testDate(ATOMDateConstruct date1, ATOMDateConstruct date2) {
		String sign = "" == "";
		final int diff = date1.compareTo(date2);
		if (diff > 0) {
			sign = "" > "";
		} else if (diff < 0) {
			sign = "" < "";
		}
		Log.w(""FBREADER"", """" + date1 + sign + date2);
	}*/

	private ArrayList<INetworkLink> myBackgroundLinks;
	private Object myBackgroundLock = new Object();

	// This method must be called from background thread
	public void runBackgroundUpdate(boolean clearCache) throws ZLNetworkException {
		synchronized (myBackgroundLock) {
			myBackgroundLinks = new ArrayList<INetworkLink>();

			final int cacheMode = clearCache ? OPDSLinkReader.CACHE_CLEAR : OPDSLinkReader.CACHE_UPDATE;
			try {
				OPDSLinkReader.loadOPDSLinks(cacheMode, new OnNewLinkListener() {
					public void onNewLink(INetworkLink link) {
						myBackgroundLinks.add(link);
					}
				});
			} catch (ZLNetworkException e) {
				myBackgroundLinks = null;
				throw e;
			} finally {
				if (myBackgroundLinks != null) {
					if (myBackgroundLinks.isEmpty()) {
						myBackgroundLinks = null;
					}
				}
			}
			// we create this copy to prevent long operations on synchronized list
			final List<INetworkLink> linksCopy = new ArrayList<INetworkLink>(myLinks);
			for (INetworkLink link : linksCopy) {
				if (link instanceof ICustomNetworkLink) {
					final ICustomNetworkLink customLink = (ICustomNetworkLink)link;
					if (customLink.isObsolete(12 * 60 * 60 * 1000)) { // 12 hours
						customLink.reloadInfo(true);
						NetworkDatabase.Instance().saveLink(customLink);
					}
				}
			}
		}
	}

	// This method MUST be called from main thread
	// This method has effect only when runBackgroundUpdate method has returned null.
	//
	// synchronize() method MUST be called after this method
	public void finishBackgroundUpdate() {
		synchronized (myBackgroundLock) {
			if (myBackgroundLinks != null) {
				removeAllLoadedLinks();
				myLinks.addAll(myBackgroundLinks);
			}
			invalidateChildren();
		}
	}


	public String rewriteUrl(String url, boolean externalUrl) {
		final String host = ZLNetworkUtil.hostFromUrl(url).toLowerCase();
		for (INetworkLink link : myLinks) {
			if (host.contains(link.getSiteName())) {
				url = link.rewriteUrl(url, externalUrl);
			}
		}
		return url;
	}

	private void invalidateChildren() {
		myChildrenAreInvalid = true;
	}

	public void invalidateVisibility() {
		myUpdateVisibility = true;
	}

	private static boolean linkIsChanged(INetworkLink link) {
		return
			link instanceof ICustomNetworkLink &&
			((ICustomNetworkLink)link).hasChanges();
	}

	private static void makeValid(INetworkLink link) {
		if (link instanceof ICustomNetworkLink) {
			((ICustomNetworkLink)link).resetChanges();
		}
	}

	private void makeUpToDate() {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();

		ListIterator<FBTree> nodeIterator = myRootTree.subTrees().listIterator();
		FBTree currentNode = null;
		int nodeCount = 0;

		final ArrayList<INetworkLink> links = new ArrayList<INetworkLink>(activeLinks());
		Collections.sort(links, new LinksComparator());
		for (int i = 0; i < links.size(); ++i) {
			INetworkLink link = links.get(i);
			boolean processed = false;
			while (currentNode != null || nodeIterator.hasNext()) {
				if (currentNode == null) {
					currentNode = nodeIterator.next();
				}
				if (!(currentNode instanceof NetworkCatalogTree)) {
					toRemove.add(currentNode);
					currentNode = null;
					++nodeCount;
					continue;
				}
				final INetworkLink nodeLink = ((NetworkCatalogTree)currentNode).Item.Link;
				if (link == nodeLink) {
					if (linkIsChanged(link)) {
						toRemove.add(currentNode);
					} else {
						processed = true;
					}
					currentNode = null;
					++nodeCount;
					break;
				} else {
					INetworkLink newNodeLink = null;
					for (int j = i; j < links.size(); ++j) {
						final INetworkLink jlnk = links.get(j);
						if (nodeLink == jlnk) {
							newNodeLink = jlnk;
							break;
						}
					}
					if (newNodeLink == null || linkIsChanged(nodeLink)) {
						toRemove.add(currentNode);
						currentNode = null;
						++nodeCount;
					} else {
						break;
					}
				}
			}
			if (!processed) {
				makeValid(link);
				final int nextIndex = nodeIterator.nextIndex();
				new NetworkCatalogRootTree(myRootTree, link, nodeCount++).Item.onDisplayItem();
				nodeIterator = myRootTree.subTrees().listIterator(nextIndex + 1);
			}
		}

		while (currentNode != null || nodeIterator.hasNext()) {
			if (currentNode == null) {
				currentNode = nodeIterator.next();
			}
			toRemove.add(currentNode);
			currentNode = null;
		}

		for (FBTree tree : toRemove) {
			tree.removeSelf();
		}
		new AddCustomCatalogItemTree(myRootTree);
		mySearchItemTree = new SearchItemTree(myRootTree, 0);
	}

	private void updateVisibility() {
		for (FBTree tree : myRootTree.subTrees()) {
			if (tree instanceof NetworkCatalogTree) {
				((NetworkCatalogTree)tree).updateVisibility();
			}
		}
	}

	public void synchronize() {
		if (myChildrenAreInvalid) {
			myChildrenAreInvalid = false;
			makeUpToDate();
		}
		if (myUpdateVisibility) {
			myUpdateVisibility = false;
			updateVisibility();
		}
	}

	public NetworkTree getRootTree() {
		return myRootTree;
	}

	public SearchItemTree getSearchItemTree() {
		return mySearchItemTree;
	}

	public NetworkCatalogTree getFakeCatalogTree(NetworkCatalogItem item) {
		final String id = item.getStringId();
		for (FBTree tree : myFakeRootTree.subTrees()) {
			final NetworkCatalogTree ncTree = (NetworkCatalogTree)tree;
			if (id.equals(ncTree.getUniqueKey().Id)) {
				return ncTree;
			}
		}
		return new NetworkCatalogTree(myFakeRootTree, item, 0);
	}

	public NetworkTree getTreeByKey(NetworkTree.Key key) {
		if (key == null) {
			return null;
		}
		if (key.Parent == null) {
			if (key.equals(myRootTree.getUniqueKey())) {
				return myRootTree;
			}
			if (key.equals(myFakeRootTree.getUniqueKey())) {
				return myFakeRootTree;
			}
			return null;
		}
		final NetworkTree parentTree = getTreeByKey(key.Parent);
		if (parentTree == null) {
			return null;
		}
		for (FBTree tree : parentTree.subTrees()) {
			final NetworkTree nTree = (NetworkTree)tree;
			if (key.equals(nTree.getUniqueKey())) {
				return nTree;
			}
		}
		return null;
	}

	public void simpleSearch(String pattern, final NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		LinkedList<ZLNetworkRequest> requestList = new LinkedList<ZLNetworkRequest>();
		LinkedList<NetworkOperationData> dataList = new LinkedList<NetworkOperationData>();

		final NetworkOperationData.OnNewItemListener synchronizedListener = new NetworkOperationData.OnNewItemListener() {
			public synchronized void onNewItem(INetworkLink link, NetworkItem item) {
				listener.onNewItem(link, item);
			}
			public synchronized boolean confirmInterrupt() {
				return listener.confirmInterrupt();
			}
			public synchronized void commitItems(INetworkLink link) {
				listener.commitItems(link);
			}
		};

		for (INetworkLink link : activeLinks()) {
			final NetworkOperationData data = link.createOperationData(synchronizedListener);
			final ZLNetworkRequest request = link.simpleSearchRequest(pattern, data);
			if (request != null) {
				dataList.add(data);
				requestList.add(request);
			}
		}

		while (requestList.size() != 0) {
			ZLNetworkManager.Instance().perform(requestList);

			requestList.clear();

			if (listener.confirmInterrupt()) {
				return;
			}
			for (NetworkOperationData data : dataList) {
				ZLNetworkRequest request = data.resume();
				if (request != null) {
					requestList.add(request);
				}
			}
		}
	}

	public void addCustomLink(ICustomNetworkLink link) {
		final int id = link.getId();
		if (id == ICustomNetworkLink.INVALID_ID) {
			myLinks.add(link);
		} else {
			for (int i = myLinks.size() - 1; i >= 0; --i) {
				final INetworkLink l = myLinks.get(i);
				if (l instanceof ICustomNetworkLink &&
					((ICustomNetworkLink)l).getId() == id) {
					myLinks.set(i, link);
					break;
				}
			}
		}
		NetworkDatabase.Instance().saveLink(link);
		invalidateChildren();
	}

	public void removeCustomLink(ICustomNetworkLink link) {
		myLinks.remove(link);
		NetworkDatabase.Instance().deleteLink(link);
		invalidateChildren();
	}
}
",True,194,4,28,6,41,11,22,L6
104,org.geometerplus.fbreader.network.TopUpItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.urlInfo.UrlInfoCollection;

public class TopUpItem extends NetworkItem {
	public TopUpItem(INetworkLink link, UrlInfoCollection<?> urls) {
		super(
			link,
			ZLResource.resource(""networkView"").getResource(""topupTitle"").getValue(),
			ZLResource.resource(""networkView"").getResource(""topupSummary"").getValue(),
			urls
		);
	}
}
",False,140,0,0,12,29,3,4,L6
105,org.geometerplus.fbreader.network.HtmlUtil.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import android.text.*;
import android.text.style.URLSpan;

public abstract class HtmlUtil {
	public static CharSequence getHtmlText(String text) {
		final Spanned htmlText = Html.fromHtml(text);
		if (htmlText.getSpans(0, htmlText.length(), URLSpan.class).length == 0) {
			return htmlText;
		}
		final Spannable newHtmlText = Spannable.Factory.getInstance().newSpannable(htmlText);
		for (URLSpan span : newHtmlText.getSpans(0, newHtmlText.length(), URLSpan.class)) {
			final int start = newHtmlText.getSpanStart(span);
			final int end = newHtmlText.getSpanEnd(span);
			final int flags = newHtmlText.getSpanFlags(span);
			final String url = NetworkLibrary.Instance().rewriteUrl(span.getURL(), true);
			newHtmlText.removeSpan(span);
			newHtmlText.setSpan(new URLSpan(url), start, end, flags);
		}
		return newHtmlText;
	}
}
",False,194,7,24,7,41,2,1,L6
106,org.geometerplus.fbreader.network.NetworkOperationData.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;


public class NetworkOperationData {

	public interface OnNewItemListener {
		void onNewItem(INetworkLink link, NetworkItem item);

		void commitItems(INetworkLink link);

		/**
		 * @return <code>true</code> to confirm interrupt reading; 
		 *         <code>false</code> to continue reading.
		 *         Once <code>true</code> has been returned,
		 *         all next calls MUST return <code>true</code>.
		 */
		boolean confirmInterrupt();
	}

	public final INetworkLink Link;
	public OnNewItemListener Listener;
	public String ResumeURI;

	public NetworkOperationData(INetworkLink link, OnNewItemListener listener) {
		Link = link;
		Listener = listener;
	}

	protected void clear() {
		ResumeURI = null;
	}

	public final ZLNetworkRequest resume() {
		final ZLNetworkRequest request = Link.resume(this);
		clear();
		return request;
	}
}
",False,195,7,26,12,32,12,3,L6
107,org.geometerplus.fbreader.network.SearchResult.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.LinkedHashMap;
import java.util.LinkedList;

public class SearchResult {
	public final String Summary;
	public final LinkedHashMap<NetworkBookItem.AuthorData, LinkedList<NetworkBookItem>> BooksMap =
		new LinkedHashMap<NetworkBookItem.AuthorData, LinkedList<NetworkBookItem>>();

	public SearchResult(String summary) {
		Summary = summary;
	}

	public void addBook(NetworkBookItem book) {
		for (NetworkBookItem.AuthorData author: book.Authors) {
			LinkedList<NetworkBookItem> list = BooksMap.get(author);
			if (list == null) {
				list = new LinkedList<NetworkBookItem>();
				BooksMap.put(author, list);
			}
			list.add(book);
		}
	}

	public boolean isEmpty() {
		return BooksMap.size() == 0;
	}
}
",False,194,7,26,12,31,3,1,L6
108,org.geometerplus.fbreader.network.NetworkException.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

public abstract class NetworkException extends ZLNetworkException {
	private static final long serialVersionUID = 8931535868304063605L;

	public static final String ERROR_INTERNAL = ""internalError"";
	public static final String ERROR_PURCHASE_NOT_ENOUGH_MONEY = ""purchaseNotEnoughMoney"";
	public static final String ERROR_PURCHASE_MISSING_BOOK = ""purchaseMissingBook"";
	public static final String ERROR_PURCHASE_ALREADY_PURCHASED = ""purchaseAlreadyPurchased"";
	public static final String ERROR_BOOK_NOT_PURCHASED = ""bookNotPurchased"";
	public static final String ERROR_DOWNLOAD_LIMIT_EXCEEDED = ""downloadLimitExceeded"";

	public static final String ERROR_EMAIL_WAS_NOT_SPECIFIED = ""emailNotSpecified"";

	public static final String ERROR_NO_USER_EMAIL = ""noUserEmail"";

	public static final String ERROR_UNSUPPORTED_OPERATION = ""unsupportedOperation"";

	public static final String ERROR_NOT_AN_OPDS = ""notAnOPDS"";
	public static final String ERROR_NO_REQUIRED_INFORMATION = ""noRequiredInformation"";
	public static final String ERROR_CACHE_DIRECTORY_ERROR = ""cacheDirectoryError"";

	private NetworkException() {
		super(null);
	}
}
",False,135,6,33,8,8,8,1,L6
109,org.geometerplus.fbreader.network.NetworkCatalogItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;
import org.geometerplus.fbreader.network.urlInfo.UrlInfoCollection;

public abstract class NetworkCatalogItem extends NetworkItem {
	// bit mask for flags parameter
	public static final int FLAG_SHOW_AUTHOR                              = 1 << 0;
	public static final int FLAG_GROUP_BY_AUTHOR                          = 1 << 1;
	public static final int FLAG_GROUP_BY_SERIES                          = 1 << 2;
	public static final int FLAG_GROUP_MORE_THAN_1_BOOK_BY_SERIES         = 1 << 3;

	public static final int FLAGS_DEFAULT =
		FLAG_SHOW_AUTHOR |
		FLAG_GROUP_MORE_THAN_1_BOOK_BY_SERIES;
	public static final int FLAGS_GROUP =
		FLAG_GROUP_BY_AUTHOR |
		FLAG_GROUP_BY_SERIES |
		FLAG_GROUP_MORE_THAN_1_BOOK_BY_SERIES;

	// catalog accessibility types:
	public static enum Accessibility {
		NEVER,
		ALWAYS,
		SIGNED_IN,
		HAS_BOOKS
	}

	private final Accessibility myAccessibility;
	private int myFlags;

	/**
	 * Creates new NetworkCatalogItem instance with specified accessibility and type.
	 *
	 * @param link          corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title         title of this library item. Must be not <code>null</code>.
	 * @param summary       description of this library item. Can be <code>null</code>.
	 * @param urls          collection of item-related URLs. Can be <code>null</code>.
	 * @param accessibility value defines when this library item will be accessible
	 *                      in the network library view. 
	 * @param flags         describes how to show book items inside this catalog
	 */
	public NetworkCatalogItem(INetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls, Accessibility accessibility, int flags) {
		super(link, title, summary, urls);
		myAccessibility = accessibility;
		myFlags = flags;
	}

	public Map<String,String> extraData() {
		return Collections.emptyMap();
	}

	public abstract void loadChildren(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException;

	public boolean supportsResumeLoading() {
		return false;
	}

	public void resumeLoading(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}


	/**
	 * Method is called each time this item is displayed to the user.
	 *
	 * This method is called when UI-element corresponding to this item is shown to the User.
	 */
	public void onDisplayItem() {
	}

	public int getFlags() {
		return myFlags;
	}

	public void setFlags(int flags) {
		myFlags = flags;
	}

	public ZLBoolean3 getVisibility() {
		final NetworkAuthenticationManager mgr = Link.authenticationManager();
		switch (myAccessibility) {
			default:
				return ZLBoolean3.B3_FALSE;
			case ALWAYS:
				return ZLBoolean3.B3_TRUE;
			case SIGNED_IN:
				if (mgr == null) {
					return ZLBoolean3.B3_FALSE;
				}
				try {
					return mgr.isAuthorised(false) ?
							ZLBoolean3.B3_TRUE : ZLBoolean3.B3_UNDEFINED;
				} catch (ZLNetworkException e) {
					return ZLBoolean3.B3_UNDEFINED;
				}
			case HAS_BOOKS:
				if ((Link.basket() != null && Link.basket().bookIds().size() > 0) ||
					(mgr != null && mgr.purchasedBooks().size() > 0)) {
					return ZLBoolean3.B3_TRUE;
				} else {
					return ZLBoolean3.B3_FALSE;
				}
		}
	}

	public abstract String getStringId();
}
",False,195,7,26,11,32,15,9,L6
110,org.geometerplus.fbreader.network.IPredefinedNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

public interface IPredefinedNetworkLink extends INetworkLink {
	String getPredefinedId();
}
",False,195,7,26,12,33,2,1,L6
111,org.geometerplus.fbreader.network.INetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;
import org.geometerplus.fbreader.network.urlInfo.UrlInfo;
import org.geometerplus.fbreader.network.urlInfo.UrlInfoWithDate;

public interface INetworkLink {
	public static final int INVALID_ID = -1;

	int getId();
	void setId(int id);

	String getSiteName();
	String getTitle();
	String getSummary();

	String getUrl(UrlInfo.Type type);
	UrlInfoWithDate getUrlInfo(UrlInfo.Type type);
	Set<UrlInfo.Type> getUrlKeys();

	/**
	 * @return 2-letters language code or special token ""multi""
	 */
	String getLanguage();

	/**
	 * @param listener Network operation listener
	 * @return instance, which represents the state of the network operation.
	 */
	NetworkOperationData createOperationData(NetworkOperationData.OnNewItemListener listener);

	ZLNetworkRequest simpleSearchRequest(String pattern, NetworkOperationData data);
	ZLNetworkRequest resume(NetworkOperationData data);

	NetworkCatalogItem libraryItem();
	NetworkAuthenticationManager authenticationManager();

	Basket basket();

	String rewriteUrl(String url, boolean isUrlExternal);
}
",False,197,5,26,11,33,30,7,L6
112,org.geometerplus.fbreader.network.ICustomNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.urlInfo.*;

public interface ICustomNetworkLink extends INetworkLink {
	void setSiteName(String name);
	void setTitle(String title);
	void setSummary(String summary);

	UrlInfoCollection<UrlInfoWithDate> urlInfoMap();
	void setUrl(UrlInfo.Type type, String url);
	void removeUrl(UrlInfo.Type type);

	boolean isObsolete(long milliSeconds);
	void reloadInfo(boolean urlsOnly) throws ZLNetworkException;

	// returns true if next methods have changed link's data:
	//   setSiteName, setTitle, setSummary, setIcon, setLink, removeLink
	boolean hasChanges();

	// resets hasChanged() result
	void resetChanges();
}
",False,194,5,29,12,33,5,5,L6
113,org.geometerplus.fbreader.network.NetworkURLCatalogItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.urlInfo.UrlInfo;
import org.geometerplus.fbreader.network.urlInfo.UrlInfoCollection;

public abstract class NetworkURLCatalogItem extends NetworkCatalogItem {
	/**
	 * Creates new NetworkURLCatalogItem instance with <code>Accessibility.ALWAYS</code> accessibility and <code>FLAGS_DEFAULT</code> flags.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param urls       collection of item-related URLs. Can be <code>null</code>.
	 */
	public NetworkURLCatalogItem(INetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls) {
		this(link, title, summary, urls, Accessibility.ALWAYS, FLAGS_DEFAULT);
	}

	/**
	 * Creates new NetworkURLCatalogItem instance with specified accessibility and type.
	 *
	 * @param link          corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title         title of this library item. Must be not <code>null</code>.
	 * @param summary       description of this library item. Can be <code>null</code>.
	 * @param urls          collection of item-related URLs. Can be <code>null</code>.
	 * @param accessibility value defines when this library item will be accessible
	 *                      in the network library view. 
	 * @param flags         value defines how to show book items in this catalog.
	 */
	public NetworkURLCatalogItem(INetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls, Accessibility accessibility, int flags) {
		super(link, title, summary, urls, accessibility, flags);
	}

	/**
	 * Performs all necessary operations with NetworkOperationData and NetworkRequest
	 * to complete loading children items.
	 * 
	 * @param data Network operation data instance
	 * @param networkRequest initial network request
	 *  
	 * @throws ZLNetworkException when network operation couldn't be completed
	 */
	protected final void doLoadChildren(NetworkOperationData data,
			ZLNetworkRequest networkRequest) throws ZLNetworkException {
		while (networkRequest != null) {
			ZLNetworkManager.Instance().perform(networkRequest);
			if (data.Listener.confirmInterrupt()) {
				return;
			}
			networkRequest = data.resume();
		}
	}

	@Override
	public String getStringId() {
		String id = getUrl(UrlInfo.Type.Catalog);
		if (id == null) {
			id = getUrl(UrlInfo.Type.HtmlPage);
		}
		return id != null ? id : String.valueOf(hashCode());
	}
}
",False,194,7,26,12,30,3,9,L6
114,org.geometerplus.fbreader.network.urlInfo.BookBuyUrlInfo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.urlInfo;

public class BookBuyUrlInfo extends BookUrlInfo {
	private static final long serialVersionUID = 7877935250896069650L;

	public final String Price;

	public BookBuyUrlInfo(Type type, int format, String url, String price) {
		super(type, format, url);
		Price = price;
	}

	public static String price(String price, String currency) {
		if (price == null || currency == null) {
			return price;
		} else if (currency.equals(""RUB"")) {
			return price + "" \u0440."";
		} else if (currency.equals(""USD"")) {
			return ""$"" + price;
		} else if (currency.equals(""GBP"")) {
			return ""\u00A3"" + price;
		} else if (currency.equals(""EUR"")) {
			return ""\u20AC"" + price;
		} else if (currency.equals(""JPY"")) {
			return ""\u00A5"" + price;
		}
		return currency + "" "" + price;
	}
}
",False,110,7,29,4,3,3,2,L6
115,org.geometerplus.fbreader.network.urlInfo.UrlInfoWithDate.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.urlInfo;

import java.util.Date;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

public final class UrlInfoWithDate extends UrlInfo {
	private static final long serialVersionUID = -896768978957787222L;

	public static final UrlInfoWithDate NULL = new UrlInfoWithDate(null, null);

	public final Date Updated;

	public UrlInfoWithDate(Type type, String url, Date updated) {
		super(type, url);
		Updated = updated;
	}

	public UrlInfoWithDate(Type type, String url) {
		this(type, url, new Date());
	}

	@Override
	public boolean equals(Object o) {
		if (o == this) {
			return true;
		}
		if (!(o instanceof UrlInfoWithDate)) {
			return false;
		}

		final UrlInfoWithDate info = (UrlInfoWithDate)o;
		return
			InfoType == info.InfoType &&
			ZLMiscUtil.equals(Url, info.Url) &&
			ZLMiscUtil.equals(Updated, info.Updated);
	}

	@Override
	public int hashCode() {
		return InfoType.hashCode() + ZLMiscUtil.hashCode(Url) + ZLMiscUtil.hashCode(Updated);
	}
}
",False,105,5,32,1,2,11,2,L6
116,org.geometerplus.fbreader.network.urlInfo.UrlInfoCollection.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.urlInfo;

import java.util.*;
import java.io.Serializable;

public class UrlInfoCollection<T extends UrlInfo> implements Serializable {
	private static final long serialVersionUID = -834589080548958222L;

	private final LinkedList<T> myInfos = new LinkedList<T>();

	public UrlInfoCollection() {
	}

	public UrlInfoCollection(UrlInfoCollection<? extends T> other) {
		myInfos.addAll(other.myInfos);
	}

	public void upgrade(UrlInfoCollection<? extends T> other) {
		myInfos.removeAll(other.myInfos);
		myInfos.addAll(other.myInfos);
	}

	public void addInfo(T info) {
		if (info != null && info.InfoType != null) {
			myInfos.add(info);
		}
	}

	public T getInfo(UrlInfo.Type type) {
		for (T info : myInfos) {
			if (info.InfoType == type) {
				return info;
			}
		}
		return null;
	}

	public List<T> getAllInfos() {
		return Collections.unmodifiableList(myInfos);
	}

	public List<T> getAllInfos(UrlInfo.Type type) {
		List<T> list = null;
		for (T info : myInfos) {
			if (info.InfoType == type) {
				if (list == null) {
					list = new LinkedList<T>();
				}
				list.add(info);
			}
		}
		return list != null ? list : Collections.<T>emptyList();
	}

	public String getUrl(UrlInfo.Type type) {
		final T info = getInfo(type);
		return info != null ? info.Url : null;
	}

	public void clear() {
		myInfos.clear();
	}

	public void removeAllInfos(UrlInfo.Type type) {
		List<T> list = null;
		for (T info : myInfos) {
			if (info.InfoType == type) {
				if (list == null) {
					list = new LinkedList<T>();
				}
				list.add(info);
			}
		}

		if (list != null) {
			myInfos.removeAll(list);
		}
	}

	public boolean isEmpty() {
		return myInfos.isEmpty();
	}
}
",False,105,5,31,2,1,22,1,L6
117,org.geometerplus.fbreader.network.urlInfo.UrlInfo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.urlInfo;

import java.io.Serializable;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

public class UrlInfo implements Serializable {
	private static final long serialVersionUID = -893514485257788222L;

	public static enum Type {
		// Never rename elements of this enum; these names are used in network database
		Catalog,
		HtmlPage,
		SingleEntry,
		Related,
		Image,
		Thumbnail,
		Search,
		SignIn,
		SignOut,
		SignUp,
		TopUp,
		RecoverPassword,
		Book,
		BookConditional,
		BookDemo,
		BookFullOrDemo,
		BookBuy,
		BookBuyInBrowser,
		TOC,
		Comments
	}

	public final Type InfoType;
	public final String Url;

	public UrlInfo(Type type, String url) {
		InfoType = type;
		Url = url;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof UrlInfo)) {
			return false;
		}
		final UrlInfo info = (UrlInfo)o;
		return InfoType == info.InfoType && ZLMiscUtil.equals(Url, info.Url);
	}

	@Override
	public int hashCode() {
		return InfoType.hashCode() + ZLMiscUtil.hashCode(Url);
	}
}
",False,110,5,36,1,1,31,1,L6
118,org.geometerplus.fbreader.network.urlInfo.BookUrlInfo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.urlInfo;

import java.io.File;
import java.net.URI;

import org.geometerplus.fbreader.Paths;

// resolvedReferenceType -- reference type without any ambiguity (for example, DOWNLOAD_FULL_OR_DEMO is ambiguous)

public class BookUrlInfo extends UrlInfo {
	private static final long serialVersionUID = -893514485257788221L;

	public interface Format {
		int NONE = 0;
		int MOBIPOCKET = 1;
		int FB2_ZIP = 2;
		int EPUB = 3;
	}

	public final int BookFormat;

	public BookUrlInfo(Type type, int format, String url) {
		super(type, url);
		BookFormat = format;
	}

	private static final String TOESCAPE = ""<>:\""|?*\\"";

	public static String makeBookFileName(String url, int format, Type resolvedReferenceType) {
		URI uri;
		try {
			uri = new URI(url);
		} catch (Throwable ex) {
			return null;
		}

		String host = uri.getHost();

		StringBuilder path = new StringBuilder(host);
		if (host.startsWith(""www."")) {
			path.delete(0, 4);
		}
		path.insert(0, File.separator);
		if (resolvedReferenceType == Type.BookDemo) {
			path.insert(0, ""Demos"");
			path.insert(0, File.separator);
		}
		path.insert(0, Paths.BooksDirectoryOption().getValue());

		int index = path.length();
		path.append(uri.getPath());
		int nameIndex = index;
		while (index < path.length()) {
			char ch = path.charAt(index);
			if (TOESCAPE.indexOf(ch) != -1) {
				path.setCharAt(index, '_');
			}
			if (ch == '/') {
				if (index + 1 == path.length()) {
					path.deleteCharAt(index);
				} else {
					path.setCharAt(index, File.separatorChar);
					nameIndex = index + 1;
				}
			}
			++index;
		}

		String ext = null;
		switch (format) {
			case Format.EPUB:
				ext = "".epub"";
				break;
			case Format.MOBIPOCKET:
				ext = "".mobi"";
				break;
			case Format.FB2_ZIP:
				ext = "".fb2.zip"";
				break;
		}

		if (ext == null) {
			int j = path.indexOf(""."", nameIndex); // using not lastIndexOf to preserve extensions like `.fb2.zip`
			if (j != -1) {
				ext = path.substring(j);
				path.delete(j, path.length());
			} else {
				return null;
			}
		} else if (path.length() > ext.length() && path.substring(path.length() - ext.length()).equals(ext)) {
			path.delete(path.length() - ext.length(), path.length());
		}

		String query = uri.getQuery();
		if (query != null) {
			index = 0;
			while (index < query.length()) {
				int j = query.indexOf(""&"", index);
				if (j == -1) {
					j = query.length();
				}
				String param = query.substring(index, j);
				if (!param.startsWith(""username="")
					&& !param.startsWith(""password="")
					&& !param.endsWith(""="")) {
					int k = path.length();
					path.append(""_"").append(param);
					while (k < path.length()) {
						char ch = path.charAt(k);
						if (TOESCAPE.indexOf(ch) != -1 || ch == '/') {
							path.setCharAt(k, '_');
						}
						++k;
					}
				}
				index = j + 1;
			}
		}
		return path.append(ext).toString();
	}

	// Url with no user-dependent info; is overridden in DecoratedBookUrlInfo
	public String cleanUrl() {
		return Url;
	}

	public final String makeBookFileName(Type resolvedReferenceType) {
		return makeBookFileName(cleanUrl(), BookFormat, resolvedReferenceType);
	}

	public final String localCopyFileName(Type resolvedReferenceType) {
		String fileName = makeBookFileName(resolvedReferenceType);
		if (fileName != null && new File(fileName).exists()) {
			return fileName;
		}
		return null;
	}

	public String toString() {
		return ""BookReference[type="" + InfoType + "";format="" + BookFormat + "";URL="" + Url + ""]"";
	}
}
",True,111,6,30,3,3,11,3,L6
119,org.geometerplus.fbreader.network.urlInfo.RelatedUrlInfo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.urlInfo;

import org.geometerplus.zlibrary.core.util.MimeType;

public class RelatedUrlInfo extends UrlInfo {
	private static final long serialVersionUID = -893514485257788098L;

	public final String Title;
	public final MimeType Mime;

	public RelatedUrlInfo(Type type, String title, MimeType mime, String url) {
		super(type, url);
		Title = title;
		Mime = mime;
	}
}
",False,107,7,27,2,2,4,2,L6
120,org.geometerplus.fbreader.network.urlInfo.DecoratedBookUrlInfo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.urlInfo;

public class DecoratedBookUrlInfo extends BookUrlInfo {
	private static final long serialVersionUID = 8558634525845586904L;

	private final String myCleanUrl;

	public DecoratedBookUrlInfo(BookUrlInfo base, String url) {
		super(base.InfoType, base.BookFormat, url);
		myCleanUrl = base.cleanUrl();
	}

	@Override
	public String cleanUrl() {
		return myCleanUrl;
	}
}
",False,110,8,36,4,3,1,2,L6
121,org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication;

import java.util.*;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.OPDSNetworkLink;
import org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager;
import org.geometerplus.fbreader.network.urlInfo.BookUrlInfo;

public abstract class NetworkAuthenticationManager {
	private static final HashMap<String, NetworkAuthenticationManager> ourManagers = new HashMap<String, NetworkAuthenticationManager>();

	public static NetworkAuthenticationManager createManager(INetworkLink link, String sslCertificate, Class<? extends NetworkAuthenticationManager> managerClass) {
		NetworkAuthenticationManager mgr = ourManagers.get(link.getSiteName());
		if (mgr == null) {
			if (managerClass == LitResAuthenticationManager.class) {
				mgr = new LitResAuthenticationManager((OPDSNetworkLink)link);
			}
			if (mgr != null) {
				ourManagers.put(link.getSiteName(), mgr);
			}
		}
		return mgr;
	}


	public final INetworkLink Link;
	public final ZLStringOption UserNameOption;
	public final String SSLCertificate;

	protected NetworkAuthenticationManager(INetworkLink link, String sslCertificate) {
		Link = link;
		UserNameOption = new ZLStringOption(link.getSiteName(), ""userName"", """");
		SSLCertificate = sslCertificate;
	}

	/*
	 * Common manager methods
	 */
	public abstract boolean isAuthorised(boolean useNetwork /* = true */) throws ZLNetworkException;
	public abstract void authorise(String password) throws ZLNetworkException;
	public abstract void logOut();
	public abstract BookUrlInfo downloadReference(NetworkBookItem book);

	public final boolean mayBeAuthorised(boolean useNetwork) {
		try {
			return isAuthorised(useNetwork);
		} catch (ZLNetworkException e) {
		}
		return true;
	}

	/*
	 * Account specific methods (can be called only if authorised!!!)
	 */
	public abstract String currentUserName();

	public boolean needsInitialization() {
		return false;
	}

	public void initialize() throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}

	// returns true if link must be purchased before downloading
	public boolean needPurchase(NetworkBookItem book) {
		return true;
	}

	public void purchaseBook(NetworkBookItem book) throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}

	public List<NetworkBookItem> purchasedBooks() {
		return Collections.emptyList();
	}

	public String currentAccount() {
		return null;
	}

	//public abstract ZLNetworkSSLCertificate certificate();

	/*
	 * topup account
	 */

	public String topupLink() {
		return null;
	}
	public Map<String,String> getTopupData() {
		return Collections.emptyMap();
	}

	/*
	 * Password Recovery
	 */
	public boolean passwordRecoverySupported() {
		return false;
	}

	public void recoverPassword(String email) throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}
}
",True,194,7,26,10,35,12,8,L6
122,org.geometerplus.fbreader.network.authentication.litres.LitResLoginXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkException;

class LitResLoginXMLReader extends LitResAuthenticationXMLReader {
	private static final String TAG_AUTHORIZATION_OK = ""catalit-authorization-ok"";
	private static final String TAG_AUTHORIZATION_FAILED = ""catalit-authorization-failed"";

	public String FirstName;
	public String LastName;
	public String UserId;
	public String Sid;
	public boolean CanRebill;

	public LitResLoginXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_AUTHORIZATION_FAILED == tag) {
			setException(new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED));
		} else if (TAG_AUTHORIZATION_OK == tag) {
			FirstName = attributes.getValue(""first-name"");
			LastName = attributes.getValue(""first-name"");
			UserId = attributes.getValue(""user-id"");
			Sid = attributes.getValue(""sid"");
			String stringCanRebill = attributes.getValue(""can-rebill"");
			if (stringCanRebill == null) {
				stringCanRebill = attributes.getValue(""can_rebill"");
			}
			CanRebill = stringCanRebill != null && !""0"".equals(stringCanRebill) && !""no"".equalsIgnoreCase(stringCanRebill);
		} else {
			setException(new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, HostName));
		}
		return true;
	}
}
",True,134,8,36,7,6,1,4,L6
123,org.geometerplus.fbreader.network.authentication.litres.LitResPasswordRecoveryXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkException;

class LitResPasswordRecoveryXMLReader extends LitResAuthenticationXMLReader {
	private static final String TAG_PASSWORD_RECOVERY_OK = ""catalit-pass-recover-ok"";
	private static final String TAG_PASSWORD_RECOVERY_FAILED = ""catalit-pass-recover-failed"";

	public LitResPasswordRecoveryXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_PASSWORD_RECOVERY_FAILED == tag) {
			final String error = attributes.getValue(""error"");
			if (""1"".equals(error)) {
				setException(new ZLNetworkException(NetworkException.ERROR_NO_USER_EMAIL));
			} else if (""2"".equals(error)) {
				setException(new ZLNetworkException(NetworkException.ERROR_EMAIL_WAS_NOT_SPECIFIED));
			} else {
				setException(new ZLNetworkException(NetworkException.ERROR_INTERNAL));
			}
		} else if (TAG_PASSWORD_RECOVERY_OK == tag) {
			// NOP
		} else {
			setException(new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, HostName));
		}
		return true;
	}
}
",True,134,8,36,7,6,1,4,L6
124,org.geometerplus.fbreader.network.authentication.litres.LitResNetworkRequest.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.io.InputStream;
import java.io.IOException;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

public class LitResNetworkRequest extends ZLNetworkRequest {
	public final LitResAuthenticationXMLReader Reader;

	static String clean(String url) {
		final int index = url.indexOf('?');
		return index != -1 ? url.substring(0, index) : url;
	}

	public LitResNetworkRequest(String url, LitResAuthenticationXMLReader reader) {
		super(clean(url), null, null);
		final int index = url.indexOf('?');
		if (index != -1) {
			for (String param : url.substring(index + 1).split(""&"")) {
				String[] pp = param.split(""="");
				if (pp.length == 2) {
					addPostParameter(pp[0], pp[1]);
				}
			}
		}
		Reader = reader;
	}

	@Override
	public void handleStream(InputStream inputStream, int length) throws IOException, ZLNetworkException {
		Reader.read(inputStream);
		ZLNetworkException e = Reader.getException();
		if (e != null) {
			throw e;
		}
	}
}
",False,134,8,36,6,8,1,4,L6
125,org.geometerplus.fbreader.network.authentication.litres.LitResXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.fbreader.network.NetworkItem;
import org.geometerplus.fbreader.network.opds.OPDSBookItem;
import org.geometerplus.fbreader.network.opds.OPDSNetworkLink;
import org.geometerplus.fbreader.network.atom.FormattedBuffer;
import org.geometerplus.fbreader.network.urlInfo.*;

class LitResXMLReader extends LitResAuthenticationXMLReader {
	public final OPDSNetworkLink Link;
	public final List<NetworkItem> Books;

	private int myIndex;

	private String myBookId;
	private String myTitle;
	//private String myLanguage;
	//private String myDate;
	private String mySeriesTitle;
	private int myIndexInSeries;

	private CharSequence mySummary;

	private final UrlInfoCollection<UrlInfo> myUrls = new UrlInfoCollection<UrlInfo>();

	private String myAuthorFirstName;
	private String myAuthorMiddleName;
	private String myAuthorLastName;
	private LinkedList<OPDSBookItem.AuthorData> myAuthors = new LinkedList<OPDSBookItem.AuthorData>();

	private LinkedList<String> myTags = new LinkedList<String>();

	public LitResXMLReader(OPDSNetworkLink link, List<NetworkItem> books) {
		super(link.getSiteName());
		Link = link;
		Books = books;
	}


	private static final int START = 0;
	private static final int CATALOG = 1;
	private static final int BOOK = 2;
	private static final int BOOK_DESCRIPTION = 3;
	private static final int HIDDEN = 4;
	private static final int TITLE_INFO = 5;
	private static final int GENRE = 6;
	private static final int AUTHOR = 7;
	private static final int FIRST_NAME = 8;
	private static final int MIDDLE_NAME = 9;
	private static final int LAST_NAME = 10;
	private static final int BOOK_TITLE = 11;
	private static final int ANNOTATION = 12;
	private static final int DATE = 13;
	private static final int LANGUAGE = 14;

	private static final String TAG_CATALOG = ""catalit-fb2-books"";
	private static final String TAG_BOOK = ""fb2-book"";
	private static final String TAG_TEXT_DESCRIPTION = ""text_description"";
	private static final String TAG_HIDDEN = ""hidden"";
	private static final String TAG_TITLE_INFO = ""title-info"";
	private static final String TAG_GENRE = ""genre"";
	private static final String TAG_AUTHOR = ""author"";
	private static final String TAG_FIRST_NAME = ""first-name"";
	private static final String TAG_MIDDLE_NAME = ""middle-name"";
	private static final String TAG_LAST_NAME = ""last-name"";
	private static final String TAG_BOOK_TITLE = ""book-title"";
	private static final String TAG_ANNOTATION = ""annotation"";
	private static final String TAG_DATE = ""date"";
	private static final String TAG_SEQUENCE = ""sequence"";
	private static final String TAG_LANGUAGE = ""lang"";

	private int myState = START;
	private final StringBuilder myBuffer = new StringBuilder();
	private FormattedBuffer myAnnotationBuffer = new FormattedBuffer(FormattedBuffer.Type.XHtml);

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.intern();

		switch (myState) {
			case START:
				if (TAG_CATALOG == tag) {
					myState = CATALOG;
				}
				break;
			case CATALOG:
				if (TAG_BOOK == tag) {
					myBookId = attributes.getValue(""hub_id"");
					myUrls.addInfo(new UrlInfo(
						UrlInfo.Type.Image, attributes.getValue(""cover_preview"")
					));
        
					myUrls.addInfo(new BookUrlInfo(
						UrlInfo.Type.BookConditional,
						BookUrlInfo.Format.FB2_ZIP,
						""https://robot.litres.ru/pages/catalit_download_book/?art="" + myBookId
					));
					myState = BOOK;
				}
				break;
			case BOOK:
				if (TAG_TEXT_DESCRIPTION == tag) {
					myState = BOOK_DESCRIPTION;
				}
				break;
			case BOOK_DESCRIPTION:
				if (TAG_HIDDEN == tag) {
					myState = HIDDEN;
				}
				break;
			case HIDDEN:
				if (TAG_TITLE_INFO == tag) {
					myState = TITLE_INFO;
				}
				break;
			case TITLE_INFO:
				if (TAG_GENRE == tag) {
					myState = GENRE;
				} else if (TAG_AUTHOR == tag) {
					myState = AUTHOR;
				} else if (TAG_BOOK_TITLE == tag) {
					myState = BOOK_TITLE;
				} else if (TAG_ANNOTATION == tag) {
					myState = ANNOTATION;
				} else if (TAG_DATE == tag) {
					myState = DATE;
				} else if (TAG_LANGUAGE == tag) {
					myState = LANGUAGE;
				} else if (TAG_SEQUENCE == tag) {
					mySeriesTitle = attributes.getValue(""name"");
					if (mySeriesTitle != null) {
						myIndexInSeries = 0;
						final String indexInSeries = attributes.getValue(""number"");
						if (indexInSeries != null) {
							try {
								myIndexInSeries = Integer.parseInt(indexInSeries);
							} catch (NumberFormatException e) {
							}
						}
					}
					//myState = SEQUENCE; // handled through attributes without state
				}
				break;
			case AUTHOR:
				if (TAG_FIRST_NAME == tag) {
					myState = FIRST_NAME;
				} else if (TAG_MIDDLE_NAME == tag) {
					myState = MIDDLE_NAME;
				} else if (TAG_LAST_NAME == tag) {
					myState = LAST_NAME;
				}
				break;
			case ANNOTATION:
				myAnnotationBuffer.appendText(myBuffer);
				myAnnotationBuffer.appendStartTag(tag, attributes);
				break;
		}

		myBuffer.delete(0, myBuffer.length());
		return false;
	}


	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.intern();

		switch (myState) {
			case CATALOG:
				if (TAG_CATALOG == tag) {
					myState = START;
				}
				break;
			case BOOK:
				if (TAG_BOOK == tag) {
					myUrls.addInfo(new UrlInfo(	
						UrlInfo.Type.SingleEntry,
						""http://data.fbreader.org/catalogs/litres2/full.php5?id="" + myBookId
					));
					Books.add(new OPDSBookItem(
						Link,
						myBookId,
						myIndex++,
						myTitle,
						mySummary,
						//myLanguage,
						//myDate,
						myAuthors,
						myTags,
						mySeriesTitle,
						myIndexInSeries,
						myUrls
					));
        
					myBookId = myTitle = /*myLanguage = myDate = */mySeriesTitle = null;
					mySummary = null;
					myIndexInSeries = 0;
					myAuthors.clear();
					myTags.clear();
					myUrls.clear();
					myState = CATALOG;
				}
				break;
			case BOOK_DESCRIPTION:
				if (TAG_TEXT_DESCRIPTION == tag) {
					myState = BOOK;
				}
				break;
			case HIDDEN:
				if (TAG_HIDDEN == tag) {
					myState = BOOK_DESCRIPTION;
				}
				break;
			case TITLE_INFO:
				if (TAG_TITLE_INFO == tag) {
					myState = HIDDEN;
				}
				break;
			case AUTHOR:
				if (TAG_AUTHOR == tag) {
					StringBuilder displayName = new StringBuilder();
					if (myAuthorFirstName != null) {
						displayName.append(myAuthorFirstName).append("" "");
					}
					if (myAuthorMiddleName != null) {
						displayName.append(myAuthorMiddleName).append("" "");
					}
					if (myAuthorLastName != null) {
						displayName.append(myAuthorLastName).append("" "");
					}
					myAuthors.add(new OPDSBookItem.AuthorData(displayName.toString().trim(), myAuthorLastName));
					myAuthorFirstName = null;
					myAuthorMiddleName = null;
					myAuthorLastName = null;
					myState = TITLE_INFO;
				}
				break;
			case FIRST_NAME:
				if (TAG_FIRST_NAME == tag) {
					myAuthorFirstName = myBuffer.toString();
					myState = AUTHOR;
				}
				break;
			case MIDDLE_NAME:
				if (TAG_MIDDLE_NAME == tag) {
					myAuthorMiddleName = myBuffer.toString();
					myState = AUTHOR;
				}
				break;
			case LAST_NAME:
				if (TAG_LAST_NAME == tag) {
					myAuthorLastName = myBuffer.toString();
					myState = AUTHOR;
				}
				break;
			case GENRE:
				if (TAG_GENRE == tag) {
					/*if (myBuffer.length() != 0) {
						const std::map<std::string,shared_ptr<LitResGenre> > &genresMap =
							LitResGenreMap::Instance().genresMap();
						const std::map<shared_ptr<LitResGenre>,std::string> &genresTitles =
							LitResGenreMap::Instance().genresTitles();
        
						std::map<std::string, shared_ptr<LitResGenre> >::const_iterator it = genresMap.find(myBuffer);
						if (it != genresMap.end()) {
							std::map<shared_ptr<LitResGenre>, std::string>::const_iterator jt = genresTitles.find(it->second);
							if (jt != genresTitles.end()) {
								myTags.push_back(jt->second);
							}
						}
					}*/
					myState = TITLE_INFO;
				}
				break;
			case BOOK_TITLE:
				if (TAG_BOOK_TITLE == tag) {
					myTitle = myBuffer.toString();
					myState = TITLE_INFO;
				}
				break;
			case ANNOTATION:
				myAnnotationBuffer.appendText(myBuffer);
				if (TAG_ANNOTATION == tag) {
					mySummary = myAnnotationBuffer.getText();
					myAnnotationBuffer.reset();
					myState = TITLE_INFO;
				} else {
					myAnnotationBuffer.appendEndTag(tag);
				}
				break;
			case DATE:
				if (TAG_DATE == tag) {
					//myDate = myBuffer.toString();
					myState = TITLE_INFO;
				}
				break;
			case LANGUAGE:
				if (TAG_LANGUAGE == tag) {
					//myLanguage = myBuffer.toString();
					myState = TITLE_INFO;
				}
				break;
		}

		myBuffer.delete(0, myBuffer.length());
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int length) {
		myBuffer.append(data, start, length);
	}
}
",True,140,0,0,8,38,1,12,L6
126,org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.OPDSNetworkLink;
import org.geometerplus.fbreader.network.authentication.*;
import org.geometerplus.fbreader.network.urlInfo.*;

public class LitResAuthenticationManager extends NetworkAuthenticationManager {
	private volatile boolean myFullyInitialized;

	private final ZLStringOption mySidOption;
	private final ZLStringOption myUserIdOption;
	private final ZLBooleanOption myCanRebillOption;

	private volatile String myInitializedDataSid;
	private volatile String myAccount;
	private final Map<String,NetworkBookItem> myPurchasedBookMap =
		new HashMap<String,NetworkBookItem>();
	private final List<NetworkBookItem> myPurchasedBookList =
		new LinkedList<NetworkBookItem>();

	public LitResAuthenticationManager(OPDSNetworkLink link) {
		super(link, null);

		mySidOption = new ZLStringOption(link.getSiteName(), ""sid"", """");
		myUserIdOption = new ZLStringOption(link.getSiteName(), ""userId"", """");
		myCanRebillOption = new ZLBooleanOption(link.getSiteName(), ""canRebill"", false);
	}

	public synchronized void initUser(String userName, String sid, String userId, boolean canRebill) {
		UserNameOption.setValue(userName);
		mySidOption.setValue(sid);
		myUserIdOption.setValue(userId);
		myCanRebillOption.setValue(canRebill);
		myFullyInitialized = !"""".equals(userName) && !"""".equals(sid) && !"""".equals(userId);
	}

	@Override
	public synchronized void logOut() {
		initUser("""", """", """", false);
		myInitializedDataSid = null;
		myPurchasedBookMap.clear();
		myPurchasedBookList.clear();
	}

	@Override
	public boolean isAuthorised(boolean useNetwork) throws ZLNetworkException {
		final String sid;
		synchronized (this) {
			boolean authState =
				UserNameOption.getValue().length() != 0 &&
				mySidOption.getValue().length() != 0;

			if (myFullyInitialized || !useNetwork) {
				return authState;
			}

			if (!authState) {
				logOut();
				return false;
			}
			sid = mySidOption.getValue();
		}

		String url = Link.getUrl(UrlInfo.Type.SignIn);
		if (url == null) {
			throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
		}

		final LitResLoginXMLReader xmlReader = new LitResLoginXMLReader(Link.getSiteName());

		ZLNetworkException exception = null;
		try {
			final LitResNetworkRequest request = new LitResNetworkRequest(url, xmlReader);
			request.addPostParameter(""sid"", sid);
			ZLNetworkManager.Instance().perform(request);
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (exception != null) {
				if (NetworkException.ERROR_AUTHENTICATION_FAILED.equals(exception.getCode())) {
					throw exception;
				}
				logOut();
				return false;
			}
			initUser(UserNameOption.getValue(), xmlReader.Sid, xmlReader.UserId, xmlReader.CanRebill);
			return true;
		}
	}

	@Override
	public void authorise(String password) throws ZLNetworkException {
		String url = Link.getUrl(UrlInfo.Type.SignIn);
		if (url == null) {
			throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
		}
		final String login;
		synchronized (this) {
			login = UserNameOption.getValue();
		}

		final LitResLoginXMLReader xmlReader = new LitResLoginXMLReader(Link.getSiteName());

		ZLNetworkException exception = null;
		try {
			final LitResNetworkRequest request = new LitResNetworkRequest(url, xmlReader);
			request.addPostParameter(""login"", login);
			request.addPostParameter(""pwd"", password);
			ZLNetworkManager.Instance().perform(request);
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (exception != null) {
				logOut();
				throw exception;
			}
			initUser(UserNameOption.getValue(), xmlReader.Sid, xmlReader.UserId, xmlReader.CanRebill);
		}
	}

	@Override
	public BookUrlInfo downloadReference(NetworkBookItem book) {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			return null;
		}
		BookUrlInfo reference = book.reference(UrlInfo.Type.BookConditional);
		if (reference == null) {
			return null;
		}
		final String url = ZLNetworkUtil.appendParameter(reference.Url, ""sid"", sid);
		return new DecoratedBookUrlInfo(reference, url);
	}


	@Override
	public String currentUserName() {
		final String value;
		synchronized (this) {
			value = UserNameOption.getValue();
		}
		if (value.length() == 0) {
			return null;
		}
		return value;
	}


	@Override
	public synchronized boolean needPurchase(NetworkBookItem book) {
		return !myPurchasedBookMap.containsKey(book.Id);
	}

	@Override
	public void purchaseBook(NetworkBookItem book) throws ZLNetworkException {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
		}

		final BookUrlInfo reference = book.reference(UrlInfo.Type.BookBuy);
		if (reference == null) {
			throw new ZLNetworkException(NetworkException.ERROR_BOOK_NOT_PURCHASED); // TODO: more correct error message???
		}

		final LitResPurchaseXMLReader xmlReader = new LitResPurchaseXMLReader(Link.getSiteName());

		ZLNetworkException exception = null;
		try {
			final LitResNetworkRequest request = new LitResNetworkRequest(reference.Url, xmlReader);
			request.addPostParameter(""sid"", sid);
			ZLNetworkManager.Instance().perform(request);
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (xmlReader.Account != null) {
				myAccount = BookBuyUrlInfo.price(xmlReader.Account, ""RUB"");
			}
			if (exception != null) {
				final String code = exception.getCode();
				if (NetworkException.ERROR_AUTHENTICATION_FAILED.equals(code)) {
					logOut();
				} else if (NetworkException.ERROR_PURCHASE_ALREADY_PURCHASED.equals(code)) {
					myPurchasedBookMap.put(book.Id, book);
					myPurchasedBookList.add(0, book);
				}
				throw exception;
			}
			if (xmlReader.BookId == null || !xmlReader.BookId.equals(book.Id)) {
				throw new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, Link.getSiteName());
			}
			myPurchasedBookMap.put(book.Id, book);
			myPurchasedBookList.add(0, book);
		}
	}

	@Override
	public String topupLink() {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			return null;
		}
		final String url = Link.getUrl(UrlInfo.Type.TopUp);
		if (url == null) {
			return null;
		}
		return ZLNetworkUtil.appendParameter(url, ""sid"", sid);
	}

	@Override
	public synchronized String currentAccount() {
		return myAccount;
	}

	void reloadPurchasedBooks() throws ZLNetworkException {
		final LitResNetworkRequest networkRequest;
		synchronized (this) {
			final String sid = mySidOption.getValue();
			if (sid.length() == 0) {
				throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
			}
			if (!sid.equals(myInitializedDataSid)) {
				logOut();
				throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
			}
			networkRequest = loadPurchasedBooks();
		}

		ZLNetworkException exception = null;
		try {
			ZLNetworkManager.Instance().perform(networkRequest);
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (exception != null) {
				//loadPurchasedBooksOnError();
				if (NetworkException.ERROR_AUTHENTICATION_FAILED.equals(exception.getCode())) {
					logOut();
				}
				throw exception;
			}
			loadPurchasedBooksOnSuccess(networkRequest);
		}
	}

	@Override
	public synchronized List<NetworkBookItem> purchasedBooks() {
		return Collections.unmodifiableList(myPurchasedBookList);
	}

	@Override
	public synchronized boolean needsInitialization() {
		final String sid = mySidOption.getValue();
		if (sid.length() == 0) {
			return false;
		}
		return !sid.equals(myInitializedDataSid);
	}

	@Override
	public void initialize() throws ZLNetworkException {
		final String sid;
		final LitResNetworkRequest purchasedBooksRequest;
		final LitResNetworkRequest accountRequest;
		synchronized (this) {
			sid = mySidOption.getValue();
			if (sid.length() == 0) {
				throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
			}
			if (sid.equals(myInitializedDataSid) || !isAuthorised(true)) {
				return;
			}

			purchasedBooksRequest = loadPurchasedBooks();
			accountRequest = loadAccount();
		}

		final LinkedList<ZLNetworkRequest> requests = new LinkedList<ZLNetworkRequest>();
		requests.add(purchasedBooksRequest);
		requests.add(accountRequest);

		ZLNetworkException exception = null;
		try {
			ZLNetworkManager.Instance().perform(requests);
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (exception != null) {
				myInitializedDataSid = null;
				loadPurchasedBooksOnError();
				loadAccountOnError();
				throw exception;
			}
			myInitializedDataSid = sid;
			loadPurchasedBooksOnSuccess(purchasedBooksRequest);
			loadAccountOnSuccess(accountRequest);
		}
	}

	private LitResNetworkRequest loadPurchasedBooks() {
		final String sid = mySidOption.getValue();
		final String query = ""pages/catalit_browser/"";

		final LitResNetworkRequest request = new LitResNetworkRequest(
			LitResUtil.url(Link, query),
			new LitResXMLReader((OPDSNetworkLink)Link, new LinkedList<NetworkItem>())
		);
		request.addPostParameter(""my"", ""1"");
		request.addPostParameter(""sid"", sid);
		return request;
	}

	private void loadPurchasedBooksOnError() {
		myPurchasedBookMap.clear();
		myPurchasedBookList.clear();
	}

	private void loadPurchasedBooksOnSuccess(LitResNetworkRequest purchasedBooksRequest) {
		LitResXMLReader reader = (LitResXMLReader)purchasedBooksRequest.Reader;
		myPurchasedBookMap.clear();
		myPurchasedBookList.clear();
		for (NetworkItem item : reader.Books) {
			if (item instanceof NetworkBookItem) {
				NetworkBookItem book = (NetworkBookItem)item;
				myPurchasedBookMap.put(book.Id, book);
				myPurchasedBookList.add(book);
			}
		}
	}

	private LitResNetworkRequest loadAccount() {
		final String sid = mySidOption.getValue();
		final String query = ""pages/purchase_book/"";

		final LitResNetworkRequest request = new LitResNetworkRequest(
			LitResUtil.url(Link, query),
			new LitResPurchaseXMLReader(Link.getSiteName())
		);
		request.addPostParameter(""sid"", sid);
		request.addPostParameter(""art"", ""0"");
		return request;
	}

	private void loadAccountOnError() {
		myAccount = null;
	}

	private void loadAccountOnSuccess(LitResNetworkRequest accountRequest) {
		LitResPurchaseXMLReader reader = (LitResPurchaseXMLReader)accountRequest.Reader;
		myAccount = BookBuyUrlInfo.price(reader.Account, ""RUB"");
	}

	@Override
	public boolean passwordRecoverySupported() {
		return true;
	}

	@Override
	public void recoverPassword(String email) throws ZLNetworkException {
		final String url = Link.getUrl(UrlInfo.Type.RecoverPassword);
		if (url == null) {
			throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
		}
		final LitResPasswordRecoveryXMLReader xmlReader =  new LitResPasswordRecoveryXMLReader(Link.getSiteName());
		final LitResNetworkRequest request = new LitResNetworkRequest(url, xmlReader);
		request.addPostParameter(""mail"", email);
		ZLNetworkManager.Instance().perform(request);
	}

	@Override
	public Map<String,String> getTopupData() {
		final HashMap<String,String> map = new HashMap<String,String>();
		map.put(""litres:userId"", myUserIdOption.getValue());
		map.put(""litres:canRebill"", myCanRebillOption.getValue() ? ""true"" : ""false"");
		map.put(""litres:sid"", mySidOption.getValue());
		return map;
	}
}
",False,194,7,26,9,33,5,23,L6
127,org.geometerplus.fbreader.network.authentication.litres.LitResRecommendationsItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.OPDSCatalogItem;
import org.geometerplus.fbreader.network.opds.OPDSNetworkLink;
import org.geometerplus.fbreader.network.urlInfo.*;

public class LitResRecommendationsItem extends OPDSCatalogItem {
	public LitResRecommendationsItem(OPDSNetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls) {
		super(link, title, summary, urls, Accessibility.HAS_BOOKS, FLAGS_DEFAULT & ~FLAGS_GROUP);
	}

	@Override
	protected String getCatalogUrl() {
		final LitResAuthenticationManager mgr =
			(LitResAuthenticationManager)Link.authenticationManager();
		final StringBuilder builder = new StringBuilder();
		boolean flag = false;
		for (NetworkBookItem book : mgr.purchasedBooks()) {
			if (flag) {
				builder.append(',');
			} else {
				flag = true;
			}
			builder.append(book.Id);
		}
		final Basket basket = Link.basket();
		if (basket != null) {
			for (String bookId : basket.bookIds()) {
				if (flag) {
					builder.append(',');
				} else {
					flag = true;
				}
				builder.append(bookId);
			}
		}

		return ZLNetworkUtil.appendParameter(getUrl(UrlInfo.Type.Catalog), ""ids"", builder.toString());
	}
}
",False,140,0,0,10,31,1,11,L6
128,org.geometerplus.fbreader.network.authentication.litres.LitResPurchaseXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkException;

class LitResPurchaseXMLReader extends LitResAuthenticationXMLReader {
	private static final String TAG_AUTHORIZATION_FAILED = ""catalit-authorization-failed"";
	private static final String TAG_PURCHASE_OK = ""catalit-purchase-ok"";
	private static final String TAG_PURCHASE_FAILED = ""catalit-purchase-failed"";

	public String Account;
	public String BookId;

	public LitResPurchaseXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_AUTHORIZATION_FAILED == tag) {
			setException(new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED));
		} else {
			Account = attributes.getValue(""account"");
			BookId = attributes.getValue(""art"");
			if (TAG_PURCHASE_OK == tag) {
				// nop
			} else if (TAG_PURCHASE_FAILED == tag) {
				final String error = attributes.getValue(""error"");
				if (""1"".equals(error)) {
					setException(new ZLNetworkException(NetworkException.ERROR_PURCHASE_NOT_ENOUGH_MONEY));
				} else if (""2"".equals(error)) {
					setException(new ZLNetworkException(NetworkException.ERROR_PURCHASE_MISSING_BOOK));
				} else if (""3"".equals(error)) {
					setException(new ZLNetworkException(NetworkException.ERROR_PURCHASE_ALREADY_PURCHASED));
				} else {
					setException(new ZLNetworkException(NetworkException.ERROR_INTERNAL));
				}
			} else {
				setException(new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, HostName));
			}
		}
		return true;
	}
}
",True,134,8,36,7,6,1,4,L6
129,org.geometerplus.fbreader.network.authentication.litres.LitResGenre.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.LinkedList;

class LitResGenre {
	public String Id;
	public String Title;
	public LinkedList<LitResGenre> Children;
}
",False,1,0,0,0,0,0,0,I0
130,org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

class LitResAuthenticationXMLReader extends ZLXMLReaderAdapter {
	public final String HostName;

	public LitResAuthenticationXMLReader(String hostName) {
		HostName = hostName;
	}

	private ZLNetworkException myException;

	protected void setException(ZLNetworkException e) {
		myException = e;
	}

	protected void setErrorMessage(String errorMessage) {
		myException = new ZLNetworkException(true, errorMessage);
	}

	public ZLNetworkException getException() {
		return myException;
	}
}
",False,136,9,35,6,8,5,2,L6
131,org.geometerplus.fbreader.network.authentication.litres.LitResBookshelfItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.urlInfo.UrlInfoCollection;

abstract class SortedCatalogItem extends NetworkCatalogItem {
	private final List<NetworkItem> myChildren = new LinkedList<NetworkItem>();

	private SortedCatalogItem(NetworkCatalogItem parent, ZLResource resource, List<NetworkItem> children, int flags) {
		super(parent.Link, resource.getValue(), resource.getResource(""summary"").getValue(), null, Accessibility.ALWAYS, flags);
		for (NetworkItem child : children) {
			if (accepts(child)) {
				myChildren.add(child);
			}
		}
		final Comparator<NetworkItem> comparator = getComparator();
		if (comparator != null) {
			Collections.sort(myChildren, comparator);
		}
	}

	public boolean isEmpty() {
		return myChildren.isEmpty();
	}

	protected abstract Comparator<NetworkItem> getComparator();
	protected boolean accepts(NetworkItem item) {
		return item instanceof NetworkBookItem;
	}

	public SortedCatalogItem(NetworkCatalogItem parent, String resourceKey, List<NetworkItem> children, int flags) {
		this(parent, ZLResource.resource(""networkView"").getResource(resourceKey), children, flags);
	}

	@Override
	public void onDisplayItem() {
	}

	@Override
	public void loadChildren(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		for (NetworkItem child : myChildren) {
			listener.onNewItem(Link, child);
		}
		listener.commitItems(Link);
	}
}

class ByAuthorCatalogItem extends SortedCatalogItem {
	ByAuthorCatalogItem(NetworkCatalogItem parent, List<NetworkItem> children) {
		super(parent, ""byAuthor"", children, FLAG_GROUP_BY_AUTHOR);
	}

	@Override
	protected Comparator<NetworkItem> getComparator() {
		return new NetworkBookItemComparator();
	}

	@Override
	public String getStringId() {
		return ""@ByAuthor"";
	}
}

class ByTitleCatalogItem extends SortedCatalogItem {
	ByTitleCatalogItem(NetworkCatalogItem parent, List<NetworkItem> children) {
		super(parent, ""byTitle"", children, FLAG_SHOW_AUTHOR);
	}

	@Override
	protected Comparator<NetworkItem> getComparator() {
		return new Comparator<NetworkItem>() {
			public int compare(NetworkItem item0, NetworkItem item1) {
				return item0.Title.toString().compareTo(item1.Title.toString());
			}
		};
	}

	@Override
	public String getStringId() {
		return ""@ByTitle"";
	}
}

class ByDateCatalogItem extends SortedCatalogItem {
	ByDateCatalogItem(NetworkCatalogItem parent, List<NetworkItem> children) {
		super(parent, ""byDate"", children, FLAG_SHOW_AUTHOR);
	}

	@Override
	protected Comparator<NetworkItem> getComparator() {
		return null;
	}

	@Override
	public String getStringId() {
		return ""@ByDate"";
	}
}

class BySeriesCatalogItem extends SortedCatalogItem {
	BySeriesCatalogItem(NetworkCatalogItem parent, List<NetworkItem> children) {
		super(parent, ""bySeries"", children, FLAG_SHOW_AUTHOR | FLAG_GROUP_BY_SERIES);
	}

	@Override
	protected Comparator<NetworkItem> getComparator() {
		return new Comparator<NetworkItem>() {
			public int compare(NetworkItem item0, NetworkItem item1) {
				final NetworkBookItem book0 = (NetworkBookItem)item0;
				final NetworkBookItem book1 = (NetworkBookItem)item1;
				final int diff = book0.SeriesTitle.compareTo(book1.SeriesTitle);
				if (diff != 0) {
					return diff;
				}
				final float fdiff = book0.IndexInSeries - book1.IndexInSeries;
				if (fdiff != 0) {
					return fdiff > 0 ? 1 : -1;
				}
				return book0.Title.toString().compareTo(book1.Title.toString());
			}
		};
	}

	@Override
	protected boolean accepts(NetworkItem item) {
		return
			item instanceof NetworkBookItem &&
			((NetworkBookItem)item).SeriesTitle != null;
	}

	@Override
	public String getStringId() {
		return ""@BySeries"";
	}
}

public class LitResBookshelfItem extends NetworkURLCatalogItem {
	private boolean myForceReload;

	public LitResBookshelfItem(INetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls) {
		super(link, title, summary, urls, Accessibility.SIGNED_IN, FLAGS_DEFAULT);
	}

	@Override
	public void onDisplayItem() {
		myForceReload = false;
	}

	@Override
	public void loadChildren(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		final LitResAuthenticationManager mgr =
			(LitResAuthenticationManager)Link.authenticationManager();

		// TODO: Maybe it's better to call isAuthorised(true) directly 
		// and let exception fly through???
		if (!mgr.mayBeAuthorised(true)) {
			throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
		}
		try {
			if (myForceReload) {
				mgr.reloadPurchasedBooks();
			}
		} finally {
			myForceReload = true;
			// TODO: implement asynchronous loading
			ArrayList<NetworkItem> children =
				new ArrayList<NetworkItem>(mgr.purchasedBooks());
			if (children.size() <= 5) {
				Collections.sort(children, new NetworkBookItemComparator());
				for (NetworkItem item : children) {
					listener.onNewItem(Link, item);
				}
			} else {
				listener.onNewItem(Link, new ByDateCatalogItem(this, children));
				listener.onNewItem(Link, new ByAuthorCatalogItem(this, children));
				listener.onNewItem(Link, new ByTitleCatalogItem(this, children));
				final BySeriesCatalogItem bySeries = new BySeriesCatalogItem(this, children);
				if (!bySeries.isEmpty()) {
					listener.onNewItem(Link, bySeries);
				}
			}
			listener.commitItems(Link);
		}
	}
}
",False,140,0,0,10,29,1,12,L6
132,org.geometerplus.fbreader.network.authentication.litres.LitResUtil.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.INetworkLink;


class LitResUtil {

	public static String url(String path) {
		String url = ""://robot.litres.ru/"" + path;
		if (ZLNetworkUtil.hasParameter(url, ""sid"") ||
				ZLNetworkUtil.hasParameter(url, ""pwd"")) {
			url = ""https"" + url;
		} else {
			url = ""http"" + url;
		}
		return url;
	}

	public static String url(INetworkLink link, String path) {
		return link.rewriteUrl(url(path), false);
	}
}
",False,140,0,0,12,33,1,2,L6
133,org.geometerplus.fbreader.network.authentication.litres.LitResGenreMap.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

/*import java.util.LinkedList;
import java.util.HashMap;

class LitResGenreMap {

	private static LitResGenreMap ourInstance;

	LinkedList<LitResGenre> myGenresTree;
	HashMap<String, LitResGenre> myGenresMap;
	HashMap<LitResGenre, String> myGenresTitles;

	public static LitResGenreMap Instance() {
		if (ourInstance == null) {
			ourInstance = new LitResGenreMap();
		}
		return ourInstance;
	}

	private LitResGenreMap() {
	}
}
*/",False,1,0,0,0,0,0,0,I0
134,org.geometerplus.fbreader.network.atom.ATOMDateConstruct.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public abstract class ATOMDateConstruct extends ATOMCommonAttributes implements Comparable<ATOMDateConstruct> {
	public int Year;
	public int Month;
	public int Day;
	public int Hour;
	public int Minutes;
	public int Seconds;
	public float SecondFraction;
	public int TZHour;
	public int TZMinutes;

	public ATOMDateConstruct(ZLStringMap attributes) {
		super(attributes);
	}

	/*
	public ATOMDateConstruct(int year) {
		Year = year;
	}

	public ATOMDateConstruct(int year, int month, int day) {
		Year = year;
		Month = month;
		Day = day;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
		SecondFraction = sfract;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
		TZHour = tzhour;
		TZMinutes = tzminutes;
		SecondFraction = sfract;
	}
	*/

	public static boolean parse(String str, ATOMDateConstruct dateTime) {
		dateTime.Year = 0;
		dateTime.Month = 0;
		dateTime.Day = 0;
		dateTime.Hour = 0;
		dateTime.Minutes = 0;
		dateTime.Seconds = 0;
		dateTime.SecondFraction = 0.0f;
		dateTime.TZHour = 0;
		dateTime.TZMinutes = 0;

		if (str == null || dateTime == null) {
			return false;
		}

		final int len = str.length();
		if (len != 4 && len != 7 && len != 10 && len != 17 && len != 20 && len < 22) {
			return false;
		}

		int num = 0, sign = 1;
		float fnum = 0.0f, fmult = 0.1f;
		int start, end, log;
		char ch;
		end = 4; start = 0; log = 0;
		while (start < len) {
			ch = str.charAt(start++);
			if (!Character.isDigit(ch)) {
				return false;
			}
			num = 10 * num + ((int) (ch - '0'));
			fnum += fmult * ((int) (ch - '0'));
			fmult *= 0.1f;
			if (start == end) {
				switch (log) {
				case 0: dateTime.Year = num; break;
				case 1: dateTime.Month = num; break;
				case 2: dateTime.Day = num; break;
				case 3: dateTime.Hour = num; break;
				case 4: dateTime.Minutes = num; break;
				case 5: dateTime.Seconds = num; break;
				case 6: dateTime.SecondFraction = fnum; break;
				case 7: dateTime.TZHour = sign * num; break;
				case 8: dateTime.TZMinutes = sign * num; break;
				default: return false;
				}
				num = 0; fnum = 0.0f; fmult = 0.1f;
				if (start == len) return true;
				switch (log) {
				case 0:
				case 1:
					if (str.charAt(start++) != '-') return false;
					end = start + 2;
					break;
				case 2:
					if (str.charAt(start++) != 'T') return false;
					end = start + 2;
					break;
				case 3:
				case 7:
					if (str.charAt(start++) != ':') return false;
					end = start + 2;
					break;
				case 4:
					ch = str.charAt(start++);
					if (ch == ':') {
						end = start + 2;
					} else if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						log += 2;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				case 5:
					ch = str.charAt(start++);
					if (ch == '.') {
						end = start;
						while (Character.isDigit(str.charAt(++end))) /* NOP */;
					} else if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						log += 1;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				case 6:
					ch = str.charAt(start++);
					if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				//case 8:
				default: return false;
				}
				++log;
			}
		}
		return false;
	}

	private static void appendChars(StringBuilder buffer, char ch, int count) {
		while (count-- > 0) {
			buffer.append(ch);
		}
	}

	public final String getDateTime(boolean brief) {
		StringBuilder timezone = new StringBuilder(""Z"");
		if (TZMinutes != 0 || TZHour != 0) {
			int tzminnum = TZMinutes;
			int tzhournum = TZHour;
			char sign;
			if (tzhournum == 0) {
				sign = (tzminnum >= 0) ? '+' : '-';
			} else {
				sign = (tzhournum > 0) ? '+' : '-';
				if (tzhournum > 0 && tzminnum < 0) {
					--tzhournum;
					tzminnum = 60 + tzminnum;
				} else if (tzhournum < 0 && tzminnum > 0) {
					++tzhournum;
					tzminnum = 60 - tzminnum;
				}
			}
			String tzmin = String.valueOf(tzminnum < 0 ? -tzminnum : tzminnum);
			String tzhour = String.valueOf(tzhournum < 0 ? -tzhournum : tzhournum);
			timezone.append(sign);
			appendChars(timezone, '0', 2 - tzhour.length());
			timezone.append(tzhour);
			timezone.append(':');
			appendChars(timezone, '0', 2 - tzmin.length());
			timezone.append(tzmin);
		}

		StringBuilder time = new StringBuilder();
		StringBuilder temp = new StringBuilder();
		if (SecondFraction >= 0.01f) {
			int sfrnum = Math.round(100 * SecondFraction);
			String sfr = String.valueOf(sfrnum);
			time.append('.');
			appendChars(time, '0', 2 - sfr.length());
			time.append(sfr);
		}
		if (!brief || time.length() != 0 || Seconds != 0) {
			String sec = String.valueOf(Seconds);
			temp.append(':');
			appendChars(temp, '0', 2 - sec.length());
			temp.append(sec);
			time.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}
		if (!brief || time.length() != 0 || Hour != 0 || Minutes != 0 || timezone.length() > 1) {
			String hour = String.valueOf(Hour);
			String min = String.valueOf(Minutes);
			appendChars(temp, '0', 2 - hour.length());
			temp.append(hour);
			temp.append(':');
			appendChars(temp, '0', 2 - min.length());
			temp.append(min);
			time.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}

		StringBuilder date = new StringBuilder();
		if (!brief || time.length() != 0 || Day != 0) {
			String day = String.valueOf(Day);
			date.append('-');
			appendChars(date, '0', 2 - day.length());
			date.append(day);
		}
		if (!brief || date.length() != 0 || Month != 0) {
			String month = String.valueOf(Month);
			temp.append('-');
			appendChars(temp, '0', 2 - month.length());
			temp.append(month);
			date.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}

		String year = String.valueOf(Year);
		appendChars(temp, '0', 4 - year.length());
		temp.append(year);
		date.insert(0, temp.toString());
		temp.delete(0, temp.length());

		if (!brief || time.length() != 0) {
			date.append('T');
			date.append(time.toString());
			date.append(timezone.toString());
		}
		return date.toString();
	}

	@Override
	public String toString() {
		return getDateTime(false);
	}

	private static final int[] DAYS_IN_MONTHS = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	private int daysInMonth(int month, int year) {
		--month;
		while (month > 11) month -= 12;
		while (month < 0) month += 12;
		if (month == 1 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) {
			return DAYS_IN_MONTHS[1] + 1;
		}
		return DAYS_IN_MONTHS[month];
	}

	public int compareTo(ATOMDateConstruct date) {
		int dateYear = date.Year;
		int dateMonth = date.Month;
		int dateDay = date.Day;
		int dateHour = date.Hour;
		int dateMinutes = date.Minutes;
		if (TZHour != date.TZHour || TZMinutes != date.TZMinutes) {
			dateMinutes += TZMinutes - date.TZMinutes;
			while (dateMinutes < 0) { dateMinutes += 60; --dateHour; }
			while (dateMinutes > 59) { dateMinutes -= 60; ++dateHour; }
			dateHour += TZHour - date.TZHour;
			while (dateHour < 0) { dateHour += 24; --dateDay; }
			while (dateHour > 23) { dateHour -= 24; ++dateDay; }
			while (dateDay < 1) dateDay += daysInMonth(--dateMonth, dateYear);
			while (dateDay > daysInMonth(dateMonth, dateYear)) dateDay -= daysInMonth(dateMonth++, dateYear);
			while (dateMonth < 1) { dateMonth += 12; --dateYear; }
			while (dateMonth > 12) { dateMonth -= 12; ++dateYear; }
		}
		if (Year != dateYear) return Year - dateYear;
		if (Month != dateMonth) return Month - dateMonth;
		if (Day != dateDay) return Day - dateDay;
		if (Hour != dateHour) return Hour - dateHour;
		if (Minutes != dateMinutes) return Minutes - dateMinutes;
		if (Seconds != date.Seconds) return Seconds - date.Seconds;
		return Math.round(100 * SecondFraction) - Math.round(100 * date.SecondFraction);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof ATOMDateConstruct)) {
			return false;
		}
		return compareTo((ATOMDateConstruct) obj) == 0;
	}
};

",True,114,7,31,2,2,6,2,L6
135,org.geometerplus.fbreader.network.atom.ATOMUpdated.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMUpdated extends ATOMDateConstruct {
	public ATOMUpdated(ZLStringMap attributes) {
		super(attributes);
	}

	/*
	public ATOMUpdated(int year) {
		super(year);
	}

	public ATOMUpdated(int year, int month, int day) {
		super(year, month, day);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
	*/
}
",False,112,7,34,2,2,5,2,L6
136,org.geometerplus.fbreader.network.atom.ATOMLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMLink extends ATOMCommonAttributes {
	public static final String HREF = ""href"";
	public static final String REL = ""rel"";
	public static final String TYPE = ""type"";
	public static final String HREFLANG = ""hreflang"";
	public static final String TITLE = ""title"";
	public static final String LENGTH = ""length"";

	protected ATOMLink(ZLStringMap source) {
		super(source);
		readAttribute(HREF, source);
		readAttribute(REL, source);
		readAttribute(TYPE, source);
		readAttribute(HREFLANG, source);
		readAttribute(TITLE, source);
		readAttribute(LENGTH, source);
	}

	public final String getHref() {
		return getAttribute(HREF);
	}

	public final String getRel() {
		return getAttribute(REL);
	}

	public final String getType() {
		return getAttribute(TYPE);
	}

	public final String getHrefLang() {
		return getAttribute(HREFLANG);
	}

	public final String getTitle() {
		return getAttribute(TITLE);
	}

	public final String getLength() {
		return getAttribute(LENGTH);
	}
}
",False,112,7,31,2,2,8,2,L6
137,org.geometerplus.fbreader.network.atom.ATOMXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import java.util.Map;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;

public abstract class ATOMXMLReader<T1 extends ATOMFeedMetadata, T2 extends ATOMEntry> extends ZLXMLReaderAdapter {
	public static String intern(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		return str.intern();
	}

	private final ATOMFeedHandler<T1, T2> myFeedHandler;

	private T1 myFeed;
	private T2 myEntry;
	private ATOMAuthor myAuthor;
	private ATOMId myId;
	private ATOMLink myLink;
	private ATOMCategory myCategory;
	private ATOMUpdated myUpdated;
	private ATOMPublished myPublished;
	private ATOMIcon myIcon;

	private Map<String,String> myNamespaceMap;

	private static final int START = 0;
	protected static final int FEED = 1;
	protected static final int F_ENTRY = 2;
	private static final int F_ID = 3;
	private static final int F_LINK = 4;
	private static final int F_CATEGORY = 5;
	private static final int F_TITLE = 6;
	private static final int F_UPDATED = 7;
	private static final int F_AUTHOR = 8;
	private static final int F_SUBTITLE = 9;
	private static final int F_ICON = 10;
	private static final int FA_NAME = 11;
	private static final int FA_URI = 12;
	private static final int FA_EMAIL = 13;
	private static final int FE_AUTHOR = 14;
	private static final int FE_ID = 15;
	private static final int FE_CATEGORY = 16;
	protected static final int FE_LINK = 17;
	private static final int FE_PUBLISHED = 18;
	private static final int FE_SUMMARY = 19;
	protected static final int FE_CONTENT = 20;
	private static final int FE_TITLE = 21;
	private static final int FE_UPDATED = 22;
	private static final int FEA_NAME = 23;
	private static final int FEA_URI = 24;
	private static final int FEA_EMAIL = 25;

	protected static final int ATOM_STATE_FIRST_UNUSED = 26;

	protected static final String TAG_FEED = ""feed"";
	protected static final String TAG_ENTRY = ""entry"";
	protected static final String TAG_AUTHOR = ""author"";
	protected static final String TAG_NAME = ""name"";
	protected static final String TAG_URI = ""uri"";
	protected static final String TAG_EMAIL = ""email"";
	protected static final String TAG_ID = ""id"";
	protected static final String TAG_CATEGORY = ""category"";
	protected static final String TAG_LINK = ""link"";
	protected static final String TAG_PUBLISHED = ""published"";
	protected static final String TAG_SUMMARY = ""summary"";
	protected static final String TAG_CONTENT = ""content"";
	protected static final String TAG_TITLE = ""title"";
	protected static final String TAG_UPDATED = ""updated"";
	protected static final String TAG_SUBTITLE = ""subtitle"";
	protected static final String TAG_ICON = ""icon"";

	protected int myState;
	private final StringBuilder myBuffer = new StringBuilder();
	protected final FormattedBuffer myFormattedBuffer = new FormattedBuffer();
	protected boolean myFeedMetadataProcessed;

	public ATOMXMLReader(ATOMFeedHandler<T1, T2> handler, boolean readEntryNotFeed) {
		myFeedHandler = handler;
		myState = readEntryNotFeed ? FEED : START;
	}

	protected final ATOMFeedHandler<T1, T2> getATOMFeedHandler() {
		return myFeedHandler;
	}

	protected final T1 getATOMFeed() {
		return myFeed;
	}

	protected final T2 getATOMEntry() {
		return myEntry;
	}

	protected final ATOMLink getATOMLink() {
		return myLink;
	}

	@Override
	public final boolean processNamespaces() {
		return true;
	}

	@Override
	public final void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myNamespaceMap = namespaceMap;
	}

	protected final String getNamespace(String prefix) {
		if (myNamespaceMap == null) {
			return null;
		}
		final String ns = myNamespaceMap.get(prefix);
		return ns != null ? ns.intern() : null;
	}

	@Override
	public final boolean startElementHandler(String tag, ZLStringMap attributes) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = """";
			tag = tag.intern();
		}
		return startElementHandler(getNamespace(tagPrefix), tag, attributes, extractBufferContent());
	}

	@Override
	public final boolean endElementHandler(String tag) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = """";
			tag = tag.intern();
		}
		return endElementHandler(getNamespace(tagPrefix), tag, extractBufferContent());
	}

	private final String extractBufferContent() {
		final char[] bufferContentArray = myBuffer.toString().trim().toCharArray();
		myBuffer.delete(0, myBuffer.length());
		if (bufferContentArray.length == 0) {
			return null;
		}
		return new String(bufferContentArray);
	}

	protected abstract T1 createFeed(ZLStringMap attributes);
	protected abstract T2 createEntry(ZLStringMap attributes);

	protected ATOMLink createLink(ZLStringMap attributes) {
		return new ATOMLink(attributes);
	}


	public boolean startElementHandler(
		final String ns, final String tag,
		final ZLStringMap attributes, final String bufferContent
	) {
		boolean interruptReading = false;
		switch (myState) {
			case START:
				if (ns == XMLNamespaces.Atom && tag == TAG_FEED) {
					myFeedHandler.processFeedStart();
					myFeed = createFeed(attributes);
					myState = FEED;
					myFeedMetadataProcessed = false;
				}
				break;
			case FEED:
				if (ns == XMLNamespaces.Atom) {
					if (tag == TAG_AUTHOR) {
						myAuthor = new ATOMAuthor(attributes);
						myState = F_AUTHOR;
					} else if (tag == TAG_ID) {
						myId = new ATOMId(attributes);
						myState = F_ID;
					} else if (tag == TAG_ICON) {
						myIcon = new ATOMIcon(attributes);
						myState = F_ICON;
					} else if (tag == TAG_LINK) {
						myLink = createLink(attributes);			// TODO
						myState = F_LINK;
					} else if (tag == TAG_CATEGORY) {
						myCategory = new ATOMCategory(attributes);
						myState = F_CATEGORY;
					} else if (tag == TAG_TITLE) {
						//myTitle = new ATOMTitle(attributes); // TODO:implement ATOMTextConstruct & ATOMTitle
						setFormattingType(attributes.getValue(""type""));
						myState = F_TITLE;
					} else if (tag == TAG_SUBTITLE) {
						//mySubtitle = new ATOMTitle(attributes); // TODO:implement ATOMTextConstruct & ATOMSubtitle
						setFormattingType(attributes.getValue(""type""));
						myState = F_SUBTITLE;
					} else if (tag == TAG_UPDATED) {
						myUpdated = new ATOMUpdated(attributes);
						myState = F_UPDATED;
					} else if (tag == TAG_ENTRY) {
						myEntry = createEntry(attributes);
						myState = F_ENTRY;
						// Process feed metadata just before first feed entry
						if (myFeed != null && !myFeedMetadataProcessed) {
							interruptReading = myFeedHandler.processFeedMetadata(myFeed, true);
							myFeedMetadataProcessed = true;
						}
					}
				}
				break;
			case F_ENTRY:
				if (ns == XMLNamespaces.Atom) {
					if (tag == TAG_AUTHOR) {
						myAuthor = new ATOMAuthor(attributes);
						myState = FE_AUTHOR;
					} else if (tag == TAG_ID) {
						myId = new ATOMId(attributes);
						myState = FE_ID;
					} else if (tag == TAG_CATEGORY) {
						myCategory = new ATOMCategory(attributes);
						myState = FE_CATEGORY;
					} else if (tag == TAG_LINK) {
						myLink = createLink(attributes);				// TODO
						myState = FE_LINK;
					} else if (tag == TAG_PUBLISHED) {
						myPublished = new ATOMPublished(attributes);
						myState = FE_PUBLISHED;
					} else if (tag == TAG_SUMMARY) {
						//mySummary = new ATOMSummary(attributes); // TODO:implement ATOMTextConstruct & ATOMSummary
						setFormattingType(attributes.getValue(""type""));
						myState = FE_SUMMARY;
					} else if (tag == TAG_CONTENT) {
						//myConent = new ATOMContent(attributes); // TODO:implement ATOMContent
						setFormattingType(attributes.getValue(""type""));
						myState = FE_CONTENT;
					} else if (tag == TAG_TITLE) {
						//myTitle = new ATOMTitle(attributes); // TODO:implement ATOMTextConstruct & ATOMTitle
						setFormattingType(attributes.getValue(""type""));
						myState = FE_TITLE;
					} else if (tag == TAG_UPDATED) {
						myUpdated = new ATOMUpdated(attributes);
						myState = FE_UPDATED;
					}
				}
				break;
			case F_AUTHOR:
				if (ns == XMLNamespaces.Atom) {
					if (tag == TAG_NAME) {
						myState = FA_NAME;
					} else if (tag == TAG_URI) {
						myState = FA_URI;
					} else if (tag == TAG_EMAIL) {
						myState = FA_EMAIL;
					}
				}
				break;
			case FE_AUTHOR:
				if (ns == XMLNamespaces.Atom) {
					if (tag == TAG_NAME) {
						myState = FEA_NAME;
					} else if (tag == TAG_URI) {
						myState = FEA_URI;
					} else if (tag == TAG_EMAIL) {
						myState = FEA_EMAIL;
					}
				}
				break;
			case FE_CONTENT:
			case FE_SUMMARY:
			case FE_TITLE:
			case F_TITLE:
			case F_SUBTITLE:
				myFormattedBuffer.appendText(bufferContent);
				myFormattedBuffer.appendStartTag(tag, attributes);
				break;
			default:
				break;
		}

		return interruptReading;
	}

	public boolean endElementHandler(String ns, String tag, String bufferContent) {
		boolean interruptReading = false;
		switch (myState) {
			case START:
				break;
			case FEED:
				if (ns == XMLNamespaces.Atom && tag == TAG_FEED) {
					if (myFeed != null) {
						interruptReading = myFeedHandler.processFeedMetadata(myFeed, false);
					}
					myFeed = null;
					myFeedHandler.processFeedEnd();
					myState = START;
				}
				break;
			case F_ENTRY:
				if (ns == XMLNamespaces.Atom && tag == TAG_ENTRY) {
					if (myEntry != null) {
						interruptReading = myFeedHandler.processFeedEntry(myEntry);
					}
					myEntry = null;
					myState = FEED;
				}
				break;
			case F_ID:
				if (ns == XMLNamespaces.Atom && tag == TAG_ID) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null && myFeed != null) {
						myId.Uri = bufferContent;
						myFeed.Id = myId;
					}
					myId = null;
					myState = FEED;
				}
				break;
			case F_ICON:
				if (ns == XMLNamespaces.Atom && tag == TAG_ICON) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null && myFeed != null) {
						myIcon.Uri = bufferContent;
						myFeed.Icon = myIcon;
					}
					myIcon = null;
					myState = FEED;
				}
				break;
			case F_LINK:
				if (ns == XMLNamespaces.Atom && tag == TAG_LINK) {
					if (myFeed != null) {
						myFeed.Links.add(myLink);
					}
					myLink = null;
					myState = FEED;
				}
				break;
			case F_CATEGORY:
				if (ns == XMLNamespaces.Atom && tag == TAG_CATEGORY) {
					if (myFeed != null) {
						myFeed.Categories.add(myCategory);
					}
					myCategory = null;
					myState = FEED;
				}
				break;
			case F_TITLE:
				myFormattedBuffer.appendText(bufferContent);
				if (ns == XMLNamespaces.Atom && tag == TAG_TITLE) {
					// TODO:implement ATOMTextConstruct & ATOMTitle
					final CharSequence title = myFormattedBuffer.getText();
					if (myFeed != null) {
						myFeed.Title = title;
					}
					myState = FEED;
				} else {
					myFormattedBuffer.appendEndTag(tag);
				}
				break;
			case F_SUBTITLE:
				myFormattedBuffer.appendText(bufferContent);
				if (ns == XMLNamespaces.Atom && tag == TAG_SUBTITLE) {
					// TODO:implement ATOMTextConstruct & ATOMSubtitle
					final CharSequence subtitle = myFormattedBuffer.getText();
					if (myFeed != null) {
						myFeed.Subtitle = subtitle;
					}
					myState = FEED;
				} else {
					myFormattedBuffer.appendEndTag(tag);
				}
				break;
			case F_UPDATED:
				if (ns == XMLNamespaces.Atom && tag == TAG_UPDATED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myUpdated) && myFeed != null) {
						myFeed.Updated = myUpdated;
					}
					myUpdated = null;
					myState = FEED;
				}
				break;
			case F_AUTHOR:
				if (ns == XMLNamespaces.Atom && tag == TAG_AUTHOR) {
					if (myFeed != null && myAuthor.Name != null) {
						myFeed.Authors.add(myAuthor);
					}
					myAuthor = null;
					myState = FEED;
				}
				break;
			case FA_NAME:
				if (ns == XMLNamespaces.Atom && tag == TAG_NAME) {
					myAuthor.Name = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_NAME:
				if (ns == XMLNamespaces.Atom && tag == TAG_NAME) {
					myAuthor.Name = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FA_URI:
				if (ns == XMLNamespaces.Atom && tag == TAG_URI) {
					myAuthor.Uri = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_URI:
				if (ns == XMLNamespaces.Atom && tag == TAG_URI) {
					myAuthor.Uri = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FA_EMAIL:
				if (ns == XMLNamespaces.Atom && tag == TAG_EMAIL) {
					myAuthor.Email = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_EMAIL:
				if (ns == XMLNamespaces.Atom && tag == TAG_EMAIL) {
					myAuthor.Email = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FE_AUTHOR:
				if (ns == XMLNamespaces.Atom && tag == TAG_AUTHOR) {
					if (myAuthor.Name != null) {
						myEntry.Authors.add(myAuthor);
					}
					myAuthor = null;
					myState = F_ENTRY;
				}
				break;
			case FE_ID:
				if (ns == XMLNamespaces.Atom && tag == TAG_ID) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null) {
						myId.Uri = bufferContent;
						myEntry.Id = myId;
					}
					myId = null;
					myState = F_ENTRY;
				}
				break;
			case FE_CATEGORY:
				if (ns == XMLNamespaces.Atom && tag == TAG_CATEGORY) {
					myEntry.Categories.add(myCategory);
					myCategory = null;
					myState = F_ENTRY;
				}
				break;
			case FE_LINK:
				if (ns == XMLNamespaces.Atom && tag == TAG_LINK) {
					myEntry.Links.add(myLink);
					myLink = null;
					myState = F_ENTRY;
				}
				break;
			case FE_PUBLISHED:
				if (ns == XMLNamespaces.Atom && tag == TAG_PUBLISHED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myPublished)) {
						myEntry.Published = myPublished;
					}
					myPublished = null;
					myState = F_ENTRY;
				}
				break;
			case FE_SUMMARY:
				myFormattedBuffer.appendText(bufferContent);
				if (ns == XMLNamespaces.Atom && tag == TAG_SUMMARY) {
					// TODO:implement ATOMTextConstruct & ATOMSummary
					myEntry.Summary = myFormattedBuffer.getText();
					myState = F_ENTRY;
				} else {
					myFormattedBuffer.appendEndTag(tag);
				}
				break;
			case FE_CONTENT:
				myFormattedBuffer.appendText(bufferContent);
				if (ns == XMLNamespaces.Atom && tag == TAG_CONTENT) {
					// TODO:implement ATOMContent
					myEntry.Content = myFormattedBuffer.getText();
					myState = F_ENTRY;
				} else {
					myFormattedBuffer.appendEndTag(tag);
				}
				break;
			case FE_TITLE:
				myFormattedBuffer.appendText(bufferContent);
				if (ns == XMLNamespaces.Atom && tag == TAG_TITLE) {
					// TODO:implement ATOMTextConstruct & ATOMTitle
					myEntry.Title = myFormattedBuffer.getText();
					myState = F_ENTRY;
				} else {
					myFormattedBuffer.appendEndTag(tag);
				}
				break;
			case FE_UPDATED:
				if (ns == XMLNamespaces.Atom && tag == TAG_UPDATED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myUpdated)) {
						myEntry.Updated = myUpdated;
					}
					myUpdated = null;
					myState = F_ENTRY;
				}
				break;
		}

		return interruptReading;
	}

	@Override
	public final void characterDataHandler(char[] data, int start, int length) {
		myBuffer.append(data, start, length);
	}

	public void setFormattingType(String type) {
		if (ATOMConstants.TYPE_HTML.equals(type) || MimeType.TEXT_HTML.Name.equals(type)) {
			myFormattedBuffer.reset(FormattedBuffer.Type.Html);
		} else if (ATOMConstants.TYPE_XHTML.equals(type) || MimeType.TEXT_XHTML.Name.equals(type)) {
			myFormattedBuffer.reset(FormattedBuffer.Type.XHtml);
		} else {
			myFormattedBuffer.reset(FormattedBuffer.Type.Text);
		}
	}
}
",True,140,0,0,9,28,2,18,L6
138,org.geometerplus.fbreader.network.atom.ATOMGenerator.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMGenerator extends ATOMCommonAttributes {
	public static final String URI = ""uri"";
	public static final String VERSION = ""version"";

	public String Text;

	protected ATOMGenerator(ZLStringMap source) {
		super(source);
		readAttribute(URI, source);
		readAttribute(VERSION, source);
	}

	public final String getUri() {
		return getAttribute(URI);
	}

	public final String getVersion() {
		return getAttribute(VERSION);
	}
}
",False,4,0,0,2,2,0,2,L7
139,org.geometerplus.fbreader.network.atom.ATOMFeedHandler.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public interface ATOMFeedHandler<T1 extends ATOMFeedMetadata,T2 extends ATOMEntry> {
	void processFeedStart();

	// returns true iff reading process should be interrupted
	boolean processFeedMetadata(T1 feed, boolean beforeEntries);

	// returns true iff reading process should be interrupted
	boolean processFeedEntry(T2 entry);

	void processFeedEnd();
}
",False,118,7,31,3,11,6,2,L6
140,org.geometerplus.fbreader.network.atom.ATOMIcon.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMIcon extends ATOMCommonAttributes {
	public String Uri;

	protected ATOMIcon(ZLStringMap attributes) {
		super(attributes);
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,109,7,50,2,2,3,2,L6
141,org.geometerplus.fbreader.network.atom.ATOMId.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMId extends ATOMCommonAttributes {
	public String Uri;

	public ATOMId() {
		this(new ZLStringMap());
	}

	protected ATOMId(ZLStringMap attributes) {
		super(attributes);
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof ATOMId)) {
			return false;
		}
		ATOMId id = (ATOMId) o;
		return Uri.equals(id.Uri);
	}

	@Override
	public int hashCode() {
		return Uri.hashCode();
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,111,7,31,2,2,6,2,L6
142,org.geometerplus.fbreader.network.atom.ATOMEntry.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMEntry extends ATOMCommonAttributes {
	public ATOMId Id;

	public LinkedList<ATOMAuthor> Authors = new LinkedList<ATOMAuthor>();
	public LinkedList<ATOMCategory> Categories = new LinkedList<ATOMCategory>();
	public LinkedList<ATOMContributor> Contributors = new LinkedList<ATOMContributor>();
	public LinkedList<ATOMLink> Links = new LinkedList<ATOMLink>();
	public ATOMPublished Published;
	//public String Rights;  // TODO: implement ATOMTextConstruct
	//public final ATOMSource Source; // TODO: implement ATOMSource
	public CharSequence Summary; // TODO: implement ATOMTextConstruct
	public CharSequence Content; // TODO: implement ATOMContent
	public CharSequence Title;   // TODO: implement ATOMTextConstruct
	public ATOMUpdated Updated;

	protected ATOMEntry(ZLStringMap source) {
		super(source);
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["")
			.append(super.toString())
			.append("",\nId="").append(Id)
			.append("",\nAuthors:[\n"");

		boolean first = true;
		for (ATOMAuthor author: Authors) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(author.toString());
		}
		buf.append(""],\nCategories:[\n"");
		first = true;
		for (ATOMCategory category: Categories) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(category.toString());
		}
		buf.append(""],\nLinks:[\n"");
		first = true;
		for (ATOMLink link: Links) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(link.toString());
		}
		return buf
			.append(""]"")
			.append("",\nPublished="").append(Published)
			//.append("",\nRights="").append(Rights)
			.append("",\nSummary="").append(Summary)
			.append("",\nTitle="").append(Title)
			.append("",\nUpdated="").append(Updated)
			.append(""]"")
			.toString();
	}
}
",False,117,7,31,2,10,6,10,L6
143,org.geometerplus.fbreader.network.atom.ATOMPublished.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMPublished extends ATOMDateConstruct {
	public ATOMPublished(ZLStringMap attributes) {
		super(attributes);
	}

	/*
	public ATOMPublished(int year) {
		super(year);
	}

	public ATOMPublished(int year, int month, int day) {
		super(year, month, day);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
	*/
}
",False,110,8,31,2,2,2,2,L6
144,org.geometerplus.fbreader.network.atom.ATOMCommonAttributes.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

abstract class ATOMCommonAttributes {
	public static final String XML_BASE = ""xml:base"";
	public static final String XML_LANG = ""xml:lang"";

	private ZLStringMap myAttributes;

	protected ATOMCommonAttributes(ZLStringMap source) {
		readAttribute(XML_BASE, source);
		readAttribute(XML_LANG, source);
	}

	protected final void readAttribute(String name, ZLStringMap source) {
		String value = source.getValue(name);
		if (value != null) {
			value = value.trim().intern();
			if (value.length() > 0) {
				if (myAttributes == null) {
					myAttributes = new ZLStringMap();
				}
				myAttributes.put(name, value);
			}
		}
	}

	public final String getAttribute(String name) {
		if (myAttributes == null) {
			return null;
		}
		return myAttributes.getValue(name);
	}

	public final String getLang() {
		return getAttribute(XML_LANG);
	}

	public final String getBase() {
		return getAttribute(XML_BASE);
	}

	// FIXME: HACK: addAttribute is used ONLY to add OPDSPrice to the ATOMLink... Must be killed + SEE NetworkOPDSFeedReader
	// name and value MUST BE not null AND MUST BE INTERNED String objects
	public final void addAttribute(String name, String value) {
		if (value != null) {
			value = value.trim().intern();
			if (value.length() > 0) {
				if (myAttributes == null) {
					myAttributes = new ZLStringMap();
				}
				myAttributes.put(name, value);
			}
		}
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""[Attributes:\n"");
		if (myAttributes != null) {
			for (int i = 0; i < myAttributes.getSize(); ++i) {
				String key = myAttributes.getKey(i);
				String value = myAttributes.getValue(key);
				if (i != 0) {
					buf.append("",\n"");
				}
				buf.append(key).append(""="").append(value);
			}
		}
		buf.append(""]"");
		return buf.toString();
	}
}
",False,124,7,34,2,1,12,1,L1
145,org.geometerplus.fbreader.network.atom.ATOMConstants.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public interface ATOMConstants {
	String TYPE_TEXT = ""text"";
	String TYPE_HTML = ""html"";
	String TYPE_XHTML = ""xhtml"";
	String TYPE_DEFAULT = TYPE_TEXT;

	String REL_ALTERNATE = ""alternate"";
	String REL_RELATED = ""related"";
	String REL_SELF = ""self"";
	String REL_ENCLOSURE = ""enclosure"";
	String REL_VIA = ""via"";
}
",False,104,8,30,0,0,4,0,L6
146,org.geometerplus.fbreader.network.atom.ATOMFeedMetadata.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMFeedMetadata extends ATOMCommonAttributes {
	public ATOMId Id;

	public LinkedList<ATOMAuthor> Authors = new LinkedList<ATOMAuthor>();
	public LinkedList<ATOMCategory> Categories = new LinkedList<ATOMCategory>();
	//public LinkedList<ATOMContributor> Contributors = new LinkedList<ATOMContributor>();
	//public ATOMGenerator Generator;
	public ATOMIcon Icon;
	public LinkedList<ATOMLink> Links = new LinkedList<ATOMLink>();
	//public ATOMLogo Logo;
	//public String Rights;   // TODO: implement ATOMTextConstruct
	public CharSequence Subtitle; // TODO: implement ATOMTextConstruct
	public CharSequence Title;    // TODO: implement ATOMTextConstruct
	public ATOMUpdated Updated;

	protected ATOMFeedMetadata(ZLStringMap source) {
		super(source);
	}
}
",False,116,7,31,2,8,6,8,L6
147,org.geometerplus.fbreader.network.atom.FormattedBuffer.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.HtmlUtil;

public class FormattedBuffer {
	public static enum Type {
		Text,
		Html,
		XHtml
	};

	private Type myType;
	private StringBuilder myBuffer = new StringBuilder();

	public FormattedBuffer(Type type) {
		myType = type;
	}

	public FormattedBuffer() {
		this(Type.Text);
	}

	public void appendText(CharSequence text) {
		if (text != null) {
			myBuffer.append(text);
		}
	}

	public void appendText(char[] data, int start, int length) {
		myBuffer.append(data, start, length);
	}

	public void appendStartTag(String tag, ZLStringMap attributes) {
		myBuffer.append(""<"").append(tag);
		for (int i = 0; i < attributes.getSize(); ++i) {
			final String key = attributes.getKey(i);
			final String value = attributes.getValue(key);
			myBuffer.append("" "").append(key).append(""=\"""");
			if (value != null) {
				myBuffer.append(value);
			}
			myBuffer.append(""\"""");
		}
		myBuffer.append("">"");
	}

	public void appendEndTag(String tag) {
		myBuffer.append(""</"").append(tag).append("">"");
	}

	public void reset(Type type) {
		myType = type;
		reset();
	}

	public void reset() {
		myBuffer.delete(0, myBuffer.length());
	}

	public CharSequence getText() {
		final String text = myBuffer.toString();

		switch (myType) {
			case Html:
			case XHtml:
				return HtmlUtil.getHtmlText(text);
			default:
				return text;
		}
	}

	@Override
	public String toString() {
		return myBuffer.toString();
	}
}
",False,140,0,0,8,40,3,2,L6
148,org.geometerplus.fbreader.network.atom.ATOMCategory.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMCategory extends ATOMCommonAttributes {
	public static final String TERM = ""term"";
	public static final String SCHEME = ""scheme"";
	public static final String LABEL = ""label"";

	protected ATOMCategory(ZLStringMap source) {
		super(source);
		readAttribute(TERM, source);
		readAttribute(SCHEME, source);
		readAttribute(LABEL, source);
	}

	public final String getTerm() {
		return getAttribute(TERM);
	}

	public final String getScheme() {
		return getAttribute(SCHEME);
	}

	public final String getLabel() {
		return getAttribute(LABEL);
	}
}
",False,111,8,30,2,2,4,2,L6
149,org.geometerplus.fbreader.network.atom.ATOMAuthor.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMAuthor extends ATOMPersonConstruct {
	protected ATOMAuthor(ZLStringMap attributes) {
		super(attributes);
	}
}
",False,112,8,30,2,2,4,2,L6
150,org.geometerplus.fbreader.network.atom.ATOMContributor.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMContributor extends ATOMPersonConstruct {
	protected ATOMContributor(ZLStringMap attributes) {
		super(attributes);
	}
}
",False,110,8,31,2,2,1,2,L6
151,org.geometerplus.fbreader.network.atom.ATOMLogo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public class ATOMLogo extends ATOMCommonAttributes {
	public String Uri;

	protected ATOMLogo(ZLStringMap attributes) {
		super(attributes);
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,4,0,0,2,2,0,2,L7
152,org.geometerplus.fbreader.network.atom.ATOMPersonConstruct.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

abstract class ATOMPersonConstruct extends ATOMCommonAttributes {
	public String Name;
	public String Uri;
	public String Email;

	protected ATOMPersonConstruct(ZLStringMap attributes) {
		super(attributes);
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nName="").append(Name);
		buf.append("",\nUri="").append(Uri);
		buf.append("",\nEmail="").append(Email);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,113,8,30,2,2,5,2,L6
153,org.geometerplus.fbreader.network.opds.OPDSPredefinedNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.IPredefinedNetworkLink;
import org.geometerplus.fbreader.network.urlInfo.*;

public class OPDSPredefinedNetworkLink extends OPDSNetworkLink implements IPredefinedNetworkLink {
	private final String myPredefinedId;

	public OPDSPredefinedNetworkLink(int id, String predifinedId, String siteName, String title, String summary, String language, UrlInfoCollection<UrlInfoWithDate> infos) {
		super(id, siteName, title, summary, language, infos);
		myPredefinedId = predifinedId;
	}

	public String getPredefinedId() {
		return myPredefinedId;
	}
}
",False,140,0,0,10,38,2,4,L6
154,org.geometerplus.fbreader.network.opds.RelationAlias.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

class RelationAlias implements Comparable<RelationAlias> {
	final String Alias;
	final String Type;

	// `alias` and `type` parameters must be either null or interned String.
	RelationAlias(String alias, String type) {
		Alias = alias;
		Type = type;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof RelationAlias)) {
			return false;
		}
		RelationAlias r = (RelationAlias) o;
		return Alias == r.Alias && Type == r.Type;
	}

	@Override
	public int hashCode() {
		return (Alias == null ? 0 : Alias.hashCode()) +
			(Type == null ? 0 : Type.hashCode());
	}

	public int compareTo(RelationAlias r) {
		if (Alias != r.Alias) {
			if (Alias == null) {
				return -1;
			} else if (r.Alias == null) {
				return 1;
			}
			return Alias.compareTo(r.Alias);
		}
		if (Type != r.Type) {
			if (Type == null) {
				return -1;
			} else if (r.Type == null) {
				return 1;
			}
			return Type.compareTo(r.Type);
		}
		return 0;
	}

	@Override
	public String toString() {
		return ""Alias("" + Alias + ""; "" + Type + "")"";
	}
}

",True,103,7,30,0,0,2,0,L6
155,org.geometerplus.fbreader.network.opds.OpenSearchDescription.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

class OpenSearchDescription {
	public static OpenSearchDescription createDefault(String template) {
		return new OpenSearchDescription(template, -1, -1);
	}

	public final String Template;
	public final int IndexOffset;
	public final int PageOffset;

	public final int ItemsPerPage = 20;

	OpenSearchDescription(String template, int indexOffset, int pageOffset) {
		Template = template;
		IndexOffset = indexOffset;
		PageOffset = pageOffset;
	}

	public boolean isValid() {
		return makeQuery("""") != null;
	}

	// searchTerms -- an HTML-encoded string
	public String makeQuery(String searchTerms) {
		final StringBuffer query = new StringBuffer();
		final Matcher m = Pattern.compile(""\\{([^}]*)\\}"").matcher(Template);
		while (m.find()) {
			String name = m.group(1);
			if (name == null || name.length() == 0 || name.contains("":"")) {
				return null;
			}
			final boolean optional = name.endsWith(""?"");
			if (optional) {
				name = name.substring(0, name.length() - 1);
			}
			name = name.intern();
			if (name == ""searchTerms"") {
				m.appendReplacement(query, searchTerms);
			} else if (name == ""count"") {
				m.appendReplacement(query, String.valueOf(ItemsPerPage));
			} else if (optional) {
				m.appendReplacement(query, """");
			} else if (name == ""startIndex"") {
				if (IndexOffset > 0) {
					m.appendReplacement(query, String.valueOf(IndexOffset));
				} else {
					return null;
				}
			} else if (name == ""startPage"") {
				if (PageOffset > 0) {
					m.appendReplacement(query, String.valueOf(PageOffset));
				} else {
					return null;
				}
			} else if (name == ""language"") {
				m.appendReplacement(query, ""*"");
			} else if (name == ""inputEncoding"" || name == ""outputEncoding"") {
				m.appendReplacement(query, ""UTF-8"");
			} else {
				return null;
			}
		}
		m.appendTail(query);
		return query.toString();
	}
}
",True,104,11,32,0,0,4,0,L6
156,org.geometerplus.fbreader.network.opds.OPDSCatalogItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.urlInfo.*;

public class OPDSCatalogItem extends NetworkURLCatalogItem {
	static class State extends NetworkOperationData {
		public String LastLoadedId;
		public final HashSet<String> LoadedIds = new HashSet<String>();

		public State(OPDSNetworkLink link, OnNewItemListener listener) {
			super(link, listener);
		}
	}
	private State myLoadingState;
	private final Map<String,String> myExtraData;

	OPDSCatalogItem(OPDSNetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls, Map<String,String> extraData) {
		super(link, title, summary, urls);
		myExtraData = extraData;
	}

	protected OPDSCatalogItem(OPDSNetworkLink link, CharSequence title, CharSequence summary, UrlInfoCollection<?> urls, Accessibility accessibility, int flags) {
		super(link, title, summary, urls, accessibility, flags);
		myExtraData = null;
	}

	private static UrlInfoCollection<UrlInfo> createSimpleCollection(String url) {
		final UrlInfoCollection<UrlInfo> collection = new UrlInfoCollection<UrlInfo>();
		collection.addInfo(new UrlInfo(UrlInfo.Type.Catalog, url));
		return collection;
	}

	OPDSCatalogItem(OPDSNetworkLink link, RelatedUrlInfo info) {
		super(link, info.Title, null, createSimpleCollection(info.Url));
		myExtraData = null;
	}

	private void doLoadChildren(ZLNetworkRequest networkRequest) throws ZLNetworkException {
		try {
			super.doLoadChildren(myLoadingState, networkRequest);
		} catch (ZLNetworkException e) {
			myLoadingState = null;
			throw e;
		}
	}

	@Override
	public final Map<String,String> extraData() {
		return myExtraData;
	}

	protected String getCatalogUrl() {
		return getUrl(UrlInfo.Type.Catalog);
	}

	@Override
	public final void loadChildren(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		OPDSNetworkLink opdsLink = (OPDSNetworkLink) Link;

		myLoadingState = opdsLink.createOperationData(listener);

		ZLNetworkRequest networkRequest =
			opdsLink.createNetworkData(this, getCatalogUrl(), myLoadingState);

		doLoadChildren(networkRequest);
	}

	@Override
	public final boolean supportsResumeLoading() {
		return true;
	}

	@Override
	public final void resumeLoading(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		if (myLoadingState != null) {
			myLoadingState.Listener = listener;
			ZLNetworkRequest networkRequest = myLoadingState.resume();
			doLoadChildren(networkRequest);
		}
	}
}
",False,195,8,26,10,34,5,10,L6
157,org.geometerplus.fbreader.network.opds.OPDSNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;
import java.net.URLEncoder;
import java.io.InputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;
import org.geometerplus.fbreader.network.urlInfo.*;

public abstract class OPDSNetworkLink extends AbstractNetworkLink {
	private TreeMap<RelationAlias,String> myRelationAliases;

	private final LinkedList<URLRewritingRule> myUrlRewritingRules = new LinkedList<URLRewritingRule>();
	private final Map<String,String> myExtraData = new HashMap<String,String>();
	private NetworkAuthenticationManager myAuthenticationManager;

	OPDSNetworkLink(int id, String siteName, String title, String summary, String language,
			UrlInfoCollection<UrlInfoWithDate> infos) {
		super(id, siteName, title, summary, language, infos);
	}

	final void setRelationAliases(Map<RelationAlias, String> relationAliases) {
		if (relationAliases != null && relationAliases.size() > 0) {
			myRelationAliases = new TreeMap<RelationAlias, String>(relationAliases);
		} else {
			myRelationAliases = null;
		}
	}

	final void setUrlRewritingRules(List<URLRewritingRule> rules) {
		myUrlRewritingRules.clear();
		myUrlRewritingRules.addAll(rules);
	}

	final void setExtraData(Map<String,String> extraData) {
		myExtraData.clear();
		myExtraData.putAll(extraData);
	}

	final void setAuthenticationManager(NetworkAuthenticationManager mgr) {
		myAuthenticationManager = mgr;
	}

	ZLNetworkRequest createNetworkData(final OPDSCatalogItem catalog, String url, final OPDSCatalogItem.State result) {
		if (url == null) {
			return null;
		}
		url = rewriteUrl(url, false);
		return new ZLNetworkRequest(url) {
			@Override
			public void handleStream(InputStream inputStream, int length) throws IOException, ZLNetworkException {
				if (result.Listener.confirmInterrupt()) {
					return;
				}

				new OPDSXMLReader(
					new OPDSFeedHandler(catalog, getURL(), result), false
				).read(inputStream);

				if (result.Listener.confirmInterrupt()) {
					if (result.LastLoadedId != null) {
						// reset state to load current page from the beginning 
						result.LastLoadedId = null;
					} else {
						result.Listener.commitItems(OPDSNetworkLink.this);
					}
				} else {
					result.Listener.commitItems(OPDSNetworkLink.this);
				}
			}
		};
	}

	@Override
	public OPDSCatalogItem.State createOperationData(NetworkOperationData.OnNewItemListener listener) {
		return new OPDSCatalogItem.State(this, listener);
	}

	public ZLNetworkRequest simpleSearchRequest(String pattern, NetworkOperationData data) {
		final String url = getUrl(UrlInfo.Type.Search);
		if (url == null) {
			return null;
		}
		try {
			pattern = URLEncoder.encode(pattern, ""utf-8"");
		} catch (UnsupportedEncodingException e) {
		}
		return createNetworkData(null, url.replace(""%s"", pattern), (OPDSCatalogItem.State)data);
	}

	public ZLNetworkRequest resume(NetworkOperationData data) {
		return createNetworkData(null, data.ResumeURI, (OPDSCatalogItem.State) data);
	}

	public NetworkCatalogItem libraryItem() {
		final UrlInfoCollection<UrlInfo> urlMap = new UrlInfoCollection<UrlInfo>();
		urlMap.addInfo(getUrlInfo(UrlInfo.Type.Catalog));
		urlMap.addInfo(getUrlInfo(UrlInfo.Type.Image));
		urlMap.addInfo(getUrlInfo(UrlInfo.Type.Thumbnail));
		return new OPDSCatalogItem(this, getTitle(), getSummary(), urlMap, myExtraData);
	}

	public NetworkAuthenticationManager authenticationManager() {
		return myAuthenticationManager;
	}

	public String rewriteUrl(String url, boolean isUrlExternal) {
		final int apply = isUrlExternal
			? URLRewritingRule.APPLY_EXTERNAL : URLRewritingRule.APPLY_INTERNAL;
		for (URLRewritingRule rule: myUrlRewritingRules) {
			if ((rule.whereToApply() & apply) != 0) {
				url = rule.apply(url);
			}
		}
		return url;
	}

	// rel and type must be either null or interned String objects.
	String relation(String rel, MimeType type) {
		if (myRelationAliases == null) {
			return rel;
		}
		RelationAlias alias = new RelationAlias(rel, type.Name);
		String mapped = myRelationAliases.get(alias);
		if (mapped != null) {
			return mapped;
		}
		if (type != null) {
			alias = new RelationAlias(rel, null);
			mapped = myRelationAliases.get(alias);
			if (mapped != null) {
				return mapped;
			}
		}
		return rel;
	}

	@Override
	public String toString() {
		return ""OPDSNetworkLink: {super="" + super.toString()
			+ ""; authManager="" + (myAuthenticationManager != null ? myAuthenticationManager.getClass().getName() : null)
			+ ""; relationAliases="" + myRelationAliases
			+ ""; rewritingRules="" + myUrlRewritingRules
			+ ""}"";
	}
}
",True,195,8,26,9,40,12,16,L6
158,org.geometerplus.fbreader.network.opds.URLRewritingRule.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.HashMap;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class URLRewritingRule {
	// rule types:
	public static final int ADD_URL_PARAMETER = 0;
	public static final int REWRITE = 1;
	public static final int UNKNOWN = 2;

	// apply values:
	public static final int APPLY_EXTERNAL = 1;
	public static final int APPLY_INTERNAL = 2;
	public static final int APPLY_ALWAYS = APPLY_EXTERNAL | APPLY_INTERNAL;

	private int myType = UNKNOWN;
	private int myApply = APPLY_ALWAYS;

	private final HashMap<String,String> myParameters = new HashMap<String,String>();

	public URLRewritingRule(ZLStringMap map) {
		for (int i = map.getSize() - 1; i >= 0; --i) {
			final String key = map.getKey(i);
			final String value = map.getValue(key);
			if (""type"".equals(key)) {
				if (""addUrlParameter"".equals(value)) {
					myType = ADD_URL_PARAMETER;
				} else if (""rewrite"".equals(value)) {
					myType = REWRITE;
				}
			} else if (""apply"".equals(key)) {
				if (""internal"".equals(value)) {
					myApply = APPLY_INTERNAL;
				} else if (""external"".equals(value)) {
					myApply = APPLY_EXTERNAL;
				}
			} else {
				myParameters.put(key, value);
			}
		}
	}

	public int whereToApply() {
		return myApply;
	}

	public String apply(String url) {
		switch (myType) {
			default:
				return url;
			case ADD_URL_PARAMETER:
			{
				final String name = myParameters.get(""name"");
				final String value = myParameters.get(""value"");
				if (name == null || value == null) {
					return url;
				}
				return ZLNetworkUtil.appendParameter(url, name, value);
			}
			case REWRITE:
			{
				/*
				final String pattern = myParameters.get(""pattern"");
				final String replacement = myParameters.get(""replacement"");
				if (pattern == null || replacement == null) {
					return url;
				}
				final Matcher matcher = Pattern.compile(pattern).matcher(url);
				if (matcher.matches()) {
					for (int i = matcher.groupCount(); i >= 1; --i) {
						url = replacement.replace(""%"" + i, matcher.group(1));
					}
				}
				*/
				return url;
			}
		}
	}
	/*
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof URLRewritingRule)) {
			return false;
		}
		final URLRewritingRule rule = (URLRewritingRule) o;
		if (Type != rule.Type
				|| Apply != rule.Apply
				|| !ZLMiscUtil.equals(Name, rule.Name)
				|| !ZLMiscUtil.equals(Value, rule.Value)) {
			return false;
		}
		return true;
	}
	*/
}
",False,123,7,30,8,6,2,2,L6
159,org.geometerplus.fbreader.network.opds.OPDSFeedMetadata.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.atom.*;

class OPDSFeedMetadata extends ATOMFeedMetadata {
	public int OpensearchTotalResults;
	public int OpensearchItemsPerPage;
	public int OpensearchStartIndex = 1;

	public String ViewType;

	protected OPDSFeedMetadata(ZLStringMap attributes) {
		super(attributes);
	}
}
",False,115,7,32,3,8,5,2,L6
160,org.geometerplus.fbreader.network.opds.OPDSXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.network.atom.*;

public class OPDSXMLReader extends ATOMXMLReader<OPDSFeedMetadata, OPDSEntry> {
	public static final String KEY_PRICE = ""price"";

	private DCDate myDCIssued;
	private String myPriceCurrency;

	public OPDSXMLReader(ATOMFeedHandler<OPDSFeedMetadata,OPDSEntry> handler, boolean readEntryNotFeed) {
		super(handler, readEntryNotFeed);
	}

	protected final OPDSFeedMetadata getOPDSFeed() {
		return getATOMFeed();
	}

	protected final OPDSEntry getOPDSEntry() {
		return getATOMEntry();
	}

	protected final OPDSLink getOPDSLink() {
		return (OPDSLink)getATOMLink();
	}

	private static final int FE_DC_LANGUAGE = ATOM_STATE_FIRST_UNUSED;
	private static final int FE_DC_ISSUED = ATOM_STATE_FIRST_UNUSED + 1;
	private static final int FE_DC_PUBLISHER = ATOM_STATE_FIRST_UNUSED + 2;
	private static final int FE_CALIBRE_SERIES = ATOM_STATE_FIRST_UNUSED + 3;
	private static final int FE_CALIBRE_SERIES_INDEX = ATOM_STATE_FIRST_UNUSED + 4;
	private static final int FEL_PRICE = ATOM_STATE_FIRST_UNUSED + 5;
	private static final int FEL_FORMAT = ATOM_STATE_FIRST_UNUSED + 6;
	private static final int OPENSEARCH_TOTALRESULTS = ATOM_STATE_FIRST_UNUSED + 7;
	private static final int OPENSEARCH_ITEMSPERPAGE = ATOM_STATE_FIRST_UNUSED + 8;
	private static final int OPENSEARCH_STARTINDEX = ATOM_STATE_FIRST_UNUSED + 9;
	private static final int FEC_HACK_SPAN = ATOM_STATE_FIRST_UNUSED + 10;
	private static final int FBREADER_VIEW = ATOM_STATE_FIRST_UNUSED + 11;

	private static final String TAG_PRICE = ""price"";
	private static final String TAG_HACK_SPAN = ""span"";

	private static final String DC_TAG_LANGUAGE = ""language"";
	private static final String DC_TAG_ISSUED = ""issued"";
	private static final String DC_TAG_PUBLISHER = ""publisher"";
	private static final String DC_TAG_FORMAT = ""format"";

	private static final String CALIBRE_TAG_SERIES = ""series"";
	private static final String CALIBRE_TAG_SERIES_INDEX = ""series_index"";

	private static final String OPENSEARCH_TAG_TOTALRESULTS = ""totalResults"";
	private static final String OPENSEARCH_TAG_ITEMSPERPAGE = ""itemsPerPage"";
	private static final String OPENSEARCH_TAG_STARTINDEX = ""startIndex"";

	private static final String FBREADER_TAG_VIEW = ""view"";

	@Override
	protected OPDSFeedMetadata createFeed(ZLStringMap attributes) {
		return new OPDSFeedMetadata(attributes);
	}

	@Override
	protected OPDSLink createLink(ZLStringMap attributes) {
		return new OPDSLink(attributes);
	}

	@Override
	protected OPDSEntry createEntry(ZLStringMap attributes) {
		return new OPDSEntry(attributes);
	}

	@Override
	public boolean startElementHandler(String ns, String tag, ZLStringMap attributes, String bufferContent) {
		switch (myState) {
			case FEED:
				if (ns == XMLNamespaces.OpenSearch) {
					if (tag == OPENSEARCH_TAG_TOTALRESULTS) {
						myState = OPENSEARCH_TOTALRESULTS;
					} else if (tag == OPENSEARCH_TAG_ITEMSPERPAGE) {
						myState = OPENSEARCH_ITEMSPERPAGE;
					} else if (tag == OPENSEARCH_TAG_STARTINDEX) {
						myState = OPENSEARCH_STARTINDEX;
					}
					return false;
				} else if (ns == XMLNamespaces.FBReaderCatalogMetadata){
					if (tag == FBREADER_TAG_VIEW) {
						myState = FBREADER_VIEW;
					}
				} else {
					return super.startElementHandler(ns, tag, attributes, bufferContent);
				}
			case F_ENTRY:
				if (ns == XMLNamespaces.DublinCoreTerms) {
					if (tag == DC_TAG_LANGUAGE) {
						myState = FE_DC_LANGUAGE;
					} else if (tag == DC_TAG_ISSUED) {
						myDCIssued = new DCDate(attributes);
						myState = FE_DC_ISSUED;
					} else if (tag == DC_TAG_PUBLISHER) {
						myState = FE_DC_PUBLISHER;
					}
					return false;
				} else if (ns == XMLNamespaces.CalibreMetadata) {
					if (tag == CALIBRE_TAG_SERIES) {
						myState = FE_CALIBRE_SERIES;
					} else if (tag == CALIBRE_TAG_SERIES_INDEX) {
						myState = FE_CALIBRE_SERIES_INDEX;
					}
					return false;
				} else {
					return super.startElementHandler(ns, tag, attributes, bufferContent);
				}
			case FE_LINK:
				if (ns == XMLNamespaces.Opds && tag == TAG_PRICE) {
					myPriceCurrency = attributes.getValue(""currencycode"");
					myState = FEL_PRICE;
					return false;
				} if (ns == XMLNamespaces.DublinCoreTerms && tag == DC_TAG_FORMAT) {
					myState = FEL_FORMAT;
					return false;
				} else {
					return super.startElementHandler(ns, tag, attributes, bufferContent);
				}
			case FE_CONTENT:
				super.startElementHandler(ns, tag, attributes, bufferContent);
				// FIXME: HACK: html handling must be implemeted neatly
				if (tag == TAG_HACK_SPAN || attributes.getValue(""class"") == ""price"") {
					myState = FEC_HACK_SPAN;
				}
				return false;
			default:
				return super.startElementHandler(ns, tag, attributes, bufferContent);
		}
	}

	@Override
	public boolean endElementHandler(String ns, String tag, String bufferContent) {
		switch (myState) {
			default:
				return super.endElementHandler(ns, tag, bufferContent);
			case FEL_PRICE:
				if (ns == XMLNamespaces.Opds && tag == TAG_PRICE) {
					if (bufferContent != null && myPriceCurrency != null) {
						getOPDSLink().Prices.add(new OPDSPrice(bufferContent.intern(), myPriceCurrency));
						myPriceCurrency = null;
					}
					myState = FE_LINK;
				}
				return false;
			case FEL_FORMAT:
				if (ns == XMLNamespaces.DublinCoreTerms && tag == DC_TAG_FORMAT) {
					if (bufferContent != null) {
						getOPDSLink().Formats.add(bufferContent.intern());
					}
					myState = FE_LINK;
				}
				return false;
			case FEC_HACK_SPAN:
				// FIXME: HACK
				myFormattedBuffer.appendText(bufferContent);
				myFormattedBuffer.appendEndTag(tag);
				myFormattedBuffer.appendText(""<br/>"");
				if (bufferContent != null) {
					getOPDSEntry().addAttribute(KEY_PRICE, bufferContent.intern());
				}
				myState = FE_CONTENT;
				return false;
			case FE_DC_LANGUAGE:
				if (ns == XMLNamespaces.DublinCoreTerms && tag == DC_TAG_LANGUAGE) {
					// FIXME:language can be lost:buffer will be truncated, if there are extension tags inside the <dc:language> tag
					getOPDSEntry().DCLanguage = bufferContent;
					myState = F_ENTRY;
				}
				return false;
			case FE_DC_ISSUED:
				if (ns == XMLNamespaces.DublinCoreTerms && tag == DC_TAG_ISSUED) {
					// FIXME:issued can be lost:buffer will be truncated, if there are extension tags inside the <dc:issued> tag
					if (ATOMDateConstruct.parse(bufferContent, myDCIssued)) {
						getOPDSEntry().DCIssued = myDCIssued;
					}
					myDCIssued = null;
					myState = F_ENTRY;
				}
				return false;
			case FE_DC_PUBLISHER:
				if (ns == XMLNamespaces.DublinCoreTerms && tag == DC_TAG_PUBLISHER) {
					// FIXME:publisher can be lost:buffer will be truncated, if there are extension tags inside the <dc:publisher> tag
					getOPDSEntry().DCPublisher = bufferContent;
					myState = F_ENTRY;
				}
				return false;
			case FE_CALIBRE_SERIES:
				if (ns == XMLNamespaces.CalibreMetadata && tag == CALIBRE_TAG_SERIES) {
					getOPDSEntry().SeriesTitle = bufferContent;
					myState = F_ENTRY;
				}
				return false;
			case FE_CALIBRE_SERIES_INDEX:
				if (ns == XMLNamespaces.CalibreMetadata && tag == CALIBRE_TAG_SERIES_INDEX) {
					if (bufferContent != null) {
						try {
							getOPDSEntry().SeriesIndex = Float.parseFloat(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = F_ENTRY;
				}
				return false;
			case OPENSEARCH_TOTALRESULTS:
				if (ns == XMLNamespaces.OpenSearch && tag == OPENSEARCH_TAG_TOTALRESULTS) {
					if (getOPDSFeed() != null && bufferContent != null) {
						try {
							getOPDSFeed().OpensearchTotalResults = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				return false;
			case OPENSEARCH_ITEMSPERPAGE:
				if (ns == XMLNamespaces.OpenSearch && tag == OPENSEARCH_TAG_ITEMSPERPAGE) {
					if (getOPDSFeed() != null && bufferContent != null) {
						try {
							getOPDSFeed().OpensearchItemsPerPage = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				return false;
			case OPENSEARCH_STARTINDEX:
				if (ns == XMLNamespaces.OpenSearch && tag == OPENSEARCH_TAG_STARTINDEX) {
					if (getOPDSFeed() != null && bufferContent != null) {
						try {
							getOPDSFeed().OpensearchStartIndex = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				return false;
			case FBREADER_VIEW:
				if (ns == XMLNamespaces.FBReaderCatalogMetadata && tag == FBREADER_TAG_VIEW) {
					if (getOPDSFeed() != null) {
						getOPDSFeed().ViewType = bufferContent;
					}
					myState = FEED;
				}
				return false;
		}
	}
}
",True,140,0,0,9,29,4,11,L6
161,org.geometerplus.fbreader.network.opds.OpenSearchXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.List;
import java.util.Map;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;

class OpenSearchXMLReader extends ZLXMLReaderAdapter {
	private final List<OpenSearchDescription> myDescriptions;

	private final String myBaseURL;

	public OpenSearchXMLReader(String baseUrl, List<OpenSearchDescription> descriptions) {
		myDescriptions = descriptions;
		myBaseURL = baseUrl;
	}

	private String myOpenSearchNamespaceId;

	@Override
	public boolean processNamespaces() {
		return true;
	}

	private static String intern(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		return str.intern();
	}

	@Override
	public void namespaceMapChangedHandler(Map<String, String> namespaces) {
		myOpenSearchNamespaceId = null;

		for (Map.Entry<String,String> entry : namespaces.entrySet()) {
			final String value = entry.getValue();
			if (value == XMLNamespaces.OpenSearch) {
				myOpenSearchNamespaceId = intern(entry.getKey());
			}
		}
	}

	private int parseInt(String value) {
		if (value == null || value.length() == 0) {
			return -1;
		}
		try {
			return Integer.valueOf(value);
		} catch (NumberFormatException e) {
			return -1;
		}
	}

	private static final int START = 0;
	private static final int DESCRIPTION = 1;

	private static final String TAG_DESCRIPTION = ""OpenSearchDescription"";
	private static final String TAG_URL = ""Url"";

	private int myState = START;

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}

		switch (myState) {
		case START:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_DESCRIPTION) {
				myState = DESCRIPTION;
			}
			break;
		case DESCRIPTION:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_URL) {
				final MimeType type = MimeType.get(attributes.getValue(""type""));
				final String rel = attributes.getValue(""rel"");
				if (MimeType.APP_ATOM.equals(type)
						&& (rel == null || rel == ""results"")) {
					final String template = ZLNetworkUtil.url(myBaseURL, attributes.getValue(""template""));
					final int indexOffset = parseInt(attributes.getValue(""indexOffset""));
					final int pageOffset = parseInt(attributes.getValue(""pageOffset""));
					final OpenSearchDescription descr =
						new OpenSearchDescription(template, indexOffset, pageOffset);
					if (descr.isValid()) {
						myDescriptions.add(0, descr);
					}
				}
			}
			break;
		}

		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}

		switch (myState) {
		case DESCRIPTION:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_DESCRIPTION) {
				myState = START;
			}
			break;
		}
		return false;
	}
}
",True,134,11,32,6,7,1,6,L6
162,org.geometerplus.fbreader.network.opds.OPDSLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.Currency;
import java.util.LinkedList;
import java.util.Locale;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.atom.ATOMLink;

class OPDSPrice {
	public final String Price;
	public final String Currency;

	// @param price     price value; must be not null
	// @param currency  currency code value; must be not null;
	//                  http://www.iso.org/iso/en/prods-services/popstds/currencycodeslist.html
	public OPDSPrice(String price, String currency) {
		Price = price;
		Currency = currency;
	}
}

class OPDSLink extends ATOMLink {
	public final LinkedList<OPDSPrice> Prices = new LinkedList<OPDSPrice>();
	public final LinkedList<String> Formats = new LinkedList<String>();

	protected OPDSLink(ZLStringMap attributes) {
		super(attributes);
	}

	private OPDSPrice getPrice(String currency) {
		for (OPDSPrice p: Prices) {
			if (currency.equals(p.Currency)) {
				return p;
			}
		}
		return null;
	}

	public OPDSPrice selectBestPrice() {
		if (Prices.isEmpty()) {
			return null;
		} else if (Prices.size() == 1) {
			return Prices.get(0);
		}
		OPDSPrice price;
		final Locale locale = Locale.getDefault();
		if (locale.getCountry().length() == 2) {
			final String bestCode = Currency.getInstance(locale).getCurrencyCode();
			if (bestCode != null) {
				price = getPrice(bestCode);
				if (price != null) {
					return price;
				}
			}
		}
		price = getPrice(""USD"");
		if (price != null) {
			return price;
		}
		price = getPrice(""EUR"");
		if (price != null) {
			return price;
		}
		return Prices.get(0);
	}
}
",False,107,7,34,2,2,2,2,L6
163,org.geometerplus.fbreader.network.opds.OPDSEntry.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.atom.*;

class OPDSEntry extends ATOMEntry {
	public String DCLanguage;
	public String DCPublisher;
	public DCDate DCIssued;

	public String SeriesTitle;
	public float SeriesIndex;

	protected OPDSEntry(ZLStringMap attributes) {
		super(attributes);
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",DCLanguage="").append(DCLanguage);
		buf.append("",DCPublisher="").append(DCPublisher);
		buf.append("",DCIssued="").append(DCIssued);
		buf.append("",SeriesTitle="").append(SeriesTitle);
		buf.append("",SeriesIndex="").append(SeriesIndex);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,117,7,32,2,11,5,3,L6
164,org.geometerplus.fbreader.network.opds.OPDSCustomNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;
import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

import org.geometerplus.fbreader.network.ICustomNetworkLink;
import org.geometerplus.fbreader.network.NetworkException;
import org.geometerplus.fbreader.network.urlInfo.*;

public class OPDSCustomNetworkLink extends OPDSNetworkLink implements ICustomNetworkLink {
	private boolean myHasChanges;

	private static String removeWWWPrefix(String siteName) {
		if (siteName != null && siteName.startsWith(""www."")) {
			return siteName.substring(4);
		}
		return siteName;
	}

	public OPDSCustomNetworkLink(int id, String siteName, String title, String summary, String language, UrlInfoCollection<UrlInfoWithDate> infos) {
		super(id, removeWWWPrefix(siteName), title, summary, language, infos);
	}

	public boolean hasChanges() {
		return myHasChanges;
	}

	public void resetChanges() {
		myHasChanges = false;
	}

	public final void setSiteName(String name) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(mySiteName, name);
		mySiteName = name;
	}

	public final void setSummary(String summary) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(mySummary, summary);
		mySummary = summary;
	}

	public final void setTitle(String title) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(myTitle, title);
		myTitle = title;
	}

	public final void setUrl(UrlInfo.Type type, String url) {
		myInfos.removeAllInfos(type);
		myInfos.addInfo(new UrlInfoWithDate(type, url));
		myHasChanges = true;
	}

	public final void removeUrl(UrlInfo.Type type) {
		myHasChanges = myHasChanges || myInfos.getInfo(type) != null;
		myInfos.removeAllInfos(type);
	}

	public boolean isObsolete(long milliSeconds) {
		final long old = System.currentTimeMillis() - milliSeconds;
		
		Date updateDate = getUrlInfo(UrlInfo.Type.Search).Updated;
		if (updateDate == null || updateDate.getTime() < old) {
			return true;
		}

		updateDate = getUrlInfo(UrlInfo.Type.Image).Updated;
		if (updateDate == null || updateDate.getTime() < old) {
			return true;
		}

		return false;
	}

	public void reloadInfo(final boolean urlsOnly) throws ZLNetworkException {
		final LinkedList<String> opensearchDescriptionURLs = new LinkedList<String>();
		final List<OpenSearchDescription> descriptions = Collections.synchronizedList(new LinkedList<OpenSearchDescription>());

		ZLNetworkException error = null;
		try {
			ZLNetworkManager.Instance().perform(new ZLNetworkRequest(getUrl(UrlInfo.Type.Catalog)) {
				@Override
				public void handleStream(InputStream inputStream, int length) throws IOException, ZLNetworkException {
					final OPDSCatalogInfoHandler info = new OPDSCatalogInfoHandler(getURL(), OPDSCustomNetworkLink.this, opensearchDescriptionURLs);
					new OPDSXMLReader(info, false).read(inputStream);
        
					if (!info.FeedStarted) {
						throw new ZLNetworkException(NetworkException.ERROR_NOT_AN_OPDS);
					}
					if (info.Title == null) {
						throw new ZLNetworkException(NetworkException.ERROR_NO_REQUIRED_INFORMATION);
					}
					setUrl(UrlInfo.Type.Image, info.Icon);
					if (info.DirectOpenSearchDescription != null) {
						descriptions.add(info.DirectOpenSearchDescription);
					}
					if (!urlsOnly) {
						myTitle = info.Title.toString();
						mySummary = info.Summary != null ? info.Summary.toString() : null;
					}
				}
			});
		} catch (ZLNetworkException e) {
			error = e;
		}

		if (!opensearchDescriptionURLs.isEmpty()) {
			LinkedList<ZLNetworkRequest> requests = new LinkedList<ZLNetworkRequest>();
			for (String url: opensearchDescriptionURLs) {
				requests.add(new ZLNetworkRequest(url) {
					@Override
					public void handleStream(InputStream inputStream, int length) throws IOException, ZLNetworkException {
						new OpenSearchXMLReader(getURL(), descriptions).read(inputStream);
					}
				});
			}
			try {
				ZLNetworkManager.Instance().perform(requests);
			} catch (ZLNetworkException e) {
				if (error == null) {
					error = e;
				}
			}
		}

		if (!descriptions.isEmpty()) {
			// TODO: May be do not use '%s'??? Use Description instead??? (this needs to rewrite SEARCH engine logic a little)
			setUrl(UrlInfo.Type.Search, descriptions.get(0).makeQuery(""%s""));
		} else {
			setUrl(UrlInfo.Type.Search, null);
		}
		if (error != null) {
			throw error;
		}
	}
}
",False,194,5,35,9,32,3,16,L6
165,org.geometerplus.fbreader.network.opds.BasketItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.urlInfo.UrlInfo;
import org.geometerplus.fbreader.network.urlInfo.UrlInfoCollection;

public class BasketItem extends OPDSCatalogItem {
	BasketItem(OPDSNetworkLink link, String title, String summary, UrlInfoCollection<?> urls, Accessibility accessibility) {
		super(link, title, summary, urls, accessibility, FLAGS_DEFAULT & ~FLAGS_GROUP);
		link.setSupportsBasket();
	}

	@Override
	protected String getCatalogUrl() {
		final StringBuilder builder = new StringBuilder();
		boolean flag = false;
		for (String bookId : Link.basket().bookIds()) {
			if (flag) {
				builder.append(',');
			} else {
				flag = true;
			}
			builder.append(bookId);
		}

		return ZLNetworkUtil.appendParameter(getUrl(UrlInfo.Type.Catalog), ""ids"", builder.toString());
	}
}
",False,195,7,26,10,32,1,10,L6
166,org.geometerplus.fbreader.network.opds.OPDSCatalogInfoHandler.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.List;

import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.atom.ATOMLink;
import org.geometerplus.fbreader.network.atom.ATOMFeedHandler;

class OPDSCatalogInfoHandler implements ATOMFeedHandler<OPDSFeedMetadata,OPDSEntry> {
	public boolean FeedStarted;
	public String Icon;
	public CharSequence Title;
	public CharSequence Summary;

	public OpenSearchDescription DirectOpenSearchDescription;
	private final List<String> myOpensearchDescriptionURLs;

	private final String myBaseURL;
	private final OPDSNetworkLink myLink;

	public OPDSCatalogInfoHandler(String baseUrl, OPDSNetworkLink link, List<String> opensearchDescriptionURLs) {
		myBaseURL = baseUrl;
		myLink = link;
		myOpensearchDescriptionURLs = opensearchDescriptionURLs;
	}

	public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
		Icon = (feed.Icon != null) ? feed.Icon.Uri : null;
		Title = feed.Title;
		Summary = feed.Subtitle;

		for (ATOMLink link: feed.Links) {
			final MimeType type = MimeType.get(link.getType());
			final String rel = myLink.relation(link.getRel(), type);
			if (rel == ""search"") {
				if (MimeType.APP_OPENSEARCHDESCRIPTION.equals(type)) {
					myOpensearchDescriptionURLs.add(ZLNetworkUtil.url(myBaseURL, link.getHref()));
				} else if (MimeType.APP_ATOM.equals(type)) {
					final String template = ZLNetworkUtil.url(myBaseURL, link.getHref());
					final OpenSearchDescription descr = OpenSearchDescription.createDefault(template);
					if (descr.isValid()) {
						DirectOpenSearchDescription = descr;
					}
				}
			}
		}
		return true;
	}

	public void processFeedStart() {
		FeedStarted = true;
	}

	public void processFeedEnd() {
	}

	public boolean processFeedEntry(OPDSEntry entry) {
		return true;
	}
}
",True,140,0,0,10,32,1,10,L6
167,org.geometerplus.fbreader.network.opds.DCDate.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.atom.*;

class DCDate extends ATOMDateConstruct {
	protected DCDate(ZLStringMap source) {
		super(source);
	}

	/*
	public DCDate(int year) {
		super(year);
	}

	public DCDate(int year, int month, int day) {
		super(year, month, day);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
	*/
}
",False,108,7,34,2,2,2,2,L6
168,org.geometerplus.fbreader.network.opds.OPDSFeedHandler.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.atom.*;
import org.geometerplus.fbreader.network.authentication.litres.LitResBookshelfItem;
import org.geometerplus.fbreader.network.authentication.litres.LitResRecommendationsItem;
import org.geometerplus.fbreader.network.urlInfo.*;

class OPDSFeedHandler implements ATOMFeedHandler<OPDSFeedMetadata,OPDSEntry>, OPDSConstants {
	private final OPDSCatalogItem myCatalog;
	private final String myBaseURL;
	private final OPDSCatalogItem.State myData;

	private int myIndex;

	private String myNextURL;
	private String mySkipUntilId;
	private boolean myFoundNewIds;

	private int myItemsToLoad = -1;

	/**
	 * Creates new OPDSFeedHandler instance that can be used to get NetworkItem objects from OPDS feeds.
	 *
	 * @param baseURL    string that contains URL of the OPDS feed, that will be read using this instance of the reader
	 * @param result     network results buffer. Must be created using OPDSNetworkLink corresponding to the OPDS feed, 
	 *                   that will be read using this instance of the reader.
	 */
	OPDSFeedHandler(OPDSCatalogItem catalog, String baseURL, OPDSCatalogItem.State result) {
		myCatalog = catalog;
		myBaseURL = baseURL;
		myData = result;
		mySkipUntilId = myData.LastLoadedId;
		myFoundNewIds = mySkipUntilId != null;
		if (!(result.Link instanceof OPDSNetworkLink)) {
			throw new IllegalArgumentException(""Parameter `result` has invalid `Link` field value: result.Link must be an instance of OPDSNetworkLink class."");
		}
	}

	public void processFeedStart() {
		myData.ResumeURI = myBaseURL;
	}

	public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
		if (beforeEntries) {
			myIndex = feed.OpensearchStartIndex - 1;
			if (feed.OpensearchItemsPerPage > 0) {
				myItemsToLoad = feed.OpensearchItemsPerPage;
				final int len = feed.OpensearchTotalResults - myIndex;
				if (len > 0 && len < myItemsToLoad) {
					myItemsToLoad = len;
				}
			}
			if (myCatalog != null) {
				if (""series"".equals(feed.ViewType)) {
					myCatalog.setFlags(myCatalog.getFlags() & ~OPDSCatalogItem.FLAGS_GROUP);
				} else if (""authors"".equals(feed.ViewType)) {
					myCatalog.setFlags(myCatalog.getFlags() & ~OPDSCatalogItem.FLAG_SHOW_AUTHOR);
				}
			}
		} else {
			final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
			for (ATOMLink link : feed.Links) {
				final MimeType type = MimeType.get(link.getType());
				final String rel = opdsLink.relation(link.getRel(), type);
				if (MimeType.APP_ATOM.weakEquals(type) && ""next"".equals(rel)) {
					myNextURL = ZLNetworkUtil.url(myBaseURL, link.getHref());
				}
			}
		}
		return false;
	}

	public void processFeedEnd() {
		if (mySkipUntilId != null) {
			// Last loaded element was not found => resume error => DO NOT RESUME
			// TODO: notify user about error???
			// TODO: do reload???
			myNextURL = null;
		}
		myData.ResumeURI = myFoundNewIds ? myNextURL : null;
		myData.LastLoadedId = null;
	}

	private boolean tryInterrupt() {
		final int noninterruptableRemainder = 10;
		return (myItemsToLoad < 0 || myItemsToLoad > noninterruptableRemainder)
				&& myData.Listener.confirmInterrupt();
	}

	private String calculateEntryId(OPDSEntry entry) {
		if (entry.Id != null) {
			return entry.Id.Uri;
		}

		String id = null;
		int idType = 0;

		final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
		for (ATOMLink link : entry.Links) {
			final MimeType type = MimeType.get(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);

			if (rel == null && MimeType.APP_ATOM.weakEquals(type)) {
				return ZLNetworkUtil.url(myBaseURL, link.getHref());
			}
			int relType = BookUrlInfo.Format.NONE;
			if (rel == null || rel.startsWith(REL_ACQUISITION_PREFIX)
					|| rel.startsWith(REL_FBREADER_ACQUISITION_PREFIX)) {
				relType = OPDSBookItem.formatByMimeType(type);
			}
			if (relType != BookUrlInfo.Format.NONE
					&& (id == null || idType < relType
							|| (idType == relType && REL_ACQUISITION.equals(rel)))) {
				id = ZLNetworkUtil.url(myBaseURL, link.getHref());
				idType = relType;
			}
		}
		return id;
	}

	public boolean processFeedEntry(OPDSEntry entry) {
		if (myItemsToLoad >= 0) {
			--myItemsToLoad;
		}

		if (entry.Id == null) {
			final String id = calculateEntryId(entry);
			if (id == null) {
				return tryInterrupt();
			}
			entry.Id = new ATOMId();
			entry.Id.Uri = id;
		}

		if (mySkipUntilId != null) {
			if (mySkipUntilId.equals(entry.Id.Uri)) {
				mySkipUntilId = null;
			}
			return tryInterrupt();
		}
		myData.LastLoadedId = entry.Id.Uri;
		if (!myFoundNewIds && !myData.LoadedIds.contains(entry.Id.Uri)) {
			myFoundNewIds = true;
		}
		myData.LoadedIds.add(entry.Id.Uri);

		final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
		boolean hasBookLink = false;
		for (ATOMLink link: entry.Links) {
			final MimeType type = MimeType.get(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (rel == null
					? (OPDSBookItem.formatByMimeType(type) != BookUrlInfo.Format.NONE)
					: (rel.startsWith(REL_ACQUISITION_PREFIX)
							|| rel.startsWith(REL_FBREADER_ACQUISITION_PREFIX))) {
				hasBookLink = true;
				break;
			}
		}

		NetworkItem item;
		if (hasBookLink) {
			item = new OPDSBookItem((OPDSNetworkLink)myData.Link, entry, myBaseURL, myIndex++);
		} else {
			item = readCatalogItem(entry);
		}
		if (item != null) {
			myData.Listener.onNewItem(myData.Link, item);
		}
		return tryInterrupt();
	}

	private NetworkItem readCatalogItem(OPDSEntry entry) {
		final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
		final UrlInfoCollection<UrlInfo> urlMap = new UrlInfoCollection<UrlInfo>();

		boolean urlIsAlternate = false;
		String litresRel = null;
		for (ATOMLink link : entry.Links) {
			final String href = ZLNetworkUtil.url(myBaseURL, link.getHref());
			final MimeType type = MimeType.get(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (MimeType.IMAGE_PNG.weakEquals(type) || MimeType.IMAGE_JPEG.weakEquals(type)) {
				if (REL_IMAGE_THUMBNAIL.equals(rel) || REL_THUMBNAIL.equals(rel)) {
					urlMap.addInfo(new UrlInfo(UrlInfo.Type.Thumbnail, href));
				} else if (REL_COVER.equals(rel) || (rel != null && rel.startsWith(REL_IMAGE_PREFIX))) {
					urlMap.addInfo(new UrlInfo(UrlInfo.Type.Image, href));
				}
			} else if (MimeType.APP_ATOM.weakEquals(type)) {
				final boolean hasCatalogUrl =
					urlMap.getInfo(UrlInfo.Type.Catalog) != null;
				if (REL_ALTERNATE.equals(rel)) {
					if (!hasCatalogUrl) {
						urlMap.addInfo(new UrlInfo(UrlInfo.Type.Catalog, href));
						urlIsAlternate = true;
					}
				} else if (!hasCatalogUrl || rel == null || REL_SUBSECTION.equals(rel)) {
					urlMap.addInfo(new UrlInfo(UrlInfo.Type.Catalog, href));
					urlIsAlternate = false;
				}
			} else if (MimeType.TEXT_HTML.weakEquals(type)) {
				if (REL_ACQUISITION.equals(rel) ||
					REL_ACQUISITION_OPEN.equals(rel) ||
					REL_ALTERNATE.equals(rel) ||
					rel == null) {
					urlMap.addInfo(new UrlInfo(UrlInfo.Type.HtmlPage, href));
				}
			} else if (MimeType.APP_LITRES.weakEquals(type)) {
				urlMap.addInfo(new UrlInfo(UrlInfo.Type.Catalog, href));
				litresRel = rel;
			}
		}

		if (urlMap.getInfo(UrlInfo.Type.Catalog) == null &&
			urlMap.getInfo(UrlInfo.Type.HtmlPage) == null) {
			return null;
		}

		if (urlMap.getInfo(UrlInfo.Type.Catalog) != null && !urlIsAlternate) {
			urlMap.removeAllInfos(UrlInfo.Type.HtmlPage);
		}

		final CharSequence annotation;
		if (entry.Summary != null) {
			annotation = entry.Summary;
		} else if (entry.Content != null) {
			annotation = entry.Content;
		} else {
			annotation = null;
		}

		if (litresRel != null) {
			if (REL_BOOKSHELF.equals(litresRel)) {
				return new LitResBookshelfItem(
					opdsLink,
					entry.Title,
					annotation,
					urlMap
				);
			} else if (REL_RECOMMENDATIONS.equals(litresRel)) {
				return new LitResRecommendationsItem(
					opdsLink,
					entry.Title,
					annotation,
					urlMap
				);
			} else if (REL_BASKET.equals(litresRel)) {
				return null;
				/*
				return new BasketItem(
					opdsLink,
					entry.Title,
					annotation,
					urlMap
				);
				*/
			} else if (REL_TOPUP.equals(litresRel)) {
				return new TopUpItem(opdsLink, urlMap);
			} else {
				return null;
			}
		} else {
			return new OPDSCatalogItem(
				opdsLink,
				entry.Title,
				annotation,
				urlMap,
				OPDSCatalogItem.Accessibility.ALWAYS,
				NetworkCatalogItem.FLAGS_DEFAULT
			);
		}
	}
}
",False,140,0,0,10,37,1,23,L6
169,org.geometerplus.fbreader.network.opds.OPDSBookItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;
import java.io.*;

import org.geometerplus.zlibrary.core.network.*;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.NetworkBookItem;
import org.geometerplus.fbreader.network.atom.*;
import org.geometerplus.fbreader.network.urlInfo.*;

public class OPDSBookItem extends NetworkBookItem implements OPDSConstants {
	private static CharSequence getAnnotation(OPDSEntry entry) {
		if (entry.Content != null) {
			return entry.Content;
		}
		if (entry.Summary != null) {
			return entry.Summary;
		}
		return null;
	}

	private static List<AuthorData> getAuthors(OPDSEntry entry) {
		final String AuthorPrefix = ""author:"";
		final String AuthorsPrefix = ""authors:"";

		final LinkedList<AuthorData> authors = new LinkedList<AuthorData>();
		for (ATOMAuthor author: entry.Authors) {
			String name = author.Name;
			final String lowerCased = name.toLowerCase();
			int index = lowerCased.indexOf(AuthorPrefix);
			if (index != -1) {
				name = name.substring(index + AuthorPrefix.length());
			} else {
				index = lowerCased.indexOf(AuthorsPrefix);
				if (index != -1) {
					name = name.substring(index + AuthorsPrefix.length());
				}
			}
			index = name.indexOf(',');
			final AuthorData authorData;
			if (index != -1) {
				final String before = name.substring(0, index).trim();
				final String after = name.substring(index + 1).trim();
				authorData = new AuthorData(after + ' ' + before, before);
			} else {
				name = name.trim();
				index = name.lastIndexOf(' ');
				authorData = new AuthorData(name, name.substring(index + 1));
			}
			authors.add(authorData);
		}
		return authors;
	}

	private static List<String> getTags(OPDSEntry entry) {
		final LinkedList<String> tags = new LinkedList<String>();
		for (ATOMCategory category : entry.Categories) {
			String label = category.getLabel();
			if (label == null) {
				label = category.getTerm();
			}
			if (label != null) {
				tags.add(label);
			}
		}
		return tags;
	}

	private static UrlInfoCollection<UrlInfo> getUrls(OPDSNetworkLink networkLink, OPDSEntry entry, String baseUrl) {
		final UrlInfoCollection<UrlInfo> urls = new UrlInfoCollection<UrlInfo>();
		for (ATOMLink link: entry.Links) {
			final String href = ZLNetworkUtil.url(baseUrl, link.getHref());
			final MimeType type = MimeType.get(link.getType());
			final String rel = networkLink.relation(link.getRel(), type);
			final UrlInfo.Type referenceType = typeByRelation(rel);
			if (REL_IMAGE_THUMBNAIL.equals(rel) || REL_THUMBNAIL.equals(rel)) {
				if (MimeType.IMAGE_PNG.equals(type) || MimeType.IMAGE_JPEG.equals(type)) {
					urls.addInfo(new UrlInfo(UrlInfo.Type.Thumbnail, href));
				}
			} else if ((rel != null && rel.startsWith(REL_IMAGE_PREFIX)) || REL_COVER.equals(rel)) {
				if (MimeType.IMAGE_PNG.equals(type) || MimeType.IMAGE_JPEG.equals(type)) {
					urls.addInfo(new UrlInfo(UrlInfo.Type.Image, href));
				}
			} else if (MimeType.APP_ATOM.Name.equals(type.Name) &&
					   ""entry"".equals(type.getParameter(""type""))) {
				urls.addInfo(new UrlInfo(UrlInfo.Type.SingleEntry, href));
			} else if (UrlInfo.Type.BookBuy == referenceType) {
				final OPDSLink opdsLink = (OPDSLink)link; 
				String price = null;
				final OPDSPrice opdsPrice = opdsLink.selectBestPrice();
				if (opdsPrice != null) {
					price = BookBuyUrlInfo.price(opdsPrice.Price, opdsPrice.Currency);
				}
				if (price == null) {
					// FIXME: HACK: price handling must be implemented not through attributes!!!
					price = BookBuyUrlInfo.price(entry.getAttribute(OPDSXMLReader.KEY_PRICE), null);
				}
				if (price == null) {
					price = """";
				}
				if (MimeType.TEXT_HTML.equals(type)) {
					collectReferences(urls, opdsLink, href,
							UrlInfo.Type.BookBuyInBrowser, price, true);
				} else {
					collectReferences(urls, opdsLink, href,
							UrlInfo.Type.BookBuy, price, false);
				}
			} else if (referenceType == UrlInfo.Type.Related) {
				urls.addInfo(new RelatedUrlInfo(referenceType, link.getTitle(), type, href));
			} else if (referenceType == UrlInfo.Type.Comments) {
				urls.addInfo(new RelatedUrlInfo(referenceType, link.getTitle(), type, href));
			} else if (referenceType == UrlInfo.Type.TOC) {
				urls.addInfo(new UrlInfo(referenceType, href));
			} else if (referenceType != null) {
				final int format = formatByMimeType(type);
				if (format != BookUrlInfo.Format.NONE) {
					urls.addInfo(new BookUrlInfo(referenceType, format, href));
				}
			}
		}
		return urls;
	}

	private static UrlInfo.Type typeByRelation(String rel) {
		if (rel == null || REL_ACQUISITION.equals(rel) || REL_ACQUISITION_OPEN.equals(rel)) {
			return UrlInfo.Type.Book;
		} else if (REL_ACQUISITION_SAMPLE.equals(rel)) {
			return UrlInfo.Type.BookDemo;
		} else if (REL_ACQUISITION_CONDITIONAL.equals(rel)) {
			return UrlInfo.Type.BookConditional;
		} else if (REL_ACQUISITION_SAMPLE_OR_FULL.equals(rel)) {
			return UrlInfo.Type.BookFullOrDemo;
		} else if (REL_ACQUISITION_BUY.equals(rel)) {
			return UrlInfo.Type.BookBuy;
		} else if (REL_RELATED.equals(rel)) {
			return UrlInfo.Type.Related;
		} else if (REL_CONTENTS.equals(rel)) {
			return UrlInfo.Type.TOC;
		} else if (REL_REPLIES.equals(rel)) {
			return UrlInfo.Type.Comments;
		} else {
			return null;
		}
	}

	private static void collectReferences(
		UrlInfoCollection<UrlInfo> urls,
		OPDSLink opdsLink,
		String href,
		UrlInfo.Type type,
		String price,
		boolean addWithoutFormat
	) {
		boolean added = false;
		for (String mime : opdsLink.Formats) {
			final int format = formatByMimeType(MimeType.get(mime));
			if (format != BookUrlInfo.Format.NONE) {
				urls.addInfo(new BookBuyUrlInfo(type, format, href, price));
				added = true;
			}
		}
		if (!added && addWithoutFormat) {
			urls.addInfo(new BookBuyUrlInfo(type, BookUrlInfo.Format.NONE, href, price));
		}
	}

	static int formatByMimeType(MimeType type) {
		if (MimeType.APP_FB2ZIP.equals(type)) {
			return BookUrlInfo.Format.FB2_ZIP;
		} else if (MimeType.APP_EPUB.equals(type)) {
			return BookUrlInfo.Format.EPUB;
		} else if (MimeType.APP_MOBI.equals(type)) {
			return BookUrlInfo.Format.MOBIPOCKET;
		}
		return BookUrlInfo.Format.NONE;
	}

	public OPDSBookItem(
		OPDSNetworkLink link, String id, int index,
		CharSequence title, CharSequence summary,
		List<AuthorData> authors, List<String> tags,
		String seriesTitle, float indexInSeries,
		UrlInfoCollection<?> urls
	) {
		super(
			link, id, index,
			title, summary,
			authors, tags,
			seriesTitle, indexInSeries,
			urls
		);
	}

	OPDSBookItem(OPDSNetworkLink networkLink, OPDSEntry entry, String baseUrl, int index) {
		this(
			networkLink, entry.Id.Uri, index,
			entry.Title, getAnnotation(entry),
			getAuthors(entry), getTags(entry),
			entry.SeriesTitle, entry.SeriesIndex,
			getUrls(networkLink, entry, baseUrl)
		);
	}

	private volatile boolean myInformationIsFull;

	@Override
	public synchronized boolean isFullyLoaded() {
		return myInformationIsFull || getUrl(UrlInfo.Type.SingleEntry) == null;
	}

	@Override
	public synchronized void loadFullInformation() throws ZLNetworkException {
		if (myInformationIsFull) {
			return;
		}

		final String url = getUrl(UrlInfo.Type.SingleEntry);
		if (url == null) {
			myInformationIsFull = true;
			return;
		}

		ZLNetworkManager.Instance().perform(new ZLNetworkRequest(url) {
			@Override
			public void handleStream(InputStream inputStream, int length) throws IOException, ZLNetworkException {
				new OPDSXMLReader(
					new SingleEntryFeedHandler(url), true
				).read(inputStream);
				myInformationIsFull = true;
			}
		});
	}

	@Override
	public OPDSCatalogItem createRelatedCatalogItem(RelatedUrlInfo info) {
		if (MimeType.APP_ATOM.equals(info.Mime)) {
			return new OPDSCatalogItem((OPDSNetworkLink)Link, info);
		}
		return null;
	}

	private class SingleEntryFeedHandler implements ATOMFeedHandler<OPDSFeedMetadata,OPDSEntry> {
		private final String myUrl;

		SingleEntryFeedHandler(String url) {
			myUrl = url;
		}

		public void processFeedStart() {
		}

		public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
			return false;
		}

		public boolean processFeedEntry(OPDSEntry entry) {
			addUrls(getUrls((OPDSNetworkLink)Link, entry, myUrl));
			final CharSequence summary = getAnnotation(entry);
			if (summary != null) {
				setSummary(summary);
			}
			return false;
		}

		public void processFeedEnd() {
		}
	}
}
",False,140,0,0,9,30,2,29,L6
170,org.geometerplus.fbreader.network.opds.OPDSLinkReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.io.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.Paths;
import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.atom.ATOMUpdated;

public class OPDSLinkReader {
	static final String CATALOGS_URL = ""http://data.fbreader.org/catalogs/generic-1.6.xml"";

	public static final int CACHE_LOAD = 0;
	public static final int CACHE_UPDATE = 1;
	public static final int CACHE_CLEAR = 2;

	public static void loadOPDSLinks(int cacheMode, final NetworkLibrary.OnNewLinkListener listener) throws ZLNetworkException {
		final File dirFile = new File(Paths.networkCacheDirectory());
		if (!dirFile.exists() && !dirFile.mkdirs()) {
			ZLNetworkManager.Instance().perform(new ZLNetworkRequest(CATALOGS_URL) {
				@Override
				public void handleStream(InputStream inputStream, int length) throws IOException, ZLNetworkException {
					new OPDSLinkXMLReader(listener, null).read(inputStream);
				}
			});
			// TODO: Is this error is needed?
			//throw new ZLNetworkException(NetworkException.ERROR_CACHE_DIRECTORY_ERROR);
			return;
		}

		final String fileName = ""fbreader_catalogs-""
			+ CATALOGS_URL.substring(CATALOGS_URL.lastIndexOf(File.separator) + 1);

		boolean cacheIsGood = false;
		File oldCache = null;
		ATOMUpdated cacheUpdatedTime = null;
		final File catalogsFile = new File(dirFile, fileName);
		if (catalogsFile.exists()) {
			switch (cacheMode) {
			case CACHE_UPDATE:
				final long diff = System.currentTimeMillis() - catalogsFile.lastModified();
				final long valid = 7 * 24 * 60 * 60 * 1000; // one week in milliseconds; FIXME: hardcoded const
				if (diff >= 0 && diff <= valid) {
					return;
				}
				/* FALLTHROUGH */
			case CACHE_CLEAR:
				try {
					final OPDSLinkXMLReader reader = new OPDSLinkXMLReader();
					reader.read(new FileInputStream(catalogsFile));
					cacheUpdatedTime = reader.getUpdatedTime();
				} catch (FileNotFoundException e) {
					throw new RuntimeException(""That's impossible!!!"", e); 
				}

				oldCache = new File(dirFile, ""_"" + fileName);
				oldCache.delete();
				if (!catalogsFile.renameTo(oldCache)) {
					catalogsFile.delete();
					oldCache = null;
				}
				break;
			case CACHE_LOAD:
				cacheIsGood = true;
				break;
			default:
				throw new IllegalArgumentException(""Invalid cacheMode value ("" + cacheMode
						+ "") in OPDSLinkReader.loadOPDSLinks method"");
			}
		}

		if (!cacheIsGood) {
			try {
				ZLNetworkManager.Instance().downloadToFile(CATALOGS_URL, catalogsFile);
			} catch (ZLNetworkException e) {
				if (oldCache == null) {
					throw e;
				}
				catalogsFile.delete();
				if (!oldCache.renameTo(catalogsFile)) {
					oldCache.delete();
					oldCache = null;
					throw e;
				}
			} finally {
				if (oldCache != null) {
					oldCache.delete();
					oldCache = null;
				}
			}
		}

		try {
			new OPDSLinkXMLReader(listener, cacheUpdatedTime).read(new FileInputStream(catalogsFile));
		} catch (FileNotFoundException e) {
			throw new RuntimeException(""That's impossible!!!"", e); 
		}
	}
}
",True,140,0,0,6,48,1,8,L6
171,org.geometerplus.fbreader.network.opds.OPDSConstants.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.atom.ATOMConstants;

interface OPDSConstants extends ATOMConstants {
	// Feed level
	String REL_BOOKSHELF = ""http://data.fbreader.org/rel/bookshelf"";
	String REL_RECOMMENDATIONS = ""http://data.fbreader.org/rel/recommendations"";
	String REL_BASKET = ""http://data.fbreader.org/rel/basket"";
	String REL_TOPUP = ""http://data.fbreader.org/rel/topup"";
	//String REL_SUBSCRIPTIONS = ""http://opds-spec.org/subscriptions"";

	// Entry level / catalog types
	String REL_SUBSECTION = ""subsection"";

	// Entry level / acquisition links
	String REL_ACQUISITION_PREFIX = ""http://opds-spec.org/acquisition"";
	String REL_FBREADER_ACQUISITION_PREFIX = ""http://data.fbreader.org/acquisition"";
	String REL_ACQUISITION = ""http://opds-spec.org/acquisition"";
	String REL_ACQUISITION_OPEN = ""http://opds-spec.org/acquisition/open-access"";
	String REL_ACQUISITION_SAMPLE = ""http://opds-spec.org/acquisition/sample"";
	String REL_ACQUISITION_BUY = ""http://opds-spec.org/acquisition/buy"";
	//String REL_ACQUISITION_BORROW = ""http://opds-spec.org/acquisition/borrow"";
	//String REL_ACQUISITION_SUBSCRIBE = ""http://opds-spec.org/acquisition/subscribe"";
	String REL_ACQUISITION_CONDITIONAL = ""http://data.fbreader.org/acquisition/conditional"";
	String REL_ACQUISITION_SAMPLE_OR_FULL = ""http://data.fbreader.org/acquisition/sampleOrFull"";

	// Entry level / other
	String REL_IMAGE_PREFIX = ""http://opds-spec.org/image"";
	//String REL_IMAGE = ""http://opds-spec.org/image"";
	String REL_IMAGE_THUMBNAIL = ""http://opds-spec.org/image/thumbnail"";
	// FIXME: This relations have been removed from OPDS-1.0 standard. Use RelationAlias instead???
	String REL_COVER = ""http://opds-spec.org/cover"";
	String REL_THUMBNAIL = ""http://opds-spec.org/thumbnail"";
	String REL_CONTENTS = ""contents""; // Book TOC
	String REL_REPLIES = ""replies"";

	// Entry level / OPDS Link Relations
	String REL_LINK_SIGN_IN = ""http://data.fbreader.org/catalog/sign-in"";
	String REL_LINK_SIGN_OUT = ""http://data.fbreader.org/catalog/sign-out"";
	String REL_LINK_SIGN_UP = ""http://data.fbreader.org/catalog/sign-up"";
	String REL_LINK_TOPUP = ""http://data.fbreader.org/catalog/refill-account"";
	String REL_LINK_RECOVER_PASSWORD = ""http://data.fbreader.org/catalog/recover-password"";
}
",True,104,7,33,1,1,3,1,L6
172,org.geometerplus.fbreader.network.opds.OPDSLinkXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.atom.*;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;
import org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager;
import org.geometerplus.fbreader.network.urlInfo.*;

class OPDSLinkXMLReader extends OPDSXMLReader implements OPDSConstants {
	private static class FeedHandler implements ATOMFeedHandler<OPDSFeedMetadata,OPDSEntry> {
		private NetworkLibrary.OnNewLinkListener myListener;

		private String myAuthenticationType;
		private final LinkedList<URLRewritingRule> myUrlRewritingRules = new LinkedList<URLRewritingRule>();
		private final HashMap<RelationAlias, String> myRelationAliases = new HashMap<RelationAlias, String>();
		private final LinkedHashMap<String,String> myExtraData = new LinkedHashMap<String,String>(); 

		private ATOMUpdated myUpdatedTime;
		private ATOMUpdated myReadAfterTime;

		public FeedHandler(NetworkLibrary.OnNewLinkListener listener, ATOMUpdated readAfter) {
			myListener = listener;
			myReadAfterTime = readAfter;
		}

		public void setAuthenticationType(String type) {
			myAuthenticationType = type;
		}

		public void addUrlRewritingRule(URLRewritingRule rule) {
			myUrlRewritingRules.add(rule);
		}

		public void addRelationAlias(RelationAlias alias, String relation) {
			myRelationAliases.put(alias, relation);
		}

		public void putExtraData(String name, String value) {
			myExtraData.put(name, value);
		}

		public void clear() {
			myAuthenticationType = null;
			myUrlRewritingRules.clear();
			myRelationAliases.clear();
			myExtraData.clear();
		}

		public ATOMUpdated getUpdatedTime() {
			return myUpdatedTime;
		}

		private static final String ENTRY_ID_PREFIX = ""urn:fbreader-org-catalog:"";

		public boolean processFeedEntry(OPDSEntry entry) {
			final String id = entry.Id.Uri;
			if (id == null || id.length() <= ENTRY_ID_PREFIX.length()
					|| !id.startsWith(ENTRY_ID_PREFIX)) {
				return false;
			}
			final String siteName = id.substring(ENTRY_ID_PREFIX.length());
			final CharSequence title = entry.Title;
			final CharSequence summary = entry.Content;
			final String language = entry.DCLanguage;

			final UrlInfoCollection<UrlInfoWithDate> infos =
				new UrlInfoCollection<UrlInfoWithDate>();
			for (ATOMLink link: entry.Links) {
				final String href = link.getHref();
				final MimeType type = MimeType.get(link.getType());
				final String rel = link.getRel();
				if (rel == REL_IMAGE_THUMBNAIL || rel == REL_THUMBNAIL) {
					if (MimeType.IMAGE_PNG.equals(type) || MimeType.IMAGE_JPEG.equals(type)) {
						infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.Thumbnail, href));
					}
				} else if ((rel != null && rel.startsWith(REL_IMAGE_PREFIX)) || rel == REL_COVER) {
					if (MimeType.IMAGE_PNG.equals(type) || MimeType.IMAGE_JPEG.equals(type)) {
						infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.Image, href));
					}
				} else if (rel == null) {
					if (MimeType.APP_ATOM.equals(type)) {
						infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.Catalog, href));
					}
				} else if (rel == ""search"") {
					if (MimeType.APP_ATOM.equals(type)) {
						final OpenSearchDescription descr = OpenSearchDescription.createDefault(href);
						if (descr.isValid()) {
							// TODO: May be do not use '%s'??? Use Description instead??? (this needs to rewrite SEARCH engine logic a little)
							infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.Search, descr.makeQuery(""%s"")));
						}
					}
				} else if (rel == REL_LINK_SIGN_IN) {
					infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.SignIn, href));
				} else if (rel == REL_LINK_SIGN_OUT) {
					infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.SignOut, href));
				} else if (rel == REL_LINK_SIGN_UP) {
					infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.SignUp, href));
				} else if (rel == REL_LINK_TOPUP) {
					infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.TopUp, href));
				} else if (rel == REL_LINK_RECOVER_PASSWORD) {
					infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.RecoverPassword, href));
				}
			}

			final String sslCertificate;
			final String path = ""network/"" + siteName + "".crt"";
			if (ZLResourceFile.createResourceFile(path).exists()) {
				sslCertificate = path;
			} else {
				sslCertificate = null;
			}

			INetworkLink result = link(id, siteName, title, summary, language, infos, sslCertificate);
			if (result != null) {
				myListener.onNewLink(result);
			}
			return false; 
		}

		private INetworkLink link(
			String id,
			String siteName,
			CharSequence title,
			CharSequence summary,
			String language,
			UrlInfoCollection<UrlInfoWithDate> infos,
			String sslCertificate
		) {
			if (siteName == null || title == null || infos.getInfo(UrlInfo.Type.Catalog) == null) {
				return null;
			}

			final String titleString = title.toString();
			final String summaryString = summary != null ? summary.toString() : null;

			OPDSNetworkLink opdsLink = new OPDSPredefinedNetworkLink(
				OPDSNetworkLink.INVALID_ID,
				id,
				siteName,
				titleString,
				summaryString,
				language,
				infos
			);

			/*if (!mySearchType.empty()) {
				opdsLink.setupAdvancedSearch(
					mySearchType,
					mySearchFields[""titleOrSeries""],
					mySearchFields[""author""],
					mySearchFields[""tag""],
					mySearchFields[""annotation""]
				);
			}*/
			opdsLink.setRelationAliases(myRelationAliases);
			opdsLink.setUrlRewritingRules(myUrlRewritingRules);
			opdsLink.setExtraData(myExtraData);

			NetworkAuthenticationManager authManager = null;
			if (myAuthenticationType == ""basic"") {
				//authManager = NetworkAuthenticationManager.createManager(opdsLink, sslCertificate, BasicAuthenticationManager.class);
			} else if (myAuthenticationType == ""litres"") {
				authManager = NetworkAuthenticationManager.createManager(opdsLink, sslCertificate, LitResAuthenticationManager.class);
			}
			opdsLink.setAuthenticationManager(authManager);

			return opdsLink;
		}

		public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
			myUpdatedTime = feed.Updated;
			if (myUpdatedTime != null && myReadAfterTime != null
					&& myUpdatedTime.compareTo(myReadAfterTime) <= 0) {
				return true;
			}
			return myListener == null; // no listener -- no need to proceed
		}

		public void processFeedStart() {
			myUpdatedTime = null;
		}

		public void processFeedEnd() {
		}
	}

	public OPDSLinkXMLReader() {
		super(new FeedHandler(null, null), false);
	}

	public OPDSLinkXMLReader(NetworkLibrary.OnNewLinkListener listener, ATOMUpdated readAfter) {
		super(new FeedHandler(listener, readAfter), false);
	}

	private FeedHandler getFeedHandler() {
		return (FeedHandler)getATOMFeedHandler();
	}

	public ATOMUpdated getUpdatedTime() {
		return getFeedHandler().getUpdatedTime();
	}

	private static final String FBREADER_ADVANCED_SEARCH = ""advancedSearch"";
	private static final String FBREADER_AUTHENTICATION = ""authentication"";
	private static final String FBREADER_REWRITING_RULE = ""urlRewritingRule"";
	private static final String FBREADER_RELATION_ALIAS = ""relationAlias"";
	private static final String FBREADER_EXTRA = ""extra"";

	@Override
	public boolean startElementHandler(final String ns, final String tag,
			final ZLStringMap attributes, final String bufferContent) {
		switch (myState) {
			case FEED:
				if (ns == XMLNamespaces.Atom && tag == TAG_ENTRY) {
					getFeedHandler().clear();
				}
				break;
			case F_ENTRY:
				if (ns == XMLNamespaces.FBReaderCatalogMetadata) {
					if (tag == FBREADER_ADVANCED_SEARCH) {
						return false;
					} else if (tag == FBREADER_AUTHENTICATION) {
						final String type = attributes.getValue(""type"");
						getFeedHandler().setAuthenticationType(type);
						return false;
					} else if (tag == FBREADER_RELATION_ALIAS) {
						final String name = attributes.getValue(""name"");
						final String type = attributes.getValue(""type"");
						String alias = attributes.getValue(""alias"");
						if (alias != null && name != null) {
							if (alias.length() == 0) {
								alias = null;
							}
							getFeedHandler().addRelationAlias(new RelationAlias(alias, type), name);
						}
						return false;
					} else if (tag == FBREADER_REWRITING_RULE) {
						getFeedHandler().addUrlRewritingRule(new URLRewritingRule(attributes));
						return false;
					} else if (tag == FBREADER_EXTRA) {
						final String name = attributes.getValue(""name"");
						final String value = attributes.getValue(""value"");
						if (name != null && value != null) {
							getFeedHandler().putExtraData(name, value);
						}
					}
				}
				break;
		}
		return super.startElementHandler(ns, tag, attributes, bufferContent);
	}
}
",True,140,0,0,6,56,1,29,L6
173,org.geometerplus.fbreader.network.tree.NetworkTreeFactory.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.*;

public class NetworkTreeFactory {
	public static NetworkTree createNetworkTree(NetworkCatalogTree parent, NetworkItem item) {
		return createNetworkTree(parent, item, -1);
	}

	public static NetworkTree createNetworkTree(NetworkCatalogTree parent, NetworkItem item, int position) {
		final int subtreesSize = parent.subTrees().size();
		if (position == -1) {
			position = subtreesSize;
		} else if (position < 0 || position > subtreesSize) {
			throw new IndexOutOfBoundsException(""`position` value equals "" + position + "" but must be in range [0; "" + subtreesSize + ""]"");
		}

		if (item instanceof NetworkCatalogItem) {
			NetworkCatalogItem catalogItem = (NetworkCatalogItem) item;
			if (catalogItem.getVisibility() == ZLBoolean3.B3_FALSE) {
				return null;
			}
			NetworkCatalogTree tree = new NetworkCatalogTree(parent, catalogItem, position);
			catalogItem.onDisplayItem();
			return tree;
		} else if (item instanceof NetworkBookItem) {
			if (position != subtreesSize) {
				throw new RuntimeException(""Unable to insert NetworkBookItem to the middle of the catalog"");
			}

			final NetworkBookItem book = (NetworkBookItem)item;
			final int flags = parent.Item.getFlags();
			final boolean showAuthors = (flags & NetworkCatalogItem.FLAG_SHOW_AUTHOR) != 0;

			switch (flags & NetworkCatalogItem.FLAGS_GROUP) {
				default:
					return new NetworkBookTree(parent, book, position, showAuthors);
				case NetworkCatalogItem.FLAG_GROUP_BY_SERIES:
					if (book.SeriesTitle == null) {
						return new NetworkBookTree(parent, book, position, showAuthors);
					} else {
						final NetworkTree previous = position > 0
							? (NetworkTree)parent.subTrees().get(position - 1) : null;
						NetworkSeriesTree seriesTree = null;
						if (previous instanceof NetworkSeriesTree) {
							seriesTree = (NetworkSeriesTree)previous;
							if (!book.SeriesTitle.equals(seriesTree.SeriesTitle)) {
								seriesTree = null;
							}
						}
						if (seriesTree == null) {
							seriesTree = new NetworkSeriesTree(
								parent, book.SeriesTitle, position, showAuthors
							);
						}
						return new NetworkBookTree(seriesTree, book, showAuthors);
					}
				case NetworkCatalogItem.FLAG_GROUP_MORE_THAN_1_BOOK_BY_SERIES:
					if (position > 0 && book.SeriesTitle != null) {
						final NetworkTree previous =
							(NetworkTree)parent.subTrees().get(position - 1);
						if (previous instanceof NetworkSeriesTree) {
							final NetworkSeriesTree seriesTree = (NetworkSeriesTree)previous;
							if (book.SeriesTitle.equals(seriesTree.SeriesTitle)) {
								return new NetworkBookTree(seriesTree, book, showAuthors);
							}
						} else /* if (previous instanceof NetworkBookTree) */ {
							final NetworkBookItem previousBook = ((NetworkBookTree)previous).Book;
							if (book.SeriesTitle.equals(previousBook.SeriesTitle)) {
								previous.removeSelf();
								final NetworkSeriesTree seriesTree = new NetworkSeriesTree(
									parent, book.SeriesTitle, position - 1, showAuthors
								);
								new NetworkBookTree(seriesTree, previousBook, showAuthors);
								return new NetworkBookTree(seriesTree, book, showAuthors);
							}
						}
					}
					return new NetworkBookTree(parent, book, position, showAuthors);
				case NetworkCatalogItem.FLAG_GROUP_BY_AUTHOR:
					if (book.Authors.isEmpty()) {
						return new NetworkBookTree(parent, book, position, showAuthors);
					} else {
						final NetworkBookItem.AuthorData author = book.Authors.get(0);
						final NetworkTree previous = position > 0
							? (NetworkTree)parent.subTrees().get(position - 1) : null;
						NetworkAuthorTree authorTree = null;
						if (previous instanceof NetworkAuthorTree) {
							authorTree = (NetworkAuthorTree)previous;
							if (!author.equals(authorTree.Author)) {
								authorTree = null;
							}
						}
						if (authorTree == null) {
							authorTree = new NetworkAuthorTree(parent, author);
						}
						return new NetworkBookTree(authorTree, book, showAuthors);
					}
			}
		} else if (item instanceof TopUpItem) {
			return new TopUpTree(parent, (TopUpItem)item);
		}
		return null;
	}
}
",False,194,7,26,10,32,2,12,L6
174,org.geometerplus.fbreader.network.tree.NetworkCatalogRootTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.fbreader.network.*;

public class NetworkCatalogRootTree extends NetworkCatalogTree {
	public NetworkCatalogRootTree(RootTree parent, INetworkLink link, int position) {
		super(parent, (NetworkCatalogItem)link.libraryItem(), position);
	}
}
",False,194,7,26,10,34,2,4,L6
175,org.geometerplus.fbreader.network.tree.AddCustomCatalogItemTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.NetworkItem;
import org.geometerplus.fbreader.network.NetworkTree;

public class AddCustomCatalogItemTree extends NetworkTree {
	public AddCustomCatalogItemTree(NetworkTree parent) {
		super(parent);
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""addCustomCatalog"").getValue();
	}

	@Override
	public String getSummary() {
		return ZLResource.resource(""networkView"").getResource(""addCustomCatalogSummary"").getValue();
	}

	@Override
	public NetworkItem getHoldedItem() {
		return null;
	}

	@Override
	protected String getStringId() {
		return ""@Add Custom Catalog"";
	}
}
",False,194,6,26,11,32,3,3,L6
176,org.geometerplus.fbreader.network.tree.NetworkBookTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.network.*;


public class NetworkBookTree extends NetworkTree {

	public final NetworkBookItem Book;

	private final boolean myShowAuthors;

	NetworkBookTree(NetworkTree parent, NetworkBookItem book, boolean showAuthors) {
		super(parent);
		Book = book;
		myShowAuthors = showAuthors;
	}

	NetworkBookTree(NetworkTree parent, NetworkBookItem book, int position, boolean showAuthors) {
		super(parent, position);
		Book = book;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return Book.Title.toString();
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors && Book.Authors.size() < 2) {
			return null;
		}
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (NetworkBookItem.AuthorData author: Book.Authors) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(author.DisplayName);
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		return createCover(Book);
	}

	@Override
	public NetworkItem getHoldedItem() {
		return Book;
	}

	@Override
	protected String getStringId() {
		return ""@Book:"" + Book.Id + "":"" + Book.Title;
	}
}
",False,194,6,26,10,33,7,4,L6
177,org.geometerplus.fbreader.network.tree.SearchItemTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.Set;
import java.util.LinkedList;
import java.util.ListIterator;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkAuthorTree;

public class SearchItemTree extends NetworkTree {
	private SearchResult myResult;

	public SearchItemTree(NetworkTree parent, int position) {
		super(parent, position);
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""search"").getValue();
	}

	@Override
	public String getSummary() {
		return ZLResource.resource(""networkView"").getResource(""searchSummary"").getValue();
	}

	public void setSearchResult(SearchResult result) {
		myResult = result;
		clear();
	}

	public SearchResult getSearchResult() {
		return myResult;
	}

	public void updateSubTrees() {
		ListIterator<FBTree> nodeIterator = subTrees().listIterator();

		final Set<NetworkBookItem.AuthorData> authorsSet = myResult.BooksMap.keySet();

		for (NetworkBookItem.AuthorData author: authorsSet) {
			if (nodeIterator != null) {
				if (nodeIterator.hasNext()) {
					FBTree currentNode = nodeIterator.next();
					if (!(currentNode instanceof NetworkAuthorTree)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					NetworkAuthorTree child = (NetworkAuthorTree)currentNode;
					if (!child.Author.equals(author)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					LinkedList<NetworkBookItem> authorBooks = myResult.BooksMap.get(author);
					child.updateSubTrees(authorBooks);
					continue;
				}
				nodeIterator = null;
			}

			LinkedList<NetworkBookItem> authorBooks = myResult.BooksMap.get(author);
			if (authorBooks.size() != 0) {
				NetworkAuthorTree child = new NetworkAuthorTree(this, author);
				child.updateSubTrees(authorBooks);
			}
		}
		if (nodeIterator != null && nodeIterator.hasNext()) {
			throw new RuntimeException(""That's impossible!!!"");
		}
	}

	@Override
	public NetworkItem getHoldedItem() {
		return null;
	}

	@Override
	protected String getStringId() {
		return ""@Search"";
	}
}
",False,194,6,26,10,30,4,8,L6
178,org.geometerplus.fbreader.network.tree.NetworkCatalogTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;

public class NetworkCatalogTree extends NetworkTree {
	public final NetworkCatalogItem Item;
	public final ArrayList<NetworkItem> ChildrenItems = new ArrayList<NetworkItem>();

	private long myLoadedTime = -1;

	public NetworkCatalogTree(RootTree parent, NetworkCatalogItem item, int position) {
		super(parent, position);
		Item = item;
	}

	NetworkCatalogTree(NetworkCatalogTree parent, NetworkCatalogItem item, int position) {
		super(parent, position);
		Item = item;
	}

	@Override
	public String getName() {
		return Item.Title.toString();
	}

	@Override
	public String getSummary() {
		final CharSequence summary = Item.getSummary();
		return summary != null ? summary.toString() : """";
	}

	@Override
	protected ZLImage createCover() {
		return createCover(Item);
	}

	public boolean isContentValid() {
		if (myLoadedTime < 0) {
			return false;
		}
		final int reloadTime = 15 * 60 * 1000; // 15 minutes in milliseconds
		return System.currentTimeMillis() - myLoadedTime < reloadTime;
	}

	public void updateLoadedTime() {
		myLoadedTime = System.currentTimeMillis();
		FBTree tree = Parent;
		while (tree instanceof NetworkCatalogTree) {
			((NetworkCatalogTree) tree).myLoadedTime = myLoadedTime;
			tree = tree.Parent;
		}
	}

	public void updateVisibility() {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();

		ListIterator<FBTree> nodeIterator = subTrees().listIterator();
		FBTree currentNode = null;
		int nodeCount = 0;

		for (int i = 0; i < ChildrenItems.size(); ++i) {
			NetworkItem currentItem = ChildrenItems.get(i);
			if (!(currentItem instanceof NetworkCatalogItem)) {
				continue;
			}
			boolean processed = false;
			while (currentNode != null || nodeIterator.hasNext()) {
				if (currentNode == null) {
					currentNode = nodeIterator.next();
				}
				if (!(currentNode instanceof NetworkCatalogTree)) {
					currentNode = null;
					++nodeCount;
					continue;
				}
				NetworkCatalogTree child = (NetworkCatalogTree) currentNode;
				if (child.Item == currentItem) {
					switch (child.Item.getVisibility()) {
						case B3_TRUE:
							child.updateVisibility();
							break;
						case B3_FALSE:
							toRemove.add(child);
							break;
						case B3_UNDEFINED:
							child.clear();
							child.ChildrenItems.clear();
							break;
					}
					currentNode = null;
					++nodeCount;
					processed = true;
					break;
				} else {
					boolean found = false;
					for (int j = i + 1; j < ChildrenItems.size(); ++j) {
						if (child.Item == ChildrenItems.get(j)) {
							found = true;
							break;
						}
					}
					if (!found) {
						toRemove.add(currentNode);
						currentNode = null;
						++nodeCount;
					} else {
						break;
					}
				}
			}
			final int nextIndex = nodeIterator.nextIndex();
			if (!processed && NetworkTreeFactory.createNetworkTree(this, currentItem, nodeCount) != null) {
				++nodeCount;
				nodeIterator = subTrees().listIterator(nextIndex + 1);
			}
		}

		while (currentNode != null || nodeIterator.hasNext()) {
			if (currentNode == null) {
				currentNode = nodeIterator.next();
			}
			if (currentNode instanceof NetworkCatalogTree) {
				toRemove.add(currentNode);
			}
			currentNode = null;
		}

		for (FBTree tree: toRemove) {
			tree.removeSelf();
		}
	}

	@Override
	public NetworkItem getHoldedItem() {
		return Item;
	}

	@Override
	public void removeItems(Set<NetworkItem> items) {
		ChildrenItems.removeAll(items);
		super.removeItems(items);
	}

	@Override
	protected String getStringId() {
		return Item.getStringId();
	}
}
",False,194,6,26,10,32,7,9,L6
179,org.geometerplus.fbreader.network.tree.RootTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.fbreader.network.NetworkItem;
import org.geometerplus.fbreader.network.NetworkTree;

public final class RootTree extends NetworkTree {
	private final String myId;

	public RootTree(String id) {
		myId = id;
	}

	@Override
	public String getName() {
		return null;
	}

	@Override
	public NetworkItem getHoldedItem() {
		return null;
	}

	@Override
	protected String getStringId() {
		return myId;
	}
}
",False,140,0,0,11,33,3,2,L6
180,org.geometerplus.fbreader.network.tree.NetworkSeriesTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;


public class NetworkSeriesTree extends NetworkTree {

	public final String SeriesTitle;

	private final boolean myShowAuthors;

	NetworkSeriesTree(NetworkTree parent, String seriesTitle, int position, boolean showAuthors) {
		super(parent, position);
		SeriesTitle = seriesTitle;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return SeriesTitle;
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors) {
			return super.getSummary();
		}

		StringBuilder builder = new StringBuilder();
		int count = 0;

		Set<NetworkBookItem.AuthorData> authorSet = new TreeSet<NetworkBookItem.AuthorData>();
		for (FBTree tree: subTrees()) {
			if (!(tree instanceof NetworkBookTree)) {
				continue;
			}
			final NetworkBookItem book = ((NetworkBookTree) tree).Book;

			for (NetworkBookItem.AuthorData author: book.Authors) {
				if (!authorSet.contains(author)) {
					authorSet.add(author);
					if (count++ > 0) {
						builder.append("",  "");
					}
					builder.append(author.DisplayName);
					if (count == 5) {
						return builder.toString();
					}
				}
			}
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		for (FBTree tree: subTrees()) {
			if (tree instanceof NetworkBookTree) {
				return ((NetworkBookTree) tree).createCover();
			}
		}
		return null;
	}

	@Override
	public NetworkItem getHoldedItem() {
		return null;
	}

	@Override
	public void removeItems(Set<NetworkItem> items) {
		super.removeItems(items);
		if (subTrees().isEmpty()) {
			removeSelf();
		}
	}

	@Override
	protected String getStringId() {
		return ""@Series:"" + SeriesTitle;
	}
}
",False,194,7,26,10,33,4,7,L6
181,org.geometerplus.fbreader.network.tree.NetworkAuthorTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;


public class NetworkAuthorTree extends NetworkTree {

	public final NetworkBookItem.AuthorData Author;

	private int myBooksNumber;
	private HashMap<String, Integer> mySeriesMap;

	NetworkAuthorTree(NetworkTree parent, NetworkBookItem.AuthorData author) {
		super(parent);
		Author = author;
	}

	@Override
	public String getName() {
		return Author.DisplayName;
	}

	@Override
	protected String getSortKey() {
		return Author.SortKey;
	}

	private int getSeriesIndex(String seriesName) {
		if (mySeriesMap == null) {
			return -1;
		}
		Integer value = mySeriesMap.get(seriesName);
		if (value == null) {
			return -1;
		}
		return value.intValue();
	}

	private void setSeriesIndex(String seriesName, int index) {
		if (mySeriesMap == null) {
			mySeriesMap = new HashMap<String, Integer>();
		}
		mySeriesMap.put(seriesName, Integer.valueOf(index));
	}

	public void updateSubTrees(LinkedList<NetworkBookItem> books) {
		if (myBooksNumber >= books.size()) {
			return;
		}
		invalidateChildren(); // call to update secondString

		ListIterator<NetworkBookItem> booksIterator = books.listIterator(myBooksNumber);
		while (booksIterator.hasNext()) {
			NetworkBookItem book = booksIterator.next();

			if (book.SeriesTitle != null) {
				final int seriesPosition = getSeriesIndex(book.SeriesTitle);
				if (seriesPosition == -1) {
					final int insertAt = subTrees().size();
					setSeriesIndex(book.SeriesTitle, insertAt);
					new NetworkBookTree(this, book, false);
				} else {
					FBTree treeAtSeriesPosition = subTrees().get(seriesPosition);
					if (treeAtSeriesPosition instanceof NetworkBookTree) {
						final NetworkBookTree bookTree = (NetworkBookTree) treeAtSeriesPosition;
						bookTree.removeSelf();
						final NetworkSeriesTree seriesTree = new NetworkSeriesTree(this, book.SeriesTitle, seriesPosition, false);
						new NetworkBookTree(seriesTree, bookTree.Book, false);
						treeAtSeriesPosition = seriesTree;
					}

					if (!(treeAtSeriesPosition instanceof NetworkSeriesTree)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					final NetworkSeriesTree seriesTree = (NetworkSeriesTree) treeAtSeriesPosition;
					ListIterator<FBTree> nodesIterator = seriesTree.subTrees().listIterator();
					int insertAt = 0;
					while (nodesIterator.hasNext()) {
						FBTree tree = nodesIterator.next();
						if (!(tree instanceof NetworkBookTree)) {
							throw new RuntimeException(""That's impossible!!!"");
						}
						NetworkBookTree bookTree = (NetworkBookTree) tree;
						if (bookTree.Book.IndexInSeries > book.IndexInSeries) {
							break;
						}
						++insertAt;
					}
					seriesTree.invalidateChildren(); // call to update secondString
					new NetworkBookTree(seriesTree, book, insertAt, false);
				}
			} else {
				new NetworkBookTree(this, book, false);
			}
		}

		myBooksNumber = books.size();
	}

	@Override
	public NetworkItem getHoldedItem() {
		return null;
	}

	@Override
	protected String getStringId() {
		return ""@Author:"" + Author.DisplayName + "":"" + Author.SortKey;
	}
}
",False,194,7,26,10,33,4,7,L6
182,org.geometerplus.fbreader.network.tree.TopUpTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.TopUpItem;
import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

public class TopUpTree extends NetworkTree {
	public final TopUpItem Item;

	TopUpTree(NetworkCatalogTree parentTree, TopUpItem item) {
		super(parentTree);
		Item = item;
	}

	@Override
	public String getName() {
		return Item.Title.toString();
	}

	@Override
	public String getSummary() {
		final NetworkAuthenticationManager mgr = Item.Link.authenticationManager();
		try {
			if (mgr != null && mgr.isAuthorised(false)) {
				final String account = mgr.currentAccount();
				final CharSequence summary = Item.getSummary();
				if (account != null && summary != null) {
					return summary.toString().replace(""%s"", account);
				}
			}
		} catch (ZLNetworkException e) {
		}
		return null;
	}

	@Override
	protected ZLImage createCover() {
		return createCover(Item);
	}

	@Override
	public TopUpItem getHoldedItem() {
		return Item;
	}

	@Override
	protected String getStringId() {
		return ""@TopUp Account"";
	}
}
",True,194,7,26,9,34,3,8,L6
183,org.geometerplus.fbreader.tree.FBTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.tree.ZLTree;
import org.geometerplus.zlibrary.core.image.ZLImage;

public abstract class FBTree extends ZLTree<FBTree> implements Comparable<FBTree> {

	private ZLImage myCover;
	private boolean myCoverRequested;

	protected FBTree() {
		super();
	}

	protected FBTree(FBTree parent) {
		super(parent);
	}

	protected FBTree(FBTree parent, int position) {
		super(parent, position);
	}

	public abstract String getName();

	public final FBTree getSubTreeByName(String name) {
		if (name == null) {
			return null;
		}
		for (FBTree t : subTrees()) {
			if (name.equals(t.getName())) {
				return t;
			}
		}
		return null;
	}

	protected String getSortKey() {
		return getName();
	}

	public int compareTo(FBTree ct) {
		final String key0 = getSortKey();
		final String key1 = ct.getSortKey();
		if (key0 == null) {
			return (key1 == null) ? 0 : -1;
		}
		if (key1 == null) {
			return 1;
		}
		return key0.toLowerCase().compareTo(key1.toLowerCase());
	}

	public final void sortAllChildren() {
		List<FBTree> children = subTrees();
		if (!children.isEmpty()) {
			Collections.sort(children);
			for (FBTree tree : children) {
				tree.sortAllChildren();
			}
		}
	}

	private String mySecondString;

	public final void invalidateChildren() {
		mySecondString = null;
	}

	public final String getSecondString() {
		if (mySecondString == null) {
			mySecondString = getSummary();
			if (mySecondString == null) {
				mySecondString = """";
			}
		}
		return mySecondString;
	}

	protected String getSummary() {
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (FBTree subtree : subTrees()) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(subtree.getName());
			if (count == 5) {
				break;
			}
		}
		return builder.toString();
	}

	protected ZLImage createCover() {
		return null;
	}

	public final ZLImage getCover() {
		if (!myCoverRequested) {
			myCover = createCover();
			if (myCover == null && Parent != null) {
				myCover = Parent.getCover();
			}
			myCoverRequested = true;
		}
		return myCover;
	}
}
",False,132,8,46,1,2,19,2,L5
184,org.geometerplus.android.fbreader.SelectionCopyAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.Application;
import android.text.ClipboardManager;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

import org.geometerplus.android.util.UIUtil;

public class SelectionCopyAction extends FBAndroidAction {
	SelectionCopyAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public void run() {
		final String text = Reader.getTextView().getSelectedText();
		Reader.getTextView().clearSelection();

		final ClipboardManager clipboard =
			(ClipboardManager)ZLAndroidApplication.Instance().getSystemService(Application.CLIPBOARD_SERVICE);
		clipboard.setText(text);
		UIUtil.showMessageText(
			BaseActivity,
			ZLResource.resource(""selection"").getResource(""textInBuffer"").getValue().replace(""%s"", clipboard.getText())
		);
	}
}
",False,421,0,0,8,105,1,9,L6
185,org.geometerplus.android.fbreader.SelectionTranslateAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.fbreader.FBView;

public class SelectionTranslateAction extends FBAndroidAction {
    SelectionTranslateAction(FBReader baseActivity, FBReaderApp fbreader) {
        super(baseActivity, fbreader);
    }

    public void run() {
        final FBView fbview = Reader.getTextView();
        DictionaryUtil.openTextInDictionary(
			BaseActivity,
        	fbview.getSelectedText(),
			fbview.getCountOfSelectedWords() == 1,
        	fbview.getSelectionStartY(),
			fbview.getSelectionEndY()
		);
        fbview.clearSelection();
    }
}
",False,421,0,0,8,106,1,7,L6
186,org.geometerplus.android.fbreader.NavigationPopup.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.view.View;
import android.widget.Button;
import android.widget.RelativeLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.text.view.ZLTextView;
import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

final class NavigationPopup extends PopupPanel {
	final static String ID = ""NavigationPopup"";

	private volatile boolean myIsInProgress;

	NavigationPopup(FBReaderApp fbReader) {
		super(fbReader);
	}

	public void runNavigation() {
		if (myWindow.getVisibility() == View.GONE) {
			myIsInProgress = false;
			initPosition();
			Application.showPopup(ID);
		}
	}

	@Override
	public String getId() {
		return ID;
	}

	@Override
	protected void show_() {
		super.show_();
		if (myWindow != null) {
			setupNavigation(myWindow);
		}
	}

	@Override
	protected void update() {
		if (!myIsInProgress && myWindow != null) {
			setupNavigation(myWindow);
		}
	}

	@Override
	public void createControlPanel(FBReader activity, RelativeLayout root, PopupWindow.Location location) {
		if (myWindow != null) {
			return;
		}

		myWindow = new PopupWindow(activity, root, location, true);

		final View layout = activity.getLayoutInflater().inflate(R.layout.navigate, myWindow, false);

		final SeekBar slider = (SeekBar)layout.findViewById(R.id.book_position_slider);
		final TextView text = (TextView)layout.findViewById(R.id.book_position_text);

		slider.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			private void gotoPage(int page) {
				final ZLTextView view = getReader().getTextView();
				if (page == 1) {
					view.gotoHome();
				} else {
					view.gotoPage(page);
				}
				getReader().getViewWidget().reset();
				getReader().getViewWidget().repaint();
			}

			public void onStopTrackingTouch(SeekBar seekBar) {
				myIsInProgress = false;
			}

			public void onStartTrackingTouch(SeekBar seekBar) {
				myIsInProgress = true;
			}

			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				if (fromUser) {
					final int page = progress + 1;
					final int pagesNumber = seekBar.getMax() + 1;
					text.setText(makeProgressText(page, pagesNumber));
					gotoPage(page);
				}
			}
		});

		final Button btnOk = (Button)layout.findViewById(android.R.id.button1);
		final Button btnCancel = (Button)layout.findViewById(android.R.id.button3);
		View.OnClickListener listener = new View.OnClickListener() {
			public void onClick(View v) {
				final ZLTextWordCursor position = StartPosition;
				if (v == btnCancel && position != null) {
					getReader().getTextView().gotoPosition(position);
				} else if (v == btnOk) {
					storePosition();
				}
				StartPosition = null;
				Application.hideActivePopup();
				getReader().getViewWidget().reset();
				getReader().getViewWidget().repaint();
			}
		};
		btnOk.setOnClickListener(listener);
		btnCancel.setOnClickListener(listener);
		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		btnOk.setText(buttonResource.getResource(""ok"").getValue());
		btnCancel.setText(buttonResource.getResource(""cancel"").getValue());

		myWindow.addView(layout);
	}

	private void setupNavigation(PopupWindow panel) {
		final SeekBar slider = (SeekBar)panel.findViewById(R.id.book_position_slider);
		final TextView text = (TextView)panel.findViewById(R.id.book_position_text);

		final ZLTextView textView = getReader().getTextView();
		final int page = textView.computeCurrentPage();
		final int pagesNumber = textView.computePageNumber();

		if (slider.getMax() != pagesNumber - 1 || slider.getProgress() != page - 1) {
			slider.setMax(pagesNumber - 1);
			slider.setProgress(page - 1);
			text.setText(makeProgressText(page, pagesNumber));
		}
	}

	private static String makeProgressText(int page, int pagesNumber) {
		return page + "" / "" + pagesNumber;
	}
}
",False,421,0,0,8,88,1,9,L6
187,org.geometerplus.android.fbreader.RunActivityAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

abstract class RunActivityAction extends FBAndroidAction {
	private final Class<?> myActivityClass;

	RunActivityAction(FBReader baseActivity, FBReaderApp fbreader, Class<?> activityClass) {
		super(baseActivity, fbreader);
		myActivityClass = activityClass;
	}

	public void run() {
		BaseActivity.startActivity(new Intent(BaseActivity.getApplicationContext(), myActivityClass));
	}
}
",False,421,0,0,8,95,3,3,L6
188,org.geometerplus.android.fbreader.PackageInfo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

public class PackageInfo {
	public final String Id;
	public final String PackageName;
	public final String ClassName;
	public final String Title;

	public final String IntentAction;
	public final String IntentKey;
	public final String IntentDataPattern;

	PackageInfo(String id, String packageName, String className, String title, String intentAction, String intentKey, String intentDataPattern) {
		Id = id;
		PackageName = packageName;
		ClassName = className;
		Title = title;

		IntentAction = intentAction;
		IntentKey = intentKey;
		IntentDataPattern = intentDataPattern;
	}
}
",False,58,7,25,0,0,2,0,L6
189,org.geometerplus.android.fbreader.RunPluginAction.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;
import android.content.ActivityNotFoundException;
import android.net.Uri;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class RunPluginAction extends FBAndroidAction {
	private final Uri myUri;

	RunPluginAction(FBReader baseActivity, FBReaderApp fbreader, Uri uri) {
		super(baseActivity, fbreader);
		myUri = uri;
	}

	public void run() {
		try {
			BaseActivity.startActivity(new Intent(""android.fbreader.action.plugin.RUN"", myUri));
		} catch (ActivityNotFoundException e) {
		}
	}
}
",True,421,0,0,8,96,1,3,L6
190,org.geometerplus.android.fbreader.SelectionPopup.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.view.View;
import android.widget.RelativeLayout;

import org.geometerplus.fbreader.fbreader.ActionCode;
import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.zlibrary.ui.android.R;

class SelectionPopup extends ButtonsPopupPanel {
	final static String ID = ""SelectionPopup"";

	SelectionPopup(FBReaderApp fbReader) {
		super(fbReader);
	}

	@Override
	public String getId() {
		return ID;
	}

	@Override
	public void createControlPanel(FBReader activity, RelativeLayout root, PopupWindow.Location location) {
		if (myWindow != null) {
			return;
		}

		myWindow = new PopupWindow(activity, root, location, false);

        addButton(ActionCode.SELECTION_COPY_TO_CLIPBOARD, true, R.drawable.selection_copy);
        addButton(ActionCode.SELECTION_SHARE, true, R.drawable.selection_share);
        addButton(ActionCode.SELECTION_TRANSLATE, true, R.drawable.selection_translate);
        addButton(ActionCode.SELECTION_BOOKMARK, true, R.drawable.selection_bookmark);
        addButton(ActionCode.SELECTION_CLEAR, true, R.drawable.selection_close);
    }
    
    public void move(int selectionStartY, int selectionEndY) {
		if (myWindow == null) {
			return;
		}

        RelativeLayout.LayoutParams layoutParams = new RelativeLayout.LayoutParams(
			RelativeLayout.LayoutParams.WRAP_CONTENT,
            RelativeLayout.LayoutParams.WRAP_CONTENT
		);
        layoutParams.addRule(RelativeLayout.CENTER_HORIZONTAL);

        final int verticalPosition; 
        final int screenHeight = ((View)myWindow.getParent()).getHeight();
		final int diffTop = screenHeight - selectionEndY;
		final int diffBottom = selectionStartY;
		if (diffTop > diffBottom) {
			verticalPosition = diffTop > myWindow.getHeight() + 20
				? RelativeLayout.ALIGN_PARENT_BOTTOM : RelativeLayout.CENTER_VERTICAL;
		} else {
			verticalPosition = diffBottom > myWindow.getHeight() + 20
				? RelativeLayout.ALIGN_PARENT_TOP : RelativeLayout.CENTER_VERTICAL;
		}

        layoutParams.addRule(verticalPosition);
        myWindow.setLayoutParams(layoutParams);
    }
}
",False,421,0,0,8,97,1,6,L6
191,org.geometerplus.android.fbreader.FBReader.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.app.SearchManager;
import android.content.*;
import android.net.Uri;
import android.os.Bundle;
import android.view.Menu;
import android.view.WindowManager;
import android.widget.RelativeLayout;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.zlibrary.text.view.ZLTextView;
import org.geometerplus.zlibrary.text.hyphenation.ZLTextHyphenator;

import org.geometerplus.zlibrary.ui.android.R;
import org.geometerplus.zlibrary.ui.android.library.ZLAndroidActivity;
import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.fbreader.ActionCode;
import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;

import org.geometerplus.android.fbreader.library.KillerCallback;
import org.geometerplus.android.fbreader.api.PluginApi;

import org.geometerplus.android.util.UIUtil;

public final class FBReader extends ZLAndroidActivity {
	public static final String BOOK_PATH_KEY = ""BookPath"";

	final static int REPAINT_CODE = 1;
	final static int CANCEL_CODE = 2;

	private int myFullScreenFlag;

	private static final String PLUGIN_ACTION_PREFIX = ""___"";
	private final List<PluginApi.ActionInfo> myPluginActions =
		new LinkedList<PluginApi.ActionInfo>();
	private final BroadcastReceiver myPluginInfoReceiver = new BroadcastReceiver() {
		@Override
		public void onReceive(Context context, Intent intent) {
			final ArrayList<PluginApi.ActionInfo> actions = getResultExtras(true).<PluginApi.ActionInfo>getParcelableArrayList(PluginApi.PluginInfo.KEY);
			if (actions != null) {
				synchronized (myPluginActions) {
					final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
					int index = 0;
					for (PluginApi.ActionInfo info : myPluginActions) {
						fbReader.removeAction(PLUGIN_ACTION_PREFIX + index++);
					}
					myPluginActions.addAll(actions);
					index = 0;
					for (PluginApi.ActionInfo info : myPluginActions) {
						fbReader.addAction(
							PLUGIN_ACTION_PREFIX + index++,
							new RunPluginAction(FBReader.this, fbReader, info.getId())
						);
					}
				}
			}
		}
	};

	@Override
	protected ZLFile fileFromIntent(Intent intent) {
		String filePath = intent.getStringExtra(BOOK_PATH_KEY);
		if (filePath == null) {
			final Uri data = intent.getData();
			if (data != null) {
				filePath = data.getPath();
			}
		}
		return filePath != null ? ZLFile.createFileByPath(filePath) : null;
	}

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();
		myFullScreenFlag =
			application.ShowStatusBarOption.getValue() ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN;
		getWindow().setFlags(
			WindowManager.LayoutParams.FLAG_FULLSCREEN, myFullScreenFlag
		);

		final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
		if (fbReader.getPopupById(TextSearchPopup.ID) == null) {
			new TextSearchPopup(fbReader);
		}
		if (fbReader.getPopupById(NavigationPopup.ID) == null) {
			new NavigationPopup(fbReader);
		}
		if (fbReader.getPopupById(SelectionPopup.ID) == null) {
			new SelectionPopup(fbReader);
		}

		fbReader.addAction(ActionCode.SHOW_LIBRARY, new ShowLibraryAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_PREFERENCES, new ShowPreferencesAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_BOOK_INFO, new ShowBookInfoAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_TOC, new ShowTOCAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_BOOKMARKS, new ShowBookmarksAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_NETWORK_LIBRARY, new ShowNetworkLibraryAction(this, fbReader));
		
		fbReader.addAction(ActionCode.SHOW_MENU, new ShowMenuAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_NAVIGATION, new ShowNavigationAction(this, fbReader));
		fbReader.addAction(ActionCode.SEARCH, new SearchAction(this, fbReader));

		fbReader.addAction(ActionCode.SELECTION_SHOW_PANEL, new SelectionShowPanelAction(this, fbReader));
		fbReader.addAction(ActionCode.SELECTION_HIDE_PANEL, new SelectionHidePanelAction(this, fbReader));
		fbReader.addAction(ActionCode.SELECTION_COPY_TO_CLIPBOARD, new SelectionCopyAction(this, fbReader));
		fbReader.addAction(ActionCode.SELECTION_SHARE, new SelectionShareAction(this, fbReader));
		fbReader.addAction(ActionCode.SELECTION_TRANSLATE, new SelectionTranslateAction(this, fbReader));
		fbReader.addAction(ActionCode.SELECTION_BOOKMARK, new SelectionBookmarkAction(this, fbReader));

		fbReader.addAction(ActionCode.PROCESS_HYPERLINK, new ProcessHyperlinkAction(this, fbReader));

		fbReader.addAction(ActionCode.SHOW_CANCEL_MENU, new ShowCancelMenuAction(this, fbReader));
	}

 	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();
		if (!application.ShowStatusBarOption.getValue() &&
			application.ShowStatusBarWhenMenuIsActiveOption.getValue()) {
			getWindow().addFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
		}
		return super.onPrepareOptionsMenu(menu);
	}

	@Override
	public void onOptionsMenuClosed(Menu menu) {
		super.onOptionsMenuClosed(menu);
		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();
		if (!application.ShowStatusBarOption.getValue() &&
			application.ShowStatusBarWhenMenuIsActiveOption.getValue()) {
			getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
		}
	}

	@Override
	protected void onNewIntent(Intent intent) {
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			final String pattern = intent.getStringExtra(SearchManager.QUERY);
			final Runnable runnable = new Runnable() {
				public void run() {
					final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
					final TextSearchPopup popup = (TextSearchPopup)fbReader.getPopupById(TextSearchPopup.ID);
					popup.initPosition();
					fbReader.TextSearchPatternOption.setValue(pattern);
					if (fbReader.getTextView().search(pattern, true, false, false, false) != 0) {
						runOnUiThread(new Runnable() {
							public void run() {
								fbReader.showPopup(popup.getId());
							}
						});
					} else {
						runOnUiThread(new Runnable() {
							public void run() {
								UIUtil.showErrorMessage(FBReader.this, ""textNotFound"");
								popup.StartPosition = null;
							}
						});
					}
				}
			};
			UIUtil.wait(""search"", runnable, this);
			startActivity(new Intent(this, getClass()));
		} else {
			super.onNewIntent(intent);
		}
	}

	@Override
	public void onStart() {
		super.onStart();
		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();

		final int fullScreenFlag =
			application.ShowStatusBarOption.getValue() ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN;
		if (fullScreenFlag != myFullScreenFlag) {
			finish();
			startActivity(new Intent(this, this.getClass()));
		}

		final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
		final RelativeLayout root = (RelativeLayout)findViewById(R.id.root_view);
		((PopupPanel)fbReader.getPopupById(TextSearchPopup.ID)).createControlPanel(this, root, PopupWindow.Location.Bottom);
		((PopupPanel)fbReader.getPopupById(NavigationPopup.ID)).createControlPanel(this, root, PopupWindow.Location.Bottom);
		((PopupPanel)fbReader.getPopupById(SelectionPopup.ID)).createControlPanel(this, root, PopupWindow.Location.Floating);

		synchronized (myPluginActions) {
			myPluginActions.clear();
		}

		sendOrderedBroadcast(
			new Intent(PluginApi.ACTION_REGISTER),
			null,
			myPluginInfoReceiver,
			null,
			RESULT_OK,
			null,
			null
		);
	}

	@Override
	public void onResume() {
		super.onResume();
		try {
			sendBroadcast(new Intent(getApplicationContext(), KillerCallback.class));
		} catch (Throwable t) {
		}
		PopupPanel.restoreVisibilities(FBReaderApp.Instance());
	}

	@Override
	public void onStop() {
		PopupPanel.removeAllWindows(FBReaderApp.Instance());
		super.onStop();
	}

	@Override
	protected FBReaderApp createApplication(ZLFile file) {
		if (SQLiteBooksDatabase.Instance() == null) {
			new SQLiteBooksDatabase(this, ""READER"");
		}
		return new FBReaderApp(file != null ? file.getPath() : null);
	}

	@Override
	public boolean onSearchRequested() {
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		final FBReaderApp.PopupPanel popup = fbreader.getActivePopup();
		fbreader.hideActivePopup();
		final SearchManager manager = (SearchManager)getSystemService(SEARCH_SERVICE);
		manager.setOnCancelListener(new SearchManager.OnCancelListener() {
			public void onCancel() {
				if (popup != null) {
					fbreader.showPopup(popup.getId());
				}
				manager.setOnCancelListener(null);
			}
		});
		startSearch(fbreader.TextSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	public void showSelectionPanel() {
		final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
		final ZLTextView view = fbReader.getTextView();
		((SelectionPopup)fbReader.getPopupById(SelectionPopup.ID))
			.move(view.getSelectionStartY(), view.getSelectionEndY());
		fbReader.showPopup(SelectionPopup.ID);
	}

	public void hideSelectionPanel() {
		final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
		final FBReaderApp.PopupPanel popup = fbReader.getActivePopup();
		if (popup != null && popup.getId() == SelectionPopup.ID) {
			FBReaderApp.Instance().hideActivePopup();
		}
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		switch (requestCode) {
			case REPAINT_CODE:
			{
				final BookModel model = fbreader.Model;
				if (model != null) {
					final Book book = model.Book;
					if (book != null) {
						book.reloadInfoFromDatabase();
						ZLTextHyphenator.Instance().load(book.getLanguage());
					}
				}
				fbreader.clearTextCaches();
				fbreader.getViewWidget().repaint();
				break;
			}
			case CANCEL_CODE:
				fbreader.runCancelAction(resultCode - 1);
				break;
		}
	}

	public void navigate() {
		((NavigationPopup)FBReaderApp.Instance().getPopupById(NavigationPopup.ID)).runNavigation();
	}

	private void addMenuItem(Menu menu, String actionId, String name) {
		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();
		application.myMainWindow.addMenuItem(menu, actionId, null, name);
	}

	private void addMenuItem(Menu menu, String actionId, int iconId) {
		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();
		application.myMainWindow.addMenuItem(menu, actionId, iconId, null);
	}

	private void addMenuItem(Menu menu, String actionId) {
		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();
		application.myMainWindow.addMenuItem(menu, actionId, null, null);
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		addMenuItem(menu, ActionCode.SHOW_LIBRARY, R.drawable.ic_menu_library);
		addMenuItem(menu, ActionCode.SHOW_NETWORK_LIBRARY, R.drawable.ic_menu_networklibrary);
		addMenuItem(menu, ActionCode.SHOW_TOC, R.drawable.ic_menu_toc);
		addMenuItem(menu, ActionCode.SHOW_BOOKMARKS, R.drawable.ic_menu_bookmarks);
		addMenuItem(menu, ActionCode.SWITCH_TO_NIGHT_PROFILE, R.drawable.ic_menu_night);
		addMenuItem(menu, ActionCode.SWITCH_TO_DAY_PROFILE, R.drawable.ic_menu_day);
		addMenuItem(menu, ActionCode.SEARCH, R.drawable.ic_menu_search);
		addMenuItem(menu, ActionCode.SHOW_PREFERENCES);
		addMenuItem(menu, ActionCode.SHOW_BOOK_INFO);
		addMenuItem(menu, ActionCode.ROTATE);
		addMenuItem(menu, ActionCode.INCREASE_FONT);
		addMenuItem(menu, ActionCode.DECREASE_FONT);
		addMenuItem(menu, ActionCode.SHOW_NAVIGATION);
		synchronized (myPluginActions) {
			int index = 0;
			for (PluginApi.ActionInfo info : myPluginActions) {
				if (info instanceof PluginApi.MenuActionInfo) {
					addMenuItem(
						menu,
						PLUGIN_ACTION_PREFIX + index++,
						((PluginApi.MenuActionInfo)info).MenuItemName
					);
				}
			}
		}

		final ZLAndroidApplication application = (ZLAndroidApplication)getApplication();
		application.myMainWindow.refreshMenu();

		return true;
	}
}
",True,421,0,0,7,105,28,42,L6
192,org.geometerplus.android.fbreader.BookInfoActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.io.File;
import java.text.DateFormat;
import java.util.*;

import android.app.Activity;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.text.method.LinkMovementMethod;
import android.util.DisplayMetrics;
import android.view.View;
import android.view.Window;
import android.widget.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;

import org.geometerplus.zlibrary.ui.android.R;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;

import org.geometerplus.fbreader.library.*;
import org.geometerplus.fbreader.network.HtmlUtil;

import org.geometerplus.android.fbreader.preferences.EditBookInfoActivity;

public class BookInfoActivity extends Activity {
	private static final boolean ENABLE_EXTENDED_FILE_INFO = false;

	public static final String CURRENT_BOOK_PATH_KEY = ""CurrentBookPath"";
	public static final String HIDE_OPEN_BUTTON_KEY = ""hideOpenButton"";

	private final ZLResource myResource = ZLResource.resource(""bookInfo"");
	private ZLFile myFile;
	private ZLImage myImage;
	private boolean myHideOpenButton;

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(
			new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this)
		);

		final String path = getIntent().getStringExtra(CURRENT_BOOK_PATH_KEY);
		myHideOpenButton = getIntent().getBooleanExtra(HIDE_OPEN_BUTTON_KEY, false);
		myFile = ZLFile.createFileByPath(path);

		myImage = Library.getCover(myFile);

		if (SQLiteBooksDatabase.Instance() == null) {
			new SQLiteBooksDatabase(this, ""LIBRARY"");
		}

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.book_info);
	}

	@Override
	protected void onStart() {
		super.onStart();

		final Book book = Book.getByFile(myFile);

		if (book != null) {
			setupCover(book);
			setupBookInfo(book);
			setupAnnotation(book);
			setupFileInfo(book);
		}

		if (myHideOpenButton) {
			findButton(R.id.book_info_button_open).setVisibility(View.GONE);
		} else {
			setupButton(R.id.book_info_button_open, ""openBook"", new View.OnClickListener() {
				public void onClick(View view) {
					startActivity(
						new Intent(getApplicationContext(), FBReader.class)
							.setAction(Intent.ACTION_VIEW)
							.putExtra(FBReader.BOOK_PATH_KEY, myFile.getPath())
							.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
					);
				}
			});
		}
		setupButton(R.id.book_info_button_edit, ""editInfo"", new View.OnClickListener() {
			public void onClick(View view) {
				startActivityForResult(
					new Intent(getApplicationContext(), EditBookInfoActivity.class)
						.putExtra(CURRENT_BOOK_PATH_KEY, myFile.getPath()),
					1
				);
			}
		});
		setupButton(R.id.book_info_button_reload, ""reloadInfo"", new View.OnClickListener() {
			public void onClick(View view) {
				if (book != null) {
					book.reloadInfoFromFile();
					setupBookInfo(book);
				}
			}
		});

		final View root = findViewById(R.id.book_info_root);
		root.invalidate();
		root.requestLayout();
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		final Book book = Book.getByFile(myFile);
		if (book != null) {
			setupBookInfo(book);
		}
	}

	private Button findButton(int buttonId) {
		return (Button)findViewById(buttonId);
	}

	private void setupButton(int buttonId, String resourceKey, View.OnClickListener listener) {
		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		final Button button = findButton(buttonId);
		button.setText(buttonResource.getResource(resourceKey).getValue());
		button.setOnClickListener(listener);
	}

	private void setupInfoPair(int id, String key, CharSequence value) {
		final LinearLayout layout = (LinearLayout)findViewById(id);
		if (value == null || value.length() == 0) {
			layout.setVisibility(View.GONE);
			return;
		}
		layout.setVisibility(View.VISIBLE);
		((TextView)layout.findViewById(R.id.book_info_key)).setText(myResource.getResource(key).getValue());
		((TextView)layout.findViewById(R.id.book_info_value)).setText(value);
	}

	private void setupCover(Book book) {
		final ImageView coverView = (ImageView)findViewById(R.id.book_cover);

		final DisplayMetrics metrics = new DisplayMetrics();
		getWindowManager().getDefaultDisplay().getMetrics(metrics);

		final int maxHeight = metrics.heightPixels * 2 / 3;
		final int maxWidth = maxHeight * 2 / 3;

		coverView.setVisibility(View.GONE);
		coverView.setImageDrawable(null);

		if (myImage == null) {
			return;
		}

		if (myImage instanceof ZLLoadableImage) {
			final ZLLoadableImage loadableImage = (ZLLoadableImage)myImage;
			if (!loadableImage.isSynchronized()) {
				loadableImage.synchronize();
			}
		}
		final ZLAndroidImageData data =
			((ZLAndroidImageManager)ZLAndroidImageManager.Instance()).getImageData(myImage);
		if (data == null) {
			return;
		}

		final Bitmap coverBitmap = data.getBitmap(2 * maxWidth, 2 * maxHeight);
		if (coverBitmap == null) {
			return;
		}

		coverView.setVisibility(View.VISIBLE);
		coverView.getLayoutParams().width = maxWidth;
		coverView.getLayoutParams().height = maxHeight;
		coverView.setImageBitmap(coverBitmap);
	}

	private void setupBookInfo(Book book) {
		((TextView)findViewById(R.id.book_info_title)).setText(myResource.getResource(""bookInfo"").getValue());

		setupInfoPair(R.id.book_title, ""title"", book.getTitle());

		final StringBuilder buffer = new StringBuilder();
		for (Author author: book.authors()) {
			if (buffer.length() > 0) {
				buffer.append("", "");
			}
			buffer.append(author.DisplayName);
		}
		setupInfoPair(R.id.book_authors, ""authors"", buffer);

		final SeriesInfo series = book.getSeriesInfo();
		setupInfoPair(R.id.book_series, ""series"",
				(series == null) ? null : series.Name);
		String seriesIndexString = null;
		if (series != null && series.Index > 0) {
			if (Math.abs(series.Index - Math.round(series.Index)) < 0.01) {
				seriesIndexString = String.valueOf(Math.round(series.Index));
			} else {
				seriesIndexString = String.format(""%.1f"", series.Index);
			}
		}
		setupInfoPair(R.id.book_series_index, ""indexInSeries"", seriesIndexString);

		buffer.delete(0, buffer.length());
		final HashSet<String> tagNames = new HashSet<String>();
		for (Tag tag : book.tags()) {
			if (!tagNames.contains(tag.Name)) {
				if (buffer.length() > 0) {
					buffer.append("", "");
				}
				buffer.append(tag.Name);
				tagNames.add(tag.Name);
			}
		}
		setupInfoPair(R.id.book_tags, ""tags"", buffer);
		String language = book.getLanguage();
		if (!ZLLanguageUtil.languageCodes().contains(language)) {
			language = ZLLanguageUtil.OTHER_LANGUAGE_CODE;
		}
		setupInfoPair(R.id.book_language, ""language"", ZLLanguageUtil.languageName(language));
	}

	private void setupAnnotation(Book book) {
		final TextView titleView = (TextView)findViewById(R.id.book_info_annotation_title);
		final TextView bodyView = (TextView)findViewById(R.id.book_info_annotation_body);
		final String annotation = Library.getAnnotation(book.File);	
		if (annotation == null) {
			titleView.setVisibility(View.GONE);
			bodyView.setVisibility(View.GONE);
		} else {
			titleView.setText(myResource.getResource(""annotation"").getValue());
			bodyView.setText(HtmlUtil.getHtmlText(annotation));
			bodyView.setMovementMethod(new LinkMovementMethod());
		}
	}

	private void setupFileInfo(Book book) {
		((TextView)findViewById(R.id.file_info_title)).setText(myResource.getResource(""fileInfo"").getValue());

		setupInfoPair(R.id.file_name, ""name"", book.File.getPath());
		if (ENABLE_EXTENDED_FILE_INFO) {
			setupInfoPair(R.id.file_type, ""type"", book.File.getExtension());
        
			final ZLFile physFile = book.File.getPhysicalFile();
			final File file = physFile == null ? null : new File(physFile.getPath());
			if (file != null && file.exists() && file.isFile()) {
				setupInfoPair(R.id.file_size, ""size"", formatSize(file.length()));
				setupInfoPair(R.id.file_time, ""time"", formatDate(file.lastModified()));
			} else {
				setupInfoPair(R.id.file_size, ""size"", null);
				setupInfoPair(R.id.file_time, ""time"", null);
			}
		} else {
			setupInfoPair(R.id.file_type, ""type"", null);
			setupInfoPair(R.id.file_size, ""size"", null);
			setupInfoPair(R.id.file_time, ""time"", null);
		}
	}

	private String formatSize(long size) {
		if (size <= 0) {
			return null;
		}
		final int kilo = 1024;
		if (size < kilo) { // less than 1 kilobyte
			return myResource.getResource(""sizeInBytes"").getValue().replaceAll(""%s"", String.valueOf(size));
		}
		final String value;
		if (size < kilo * kilo) { // less than 1 megabyte
			value = String.format(""%.2f"", ((float)size) / kilo);
		} else {
			value = String.valueOf(size / kilo);
		}
		return myResource.getResource(""sizeInKiloBytes"").getValue().replaceAll(""%s"", value);
	}

	private String formatDate(long date) {
		if (date == 0) {
			return null;
		}
		return DateFormat.getDateTimeInstance().format(new Date(date));
	}
}
",False,421,0,0,8,110,3,19,L6
193,org.geometerplus.android.fbreader.SelectionShareAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

public class SelectionShareAction extends FBAndroidAction {
	SelectionShareAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public void run() {
		final String text = Reader.getTextView().getSelectedText();
		final String title = Reader.Model.Book.getTitle();
		Reader.getTextView().clearSelection();

		final Intent intent = new Intent(android.content.Intent.ACTION_SEND);
		intent.setType(""text/plain"");
		intent.putExtra(android.content.Intent.EXTRA_SUBJECT, 
			ZLResource.resource(""selection"").getResource(""quoteFrom"").getValue().replace(""%s"", title)
		);
		intent.putExtra(android.content.Intent.EXTRA_TEXT, text);
		BaseActivity.startActivity(Intent.createChooser(intent, null));
	}
}
",False,421,0,0,8,115,1,9,L6
194,org.geometerplus.android.fbreader.ShowCancelMenuAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.List;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowCancelMenuAction extends FBAndroidAction {
	ShowCancelMenuAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public void run() {
		if (Reader.getCurrentView() != Reader.BookTextView) {
			Reader.showBookTextView();
		} else {
			final List<FBReaderApp.CancelActionDescription> descriptionList =
				Reader.getCancelActionsList();
			if (descriptionList.size() == 1) {
				Reader.closeWindow();
			} else {
				final Intent intent = new Intent();
				intent.setClass(BaseActivity, CancelActivity.class);
				intent.putExtra(CancelActivity.LIST_SIZE, descriptionList.size());
				int index = 0;
				for (FBReaderApp.CancelActionDescription description : descriptionList) {
					intent.putExtra(CancelActivity.ITEM_TITLE + index, description.Title);
					intent.putExtra(CancelActivity.ITEM_SUMMARY + index, description.Summary);
					++index;
				}
				BaseActivity.startActivityForResult(intent, FBReader.CANCEL_CODE);
			}
		}
	}
}
",False,421,0,0,8,94,1,6,L6
195,org.geometerplus.android.fbreader.ShowNavigationAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.zlibrary.text.model.ZLTextModel;
import org.geometerplus.zlibrary.text.view.ZLTextView;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowNavigationAction extends FBAndroidAction {
	ShowNavigationAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	@Override
	public boolean isVisible() {
		final ZLTextView view = (ZLTextView)Reader.getCurrentView();
		final ZLTextModel textModel = view.getModel();
		return textModel != null && textModel.getParagraphsNumber() != 0;
	}

	public void run() {
		BaseActivity.navigate();
	}
}
",False,421,0,0,8,90,1,7,L6
196,org.geometerplus.android.fbreader.PopupWindow.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.Activity;
import android.os.Handler;
import android.os.Message;
import android.content.Context;
import android.view.*;
import android.view.animation.AlphaAnimation;
import android.widget.*;

import org.geometerplus.zlibrary.ui.android.R;

public class PopupWindow extends LinearLayout {
	public static enum Location {
		Bottom,
		Floating
	}

	private final Activity myActivity;

	public PopupWindow(Activity activity, RelativeLayout root, Location location, boolean fillWidth) {
		super(activity);
		myActivity = activity;

		setFocusable(false);
		
		final LayoutInflater inflater =
			(LayoutInflater)activity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(
			location == Location.Bottom
				? R.layout.control_panel_bottom : R.layout.control_panel_floating,
			this,
			true
		);

		RelativeLayout.LayoutParams p = new RelativeLayout.LayoutParams(
			fillWidth ? ViewGroup.LayoutParams.FILL_PARENT : ViewGroup.LayoutParams.WRAP_CONTENT,
			RelativeLayout.LayoutParams.WRAP_CONTENT
		);
		p.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
		p.addRule(RelativeLayout.CENTER_HORIZONTAL);
		root.addView(this, p);

		setVisibility(View.GONE);
	}

	@Override
	public boolean onTouchEvent(MotionEvent event) {
		return true;
	}

	public void show() {
		myActivity.runOnUiThread(new Runnable() {
			public void run() {
				setVisibility(View.VISIBLE);
			}
		});
	}

	public void hide() {
		myActivity.runOnUiThread(new Runnable() {
			public void run() {
				setVisibility(View.GONE);
			}
		});
	}
	
	public void addView(View view) {
		((LinearLayout)findViewById(R.id.tools_plate)).addView(view);
	}
}
",False,55,5,24,0,0,6,0,L6
197,org.geometerplus.android.fbreader.SQLiteBooksDatabase.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import android.database.SQLException;
import android.database.Cursor;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.options.ZLIntegerOption;
import org.geometerplus.zlibrary.core.config.ZLConfig;
import org.geometerplus.zlibrary.text.view.ZLTextPosition;
import org.geometerplus.zlibrary.text.view.ZLTextFixedPosition;

import org.geometerplus.fbreader.library.*;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.util.SQLiteUtil;

public final class SQLiteBooksDatabase extends BooksDatabase {
	private final String myInstanceId;
	private final SQLiteDatabase myDatabase;

	public SQLiteBooksDatabase(Context context, String instanceId) {
		myInstanceId = instanceId;
		myDatabase = context.openOrCreateDatabase(""books.db"", Context.MODE_PRIVATE, null);
		migrate(context);
	}

	protected void executeAsATransaction(Runnable actions) {
		myDatabase.beginTransaction();
		try {
			actions.run();
			myDatabase.setTransactionSuccessful();
		} finally {
			myDatabase.endTransaction();
		}
	}

	private void migrate(Context context) {
		final int version = myDatabase.getVersion();
		final int currentVersion = 16;
		if (version >= currentVersion) {
			return;
		}
		UIUtil.wait((version == 0) ? ""creatingBooksDatabase"" : ""updatingBooksDatabase"", new Runnable() {
			public void run() {
				myDatabase.beginTransaction();

				switch (version) {
					case 0:
						createTables();
					case 1:
						updateTables1();
					case 2:
						updateTables2();
					case 3:
						updateTables3();
					case 4:
						updateTables4();
					case 5:
						updateTables5();
					case 6:
						updateTables6();
					case 7:
						updateTables7();
					case 8:
						updateTables8();
					case 9:
						updateTables9();
					case 10:
						updateTables10();
					case 11:
						updateTables11();
					case 12:
						updateTables12();
					case 13:
						updateTables13();
					case 14:
						updateTables14();
					case 15:
						updateTables15();
				}
				myDatabase.setTransactionSuccessful();
				myDatabase.endTransaction();

				myDatabase.execSQL(""VACUUM"");
				myDatabase.setVersion(currentVersion);
			}
		}, context);
	}

	@Override
	protected Book loadBook(long bookId) {
		Book book = null;
		final Cursor cursor = myDatabase.rawQuery(""SELECT file_id,title,encoding,language FROM Books WHERE book_id = "" + bookId, null);
		if (cursor.moveToNext()) {
			book = createBook(
				bookId, cursor.getLong(0), cursor.getString(1), cursor.getString(2), cursor.getString(3)
			);
		}
		cursor.close();
		return book;
	}

	@Override
	protected void reloadBook(Book book) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT title,encoding,language FROM Books WHERE book_id = "" + book.getId(), null);
		if (cursor.moveToNext()) {
			book.setTitle(cursor.getString(0));
			book.setEncoding(cursor.getString(1));
			book.setLanguage(cursor.getString(2));
		}
		cursor.close();
	}

	protected Book loadBookByFile(long fileId, ZLFile file) {
		if (fileId == -1) {
			return null;
		}
		Book book = null;
		final Cursor cursor = myDatabase.rawQuery(""SELECT book_id,title,encoding,language FROM Books WHERE file_id = "" + fileId, null);
		if (cursor.moveToNext()) {
			book = createBook(
				cursor.getLong(0), file, cursor.getString(1), cursor.getString(2), cursor.getString(3)
			);
		}
		cursor.close();
		return book;
	}

	private boolean myTagCacheIsInitialized;
	private final HashMap<Tag,Long> myIdByTag = new HashMap<Tag,Long>();
	private final HashMap<Long,Tag> myTagById = new HashMap<Long,Tag>();

	private void initTagCache() {
		if (myTagCacheIsInitialized) {
			return;
		}
		myTagCacheIsInitialized = true;

		Cursor cursor = myDatabase.rawQuery(""SELECT tag_id,parent_id,name FROM Tags ORDER BY tag_id"", null);
		while (cursor.moveToNext()) {
			long id = cursor.getLong(0);
			if (myTagById.get(id) == null) {
				final Tag tag = Tag.getTag(myTagById.get(cursor.getLong(1)), cursor.getString(2));
				myIdByTag.put(tag, id);
				myTagById.put(id, tag);
			}
		}
		cursor.close();
	}

	@Override
	protected Map<Long,Book> loadBooks(FileInfoSet infos) {
		Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id,file_id,title,encoding,language FROM Books"", null
		);
		final HashMap<Long,Book> booksById = new HashMap<Long,Book>();
		final HashMap<Long,Book> booksByFileId = new HashMap<Long,Book>();
		while (cursor.moveToNext()) {
			final long id = cursor.getLong(0);
			final long fileId = cursor.getLong(1);
			final Book book = createBook(
				id, infos.getFile(fileId), cursor.getString(2), cursor.getString(3), cursor.getString(4)
			);
			if (book != null) {
				booksById.put(id, book);
				booksByFileId.put(fileId, book);
			}
		}
		cursor.close();

		initTagCache();

		cursor = myDatabase.rawQuery(
			""SELECT author_id,name,sort_key FROM Authors"", null
		);
		final HashMap<Long,Author> authorById = new HashMap<Long,Author>();
		while (cursor.moveToNext()) {
			authorById.put(cursor.getLong(0), new Author(cursor.getString(1), cursor.getString(2)));
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,author_id FROM BookAuthor ORDER BY author_index"", null
		);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				Author author = authorById.get(cursor.getLong(1));
				if (author != null) {
					addAuthor(book, author);
				}
			}
		}
		cursor.close();

		cursor = myDatabase.rawQuery(""SELECT book_id,tag_id FROM BookTag"", null);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				addTag(book, getTagById(cursor.getLong(1)));
			}
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT series_id,name FROM Series"", null
		);
		final HashMap<Long,String> seriesById = new HashMap<Long,String>();
		while (cursor.moveToNext()) {
			seriesById.put(cursor.getLong(0), cursor.getString(1));
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,series_id,book_index FROM BookSeries"", null
		);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				String series = seriesById.get(cursor.getLong(1));
				if (series != null) {
					setSeriesInfo(book, series, cursor.getFloat(2));
				}
			}
		}
		cursor.close();
		return booksByFileId;
	}

	private SQLiteStatement myUpdateBookInfoStatement;
	protected void updateBookInfo(long bookId, long fileId, String encoding, String language, String title) {
		if (myUpdateBookInfoStatement == null) {
			myUpdateBookInfoStatement = myDatabase.compileStatement(
				""UPDATE Books SET file_id = ?, encoding = ?, language = ?, title = ? WHERE book_id = ?""
			);
		}
		myUpdateBookInfoStatement.bindLong(1, fileId);
		SQLiteUtil.bindString(myUpdateBookInfoStatement, 2, encoding);
		SQLiteUtil.bindString(myUpdateBookInfoStatement, 3, language);
		myUpdateBookInfoStatement.bindString(4, title);
		myUpdateBookInfoStatement.bindLong(5, bookId);
		myUpdateBookInfoStatement.execute();
	}

	private SQLiteStatement myInsertBookInfoStatement;
	protected long insertBookInfo(ZLFile file, String encoding, String language, String title) {
		if (myInsertBookInfoStatement == null) {
			myInsertBookInfoStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Books (encoding,language,title,file_id) VALUES (?,?,?,?)""
			);
		}
		SQLiteUtil.bindString(myInsertBookInfoStatement, 1, encoding);
		SQLiteUtil.bindString(myInsertBookInfoStatement, 2, language);
		myInsertBookInfoStatement.bindString(3, title);
		final FileInfoSet infoSet = new FileInfoSet(file);
		myInsertBookInfoStatement.bindLong(4, infoSet.getId(file));
		return myInsertBookInfoStatement.executeInsert();
	}

	private SQLiteStatement myDeleteBookAuthorsStatement;
	protected void deleteAllBookAuthors(long bookId) {
		if (myDeleteBookAuthorsStatement == null) {
			myDeleteBookAuthorsStatement = myDatabase.compileStatement(
				""DELETE FROM BookAuthor WHERE book_id = ?""
			);
		}
		myDeleteBookAuthorsStatement.bindLong(1, bookId);
		myDeleteBookAuthorsStatement.execute();
	}

	private SQLiteStatement myGetAuthorIdStatement;
	private SQLiteStatement myInsertAuthorStatement;
	private SQLiteStatement myInsertBookAuthorStatement;
	protected void saveBookAuthorInfo(long bookId, long index, Author author) {
		if (myGetAuthorIdStatement == null) {
			myGetAuthorIdStatement = myDatabase.compileStatement(
				""SELECT author_id FROM Authors WHERE name = ? AND sort_key = ?""
			);
			myInsertAuthorStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Authors (name,sort_key) VALUES (?,?)""
			);
			myInsertBookAuthorStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookAuthor (book_id,author_id,author_index) VALUES (?,?,?)""
			);
		}

		long authorId;
		try {
			myGetAuthorIdStatement.bindString(1, author.DisplayName);
			myGetAuthorIdStatement.bindString(2, author.SortKey);
			authorId = myGetAuthorIdStatement.simpleQueryForLong();
		} catch (SQLException e) {
			myInsertAuthorStatement.bindString(1, author.DisplayName);
			myInsertAuthorStatement.bindString(2, author.SortKey);
			authorId = myInsertAuthorStatement.executeInsert();
		}
		myInsertBookAuthorStatement.bindLong(1, bookId);
		myInsertBookAuthorStatement.bindLong(2, authorId);
		myInsertBookAuthorStatement.bindLong(3, index);
		myInsertBookAuthorStatement.execute();
	}

	protected List<Author> loadAuthors(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Authors.name,Authors.sort_key FROM BookAuthor INNER JOIN Authors ON Authors.author_id = BookAuthor.author_id WHERE BookAuthor.book_id = ?"", new String[] { """" + bookId });
		if (!cursor.moveToNext()) {
			cursor.close();
			return null;
		}
		final ArrayList<Author> list = new ArrayList<Author>();
		do {
			list.add(new Author(cursor.getString(0), cursor.getString(1)));
		} while (cursor.moveToNext());
		cursor.close();	
		return list;
	}

	private SQLiteStatement myGetTagIdStatement;
	private SQLiteStatement myCreateTagIdStatement;
	private long getTagId(Tag tag) {
		if (myGetTagIdStatement == null) {
			myGetTagIdStatement = myDatabase.compileStatement(
				""SELECT tag_id FROM Tags WHERE parent_id = ? AND name = ?""
			);
			myCreateTagIdStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Tags (parent_id,name) VALUES (?,?)""
			);
		}	
		{
			final Long id = myIdByTag.get(tag);
			if (id != null) {
				return id;
			}
		}
		if (tag.Parent != null) {
			myGetTagIdStatement.bindLong(1, getTagId(tag.Parent));
		} else {
			myGetTagIdStatement.bindNull(1);
		}
		myGetTagIdStatement.bindString(2, tag.Name);
		long id;
		try {
			id = myGetTagIdStatement.simpleQueryForLong();
		} catch (SQLException e) {
			if (tag.Parent != null) {
				myCreateTagIdStatement.bindLong(1, getTagId(tag.Parent));
			} else {
				myCreateTagIdStatement.bindNull(1);
			}
			myCreateTagIdStatement.bindString(2, tag.Name);
			id = myCreateTagIdStatement.executeInsert();
		}
		myIdByTag.put(tag, id);
		myTagById.put(id, tag);
		return id;
	}

	private SQLiteStatement myDeleteBookTagsStatement;
	protected void deleteAllBookTags(long bookId) {
		if (myDeleteBookTagsStatement == null) {
			myDeleteBookTagsStatement = myDatabase.compileStatement(
				""DELETE FROM BookTag WHERE book_id = ?""
			);
		}
		myDeleteBookTagsStatement.bindLong(1, bookId);
		myDeleteBookTagsStatement.execute();
	}

	private SQLiteStatement myInsertBookTagStatement;
	protected void saveBookTagInfo(long bookId, Tag tag) {
		if (myInsertBookTagStatement == null) {
			myInsertBookTagStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO BookTag (book_id,tag_id) VALUES (?,?)""
			);
		}
		myInsertBookTagStatement.bindLong(1, bookId);
		myInsertBookTagStatement.bindLong(2, getTagId(tag));
		myInsertBookTagStatement.execute();
	}

	private Tag getTagById(long id) {
		Tag tag = myTagById.get(id);
		if (tag == null) {
			final Cursor cursor = myDatabase.rawQuery(""SELECT parent_id,name FROM Tags WHERE tag_id = ?"", new String[] { """" + id });
			if (cursor.moveToNext()) {
				final Tag parent = cursor.isNull(0) ? null : getTagById(cursor.getLong(0));
				tag = Tag.getTag(parent, cursor.getString(1));
				myIdByTag.put(tag, id);
				myTagById.put(id, tag);
			}
			cursor.close();
		}
		return tag;
	}

	protected List<Tag> loadTags(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Tags.tag_id FROM BookTag INNER JOIN Tags ON Tags.tag_id = BookTag.tag_id WHERE BookTag.book_id = ?"", new String[] { """" + bookId });
		if (!cursor.moveToNext()) {
			cursor.close();
			return null;
		}
		ArrayList<Tag> list = new ArrayList<Tag>();
		do {
			list.add(getTagById(cursor.getLong(0)));
		} while (cursor.moveToNext());
		cursor.close();	
		return list;
	}

	private SQLiteStatement myGetSeriesIdStatement;
	private SQLiteStatement myInsertSeriesStatement;
	private SQLiteStatement myInsertBookSeriesStatement;
	private SQLiteStatement myDeleteBookSeriesStatement;
	protected void saveBookSeriesInfo(long bookId, SeriesInfo seriesInfo) {
		if (myGetSeriesIdStatement == null) {
			myGetSeriesIdStatement = myDatabase.compileStatement(
				""SELECT series_id FROM Series WHERE name = ?""
			);
			myInsertSeriesStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Series (name) VALUES (?)""
			);
			myInsertBookSeriesStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookSeries (book_id,series_id,book_index) VALUES (?,?,?)""
			);
			myDeleteBookSeriesStatement = myDatabase.compileStatement(
				""DELETE FROM BookSeries WHERE book_id = ?""
			);
		}

		if (seriesInfo == null) {
			myDeleteBookSeriesStatement.bindLong(1, bookId);
			myDeleteBookSeriesStatement.execute();
		} else {
			long seriesId;
			try {
				myGetSeriesIdStatement.bindString(1, seriesInfo.Name);
				seriesId = myGetSeriesIdStatement.simpleQueryForLong();
			} catch (SQLException e) {
				myInsertSeriesStatement.bindString(1, seriesInfo.Name);
				seriesId = myInsertSeriesStatement.executeInsert();
			}
			myInsertBookSeriesStatement.bindLong(1, bookId);
			myInsertBookSeriesStatement.bindLong(2, seriesId);
			myInsertBookSeriesStatement.bindDouble(3, seriesInfo.Index);
			myInsertBookSeriesStatement.execute();
		}
	}

	protected SeriesInfo loadSeriesInfo(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Series.name,BookSeries.book_index FROM BookSeries INNER JOIN Series ON Series.series_id = BookSeries.series_id WHERE BookSeries.book_id = ?"", new String[] { """" + bookId });
		SeriesInfo info = null;
		if (cursor.moveToNext()) {
			info = new SeriesInfo(cursor.getString(0), cursor.getFloat(1));
		}
		cursor.close();	
		return info;
	}

	private SQLiteStatement myRemoveFileInfoStatement;
	protected void removeFileInfo(long fileId) {
		if (fileId == -1) {
			return;
		}
		if (myRemoveFileInfoStatement == null) {
			myRemoveFileInfoStatement = myDatabase.compileStatement(
				""DELETE FROM Files WHERE file_id = ?""
			);
		}
		myRemoveFileInfoStatement.bindLong(1, fileId);
		myRemoveFileInfoStatement.execute();
	}

	private SQLiteStatement myInsertFileInfoStatement;
	private SQLiteStatement myUpdateFileInfoStatement;
	protected void saveFileInfo(FileInfo fileInfo) {
		final long id = fileInfo.Id;
		SQLiteStatement statement;
		if (id == -1) {
			if (myInsertFileInfoStatement == null) {
				myInsertFileInfoStatement = myDatabase.compileStatement(
					""INSERT OR IGNORE INTO Files (name,parent_id,size) VALUES (?,?,?)""
				);
			}
			statement = myInsertFileInfoStatement;
		} else {
			if (myUpdateFileInfoStatement == null) {
				myUpdateFileInfoStatement = myDatabase.compileStatement(
					""UPDATE Files SET name = ?, parent_id = ?, size = ? WHERE file_id = ?""
				);
			}
			statement = myUpdateFileInfoStatement;
		}
		statement.bindString(1, fileInfo.Name);
		final FileInfo parent = fileInfo.Parent;
		if (parent != null) {
			statement.bindLong(2, parent.Id);
		} else {
			statement.bindNull(2);
		}
		final long size = fileInfo.FileSize;
		if (size != -1) {
			statement.bindLong(3, size);
		} else {
			statement.bindNull(3);
		}
		if (id == -1) {
			fileInfo.Id = statement.executeInsert();
		} else {
			statement.bindLong(4, id);
			statement.execute();
		}
	}

	protected Collection<FileInfo> loadFileInfos() {
		Cursor cursor = myDatabase.rawQuery(
			""SELECT file_id,name,parent_id,size FROM Files"", null
		);
		HashMap<Long,FileInfo> infosById = new HashMap<Long,FileInfo>();
		while (cursor.moveToNext()) {
			final long id = cursor.getLong(0);
			final FileInfo info = createFileInfo(id,
				cursor.getString(1),
				cursor.isNull(2) ? null : infosById.get(cursor.getLong(2))
			);
			if (!cursor.isNull(3)) {
				info.FileSize = cursor.getLong(3);
			}
			infosById.put(id, info);
		}
		cursor.close();
		return infosById.values();
	}

	protected Collection<FileInfo> loadFileInfos(ZLFile file) {
		final LinkedList<ZLFile> fileStack = new LinkedList<ZLFile>();
		for (; file != null; file = file.getParent()) {
			fileStack.addFirst(file);
		}

		final ArrayList<FileInfo> infos = new ArrayList<FileInfo>(fileStack.size());
		final String[] parameters = { null };
		FileInfo current = null;
		for (ZLFile f : fileStack) {
			parameters[0] = f.getLongName();
			final Cursor cursor = myDatabase.rawQuery(
				(current == null) ?
					""SELECT file_id,size FROM Files WHERE name = ?"" :
					""SELECT file_id,size FROM Files WHERE parent_id = "" + current.Id + "" AND name = ?"",
				parameters
			);
			if (cursor.moveToNext()) {
				current = createFileInfo(cursor.getLong(0), parameters[0], current);
				if (!cursor.isNull(1)) {
					current.FileSize = cursor.getLong(1);
				}
				infos.add(current);
				cursor.close();
			} else {
				cursor.close();
				break;
			}
		}

		return infos;
	}

	protected Collection<FileInfo> loadFileInfos(long fileId) {
		final ArrayList<FileInfo> infos = new ArrayList<FileInfo>();
		while (fileId != -1) {
			final Cursor cursor = myDatabase.rawQuery(
				""SELECT name,size,parent_id FROM Files WHERE file_id = "" + fileId, null
			);
			if (cursor.moveToNext()) {
				FileInfo info = createFileInfo(fileId, cursor.getString(0), null);
				if (!cursor.isNull(1)) {
					info.FileSize = cursor.getLong(1);
				}
				infos.add(0, info);
				fileId = cursor.isNull(2) ? -1 : cursor.getLong(2);
			} else {
				fileId = -1;
			}
			cursor.close();
		}
		for (int i = 1; i < infos.size(); ++i) {
			final FileInfo oldInfo = infos.get(i);
			final FileInfo newInfo = createFileInfo(oldInfo.Id, oldInfo.Name, infos.get(i - 1));
			newInfo.FileSize = oldInfo.FileSize;
			infos.set(i, newInfo);
		}
		return infos;
	}

	private SQLiteStatement mySaveRecentBookStatement;
	protected void saveRecentBookIds(final List<Long> ids) {
		if (mySaveRecentBookStatement == null) {
			mySaveRecentBookStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO RecentBooks (book_id) VALUES (?)""
			);
		}
		executeAsATransaction(new Runnable() {
			public void run() {
				myDatabase.delete(""RecentBooks"", null, null);
				for (long id : ids) {
					mySaveRecentBookStatement.bindLong(1, id);
					mySaveRecentBookStatement.execute();
				}
			}
		});
	}

	protected List<Long> loadRecentBookIds() {
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id FROM RecentBooks ORDER BY book_index"", null
		);
		final LinkedList<Long> ids = new LinkedList<Long>();
		while (cursor.moveToNext()) {
			ids.add(cursor.getLong(0));
		}
		cursor.close();
		return ids;
	}

	private SQLiteStatement myAddToFavoritesStatement;
	protected void addToFavorites(long bookId) {
		if (myAddToFavoritesStatement == null) {
			myAddToFavoritesStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Favorites(book_id) VALUES (?)""
			);
		}
		myAddToFavoritesStatement.bindLong(1, bookId);
		myAddToFavoritesStatement.execute();
	}

	private SQLiteStatement myRemoveFromFavoritesStatement;
	protected void removeFromFavorites(long bookId) {
		if (myRemoveFromFavoritesStatement == null) {
			myRemoveFromFavoritesStatement = myDatabase.compileStatement(
				""DELETE FROM Favorites WHERE book_id = ?""
			);
		}
		myRemoveFromFavoritesStatement.bindLong(1, bookId);
		myRemoveFromFavoritesStatement.execute();
	}

	protected List<Long> loadFavoritesIds() {
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id FROM Favorites"", null
		);
		final LinkedList<Long> ids = new LinkedList<Long>();
		while (cursor.moveToNext()) {
			ids.add(cursor.getLong(0));
		}
		cursor.close();
		return ids;
	}

	@Override
	protected List<Bookmark> loadBookmarks(long bookId, boolean visible) {
		LinkedList<Bookmark> list = new LinkedList<Bookmark>();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT Bookmarks.bookmark_id,Bookmarks.book_id,Books.title,Bookmarks.bookmark_text,Bookmarks.creation_time,Bookmarks.modification_time,Bookmarks.access_time,Bookmarks.access_counter,Bookmarks.model_id,Bookmarks.paragraph,Bookmarks.word,Bookmarks.char FROM Bookmarks INNER JOIN Books ON Books.book_id = Bookmarks.book_id WHERE Bookmarks.book_id = ? AND Bookmarks.visible = ?"", new String[] { """" + bookId, visible ? ""1"" : ""0"" }
		);
		while (cursor.moveToNext()) {
			list.add(createBookmark(
				cursor.getLong(0),
				cursor.getLong(1),
				cursor.getString(2),
				cursor.getString(3),
				SQLiteUtil.getDate(cursor, 4),
				SQLiteUtil.getDate(cursor, 5),
				SQLiteUtil.getDate(cursor, 6),
				(int)cursor.getLong(7),
				cursor.getString(8),
				(int)cursor.getLong(9),
				(int)cursor.getLong(10),
				(int)cursor.getLong(11),
				visible
			));
		}
		cursor.close();
		return list;
	}

	@Override
	protected List<Bookmark> loadAllVisibleBookmarks() {
		LinkedList<Bookmark> list = new LinkedList<Bookmark>();
		myDatabase.execSQL(""DELETE FROM Bookmarks WHERE book_id = -1"");
		Cursor cursor = myDatabase.rawQuery(
			""SELECT Bookmarks.bookmark_id,Bookmarks.book_id,Books.title,Bookmarks.bookmark_text,Bookmarks.creation_time,Bookmarks.modification_time,Bookmarks.access_time,Bookmarks.access_counter,Bookmarks.model_id,Bookmarks.paragraph,Bookmarks.word,Bookmarks.char FROM Bookmarks INNER JOIN Books ON Books.book_id = Bookmarks.book_id WHERE Bookmarks.visible = 1"", null
		);
		while (cursor.moveToNext()) {
			list.add(createBookmark(
				cursor.getLong(0),
				cursor.getLong(1),
				cursor.getString(2),
				cursor.getString(3),
				SQLiteUtil.getDate(cursor, 4),
				SQLiteUtil.getDate(cursor, 5),
				SQLiteUtil.getDate(cursor, 6),
				(int)cursor.getLong(7),
				cursor.getString(8),
				(int)cursor.getLong(9),
				(int)cursor.getLong(10),
				(int)cursor.getLong(11),
				true
			));
		}
		cursor.close();
		return list;
	}

	private SQLiteStatement myInsertBookmarkStatement;
	private SQLiteStatement myUpdateBookmarkStatement;
	@Override
	protected long saveBookmark(Bookmark bookmark) {
		SQLiteStatement statement;
		if (bookmark.getId() == -1) {
			if (myInsertBookmarkStatement == null) {
				myInsertBookmarkStatement = myDatabase.compileStatement(
					""INSERT OR IGNORE INTO Bookmarks (book_id,bookmark_text,creation_time,modification_time,access_time,access_counter,model_id,paragraph,word,char,visible) VALUES (?,?,?,?,?,?,?,?,?,?,?)""
				);
			}
			statement = myInsertBookmarkStatement;
		} else {
			if (myUpdateBookmarkStatement == null) {
				myUpdateBookmarkStatement = myDatabase.compileStatement(
					""UPDATE Bookmarks SET book_id = ?, bookmark_text = ?, creation_time =?, modification_time = ?,access_time = ?, access_counter = ?, model_id = ?, paragraph = ?, word = ?, char = ?, visible = ? WHERE bookmark_id = ?""
				);
			}
			statement = myUpdateBookmarkStatement;
		}

		statement.bindLong(1, bookmark.getBookId());
		statement.bindString(2, bookmark.getText());
		SQLiteUtil.bindDate(statement, 3, bookmark.getTime(Bookmark.CREATION));
		SQLiteUtil.bindDate(statement, 4, bookmark.getTime(Bookmark.MODIFICATION));
		SQLiteUtil.bindDate(statement, 5, bookmark.getTime(Bookmark.ACCESS));
		statement.bindLong(6, bookmark.getAccessCount());
		SQLiteUtil.bindString(statement, 7, bookmark.ModelId);
		statement.bindLong(8, bookmark.ParagraphIndex);
		statement.bindLong(9, bookmark.ElementIndex);
		statement.bindLong(10, bookmark.CharIndex);
		statement.bindLong(11, bookmark.IsVisible ? 1 : 0);

		if (statement == myInsertBookmarkStatement) {
			return statement.executeInsert();
		} else {
			final long id = bookmark.getId();
			statement.bindLong(12, id);
			statement.execute();
			return id;
		}
	}

	private SQLiteStatement myDeleteBookmarkStatement;
	@Override
	protected void deleteBookmark(Bookmark bookmark) {
		if (myDeleteBookmarkStatement == null) {
			myDeleteBookmarkStatement = myDatabase.compileStatement(
				""DELETE FROM Bookmarks WHERE bookmark_id = ?""
			);
		}
		myDeleteBookmarkStatement.bindLong(1, bookmark.getId());
		myDeleteBookmarkStatement.execute();
	}

	protected ZLTextPosition getStoredPosition(long bookId) {
		ZLTextPosition position = null;
		Cursor cursor = myDatabase.rawQuery(
			""SELECT paragraph,word,char FROM BookState WHERE book_id = "" + bookId, null
		);
		if (cursor.moveToNext()) {
			position = new ZLTextFixedPosition(
				(int)cursor.getLong(0),
				(int)cursor.getLong(1),
				(int)cursor.getLong(2)
			);
		}
		cursor.close();
		return position;
	}

	private SQLiteStatement myStorePositionStatement;
	protected void storePosition(long bookId, ZLTextPosition position) {
		if (myStorePositionStatement == null) {
			myStorePositionStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookState (book_id,paragraph,word,char) VALUES (?,?,?,?)""
			);
		}
		myStorePositionStatement.bindLong(1, bookId);
		myStorePositionStatement.bindLong(2, position.getParagraphIndex());
		myStorePositionStatement.bindLong(3, position.getElementIndex());
		myStorePositionStatement.bindLong(4, position.getCharIndex());
		myStorePositionStatement.execute();
	}

	private SQLiteStatement myInsertIntoBookListStatement;
	protected boolean insertIntoBookList(long bookId) {
		if (myInsertIntoBookListStatement == null) {
			myInsertIntoBookListStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO BookList(book_id) VALUES (?)""
			);
		}
		myInsertIntoBookListStatement.bindLong(1, bookId);
		myInsertIntoBookListStatement.execute();
		return true;
	}

	private SQLiteStatement myDeleteFromBookListStatement;
	protected boolean deleteFromBookList(long bookId) {
		if (myDeleteFromBookListStatement == null) {
			myDeleteFromBookListStatement = myDatabase.compileStatement(
				""DELETE FROM BookList WHERE book_id = ?""
			);
		}
		myDeleteFromBookListStatement.bindLong(1, bookId);
		myDeleteFromBookListStatement.execute();
		deleteVisitedHyperlinks(bookId);
		return true;
	}

	private SQLiteStatement myCheckBookListStatement;
	protected boolean checkBookList(long bookId) {
		if (myCheckBookListStatement == null) {
			myCheckBookListStatement = myDatabase.compileStatement(
				""SELECT COUNT(*) FROM BookList WHERE book_id = ?""
			);
		}
		myCheckBookListStatement.bindLong(1, bookId);
		return myCheckBookListStatement.simpleQueryForLong() > 0;
	}

	private SQLiteStatement myDeleteVisitedHyperlinksStatement;
	private void deleteVisitedHyperlinks(long bookId) {
		if (myDeleteVisitedHyperlinksStatement == null) {
			myDeleteVisitedHyperlinksStatement = myDatabase.compileStatement(
				""DELETE FROM VisitedHyperlinks WHERE book_id = ?""
			);
		}

		myDeleteVisitedHyperlinksStatement.bindLong(1, bookId);
		myDeleteVisitedHyperlinksStatement.execute();
	}

	private SQLiteStatement myStoreVisitedHyperlinksStatement;
	protected void addVisitedHyperlink(long bookId, String hyperlinkId) {
		if (myStoreVisitedHyperlinksStatement == null) {
			myStoreVisitedHyperlinksStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO VisitedHyperlinks(book_id,hyperlink_id) VALUES (?,?)""
			);
		}

		myStoreVisitedHyperlinksStatement.bindLong(1, bookId);
		myStoreVisitedHyperlinksStatement.bindString(2, hyperlinkId);
		myStoreVisitedHyperlinksStatement.execute();
	}

	protected Collection<String> loadVisitedHyperlinks(long bookId) {
		final TreeSet<String> links = new TreeSet<String>();
		final Cursor cursor = myDatabase.rawQuery(""SELECT hyperlink_id FROM VisitedHyperlinks WHERE book_id = ?"", new String[] { """" + bookId });
		while (cursor.moveToNext()) {
			links.add(cursor.getString(0));
		}
		cursor.close();
		return links;
	}


	private void createTables() {
		myDatabase.execSQL(
			""CREATE TABLE Books("" +
				""book_id INTEGER PRIMARY KEY,"" +
				""encoding TEXT,"" +
				""language TEXT,"" +
				""title TEXT NOT NULL,"" +
				""file_name TEXT UNIQUE NOT NULL)"");
		myDatabase.execSQL(
			""CREATE TABLE Authors("" +
				""author_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""sort_key TEXT NOT NULL,"" +
				""CONSTRAINT Authors_Unique UNIQUE (name, sort_key))"");
		myDatabase.execSQL(
			""CREATE TABLE BookAuthor("" +
				""author_id INTEGER NOT NULL REFERENCES Authors(author_id),"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""author_index INTEGER NOT NULL,"" +
				""CONSTRAINT BookAuthor_Unique0 UNIQUE (author_id, book_id),"" +
				""CONSTRAINT BookAuthor_Unique1 UNIQUE (book_id, author_index))"");
		myDatabase.execSQL(
			""CREATE TABLE Series("" +
				""series_id INTEGER PRIMARY KEY,"" +
				""name TEXT UNIQUE NOT NULL)"");
		myDatabase.execSQL(
			""CREATE TABLE BookSeries("" +
				""series_id INTEGER NOT NULL REFERENCES Series(series_id),"" +
				""book_id INTEGER NOT NULL UNIQUE REFERENCES Books(book_id),"" +
				""book_index INTEGER)"");
		myDatabase.execSQL(
			""CREATE TABLE Tags("" +
				""tag_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent INTEGER REFERENCES Tags(tag_id),"" +
				""CONSTRAINT Tags_Unique UNIQUE (name, parent))"");
		myDatabase.execSQL(
			""CREATE TABLE BookTag("" +
				""tag_id INTEGER REFERENCES Tags(tag_id),"" +
				""book_id INTEGER REFERENCES Books(book_id),"" +
				""CONSTRAINT BookTag_Unique UNIQUE (tag_id, book_id))"");
	}

	private void updateTables1() {
		myDatabase.execSQL(""ALTER TABLE Tags RENAME TO Tags_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE Tags("" +
				""tag_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent_id INTEGER REFERENCES Tags(tag_id),"" +
				""CONSTRAINT Tags_Unique UNIQUE (name, parent_id))"");
		myDatabase.execSQL(""INSERT INTO Tags (tag_id,name,parent_id) SELECT tag_id,name,parent FROM Tags_Obsolete"");
		myDatabase.execSQL(""DROP TABLE Tags_Obsolete"");

		myDatabase.execSQL(""ALTER TABLE BookTag RENAME TO BookTag_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE BookTag("" +
				""tag_id INTEGER NOT NULL REFERENCES Tags(tag_id),"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""CONSTRAINT BookTag_Unique UNIQUE (tag_id, book_id))"");
		myDatabase.execSQL(""INSERT INTO BookTag (tag_id,book_id) SELECT tag_id,book_id FROM BookTag_Obsolete"");
		myDatabase.execSQL(""DROP TABLE BookTag_Obsolete"");
	}

	private void updateTables2() {
		myDatabase.execSQL(""CREATE INDEX BookAuthor_BookIndex ON BookAuthor (book_id)"");
		myDatabase.execSQL(""CREATE INDEX BookTag_BookIndex ON BookTag (book_id)"");
		myDatabase.execSQL(""CREATE INDEX BookSeries_BookIndex ON BookSeries (book_id)"");
	}

	private void updateTables3() {
		myDatabase.execSQL(
			""CREATE TABLE Files("" +
				""file_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent_id INTEGER REFERENCES Files(file_id),"" +
				""size INTEGER,"" +
				""CONSTRAINT Files_Unique UNIQUE (name, parent_id))"");
	}

	private void updateTables4() {
		final FileInfoSet fileInfos = new FileInfoSet();
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT file_name FROM Books"", null
		);
		while (cursor.moveToNext()) {
			fileInfos.check(ZLFile.createFileByPath(cursor.getString(0)).getPhysicalFile(), false);
		}
		cursor.close();
		fileInfos.save();

		myDatabase.execSQL(
			""CREATE TABLE RecentBooks("" +
				""book_index INTEGER PRIMARY KEY,"" +
				""book_id INTEGER REFERENCES Books(book_id))"");
		final ArrayList<Long> ids = new ArrayList<Long>();

		final SQLiteStatement statement = myDatabase.compileStatement(
			""SELECT book_id FROM Books WHERE file_name = ?""
		);

		for (int i = 0; i < 20; ++i) {
			final ZLStringOption option = new ZLStringOption(""LastOpenedBooks"", ""Book"" + i, """");
			final String fileName = option.getValue();
			option.setValue("""");
			try {
				statement.bindString(1, fileName);
				final long bookId = statement.simpleQueryForLong();
				if (bookId != -1) {
					ids.add(bookId);
				}
			} catch (SQLException e) {
			}
		}
		saveRecentBookIds(ids);
	}

	private void updateTables5() {
		myDatabase.execSQL(
			""CREATE TABLE Bookmarks("" +
				""bookmark_id INTEGER PRIMARY KEY,"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""bookmark_text TEXT NOT NULL,"" +
				""creation_time INTEGER NOT NULL,"" +
				""modification_time INTEGER,"" +
				""access_time INTEGER,"" +
				""access_counter INTEGER NOT NULL,"" +
				""paragraph INTEGER NOT NULL,"" +
				""word INTEGER NOT NULL,"" +
				""char INTEGER NOT NULL)"");

		myDatabase.execSQL(
			""CREATE TABLE BookState("" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books(book_id),"" +
				""paragraph INTEGER NOT NULL,"" +
				""word INTEGER NOT NULL,"" +
				""char INTEGER NOT NULL)"");
		Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id,file_name FROM Books"", null
		);
		final SQLiteStatement statement = myDatabase.compileStatement(""INSERT INTO BookState (book_id,paragraph,word,char) VALUES (?,?,?,?)"");
		while (cursor.moveToNext()) {
			final long bookId = cursor.getLong(0);
			final String fileName = cursor.getString(1);
			final int position = new ZLIntegerOption(fileName, ""PositionInBuffer"", 0).getValue();
			final int paragraph = new ZLIntegerOption(fileName, ""Paragraph_"" + position, 0).getValue();
			final int word = new ZLIntegerOption(fileName, ""Word_"" + position, 0).getValue();
			final int chr = new ZLIntegerOption(fileName, ""Char_"" + position, 0).getValue();
			if ((paragraph != 0) || (word != 0) || (chr != 0)) {
				statement.bindLong(1, bookId);
				statement.bindLong(2, paragraph);
				statement.bindLong(3, word);
				statement.bindLong(4, chr);
				statement.execute();
			}
			ZLConfig.Instance().removeGroup(fileName);
		}
		cursor.close();
	}

	private void updateTables6() {
		myDatabase.execSQL(
			""ALTER TABLE Bookmarks ADD COLUMN model_id TEXT""
		);

		myDatabase.execSQL(
			""ALTER TABLE Books ADD COLUMN file_id INTEGER""
		);

		myDatabase.execSQL(""DELETE FROM Files"");
		final FileInfoSet infoSet = new FileInfoSet();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT file_name FROM Books"", null
		);
		while (cursor.moveToNext()) {
			infoSet.check(ZLFile.createFileByPath(cursor.getString(0)).getPhysicalFile(), false);
		}
		cursor.close();
		infoSet.save();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,file_name FROM Books"", null
		);
		final SQLiteStatement deleteStatement = myDatabase.compileStatement(""DELETE FROM Books WHERE book_id = ?"");
		final SQLiteStatement updateStatement = myDatabase.compileStatement(""UPDATE Books SET file_id = ? WHERE book_id = ?"");
		while (cursor.moveToNext()) {
			final long bookId = cursor.getLong(0);
			final long fileId = infoSet.getId(ZLFile.createFileByPath(cursor.getString(1)));

			if (fileId == -1) {
				deleteStatement.bindLong(1, bookId);
				deleteStatement.execute();
			} else {
				updateStatement.bindLong(1, fileId);
				updateStatement.bindLong(2, bookId);
				updateStatement.execute();
			}
		}
		cursor.close();

		myDatabase.execSQL(""ALTER TABLE Books RENAME TO Books_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE Books("" +
				""book_id INTEGER PRIMARY KEY,"" +
				""encoding TEXT,"" +
				""language TEXT,"" +
				""title TEXT NOT NULL,"" +
				""file_id INTEGER UNIQUE NOT NULL REFERENCES Files(file_id))"");
		myDatabase.execSQL(""INSERT INTO Books (book_id,encoding,language,title,file_id) SELECT book_id,encoding,language,title,file_id FROM Books_Obsolete"");
		myDatabase.execSQL(""DROP TABLE Books_Obsolete"");
	}

	private void updateTables7() {
		final ArrayList<Long> seriesIDs = new ArrayList<Long>();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT series_id,name FROM Series"", null
		);
		while (cursor.moveToNext()) {
			if (cursor.getString(1).length() > 200) {
				seriesIDs.add(cursor.getLong(0));
			}
		}
		cursor.close();
		if (seriesIDs.isEmpty()) {
			return;
		}

		final ArrayList<Long> bookIDs = new ArrayList<Long>();
		for (Long id : seriesIDs) {
			cursor = myDatabase.rawQuery(
				""SELECT book_id FROM BookSeries WHERE series_id="" + id, null
			);
			while (cursor.moveToNext()) {
				bookIDs.add(cursor.getLong(0));
			}
			cursor.close();
			myDatabase.execSQL(""DELETE FROM BookSeries WHERE series_id="" + id);
			myDatabase.execSQL(""DELETE FROM Series WHERE series_id="" + id);
		}

		for (Long id : bookIDs) {
			myDatabase.execSQL(""DELETE FROM Books WHERE book_id="" + id);
			myDatabase.execSQL(""DELETE FROM BookAuthor WHERE book_id="" + id);
			myDatabase.execSQL(""DELETE FROM BookTag WHERE book_id="" + id);
		}
	}

	private void updateTables8() {
		myDatabase.execSQL(
			""CREATE TABLE IF NOT EXISTS BookList ( "" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books (book_id))"");
	}

	private void updateTables9() {
		myDatabase.execSQL(""CREATE INDEX BookList_BookIndex ON BookList (book_id)"");
	}

	private void updateTables10() {
		myDatabase.execSQL(
			""CREATE TABLE IF NOT EXISTS Favorites("" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books(book_id))"");
	}

	private void updateTables11() {
		myDatabase.execSQL(""UPDATE Files SET size = size + 1"");
	}

	private void updateTables12() {
		myDatabase.execSQL(""DELETE FROM Files WHERE parent_id IN (SELECT file_id FROM Files WHERE name LIKE '%.epub')"");
	}

	private void updateTables13() {
		myDatabase.execSQL(
			""ALTER TABLE Bookmarks ADD COLUMN visible INTEGER DEFAULT 1""
		);
	}

	private void updateTables14() {
		myDatabase.execSQL(""ALTER TABLE BookSeries RENAME TO BookSeries_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE BookSeries("" +
				""series_id INTEGER NOT NULL REFERENCES Series(series_id),"" +
				""book_id INTEGER NOT NULL UNIQUE REFERENCES Books(book_id),"" +
				""book_index REAL)"");
		myDatabase.execSQL(""INSERT INTO BookSeries (series_id,book_id,book_index) SELECT series_id,book_id,book_index FROM BookSeries_Obsolete"");
		myDatabase.execSQL(""DROP TABLE BookSeries_Obsolete"");
	}

	private void updateTables15() {
		myDatabase.execSQL(
			""CREATE TABLE IF NOT EXISTS VisitedHyperlinks("" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""hyperlink_id TEXT NOT NULL,"" +
				""CONSTRAINT VisitedHyperlinks_Unique UNIQUE (book_id, hyperlink_id))"");
	}
}
",True,199,5,27,7,34,4,17,L6
198,org.geometerplus.android.fbreader.ShowPreferencesAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

import org.geometerplus.android.fbreader.preferences.PreferenceActivity;

class ShowPreferencesAction extends FBAndroidAction {
	ShowPreferencesAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public void run() {
		BaseActivity.startActivityForResult(
			new Intent(BaseActivity.getApplicationContext(), PreferenceActivity.class),
			FBReader.REPAINT_CODE
		);
	}
}
",False,421,0,0,8,101,1,4,L6
199,org.geometerplus.android.fbreader.TOCActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.Bundle;
import android.view.*;
import android.widget.*;
import android.app.ListActivity;

import org.geometerplus.zlibrary.core.application.ZLApplication;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;
import org.geometerplus.fbreader.bookmodel.TOCTree;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

public class TOCActivity extends ListActivity {
	private TOCAdapter myAdapter;
	private ZLTree<?> mySelectedItem;

	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		requestWindowFeature(Window.FEATURE_NO_TITLE);

		final FBReaderApp fbreader = (FBReaderApp)ZLApplication.Instance();
		final TOCTree root = fbreader.Model.TOCTree;
		myAdapter = new TOCAdapter(root);
		final ZLTextWordCursor cursor = fbreader.BookTextView.getStartCursor();
		int index = cursor.getParagraphIndex();	
		if (cursor.isEndOfParagraph()) {
			++index;
		}
		TOCTree treeToSelect = null;
		// TODO: process multi-model texts
		for (TOCTree tree : root) {
			final TOCTree.Reference reference = tree.getReference();
			if (reference == null) {
				continue;
			}
			if (reference.ParagraphIndex > index) {
				break;
			}
			treeToSelect = tree;
		}
		myAdapter.selectItem(treeToSelect);
		mySelectedItem = treeToSelect;
	}

	private static final int PROCESS_TREE_ITEM_ID = 0;
	private static final int READ_BOOK_ITEM_ID = 1;

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final TOCTree tree = (TOCTree)myAdapter.getItem(position);
		switch (item.getItemId()) {
			case PROCESS_TREE_ITEM_ID:
				myAdapter.runTreeItem(tree);
				return true;
			case READ_BOOK_ITEM_ID:
				myAdapter.openBookText(tree);
				return true;
		}
		return super.onContextItemSelected(item);
	}

	private final class TOCAdapter extends ZLTreeAdapter {
		TOCAdapter(TOCTree root) {
			super(getListView(), root);
		}

		@Override
		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final TOCTree tree = (TOCTree)getItem(position);
			if (tree.hasChildren()) {
				menu.setHeaderTitle(tree.getText());
				final ZLResource resource = ZLResource.resource(""tocView"");
				menu.add(0, PROCESS_TREE_ITEM_ID, 0, resource.getResource(isOpen(tree) ? ""collapseTree"" : ""expandTree"").getValue());
				menu.add(0, READ_BOOK_ITEM_ID, 0, resource.getResource(""readText"").getValue());
			}
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			final View view = (convertView != null) ? convertView :
				LayoutInflater.from(parent.getContext()).inflate(R.layout.toc_tree_item, parent, false);
			final TOCTree tree = (TOCTree)getItem(position);
			view.setBackgroundColor((tree == mySelectedItem) ? 0xff808080 : 0);
			setIcon((ImageView)view.findViewById(R.id.toc_tree_item_icon), tree);
			((TextView)view.findViewById(R.id.toc_tree_item_text)).setText(tree.getText());
			return view;
		}

		void openBookText(TOCTree tree) {
			final TOCTree.Reference reference = tree.getReference();
			if (reference != null) {
				finish();
				final FBReaderApp fbreader = (FBReaderApp)ZLApplication.Instance();
				fbreader.addInvisibleBookmark();
				fbreader.BookTextView.gotoPosition(reference.ParagraphIndex, 0, 0);
				fbreader.showBookTextView();
			}
		}

		@Override
		protected boolean runTreeItem(ZLTree<?> tree) {
			if (super.runTreeItem(tree)) {
				return true;
			}
			openBookText((TOCTree)tree);
			return true;
		}
	}
}
",False,220,0,0,6,69,0,10,L7
200,org.geometerplus.android.fbreader.ShowNetworkLibraryAction.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

import org.geometerplus.android.fbreader.network.NetworkLibraryActivity;

class ShowNetworkLibraryAction extends RunActivityAction {
	ShowNetworkLibraryAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader, NetworkLibraryActivity.class);
	}
}
",False,421,0,0,7,132,1,4,L6
201,org.geometerplus.android.fbreader.ShowLibraryAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.bookmodel.BookModel;

import org.geometerplus.android.fbreader.library.LibraryTopLevelActivity;

class ShowLibraryAction extends FBAndroidAction {
	ShowLibraryAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public void run() {
		final BookModel model = Reader.Model;
		Intent intent = new Intent(BaseActivity.getApplicationContext(), LibraryTopLevelActivity.class);
		if (model != null && model.Book != null) {
			intent.putExtra(LibraryTopLevelActivity.SELECTED_BOOK_PATH_KEY, model.Book.File.getPath());
		}
		BaseActivity.startActivity(intent);
	}
}
",False,421,0,0,8,92,1,9,L6
202,org.geometerplus.android.fbreader.BookmarksActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.app.*;
import android.os.*;
import android.view.*;
import android.widget.*;
import android.content.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.library.*;

import org.geometerplus.android.util.UIUtil;

public class BookmarksActivity extends TabActivity implements MenuItem.OnMenuItemClickListener {
	private static final int OPEN_ITEM_ID = 0;
	private static final int EDIT_ITEM_ID = 1;
	private static final int DELETE_ITEM_ID = 2;

	List<Bookmark> AllBooksBookmarks;
	private final List<Bookmark> myThisBookBookmarks = new LinkedList<Bookmark>();
	private final List<Bookmark> mySearchResults = new LinkedList<Bookmark>();

	private ListView myThisBookView;
	private ListView myAllBooksView;
	private ListView mySearchResultsView;

	private final ZLResource myResource = ZLResource.resource(""bookmarksView"");
	private final ZLStringOption myBookmarkSearchPatternOption =
		new ZLStringOption(""BookmarkSearch"", ""Pattern"", """");

	private ListView createTab(String tag, int id) {
		final TabHost host = getTabHost();
		final String label = myResource.getResource(tag).getValue();
		host.addTab(host.newTabSpec(tag).setIndicator(label).setContent(id));
		return (ListView)findViewById(id);
	}

	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);

		final SearchManager manager = (SearchManager)getSystemService(SEARCH_SERVICE);
		manager.setOnCancelListener(null);

		final TabHost host = getTabHost();
		LayoutInflater.from(this).inflate(R.layout.bookmarks, host.getTabContentView(), true);

		AllBooksBookmarks = Bookmark.bookmarks();
		Collections.sort(AllBooksBookmarks, new Bookmark.ByTimeComparator());
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();

		if (fbreader.Model != null) {
			final long bookId = fbreader.Model.Book.getId();
			for (Bookmark bookmark : AllBooksBookmarks) {
				if (bookmark.getBookId() == bookId) {
					myThisBookBookmarks.add(bookmark);
				}
			}
        
			myThisBookView = createTab(""thisBook"", R.id.this_book);
			new BookmarksAdapter(myThisBookView, myThisBookBookmarks, true);
		} else {
			findViewById(R.id.this_book).setVisibility(View.GONE);
		}

		myAllBooksView = createTab(""allBooks"", R.id.all_books);
		new BookmarksAdapter(myAllBooksView, AllBooksBookmarks, false);

		findViewById(R.id.search_results).setVisibility(View.GONE);
	}

	@Override
	protected void onNewIntent(Intent intent) {
		if (!Intent.ACTION_SEARCH.equals(intent.getAction())) {
			return;
		}
	   	String pattern = intent.getStringExtra(SearchManager.QUERY);
		myBookmarkSearchPatternOption.setValue(pattern);

		final LinkedList<Bookmark> bookmarks = new LinkedList<Bookmark>();
		pattern = pattern.toLowerCase();
		for (Bookmark b : AllBooksBookmarks) {
			if (ZLMiscUtil.matchesIgnoreCase(b.getText(), pattern)) {
				bookmarks.add(b);
			}
		}
		if (!bookmarks.isEmpty()) {
			showSearchResultsTab(bookmarks);
		} else {
			UIUtil.showErrorMessage(this, ""bookmarkNotFound"");
		}
	}

	@Override
	public void onPause() {
		for (Bookmark bookmark : AllBooksBookmarks) {
			bookmark.save();
		}
		super.onPause();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		final MenuItem item = menu.add(
			0, 1, Menu.NONE,
			myResource.getResource(""menu"").getResource(""search"").getValue()
		);
		item.setOnMenuItemClickListener(this);
		item.setIcon(R.drawable.ic_menu_search);
		return true;
	}

	@Override
	public boolean onSearchRequested() {
		startSearch(myBookmarkSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	void showSearchResultsTab(LinkedList<Bookmark> results) {
		if (mySearchResultsView == null) {
			mySearchResultsView = createTab(""searchResults"", R.id.search_results);
			new BookmarksAdapter(mySearchResultsView, mySearchResults, false);
		} else {
			mySearchResults.clear();
		}
		mySearchResults.addAll(results);
		mySearchResultsView.invalidateViews();
		mySearchResultsView.requestLayout();
		getTabHost().setCurrentTabByTag(""searchResults"");
	}

	public boolean onMenuItemClick(MenuItem item) {
		switch (item.getItemId()) {
			case 1:
				return onSearchRequested();
			default:
				return true;
		}
	}

	private void invalidateAllViews() {
		myThisBookView.invalidateViews();
		myThisBookView.requestLayout();
		myAllBooksView.invalidateViews();
		myAllBooksView.requestLayout();
		if (mySearchResultsView != null) {
			mySearchResultsView.invalidateViews();
			mySearchResultsView.requestLayout();
		}
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final ListView view = (ListView)getTabHost().getCurrentView();
		final Bookmark bookmark = ((BookmarksAdapter)view.getAdapter()).getItem(position);
		switch (item.getItemId()) {
			case OPEN_ITEM_ID:
				gotoBookmark(bookmark);
				return true;
			case EDIT_ITEM_ID:
        		final Intent intent = new Intent(this, BookmarkEditActivity.class);
        		startActivityForResult(intent, 1);
				// TODO: implement
				return true;
			case DELETE_ITEM_ID:
				bookmark.delete();
				myThisBookBookmarks.remove(bookmark);
				AllBooksBookmarks.remove(bookmark);
				mySearchResults.remove(bookmark);
				invalidateAllViews();
				return true;
		}
		return super.onContextItemSelected(item);
	}

	private void addBookmark() {
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		final Bookmark bookmark = fbreader.addBookmark(20, true);
		if (bookmark != null) {
			myThisBookBookmarks.add(0, bookmark);
			AllBooksBookmarks.add(0, bookmark);
			invalidateAllViews();
		}
	}

	private void gotoBookmark(Bookmark bookmark) {
		bookmark.onOpen();
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		final long bookId = bookmark.getBookId();
		if ((fbreader.Model == null) || (fbreader.Model.Book.getId() != bookId)) {
			final Book book = Book.getById(bookId);
			if (book != null) {
				finish();
				fbreader.openBook(book, bookmark);
			} else {
				UIUtil.showErrorMessage(this, ""cannotOpenBook"");
			}
		} else {
			finish();
			fbreader.gotoBookmark(bookmark);
		}
	}

	private final class BookmarksAdapter extends BaseAdapter implements AdapterView.OnItemClickListener, View.OnCreateContextMenuListener {
		private final List<Bookmark> myBookmarks;
		private final boolean myCurrentBook;

		BookmarksAdapter(ListView listView, List<Bookmark> bookmarks, boolean currentBook) {
			myBookmarks = bookmarks;
			myCurrentBook = currentBook;
			listView.setAdapter(this);
			listView.setOnItemClickListener(this);
			listView.setOnCreateContextMenuListener(this);
		}

		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			if (getItem(position) != null) {
				menu.setHeaderTitle(getItem(position).getText());
				final ZLResource resource = ZLResource.resource(""bookmarksView"");
				menu.add(0, OPEN_ITEM_ID, 0, resource.getResource(""open"").getValue());
				//menu.add(0, EDIT_ITEM_ID, 0, resource.getResource(""edit"").getValue());
				menu.add(0, DELETE_ITEM_ID, 0, resource.getResource(""delete"").getValue());
			}
		}

		public View getView(int position, View convertView, ViewGroup parent) {
			final View view = (convertView != null) ? convertView :
				LayoutInflater.from(parent.getContext()).inflate(R.layout.bookmark_item, parent, false);
			final ImageView imageView = (ImageView)view.findViewById(R.id.bookmark_item_icon);
			final TextView textView = (TextView)view.findViewById(R.id.bookmark_item_text);
			final TextView bookTitleView = (TextView)view.findViewById(R.id.bookmark_item_booktitle);

			final Bookmark bookmark = getItem(position);
			if (bookmark == null) {
				imageView.setVisibility(View.VISIBLE);
				imageView.setImageResource(R.drawable.ic_list_plus);
				textView.setText(ZLResource.resource(""bookmarksView"").getResource(""new"").getValue());
				bookTitleView.setVisibility(View.GONE);
			} else {
				imageView.setVisibility(View.GONE);
				textView.setText(bookmark.getText());
				if (myCurrentBook) {
					bookTitleView.setVisibility(View.GONE);
				} else {
					bookTitleView.setVisibility(View.VISIBLE);
					bookTitleView.setText(bookmark.getBookTitle());
				}
			}
			return view;
		}

		public final boolean areAllItemsEnabled() {
			return true;
		}

		public final boolean isEnabled(int position) {
			return true;
		}

		public final long getItemId(int position) {
			return position;
		}
	
		public final Bookmark getItem(int position) {
			if (myCurrentBook) {
				--position;
			}
			return (position >= 0) ? myBookmarks.get(position) : null;
		}

		public final int getCount() {
			return myCurrentBook ? myBookmarks.size() + 1 : myBookmarks.size();
		}

		public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
			final Bookmark bookmark = getItem(position);
			if (bookmark != null) {
				gotoBookmark(bookmark);
			} else {
				addBookmark();
			}
		}
	}
}
",True,220,0,0,6,67,0,10,L7
203,org.geometerplus.android.fbreader.ShowMenuAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowMenuAction extends FBAndroidAction {
	ShowMenuAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public void run() {
		BaseActivity.openOptionsMenu();
	}
}
",False,421,0,0,8,96,1,3,L6
204,org.geometerplus.android.fbreader.FBAndroidAction.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

abstract class FBAndroidAction extends FBAction {
	protected final FBReader BaseActivity;

	FBAndroidAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(fbreader);
		BaseActivity = baseActivity;
	}
}
",False,421,0,0,8,96,16,3,L6
205,org.geometerplus.android.fbreader.CancelActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.ListActivity;
import android.content.Intent;
import android.os.Bundle;
import android.widget.*;
import android.view.*;

import org.geometerplus.zlibrary.ui.android.R;

public class CancelActivity extends ListActivity {
	static final String LIST_SIZE = ""listSize"";
	static final String ITEM_TITLE = ""title"";
	static final String ITEM_SUMMARY = ""summary"";

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		final ActionListAdapter adapter = new ActionListAdapter(getIntent());
		setListAdapter(adapter);
		getListView().setOnItemClickListener(adapter);
		setResult(-1);
	}

	private class ActionListAdapter extends BaseAdapter implements AdapterView.OnItemClickListener {
		private final Intent myIntent;

		ActionListAdapter(Intent intent) {
			myIntent = intent;
		}

		public final int getCount() {
			return myIntent.getIntExtra(LIST_SIZE, 0);
		}

		public final Integer getItem(int position) {
			return position;
		}

		public final long getItemId(int position) {
			return position;
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final View view = convertView != null
				? convertView
				: LayoutInflater.from(parent.getContext()).inflate(R.layout.cancel_item, parent, false);
			final TextView titleView = (TextView)view.findViewById(R.id.cancel_item_title);
			final TextView summaryView = (TextView)view.findViewById(R.id.cancel_item_summary);
			final String title = myIntent.getStringExtra(ITEM_TITLE + position);
			final String summary = myIntent.getStringExtra(ITEM_SUMMARY + position);
			titleView.setText(title);
			if (summary != null) {
				summaryView.setVisibility(View.VISIBLE);
				summaryView.setText(summary);
				titleView.setLayoutParams(new LinearLayout.LayoutParams(
					LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT
				));
			} else {
				summaryView.setVisibility(View.GONE);
				titleView.setLayoutParams(new LinearLayout.LayoutParams(
					LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.FILL_PARENT
				));
			}
			return view;
		}

		public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
			setResult((int)id + 1);
			finish();
		}
	}
}
",False,55,6,27,0,0,1,0,L6
206,org.geometerplus.android.fbreader.SelectionHidePanelAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class SelectionHidePanelAction extends FBAndroidAction {
	SelectionHidePanelAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	@Override
	protected void run() {
		BaseActivity.hideSelectionPanel();
	}
}
",False,421,0,0,8,96,1,3,L6
207,org.geometerplus.android.fbreader.SearchAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class SearchAction extends FBAndroidAction {
	SearchAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public boolean isVisible() {
		return Reader.Model != null;
	}

	public void run() {
		BaseActivity.onSearchRequested();
	}
}
",False,421,0,0,8,96,1,4,L6
208,org.geometerplus.android.fbreader.DictionaryUtil.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.app.*;
import android.content.*;
import android.net.Uri;
import android.util.DisplayMetrics;
import android.view.Gravity;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.zlibrary.text.view.ZLTextRegion;
import org.geometerplus.zlibrary.text.view.ZLTextWord;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.util.PackageUtil;

public abstract class DictionaryUtil {
	// Map: dictionary info -> hide if package is not installed
	private static LinkedHashMap<PackageInfo,Boolean> ourDictionaryInfos =
		new LinkedHashMap<PackageInfo,Boolean>();
	private static ZLStringOption ourSingleWordTranslatorOption;
	private static ZLStringOption ourMultiWordTranslatorOption;

	private static class InfoReader extends ZLXMLReaderAdapter {
		@Override
		public boolean dontCacheAttributeValues() {
			return true;
		}

		@Override
		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			if (""dictionary"".equals(tag)) {
				final String id = attributes.getValue(""id"");
				final String title = attributes.getValue(""title"");
				ourDictionaryInfos.put(new PackageInfo(
					id,
					attributes.getValue(""package""),
					attributes.getValue(""class""),
					title != null ? title : id,
					attributes.getValue(""action""),
					attributes.getValue(""dataKey""),
					attributes.getValue(""pattern"")
				), !""always"".equals(attributes.getValue(""list"")));
			}
			return false;
		}
	}

	private interface ColorDict3 {
		String ACTION = ""colordict.intent.action.SEARCH"";
		String QUERY = ""EXTRA_QUERY"";
		String HEIGHT = ""EXTRA_HEIGHT"";
		String WIDTH = ""EXTRA_WIDTH"";
		String GRAVITY = ""EXTRA_GRAVITY"";
		String MARGIN_LEFT = ""EXTRA_MARGIN_LEFT"";
		String MARGIN_TOP = ""EXTRA_MARGIN_TOP"";
		String MARGIN_BOTTOM = ""EXTRA_MARGIN_BOTTOM"";
		String MARGIN_RIGHT = ""EXTRA_MARGIN_RIGHT"";
		String FULLSCREEN = ""EXTRA_FULLSCREEN"";
	}

	private static Map<PackageInfo,Boolean> infos() {
		if (ourDictionaryInfos.isEmpty()) {
			new InfoReader().read(ZLFile.createFileByPath(""dictionaries.xml""));
		}
		return ourDictionaryInfos;
	}

	public static List<PackageInfo> dictionaryInfos(Context context) {
		final LinkedList<PackageInfo> list = new LinkedList<PackageInfo>();
		for (Map.Entry<PackageInfo,Boolean> entry : infos().entrySet()) {
			final PackageInfo info = entry.getKey();
			if (!entry.getValue() ||
				PackageUtil.canBeStarted(context, getDictionaryIntent(info, ""test""), false)) {
				list.add(info);
			}
		}
		return list;
	}

	private static PackageInfo firstInfo() {
		for (Map.Entry<PackageInfo,Boolean> entry : infos().entrySet()) {
			if (!entry.getValue()) {
				return entry.getKey();
			}
		}
		throw new RuntimeException(""There are no available dictionary infos"");
	}

	public static ZLStringOption singleWordTranslatorOption() {
		if (ourSingleWordTranslatorOption == null) {
			ourSingleWordTranslatorOption = new ZLStringOption(""Dictionary"", ""Id"", firstInfo().Id);
		}
		return ourSingleWordTranslatorOption;
	}

	public static ZLStringOption multiWordTranslatorOption() {
		if (ourMultiWordTranslatorOption == null) {
			ourMultiWordTranslatorOption = new ZLStringOption(""Translator"", ""Id"", firstInfo().Id);
		}
		return ourMultiWordTranslatorOption;
	}

	private static PackageInfo getCurrentDictionaryInfo(boolean singleWord) {
		final ZLStringOption option = singleWord
			? singleWordTranslatorOption() : multiWordTranslatorOption();
		final String id = option.getValue();
		for (PackageInfo info : infos().keySet()) {
			if (info.Id.equals(id)) {
				return info;
			}
		}
		return firstInfo();
	}

	private static Intent getDictionaryIntent(String text, boolean singleWord) {
		return getDictionaryIntent(getCurrentDictionaryInfo(singleWord), text);
	}

	public static Intent getDictionaryIntent(PackageInfo dictionaryInfo, String text) {
		final Intent intent = new Intent(dictionaryInfo.IntentAction);
		if (dictionaryInfo.PackageName != null) {
			String cls = dictionaryInfo.ClassName;
			if (cls != null && cls.startsWith(""."")) {
				cls = dictionaryInfo.PackageName + cls;
			}
			intent.setComponent(new ComponentName(
				dictionaryInfo.PackageName, cls
			));
		}
		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		text = dictionaryInfo.IntentDataPattern.replace(""%s"", text);
		if (dictionaryInfo.IntentKey != null) {
			return intent.putExtra(dictionaryInfo.IntentKey, text);
		} else {
			return intent.setData(Uri.parse(text));
		}			
	}

	public static void openTextInDictionary(Activity activity, String text, boolean singleWord, int selectionTop, int selectionBottom) {
		if (singleWord) {
			int start = 0;
			int end = text.length();
			for (; start < end && !Character.isLetterOrDigit(text.charAt(start)); ++start);
			for (; start < end && !Character.isLetterOrDigit(text.charAt(end - 1)); --end);
			if (start == end) {
				return;
			}
			text = text.substring(start, end);
		}

		final PackageInfo info = getCurrentDictionaryInfo(singleWord);
		final Intent intent = getDictionaryIntent(info, text);
		try {
			if (""ColorDict"".equals(info.Id)) {
				final DisplayMetrics metrics = new DisplayMetrics();
				activity.getWindowManager().getDefaultDisplay().getMetrics(metrics);
				final int screenHeight = metrics.heightPixels;
				final int topSpace = selectionTop;
				final int bottomSpace = metrics.heightPixels - selectionBottom;
				final boolean showAtBottom = bottomSpace >= topSpace;
				final int space = (showAtBottom ? bottomSpace : topSpace) - 20;
				final int maxHeight = Math.min(400, screenHeight * 2 / 3);
				final int minHeight = Math.min(200, screenHeight * 2 / 3);
				intent.putExtra(ColorDict3.HEIGHT, Math.max(minHeight, Math.min(maxHeight, space)));
				intent.putExtra(ColorDict3.GRAVITY, showAtBottom ? Gravity.BOTTOM : Gravity.TOP);
				final ZLAndroidApplication application = ZLAndroidApplication.Instance();
				intent.putExtra(ColorDict3.FULLSCREEN, !application.ShowStatusBarOption.getValue());
			}
			activity.startActivity(intent);
		} catch (ActivityNotFoundException e) {
			DictionaryUtil.installDictionaryIfNotInstalled(activity, singleWord);
		}
	}

	public static void openWordInDictionary(Activity activity, ZLTextWord word, ZLTextRegion region) { 
		openTextInDictionary(
			activity, word.toString(), true, region.getTop(), region.getBottom()
		);
	}

	public static void installDictionaryIfNotInstalled(final Activity activity, boolean singleWord) {
		if (PackageUtil.canBeStarted(activity, getDictionaryIntent(""test"", singleWord), false)) {
			return;
		}
		final PackageInfo dictionaryInfo = getCurrentDictionaryInfo(singleWord);

		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource installResource = dialogResource.getResource(""installDictionary"");
		new AlertDialog.Builder(activity)
			.setTitle(installResource.getResource(""title"").getValue())
			.setMessage(installResource.getResource(""message"").getValue().replace(""%s"", dictionaryInfo.Title))
			.setIcon(0)
			.setPositiveButton(
				buttonResource.getResource(""install"").getValue(),
				new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface dialog, int which) {
						installDictionary(activity, dictionaryInfo);
					}
				}
			)
			.setNegativeButton(buttonResource.getResource(""skip"").getValue(), null)
			.create().show();
	}

	private static void installDictionary(Activity activity, PackageInfo dictionaryInfo) {
		if (!PackageUtil.installFromMarket(activity, dictionaryInfo.PackageName)) {
			UIUtil.showErrorMessage(activity, ""cannotRunAndroidMarket"", dictionaryInfo.Title);
		}
	}
}
",False,151,6,25,7,26,4,12,L6
209,org.geometerplus.android.fbreader.ButtonsPopupPanel.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.ArrayList;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

import android.content.Context;
import android.view.View;
import android.widget.RelativeLayout;
import android.widget.ZoomButton;

abstract class ButtonsPopupPanel extends PopupPanel implements View.OnClickListener {
	class ActionButton extends ZoomButton {
		final String ActionId;
		final boolean IsCloseButton;

		ActionButton(Context context, String actionId, boolean isCloseButton) {
			super(context);
			ActionId = actionId;
			IsCloseButton = isCloseButton;
		}
	}

	private final ArrayList<ActionButton> myButtons = new ArrayList<ActionButton>();

	ButtonsPopupPanel(FBReaderApp fbReader) {
		super(fbReader);
	}

	protected void addButton(String actionId, boolean isCloseButton, int imageId) {
		final ActionButton button = new ActionButton(myWindow.getContext(), actionId, isCloseButton);
		button.setImageResource(imageId);
		myWindow.addView(button);
		button.setOnClickListener(this);
		myButtons.add(button);
	}

	@Override
	protected void update() {
		for (ActionButton button : myButtons) {
			button.setEnabled(Application.isActionEnabled(button.ActionId));
		}
	}

	public void onClick(View view) {
		final ActionButton button = (ActionButton)view;
		Application.doAction(button.ActionId);
		if (button.IsCloseButton) {
			storePosition();
			StartPosition = null;
			Application.hideActivePopup();
		}
	}
}
",False,421,0,0,9,103,2,4,L6
210,org.geometerplus.android.fbreader.SelectionShowPanelAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class SelectionShowPanelAction extends FBAndroidAction {
	SelectionShowPanelAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	@Override
	public boolean isEnabled() {
		return !Reader.getTextView().isSelectionEmpty();
	}

	@Override
	protected void run() {
		BaseActivity.showSelectionPanel();
	}
}
",False,421,0,0,8,91,1,5,L6
211,org.geometerplus.android.fbreader.ShowBookInfoAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowBookInfoAction extends FBAndroidAction {
	ShowBookInfoAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public boolean isVisible() {
		return Reader.Model != null;
	}

	public void run() {
		BaseActivity.startActivityForResult(
			new Intent(BaseActivity.getApplicationContext(), BookInfoActivity.class)
				.putExtra(BookInfoActivity.CURRENT_BOOK_PATH_KEY, Reader.Model.Book.File.getPath())
				.putExtra(BookInfoActivity.HIDE_OPEN_BUTTON_KEY, true),
			FBReader.REPAINT_CODE
		);
	}
}
",False,421,0,0,8,96,1,8,L6
212,org.geometerplus.android.fbreader.BookmarkEditActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.Bundle;
import android.app.Activity;
import android.view.*;
import android.widget.*;
import android.content.Context;


class SimpleContainer extends ViewGroup {
	private final View myEditText;
	private final Button myOkButton;
	private final Button myCancelButton;

	SimpleContainer(Context context) {
		super(context);
		myEditText = new EditText(context);
		myOkButton = new Button(context);
		myOkButton.setText(""ok"");
		myCancelButton = new Button(context);
		myCancelButton.setText(""cancel"");
		addView(myOkButton);
		addView(myCancelButton);
		addView(myEditText);
	}

	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
		final int buttonHeight = Math.max(54, Math.max(myOkButton.getHeight(), myCancelButton.getHeight()));
		myEditText.layout(left + 8, top + 8, right - 8, bottom - buttonHeight - 16);
		myOkButton.layout(left + 8, bottom - buttonHeight - 8, (left + right) / 2 - 4, bottom - 8);
		myCancelButton.layout((left + right) / 2 + 4, bottom - buttonHeight - 8, right - 8, bottom - 8);
	}
}

public class BookmarkEditActivity extends Activity {
	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		final SimpleContainer container = new SimpleContainer(this);
		setContentView(container);
	}
}
",False,1,0,0,0,0,0,0,I0
213,org.geometerplus.android.fbreader.PopupPanel.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.view.View;
import android.view.ViewGroup;
import android.widget.RelativeLayout;

import org.geometerplus.zlibrary.core.application.ZLApplication;

import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

abstract class PopupPanel extends ZLApplication.PopupPanel {
	public ZLTextWordCursor StartPosition;

	protected PopupWindow myWindow;

	PopupPanel(FBReaderApp fbReader) {
		super(fbReader);
	}

	protected final FBReaderApp getReader() {
		return (FBReaderApp)Application;
	}

	@Override
	protected void show_() {
		if (myWindow != null) {
			myWindow.show();
		}
	}

	@Override
	protected void hide_() {
		if (myWindow != null) {
			myWindow.hide();
		}
	}

	private final void removeWindow() {
		if (myWindow != null) {
			ViewGroup root = (ViewGroup)myWindow.getParent();
			myWindow.hide();
			root.removeView(myWindow);
			myWindow = null;
		}
	}

	public static void removeAllWindows(ZLApplication application) {
		for (ZLApplication.PopupPanel popup : application.popupPanels()) {
			((PopupPanel)popup).removeWindow();
		}
	}

	public static void restoreVisibilities(ZLApplication application) {
		final PopupPanel popup = (PopupPanel)application.getActivePopup();
		if (popup != null) {
			popup.show_();
		}
	}

	public final void initPosition() {
		if (StartPosition == null) {
			StartPosition = new ZLTextWordCursor(getReader().getTextView().getStartCursor());
		}
	}

	public final void storePosition() {
		if (StartPosition != null &&
			!StartPosition.equals(getReader().getTextView().getStartCursor())) {
			getReader().addInvisibleBookmark(StartPosition);
		}
	}

	public abstract void createControlPanel(FBReader activity, RelativeLayout root, PopupWindow.Location location);
}
",False,421,0,0,8,88,5,7,L6
214,org.geometerplus.android.fbreader.ShowBookmarksAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowBookmarksAction extends RunActivityAction {
	ShowBookmarksAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader, BookmarksActivity.class);
	}
}
",False,421,0,0,8,96,1,3,L6
215,org.geometerplus.android.fbreader.ProcessHyperlinkAction.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;
import android.content.ActivityNotFoundException;
import android.net.Uri;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.bookmodel.FBHyperlinkType;
import org.geometerplus.fbreader.network.NetworkLibrary;

import org.geometerplus.android.fbreader.network.BookDownloader;
import org.geometerplus.android.fbreader.network.BookDownloaderService;
import org.geometerplus.android.fbreader.image.ImageViewActivity;

class ProcessHyperlinkAction extends FBAndroidAction {
	private static final String ACTION_LINK_PREFIX = ""fbreader-action://"";

	ProcessHyperlinkAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader);
	}

	public boolean isEnabled() {
		return Reader.getTextView().getSelectedRegion() != null;
	}

	public void run() {
		final ZLTextRegion region = Reader.getTextView().getSelectedRegion();
		if (region == null) {
			return;
		}

		final ZLTextRegion.Soul soul = region.getSoul();
		if (soul instanceof ZLTextHyperlinkRegionSoul) {
			Reader.getTextView().hideSelectedRegionBorder();
			Reader.getViewWidget().repaint();
			final ZLTextHyperlink hyperlink = ((ZLTextHyperlinkRegionSoul)soul).Hyperlink;
			switch (hyperlink.Type) {
				case FBHyperlinkType.EXTERNAL:
					if (hyperlink.Id.startsWith(ACTION_LINK_PREFIX)) {
						Reader.doAction(hyperlink.Id.substring(ACTION_LINK_PREFIX.length()));
					} else {
						openInBrowser(hyperlink.Id);
					}
					break;
				case FBHyperlinkType.INTERNAL:
					Reader.Model.Book.markHyperlinkAsVisited(hyperlink.Id);
					Reader.tryOpenFootnote(hyperlink.Id);
					break;
			}
		} else if (soul instanceof ZLTextImageRegionSoul) {
			Reader.getTextView().hideSelectedRegionBorder();
			Reader.getViewWidget().repaint();
			final String uriString = ((ZLTextImageRegionSoul)soul).ImageElement.URI;
			if (uriString != null) {
				try {
					final Intent intent = new Intent();
					intent.setClass(BaseActivity, ImageViewActivity.class);
					intent.setData(Uri.parse(uriString));
					intent.putExtra(
						ImageViewActivity.BACKGROUND_COLOR_KEY,
						Reader.ImageViewBackgroundOption.getValue().getIntValue()
					);
					BaseActivity.startActivity(intent);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		} else if (soul instanceof ZLTextWordRegionSoul) {
			DictionaryUtil.openWordInDictionary(
				BaseActivity, ((ZLTextWordRegionSoul)soul).Word, region
			);
		}
	}

	private void openInBrowser(String urlString) {
		final Intent intent = new Intent(Intent.ACTION_VIEW);
		boolean externalUrl = true;
		if (BookDownloader.acceptsUri(Uri.parse(urlString))) {
			intent.setClass(BaseActivity, BookDownloader.class);
			intent.putExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY, BookDownloaderService.Notifications.ALL);
			externalUrl = false;
		}
		final NetworkLibrary nLibrary = NetworkLibrary.Instance();
		try {
			nLibrary.initialize();
		} catch (ZLNetworkException e) {
		}
		intent.setData(Uri.parse(NetworkLibrary.Instance().rewriteUrl(urlString, externalUrl)));
		try {
			BaseActivity.startActivity(intent);
		} catch (ActivityNotFoundException e) {
			// TODO: show an error message
		}
	}
}
",True,421,0,0,7,135,1,24,L6
216,org.geometerplus.android.fbreader.TextSearchPopup.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.ArrayList;

import android.widget.RelativeLayout;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.fbreader.ActionCode;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

final class TextSearchPopup extends ButtonsPopupPanel {
	final static String ID = ""TextSearchPopup"";

	TextSearchPopup(FBReaderApp fbReader) {
		super(fbReader);
	}

	@Override
	public String getId() {
		return ID;
	}

	@Override
	protected void hide_() {
		getReader().getTextView().clearFindResults();
		super.hide_();
	}

	@Override
	public void createControlPanel(FBReader activity, RelativeLayout root, PopupWindow.Location location) {
		if (myWindow != null) {
			return;
		}

		myWindow = new PopupWindow(activity, root, location, false);

		addButton(ActionCode.FIND_PREVIOUS, false, R.drawable.text_search_previous);
		addButton(ActionCode.CLEAR_FIND_RESULTS, true, R.drawable.text_search_close);
		addButton(ActionCode.FIND_NEXT, false, R.drawable.text_search_next);
	}
}
",False,421,0,0,8,88,1,7,L6
217,org.geometerplus.android.fbreader.ZLTreeAdapter.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.HashSet;

import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.ui.android.R;

abstract class ZLTreeAdapter extends BaseAdapter implements AdapterView.OnItemClickListener, View.OnCreateContextMenuListener {
	private final ListView myParent;
	private ZLTree<?> myTree;
	private ZLTree<?>[] myItems;
	private final HashSet<ZLTree<?>> myOpenItems = new HashSet<ZLTree<?>>();

	protected ZLTreeAdapter(ListView parent, ZLTree<?> tree) {
		myParent = parent;
		myTree = tree;
		myItems = new ZLTree[tree.getSize() - 1];
		myOpenItems.add(tree);

		parent.setAdapter(this);
		parent.setOnItemClickListener(this);
		parent.setOnCreateContextMenuListener(this);
	}

	protected final void openTree(ZLTree<?> tree) {
		if (tree == null) {
			return;
		}
		while (!myOpenItems.contains(tree)) {
			myOpenItems.add(tree);
			tree = tree.Parent;
		}
	}

	public final void expandOrCollapseTree(ZLTree<?> tree) {
		if (!tree.hasChildren()) {
			return;
		}
		if (isOpen(tree)) {
			myOpenItems.remove(tree);
		} else {
			myOpenItems.add(tree);
		}
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public final boolean isOpen(ZLTree<?> tree) {
		return myOpenItems.contains(tree);
	}

	public final void selectItem(ZLTree<?> tree) {
		if (tree == null) {
			return;
		}
		openTree(tree.Parent);
		int index = 0;
		while (true) {
			ZLTree<?> parent = tree.Parent;
			if (parent == null) {
				break;
			}
			for (ZLTree<?> sibling : parent.subTrees()) {
				if (sibling == tree) {
					break;
				}
				index += getCount(sibling);
			}
			tree = parent;
			++index;
		}
		if (index > 0) {
			myParent.setSelection(index - 1);
		}
	}

	private int getCount(ZLTree<?> tree) {
		int count = 1;
		if (isOpen(tree)) {
			for (ZLTree<?> subtree : tree.subTrees()) {
				count += getCount(subtree);
			}
		}
		return count;
	}

	public final int getCount() {
		return getCount(myTree) - 1;
	}

	private final int indexByPosition(int position, ZLTree<?> tree) {
		if (position == 0) {
			return 0;
		}
		--position;
		int index = 1;
		for (ZLTree<?> subtree : tree.subTrees()) {
			int count = getCount(subtree);
			if (count <= position) {
				position -= count;
				index += subtree.getSize();
			} else {
				return index + indexByPosition(position, subtree);
			}
		}
		throw new RuntimeException(""That's impossible!!!"");
	}

	public final ZLTree<?> getItem(int position) {
		final int index = indexByPosition(position + 1, myTree) - 1;
		ZLTree<?> item = myItems[index];
		if (item == null) {
			item = myTree.getTreeByParagraphNumber(index + 1);
			myItems[index] = item;
		}
		return item;
	}

	public final boolean areAllItemsEnabled() {
		return true;
	}

	public final boolean isEnabled(int position) {
		return true;
	}

	public final long getItemId(int position) {
		return indexByPosition(position + 1, myTree);
	}

	protected boolean runTreeItem(ZLTree<?> tree) {
		if (!tree.hasChildren()) {
			return false;
		}
		expandOrCollapseTree(tree);
		return true;
	}

	protected void resetTree(ZLTree<?> tree) {
		myTree = tree;
		myItems = new ZLTree[tree.getSize() - 1];
		myOpenItems.clear();
		myOpenItems.add(tree);
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public void resetTree() {
		myItems = new ZLTree[myTree.getSize() - 1];
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
		runTreeItem(getItem(position));
	}

	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
	}

	public abstract View getView(int position, View convertView, ViewGroup parent);

	protected final void setIcon(ImageView imageView, ZLTree<?> tree) {
		if (tree.hasChildren()) {
			if (isOpen(tree)) {
				imageView.setImageResource(R.drawable.ic_list_group_open);
			} else {
				imageView.setImageResource(R.drawable.ic_list_group_closed);
			}
		} else {
			imageView.setImageResource(R.drawable.ic_list_group_empty);
		}
		imageView.setPadding(25 * (tree.Level - 1), imageView.getPaddingTop(), 0, imageView.getPaddingBottom());
	}
}
",False,3,1,1,1,1,1,1,L7
218,org.geometerplus.android.fbreader.SelectionBookmarkAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.library.Bookmark;
import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.fbreader.FBView;

import org.geometerplus.android.util.UIUtil;

public class SelectionBookmarkAction extends FBAndroidAction {
	SelectionBookmarkAction(FBReader baseApplication, FBReaderApp fbreader) {
		super(baseApplication, fbreader);
	}

	public void run() {
		final FBView fbview = Reader.getTextView();
		final String text = fbview.getSelectedText();

		new Bookmark(
			Reader.Model.Book,
			fbview.getModel().getId(),
			fbview.getSelectionStartPosition(), 
			text,
			true
		).save();
        fbview.clearSelection();

		UIUtil.showMessageText(
			BaseActivity,
			ZLResource.resource(""selection"").getResource(""bookmarkCreated"").getValue().replace(""%s"", text)
		);
	}
}
",False,421,0,0,8,108,1,11,L6
219,org.geometerplus.android.fbreader.ShowTOCAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowTOCAction extends RunActivityAction {
	ShowTOCAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader, TOCActivity.class);
	}

	public boolean isVisible() {
		return (Reader.Model != null) && Reader.Model.TOCTree.hasChildren();
	}
}
",False,421,0,0,8,102,1,6,L6
220,org.geometerplus.android.fbreader.image.ImageViewActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.image;

import android.app.Activity;
import android.content.Intent;
import android.graphics.*;
import android.net.Uri;
import android.os.Bundle;
import android.view.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.*;
import org.geometerplus.zlibrary.core.util.MimeType;
import org.geometerplus.zlibrary.core.util.ZLColor;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;
import org.geometerplus.zlibrary.ui.android.util.ZLAndroidColorUtil;

public class ImageViewActivity extends Activity {
	public static final String BACKGROUND_COLOR_KEY = ""bgColor"";

	private Bitmap myBitmap;
	private ZLColor myBgColor;

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();
		final boolean showStatusBar = application.ShowStatusBarOption.getValue();
		getWindow().setFlags(
			WindowManager.LayoutParams.FLAG_FULLSCREEN,
			showStatusBar ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN
		);

		Thread.setDefaultUncaughtExceptionHandler(
			new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this)
		);

		setContentView(new ImageView());

		final Intent intent = getIntent();

		myBgColor = new ZLColor(
			intent.getIntExtra(BACKGROUND_COLOR_KEY, new ZLColor(127, 127, 127).getIntValue())
		);

		final Uri uri = intent.getData();
		if (ZLFileImage.SCHEME.equals(uri.getScheme())) {
			try {
				final String[] data = uri.getPath().split(""\000"");
				final ZLFileImage image = new ZLFileImage(
					MimeType.IMAGE_AUTO,
					ZLFile.createFileByPath(data[0]),
					Integer.parseInt(data[1]),
					Integer.parseInt(data[2])
				);
				final ZLImageData imageData = ZLImageManager.Instance().getImageData(image);
				myBitmap = ((ZLAndroidImageData)imageData).getFullSizeBitmap();
			} catch (Exception e) {
				// TODO: error message (?)
				finish();
			}
		} else {
			// TODO: error message (?)
			finish();
		}
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
		if (myBitmap != null) {
			myBitmap.recycle();
		}
		myBitmap = null;
	}

	private class ImageView extends View {
		private final Paint myPaint = new Paint();

		private int myDx;
		private int myDy;

		ImageView() {
			super(ImageViewActivity.this);
		}

		@Override
		protected void onDraw(final Canvas canvas) {
			myPaint.setColor(ZLAndroidColorUtil.rgb(myBgColor));
			final int w = getWidth();
			final int h = getHeight();
			canvas.drawRect(0, 0, w, h, myPaint);
			if (myBitmap == null || myBitmap.isRecycled()) {
				return;
			}

			final int bw = myBitmap.getWidth();
			final int bh = myBitmap.getHeight();
			
			final int left, top;
			if (bw <= w) {
				left = (w - bw) / 2;
			} else {
				left = Math.max(w - bw, Math.min(0, (w - bw) / 2 + myDx));
			}
			if (bh <= h) {
				top = (h - bh) / 2;
			} else {
				top = Math.max(h - bh, Math.min(0, (h - bh) / 2 + myDy));
			}
			canvas.drawBitmap(myBitmap, left, top, myPaint);
		}

		private void shift(int dx, int dy) {
			if (myBitmap == null || myBitmap.isRecycled()) {
				return;
			}

			final int w = getWidth();
			final int h = getHeight();
			final int bw = myBitmap.getWidth();
			final int bh = myBitmap.getHeight();

			final int newDx, newDy;

			if (w < bw) {
				final int delta = bw - w;
				newDx = Math.max(-delta, Math.min(delta, myDx + dx));
			} else {
				newDx = myDx;
			}
			if (h < bh) {
				final int delta = bh - h;
				newDy = Math.max(-delta, Math.min(delta, myDy + dy));
			} else {
				newDy = myDy;
			}

			if (newDx != myDx || newDy != myDy) {
				myDx = newDx;
				myDy = newDy;
				postInvalidate();
			}
		}

		private boolean myMotionControl;
		private int mySavedX;
		private int mySavedY;
		@Override
		public boolean onTouchEvent(MotionEvent event) {
			int x = (int)event.getX();
			int y = (int)event.getY();

			switch (event.getAction()) {
				case MotionEvent.ACTION_UP:
					myMotionControl = false;
					break;
				case MotionEvent.ACTION_DOWN:
					myMotionControl = true;
					mySavedX = x;
					mySavedY = y;
					break;
				case MotionEvent.ACTION_MOVE:
					if (myMotionControl) {
						shift(x - mySavedX, y - mySavedY);
					}
					myMotionControl = true;
					mySavedX = x;
					mySavedY = y;
					break;
			}
			return true;
		}
	}
}
",True,138,6,27,8,18,1,11,L6
221,org.geometerplus.android.fbreader.library.LibraryTreeActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.ListView;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.BookTree;
import org.geometerplus.fbreader.tree.FBTree;

public class LibraryTreeActivity extends LibraryBaseActivity {
	private String myTreePathString;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		if (DatabaseInstance == null || LibraryInstance == null) {
			finish();
			return;
		}

		final Intent intent = getIntent();
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			if (runSearch(intent)) {
				startActivity(intent
					.setAction(ACTION_FOUND)
					.setClass(getApplicationContext(), LibraryTopLevelActivity.class)
					.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK)
				);
			} else {
				showNotFoundToast();
				finish();
			}
			return;
		}

		myTreePathString = intent.getStringExtra(TREE_PATH_KEY);
        
		final String[] path = myTreePathString.split(""\000"");
        
		String title = null;
		if (path.length == 1) {
			title = myResource.getResource(path[0]).getResource(""summary"").getValue();
			final String parameter = intent.getStringExtra(PARAMETER_KEY);
			if (parameter != null) {
				title = title.replace(""%s"", parameter);
			}
		} else {
			title = path[path.length - 1];
		}
		setTitle(title);

		FBTree tree = null;
		if (PATH_RECENT.equals(path[0])) {
			tree = LibraryInstance.recentBooks();
		} else if (PATH_SEARCH_RESULTS.equals(path[0])) {
			tree = LibraryInstance.searchResults();
		} else if (PATH_BY_AUTHOR.equals(path[0])) {
			tree = LibraryInstance.byAuthor();
		} else if (PATH_BY_TITLE.equals(path[0])) {
			tree = LibraryInstance.byTitle();
		} else if (PATH_BY_TAG.equals(path[0])) {
			tree = LibraryInstance.byTag();
		} else if (PATH_FAVORITES.equals(path[0])) {
			tree = LibraryInstance.favorites();
		}
        
		for (int i = 1; i < path.length; ++i) {
			if (tree == null) {
				break;
			}
			tree = tree.getSubTreeByName(path[i]);
		}

		mySelectedBook = null;
		if (mySelectedBookPath != null) {
			final ZLFile file = ZLFile.createFileByPath(mySelectedBookPath);
			if (file != null) {
				mySelectedBook = Book.getByFile(file);
			}
		}
        
		if (tree != null) {
			final LibraryAdapter adapter = new LibraryAdapter(tree.subTrees());
			setListAdapter(adapter);
			getListView().setOnCreateContextMenuListener(adapter);
			setSelection(adapter.getFirstSelectedItemIndex());
		}
	}

	@Override
	public void onListItemClick(ListView listView, View view, int position, long rowId) {
		FBTree tree = ((LibraryAdapter)getListAdapter()).getItem(position);
		if (tree instanceof BookTree) {
			showBookInfo(((BookTree)tree).Book);
		} else {
			new OpenTreeRunnable(LibraryInstance, myTreePathString + ""\000"" + tree.getName()).run();
		}
	}
}
",True,422,0,0,9,110,0,9,L7
222,org.geometerplus.android.fbreader.library.InitializationService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.os.Handler;
import android.os.Message;

public class InitializationService extends Service {
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				stopSelf();
			}
		};

		final Thread libraryInitializer = new Thread(""LibraryInitializer"") {
			public void run() {
				try {
					LibraryBaseActivity.LibraryInstance.synchronize();
				} finally {
					handler.sendMessage(handler.obtainMessage(0));
				}
			}
		};
		libraryInitializer.setPriority(Thread.MIN_PRIORITY);
		libraryInitializer.start();
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		onStart(intent, startId);
		return 0;
	}
}
",True,422,0,0,9,107,0,2,L7
223,org.geometerplus.android.fbreader.library.BaseActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.app.*;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.library.*;

import org.geometerplus.android.fbreader.FBReader;
import org.geometerplus.android.fbreader.BookInfoActivity;

abstract class BaseActivity extends ListActivity {
	public static final String SELECTED_BOOK_PATH_KEY = ""SelectedBookPath"";
	private static final int OPEN_BOOK_ITEM_ID = 0;
	private static final int SHOW_BOOK_INFO_ITEM_ID = 1;
	private static final int ADD_TO_FAVORITES_ITEM_ID = 2;
	private static final int REMOVE_FROM_FAVORITES_ITEM_ID = 3;
	private static final int DELETE_BOOK_ITEM_ID = 4;

	protected static final int CHILD_LIST_REQUEST = 0;
	protected static final int BOOK_INFO_REQUEST = 1;
	protected static final int RESULT_DONT_INVALIDATE_VIEWS = 0;
	protected static final int RESULT_DO_INVALIDATE_VIEWS = 1;

	static BooksDatabase DatabaseInstance;
	static Library LibraryInstance;

	protected final ZLResource myResource = ZLResource.resource(""libraryView"");
	protected String mySelectedBookPath;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		mySelectedBookPath = getIntent().getStringExtra(SELECTED_BOOK_PATH_KEY);
		setResult(RESULT_DONT_INVALIDATE_VIEWS);
	}

	protected void openBook(Book book) {
		startActivity(
			new Intent(getApplicationContext(), FBReader.class)
				.setAction(Intent.ACTION_VIEW)
				.putExtra(FBReader.BOOK_PATH_KEY, book.File.getPath())
				.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
		);
	}

	protected void createBookContextMenu(ContextMenu menu, Book book) {
		menu.setHeaderTitle(book.getTitle());
		menu.add(0, OPEN_BOOK_ITEM_ID, 0, myResource.getResource(""openBook"").getValue());
		menu.add(0, SHOW_BOOK_INFO_ITEM_ID, 0, myResource.getResource(""showBookInfo"").getValue());
		if (LibraryInstance.isBookInFavorites(book)) {
			menu.add(0, REMOVE_FROM_FAVORITES_ITEM_ID, 0, myResource.getResource(""removeFromFavorites"").getValue());
		} else {
			menu.add(0, ADD_TO_FAVORITES_ITEM_ID, 0, myResource.getResource(""addToFavorites"").getValue());
		}
		if ((LibraryInstance.getRemoveBookMode(book) & Library.REMOVE_FROM_DISK) != 0) {
			menu.add(0, DELETE_BOOK_ITEM_ID, 0, myResource.getResource(""deleteBook"").getValue());
        }
	}

	protected View createView(View convertView, ViewGroup parent, String name, String summary) {
		final View view = (convertView != null) ?  convertView :
			LayoutInflater.from(parent.getContext()).inflate(R.layout.library_tree_item, parent, false);

        ((TextView)view.findViewById(R.id.library_tree_item_name)).setText(name);
		((TextView)view.findViewById(R.id.library_tree_item_childrenlist)).setText(summary);
		return view;
	}

	private int myCoverWidth = -1;
	private int myCoverHeight = -1;
	private final Runnable myInvalidateViewsRunnable = new Runnable() {
		public void run() {
			getListView().invalidateViews();
		}
	};

	protected ImageView getCoverView(View parent) {
		if (myCoverWidth == -1) {
			parent.measure(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
			myCoverHeight = parent.getMeasuredHeight();
			myCoverWidth = myCoverHeight * 15 / 32;
			parent.requestLayout();
		}

		final ImageView coverView = (ImageView)parent.findViewById(R.id.library_tree_item_icon);
		coverView.getLayoutParams().width = myCoverWidth;
		coverView.getLayoutParams().height = myCoverHeight;
		coverView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
		coverView.requestLayout();
		return coverView;
	}

	protected Bitmap getCoverBitmap(ZLImage cover) {
		if (cover == null) {
			return null;
		}

		ZLAndroidImageData data = null;
		final ZLAndroidImageManager mgr = (ZLAndroidImageManager)ZLAndroidImageManager.Instance();
		if (cover instanceof ZLLoadableImage) {
			final ZLLoadableImage img = (ZLLoadableImage)cover;
			if (img.isSynchronized()) {
				data = mgr.getImageData(img);
			} else {
				img.startSynchronization(myInvalidateViewsRunnable);
			}
		} else {
			data = mgr.getImageData(cover);
		}
		return data != null ? data.getBitmap(2 * myCoverWidth, 2 * myCoverHeight) : null;
	}

	private class BookDeleter implements DialogInterface.OnClickListener {
		private final Book myBook;
		private final int myMode;

		BookDeleter(Book book, int removeMode) {
			myBook = book;
			myMode = removeMode;
		}

		public void onClick(DialogInterface dialog, int which) {
			deleteBook(myBook, myMode);
			setResult(RESULT_DO_INVALIDATE_VIEWS);
		}
	}

	private void tryToDeleteBook(Book book) {
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource boxResource = dialogResource.getResource(""deleteBookBox"");
		new AlertDialog.Builder(this)
			.setTitle(book.getTitle())
			.setMessage(boxResource.getResource(""message"").getValue())
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new BookDeleter(book, Library.REMOVE_FROM_DISK))
			.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
			.create().show();
	}

	protected void deleteBook(Book book, int mode) {
		LibraryInstance.removeBook(book, mode);
	}

	protected void showBookInfo(Book book) {
		startActivityForResult(
			new Intent(getApplicationContext(), BookInfoActivity.class)
				.putExtra(BookInfoActivity.CURRENT_BOOK_PATH_KEY, book.File.getPath()),
			BOOK_INFO_REQUEST
		);
	}

	protected boolean onContextItemSelected(int itemId, Book book) {
		switch (itemId) {
			case OPEN_BOOK_ITEM_ID:
				openBook(book);
				return true;
			case SHOW_BOOK_INFO_ITEM_ID:
				showBookInfo(book);
				return true;
			case ADD_TO_FAVORITES_ITEM_ID:
				LibraryInstance.addBookToFavorites(book);
				return true;
			case REMOVE_FROM_FAVORITES_ITEM_ID:
				LibraryInstance.removeBookFromFavorites(book);
				getListView().invalidateViews();
				return true;
			case DELETE_BOOK_ITEM_ID:
				tryToDeleteBook(book);
				return true;
		}
		return false;
	}
}
",False,424,1,3,8,98,6,13,L6
224,org.geometerplus.android.fbreader.library.FileManager.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import java.util.*;

import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.os.Environment;
import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.Paths;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Library;
import org.geometerplus.fbreader.formats.PluginCollection;

import org.geometerplus.android.util.UIUtil;

public final class FileManager extends BaseActivity {
	public static String FILE_MANAGER_PATH = ""FileManagerPath"";
	
	private String myPath;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		if (DatabaseInstance == null || LibraryInstance == null) {
			finish();
			return;
		}

		FileListAdapter adapter = new FileListAdapter();
		setListAdapter(adapter);

		myPath = getIntent().getStringExtra(FILE_MANAGER_PATH);

		if (myPath == null) {
			setTitle(myResource.getResource(""fileTree"").getValue());
			addItem(Paths.BooksDirectoryOption().getValue(), ""fileTreeLibrary"");
			addItem(""/"", ""fileTreeRoot"");
			addItem(Environment.getExternalStorageDirectory().getPath(), ""fileTreeCard"");
			adapter.notifyDataSetChanged();
		} else {
			setTitle(myPath);
			startUpdate();
		}

		getListView().setOnCreateContextMenuListener(adapter);
		getListView().setTextFilterEnabled(true);
		getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {
			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
				runItem(((FileListAdapter)getListAdapter()).getItem(position));
			}
		});
	}

	private void startUpdate() {
		final ZLFile file = ZLFile.createFileByPath(myPath);
		if (file != null) {
			new Thread(new SmartFilter(file)).start();
		}
	}

	@Override
	protected void onActivityResult(int requestCode, int returnCode, Intent intent) {
		if (requestCode == CHILD_LIST_REQUEST && returnCode == RESULT_DO_INVALIDATE_VIEWS) {
			if (myPath != null) {
				((FileListAdapter)getListAdapter()).clear();
				startUpdate();
			}
			getListView().invalidateViews();
			setResult(RESULT_DO_INVALIDATE_VIEWS);
		} else if (requestCode == BOOK_INFO_REQUEST) {
			getListView().invalidateViews();
		}
	} 

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final FileItem fileItem = ((FileListAdapter)getListAdapter()).getItem(position);
		final Book book = fileItem.getBook(); 
		if (book != null) {
			return onContextItemSelected(item.getItemId(), book);
		}
		return super.onContextItemSelected(item);
	}

	@Override
	protected void deleteBook(Book book, int mode) {
		super.deleteBook(book, mode);
		((FileListAdapter)getListAdapter()).deleteFile(book.File);
		getListView().invalidateViews();
	}

	private void runItem(FileItem item) {
		final ZLFile file = item.getFile();
		final Book book = item.getBook();
		if (book != null) {
			showBookInfo(book);
		} else if (file.isDirectory() || file.isArchive()) {
			startActivityForResult(
				new Intent(this, FileManager.class)
					.putExtra(SELECTED_BOOK_PATH_KEY, mySelectedBookPath)
					.putExtra(FILE_MANAGER_PATH, file.getPath()),
				CHILD_LIST_REQUEST
			);
		} else {
			UIUtil.showErrorMessage(FileManager.this, ""permissionDenied"");
		}
	}

	private void addItem(String path, String resourceKey) {
		final ZLResource resource = myResource.getResource(resourceKey);
		((FileListAdapter)getListAdapter()).add(new FileItem(
			ZLFile.createFileByPath(path),
			resource.getValue(),
			resource.getResource(""summary"").getValue()
		));
	}

	private boolean isItemSelected(FileItem item) {
		if (mySelectedBookPath == null || !item.isSelectable()) {
			return false;
		}

		final ZLFile file = item.getFile();
		final String path = file.getPath();
		if (mySelectedBookPath.equals(path)) {
			return true;
		}

		String prefix = path;
		if (file.isDirectory()) {
			if (!prefix.endsWith(""/"")) {
				prefix += '/';
			}
		} else if (file.isArchive()) {
			prefix += ':';
		} else {
			return false;
		}
		return mySelectedBookPath.startsWith(prefix);
	}

	private final class FileListAdapter extends BaseAdapter implements View.OnCreateContextMenuListener {
		private List<FileItem> myItems = new ArrayList<FileItem>();

		public synchronized void clear() {
			myItems.clear();
		}

		public synchronized void add(FileItem item) {
			myItems.add(item);
		}

		public synchronized void deleteFile(ZLFile file) {
			for (FileItem item : myItems) {
				if (file.equals(item.getFile())) {
					myItems.remove(item);
					break;
				}
			}
		}

		public synchronized int getCount() {
			return myItems.size();
		}

		public synchronized FileItem getItem(int position) {
			return myItems.get(position);
		}

		public long getItemId(int position) {
			return position;
		}

		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final Book book = getItem(position).getBook();
			if (book != null) {
				createBookContextMenu(menu, book); 
			}
		}

		public View getView(int position, View convertView, ViewGroup parent) {
            final FileItem item = getItem(position);
			final View view = createView(convertView, parent, item.getName(), item.getSummary());
			if (isItemSelected(item)) {
				view.setBackgroundColor(0xff555555);
			} else {
				view.setBackgroundColor(0);
			}
			final ImageView coverView = getCoverView(view);
			final Bitmap coverBitmap = getCoverBitmap(item.getCover());

			if (coverBitmap != null) {
				coverView.setImageBitmap(coverBitmap);
			} else {
				coverView.setImageResource(item.getIcon());
			}

            return view;
		}
	}

	private final class FileItem {
		private final ZLFile myFile;
		private final String myName;
		private final String mySummary;
		private final boolean myIsSelectable;

		private ZLImage myCover = null;
		private boolean myCoverIsInitialized = false;

		public FileItem(ZLFile file, String name, String summary) {
			myFile = file;
			myName = name;
			mySummary = summary;
			myIsSelectable = false;
		}

		public FileItem(ZLFile file) {
			if (file.isArchive() && file.getPath().endsWith("".fb2.zip"")) {
				final List<ZLFile> children = file.children();
				if (children.size() == 1) {
					final ZLFile child = children.get(0);
					if (child.getPath().endsWith("".fb2"")) {
						myFile = child;
						myName = file.getLongName();
						mySummary = null;
						myIsSelectable = true;
						return;
					}
				} 
			}
			myFile = file;
			myName = null;
			mySummary = null;
			myIsSelectable = true;
		}

		public String getName() {
			return myName != null ? myName : myFile.getShortName();
		}

		public String getSummary() {
			if (mySummary != null) {
				return mySummary;
			}

			final Book book = getBook();
			if (book != null) {
				return book.getTitle();
			}

			return null;
		}

		public boolean isSelectable() {
			return myIsSelectable;
		}

		public int getIcon() {
			if (getBook() != null) {
				return R.drawable.ic_list_library_book;
			} else if (myFile.isDirectory()) {
				if (myFile.isReadable()) {
					return R.drawable.ic_list_library_folder;
				} else {
					return R.drawable.ic_list_library_permission_denied;
				}
			} else if (myFile.isArchive()) {
				return R.drawable.ic_list_library_zip;
			} else {
				System.err.println(
					""File "" + myFile.getPath() +
					"" that is not a directory, not a book and not an archive "" +
					""has been found in getIcon()""
				);
				return R.drawable.ic_list_library_permission_denied;
			}
		}

		public ZLImage getCover() {
			if (!myCoverIsInitialized) {
				myCoverIsInitialized = true;
				myCover = Library.getCover(myFile);
			}
			return myCover;
		}

		public ZLFile getFile() {
			return myFile;
		}

		public Book getBook() {
			return Book.getByFile(myFile);
		}
	}

	private final class SmartFilter implements Runnable {
		private final ZLFile myFile;

		public SmartFilter(ZLFile file) {
			myFile = file;
		}

		public void run() {
			if (!myFile.isReadable()) {
				runOnUiThread(new Runnable() {
					public void run() {
						UIUtil.showErrorMessage(FileManager.this, ""permissionDenied"");
					}
				});
				finish();
				return;
			}

			final ArrayList<ZLFile> children = new ArrayList<ZLFile>(myFile.children());
			Collections.sort(children, new FileComparator());
			for (final ZLFile file : children) {
				if (Thread.currentThread().isInterrupted()) {
					break;
				}
				if (file.isDirectory() || file.isArchive() ||
					PluginCollection.Instance().getPlugin(file) != null) {
					runOnUiThread(new Runnable() {
						public void run() {
							final FileListAdapter adapter = (FileListAdapter)getListAdapter();
							adapter.add(new FileItem(file));
							adapter.notifyDataSetChanged();
						}
					});
				}
			}
		}
	}

	private static class FileComparator implements Comparator<ZLFile> {
		public int compare(ZLFile f0, ZLFile f1) {
			return f0.getShortName().compareToIgnoreCase(f1.getShortName());
		}
	}
}
",True,422,0,0,9,112,0,10,L7
225,org.geometerplus.android.fbreader.library.KillerCallback.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Process;

public class KillerCallback extends BroadcastReceiver {
	@Override
	public void onReceive(Context context, Intent intent) {
		Process.killProcess(Process.myPid());
	}
}
",False,55,5,28,0,0,1,0,L6
226,org.geometerplus.android.fbreader.library.LibraryBaseActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import java.util.List;

import android.app.*;
import android.content.Intent;
import android.graphics.Bitmap;
import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.library.*;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

abstract class LibraryBaseActivity extends BaseActivity implements MenuItem.OnMenuItemClickListener {
	static final String TREE_PATH_KEY = ""TreePath"";
	static final String PARAMETER_KEY = ""Parameter"";

	static final String PATH_FAVORITES = ""favorites"";
	static final String PATH_SEARCH_RESULTS = ""searchResults"";
	static final String PATH_RECENT = ""recent"";
	static final String PATH_BY_AUTHOR = ""byAuthor"";
	static final String PATH_BY_TITLE = ""byTitle"";
	static final String PATH_BY_TAG = ""byTag"";

	static final ZLStringOption BookSearchPatternOption =
		new ZLStringOption(""BookSearch"", ""Pattern"", """");

	protected Book mySelectedBook;

	@Override
	protected void onActivityResult(int requestCode, int returnCode, Intent intent) {
		if (requestCode == CHILD_LIST_REQUEST && returnCode == RESULT_DO_INVALIDATE_VIEWS) {
			getListView().invalidateViews();
			setResult(RESULT_DO_INVALIDATE_VIEWS);
		}
	}

	@Override
	public boolean onSearchRequested() {
		startSearch(BookSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	protected static final String ACTION_FOUND = ""fbreader.library.intent.FOUND"";

	protected boolean runSearch(Intent intent) {
	   	final String pattern = intent.getStringExtra(SearchManager.QUERY);
		if (pattern == null || pattern.length() == 0) {
			return false;
		}
		BookSearchPatternOption.setValue(pattern);
		return LibraryInstance.searchBooks(pattern).hasChildren();
	}

	protected void showNotFoundToast() {
		UIUtil.showErrorMessage(this, ""bookNotFound"");
	}

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        addMenuItem(menu, 1, ""localSearch"", R.drawable.ic_menu_search);
        return true;
    }

    private MenuItem addMenuItem(Menu menu, int index, String resourceKey, int iconId) {
        final String label = myResource.getResource(""menu"").getResource(resourceKey).getValue();
        final MenuItem item = menu.add(0, index, Menu.NONE, label);
        item.setOnMenuItemClickListener(this);
        item.setIcon(iconId);
        return item;
    }

    public boolean onMenuItemClick(MenuItem item) {
        switch (item.getItemId()) {
            case 1:
                return onSearchRequested();
            default:
                return true;
        }
    }

	protected final class LibraryAdapter extends BaseAdapter implements View.OnCreateContextMenuListener {
		private final List<FBTree> myItems;

		public LibraryAdapter(List<FBTree> items) {
			myItems = items;
		}

		public final int getCount() {
			return myItems.size();
		}

		public int getFirstSelectedItemIndex() {
			int index = 0;
			for (FBTree t : myItems) {
				if (isTreeSelected(t)) {
					return index;
				}
				++index;
			}
			return -1;
		}

		public final FBTree getItem(int position) {
			return myItems.get(position);
		}

		public final long getItemId(int position) {
			return position;
		}

		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final LibraryTree tree = (LibraryTree)getItem(position);
			if (tree instanceof BookTree) {
				createBookContextMenu(menu, ((BookTree)tree).Book);
			}
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final FBTree tree = getItem(position);
			final View view = createView(convertView, parent, tree.getName(), tree.getSecondString());
			if (isTreeSelected(tree)) {
				view.setBackgroundColor(0xff555555);
			} else {
				view.setBackgroundColor(0);
			}

			final ImageView coverView = getCoverView(view);

			if (tree instanceof ZLAndroidTree) {
				coverView.setImageResource(((ZLAndroidTree)tree).getCoverResourceId());
			} else {
				final Bitmap coverBitmap = getCoverBitmap(tree.getCover());
				if (coverBitmap != null) {
					coverView.setImageBitmap(coverBitmap);
				} else if (tree instanceof AuthorTree) {
					coverView.setImageResource(R.drawable.ic_list_library_author);
				} else if (tree instanceof TagTree) {
					coverView.setImageResource(R.drawable.ic_list_library_tag);
				} else if (tree instanceof BookTree) {
					coverView.setImageResource(R.drawable.ic_list_library_book);
				} else {
					coverView.setImageResource(R.drawable.ic_list_library_books);
				}
			}

			return view;
		}
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final FBTree tree = ((LibraryAdapter)getListAdapter()).getItem(position);
		if (tree instanceof BookTree) {
			return onContextItemSelected(item.getItemId(), ((BookTree)tree).Book);
		}
		return super.onContextItemSelected(item);
	}

	@Override
	protected void deleteBook(Book book, int mode) {
		super.deleteBook(book, mode);
		getListView().invalidateViews();
	}

	protected boolean isTreeSelected(FBTree tree) {
		if (mySelectedBook == null) {
			return false;
		}

		if (tree instanceof BookTree) {
			return mySelectedBook.equals(((BookTree)tree).Book);
		}
		if (tree instanceof AuthorTree) {
			return mySelectedBook.authors().contains(((AuthorTree)tree).Author);
		}
		if (tree instanceof TitleTree) {
			final String title = mySelectedBook.getTitle();
			return tree != null && title.trim().startsWith(((TitleTree)tree).Title);
		}
		if (tree instanceof SeriesTree) {
			final SeriesInfo info = mySelectedBook.getSeriesInfo();
			final String series = ((SeriesTree)tree).Series;
			return info != null && series != null && series.equals(info.Name);
		}
		if (tree instanceof TagTree) {
			final Tag tag = ((TagTree)tree).Tag;
			for (Tag t : mySelectedBook.tags()) {
				for (; t != null; t = t.Parent) {
					if (t == tag) {
						return true;
					}
				}
			}
			return false;
		}
		return false;
	}

	protected class StartTreeActivityRunnable implements Runnable {
		private final String myTreePath;
		private final String myParameter;

		public StartTreeActivityRunnable(String treePath, String parameter) {
			myTreePath = treePath;
			myParameter = parameter;
		}

		public void run() {
			startActivityForResult(
				new Intent(LibraryBaseActivity.this, LibraryTreeActivity.class)
					.putExtra(SELECTED_BOOK_PATH_KEY, mySelectedBookPath)
					.putExtra(TREE_PATH_KEY, myTreePath)
					.putExtra(PARAMETER_KEY, myParameter),
				CHILD_LIST_REQUEST
			);
		}
	}

	protected class OpenTreeRunnable implements Runnable {
		private final Library myLibrary;
		private final Runnable myPostRunnable;

		public OpenTreeRunnable(Library library, String treePath) {
			this(library, treePath, null);
		}

		public OpenTreeRunnable(Library library, String treePath, String parameter) {
			this(library, new StartTreeActivityRunnable(treePath, parameter));
		}

		public OpenTreeRunnable(Library library, Runnable postRunnable) {
			myLibrary = library;
			myPostRunnable = postRunnable;
		}

		public void run() {
			if (myLibrary == null) {
				return;
			}
			if (myLibrary.hasState(Library.STATE_FULLY_INITIALIZED)) {
				myPostRunnable.run();
			} else {
				UIUtil.runWithMessage(LibraryBaseActivity.this, ""loadingBookList"",
				new Runnable() {
					public void run() {
						myLibrary.waitForState(Library.STATE_FULLY_INITIALIZED);
					}
				},
				myPostRunnable);
			}
		}
	}
}
",True,422,1,1,9,107,2,17,L6
227,org.geometerplus.android.fbreader.library.LibraryTopLevelActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import java.util.LinkedList;

import android.app.SearchManager;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.widget.ListView;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.library.Library;
import org.geometerplus.fbreader.tree.FBTree;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.fbreader.SQLiteBooksDatabase;
import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

public class LibraryTopLevelActivity extends LibraryBaseActivity {
	private LinkedList<FBTree> myItems;
	private TopLevelTree mySearchResultsItem;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		requestWindowFeature(Window.FEATURE_NO_TITLE);

		DatabaseInstance = SQLiteBooksDatabase.Instance();
		if (DatabaseInstance == null) {
			DatabaseInstance = new SQLiteBooksDatabase(this, ""LIBRARY"");
		}
		if (LibraryInstance == null) {
			LibraryInstance = new Library();
			startService(new Intent(getApplicationContext(), InitializationService.class));
		}

		myItems = new LinkedList<FBTree>();
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_FAVORITES),
			R.drawable.ic_list_library_favorites,
			new OpenTreeRunnable(LibraryInstance, new StartTreeActivityRunnable(PATH_FAVORITES, null) {
				public void run() {
					if (LibraryInstance.favorites().hasChildren()) {
						super.run();
					} else {
						UIUtil.showErrorMessage(LibraryTopLevelActivity.this, ""noFavorites"");
					}
				}
			})
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_RECENT),
			R.drawable.ic_list_library_recent,
			new OpenTreeRunnable(LibraryInstance, PATH_RECENT)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_BY_AUTHOR),
			R.drawable.ic_list_library_authors,
			new OpenTreeRunnable(LibraryInstance, PATH_BY_AUTHOR)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_BY_TITLE),
			R.drawable.ic_list_library_books,
			new OpenTreeRunnable(LibraryInstance, PATH_BY_TITLE)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_BY_TAG),
			R.drawable.ic_list_library_tags,
			new OpenTreeRunnable(LibraryInstance, PATH_BY_TAG)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(""fileTree""),
			R.drawable.ic_list_library_folder,
			new Runnable() {
				public void run() {
					startActivity(
						new Intent(LibraryTopLevelActivity.this, FileManager.class)
							.putExtra(SELECTED_BOOK_PATH_KEY, mySelectedBookPath)
					);
				}
			}
		));
		setListAdapter(new LibraryAdapter(myItems));

		onNewIntent(getIntent());
	}

	@Override
	public void onDestroy() {
		LibraryInstance = null;
		super.onDestroy();
	}

	@Override
	public void onListItemClick(ListView listView, View view, int position, long rowId) {
		TopLevelTree tree = (TopLevelTree)((LibraryAdapter)getListAdapter()).getItem(position);
		tree.run();
	}

	private void setSearchResults(Intent intent) {
		if (myItems.get(0) == mySearchResultsItem) {
			myItems.remove(0);
		}
		final String pattern = intent.getStringExtra(SearchManager.QUERY);
		mySearchResultsItem = new TopLevelTree(
			myResource.getResource(PATH_SEARCH_RESULTS),
			pattern,
			R.drawable.ic_list_library_books,
			new OpenTreeRunnable(LibraryInstance, PATH_SEARCH_RESULTS, pattern)
		);
		myItems.add(0, mySearchResultsItem);
		getListView().invalidateViews();
		mySearchResultsItem.run();
	}

	public void onNewIntent(Intent intent) {
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			if (runSearch(intent)) {
				setSearchResults(intent);
			} else {
				showNotFoundToast();
			}
		} else if (ACTION_FOUND.equals(intent.getAction())) {
			setSearchResults(intent);
		}
	}
}

class TopLevelTree extends FBTree implements ZLAndroidTree {
	private final ZLResource myResource;
	private final String myParameter;
	private final int myCoverResourceId;
	private final Runnable myAction;

	public TopLevelTree(ZLResource resource, String parameter, int coverResourceId, Runnable action) {
		myResource = resource;
		myParameter = parameter;
		myCoverResourceId = coverResourceId;
		myAction = action;
	}

	public TopLevelTree(ZLResource resource, int coverResourceId, Runnable action) {
		this(resource, null, coverResourceId, action);
	}

	@Override
	public String getName() {
		return myResource.getValue();
	}

	@Override
	public String getSummary() {
		final String summary = myResource.getResource(""summary"").getValue();
		return myParameter == null ? summary : summary.replace(""%s"", myParameter);
	}

	public int getCoverResourceId() {
		return myCoverResourceId;
	}

	public void run() {
		myAction.run();
	}
}
",True,421,0,0,9,103,1,10,L6
228,org.geometerplus.android.fbreader.api.ApiServerImplementation.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.api;

import java.util.*;

import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.config.ZLConfig;

import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

public class ApiServerImplementation extends ApiInterface.Stub implements Api, ApiMethods {
	private final FBReaderApp myReader = (FBReaderApp)FBReaderApp.Instance();

	private ApiObject.Error unsupportedMethodError(int method) {
		return new ApiObject.Error(""Unsupported method code: "" + method);
	}

	private ApiObject.Error exceptionInMethodError(int method, Throwable e) {
		return new ApiObject.Error(""Exception in method "" + method + "": "" + e);
	}

	public ApiObject request(int method, ApiObject[] parameters) {
		try {
			switch (method) {
				case GET_FBREADER_VERSION:
					return ApiObject.envelope(getFBReaderVersion());
				case GET_OPTION_VALUE:
					return ApiObject.envelope(getOptionValue(
						((ApiObject.String)parameters[0]).Value,
						((ApiObject.String)parameters[1]).Value
					));
				case SET_OPTION_VALUE:
					setOptionValue(
						((ApiObject.String)parameters[0]).Value,
						((ApiObject.String)parameters[1]).Value,
						((ApiObject.String)parameters[2]).Value
					);
					return ApiObject.Void.Instance;
				case GET_BOOK_LANGUAGE:
					return ApiObject.envelope(getBookLanguage());
				case GET_BOOK_TITLE:
					return ApiObject.envelope(getBookTitle());
				case GET_BOOK_FILE_NAME:
					return ApiObject.envelope(getBookFileName());
				case GET_PARAGRAPHS_NUMBER:
					return ApiObject.envelope(getParagraphsNumber());
				case GET_ELEMENTS_NUMBER:
					return ApiObject.envelope(getElementsNumber(
						((ApiObject.Integer)parameters[0]).Value
					));
				case GET_PARAGRAPH_TEXT:
					return ApiObject.envelope(getParagraphText(
						((ApiObject.Integer)parameters[0]).Value
					));
				case GET_PAGE_START:
					return getPageStart();
				case GET_PAGE_END:
					return getPageEnd();
				case IS_PAGE_END_OF_SECTION:
					return ApiObject.envelope(isPageEndOfSection());
				case IS_PAGE_END_OF_TEXT:
					return ApiObject.envelope(isPageEndOfText());
				case SET_PAGE_START:
					setPageStart((TextPosition)parameters[0]);
					return ApiObject.Void.Instance;
				case HIGHLIGHT_AREA:
				{
					highlightArea((TextPosition)parameters[0], (TextPosition)parameters[1]);
					return ApiObject.Void.Instance;
				}
				case CLEAR_HIGHLIGHTING:
					clearHighlighting();
					return ApiObject.Void.Instance;
				default:
					return unsupportedMethodError(method);
			}
		} catch (Throwable e) {
			return new ApiObject.Error(""Exception in method "" + method + "": "" + e);
		} 
	}

	public List<ApiObject> requestList(int method, ApiObject[] parameters) {
		try {
			switch (method) {
				case GET_OPTION_GROUPS:
					return ApiObject.envelope(getOptionGroups());
				case GET_OPTION_NAMES:
					return ApiObject.envelope(getOptionNames(
						((ApiObject.String)parameters[0]).Value
					));
				case GET_BOOK_TAGS:
					return ApiObject.envelope(getBookTags());
				default:
					return Collections.<ApiObject>singletonList(unsupportedMethodError(method));
			}
		} catch (Throwable e) {
			return Collections.<ApiObject>singletonList(exceptionInMethodError(method, e));
		} 
	}

	private Map<ApiObject,ApiObject> errorMap(ApiObject.Error error) {
		return Collections.<ApiObject,ApiObject>singletonMap(error, error);
	}

	public Map<ApiObject,ApiObject> requestMap(int method, ApiObject[] parameters) {
		try {
			switch (method) {
				default:
					return errorMap(unsupportedMethodError(method));
			}
		} catch (Throwable e) {
			return errorMap(exceptionInMethodError(method, e));
		} 
	}

	// information about fbreader
	public String getFBReaderVersion() {
		return ZLibrary.Instance().getVersionName();
	}

	// preferences information
	public List<String> getOptionGroups() {
		return ZLConfig.Instance().listGroups();
	}

	public List<String> getOptionNames(String group) {
		return ZLConfig.Instance().listNames(group);
	}

	public String getOptionValue(String group, String name) {
		return ZLConfig.Instance().getValue(group, name, null);
	}

	public void setOptionValue(String group, String name, String value) {
		// TODO: implement
	}

	public String getBookLanguage() {
		return myReader.Model.Book.getLanguage();
	}

	public String getBookTitle() {
		return myReader.Model.Book.getTitle();
	}

	public List<String> getBookTags() {
		// TODO: implement
		return Collections.emptyList();
	}

	public String getBookFileName() {
		// TODO: implement
		return null;
	}

	// page information
	public TextPosition getPageStart() {
		return getTextPosition(myReader.getTextView().getStartCursor());
	}

	public TextPosition getPageEnd() {
		return getTextPosition(myReader.getTextView().getEndCursor());
	}

	public boolean isPageEndOfSection() {
		final ZLTextWordCursor cursor = myReader.getTextView().getEndCursor();
		return cursor.isEndOfParagraph() && cursor.getParagraphCursor().isEndOfSection();
	}

	public boolean isPageEndOfText() {
		final ZLTextWordCursor cursor = myReader.getTextView().getEndCursor();
		return cursor.isEndOfParagraph() && cursor.getParagraphCursor().isLast();
	}

	private TextPosition getTextPosition(ZLTextWordCursor cursor) {
		return new TextPosition(
			cursor.getParagraphIndex(),
			cursor.getElementIndex(),
			cursor.getCharIndex()
		);
	}

	private ZLTextFixedPosition getZLTextPosition(TextPosition position) {
		return new ZLTextFixedPosition(
			position.ParagraphIndex,
			position.ElementIndex,
			position.CharIndex
		);
	}

	// manage view
	public void setPageStart(TextPosition position) {
		myReader.getTextView().gotoPosition(position.ParagraphIndex, position.ElementIndex, position.CharIndex);
		myReader.getViewWidget().repaint();
	}

	public void highlightArea(TextPosition start, TextPosition end) {
		myReader.getTextView().highlight(
			getZLTextPosition(start),
			getZLTextPosition(end)
		);
	}

	public void clearHighlighting() {
		myReader.getTextView().clearHighlighting();
	}

	public int getParagraphsNumber() {
		return myReader.Model.BookTextModel.getParagraphsNumber();
	}

	public int getElementsNumber(int paragraphIndex) {
		final ZLTextWordCursor cursor = new ZLTextWordCursor(myReader.getTextView().getStartCursor());
		cursor.moveToParagraph(paragraphIndex);
		cursor.moveToParagraphEnd();
		return cursor.getElementIndex();
	}

	public String getParagraphText(int paragraphIndex) {
		final StringBuffer sb = new StringBuffer();
		final ZLTextWordCursor cursor = new ZLTextWordCursor(myReader.getTextView().getStartCursor());
		cursor.moveToParagraph(paragraphIndex);
		cursor.moveToParagraphStart();
		while (!cursor.isEndOfParagraph()) {
			ZLTextElement element = cursor.getElement();
			if (element instanceof ZLTextWord) {
				sb.append(element.toString() + "" "");
			}
			cursor.nextWord();
		}
		return sb.toString();
	}
}
",True,223,1,1,6,76,1,18,L7
229,org.geometerplus.android.fbreader.api.ApiObject.java,"/*
 * This code is in the public domain.
 */

package org.geometerplus.android.fbreader.api;

import java.util.List;
import java.util.ArrayList;

import android.os.Parcel;
import android.os.Parcelable;

public abstract class ApiObject implements Parcelable {
	protected static interface Type {
		int ERROR = -1;
		int VOID = 0;
		int INT = 1;
		int STRING = 2;
		int BOOLEAN = 3;
		int TEXT_POSITION = 10;
	}

	static class Void extends ApiObject {
		static Void Instance = new Void();

		private Void() {
		}

		@Override
		protected int type() {
			return Type.VOID;
		}
	}

	static class Integer extends ApiObject {
		final int Value;

		Integer(int value) {
			Value = value;
		}

		@Override
		protected int type() {
			return Type.INT;
		}

		@Override
		public void writeToParcel(Parcel parcel, int flags) {
			super.writeToParcel(parcel, flags);
			parcel.writeInt(Value);
		}
	}

	static class Boolean extends ApiObject {
		final boolean Value;

		Boolean(boolean value) {
			Value = value;
		}

		@Override
		protected int type() {
			return Type.BOOLEAN;
		}

		@Override
		public void writeToParcel(Parcel parcel, int flags) {
			super.writeToParcel(parcel, flags);
			parcel.writeByte((byte)(Value ? 1 : 0));
		}
	}

	static class String extends ApiObject {
		final java.lang.String Value;

		String(java.lang.String value) {
			Value = value;
		}

		@Override
		protected int type() {
			return Type.STRING;
		}

		@Override
		public void writeToParcel(Parcel parcel, int flags) {
			super.writeToParcel(parcel, flags);
			parcel.writeString(Value);
		}
	}

	static class Error extends ApiObject {
		final java.lang.String Message;

		Error(java.lang.String message) {
			Message = message;
		}

		@Override
		protected int type() {
			return Type.ERROR;
		}

		@Override
		public void writeToParcel(Parcel parcel, int flags) {
			super.writeToParcel(parcel, flags);
			parcel.writeString(Message);
		}
	}

	static ApiObject envelope(int value) {
		return new Integer(value);
	}

	static ApiObject envelope(boolean value) {
		return new Boolean(value);
	}

	static ApiObject envelope(java.lang.String value) {
		return new String(value);
	}

	static List<ApiObject> envelope(List<java.lang.String> values) {
		final ArrayList<ApiObject> objects = new ArrayList<ApiObject>(values.size());
		for (java.lang.String v : values) {
			objects.add(new String(v));
		}
		return objects;
	}

	abstract protected int type();

	public int describeContents() {
		return 0;
	}

	public void writeToParcel(Parcel parcel, int flags) {
		parcel.writeInt(type());
	}

	public static final Parcelable.Creator<ApiObject> CREATOR =
		new Parcelable.Creator<ApiObject>() {
			public ApiObject createFromParcel(Parcel parcel) {
				final int code = parcel.readInt();
				switch (code) {
					default:
						return new Error(""Unknown object code: "" + code);
					case Type.ERROR:
						return new Error(parcel.readString());
					case Type.VOID:
						return Void.Instance;
					case Type.INT:
						return new Integer(parcel.readInt());
					case Type.BOOLEAN:
						return new Boolean(parcel.readByte() == 1);
					case Type.STRING:
						return new String(parcel.readString());
					case Type.TEXT_POSITION:
						return new TextPosition(parcel.readInt(), parcel.readInt(), parcel.readInt());
				}
			}

			public ApiObject[] newArray(int size) {
				return new ApiObject[size];
			}
		};
}
",False,5,2,2,1,1,3,1,L0
230,org.geometerplus.android.fbreader.api.ApiMethods.java,"/*
 * This code is in the public domain.
 */

package org.geometerplus.android.fbreader.api;

interface ApiMethods {
	// fbreader information
	int GET_FBREADER_VERSION = 1;

	// library information

	// network library information

	// bookmarks information

	// preferences
	int GET_OPTION_GROUPS = 401;
	int GET_OPTION_NAMES = 402;
	int GET_OPTION_VALUE = 403;
	int SET_OPTION_VALUE = 404;

	// book information
	int GET_BOOK_LANGUAGE = 501;
	int GET_BOOK_TITLE = 502;
	int GET_BOOK_AUTHORS = 503;
	int GET_BOOK_TAGS = 504;
	int GET_BOOK_FILE_NAME = 505;

	// text information
	int GET_PARAGRAPHS_NUMBER = 601;
	int GET_ELEMENTS_NUMBER = 602;
	int GET_PARAGRAPH_TEXT = 603;

	// page information
	int GET_PAGE_START = 701;
	int GET_PAGE_END = 702;
	int IS_PAGE_END_OF_TEXT = 703;
	int IS_PAGE_END_OF_SECTION = 704;

	// view management
	int SET_PAGE_START = 801;
	int HIGHLIGHT_AREA = 802;
	int CLEAR_HIGHLIGHTING = 803;
}
",False,4,2,2,0,0,2,0,L0
231,org.geometerplus.android.fbreader.api.TextPosition.java,"/*
 * This code is in the public domain.
 */

package org.geometerplus.android.fbreader.api;

import android.os.Parcel;
import android.os.Parcelable;

public final class TextPosition extends ApiObject {
	public final int ParagraphIndex;
	public final int ElementIndex;
	public final int CharIndex;

	public TextPosition(int paragraphIndex, int elementIndex, int charIndex) {
		ParagraphIndex = paragraphIndex;
		ElementIndex = elementIndex;
		CharIndex = charIndex;
	}

	@Override
	protected int type() {
		return Type.TEXT_POSITION;
	}

	@Override
	public void writeToParcel(Parcel parcel, int flags) {
		super.writeToParcel(parcel, flags);
		parcel.writeInt(ParagraphIndex);
		parcel.writeInt(ElementIndex);
		parcel.writeInt(CharIndex);
	}

	public static final Parcelable.Creator<TextPosition> CREATOR =
		new Parcelable.Creator<TextPosition>() {
			public TextPosition createFromParcel(Parcel parcel) {
				parcel.readInt();
				return new TextPosition(parcel.readInt(), parcel.readInt(), parcel.readInt());
			}

			public TextPosition[] newArray(int size) {
				return new TextPosition[size];
			}
		};
}
",False,6,2,3,1,1,4,1,L0
232,org.geometerplus.android.fbreader.api.ApiClientImplementation.java,"/*
 * This code is in the public domain.
 */

package org.geometerplus.android.fbreader.api;

import java.util.*;

import android.content.*;
import android.os.IBinder;

public class ApiClientImplementation implements ServiceConnection, Api, ApiMethods {
	public static interface ConnectionListener {
		void onConnected();
	}

	private static String ACTION_API = ""android.fbreader.action.API"";

	private final Context myContext;
	private ConnectionListener myListener;
	private volatile ApiInterface myInterface;

	public ApiClientImplementation(Context context, ConnectionListener listener) {
		myContext = context;
		myListener = listener;
		connect();
	}

	public synchronized void connect() {
		if (myInterface == null) {
			myContext.bindService(new Intent(ACTION_API), this, Context.BIND_AUTO_CREATE);
		}
	}

	public synchronized void disconnect() {
		if (myInterface != null) {
			try {
				myContext.unbindService(this);
			} catch (IllegalArgumentException e) {
			}
			myInterface = null;
		}
	}

	public synchronized void onServiceConnected(ComponentName className, IBinder service) {
		myInterface = ApiInterface.Stub.asInterface(service);
		if (myListener != null) {
			myListener.onConnected();
		}
	}

	public synchronized void onServiceDisconnected(ComponentName name) {
		myInterface = null;
	}

	private synchronized void checkConnection() throws ApiException {
		if (myInterface == null) {
			throw new ApiException(""Not connected to FBReader"");
		}
	}

	private synchronized ApiObject request(int method, ApiObject[] params) throws ApiException {
		checkConnection();
		try {
			final ApiObject object = myInterface.request(method, params);
			if (object instanceof ApiObject.Error) {
				throw new ApiException(((ApiObject.Error)object).Message);
			}
			return object;
		} catch (android.os.RemoteException e) {
			throw new ApiException(e);
		}
	}

	private synchronized List<ApiObject> requestList(int method, ApiObject[] params) throws ApiException {
		checkConnection();
		try {
			final List<ApiObject> list = myInterface.requestList(method, params);
			for (ApiObject object : list) {
				if (object instanceof ApiObject.Error) {
					throw new ApiException(((ApiObject.Error)object).Message);
				}
			}
			return list;
		} catch (android.os.RemoteException e) {
			throw new ApiException(e);
		}
	}

	private String requestString(int method, ApiObject[] params) throws ApiException {
		final ApiObject object = request(method, params);
		if (!(object instanceof ApiObject.String)) {
			throw new ApiException(""Cannot cast return type of method "" + method + "" to String"");
		}
		return ((ApiObject.String)object).Value;
	}

	private int requestInt(int method, ApiObject[] params) throws ApiException {
		final ApiObject object = request(method, params);
		if (!(object instanceof ApiObject.Integer)) {
			throw new ApiException(""Cannot cast return type of method "" + method + "" to int"");
		}
		return ((ApiObject.Integer)object).Value;
	}

	private boolean requestBoolean(int method, ApiObject[] params) throws ApiException {
		final ApiObject object = request(method, params);
		if (!(object instanceof ApiObject.Boolean)) {
			throw new ApiException(""Cannot cast return type of method "" + method + "" to boolean"");
		}
		return ((ApiObject.Boolean)object).Value;
	}

	private TextPosition requestTextPosition(int method, ApiObject[] params) throws ApiException {
		final ApiObject object = request(method, params);
		if (!(object instanceof TextPosition)) {
			throw new ApiException(""Cannot cast return type of method "" + method + "" to TextPosition"");
		}
		return (TextPosition)object;
	}

	private List<String> requestStringList(int method, ApiObject[] params) throws ApiException {
		final List<ApiObject> list = requestList(method, params);
		final ArrayList<String> stringList = new ArrayList<String>(list.size());
		for (ApiObject object : list) {
			if (!(object instanceof ApiObject.String)) {
				throw new ApiException(""Cannot cast an element returned from method "" + method + "" to String"");
			}
			stringList.add(((ApiObject.String)object).Value);
		}
		return stringList;
	}

	private static final ApiObject[] EMPTY_PARAMETERS = new ApiObject[0];

	private static ApiObject[] envelope(String value) {
		return new ApiObject[] { ApiObject.envelope(value) };
	}

	private static ApiObject[] envelope(int value) {
		return new ApiObject[] { ApiObject.envelope(value) };
	}

	// information about fbreader
	public String getFBReaderVersion() throws ApiException {
		return requestString(GET_FBREADER_VERSION, EMPTY_PARAMETERS);
	}

	// preferences information
	public List<String> getOptionGroups() throws ApiException {
		return requestStringList(GET_OPTION_GROUPS, EMPTY_PARAMETERS);
	}

	public List<String> getOptionNames(String group) throws ApiException {
		return requestStringList(GET_OPTION_NAMES, envelope(group));
	}

	public String getOptionValue(String group, String name) throws ApiException {
		return requestString(
			GET_OPTION_VALUE,
			new ApiObject[] { ApiObject.envelope(group), ApiObject.envelope(name) }
		);
	}

	public void setOptionValue(String group, String name, String value) throws ApiException {
		request(
			SET_OPTION_VALUE,
			new ApiObject[] { ApiObject.envelope(group), ApiObject.envelope(name), ApiObject.envelope(value) }
		);
	}

	public String getBookLanguage() throws ApiException {
		return requestString(GET_BOOK_LANGUAGE, EMPTY_PARAMETERS);
	}

	public String getBookTitle() throws ApiException {
		return requestString(GET_BOOK_TITLE, EMPTY_PARAMETERS);
	}

	public List<String> getBookTags() throws ApiException {
		return requestStringList(GET_BOOK_TAGS, EMPTY_PARAMETERS);
	}

	public String getBookFileName() throws ApiException {
		return requestString(GET_BOOK_FILE_NAME, EMPTY_PARAMETERS);
	}

	public TextPosition getPageStart() throws ApiException {
		return requestTextPosition(GET_PAGE_START, EMPTY_PARAMETERS);
	}

	public TextPosition getPageEnd() throws ApiException {
		return requestTextPosition(GET_PAGE_END, EMPTY_PARAMETERS);
	}

	public boolean isPageEndOfSection() throws ApiException {
		return requestBoolean(IS_PAGE_END_OF_SECTION, EMPTY_PARAMETERS);
	}

	public boolean isPageEndOfText() throws ApiException {
		return requestBoolean(IS_PAGE_END_OF_TEXT, EMPTY_PARAMETERS);
	}

	public int getParagraphsNumber() throws ApiException {
		return requestInt(GET_PARAGRAPHS_NUMBER, EMPTY_PARAMETERS);
	}

	public String getParagraphText(int paragraphIndex) throws ApiException {
		return requestString(GET_PARAGRAPH_TEXT, envelope(paragraphIndex));
	}

	public int getElementsNumber(int paragraphIndex) throws ApiException {
		return requestInt(GET_ELEMENTS_NUMBER, envelope(paragraphIndex));
	}

	public void setPageStart(TextPosition position) throws ApiException {
		request(SET_PAGE_START, new ApiObject[] { position });
	}

	public void highlightArea(TextPosition start, TextPosition end) throws ApiException {
		request(HIGHLIGHT_AREA, new ApiObject[] { start, end });
	}

	public void clearHighlighting() throws ApiException {
		request(CLEAR_HIGHLIGHTING, EMPTY_PARAMETERS);
	}
}
",True,6,0,0,1,5,0,5,L7
233,org.geometerplus.android.fbreader.api.PluginApi.java,"/*
 * This code is in the public domain.
 */

package org.geometerplus.android.fbreader.api;

import java.util.*;

import android.app.Activity;
import android.content.*;
import android.net.Uri;
import android.os.*;

public abstract class PluginApi {
	public static final String ACTION_REGISTER = ""android.fbreader.action.plugin.REGISTER"";
	public static final String ACTION_RUN = ""android.fbreader.action.plugin.RUN"";

	public static abstract class PluginInfo extends BroadcastReceiver {
		public static final String KEY = ""actions"";

		public void onReceive(Context context, Intent intent) {
			final List<ActionInfo> newActions = implementedActions(context);
			if (newActions != null) {
				final Bundle bundle = getResultExtras(true);
				ArrayList<ActionInfo> actions = bundle.<ActionInfo>getParcelableArrayList(KEY);
				if (actions == null) {
					actions = new ArrayList<ActionInfo>();
				}
				actions.addAll(newActions);
				bundle.putParcelableArrayList(KEY, actions);
			}
		}

		protected abstract List<ActionInfo> implementedActions(Context context);
	}

	public static abstract class ActionInfo implements Parcelable {
		protected static final int TYPE_MENU = 1;

		private final String myId;

		protected ActionInfo(Uri id) {
			myId = id.toString();
		}

		protected abstract int getType();

		public Uri getId() {
			return Uri.parse(myId);
		}

		public int describeContents() {
			return 0;
		}

		public void writeToParcel(Parcel parcel, int flags) {
			parcel.writeInt(getType());
			parcel.writeString(myId);
		}

		public static final Creator<ActionInfo> CREATOR = new Creator<ActionInfo>() {
			public ActionInfo createFromParcel(Parcel parcel) {
				switch (parcel.readInt()) {
					case TYPE_MENU:
						return new MenuActionInfo(
							Uri.parse(parcel.readString()),
							parcel.readString()
						);
					default:
						return null;
				}
			}

			public ActionInfo[] newArray(int size) {
				return new ActionInfo[size];
			}
		};
	}

	public static class MenuActionInfo extends ActionInfo {
		public final String MenuItemName;

		public MenuActionInfo(Uri id, String menuItemName) {
			super(id);
			MenuItemName = menuItemName;
		}

		@Override
		protected int getType() {
			return TYPE_MENU;
		}

		@Override
		public void writeToParcel(Parcel parcel, int flags) {
			super.writeToParcel(parcel, flags);
			parcel.writeString(MenuItemName);
		}
	}
}
",False,55,5,28,0,0,1,0,L6
234,org.geometerplus.android.fbreader.api.ApiService.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.api;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;

public class ApiService extends Service {
	@Override
	public IBinder onBind(Intent intent) {
		return new ApiServerImplementation();
	}
}
",False,223,0,0,7,76,0,1,L7
235,org.geometerplus.android.fbreader.api.Api.java,"/*
 * This code is in the public domain.
 */

package org.geometerplus.android.fbreader.api;

import java.util.List;

public interface Api {
	// information about fbreader
	String getFBReaderVersion() throws ApiException;

	// preferences information
	List<String> getOptionGroups() throws ApiException;
	List<String> getOptionNames(String group) throws ApiException;
	String getOptionValue(String group, String name) throws ApiException;
	void setOptionValue(String group, String name, String value) throws ApiException;

	// book information
	String getBookLanguage() throws ApiException;
	String getBookTitle() throws ApiException;
	//List<String> getBookAuthors() throws ApiException;
	List<String> getBookTags() throws ApiException;
	String getBookFileName() throws ApiException;

	// text information
	int getParagraphsNumber() throws ApiException;
	int getElementsNumber(int paragraphIndex) throws ApiException;
	String getParagraphText(int paragraphIndex) throws ApiException;

	// page information
	TextPosition getPageStart() throws ApiException;
	TextPosition getPageEnd() throws ApiException;
	boolean isPageEndOfSection() throws ApiException;
	boolean isPageEndOfText() throws ApiException;

	// manage view
	void setPageStart(TextPosition position) throws ApiException;
	void highlightArea(TextPosition start, TextPosition end) throws ApiException;
	void clearHighlighting() throws ApiException;
}
",False,7,2,2,2,2,2,2,L0
236,org.geometerplus.android.fbreader.api.ApiException.java,"/*
 * This code is in the public domain.
 */

package org.geometerplus.android.fbreader.api;

public class ApiException extends Exception {
	ApiException(String message) {
		super(message);
	}

	ApiException(Exception parent) {
		super(parent);
	}
}
",False,5,3,2,0,0,2,0,L0
237,org.geometerplus.android.fbreader.preferences.ZLPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

interface ZLPreference {
	void onAccept();
}
",False,76,8,29,0,0,9,0,L0
238,org.geometerplus.android.fbreader.preferences.PreferenceActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Intent;

import org.geometerplus.zlibrary.core.application.ZLKeyBindings;
import org.geometerplus.zlibrary.core.options.ZLIntegerOption;
import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;

import org.geometerplus.zlibrary.text.view.style.*;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;
import org.geometerplus.zlibrary.ui.android.view.AndroidFontUtil;

import org.geometerplus.fbreader.fbreader.*;
import org.geometerplus.fbreader.Paths;
import org.geometerplus.fbreader.bookmodel.FBTextKind;

import org.geometerplus.android.fbreader.DictionaryUtil;

public class PreferenceActivity extends ZLPreferenceActivity {
	public PreferenceActivity() {
		super(""Preferences"");
	}

	@Override
	protected void init(Intent intent) {
		final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
		final ZLAndroidApplication androidApp = ZLAndroidApplication.Instance();
		final ColorProfile profile = fbReader.getColorProfile();

		final Screen directoriesScreen = createPreferenceScreen(""directories"");
		directoriesScreen.addOption(Paths.BooksDirectoryOption(), ""books"");
		if (AndroidFontUtil.areExternalFontsSupported()) {
			directoriesScreen.addOption(Paths.FontsDirectoryOption(), ""fonts"");
		}
		directoriesScreen.addOption(Paths.WallpapersDirectoryOption(), ""wallpapers"");

		final ZLPreferenceSet statusBarPreferences = new ZLPreferenceSet();
		final Screen appearanceScreen = createPreferenceScreen(""appearance"");
		appearanceScreen.addOption(androidApp.AutoOrientationOption, ""autoOrientation"");
		appearanceScreen.addPreference(
			new ZLBooleanPreference(
				this, androidApp.ShowStatusBarOption, appearanceScreen.Resource, ""showStatusBar""
			) {
				@Override
				public void onClick() {
					super.onClick();
					statusBarPreferences.setEnabled(!isChecked());
				}
			}
		);
		statusBarPreferences.add(
			appearanceScreen.addOption(
				androidApp.ShowStatusBarWhenMenuIsActiveOption,
				""showStatusBarWhenMenuIsActive""
			)
		);
		statusBarPreferences.setEnabled(!androidApp.ShowStatusBarOption.getValue());
		appearanceScreen.addOption(androidApp.DisableButtonLightsOption, ""disableButtonLights"");

		final Screen textScreen = createPreferenceScreen(""text"");
		final ZLTextStyleCollection collection = ZLTextStyleCollection.Instance();
		final ZLTextBaseStyle baseStyle = collection.getBaseStyle();
		textScreen.addPreference(new FontOption(
			this, textScreen.Resource, ""font"",
			baseStyle.FontFamilyOption, false
		));
		textScreen.addPreference(new ZLIntegerRangePreference(
			this, textScreen.Resource.getResource(""fontSize""),
			baseStyle.FontSizeOption
		));
		textScreen.addPreference(new FontStylePreference(
			this, textScreen.Resource, ""fontStyle"",
			baseStyle.BoldOption, baseStyle.ItalicOption
		));
		final ZLIntegerRangeOption spaceOption = baseStyle.LineSpaceOption;
		final String[] spacings = new String[spaceOption.MaxValue - spaceOption.MinValue + 1];
		for (int i = 0; i < spacings.length; ++i) {
			final int val = spaceOption.MinValue + i;
			spacings[i] = (char)(val / 10 + '0') + ""."" + (char)(val % 10 + '0');
		}
		textScreen.addPreference(new ZLChoicePreference(
			this, textScreen.Resource, ""lineSpacing"",
			spaceOption, spacings
		));
		final String[] alignments = { ""left"", ""right"", ""center"", ""justify"" };
		textScreen.addPreference(new ZLChoicePreference(
			this, textScreen.Resource, ""alignment"",
			baseStyle.AlignmentOption, alignments
		));
		textScreen.addPreference(new ZLBooleanPreference(
			this, baseStyle.AutoHyphenationOption,
			textScreen.Resource, ""autoHyphenations""
		));

		final Screen moreStylesScreen = textScreen.createPreferenceScreen(""more"");

		byte styles[] = {
			FBTextKind.REGULAR,
			FBTextKind.TITLE,
			FBTextKind.SECTION_TITLE,
			FBTextKind.SUBTITLE,
			FBTextKind.H1,
			FBTextKind.H2,
			FBTextKind.H3,
			FBTextKind.H4,
			FBTextKind.H5,
			FBTextKind.H6,
			FBTextKind.ANNOTATION,
			FBTextKind.EPIGRAPH,
			FBTextKind.AUTHOR,
			FBTextKind.POEM_TITLE,
			FBTextKind.STANZA,
			FBTextKind.VERSE,
			FBTextKind.CITE,
			FBTextKind.INTERNAL_HYPERLINK,
			FBTextKind.EXTERNAL_HYPERLINK,
			FBTextKind.FOOTNOTE,
			FBTextKind.ITALIC,
			FBTextKind.EMPHASIS,
			FBTextKind.BOLD,
			FBTextKind.STRONG,
			FBTextKind.DEFINITION,
			FBTextKind.DEFINITION_DESCRIPTION,
			FBTextKind.PREFORMATTED,
			FBTextKind.CODE
		};
		for (int i = 0; i < styles.length; ++i) {
			final ZLTextStyleDecoration decoration = collection.getDecoration(styles[i]);
			if (decoration == null) {
				continue;
			}
			ZLTextFullStyleDecoration fullDecoration =
				decoration instanceof ZLTextFullStyleDecoration ?
					(ZLTextFullStyleDecoration)decoration : null;

			final Screen formatScreen = moreStylesScreen.createPreferenceScreen(decoration.getName());
			formatScreen.addPreference(new FontOption(
				this, textScreen.Resource, ""font"",
				decoration.FontFamilyOption, true
			));
			formatScreen.addPreference(new ZLIntegerRangePreference(
				this, textScreen.Resource.getResource(""fontSizeDifference""),
				decoration.FontSizeDeltaOption
			));
			formatScreen.addPreference(new ZLBoolean3Preference(
				this, textScreen.Resource, ""bold"",
				decoration.BoldOption
			));
			formatScreen.addPreference(new ZLBoolean3Preference(
				this, textScreen.Resource, ""italic"",
				decoration.ItalicOption
			));
			if (fullDecoration != null) {
				final String[] allAlignments = { ""unchanged"", ""left"", ""right"", ""center"", ""justify"" };
				formatScreen.addPreference(new ZLChoicePreference(
					this, textScreen.Resource, ""alignment"",
					fullDecoration.AlignmentOption, allAlignments
				));
			}
			formatScreen.addPreference(new ZLBoolean3Preference(
				this, textScreen.Resource, ""allowHyphenations"",
				decoration.AllowHyphenationsOption
			));
			if (fullDecoration != null) {
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""spaceBefore""),
					fullDecoration.SpaceBeforeOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""spaceAfter""),
					fullDecoration.SpaceAfterOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""leftIndent""),
					fullDecoration.LeftIndentOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""rightIndent""),
					fullDecoration.RightIndentOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""firstLineIndent""),
					fullDecoration.FirstLineIndentDeltaOption
				));
				final ZLIntegerOption spacePercentOption = fullDecoration.LineSpacePercentOption;
				final int[] spacingValues = new int[17];
				final String[] spacingKeys = new String[17];
				spacingValues[0] = -1;
				spacingKeys[0] = ""unchanged"";
				for (int j = 1; j < spacingValues.length; ++j) {
					final int val = 4 + j;
					spacingValues[j] = 10 * val;
					spacingKeys[j] = (char)(val / 10 + '0') + ""."" + (char)(val % 10 + '0');
				}
				formatScreen.addPreference(new ZLIntegerChoicePreference(
					this, textScreen.Resource, ""lineSpacing"",
					spacePercentOption, spacingValues, spacingKeys
				));
			}
				
		}

		final ZLPreferenceSet footerPreferences = new ZLPreferenceSet();
		final ZLPreferenceSet bgPreferences = new ZLPreferenceSet();

		final Screen colorsScreen = createPreferenceScreen(""colors"");
		colorsScreen.addPreference(new WallpaperPreference(
			this, profile, colorsScreen.Resource, ""background""
		) {
			@Override
			protected void onDialogClosed(boolean result) {
				super.onDialogClosed(result);
				bgPreferences.setEnabled("""".equals(getValue()));
			}
		});
		bgPreferences.add(
			colorsScreen.addOption(profile.BackgroundOption, ""backgroundColor"")
		);
		bgPreferences.setEnabled("""".equals(profile.WallpaperOption.getValue()));
		/*
		colorsScreen.addOption(profile.SelectionBackgroundOption, ""selectionBackground"");
		*/
		colorsScreen.addOption(profile.HighlightingOption, ""highlighting"");
		colorsScreen.addOption(profile.RegularTextOption, ""text"");
		colorsScreen.addOption(profile.HyperlinkTextOption, ""hyperlink"");
		colorsScreen.addOption(profile.VisitedHyperlinkTextOption, ""hyperlinkVisited"");
		colorsScreen.addOption(profile.FooterFillOption, ""footer"");
		colorsScreen.addOption(profile.SelectionBackgroundOption, ""selectionBackground"");
		colorsScreen.addOption(profile.SelectionForegroundOption, ""selectionForeground"");

		final Screen marginsScreen = createPreferenceScreen(""margins"");
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""left""),
			fbReader.LeftMarginOption
		));
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""right""),
			fbReader.RightMarginOption
		));
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""top""),
			fbReader.TopMarginOption
		));
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""bottom""),
			fbReader.BottomMarginOption
		));

		final Screen statusLineScreen = createPreferenceScreen(""scrollBar"");

		final String[] scrollBarTypes = {""hide"", ""show"", ""showAsProgress"", ""showAsFooter""};
		statusLineScreen.addPreference(new ZLChoicePreference(
			this, statusLineScreen.Resource, ""scrollbarType"",
			fbReader.ScrollbarTypeOption, scrollBarTypes
		) {
			@Override
			protected void onDialogClosed(boolean result) {
				super.onDialogClosed(result);
				footerPreferences.setEnabled(
					findIndexOfValue(getValue()) == FBView.SCROLLBAR_SHOW_AS_FOOTER
				);
			}
		});

		footerPreferences.add(statusLineScreen.addPreference(new ZLIntegerRangePreference(
			this, statusLineScreen.Resource.getResource(""footerHeight""),
			fbReader.FooterHeightOption
		)));
		footerPreferences.add(statusLineScreen.addOption(profile.FooterFillOption, ""footerColor""));
		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowTOCMarksOption, ""tocMarks""));

		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowClockOption, ""showClock""));
		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowBatteryOption, ""showBattery""));
		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowProgressOption, ""showProgress""));
		footerPreferences.add(statusLineScreen.addPreference(new FontOption(
			this, statusLineScreen.Resource, ""font"",
			fbReader.FooterFontOption, false
		)));
		footerPreferences.setEnabled(
			fbReader.ScrollbarTypeOption.getValue() == FBView.SCROLLBAR_SHOW_AS_FOOTER
		);

		final Screen displayScreen = createPreferenceScreen(""display"");
		displayScreen.addPreference(new ZLBooleanPreference(
			this,
			fbReader.AllowScreenBrightnessAdjustmentOption,
			displayScreen.Resource,
			""allowScreenBrightnessAdjustment""
		) {
			public void onAccept() {
				super.onAccept();
				if (!isChecked()) {
					androidApp.ScreenBrightnessLevelOption.setValue(0);
				}
			}
		});
		displayScreen.addPreference(new BatteryLevelToTurnScreenOffPreference(
			this,
			androidApp.BatteryLevelToTurnScreenOffOption,
			displayScreen.Resource,
			""dontTurnScreenOff""
		));
		/*
		displayScreen.addPreference(new ZLBooleanPreference(
			this,
			androidApp.DontTurnScreenOffDuringChargingOption,
			displayScreen.Resource,
			""dontTurnScreenOffDuringCharging""
		));
		*/

		/*
		final Screen colorProfileScreen = createPreferenceScreen(""colorProfile"");
		final ZLResource resource = colorProfileScreen.Resource;
		colorProfileScreen.setSummary(ColorProfilePreference.createTitle(resource, fbreader.getColorProfileName()));
		for (String key : ColorProfile.names()) {
			colorProfileScreen.addPreference(new ColorProfilePreference(
				this, fbreader, colorProfileScreen, key, ColorProfilePreference.createTitle(resource, key)
			));
		}
		*/

		final ScrollingPreferences scrollingPreferences = ScrollingPreferences.Instance();

		//final Screen tapZonesScreen = createPreferenceScreen(""tapZones"");
		//tapZonesScreen.addOption(scrollingPreferences.TapZonesSchemeOption, ""tapZonesScheme"");

		final Screen scrollingScreen = createPreferenceScreen(""scrolling"");
		scrollingScreen.addOption(scrollingPreferences.FingerScrollingOption, ""fingerScrolling"");
		scrollingScreen.addOption(fbReader.EnableDoubleTapOption, ""enableDoubleTapDetection"");

		final ZLPreferenceSet volumeKeysPreferences = new ZLPreferenceSet();
		scrollingScreen.addPreference(new ZLBooleanPreference(
			this, scrollingPreferences.VolumeKeysOption, scrollingScreen.Resource, ""volumeKeys""
		) {
			@Override
			protected void onClick() {
				super.onClick();
				volumeKeysPreferences.setEnabled(isChecked());
			}
		});	
		volumeKeysPreferences.add(scrollingScreen.addOption(
			scrollingPreferences.InvertVolumeKeysOption, ""invertVolumeKeys""
		));
		volumeKeysPreferences.setEnabled(scrollingPreferences.VolumeKeysOption.getValue());

		scrollingScreen.addOption(scrollingPreferences.AnimationOption, ""animation"");
		scrollingScreen.addPreference(new AnimationSpeedPreference(
			this,
			scrollingScreen.Resource,
			""animationSpeed"",
			scrollingPreferences.AnimationSpeedOption
		));
		scrollingScreen.addOption(scrollingPreferences.HorizontalOption, ""horizontal"");

		final Screen dictionaryScreen = createPreferenceScreen(""dictionary"");
		dictionaryScreen.addPreference(new DictionaryPreference(
			this,
			dictionaryScreen.Resource,
			""dictionary"",
			DictionaryUtil.singleWordTranslatorOption()
		));
		dictionaryScreen.addPreference(new DictionaryPreference(
			this,
			dictionaryScreen.Resource,
			""translator"",
			DictionaryUtil.multiWordTranslatorOption()
		));
		dictionaryScreen.addPreference(new ZLBooleanPreference(
			this,
			fbReader.NavigateAllWordsOption,
			dictionaryScreen.Resource,
			""navigateOverAllWords""
		));
		dictionaryScreen.addOption(fbReader.WordTappingActionOption, ""tappingAction"");

		final Screen imagesScreen = createPreferenceScreen(""images"");
		imagesScreen.addOption(fbReader.ImageTappingActionOption, ""tappingAction"");
		imagesScreen.addOption(fbReader.ImageViewBackgroundOption, ""backgroundColor"");

		final Screen cancelMenuScreen = createPreferenceScreen(""cancelMenu"");
		cancelMenuScreen.addOption(fbReader.ShowPreviousBookInCancelMenuOption, ""previousBook"");
		cancelMenuScreen.addOption(fbReader.ShowPositionsInCancelMenuOption, ""positions"");
		final ZLKeyBindings bindings = fbReader.keyBindings();
		final String[] backKeyActions =
			//{ ActionCode.EXIT, ActionCode.GO_BACK, ActionCode.SHOW_CANCEL_MENU };
			{ ActionCode.EXIT, ActionCode.SHOW_CANCEL_MENU };
		cancelMenuScreen.addPreference(new ZLStringChoicePreference(
			this, cancelMenuScreen.Resource, ""backKeyAction"",
			bindings.getOption(""<Back>"", false), backKeyActions
		));
		final String[] backKeyLongPressActions =
			//{ ActionCode.EXIT, ActionCode.GO_BACK, ActionCode.SHOW_CANCEL_MENU, FBReaderApp.NoAction };
			{ ActionCode.EXIT, ActionCode.SHOW_CANCEL_MENU, FBReaderApp.NoAction };
		cancelMenuScreen.addPreference(new ZLStringChoicePreference(
			this, cancelMenuScreen.Resource, ""backKeyLongPressAction"",
			bindings.getOption(""<Back>"", true), backKeyLongPressActions
		));
	}
}
",False,323,6,27,7,71,1,36,L6
239,org.geometerplus.android.fbreader.preferences.ZLColorPreference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.content.DialogInterface;
import android.graphics.*;
import android.graphics.drawable.*;
import android.preference.DialogPreference;
import android.view.View;
import android.widget.SeekBar;

import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.options.ZLColorOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.R;
import org.geometerplus.zlibrary.ui.android.util.ZLAndroidColorUtil;

class ZLColorPreference extends DialogPreference implements ZLPreference {
	private final ZLColorOption myOption;

	private SeekBar myRedSlider;
	private SeekBar myGreenSlider;
	private SeekBar myBlueSlider;
	private final GradientDrawable myPreviewDrawable = new GradientDrawable();

	ZLColorPreference(Context context, ZLResource resource, String resourceKey, ZLColorOption option) {
		super(context, null);
		myOption = option;
		final String title = resource.getResource(resourceKey).getValue();
		setTitle(title);
		setDialogTitle(title);
		setDialogLayoutResource(R.layout.color_dialog);

		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		setPositiveButtonText(buttonResource.getResource(""ok"").getValue());
		setNegativeButtonText(buttonResource.getResource(""cancel"").getValue());
	}

	private SeekBar createSlider(View view, int id, int value, String resourceKey) {
		final SeekBar slider = (SeekBar)view.findViewById(id);
		slider.setProgress(value);
		slider.setProgressDrawable(new SeekBarDrawable(
			slider.getProgressDrawable(),
			ZLResource.resource(""color"").getResource(resourceKey).getValue(),
			slider
		));
		return slider;
	}

	@Override
	protected void onBindDialogView(View view) {
		final ZLColor color = myOption.getValue();

		myRedSlider = createSlider(view, R.id.color_red, color.Red, ""red"");
		myGreenSlider = createSlider(view, R.id.color_green, color.Green, ""green"");
		myBlueSlider = createSlider(view, R.id.color_blue, color.Blue, ""blue"");

		final View colorBox = view.findViewById(R.id.color_box);
		colorBox.setBackgroundDrawable(myPreviewDrawable);
		myPreviewDrawable.setCornerRadius(7);
		myPreviewDrawable.setColor(ZLAndroidColorUtil.rgb(color));

		final SeekBar.OnSeekBarChangeListener listener = new SeekBar.OnSeekBarChangeListener() {
			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				myPreviewDrawable.setColor(Color.rgb(
					myRedSlider.getProgress(),
					myGreenSlider.getProgress(),
					myBlueSlider.getProgress()
				));
				myPreviewDrawable.invalidateSelf();
			}

			public void onStartTrackingTouch(SeekBar seekBar) {
			}

			public void onStopTrackingTouch(SeekBar seekBar) {
				myPreviewDrawable.setColor(Color.rgb(
					myRedSlider.getProgress(),
					myGreenSlider.getProgress(),
					myBlueSlider.getProgress()
				));
				myPreviewDrawable.invalidateSelf();
			}
		};
		myRedSlider.setOnSeekBarChangeListener(listener);
		myGreenSlider.setOnSeekBarChangeListener(listener);
		myBlueSlider.setOnSeekBarChangeListener(listener);

		super.onBindDialogView(view);
	}

	@Override
	public void onClick(DialogInterface dialog, int which) {
		if (which == DialogInterface.BUTTON_POSITIVE) {
			myOption.setValue(new ZLColor(
				myRedSlider.getProgress(),
				myGreenSlider.getProgress(),
				myBlueSlider.getProgress()
			));
		}
	}

	/*
	@Override
	protected void onBindView(View view) {
		final ImageView colorView = (ImageView)view.findViewById(R.id.color_preference_color);
		//colorView.setImageResource(R.drawable.fbreader);
		final Drawable drawable = new ColorDrawable(0x00FF00);
		colorView.setImageDrawable(drawable);
		
		super.onBindView(view);
	}
	*/

	public void onAccept() {
	}

	static class SeekBarDrawable extends Drawable {
		private final SeekBar mySlider;
		private final Drawable myBase;
		private final String myText;
		private final Paint myPaint;
		private final Paint myOutlinePaint;
		private boolean myLabelOnRight;

		public SeekBarDrawable(Drawable base, String text, SeekBar slider) {
			mySlider = slider;
			myBase = base;
			myText = text;

			myPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
			myPaint.setTypeface(Typeface.DEFAULT_BOLD);
			myPaint.setColor(Color.BLACK);
			myPaint.setAlpha(255);

			myOutlinePaint = new Paint(myPaint);
			myOutlinePaint.setStyle(Paint.Style.STROKE);
			myOutlinePaint.setStrokeWidth(3);
			myOutlinePaint.setColor(0xFFAAAAAA);

			myLabelOnRight = mySlider.getProgress() < 128;
		}

		@Override
		protected void onBoundsChange(Rect bounds) {
			myBase.setBounds(bounds);
		}
		
		@Override
		protected boolean onStateChange(int[] state) {
			invalidateSelf();
			return false;
		}
		
		@Override
		public boolean isStateful() {
			return true;
		}
		
		@Override
		protected boolean onLevelChange(int level) {
			if (level < 4000) {
				myLabelOnRight = true;
			} else if (level > 6000) {
				myLabelOnRight = false;
			}
			return myBase.setLevel(level);
		}
		
		@Override
		public void draw(Canvas canvas) {
			myBase.draw(canvas);

			final Rect bounds = getBounds();
			final int textSize = bounds.height() * 2 / 3;
			myPaint.setTextSize(textSize);
			myOutlinePaint.setTextSize(textSize);
			final Rect textBounds = new Rect();
			myPaint.getTextBounds(""a"", 0, 1, textBounds);
			final String text = myText + "": "" + mySlider.getProgress();
			final float textWidth = myOutlinePaint.measureText(text);
			final float x = myLabelOnRight ? bounds.width() - textWidth - 6 : 6;
			final float y = bounds.height() / 2 + textBounds.height();
			canvas.drawText(text, x, y, myOutlinePaint);
			canvas.drawText(text, x, y, myPaint);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}
	}
}
",False,91,8,29,7,8,1,5,L6
240,org.geometerplus.android.fbreader.preferences.DictionaryPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.List;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.android.fbreader.DictionaryUtil;
import org.geometerplus.android.fbreader.PackageInfo;

class DictionaryPreference extends ZLStringListPreference {
	private final ZLStringOption myOption;

	DictionaryPreference(Context context, ZLResource resource, String resourceKey, ZLStringOption dictionaryOption) {
		super(context, resource, resourceKey);

		myOption = dictionaryOption;
		final List<PackageInfo> infos = DictionaryUtil.dictionaryInfos(context);
		
		final String[] values = new String[infos.size()];
		final String[] texts = new String[infos.size()];
		int index = 0;
		for (PackageInfo i : infos) {
			values[index] = i.Id;
			texts[index] = i.Title;
			++index;
		}
		setLists(values, texts);

		setInitialValue(myOption.getValue());
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,153,7,27,8,25,1,5,L6
241,org.geometerplus.android.fbreader.preferences.FontStylePreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class FontStylePreference extends ZLStringListPreference {
	private final ZLBooleanOption myBoldOption;
	private final ZLBooleanOption myItalicOption;
	private final String[] myValues = { ""regular"", ""bold"", ""italic"", ""boldItalic"" };

	FontStylePreference(Context context, ZLResource resource, String resourceKey, ZLBooleanOption boldOption, ZLBooleanOption italicOption) {
		super(context, resource, resourceKey);

		myBoldOption = boldOption;
		myItalicOption = italicOption;
		setList(myValues);

		final int intValue =
			(boldOption.getValue() ? 1 : 0) |
			(italicOption.getValue() ? 2 : 0);
		setInitialValue(myValues[intValue]);
	}

	public void onAccept() {
		final int intValue = findIndexOfValue(getValue());
		myBoldOption.setValue((intValue & 0x1) == 0x1);
		myItalicOption.setValue((intValue & 0x2) == 0x2);
	}
}
",False,89,7,27,7,8,1,3,L6
242,org.geometerplus.android.fbreader.preferences.ZLStringChoicePreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLStringChoicePreference extends ZLStringListPreference {
	private final ZLStringOption myOption;

	ZLStringChoicePreference(Context context, ZLResource rootResource, String resourceKey, ZLStringOption option, String[] values) {
		super(context, rootResource, resourceKey);
		setList(values);
		setInitialValue(option.getValue());
		myOption = option;
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,89,7,27,7,8,1,3,L6
243,org.geometerplus.android.fbreader.preferences.ZLIntegerChoicePreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLIntegerOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLIntegerChoicePreference extends ZLStringListPreference {
	private final ZLIntegerOption myOption;
	private final int[] myValues;

	ZLIntegerChoicePreference(Context context, ZLResource resource, String resourceKey, ZLIntegerOption option, int[] values, String[] valueResourceKeys) {
		super(context, resource, resourceKey);
		assert(values.length == valueResourceKeys.length);

		myOption = option;
		myValues = values;
		setList(valueResourceKeys);

		final int initialValue = option.getValue();
		int index = 0;
		int minDiff = Math.abs(values[0] - initialValue);
		for (int i = 1; i < values.length; ++i) {
			final int diff = Math.abs(values[i] - initialValue);
			if (diff < minDiff) {
				minDiff = diff;
				index = i;
			}
		}
		setInitialValue(valueResourceKeys[index]);
	}

	public void onAccept() {
		myOption.setValue(myValues[findIndexOfValue(getValue())]);
	}
}
",False,89,7,27,7,8,1,3,L6
244,org.geometerplus.android.fbreader.preferences.ZLPreferenceActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.ArrayList;

import android.os.Bundle;
import android.preference.*;
import android.content.Intent;

import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLPreferenceActivity extends android.preference.PreferenceActivity {
	private final ArrayList<ZLPreference> myPreferences = new ArrayList<ZLPreference>();

	protected class Screen {
		public final ZLResource Resource;
		private final PreferenceScreen myScreen;

		private Screen(ZLResource root, String resourceKey) {
			Resource = root.getResource(resourceKey);
			myScreen = getPreferenceManager().createPreferenceScreen(ZLPreferenceActivity.this);
			myScreen.setTitle(Resource.getValue());
			myScreen.setSummary(Resource.getResource(""summary"").getValue());
		}

		public void setSummary(CharSequence summary) {
			myScreen.setSummary(summary);
		}

		public Screen createPreferenceScreen(String resourceKey) {
			Screen screen = new Screen(Resource, resourceKey);
			myScreen.addPreference(screen.myScreen);
			return screen;
		}

		public ZLPreference addPreference(ZLPreference preference) {
			myScreen.addPreference((Preference)preference);
			myPreferences.add(preference);
			return preference;
		}

		public ZLPreference addOption(ZLBooleanOption option, String resourceKey) {
			return addPreference(
				new ZLBooleanPreference(ZLPreferenceActivity.this, option, Resource, resourceKey)
			);
		}

		public ZLPreference addOption(ZLStringOption option, String resourceKey) {
			return addPreference(
				new ZLStringOptionPreference(ZLPreferenceActivity.this, option, Resource, resourceKey)
			);
		}

		public ZLPreference addOption(ZLColorOption option, String resourceKey) {
			return addPreference(
				new ZLColorPreference(ZLPreferenceActivity.this, Resource, resourceKey, option)
			);
		}

		public <T extends Enum<T>> ZLPreference addOption(ZLEnumOption<T> option, String resourceKey) {
			return addPreference(
				new ZLEnumPreference<T>(ZLPreferenceActivity.this, option, Resource, resourceKey)
			);
		}

		public void close() {
			myScreen.getDialog().dismiss();
			ZLPreferenceActivity.this.getListView().invalidateViews();
		}

		public void setOnPreferenceClickListener(PreferenceScreen.OnPreferenceClickListener onPreferenceClickListener) {
			myScreen.setOnPreferenceClickListener(onPreferenceClickListener);
		}
	}

	private PreferenceScreen myScreen;
	final ZLResource Resource;

	ZLPreferenceActivity(String resourceKey) {
		Resource = ZLResource.resource(""dialog"").getResource(resourceKey);
	}

	Screen createPreferenceScreen(String resourceKey) {
		Screen screen = new Screen(Resource, resourceKey);
		myScreen.addPreference(screen.myScreen);
		return screen;
	}

	public ZLPreference addPreference(ZLPreference preference) {
		myScreen.addPreference((Preference)preference);
		myPreferences.add(preference);
		return preference;
	}

	public ZLPreference addOption(ZLBooleanOption option, String resourceKey) {
		ZLBooleanPreference preference =
			new ZLBooleanPreference(ZLPreferenceActivity.this, option, Resource, resourceKey);
		myScreen.addPreference(preference);
		myPreferences.add(preference);
		return preference;
	}

	/*
	protected Category createCategory() {
		return new CategoryImpl(myScreen, Resource);
	}
	*/

	protected abstract void init(Intent intent);

	@Override
	protected void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		myScreen = getPreferenceManager().createPreferenceScreen(this);

		init(getIntent());

		setPreferenceScreen(myScreen);
	}

	@Override
	protected void onPause() {
		for (ZLPreference preference : myPreferences) {
			preference.onAccept();
		}
		super.onPause();
	}
}
",False,101,7,29,7,11,2,11,L6
245,org.geometerplus.android.fbreader.preferences.ZLPreferenceSet.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.LinkedList;

import android.preference.Preference;

class ZLPreferenceSet {
	private final LinkedList<ZLPreference> myPreferences = new LinkedList<ZLPreference>();

	final void add(ZLPreference preference) {
		myPreferences.add(preference);
	}

	final void setEnabled(boolean enable) {
		for (ZLPreference preference : myPreferences) {
			((Preference)preference).setEnabled(enable);
		}
	}
}
",False,57,7,27,1,1,1,1,L6
246,org.geometerplus.android.fbreader.preferences.EditBookInfoActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.TreeSet;

import android.content.Context;
import android.content.Intent;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.zlibrary.text.hyphenation.ZLTextHyphenator;

import org.geometerplus.fbreader.library.Book;

import org.geometerplus.android.fbreader.BookInfoActivity;
import org.geometerplus.android.fbreader.SQLiteBooksDatabase;

class BookTitlePreference extends ZLStringPreference {
	private final Book myBook;

	BookTitlePreference(Context context, ZLResource rootResource, String resourceKey, Book book) {
		super(context, rootResource, resourceKey);
		myBook = book;
		setValue(book.getTitle());
	}

	public void onAccept() {
		myBook.setTitle(getValue());
	}
}

class LanguagePreference extends ZLStringListPreference {
	private final Book myBook;

	LanguagePreference(Context context, ZLResource rootResource, String resourceKey, Book book) {
		super(context, rootResource, resourceKey);
		myBook = book;
		final TreeSet<String> set = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
		set.addAll(ZLTextHyphenator.Instance().languageCodes());
		set.add(ZLLanguageUtil.OTHER_LANGUAGE_CODE);

		final int size = set.size();
		String[] codes = new String[size];
		String[] names = new String[size];
		int index = 0;
		for (String code : set) {
			codes[index] = code;
			names[index] = ZLLanguageUtil.languageName(code);
			++index;
		}
		setLists(codes, names);
		String language = myBook.getLanguage();
		if (language == null) {
			language = ZLLanguageUtil.OTHER_LANGUAGE_CODE;
		}
		if (!setInitialValue(language)) {
			setInitialValue(ZLLanguageUtil.OTHER_LANGUAGE_CODE);
		}
	}

	public void onAccept() {
		final String value = getValue();
		myBook.setLanguage((value.length() != 0) ? value : null);
	}
}

public class EditBookInfoActivity extends ZLPreferenceActivity {
	private Book myBook;

	public EditBookInfoActivity() {
		super(""BookInfo"");
	}

	@Override
	protected void init(Intent intent) {
		if (SQLiteBooksDatabase.Instance() == null) {
			new SQLiteBooksDatabase(this, ""LIBRARY"");
		}

		final String path = intent.getStringExtra(BookInfoActivity.CURRENT_BOOK_PATH_KEY);
		final ZLFile file = ZLFile.createFileByPath(path);
		myBook = Book.getByFile(file);

		if (myBook == null) {
			finish();
			return;
		}

		addPreference(new BookTitlePreference(this, Resource, ""title"", myBook));
		addPreference(new LanguagePreference(this, Resource, ""language"", myBook));
	}

	@Override
	protected void onPause() {
		super.onPause();
		if (myBook != null) {
			myBook.save();
		}
	}
}
",False,421,0,0,9,114,1,11,L6
247,org.geometerplus.android.fbreader.preferences.WallpaperPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.*;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.fbreader.ColorProfile;
import org.geometerplus.fbreader.fbreader.WallpapersUtil;

class WallpaperPreference extends ZLStringListPreference {
	private final ZLStringOption myOption;

	WallpaperPreference(Context context, ColorProfile profile, ZLResource resource, String resourceKey) {
		super(context, resource, resourceKey);

		myOption = profile.WallpaperOption;
		final List<ZLFile> predefined = WallpapersUtil.predefinedWallpaperFiles();
		final List<ZLFile> external = WallpapersUtil.externalWallpaperFiles();
		
		final int size = 1 + predefined.size() + external.size();
		final String[] values = new String[size];
		final String[] texts = new String[size];

		final ZLResource optionResource = resource.getResource(resourceKey);
		values[0] = """";
		texts[0] = optionResource.getResource(""solidColor"").getValue();
		int index = 1;
		for (ZLFile f : predefined) {
			values[index] = f.getPath();
			final String name = f.getShortName();
			texts[index] = optionResource.getResource(
				name.substring(0, name.indexOf("".""))
			).getValue();
			++index;
		}
		for (ZLFile f : external) {
			values[index] = f.getPath();
			texts[index] = f.getShortName();
			++index;
		}
		setLists(values, texts);

		setInitialValue(myOption.getValue());
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,95,7,27,6,12,1,6,L6
248,org.geometerplus.android.fbreader.preferences.ZLStringOptionPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import android.content.Context;

class ZLStringOptionPreference extends ZLStringPreference {
	private final ZLStringOption myOption;

	ZLStringOptionPreference(Context context, ZLStringOption option, ZLResource rootResource, String resourceKey) {
		super(context, rootResource, resourceKey);
		myOption = option;
		setValue(myOption.getValue());
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,90,8,29,7,8,1,3,L6
249,org.geometerplus.android.fbreader.preferences.ZLEnumPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLEnumOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLEnumPreference<T extends Enum<T>> extends ZLStringListPreference {
	private final ZLEnumOption<T> myOption;

	ZLEnumPreference(Context context, ZLEnumOption<T> option, ZLResource resource, String resourceKey) {
		super(context, resource, resourceKey);
		myOption = option;

		final T initialValue = option.getValue();
		final T[] allValues = initialValue.getDeclaringClass().getEnumConstants();
		final String[] stringValues = new String[allValues.length];
		for (int i = 0; i < stringValues.length; ++i) {
			stringValues[i] = allValues[i].toString();
		}
		setList(stringValues);
		setInitialValue(initialValue.toString());
	}

	public void onAccept() {
		myOption.setValue(Enum.valueOf(myOption.getValue().getDeclaringClass(), getValue()));
	}
}
",False,90,8,29,7,8,1,3,L6
250,org.geometerplus.android.fbreader.preferences.ZLChoicePreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLChoicePreference extends ZLStringListPreference {
	private final ZLIntegerRangeOption myOption;

	ZLChoicePreference(Context context, ZLResource resource, String resourceKey, ZLIntegerRangeOption option, String[] valueResourceKeys) {
		super(context, resource, resourceKey);

		assert(option.MaxValue - option.MinValue + 1 == valueResourceKeys.length);

		myOption = option;
		setList(valueResourceKeys);

		setInitialValue(valueResourceKeys[option.getValue() - option.MinValue]);
	}

	public void onAccept() {
		myOption.setValue(myOption.MinValue + findIndexOfValue(getValue()));
	}
}
",False,89,7,27,7,8,1,3,L6
251,org.geometerplus.android.fbreader.preferences.BatteryLevelToTurnScreenOffPreference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;

class BatteryLevelToTurnScreenOffPreference extends ZLStringListPreference {
	private final ZLIntegerRangeOption myOption;

	BatteryLevelToTurnScreenOffPreference(Context context, ZLIntegerRangeOption option, ZLResource rootResource, String resourceKey) {
		super(context, rootResource, resourceKey);
		myOption = option;
		String[] entries = { ""0"", ""25"", ""50"", ""100"" };
		setList(entries);

		int value = option.getValue();
		if (value <= 0) {
			setInitialValue(""0"");
		} else if (value <= 25) {
			setInitialValue(""25"");
		} else if (value <= 50) {
			setInitialValue(""50"");
		} else {
			setInitialValue(""100"");
		}
	}

	public void onAccept() {
		try {
			myOption.setValue(Integer.parseInt(getValue()));
		} catch (NumberFormatException e) {
		}
	}
}
",True,89,7,27,7,8,1,3,L6
252,org.geometerplus.android.fbreader.preferences.AnimationSpeedPreference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.content.DialogInterface;
import android.graphics.*;
import android.graphics.drawable.*;
import android.preference.DialogPreference;
import android.view.View;
import android.widget.SeekBar;

import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.R;

class AnimationSpeedPreference extends DialogPreference implements ZLPreference {
	private final ZLIntegerRangeOption myOption;
	private final ZLResource myResource;

	private SeekBar mySlider;

	AnimationSpeedPreference(Context context, ZLResource resource, String resourceKey, ZLIntegerRangeOption option) {
		super(context, null);
		myOption = option;
		myResource = resource.getResource(resourceKey);
		final String title = myResource.getValue();
		setTitle(title);
		setDialogTitle(title);
		setDialogLayoutResource(R.layout.animation_speed_dialog);

		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		setPositiveButtonText(buttonResource.getResource(""ok"").getValue());
		setNegativeButtonText(buttonResource.getResource(""cancel"").getValue());
	}

	@Override
	protected void onBindDialogView(View view) {
		mySlider = (SeekBar)view.findViewById(R.id.animation_speed_slider);
		mySlider.setMax(myOption.MaxValue - myOption.MinValue);
		mySlider.setProgress(myOption.getValue() - myOption.MinValue);
		mySlider.setProgressDrawable(new SeekBarDrawable());

		super.onBindDialogView(view);
	}

	@Override
	public void onClick(DialogInterface dialog, int which) {
		if (which == DialogInterface.BUTTON_POSITIVE) {
			myOption.setValue(myOption.MinValue + mySlider.getProgress());
		}
	}

	public void onAccept() {
	}

	private class SeekBarDrawable extends Drawable {
		private final Drawable myBase;
		private final Paint myPaint;
		private final Paint myOutlinePaint;

		public SeekBarDrawable() {
			myBase = mySlider.getProgressDrawable();

			myPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
			myPaint.setTypeface(Typeface.DEFAULT_BOLD);
			myPaint.setColor(Color.BLACK);
			myPaint.setAlpha(255);

			myOutlinePaint = new Paint(myPaint);
			myOutlinePaint.setStyle(Paint.Style.STROKE);
			myOutlinePaint.setStrokeWidth(3);
			myOutlinePaint.setColor(0xFFAAAAAA);
		}

		@Override
		protected void onBoundsChange(Rect bounds) {
			myBase.setBounds(bounds);
		}
		
		@Override
		protected boolean onStateChange(int[] state) {
			invalidateSelf();
			return false;
		}
		
		@Override
		public boolean isStateful() {
			return true;
		}
		
		@Override
		protected boolean onLevelChange(int level) {
			return myBase.setLevel(level);
		}
		
		@Override
		public void draw(Canvas canvas) {
			myBase.draw(canvas);

			final Rect bounds = getBounds();
			final int textSize = bounds.height() * 2 / 3;
			myPaint.setTextSize(textSize);
			myOutlinePaint.setTextSize(textSize);

			final Rect textBounds = new Rect();
			myPaint.getTextBounds(""a"", 0, 1, textBounds);
			final float y = bounds.height() / 2 + textBounds.height();

			final int progress = mySlider.getProgress();
			final int max = mySlider.getMax();
			if (progress >= max / 3) {
				final String text = myResource.getResource(""slow"").getValue();
				//final float textWidth = myOutlinePaint.measureText(text);
				final float x = 6;
				canvas.drawText(text, x, y, myOutlinePaint);
				canvas.drawText(text, x, y, myPaint);
			}
			if (progress <= 2 * max / 3) {
				final String text = myResource.getResource(""fast"").getValue();
				final float textWidth = myOutlinePaint.measureText(text);
				final float x = bounds.width() - textWidth - 6;
				canvas.drawText(text, x, y, myOutlinePaint);
				canvas.drawText(text, x, y, myPaint);
			}
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}
	}
}
",False,88,7,27,7,8,1,3,L6
253,org.geometerplus.android.fbreader.preferences.FontOption.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.ArrayList;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.view.AndroidFontUtil;

class FontOption extends ZLStringListPreference {
	private final ZLStringOption myOption;

	private static String UNCHANGED = ""unchanged"";

	FontOption(Context context, ZLResource resource, String resourceKey, ZLStringOption option, boolean includeDummyValue) {
		super(context, resource, resourceKey);

		myOption = option;
		final ArrayList<String> fonts = new ArrayList<String>();
		AndroidFontUtil.fillFamiliesList(fonts, true);
		if (includeDummyValue) {
			fonts.add(0, UNCHANGED);
		}
		setList((String[])fonts.toArray(new String[fonts.size()]));

		final String optionValue = option.getValue();
		final String initialValue = optionValue.length() > 0 ?
			AndroidFontUtil.realFontFamilyName(optionValue) : UNCHANGED;
		for (String fontName : fonts) {
			if (initialValue.equals(fontName)) {
				setInitialValue(fontName);
				return;
			}
		}
		for (String fontName : fonts) {
			if (initialValue.equals(AndroidFontUtil.realFontFamilyName(fontName))) {
				setInitialValue(fontName);
				return;
			}
		}
	}

	public void onAccept() {
		final String value = getValue();
		myOption.setValue(UNCHANGED.equals(value) ? """" : value);
	}
}
",False,94,7,27,7,8,1,4,L6
254,org.geometerplus.android.fbreader.preferences.InfoPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.Preference;

class InfoPreference extends Preference implements ZLPreference {
	InfoPreference(Context context, String title, String value) {
		super(context);
		setTitle(title);
		setSummary(value);
		setEnabled(false);
	}

	public void onAccept() {
	}
}
",False,2,0,0,1,1,0,1,L7
255,org.geometerplus.android.fbreader.preferences.ZLStringListPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.ListPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLStringListPreference extends ListPreference implements ZLPreference {
	private final ZLResource myResource;

	ZLStringListPreference(Context context, ZLResource rootResource, String resourceKey) {
		super(context);

		myResource = rootResource.getResource(resourceKey);
		setTitle(myResource.getValue());
	}

	protected final void setList(String[] values) {
		String[] texts = new String[values.length];
		for (int i = 0; i < values.length; ++i) {
			final ZLResource resource = myResource.getResource(values[i]);
			texts[i] = resource.hasValue() ? resource.getValue() : values[i];
		}
		setLists(values, texts);
	}

	protected final void setLists(String[] values, String[] texts) {
		assert(values.length == texts.length);
		setEntries(texts);
		setEntryValues(values);
	}

	protected final boolean setInitialValue(String value) {
		if (value == null) {
			return false;
		}
		// throws NPE in some cases (?)
		//final int index = findIndexOfValue(value);
		int index = -1;
		final CharSequence[] entryValues = getEntryValues();
		for (int i = 0; i < entryValues.length; ++i) {
			if (value.equals(entryValues[i])) {
				index = i;
				break;
			}
		}
		if (index >= 0) {
			setValueIndex(index);
			setSummary(getEntry());
			return true;
		}
		return false;
	}

	@Override
	protected void onDialogClosed(boolean result) {
		super.onDialogClosed(result);
		if (result) {
			setSummary(getEntry());
		}
	}
}
",False,96,7,29,7,8,12,2,L6
256,org.geometerplus.android.fbreader.preferences.ZLBoolean3Preference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;
import org.geometerplus.zlibrary.core.options.ZLBoolean3Option;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLBoolean3Preference extends ZLStringListPreference {
	private static final String ON = ""on"";
	private static final String OFF = ""off"";
	private static final String UNCHANGED = ""unchanged"";

	private final ZLBoolean3Option myOption;

	ZLBoolean3Preference(Context context, ZLResource resource, String resourceKey, ZLBoolean3Option option) {
		super(context, resource, resourceKey);

		myOption = option;
		setList(new String[] { ON, OFF, UNCHANGED });

		switch (option.getValue()) {
			case B3_TRUE:
				setInitialValue(ON);
				break;
			case B3_FALSE:
				setInitialValue(OFF);
				break;
			case B3_UNDEFINED:
				setInitialValue(UNCHANGED);
				break;
		}
	}

	public void onAccept() {
		final String value = getValue();
		if (ON.equals(value)) {
			myOption.setValue(ZLBoolean3.B3_TRUE);
		} else if (OFF.equals(value)) {
			myOption.setValue(ZLBoolean3.B3_FALSE);
		} else {
			myOption.setValue(ZLBoolean3.B3_UNDEFINED);
		}
	}
}
",False,90,7,27,7,8,1,4,L6
257,org.geometerplus.android.fbreader.preferences.ZLBooleanPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.CheckBoxPreference;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLBooleanPreference extends CheckBoxPreference implements ZLPreference {
	private final ZLBooleanOption myOption;

	ZLBooleanPreference(Context context, ZLBooleanOption option, ZLResource rootResource, String resourceKey) {
		super(context);
		myOption = option;

		ZLResource resource = rootResource.getResource(resourceKey);
		setTitle(resource.getValue());
		setSummaryOn(resource.getResource(""summaryOn"").getValue());
		setSummaryOff(resource.getResource(""summaryOff"").getValue());
		setChecked(option.getValue());
	}

	@Override
	protected void onClick() {
		super.onClick();
		myOption.setValue(isChecked());
	}

	public void onAccept() {
	}
}
",False,89,7,26,7,8,2,3,L6
258,org.geometerplus.android.fbreader.preferences.ZLStringPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.EditTextPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLStringPreference extends EditTextPreference implements ZLPreference {
	private String myValue;

	ZLStringPreference(Context context, ZLResource rootResource, String resourceKey) {
		super(context);

		ZLResource resource = rootResource.getResource(resourceKey);
		setTitle(resource.getValue());
	}

	protected final void setValue(String value) {
		setSummary(value);
		setText(value);
		myValue = value;
	}

	protected final String getValue() {
		return myValue;
	}

	@Override
	protected void onDialogClosed(boolean result) {
		if (result) {
			setValue(getEditText().getText().toString());
		}
		super.onDialogClosed(result);
	}
}
",False,87,8,23,7,8,2,2,L6
259,org.geometerplus.android.fbreader.preferences.ZLIntegerRangePreference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.ListPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;

class ZLIntegerRangePreference extends ListPreference implements ZLPreference {
	private final ZLIntegerRangeOption myOption;

	ZLIntegerRangePreference(Context context, ZLResource resource, ZLIntegerRangeOption option) {
		super(context);
		myOption = option;
		setTitle(resource.getValue());
		String[] entries = new String[option.MaxValue - option.MinValue + 1];
		for (int i = 0; i < entries.length; ++i) {
			entries[i] = ((Integer)(i + option.MinValue)).toString();
		}
		setEntries(entries);
		setEntryValues(entries);
		setValueIndex(option.getValue() - option.MinValue);
		setSummary(getValue());
	}

	@Override
	protected void onDialogClosed(boolean result) {
		super.onDialogClosed(result);
		if (result) {
			final String value = getValue();
			setSummary(value);
			myOption.setValue(myOption.MinValue + findIndexOfValue(value));
		}
	}

	public void onAccept() {
	}
}
",False,88,7,27,7,8,1,3,L6
260,org.geometerplus.android.fbreader.network.NetworkBookInfoActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.Activity;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.text.method.LinkMovementMethod;
import android.util.DisplayMetrics;
import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.util.MimeType;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;
import org.geometerplus.zlibrary.ui.android.network.SQLiteCookieDatabase;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;
import org.geometerplus.fbreader.network.urlInfo.*;

public class NetworkBookInfoActivity extends Activity implements NetworkView.EventListener {
	private NetworkBookItem myBook;
	private View myMainView;

	private final ZLResource myResource = ZLResource.resource(""networkBookView"");
	private BookDownloaderServiceConnection myConnection;

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		SQLiteCookieDatabase.init(this);

		myMainView = getLayoutInflater().inflate(R.layout.network_book, null, false);
		setContentView(myMainView);
		myMainView.setOnCreateContextMenuListener(this);
	}

	@Override
	protected void onResume() {
		super.onResume();

		if (!NetworkView.Instance().isInitialized()) {
			if (NetworkInitializer.Instance == null) {
				new NetworkInitializer(null);
				NetworkInitializer.Instance.start();
			} else {
				NetworkInitializer.Instance.setActivity(null);
			}
		}

		if (myBook == null) {
			final NetworkTree tree = Util.getTreeFromIntent(getIntent());
			if (!(tree instanceof NetworkBookTree)) {
				finish();
				return;
			}
			myBook = ((NetworkBookTree)tree).Book;
        
			myConnection = new BookDownloaderServiceConnection();
			bindService(
				new Intent(getApplicationContext(), BookDownloaderService.class),
				myConnection,
				BIND_AUTO_CREATE
			);
        
			setTitle(myBook.Title);
        
			setupDescription();
			setupExtraLinks();
			setupInfo();
			setupCover();
			setupButtons();
		}
	}

	View getMainView() {
		return myMainView;
	}

	private void setTextById(int id, CharSequence text) {
		((TextView)findViewById(id)).setText(text);
	}

	private void setTextFromResource(int id, String resourceKey) {
		setTextById(id, myResource.getResource(resourceKey).getValue());
	}

	@Override
	public void onDestroy() {
		if (!NetworkView.Instance().isInitialized() && NetworkInitializer.Instance != null) {
			NetworkInitializer.Instance.setActivity(null);
		}
		if (myConnection != null) {
			unbindService(myConnection);
			myConnection = null;
		}
		super.onDestroy();
	}

	@Override
	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
		NetworkView.Instance().getTopupActions().buildContextMenu(this, menu, myBook.Link);
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		TopupActions.runAction(this, myBook.Link, item.getItemId());
		return true;
	}

	private final void setupDescription() {
		setTextFromResource(R.id.network_book_description_title, ""description"");

		CharSequence description = myBook.getSummary();
		if (description == null) {
			description = myResource.getResource(""noDescription"").getValue();
		}
		final TextView descriptionView = (TextView)findViewById(R.id.network_book_description);
		descriptionView.setText(description);
		descriptionView.setMovementMethod(new LinkMovementMethod());
	}

	private final void setupExtraLinks() {
		final List<UrlInfo> extraLinks = myBook.getAllInfos(UrlInfo.Type.Related);
		if (extraLinks.isEmpty()) {
			findViewById(R.id.network_book_extra_links_title).setVisibility(View.GONE);
			findViewById(R.id.network_book_extra_links).setVisibility(View.GONE);
		} else {
			setTextFromResource(R.id.network_book_extra_links_title, ""extraLinks"");
			final LinearLayout extraLinkSection =
				(LinearLayout)findViewById(R.id.network_book_extra_links);
			final LayoutInflater inflater = getLayoutInflater();
			View linkView = null;
			for (UrlInfo info : extraLinks) {
				if (!(info instanceof RelatedUrlInfo)) {
					continue;
				}
				final RelatedUrlInfo relatedInfo = (RelatedUrlInfo)info;
				linkView = inflater.inflate(R.layout.extra_link_item, extraLinkSection, false);
				linkView.setOnClickListener(new View.OnClickListener() {
					public void onClick(View view) {
						final NetworkCatalogItem catalogItem =
							myBook.createRelatedCatalogItem(relatedInfo);
						if (catalogItem != null) {
							NetworkCatalogActions.doExpandCatalog(
								NetworkBookInfoActivity.this,
								NetworkLibrary.Instance().getFakeCatalogTree(catalogItem)
							);
						} else if (MimeType.TEXT_HTML.equals(relatedInfo.Mime)) {
							Util.openInBrowser(NetworkBookInfoActivity.this, relatedInfo.Url);
						}
					}
				});
				((TextView)linkView.findViewById(R.id.extra_link_title)).setText(relatedInfo.Title);
				extraLinkSection.addView(linkView);
			}
			linkView.findViewById(R.id.extra_link_divider).setVisibility(View.GONE);
		}
	}

	private void setPairLabelTextFromResource(int id, String resourceKey) {
		final LinearLayout layout = (LinearLayout)findViewById(id);
		((TextView)layout.findViewById(R.id.book_info_key))
			.setText(myResource.getResource(resourceKey).getValue());
	}

	private void setPairValueText(int id, CharSequence text) {
		final LinearLayout layout = (LinearLayout)findViewById(id);
		((TextView)layout.findViewById(R.id.book_info_value)).setText(text);
	}

	private void setupInfo() {
		setTextFromResource(R.id.network_book_info_title, ""bookInfo"");

		setPairLabelTextFromResource(R.id.network_book_title, ""title"");
		setPairLabelTextFromResource(R.id.network_book_authors, ""authors"");
		setPairLabelTextFromResource(R.id.network_book_series_title, ""series"");
		setPairLabelTextFromResource(R.id.network_book_series_index, ""indexInSeries"");
		setPairLabelTextFromResource(R.id.network_book_tags, ""tags"");
		setPairLabelTextFromResource(R.id.network_book_catalog, ""catalog"");

		setPairValueText(R.id.network_book_title, myBook.Title);

		if (myBook.Authors.size() > 0) {
			findViewById(R.id.network_book_authors).setVisibility(View.VISIBLE);
			final StringBuilder authorsText = new StringBuilder();
			for (NetworkBookItem.AuthorData author : myBook.Authors) {
				if (authorsText.length() > 0) {
					authorsText.append("", "");
				}
				authorsText.append(author.DisplayName);
			}
			setPairValueText(R.id.network_book_authors, authorsText);
		} else {
			findViewById(R.id.network_book_authors).setVisibility(View.GONE);
		}

		if (myBook.SeriesTitle != null) {
			findViewById(R.id.network_book_series_title).setVisibility(View.VISIBLE);
			setPairValueText(R.id.network_book_series_title, myBook.SeriesTitle);
			final float indexInSeries = myBook.IndexInSeries;
			if (indexInSeries > 0) {
				final String seriesIndexString;
				if (Math.abs(indexInSeries - Math.round(indexInSeries)) < 0.01) {
					seriesIndexString = String.valueOf(Math.round(indexInSeries));
				} else {
					seriesIndexString = String.format(""%.1f"", indexInSeries);
				}
				setPairValueText(R.id.network_book_series_index, seriesIndexString);
				findViewById(R.id.network_book_series_index).setVisibility(View.VISIBLE);
			} else {
				findViewById(R.id.network_book_series_index).setVisibility(View.GONE);
			}
		} else {
			findViewById(R.id.network_book_series_title).setVisibility(View.GONE);
			findViewById(R.id.network_book_series_index).setVisibility(View.GONE);
		}

		if (myBook.Tags.size() > 0) {
			findViewById(R.id.network_book_tags).setVisibility(View.VISIBLE);
			final StringBuilder tagsText = new StringBuilder();
			for (String tag : myBook.Tags) {
				if (tagsText.length() > 0) {
					tagsText.append("", "");
				}
				tagsText.append(tag);
			}
			setPairValueText(R.id.network_book_tags, tagsText);
		} else {
			findViewById(R.id.network_book_tags).setVisibility(View.GONE);
		}

		setPairValueText(R.id.network_book_catalog, myBook.Link.getTitle());
	}

	private final void setupCover() {
		final View rootView = findViewById(R.id.network_book_root);
		final ImageView coverView = (ImageView)findViewById(R.id.network_book_cover);

		final DisplayMetrics metrics = new DisplayMetrics();
		getWindowManager().getDefaultDisplay().getMetrics(metrics);

		final int maxHeight = metrics.heightPixels * 2 / 3;
		final int maxWidth = maxHeight * 2 / 3;
		Bitmap coverBitmap = null;
		final ZLImage cover = NetworkTree.createCover(myBook);
		if (cover != null) {
			ZLAndroidImageData data = null;
			final ZLAndroidImageManager mgr = (ZLAndroidImageManager)ZLAndroidImageManager.Instance();
			if (cover instanceof ZLLoadableImage) {
				final ZLLoadableImage img = (ZLLoadableImage)cover;
				img.startSynchronization(new Runnable() {
					public void run() {
						img.synchronizeFast();
						final ZLAndroidImageData data = mgr.getImageData(img);
						if (data != null) {
							final Bitmap coverBitmap = data.getBitmap(maxWidth, maxHeight);
							if (coverBitmap != null) {
								coverView.setImageBitmap(coverBitmap);
								coverView.setVisibility(View.VISIBLE);
								rootView.invalidate();
								rootView.requestLayout();
							}
						}
					}
				});
			} else {
				data = mgr.getImageData(cover);
			}
			if (data != null) {
				coverBitmap = data.getBitmap(maxWidth, maxHeight);
			}
		}
		if (coverBitmap != null) {
			coverView.setImageBitmap(coverBitmap);
			coverView.setVisibility(View.VISIBLE);
		} else {
			coverView.setVisibility(View.GONE);
		}
	}

	private final void setupButtons() {
		final ZLResource resource = ZLResource.resource(""networkView"");
		final int buttons[] = new int[] {
				R.id.network_book_button0,
				R.id.network_book_button1,
				R.id.network_book_button2,
				R.id.network_book_button3,
		};
		final Set<NetworkBookActions.Action> actions = NetworkBookActions.getContextMenuActions(myBook, myConnection);

		final boolean skipSecondButton =
			actions.size() < buttons.length &&
			actions.size() % 2 == 1;
		int buttonNumber = 0;
		for (final NetworkBookActions.Action a : actions) {
			if (skipSecondButton && buttonNumber == 1) {
				++buttonNumber;
			}
			if (buttonNumber >= buttons.length) {
				break;
			}

			final String text;
			if (a.Arg == null) {
				text = resource.getResource(a.Key).getValue();
			} else {
				text = resource.getResource(a.Key).getValue().replace(""%s"", a.Arg);
			}

			final int buttonId = buttons[buttonNumber++];
			TextView button = (TextView)findViewById(buttonId);
			button.setText(text);
			button.setVisibility(View.VISIBLE);
			button.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					NetworkBookActions.runActionStatic(NetworkBookInfoActivity.this, myBook, a.Id);
					NetworkBookInfoActivity.this.updateView();
				}
			});
			button.setEnabled(a.Id != NetworkTreeActions.TREE_NO_ACTION);
		}
		findViewById(R.id.network_book_left_spacer).setVisibility(skipSecondButton ? View.VISIBLE : View.GONE);
		findViewById(R.id.network_book_right_spacer).setVisibility(skipSecondButton ? View.VISIBLE : View.GONE);
		if (skipSecondButton) {
			final int buttonId = buttons[1];
			View button = findViewById(buttonId);
			button.setVisibility(View.GONE);
			button.setOnClickListener(null);
		}
		while (buttonNumber < buttons.length) {
			final int buttonId = buttons[buttonNumber++];
			View button = findViewById(buttonId);
			button.setVisibility(View.GONE);
			button.setOnClickListener(null);
		}
	}

	private void updateView() {
		setupButtons();
		final View rootView = findViewById(R.id.network_book_root);
		rootView.invalidate();
		rootView.requestLayout();
	}

	@Override
	protected void onStart() {
		super.onStart();
		NetworkView.Instance().addEventListener(this);
	}

	@Override
	protected void onStop() {
		NetworkView.Instance().removeEventListener(this);
		super.onStop();
	}

	public void onModelChanged() {
		runOnUiThread(new Runnable() {
			public void run() {
				updateView();
			}
		});
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		switch (requestCode) {
			case NetworkBaseActivity.CUSTOM_AUTHENTICATION_CODE:
				Util.processCustomAuthentication(this, myBook.Link, resultCode, data);
				break;
			case NetworkBaseActivity.SIGNUP_CODE:
				Util.processSignup(myBook.Link, resultCode, data);
				break;
		}
	}
}
",False,421,0,0,8,116,1,26,L6
261,org.geometerplus.android.fbreader.network.LibraryInitializationService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.app.Service;
import android.content.Intent;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

public class LibraryInitializationService extends Service {
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);

		final NetworkView view = NetworkView.Instance();
		if (!view.isInitialized()) {
			stopSelf();
			return;
		}

		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				if (msg.what > 0 && msg.obj == null) {
					view.finishBackgroundUpdate();
				}
				stopSelf();
			}
		};

		final Thread thread = new Thread(new Runnable() {
			public void run() {
				int code = 0;
				String error = null;
				try {
					try {
						view.runBackgroundUpdate(false);
					} catch (ZLNetworkException e) {
						error = e.getMessage();
					}
					code = 1;
				} finally {
					handler.sendMessage(handler.obtainMessage(code, error));
				}
			}
		});
		thread.setPriority(Thread.MIN_PRIORITY);
		thread.start();
	}
}
",True,422,0,0,9,113,0,2,L7
262,org.geometerplus.android.fbreader.network.UserRegistrationConstants.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

public interface UserRegistrationConstants {
	String USER_REGISTRATION_USERNAME = ""userName"";
	String USER_REGISTRATION_PASSWORD = ""password"";
	String USER_REGISTRATION_EMAIL = ""eMail"";
	String USER_REGISTRATION_LITRES_SID = ""litres:sid"";
}
",True,55,7,26,0,0,2,0,L6
263,org.geometerplus.android.fbreader.network.Util.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.Context;
import android.net.Uri;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;
import org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;
import org.geometerplus.fbreader.network.urlInfo.UrlInfo;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.util.PackageUtil;

abstract class Util implements UserRegistrationConstants {
	private static final String REGISTRATION_ACTION =
		""android.fbreader.action.NETWORK_LIBRARY_REGISTER"";
	static final String SMS_TOPUP_ACTION =
		""android.fbreader.action.NETWORK_LIBRARY_SMS_REFILLING"";
	static final String CREDIT_CARD_TOPUP_ACTION =
		""android.fbreader.action.NETWORK_LIBRARY_CREDIT_CARD_TOPUP"";
	static final String SELF_SERVICE_KIOSK_TOPUP_ACTION =
		""android.fbreader.action.NETWORK_LIBRARY_SELF_SERVICE_KIOSK_TOPUP"";

	private static boolean testService(Activity activity, String action, String url) {
		return url != null && PackageUtil.canBeStarted(activity, new Intent(action, Uri.parse(url)), true);
	}

	static boolean isRegistrationSupported(Activity activity, INetworkLink link) {
		return testService(
			activity,
			REGISTRATION_ACTION,
			link.getUrl(UrlInfo.Type.SignUp)
		);
	}

	static void runRegistrationDialog(Activity activity, INetworkLink link) {
		try {
			final Intent intent = new Intent(
				REGISTRATION_ACTION,
				Uri.parse(link.getUrl(UrlInfo.Type.SignUp))
			);
			if (PackageUtil.canBeStarted(activity, intent, true)) {
				activity.startActivityForResult(new Intent(
					REGISTRATION_ACTION,
					Uri.parse(link.getUrl(UrlInfo.Type.SignUp))
				), NetworkBaseActivity.SIGNUP_CODE);
			}
		} catch (ActivityNotFoundException e) {
		}
	}

	private static final Map<Activity,Runnable> ourAfterRegisrationMap =
		new HashMap<Activity,Runnable>();

	static void runAuthenticationDialog(Activity activity, INetworkLink link, String error, Runnable onSuccess) {
		final NetworkAuthenticationManager mgr = link.authenticationManager();

		final Intent intent = new Intent(activity, AuthenticationActivity.class);
		intent.putExtra(AuthenticationActivity.USERNAME_KEY, mgr.UserNameOption.getValue());
		if (isRegistrationSupported(activity, link)) {
			intent.putExtra(AuthenticationActivity.SHOW_SIGNUP_LINK_KEY, true);
		}
		intent.putExtra(AuthenticationActivity.SCHEME_KEY, ""https"");
		intent.putExtra(AuthenticationActivity.ERROR_KEY, error);
		if (onSuccess != null) {
			ourAfterRegisrationMap.put(activity, onSuccess);
		}
		activity.startActivityForResult(intent, NetworkBaseActivity.CUSTOM_AUTHENTICATION_CODE);
	}

	static void processCustomAuthentication(final Activity activity, final INetworkLink link, int resultCode, Intent data) {
		final Runnable onSuccess = ourAfterRegisrationMap.get(activity);
		ourAfterRegisrationMap.remove(activity);
		switch (resultCode) {
			case AuthenticationActivity.RESULT_CANCELED:
				UIUtil.wait(
					""signOut"",
					new Runnable() {
						public void run() {
							final NetworkAuthenticationManager mgr =
								 link.authenticationManager();
							if (mgr.mayBeAuthorised(false)) {
								mgr.logOut();
							}
							final NetworkLibrary library = NetworkLibrary.Instance();
							library.invalidateVisibility();
							library.synchronize();
							NetworkView.Instance().fireModelChanged();
						}
					},
					activity
				);
				break;
			case AuthenticationActivity.RESULT_OK:
			{
				final ZLResource resource =
					ZLResource.resource(""dialog"").getResource(""AuthenticationDialog"");
				final String username =
					data.getStringExtra(AuthenticationActivity.USERNAME_KEY);
				final String password =
					data.getStringExtra(AuthenticationActivity.PASSWORD_KEY);
				if (username.length() == 0) {
					runAuthenticationDialog(
						activity, link,
						resource.getResource(""loginIsEmpty"").getValue(),
						onSuccess
					);
				}
				final NetworkAuthenticationManager mgr = link.authenticationManager();
				mgr.UserNameOption.setValue(username);
				final Runnable runnable = new Runnable() {
					public void run() {
						try {
							mgr.authorise(password);
							if (mgr.needsInitialization()) {
								mgr.initialize();
							}
							if (onSuccess != null) {
								onSuccess.run();
							}
						} catch (ZLNetworkException e) {
							mgr.logOut();
							runAuthenticationDialog(activity, link, e.getMessage(), onSuccess);
							return;
						}
						final NetworkLibrary library = NetworkLibrary.Instance();
						library.invalidateVisibility();
						library.synchronize();
						NetworkView.Instance().fireModelChanged();
					}
				};
				UIUtil.wait(""authentication"", runnable, activity);
				break;
			}
			case AuthenticationActivity.RESULT_SIGNUP:
				Util.runRegistrationDialog(activity, link);
				break;
		}
	}

	static void processSignup(INetworkLink link, int resultCode, Intent data) {
		if (resultCode == Activity.RESULT_OK && data != null) {
			try {
				final NetworkAuthenticationManager mgr = link.authenticationManager();
				if (mgr instanceof LitResAuthenticationManager) {
					((LitResAuthenticationManager)mgr).initUser(
						data.getStringExtra(USER_REGISTRATION_USERNAME),
						data.getStringExtra(USER_REGISTRATION_LITRES_SID),
						"""",
						false
					);
				}
				if (!mgr.isAuthorised(true)) {
					throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
				}
				try {
					mgr.initialize();
				} catch (ZLNetworkException e) {
					mgr.logOut();
					throw e;
				}
			} catch (ZLNetworkException e) {
				// TODO: show an error message
			}
		}
	}

	static boolean isTopupSupported(Activity activity, INetworkLink link) {
		return
			isBrowserTopupSupported(activity, link) ||
			isTopupSupported(activity, link, SMS_TOPUP_ACTION) ||
			isTopupSupported(activity, link, CREDIT_CARD_TOPUP_ACTION) ||
			isTopupSupported(activity, link, SELF_SERVICE_KIOSK_TOPUP_ACTION);
	}

	static boolean isTopupSupported(Activity activity, INetworkLink link, String action) {
		return testService(
			activity,
			action,
			link.getUrl(UrlInfo.Type.Catalog)
		);
	}

	static void runTopupDialog(Activity activity, INetworkLink link, String action) {
		try {
			final Intent intent = new Intent(
				action,
				Uri.parse(link.getUrl(UrlInfo.Type.Catalog))
			);
			final NetworkAuthenticationManager mgr = link.authenticationManager();
			if (mgr != null) {
				for (Map.Entry<String,String> entry : mgr.getTopupData().entrySet()) {
					intent.putExtra(entry.getKey(), entry.getValue());
				}
			}
			if (PackageUtil.canBeStarted(activity, intent, true)) {
				activity.startActivity(intent);
			}
		} catch (ActivityNotFoundException e) {
		}
	}

	static boolean isBrowserTopupSupported(Activity activity, INetworkLink link) {
		return link.getUrl(UrlInfo.Type.TopUp) != null;
	}

	static void openInBrowser(Context context, String url) {
		if (url != null) {
			url = NetworkLibrary.Instance().rewriteUrl(url, true);
			context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
		}
	}

	static final String TREE_KEY_KEY = ""org.geometerplus.android.fbreader.network.TreeKey"";

	static void openTree(Context context, NetworkTree tree) {
		final Class<?> clz = tree instanceof NetworkBookTree
			? NetworkBookInfoActivity.class : NetworkCatalogActivity.class;
		context.startActivity(
			new Intent(context.getApplicationContext(), clz)
				.putExtra(TREE_KEY_KEY, tree.getUniqueKey())
		);
	}

	public static NetworkTree getTreeFromIntent(Intent intent) {
		final NetworkLibrary library = NetworkLibrary.Instance();
		final NetworkTree.Key key = (NetworkTree.Key)intent.getSerializableExtra(TREE_KEY_KEY);
		return library.getTreeByKey(key);
	}
}
",True,422,1,1,9,92,8,16,L6
264,org.geometerplus.android.fbreader.network.NetworkBookActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Set;
import java.util.LinkedHashSet;
import java.io.File;

import android.app.AlertDialog;
import android.app.Activity;
import android.os.Message;
import android.os.Handler;
import android.net.Uri;
import android.content.Intent;
import android.content.DialogInterface;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.fbreader.FBReader;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.urlInfo.*;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;
import org.geometerplus.fbreader.network.tree.NetworkAuthorTree;
import org.geometerplus.fbreader.network.tree.NetworkSeriesTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class NetworkBookActions extends NetworkTreeActions {
	public static final int DOWNLOAD_BOOK_ITEM_ID = 0;
	public static final int DOWNLOAD_DEMO_ITEM_ID = 1;
	public static final int READ_BOOK_ITEM_ID = 2;
	public static final int READ_DEMO_ITEM_ID = 3;
	public static final int DELETE_BOOK_ITEM_ID = 4;
	public static final int DELETE_DEMO_ITEM_ID = 5;
	public static final int BUY_DIRECTLY_ITEM_ID = 6;
	public static final int BUY_IN_BROWSER_ITEM_ID = 7;
	public static final int SHOW_BOOK_ACTIVITY_ITEM_ID = 8;
	public static final int SHOW_BOOKS_ITEM_ID = 9;
	public static final int ADD_BOOK_TO_BASKET = 10;
	public static final int REMOVE_BOOK_FROM_BASKET = 11;
	public static final int ADD_CATALOG_TO_FAVORITES = 12;
	public static final int REMOVE_CATALOG_FROM_FAVORITES = 13;

	private static boolean useFullReferences(NetworkBookItem book) {
		return book.reference(UrlInfo.Type.Book) != null ||
			book.reference(UrlInfo.Type.BookConditional) != null;
	}

	private static boolean useDemoReferences(NetworkBookItem book) {
		return book.reference(UrlInfo.Type.BookDemo) != null &&
			book.localCopyFileName() == null &&
			book.reference(UrlInfo.Type.Book) == null;
	}

	private static boolean useBuyReferences(NetworkBookItem book) {
		return book.localCopyFileName() == null &&
			book.reference(UrlInfo.Type.Book) == null;
	}

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof NetworkBookTree
			|| tree instanceof NetworkAuthorTree
			|| tree instanceof NetworkSeriesTree;
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(tree.getName());
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			addMenuItem(menu, SHOW_BOOKS_ITEM_ID, ""showBooks"");
			return;
		}

		final NetworkBookTree bookTree = (NetworkBookTree) tree;
		final NetworkBookItem book = bookTree.Book;

		Set<Action> actions = getContextMenuActions(book, ((NetworkBaseActivity)activity).Connection);
		for (Action a: actions) {
			if (a.Arg == null) {
				addMenuItem(menu, a.Id, a.Key);
			} else {
				addMenuItem(menu, a.Id, a.Key, a.Arg);
			}
		}
	}

	static class Action {
		public final int Id;
		public final String Key;
		public final String Arg;

		public Action(int id, String key) {
			Id = id;
			Key = key;
			Arg = null;
		}

		public Action(int id, String key, String arg) {
			Id = id;
			Key = key;
			Arg = arg;
		}
	}

	static int getBookStatus(NetworkBookItem book, BookDownloaderServiceConnection connection) {
		if (useFullReferences(book)) {
			final BookUrlInfo reference = book.reference(UrlInfo.Type.Book);
			if (reference != null
					&& connection != null && connection.isBeingDownloaded(reference.Url)) {
				return R.drawable.ic_list_download;
			} else if (book.localCopyFileName() != null) {
				return R.drawable.ic_list_flag;
			} else if (reference != null) {
				return R.drawable.ic_list_download;
			}
		}
		if (useBuyReferences(book)
				&& book.reference(UrlInfo.Type.BookBuy) != null
				|| book.reference(UrlInfo.Type.BookBuyInBrowser) != null) {
			return R.drawable.ic_list_buy;
		}
		return 0;
	}

	static Set<Action> getContextMenuActions(NetworkBookItem book, BookDownloaderServiceConnection connection) {
		LinkedHashSet<Action> actions = new LinkedHashSet<Action>();
		if (useFullReferences(book)) {
			final BookUrlInfo reference = book.reference(UrlInfo.Type.Book);
			if (reference != null
					&& connection != null && connection.isBeingDownloaded(reference.Url)) {
				actions.add(new Action(TREE_NO_ACTION, ""alreadyDownloading""));
			} else if (book.localCopyFileName() != null) {
				actions.add(new Action(READ_BOOK_ITEM_ID, ""read""));
				actions.add(new Action(DELETE_BOOK_ITEM_ID, ""delete""));
			} else if (reference != null) {
				actions.add(new Action(DOWNLOAD_BOOK_ITEM_ID, ""download""));
			}
		}
		if (useDemoReferences(book)) {
			final BookUrlInfo reference = book.reference(UrlInfo.Type.BookDemo);
			if (connection != null && connection.isBeingDownloaded(reference.Url)) {
				actions.add(new Action(TREE_NO_ACTION, ""alreadyDownloadingDemo""));
			} else if (reference.localCopyFileName(UrlInfo.Type.BookDemo) != null) {
				actions.add(new Action(READ_DEMO_ITEM_ID, ""readDemo""));
				actions.add(new Action(DELETE_DEMO_ITEM_ID, ""deleteDemo""));
			} else {
				actions.add(new Action(DOWNLOAD_DEMO_ITEM_ID, ""downloadDemo""));
			}
		}
		if (useBuyReferences(book)) {
			int id = TREE_NO_ACTION;
			BookUrlInfo reference = null;
			if (book.reference(UrlInfo.Type.BookBuy) != null) {
				reference = book.reference(UrlInfo.Type.BookBuy);
				id = BUY_DIRECTLY_ITEM_ID;
			} else if (book.reference(UrlInfo.Type.BookBuyInBrowser) != null) {
				reference = book.reference(UrlInfo.Type.BookBuyInBrowser);
				id = BUY_IN_BROWSER_ITEM_ID;
			}
			if (reference != null) {
				final String price = ((BookBuyUrlInfo)reference).Price;
				actions.add(new Action(id, ""buy"", price));
			}
			final Basket basket = book.Link.basket();
			if (basket != null) {
				if (basket.contains(book)) {
					actions.add(new Action(REMOVE_BOOK_FROM_BASKET, ""removeFromBasket""));
				} else {
					actions.add(new Action(ADD_BOOK_TO_BASKET, ""addToBasket""));
				}
			}
		}
		return actions;
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			return SHOW_BOOKS_ITEM_ID;
		}
		return SHOW_BOOK_ACTIVITY_ITEM_ID;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			switch (actionCode) {
				case SHOW_BOOKS_ITEM_ID:
					Util.openTree(activity, tree);
					return true;
			}
			return false;
		} else if (tree instanceof NetworkBookTree) {
			return runActionStatic(activity, ((NetworkBookTree)tree), actionCode);
		} else {
			return false;
		}
	}

	static boolean runActionStatic(final Activity activity, final NetworkBookTree tree, int actionCode) {
		switch (actionCode) {
			case SHOW_BOOK_ACTIVITY_ITEM_ID:
				if (tree.Book.isFullyLoaded()) {
					Util.openTree(activity, tree);
				} else {
					UIUtil.wait(""loadInfo"", new Runnable() {
						public void run() {
							try {
								tree.Book.loadFullInformation();
							} catch (ZLNetworkException e) {
								e.printStackTrace();
							}
							activity.runOnUiThread(new Runnable() {
								public void run() {
									Util.openTree(activity, tree);
								}
							});
						}
					}, activity);
				}
				return true;
			default:
				return runActionStatic(activity, tree.Book, actionCode);
		}
	}

	static boolean runActionStatic(Activity activity, NetworkBookItem book, int actionCode) {
		switch (actionCode) {
			case DOWNLOAD_BOOK_ITEM_ID:
				doDownloadBook(activity, book, false);
				return true;
			case DOWNLOAD_DEMO_ITEM_ID:
				doDownloadBook(activity, book, true);
				return true;
			case READ_BOOK_ITEM_ID:
				doReadBook(activity, book, false);
				return true;
			case READ_DEMO_ITEM_ID:
				doReadBook(activity, book, true);
				return true;
			case DELETE_BOOK_ITEM_ID:
				tryToDeleteBook(activity, book, false);
				return true;
			case DELETE_DEMO_ITEM_ID:
				tryToDeleteBook(activity, book, true);
				return true;
			case BUY_DIRECTLY_ITEM_ID:
				doBuyDirectly(activity, book);
				return true;
			case BUY_IN_BROWSER_ITEM_ID:
				doBuyInBrowser(activity, book);
				return true;
			case ADD_BOOK_TO_BASKET:
				book.Link.basket().add(book);
				return true;
			case REMOVE_BOOK_FROM_BASKET:
				book.Link.basket().remove(book);
				return true;
		}
		return false;
	}

	private static void doDownloadBook(Activity activity, final NetworkBookItem book, boolean demo) {
		final UrlInfo.Type resolvedType =
			demo ? UrlInfo.Type.BookDemo : UrlInfo.Type.Book;
		final BookUrlInfo ref = book.reference(resolvedType);
		if (ref != null) {
			final String sslCertificate;
			if (book.Link.authenticationManager() != null) {
				sslCertificate = book.Link.authenticationManager().SSLCertificate;
			} else {
				sslCertificate = null;
			}
			activity.startService(
				new Intent(Intent.ACTION_VIEW, Uri.parse(ref.Url), 
						activity.getApplicationContext(), BookDownloaderService.class)
					.putExtra(BookDownloaderService.BOOK_FORMAT_KEY, ref.BookFormat)
					.putExtra(BookDownloaderService.REFERENCE_TYPE_KEY, resolvedType)
					.putExtra(BookDownloaderService.CLEAN_URL_KEY, ref.cleanUrl())
					.putExtra(BookDownloaderService.TITLE_KEY, book.Title)
					.putExtra(BookDownloaderService.SSL_CERTIFICATE_KEY, sslCertificate)
			);
		}
	}

	private static void doReadBook(Activity activity, final NetworkBookItem book, boolean demo) {
		String local = null;
		if (!demo) {
			local = book.localCopyFileName();
		} else {
			final BookUrlInfo reference = book.reference(UrlInfo.Type.BookDemo);
			if (reference != null) {
				local = reference.localCopyFileName(UrlInfo.Type.BookDemo);
			}
		}
		if (local != null) {
			activity.startActivity(
				new Intent(Intent.ACTION_VIEW,
					Uri.fromFile(new File(local)),
					activity.getApplicationContext(),
					FBReader.class
				).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK)
			);
		}
	}

	private static void tryToDeleteBook(Activity activity, final NetworkBookItem book, final boolean demo) {
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource boxResource = dialogResource.getResource(""deleteBookBox"");
		new AlertDialog.Builder(activity)
			.setTitle(book.Title)
			.setMessage(boxResource.getResource(""message"").getValue())
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
					// TODO: remove information about book from Library???
					if (!demo) {
						book.removeLocalFiles();
					} else {
						final BookUrlInfo reference = book.reference(UrlInfo.Type.BookDemo);
						if (reference != null) {
							final String fileName = reference.localCopyFileName(UrlInfo.Type.BookDemo);
							if (fileName != null) {
								new File(fileName).delete();
							}
						}
					}
					NetworkView.Instance().fireModelChangedAsync();
				}
			})
			.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
			.create().show();
	}

	private static void doBuyDirectly(final Activity activity, final NetworkBookItem book) {
		final NetworkAuthenticationManager mgr = book.Link.authenticationManager();
		if (mgr == null) {
			return;
		}
		/*if (!NetworkOperationRunnable::tryConnect()) {
			return;
		}*/


		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");

		final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				if (which == DialogInterface.BUTTON_NEGATIVE) {
					return;
				}
				if (!mgr.needPurchase(book)) {
					return;
				}
				final boolean downloadBook = which == DialogInterface.BUTTON_NEUTRAL;
				final Handler handler = new Handler() {
					public void handleMessage(Message message) {
						final ZLNetworkException exception = (ZLNetworkException)message.obj;
						if (exception != null) {
							String buttonKey;
							DialogInterface.OnClickListener action = null;
							if (NetworkException.ERROR_PURCHASE_NOT_ENOUGH_MONEY.equals(
								exception.getCode())
							) {
								buttonKey = ""topup"";
								action = new DialogInterface.OnClickListener() {
									public void onClick(DialogInterface dialog, int which) {
										new TopupActions().runStandalone(activity, book.Link);
									}
								};
							} else {
								buttonKey = ""ok"";
							}
							final ZLResource boxResource = dialogResource.getResource(""networkError"");
							new AlertDialog.Builder(activity)
								.setTitle(boxResource.getResource(""title"").getValue())
								.setMessage(exception.getMessage())
								.setIcon(0)
								.setPositiveButton(buttonResource.getResource(buttonKey).getValue(), action)
								.create().show();
						} else if (downloadBook) {
							doDownloadBook(activity, book, false);
						}
						if (!mgr.mayBeAuthorised(true)) {
							final NetworkLibrary library = NetworkLibrary.Instance();
							library.invalidateVisibility();
							library.synchronize();
						}
						if (NetworkView.Instance().isInitialized()) {
							NetworkView.Instance().fireModelChangedAsync();
						}
					}
				}; // end Handler
				final Runnable runnable = new Runnable() {
					public void run() {
						ZLNetworkException exception = null;
						try {
							mgr.purchaseBook(book);
						} catch (ZLNetworkException e) {
							exception = e;
						}
						handler.sendMessage(handler.obtainMessage(0, exception));
					}
				}; // end Runnable
				UIUtil.wait(""purchaseBook"", runnable, activity);
			} // end onClick
		}; // end listener

		final Runnable buyRunnable = new Runnable() {
			public void run() {
				if (!mgr.needPurchase(book)) {
					final ZLResource boxResource = dialogResource.getResource(""alreadyPurchasedBox"");
					new AlertDialog.Builder(activity)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage(boxResource.getResource(""message"").getValue())
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
					return;
				}
				final ZLResource boxResource = dialogResource.getResource(""purchaseConfirmBox"");
				new AlertDialog.Builder(activity)
					.setTitle(boxResource.getResource(""title"").getValue())
					.setMessage(boxResource.getResource(""message"").getValue().replace(""%s"", book.Title))
					.setIcon(0)
					.setPositiveButton(buttonResource.getResource(""buy"").getValue(), listener)
					.setNeutralButton(buttonResource.getResource(""buyAndDownload"").getValue(), listener)
					.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
					.create().show();
			}
		};
		final Runnable buyOnUiRunnable = new Runnable() {
			public void run() {
				activity.runOnUiThread(buyRunnable);
			}
		};

		try {
			if (mgr.isAuthorised(true)) {
				buyRunnable.run();
				return;
			}
		} catch (ZLNetworkException e) {
		}
		Util.runAuthenticationDialog(activity, book.Link, null, buyOnUiRunnable);
	}

	private static void doBuyInBrowser(Activity activity, final NetworkBookItem book) {
		BookUrlInfo reference = book.reference(UrlInfo.Type.BookBuyInBrowser);
		if (reference != null) {
			Util.openInBrowser(activity, reference.Url);
		}
	}

}
",True,421,0,0,7,131,3,26,L6
265,org.geometerplus.android.fbreader.network.BookDownloaderServiceConnection.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.IBinder;
import android.content.ServiceConnection;
import android.content.ComponentName;

class BookDownloaderServiceConnection implements ServiceConnection {

	private BookDownloaderInterface myInterface;

	public synchronized void onServiceConnected(ComponentName className, IBinder service) {
		myInterface = BookDownloaderInterface.Stub.asInterface(service);
	}

	public synchronized void onServiceDisconnected(ComponentName name) {
		myInterface = null;
	}

	public synchronized boolean isBeingDownloaded(String url) {
		if (myInterface != null) {
			try {
				return myInterface.isBeingDownloaded(url);
			} catch (android.os.RemoteException e) {
			}
		}
		return false;
	}
}
",True,55,6,26,0,0,3,0,L6
266,org.geometerplus.android.fbreader.network.BookDownloaderCallback.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class BookDownloaderCallback extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent) {
		if (NetworkView.Instance().isInitialized()) {
			NetworkView.Instance().fireModelChangedAsync();
		}
	}
}
",False,422,0,0,9,113,0,1,L7
267,org.geometerplus.android.fbreader.network.TopupActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.View;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.tree.TopUpTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

class TopupActions extends NetworkTreeActions {
	public static final int TOPUP_VIA_SMS_ITEM_ID = 0;
	public static final int TOPUP_VIA_BROWSER_ITEM_ID = 1;
	public static final int TOPUP_VIA_CREDIT_CARD_ITEM_ID = 2;
	public static final int TOPUP_VIA_SELF_SERVICE_ITEM_ID = 3;

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof TopUpTree;
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		buildContextMenu(activity, menu, ((TopUpTree)tree).Item.Link);
	}

	void buildContextMenu(Activity activity, ContextMenu menu, INetworkLink link) {
		menu.setHeaderTitle(getTitleValue(""topupTitle""));

		if (Util.isTopupSupported(activity, link, Util.CREDIT_CARD_TOPUP_ACTION)) {
			addMenuItem(menu, TOPUP_VIA_CREDIT_CARD_ITEM_ID, ""topupViaCreditCard"");
		}
		if (Util.isTopupSupported(activity, link, Util.SMS_TOPUP_ACTION)) {
			addMenuItem(menu, TOPUP_VIA_SMS_ITEM_ID, ""topupViaSms"");
		}
		if (Util.isTopupSupported(activity, link, Util.SELF_SERVICE_KIOSK_TOPUP_ACTION)) {
			addMenuItem(menu, TOPUP_VIA_SELF_SERVICE_ITEM_ID, ""topupViaSelfServiceKiosk"");
		}
		if (Util.isBrowserTopupSupported(activity, link)) {
			addMenuItem(menu, TOPUP_VIA_BROWSER_ITEM_ID, ""topupViaBrowser"");
		}
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		return getDefaultActionCode(activity, ((TopUpTree)tree).Item.Link);
	}
	private int getDefaultActionCode(Activity activity, INetworkLink link) {
		final boolean browser = Util.isBrowserTopupSupported(activity, link);
		final boolean sms = Util.isTopupSupported(activity, link, Util.SMS_TOPUP_ACTION);
		final boolean creditCard = Util.isTopupSupported(activity, link, Util.CREDIT_CARD_TOPUP_ACTION);
		final boolean selfService = Util.isTopupSupported(activity, link, Util.SELF_SERVICE_KIOSK_TOPUP_ACTION);
		final int count =
			(sms ? 1 : 0) +
			(browser ? 1 : 0) +
			(creditCard ? 1 : 0) +
			(selfService ? 1 : 0);

		if (count > 1) {
			return TREE_SHOW_CONTEXT_MENU;
		} else if (sms) {
			return TOPUP_VIA_SMS_ITEM_ID;
		} else if (creditCard) {
			return TOPUP_VIA_CREDIT_CARD_ITEM_ID;
		} else if (selfService) {
			return TOPUP_VIA_SELF_SERVICE_ITEM_ID;
		} else /* if (browser) */ { 
			return TOPUP_VIA_BROWSER_ITEM_ID;
		}
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		final INetworkLink link = ((TopUpTree)tree).Item.Link;
		return runAction(activity, link, actionCode);
	}

	static boolean runAction(Activity activity, INetworkLink link, int actionCode) {
		Runnable topupRunnable = null;
		switch (actionCode) {
			case TOPUP_VIA_SMS_ITEM_ID:
				topupRunnable = topupRunnable(activity, link, Util.SMS_TOPUP_ACTION);
				break;
			case TOPUP_VIA_BROWSER_ITEM_ID:
				topupRunnable = browserTopupRunnable(activity, link);
				break;
			case TOPUP_VIA_CREDIT_CARD_ITEM_ID:
				topupRunnable = topupRunnable(activity, link, Util.CREDIT_CARD_TOPUP_ACTION);
				break;
			case TOPUP_VIA_SELF_SERVICE_ITEM_ID:
				topupRunnable = topupRunnable(activity, link, Util.SELF_SERVICE_KIOSK_TOPUP_ACTION);
				break;
		}

		if (topupRunnable == null) {
			return false;
		}
		doTopup(activity, link, topupRunnable);
		return true;
	}

	private static Runnable browserTopupRunnable(final Activity activity, final INetworkLink link) {
		return new Runnable() {
			public void run() {
				Util.openInBrowser(
					activity,
					link.authenticationManager().topupLink()
				);
			}
		};
	}

	private static Runnable topupRunnable(final Activity activity, final INetworkLink link, final String action) {
		return new Runnable() {
			public void run() {
				Util.runTopupDialog(activity, link, action);
			}
		};
	}

	private static void doTopup(final Activity activity, final INetworkLink link, final Runnable action) {
		final NetworkAuthenticationManager mgr = link.authenticationManager();
		if (mgr.mayBeAuthorised(false)) {
			action.run();
		} else {
			Util.runAuthenticationDialog(activity, link, null, new Runnable() {
				public void run() {
					if (mgr.mayBeAuthorised(false)) {
						activity.runOnUiThread(action);
					}
				}
			});
		}
	}

	public void runStandalone(Activity activity, INetworkLink link) {
		final int topupActionCode = getDefaultActionCode(activity, link);
		if (topupActionCode == TREE_SHOW_CONTEXT_MENU) {
			//activity.getListView().showContextMenu();
			View view = null;
			if (activity instanceof NetworkBaseActivity) {	
				view = ((NetworkBaseActivity)activity).getListView();
			} else if (activity instanceof NetworkBookInfoActivity) {
				view = ((NetworkBookInfoActivity)activity).getMainView();
			}
			if (view != null) {
				view.showContextMenu();
			}
		} else if (topupActionCode >= 0) {
			runAction(activity, link, topupActionCode);
		}
	}
}
",True,421,0,0,9,103,4,9,L6
268,org.geometerplus.android.fbreader.network.NetworkCatalogActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.Bundle;
import android.view.*;
import android.widget.BaseAdapter;
import android.content.Intent;

import org.apache.http.auth.AuthScope;
import org.apache.http.auth.Credentials;
import org.apache.http.auth.UsernamePasswordCredentials;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.*;
import org.geometerplus.fbreader.tree.FBTree;

public class NetworkCatalogActivity extends NetworkBaseActivity implements UserRegistrationConstants {
	private static final String ACTIVITY_BY_TREE_KEY = ""ActivityByTree"";

	static void setForTree(NetworkTree tree, NetworkCatalogActivity activity) {
		if (tree != null) {
			tree.setUserData(ACTIVITY_BY_TREE_KEY, activity);
		}
	}

	static NetworkCatalogActivity getByTree(NetworkTree tree) {
		return (NetworkCatalogActivity)tree.getUserData(ACTIVITY_BY_TREE_KEY);
	}

	private NetworkTree myTree;
	private volatile boolean myInProgress;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

		myTree = Util.getTreeFromIntent(getIntent());

		if (myTree == null) {
			finish();
			return;
		}

		setForTree(myTree, this);

		setListAdapter(new CatalogAdapter());
		getListView().invalidateViews();
		setupTitle();
	}

	@Override
	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
		if (menuInfo == null && myTree instanceof NetworkCatalogTree) {
			final INetworkLink link = ((NetworkCatalogTree)myTree).Item.Link;
			if (Util.isTopupSupported(this, link)) {
				final TopupActions actions = NetworkView.Instance().getTopupActions();
				if (actions != null) {
					actions.buildContextMenu(this, menu, link);
					return;
				}
			}
		}
		super.onCreateContextMenu(menu, view, menuInfo);
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		if ((item == null || item.getMenuInfo() == null) && myTree instanceof NetworkCatalogTree) {
			final INetworkLink link = ((NetworkCatalogTree)myTree).Item.Link;
			if (Util.isTopupSupported(this, link)) {
				final TopupActions actions = NetworkView.Instance().getTopupActions();
				if (actions != null && TopupActions.runAction(this, link, item.getItemId())) {
					return true;
				}
			}
		}
		return super.onContextItemSelected(item);
	}

	private final MyCredentialsCreator myCredentialsCreator = new MyCredentialsCreator();

	private class MyCredentialsCreator implements ZLNetworkManager.CredentialsCreator {
		private volatile String myUsername;
		private volatile String myPassword;
        
		public Credentials createCredentials(String scheme, AuthScope scope) {
			if (!""basic"".equalsIgnoreCase(scope.getScheme())) {
				return null;
			}

			final Intent intent = new Intent();
			final String host = scope.getHost();
			final String area = scope.getRealm();
			final ZLStringOption option = new ZLStringOption(""username"", host + "":"" + area, """");
			intent.setClass(NetworkCatalogActivity.this, AuthenticationActivity.class);
			intent.putExtra(AuthenticationActivity.HOST_KEY, host);
			intent.putExtra(AuthenticationActivity.AREA_KEY, area);
			intent.putExtra(AuthenticationActivity.SCHEME_KEY, scheme);
			intent.putExtra(AuthenticationActivity.USERNAME_KEY, option.getValue());
			startActivityForResult(intent, BASIC_AUTHENTICATION_CODE);
			synchronized (this) {
				try {
					wait();
				} catch (InterruptedException e) {
				}
			}
        
			Credentials creds = null;
			if (myUsername != null && myPassword != null) {
				option.setValue(myUsername);
				creds = new UsernamePasswordCredentials(myUsername, myPassword);
			}
			myUsername = null;
			myPassword = null;
			return creds;
		}
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		switch (requestCode) {
			case BASIC_AUTHENTICATION_CODE:
				synchronized (myCredentialsCreator) {
					if (resultCode == AuthenticationActivity.RESULT_OK && data != null) {
						myCredentialsCreator.myUsername =
							data.getStringExtra(AuthenticationActivity.USERNAME_KEY);
						myCredentialsCreator.myPassword =
							data.getStringExtra(AuthenticationActivity.PASSWORD_KEY);
					}
					myCredentialsCreator.notify();
				}
				break;
			case CUSTOM_AUTHENTICATION_CODE:
				Util.processCustomAuthentication(
					this, ((NetworkCatalogTree)myTree).Item.Link, resultCode, data
				);
				break;
			case SIGNUP_CODE:
				Util.processSignup(((NetworkCatalogTree)myTree).Item.Link, resultCode, data);
				break;
		}
	}

	private final void setupTitle() {
		String title = null;
		final NetworkView networkView = NetworkView.Instance();
		if (networkView.isInitialized()) {
			final NetworkTreeActions actions = networkView.getActions(myTree);
			if (actions != null) {
				title = actions.getTreeTitle(myTree);
			}
		}
		if (title == null) {
			title = myTree.getName();
		}
		setTitle(title);
		setProgressBarIndeterminateVisibility(myInProgress);
	}

	@Override
	public void onDestroy() {
		setForTree(myTree, null);
		super.onDestroy();
	}

	@Override
	public void onResume() {
		super.onResume();
		ZLNetworkManager.Instance().setCredentialsCreator(myCredentialsCreator);
	}

	private final class CatalogAdapter extends BaseAdapter {
		public final int getCount() {
			return myTree.subTrees().size();
		}

		public final NetworkTree getItem(int position) {
			if (position < 0 || position >= myTree.subTrees().size()) {
				return null;
			}
			return (NetworkTree)myTree.subTrees().get(position);
		}

		public final long getItemId(int position) {
			return position;
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final NetworkTree tree = getItem(position);
			return setupNetworkTreeItemView(convertView, parent, tree);
		}

		void onModelChanged() {
			notifyDataSetChanged();
			for (FBTree child : myTree.subTrees()) {
				if (child instanceof TopUpTree) {
					child.invalidateChildren();
				}
			}
		}
	}

	private static NetworkTree getLoadableNetworkTree(NetworkTree tree) {
		while (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			if (tree.Parent instanceof NetworkTree) {
				tree = (NetworkTree)tree.Parent;
			} else {
				return null;
			}
		}
		return tree;
	}

	@Override
	public void onModelChanged() {
		runOnUiThread(new Runnable() {
			public void run() {
				final NetworkTree tree = getLoadableNetworkTree(myTree);
				myInProgress =
					tree != null &&
					ItemsLoadingService.getRunnable(tree) != null;
				getListView().invalidateViews();
            
				/*
				 * getListAdapter() always returns CatalogAdapter because onModelChanged() 
				 * can be called only after Activity's onStart() method (where NetworkView's 
				 * addEventListener() is called). Therefore CatalogAdapter will be set as 
				 * adapter in onCreate() method before any calls to onModelChanged().
				 */
				((CatalogAdapter)getListAdapter()).onModelChanged();
            
				setupTitle();
			}
		});
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event)  {
		if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
			doStopLoading();
		}
		return super.onKeyDown(keyCode, event);
	}

	private void doStopLoading() {
		final ItemsLoader runnable = ItemsLoadingService.getRunnable(myTree);
		if (runnable != null) {
			runnable.interruptLoading();
		}
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		return NetworkView.Instance().createOptionsMenu(menu, myTree);
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		super.onPrepareOptionsMenu(menu);
		return NetworkView.Instance().prepareOptionsMenu(this, menu, myTree);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		if (NetworkView.Instance().runOptionsMenu(this, item, myTree)) {
			return true;
		}
		return super.onOptionsItemSelected(item);
	}
}
",True,422,1,1,9,114,2,20,L6
269,org.geometerplus.android.fbreader.network.SearchItemActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.SearchResult;
import org.geometerplus.fbreader.network.tree.SearchItemTree;

class SearchItemActions extends NetworkTreeActions {

	public static final int RUN_SEARCH_ITEM_ID = 0;


	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof SearchItemTree;
	}

	@Override
	public String getTreeTitle(NetworkTree tree) {
		final SearchResult result = ((SearchItemTree)tree).getSearchResult();
		if (result != null) {
			return result.Summary;
		}
		return tree.getName();
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(tree.getName());

		final boolean isLoading = ItemsLoadingService.getRunnable(tree) != null;

		if (!isLoading) {
			addMenuItem(menu, RUN_SEARCH_ITEM_ID, ""search"");
		} else {
			addMenuItem(menu, TREE_NO_ACTION, ""stoppingNetworkSearch"");
		}
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		final boolean isLoading = ItemsLoadingService.getRunnable(tree) != null;
		if (!isLoading) {
			return RUN_SEARCH_ITEM_ID;
		}
		return TREE_NO_ACTION;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		switch (actionCode) {
			case RUN_SEARCH_ITEM_ID:
				activity.onSearchRequested();
				return true;
		}
		return false;
	}
}
",False,421,0,0,9,109,1,7,L6
270,org.geometerplus.android.fbreader.network.NetworkNotifications.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

class NetworkNotifications {
	private static NetworkNotifications ourInstance;

	public static NetworkNotifications Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkNotifications();
		}
		return ourInstance;
	}

	//private static final int CATALOG_LOADING = 0;
	//private static final int NETWORK_SEARCH = 1;

	private static final int BOOK_DOWNLOADING_START = 0x10000000;
	private static final int BOOK_DOWNLOADING_END   = 0x1fffffff;

	private volatile int myBookDownloadingId = BOOK_DOWNLOADING_START;

	private NetworkNotifications() {
	}

	/*public int getCatalogLoadingId() {
		return CATALOG_LOADING;
	}*/

	/*public int getNetworkSearchId() {
		return NETWORK_SEARCH;
	}*/

	public synchronized int getBookDownloadingId() {
		final int id = myBookDownloadingId;
		if (myBookDownloadingId == BOOK_DOWNLOADING_END) {
			myBookDownloadingId = BOOK_DOWNLOADING_START;
		} else {
			++myBookDownloadingId;
		}
		return id;
	}
}
",False,55,5,38,0,0,1,0,L6
271,org.geometerplus.android.fbreader.network.NetworkSearchActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.List;
import java.util.Set;

import android.app.AlertDialog;
import android.app.Activity;
import android.app.SearchManager;
import android.os.Bundle;
import android.content.Intent;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.SearchItemTree;


public class NetworkSearchActivity extends Activity {
	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		if (!NetworkView.Instance().isInitialized()) {
			finish();
		}

		final Intent intent = getIntent();
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			final String pattern = intent.getStringExtra(SearchManager.QUERY);
			runSearch(pattern);
		}
		finish();
	}

	private static class Searcher extends ItemsLoader {
		private final SearchItemTree myTree;
		private final String myPattern;

		public Searcher(Activity activity, SearchItemTree tree, String pattern) {
			super(activity);
			myTree = tree;
			myPattern = pattern;
		}

		@Override
		public void doBefore() {
		}

		@Override
		public void doLoading(NetworkOperationData.OnNewItemListener doWithListener) {
			try {
				NetworkLibrary.Instance().simpleSearch(myPattern, doWithListener);
			} catch (ZLNetworkException e) {
			}
		}

		@Override
		protected void updateItems(List<NetworkItem> items) {
			SearchResult result = myTree.getSearchResult();
			for (NetworkItem item: items) {
				if (item instanceof NetworkBookItem) {
					result.addBook((NetworkBookItem)item);
				}
			}
			myTree.updateSubTrees();
			NetworkView.Instance().fireModelChanged();
		}

		@Override
		protected void onFinish(String errorMessage, boolean interrupted,
				Set<NetworkItem> uncommitedItems) {
			if (interrupted) {
				myTree.setSearchResult(null);
			} else {
				myTree.updateSubTrees();
				afterUpdateCatalog(errorMessage, myTree.getSearchResult().isEmpty());
			}
			NetworkView.Instance().fireModelChanged();
		}

		private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
			final ZLResource dialogResource = ZLResource.resource(""dialog"");
			ZLResource boxResource = null;
			String msg;
			if (errorMessage != null) {
				boxResource = dialogResource.getResource(""networkError"");
				msg = errorMessage;
			} else if (childrenEmpty) {
				boxResource = dialogResource.getResource(""emptySearchResults"");
				msg = boxResource.getResource(""message"").getValue();
			} else {
				return;
			}

			final SearchItemTree tree = NetworkLibrary.Instance().getSearchItemTree();
			if (tree == null) {
				return;
			}

			final NetworkCatalogActivity activity = NetworkCatalogActivity.getByTree(tree);
			if (activity != null) {
				final ZLResource buttonResource = dialogResource.getResource(""button"");
				new AlertDialog.Builder(activity)
					.setTitle(boxResource.getResource(""title"").getValue())
					.setMessage(msg)
					.setIcon(0)
					.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
					.create().show();
			}
		}
	}

	protected void runSearch(final String pattern) {
		final NetworkLibrary library = NetworkLibrary.Instance();
		library.NetworkSearchPatternOption.setValue(pattern);

		final SearchItemTree tree = library.getSearchItemTree();
		if (tree == null ||
			ItemsLoadingService.getRunnable(tree) != null) {
			return;
		}

		final String summary = ZLResource.resource(""networkView"").getResource(""searchResults"").getValue().replace(""%s"", pattern);
		final SearchResult result = new SearchResult(summary);

		tree.setSearchResult(result);
		NetworkView.Instance().fireModelChangedAsync();

		ItemsLoadingService.start(
			this, tree, new Searcher(this, tree, pattern)
		);
		Util.openTree(this, tree);
	}
}
",True,422,0,0,9,101,0,15,L7
272,org.geometerplus.android.fbreader.network.AuthenticationActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;
import android.widget.Button;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.R;

public class AuthenticationActivity extends Activity {
	final static String AREA_KEY = ""area"";
	final static String HOST_KEY = ""host"";
	final static String SCHEME_KEY = ""scheme"";
	final static String USERNAME_KEY = ""username"";
	final static String PASSWORD_KEY = ""password"";
	final static String ERROR_KEY = ""error"";
	final static String SHOW_SIGNUP_LINK_KEY = ""showSignupLink"";

	final static int RESULT_SIGNUP = RESULT_FIRST_USER;

	private ZLResource myResource;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));
		setResult(RESULT_CANCELED);
		setContentView(R.layout.authentication);

		final Intent intent = getIntent();
		final String host = intent.getStringExtra(HOST_KEY);
		final String area = intent.getStringExtra(AREA_KEY);
		final String username = intent.getStringExtra(USERNAME_KEY);
		final String error = intent.getStringExtra(ERROR_KEY);
		final boolean showSignupLink = intent.getBooleanExtra(SHOW_SIGNUP_LINK_KEY, false);

		myResource = ZLResource.resource(""dialog"").getResource(""AuthenticationDialog"");

		setTitle(host != null ? host : myResource.getResource(""title"").getValue());

		if (area != null && !"""".equals(area)) {
			findTextView(R.id.authentication_subtitle).setText(area);
		} else {
			findTextView(R.id.authentication_subtitle).setVisibility(View.GONE);
		}
		final TextView warningView = findTextView(R.id.authentication_unencrypted_warning);
		if (""https"".equalsIgnoreCase(intent.getStringExtra(SCHEME_KEY))) {
			warningView.setVisibility(View.GONE);
		} else {
			warningView.setText(myResource.getResource(""unencryptedWarning"").getValue());
		}
		findTextView(R.id.authentication_username_label).setText(
			myResource.getResource(""login"").getValue()
		);
		findTextView(R.id.authentication_password_label).setText(
			myResource.getResource(""password"").getValue()
		);

		final TextView usernameView = findTextView(R.id.authentication_username);
		usernameView.setText(username);

		final TextView errorView = findTextView(R.id.authentication_error);
		if (error != null && !"""".equals(error)) {
			errorView.setVisibility(View.VISIBLE);
			errorView.setText(error);
		} else {
			errorView.setVisibility(View.GONE);
		}

		if (showSignupLink) {
			findViewById(R.id.authentication_signup_box).setVisibility(View.VISIBLE);
			final TextView signupView = (TextView)findViewById(R.id.authentication_signup);
			signupView.setText(myResource.getResource(""register"").getValue());
			signupView.setOnClickListener(new View.OnClickListener() {
				public void onClick(View view) {
					setResult(RESULT_SIGNUP);
					finish();
				}
			});
		} else {
			findViewById(R.id.authentication_signup_box).setVisibility(View.GONE);
		}

		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");

		final Button okButton = findButton(R.id.authentication_ok_button);
		okButton.setText(buttonResource.getResource(""ok"").getValue());
		okButton.setOnClickListener(new Button.OnClickListener() {
			public void onClick(View v) {
				final Intent data = new Intent();
				data.putExtra(
					USERNAME_KEY,
					usernameView.getText().toString()
				);
				data.putExtra(
					PASSWORD_KEY,
					findTextView(R.id.authentication_password).getText().toString()
				);
				setResult(RESULT_OK, data);
				finish();
			}
		});

		final Button cancelButton = findButton(R.id.authentication_cancel_button);
		cancelButton.setText(buttonResource.getResource(""cancel"").getValue());
		cancelButton.setOnClickListener(new Button.OnClickListener() {
			public void onClick(View v) {
				finish();
			}
		});
	}

	private TextView findTextView(int resourceId) {
		return (TextView)findViewById(resourceId);
	}

	private Button findButton(int resourceId) {
		return (Button)findViewById(resourceId);
	}
}
",True,85,7,26,7,8,2,2,L6
273,org.geometerplus.android.fbreader.network.ItemsLoadingService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.os.IBinder;
import android.os.Handler;
import android.os.Message;

import org.geometerplus.fbreader.network.NetworkTree;

public class ItemsLoadingService extends Service {
	private static final String KEY = ""ItemsLoadingRunnable"";

	static void start(Context context, NetworkTree tree, ItemsLoader runnable) {
		boolean doDownload = false;
		synchronized (tree) {
			if (tree.getUserData(KEY) == null) {
				tree.setUserData(KEY, runnable);
				doDownload = true;
			}
		}
		if (doDownload) {
			context.startService(
				new Intent(context.getApplicationContext(), ItemsLoadingService.class)
					.putExtra(Util.TREE_KEY_KEY, tree.getUniqueKey())
			);
		}
	}

	static ItemsLoader getRunnable(NetworkTree tree) {
		return tree != null ? (ItemsLoader)tree.getUserData(KEY) : null;
	}

	private static void removeRunnable(NetworkTree tree) {
		synchronized (tree) {
			ItemsLoader runnable = (ItemsLoader)tree.getUserData(KEY);
			if (runnable != null) {
				tree.setUserData(KEY, null);
				runnable.runFinishHandler();
			}
		}
	}

	private volatile int myServiceCounter;

	private void doStart() {
		++myServiceCounter;
	}

	private void doStop() {
		if (--myServiceCounter == 0) {
			stopSelf();
		}
	}


	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		doStart();

		final NetworkTree tree = Util.getTreeFromIntent(intent);
		if (tree == null) {
			doStop();
			return;
		}
		intent.removeExtra(Util.TREE_KEY_KEY);

		if (!NetworkView.Instance().isInitialized()) {
			doStop();
			return;
		}

		final ItemsLoader runnable = getRunnable(tree);
		if (runnable == null) {
			doStop();
			return;
		}

		final Handler finishHandler = new Handler() {
			public void handleMessage(Message message) {
				doStop();
				removeRunnable(tree);
				NetworkView.Instance().fireModelChanged();
			}
		};

		// this call is needed to show indeterminate progress bar in title right on downloading start
		NetworkView.Instance().fireModelChangedAsync();

		final Thread loader = new Thread(new Runnable() {
			public void run() {
				try {
					runnable.run();
				} finally {
					finishHandler.sendEmptyMessage(0);
				}
			}
		});
		loader.setPriority(Thread.MIN_PRIORITY);
		loader.start();
	}
}
",True,422,1,1,9,114,6,4,L6
274,org.geometerplus.android.fbreader.network.NetworkView.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.Activity;
import android.os.Handler;
import android.os.Message;
import android.view.MenuItem;
import android.view.Menu;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkCatalogTree;

class NetworkView {
	private static NetworkView ourInstance;

	public static NetworkView Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkView();
		}
		return ourInstance;
	}

	private volatile boolean myInitialized;
	private final ArrayList<NetworkTreeActions> myActions = new ArrayList<NetworkTreeActions>();
	private TopupActions myTopupActions;

	private NetworkView() {
	}

	public boolean isInitialized() {
		return myInitialized;
	}

	public void initialize() throws ZLNetworkException {
		new SQLiteNetworkDatabase();

		final NetworkLibrary library = NetworkLibrary.Instance();
		library.initialize();
		library.synchronize();

		myActions.add(new NetworkBookActions());
		myActions.add(new NetworkCatalogActions());
		myActions.add(new SearchItemActions());
		myTopupActions = new TopupActions();
		myActions.add(myTopupActions);
		myActions.add(new AddCustomCatalogItemActions());
		myActions.trimToSize();

		myInitialized = true;
	}

	public void runBackgroundUpdate(boolean clearCache) throws ZLNetworkException {
		NetworkLibrary.Instance().runBackgroundUpdate(clearCache);
	}

	// This method MUST be called from main thread
	// This method has effect only when runBackgroundUpdate method has returned null
	public void finishBackgroundUpdate() {
		NetworkLibrary library = NetworkLibrary.Instance();
		library.finishBackgroundUpdate();
		library.synchronize();
		fireModelChanged();
	}

	/*
	 * NetworkItem's actions
	 */

	public TopupActions getTopupActions() {
		return myTopupActions;
	}

	public NetworkTreeActions getActions(NetworkTree tree) {
		for (NetworkTreeActions actions : myActions) {
			if (actions.canHandleTree(tree)) {
				return actions;
			}
		}
		return null;
	}

	/*
	 * OptionsMenu methods
	 */

	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.createOptionsMenu(menu, tree);
		}
		return false;
	}

	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.prepareOptionsMenu(activity, menu, tree);
		}
		return false;
	}

	public boolean runOptionsMenu(NetworkBaseActivity activity, MenuItem item, NetworkTree tree) {
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.runAction(activity, tree, item.getItemId());
		}
		return false;
	}

	/*
	 * Code for loading network items (running items-loading service and managing items-loading runnables).
	 */

	public void tryResumeLoading(Activity activity, NetworkCatalogTree tree, Runnable expandRunnable) {
		final ItemsLoader runnable = ItemsLoadingService.getRunnable(tree);
		if (runnable != null && runnable.tryResumeLoading()) {
			Util.openTree(activity, tree);
			return;
		}
		if (runnable == null) {
			expandRunnable.run();
		} else {
			runnable.runOnFinish(expandRunnable);
		}
	}


	/*
	 * Notifying view's components from services
	 */

	public interface EventListener {
		void onModelChanged();
	}

	private Handler myEventHandler;
	private LinkedList<EventListener> myEventListeners = new LinkedList<EventListener>();

	/*
	 * This method must be called only from main thread
	 */
	public final void addEventListener(EventListener listener) {
		synchronized (myEventListeners) {
			if (myEventHandler == null) {
				myEventHandler = new Handler() {
					@Override
					public void handleMessage(Message msg) {
						fireModelChanged();
					}
				};
			}
			if (listener != null) {
				myEventListeners.add(listener);
			}
		}
	}

	public final void removeEventListener(EventListener listener) {
		synchronized (myEventListeners) {
			myEventListeners.remove(listener);
		}
	}

	final void fireModelChangedAsync() {
		synchronized (myEventListeners) {
			if (myEventHandler != null) {
				myEventHandler.sendEmptyMessage(0);
			}
		}
	}

	final void fireModelChanged() {
		for (EventListener listener : myEventListeners) {
			listener.onModelChanged();
		}
	}
}
",True,424,1,3,8,113,12,15,L6
275,org.geometerplus.android.fbreader.network.BookDownloaderService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;
import java.io.*;

import android.os.IBinder;
import android.os.Handler;
import android.os.Message;
import android.app.Service;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.net.Uri;
import android.content.Intent;
import android.widget.RemoteViews;
import android.widget.Toast;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.*;

import org.geometerplus.fbreader.network.urlInfo.UrlInfo;
import org.geometerplus.fbreader.network.urlInfo.BookUrlInfo;

import org.geometerplus.android.fbreader.FBReader;

public class BookDownloaderService extends Service {
	public static final String BOOK_FORMAT_KEY = ""org.geometerplus.android.fbreader.network.BookFormat"";
	public static final String REFERENCE_TYPE_KEY = ""org.geometerplus.android.fbreader.network.ReferenceType"";
	public static final String CLEAN_URL_KEY = ""org.geometerplus.android.fbreader.network.CleanURL"";
	public static final String TITLE_KEY = ""org.geometerplus.android.fbreader.network.Title"";
	public static final String SSL_CERTIFICATE_KEY = ""org.geometerplus.android.fbreader.network.SSLCertificate"";

	public static final String SHOW_NOTIFICATIONS_KEY = ""org.geometerplus.android.fbreader.network.ShowNotifications"";

	public interface Notifications {
		int DOWNLOADING_STARTED = 0x0001;
		int ALREADY_DOWNLOADING = 0x0002;

		int ALL = 0x0003;
	}


	private Set<String> myDownloadingURLs = Collections.synchronizedSet(new HashSet<String>());
	private Set<Integer> myOngoingNotifications = new HashSet<Integer>();

	private volatile int myServiceCounter;

	private void doStart() {
		++myServiceCounter;
	}

	private void doStop() {
		if (--myServiceCounter == 0) {
			stopSelf();
		}
	}

	public static ZLResource getResource() {
		return ZLResource.resource(""bookDownloader"");
	}

	@Override
	public IBinder onBind(Intent intent) {
		return new BookDownloaderInterface.Stub() {
			public boolean isBeingDownloaded(String url) {
				return myDownloadingURLs.contains(url);
			}
		};
	}

	@Override
	public void onDestroy() {
		final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		for (int notificationId: myOngoingNotifications) {
			notificationManager.cancel(notificationId);
		}
		myOngoingNotifications.clear();
		super.onDestroy();
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		doStart();

		final Uri uri = intent.getData();
		if (uri == null) {
			doStop();
			return;
		}
		intent.setData(null);

		final int notifications = intent.getIntExtra(SHOW_NOTIFICATIONS_KEY, 0);

		final String url = uri.toString();
		final int bookFormat = intent.getIntExtra(BOOK_FORMAT_KEY, BookUrlInfo.Format.NONE);
		UrlInfo.Type referenceType = (UrlInfo.Type)intent.getSerializableExtra(REFERENCE_TYPE_KEY);
		if (referenceType == null) {
			referenceType = UrlInfo.Type.Book;
		}

		String cleanURL = intent.getStringExtra(CLEAN_URL_KEY);
		if (cleanURL == null) {
			cleanURL = url;
		}

		if (myDownloadingURLs.contains(url)) {
			if ((notifications & Notifications.ALREADY_DOWNLOADING) != 0) {
				showMessage(""alreadyDownloading"");
			}
			doStop();
			return;
		}

		String fileName = BookUrlInfo.makeBookFileName(cleanURL, bookFormat, referenceType);
		if (fileName == null) {
			doStop();
			return;
		}

		int index = fileName.lastIndexOf(File.separator);
		if (index != -1) {
			final String dir = fileName.substring(0, index);
			final File dirFile = new File(dir);
			if (!dirFile.exists() && !dirFile.mkdirs()) {
				showMessage(""cannotCreateDirectory"", dirFile.getPath());
				doStop();
				return;
			}
			if (!dirFile.exists() || !dirFile.isDirectory()) {
				showMessage(""cannotCreateDirectory"", dirFile.getPath());
				doStop();
				return;
			}
		}

		final File fileFile = new File(fileName);
		if (fileFile.exists()) {
			if (!fileFile.isFile()) {
				showMessage(""cannotCreateFile"", fileFile.getPath());
				doStop();
				return;
			}
			// TODO: question box: redownload?
			doStop();
			startActivity(getFBReaderIntent(fileFile));
			return;
		}
		String title = intent.getStringExtra(TITLE_KEY);
		if (title == null || title.length() == 0) {
			title = fileFile.getName();
		}
		if ((notifications & Notifications.DOWNLOADING_STARTED) != 0) {
			showMessage(""downloadingStarted"");
		}
		final String sslCertificate = intent.getStringExtra(SSL_CERTIFICATE_KEY);
		startFileDownload(url, sslCertificate, fileFile, title);
	}

	private void showMessage(String key) {
		Toast.makeText(
			getApplicationContext(),
			getResource().getResource(key).getValue(),
			Toast.LENGTH_SHORT
		).show();
	}

	private void showMessage(String key, String parameter) {
		Toast.makeText(
			getApplicationContext(),
			getResource().getResource(key).getValue().replace(""%s"", parameter),
			Toast.LENGTH_SHORT
		).show();
	}

	private Intent getFBReaderIntent(final File file) {
		final Intent intent = new Intent(getApplicationContext(), FBReader.class);
		if (file != null) {
			intent.setAction(Intent.ACTION_VIEW).setData(Uri.fromFile(file));
		}
		return intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
	}

	private Notification createDownloadFinishNotification(File file, String title, boolean success) {
		final ZLResource resource = getResource();
		final String tickerText = success ?
			resource.getResource(""tickerSuccess"").getValue() :
			resource.getResource(""tickerError"").getValue();
		final String contentText = success ?
			resource.getResource(""contentSuccess"").getValue() :
			resource.getResource(""contentError"").getValue();
		final Notification notification = new Notification(
			android.R.drawable.stat_sys_download_done,
			tickerText,
			System.currentTimeMillis()
		);
		notification.flags |= Notification.FLAG_AUTO_CANCEL;
		final Intent intent = success ? getFBReaderIntent(file) : new Intent();
		final PendingIntent contentIntent = PendingIntent.getActivity(this, 0, intent, 0);
		notification.setLatestEventInfo(getApplicationContext(), title, contentText, contentIntent);
		return notification;
	}

	private Notification createDownloadProgressNotification(String title) {
		final RemoteViews contentView = new RemoteViews(getPackageName(), R.layout.download_notification);
		contentView.setTextViewText(R.id.download_notification_title, title);
		contentView.setTextViewText(R.id.download_notification_progress_text, """");
		contentView.setProgressBar(R.id.download_notification_progress_bar, 100, 0, true);

		final PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(), 0);

		final Notification notification = new Notification();
		notification.icon = android.R.drawable.stat_sys_download;
		notification.flags |= Notification.FLAG_ONGOING_EVENT;
		notification.contentView = contentView;
		notification.contentIntent = contentIntent;

		return notification;
	}

	private void sendDownloaderCallback() {
		sendBroadcast(
			new Intent(getApplicationContext(), BookDownloaderCallback.class)
		);
	}

	private void startFileDownload(final String urlString, final String sslCertificate, final File file, final String title) {
		myDownloadingURLs.add(urlString);
		sendDownloaderCallback();

		final int notificationId = NetworkNotifications.Instance().getBookDownloadingId();
		final Notification progressNotification = createDownloadProgressNotification(title);

		final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		myOngoingNotifications.add(Integer.valueOf(notificationId));
		notificationManager.notify(notificationId, progressNotification);

		final Handler progressHandler = new Handler() {
			public void handleMessage(Message message) {
				final int progress = message.what;
				final RemoteViews contentView = (RemoteViews)progressNotification.contentView;

				if (progress < 0) {
					contentView.setTextViewText(R.id.download_notification_progress_text, """");
					contentView.setProgressBar(R.id.download_notification_progress_bar, 100, 0, true);
				} else {
					contentView.setTextViewText(R.id.download_notification_progress_text, """" + progress + ""%"");
					contentView.setProgressBar(R.id.download_notification_progress_bar, 100, progress, false);
				}
				final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
				notificationManager.notify(notificationId, progressNotification);
			}
		};

		final Handler downloadFinishHandler = new Handler() {
			public void handleMessage(Message message) {
				myDownloadingURLs.remove(urlString);
				final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
				notificationManager.cancel(notificationId);
				myOngoingNotifications.remove(Integer.valueOf(notificationId));
				notificationManager.notify(
					notificationId,
					createDownloadFinishNotification(file, title, message.what != 0)
				);
				sendDownloaderCallback();
				doStop();
			}
		};

		final ZLNetworkRequest request = new ZLNetworkRequest(urlString, sslCertificate, null) {
			public void handleStream(InputStream inputStream, int length) throws IOException, ZLNetworkException {
				final int updateIntervalMillis = 1000; // FIXME: remove hardcoded time constant

				int downloadedPart = 0;
				long progressTime = System.currentTimeMillis() + updateIntervalMillis;
				if (length <= 0) {
					progressHandler.sendEmptyMessage(-1);
				}
				OutputStream outStream;
				try {
					outStream = new FileOutputStream(file);
				} catch (FileNotFoundException ex) {
					throw new ZLNetworkException(ZLNetworkException.ERROR_CREATE_FILE, file.getPath());
				}
				try {
					final byte[] buffer = new byte[8192];
					while (true) {
						final int size = inputStream.read(buffer);
						if (size <= 0) {
							break;
						}
						downloadedPart += size;
						if (length > 0) {
							final long currentTime = System.currentTimeMillis();
							if (currentTime > progressTime) {
								progressTime = currentTime + updateIntervalMillis;
								progressHandler.sendEmptyMessage(downloadedPart * 100 / length);
							}
							/*if (downloadedPart * 100 / length > 95) {
								throw new IOException(""debug exception"");
							}*/
						}
						outStream.write(buffer, 0, size);
						/*try {
							Thread.currentThread().sleep(200);
						} catch (InterruptedException ex) {
						}*/
					}
				} finally {
					outStream.close();
				}
			}
		};

		final Thread downloader = new Thread(new Runnable() {
			public void run() {
				boolean success = false;
				try {
					ZLNetworkManager.Instance().perform(request);
					success = true;
				} catch (ZLNetworkException e) {
					// TODO: show error message to User
					file.delete();
				} finally {
					downloadFinishHandler.sendEmptyMessage(success ? 1 : 0);
				}
			}
		});
		downloader.setPriority(Thread.MIN_PRIORITY);
		downloader.start();
	}
}
",True,421,0,0,8,102,3,8,L6
276,org.geometerplus.android.fbreader.network.NetworkInitializer.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Handler;
import android.os.Message;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.android.util.UIUtil;

class NetworkInitializer extends Handler {
	static NetworkInitializer Instance;

	private Activity myActivity;

	public NetworkInitializer(Activity activity) {
		Instance = this;
		setActivity(activity);
	}

	public void setActivity(Activity activity) {
		myActivity = activity;
	}

	final DialogInterface.OnClickListener myListener = new DialogInterface.OnClickListener() {
		public void onClick(DialogInterface dialog, int which) {
			if (which == DialogInterface.BUTTON_POSITIVE) {
				NetworkInitializer.this.start();
			} else if (myActivity != null) {
				myActivity.finish();
			}
		}
	};

	// run this method only if myActivity != null
	private void runInitialization() {
		UIUtil.wait(""loadingNetworkLibrary"", new Runnable() {
			public void run() {
				String error = null;
				try {
					NetworkView.Instance().initialize();
					if (myActivity instanceof NetworkLibraryActivity) {
						((NetworkLibraryActivity)myActivity).processSavedIntent();
					}
				} catch (ZLNetworkException e) {
					error = e.getMessage();
				}
				NetworkInitializer.this.end(error);
			}
		}, myActivity);
	}

	private void showTryAgainDialog(Activity activity, String error) {
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource boxResource = dialogResource.getResource(""networkError"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		new AlertDialog.Builder(activity)
			.setTitle(boxResource.getResource(""title"").getValue())
			.setMessage(error)
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""tryAgain"").getValue(), myListener)
			.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), myListener)
			.setOnCancelListener(new DialogInterface.OnCancelListener() {
				public void onCancel(DialogInterface dialog) {
					myListener.onClick(dialog, DialogInterface.BUTTON_NEGATIVE);
				}
			})
			.create().show();
	}

	@Override
	public void handleMessage(Message message) {
		if (myActivity == null) {
			return;
		} else if (message.what == 0) {
			runInitialization(); // run initialization process
		} else if (message.obj == null) {
			if (myActivity instanceof NetworkLibraryActivity) {
				final NetworkLibraryActivity a = (NetworkLibraryActivity)myActivity;
				a.startService(new Intent(a.getApplicationContext(), LibraryInitializationService.class));
				a.prepareView(); // initialization is complete successfully
			}
		} else {
			showTryAgainDialog(myActivity, (String)message.obj); // handle initialization error
		}
	}

	public void start() {
		sendEmptyMessage(0);
	}

	private void end(String error) {
		sendMessage(obtainMessage(1, error));
	}
}
",False,421,0,0,9,101,2,5,L6
277,org.geometerplus.android.fbreader.network.AddCustomCatalogItemActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.content.Intent;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.tree.AddCustomCatalogItemTree;

class AddCustomCatalogItemActions extends NetworkTreeActions {
	public static final int RUN_ITEM_ID = 0;

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof AddCustomCatalogItemTree;
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		return RUN_ITEM_ID;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		switch (actionCode) {
			case RUN_ITEM_ID:
				addCustomCatalog(activity);
				return true;
		}
		return false;
	}

	public static void addCustomCatalog(Activity activity) {
		activity.startActivity(new Intent(activity, AddCustomCatalogActivity.class));
	}
}
",False,421,0,0,9,114,2,4,L6
278,org.geometerplus.android.fbreader.network.NetworkTreeActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.Menu;
import android.view.ContextMenu;
import android.view.MenuItem;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.NetworkTree;


abstract class NetworkTreeActions {

	// special values to return from getDefaultActionCode(NetworkTree)
	public static final int TREE_NO_ACTION = -1;
	public static final int TREE_SHOW_CONTEXT_MENU = -2;


	protected final ZLResource myResource = ZLResource.resource(""networkView"");

	protected final String getTitleValue(String key) {
		return myResource.getResource(key).getValue();
	}

	protected final String getTitleValue(String key, String arg) {
		return myResource.getResource(key).getValue().replace(""%s"", arg);
	}

	protected final String getConfirmValue(String key) {
		return myResource.getResource(""confirmQuestions"").getResource(key).getValue();
	}

	protected final String getConfirmValue(String key, String arg) {
		return myResource.getResource(""confirmQuestions"").getResource(key).getValue().replace(""%s"", arg);
	}

	protected final String getOptionsValue(String key) {
		return myResource.getResource(""menu"").getResource(key).getValue();
	}

	protected final String getOptionsValue(String key, String arg) {
		return myResource.getResource(""menu"").getResource(key).getValue().replace(""%s"", arg);
	}

	protected final MenuItem addMenuItem(ContextMenu menu, int id, String key) {
		return menu.add(0, id, 0, getTitleValue(key)).setEnabled(id != TREE_NO_ACTION);
	}

	protected final MenuItem addMenuItem(ContextMenu menu, int id, String key, String arg) {
		return menu.add(0, id, 0, getTitleValue(key, arg)).setEnabled(id != TREE_NO_ACTION);
	}

	protected final MenuItem addOptionsItem(Menu menu, int id, String key/*, int iconId*/) {
		final MenuItem item = menu.add(0, id, 0, getOptionsValue(key));
		//item.setIcon(iconId);
		return item;
	}

	protected final MenuItem addOptionsItem(Menu menu, int id, String key, String arg/*, int iconId*/) {
		final MenuItem item = menu.add(0, id, 0, getOptionsValue(key, arg));
		//item.setIcon(iconId);
		return item;
	}

	protected final MenuItem prepareOptionsItem(Menu menu, int id, boolean state) {
		return menu.findItem(id).setVisible(state).setEnabled(state);
	}

	protected final MenuItem prepareOptionsItem(Menu menu, int id, boolean state, String key, String arg) {
		final MenuItem item = prepareOptionsItem(menu, id, state);
		if (state) {
			item.setTitle(getOptionsValue(key, arg));
		}
		return item;
	}


	public abstract boolean canHandleTree(NetworkTree tree);

	public String getTreeTitle(NetworkTree tree) {
		return tree.getName();
	}

	public abstract void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree);

	public abstract int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree);
	public abstract String getConfirmText(NetworkTree tree, int actionCode);

	public abstract boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode);

	public abstract boolean createOptionsMenu(Menu menu, NetworkTree tree);
	public abstract boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree);
}
",False,421,0,0,9,112,9,4,L6
279,org.geometerplus.android.fbreader.network.SQLiteNetworkDatabase.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.urlInfo.*;

import org.geometerplus.android.util.SQLiteUtil;

class SQLiteNetworkDatabase extends NetworkDatabase {
	private final SQLiteDatabase myDatabase;

	SQLiteNetworkDatabase() {
		myDatabase = ZLAndroidApplication.Instance().openOrCreateDatabase(""network.db"", Context.MODE_PRIVATE, null);
		migrate();
	}

	private void migrate() {
		final int version = myDatabase.getVersion();
		final int currentCodeVersion = 6;
		if (version >= currentCodeVersion) {
			return;
		}
		myDatabase.beginTransaction();
		switch (version) {
			case 0:
				createTables();
			case 1:
				updateTables1();
			case 2:
				updateTables2();
			case 3:
				updateTables3();
			case 4:
				updateTables4();
			case 5:
				updateTables5();
		}
		myDatabase.setTransactionSuccessful();
		myDatabase.endTransaction();

		myDatabase.execSQL(""VACUUM"");
		myDatabase.setVersion(currentCodeVersion);
	}

	protected void executeAsATransaction(Runnable actions) {
		myDatabase.beginTransaction();
		try {
			actions.run();
			myDatabase.setTransactionSuccessful();
		} finally {
			myDatabase.endTransaction();
		}
	}

	@Override
	protected synchronized List<INetworkLink> listLinks() {
		final List<INetworkLink> links = new LinkedList<INetworkLink>();

		final Cursor cursor = myDatabase.rawQuery(""SELECT link_id,predefined_id,title,site_name,summary,language FROM Links"", null);
		final UrlInfoCollection<UrlInfoWithDate> linksMap = new UrlInfoCollection<UrlInfoWithDate>();
		while (cursor.moveToNext()) {
			final int id = cursor.getInt(0);
			final String predefinedId = cursor.getString(1);
			final String title = cursor.getString(2);
			final String siteName = cursor.getString(3);
			final String summary = cursor.getString(4);
			final String language = cursor.getString(5);

			linksMap.clear();
			final Cursor linksCursor = myDatabase.rawQuery(""SELECT key,url,update_time FROM LinkUrls WHERE link_id = "" + id, null);
			while (linksCursor.moveToNext()) {
				try {
					linksMap.addInfo(
						new UrlInfoWithDate(
							UrlInfo.Type.valueOf(linksCursor.getString(0)),
							linksCursor.getString(1),
							SQLiteUtil.getDate(linksCursor, 2)
						)
					);
				} catch (IllegalArgumentException e) {
				}
			}
			linksCursor.close();

			final INetworkLink l = createLink(id, predefinedId, siteName, title, summary, language, linksMap);
			if (l != null) {
				links.add(l);
			}
		}
		cursor.close();

		return links;
	}

	private SQLiteStatement myInsertCustomLinkStatement;
	private SQLiteStatement myUpdateCustomLinkStatement;
	private SQLiteStatement myInsertCustomLinkUrlStatement;
	private SQLiteStatement myUpdateCustomLinkUrlStatement;
	@Override
	protected synchronized void saveLink(final INetworkLink link) {
		executeAsATransaction(new Runnable() {
			public void run() {
				final SQLiteStatement statement;
				if (link.getId() == INetworkLink.INVALID_ID) {
					if (myInsertCustomLinkStatement == null) {
						myInsertCustomLinkStatement = myDatabase.compileStatement(
							""INSERT INTO Links (title,site_name,summary,language,predefined_id) VALUES (?,?,?,?,?)""
						);
					}
					statement = myInsertCustomLinkStatement;
				} else {
					if (myUpdateCustomLinkStatement == null) {
						myUpdateCustomLinkStatement = myDatabase.compileStatement(
							""UPDATE Links SET title = ?, site_name = ?, summary = ?, language = ?""
								+ "" WHERE link_id = ?""
						);
					}
					statement = myUpdateCustomLinkStatement;
				}

				statement.bindString(1, link.getTitle());
				statement.bindString(2, link.getSiteName());
				SQLiteUtil.bindString(statement, 3, link.getSummary());
				SQLiteUtil.bindString(statement, 4, link.getLanguage());

				final long id;
				final UrlInfoCollection<UrlInfoWithDate> linksMap =
					new UrlInfoCollection<UrlInfoWithDate>();

				if (statement == myInsertCustomLinkStatement) {
					if (link instanceof IPredefinedNetworkLink) {
						statement.bindString(5, ((IPredefinedNetworkLink)link).getPredefinedId());
					} else {
						SQLiteUtil.bindString(statement, 5, null);
					}
					id = statement.executeInsert();
					link.setId((int)id);
				} else {
					id = link.getId();
					statement.bindLong(5, id);
					statement.execute();
					
					final Cursor linksCursor = myDatabase.rawQuery(""SELECT key,url,update_time FROM LinkUrls WHERE link_id = "" + link.getId(), null);
					while (linksCursor.moveToNext()) {
						try {
							linksMap.addInfo(
								new UrlInfoWithDate(
									UrlInfo.Type.valueOf(linksCursor.getString(0)),
									linksCursor.getString(1),
									SQLiteUtil.getDate(linksCursor, 2)
								)
							);
						} catch (IllegalArgumentException e) {
						}
					}
					linksCursor.close();
				}

				for (UrlInfo.Type key : link.getUrlKeys()) {
					final UrlInfoWithDate info = link.getUrlInfo(key);
					final UrlInfoWithDate dbInfo = linksMap.getInfo(key);
					linksMap.removeAllInfos(key);
					final SQLiteStatement urlStatement;
					if (dbInfo == null) {
						if (myInsertCustomLinkUrlStatement == null) {
							myInsertCustomLinkUrlStatement = myDatabase.compileStatement(
									""INSERT OR REPLACE INTO LinkUrls(url,update_time,link_id,key) VALUES (?,?,?,?)"");
						}
						urlStatement = myInsertCustomLinkUrlStatement;
					} else if (!info.equals(dbInfo)) {
						if (myUpdateCustomLinkUrlStatement == null) {
							myUpdateCustomLinkUrlStatement = myDatabase.compileStatement(
									""UPDATE LinkUrls SET url = ?, update_time = ? WHERE link_id = ? AND key = ?"");
						}
						urlStatement = myUpdateCustomLinkUrlStatement;
					} else {
						continue;
					}
					SQLiteUtil.bindString(urlStatement, 1, info.Url);
					SQLiteUtil.bindDate(urlStatement, 2, info.Updated);
					urlStatement.bindLong(3, id);
					urlStatement.bindString(4, key.toString());
					urlStatement.execute();
				}
				for (UrlInfo info : linksMap.getAllInfos()) {
					myDatabase.delete(""LinkUrls"", ""link_id = ? AND key = ?"",
						new String[] { String.valueOf(id), info.InfoType.toString() }
					);
				}
			}
		});
	}

	@Override
	protected synchronized void deleteLink(final INetworkLink link) {
		if (link.getId() == INetworkLink.INVALID_ID) {
			return;
		}
		executeAsATransaction(new Runnable() {
			public void run() {
				final String stringLinkId = String.valueOf(link.getId());
				myDatabase.delete(""Links"", ""link_id = ?"", new String[] { stringLinkId });
				myDatabase.delete(""LinkUrls"", ""link_id = ?"", new String[] { stringLinkId });
				link.setId(INetworkLink.INVALID_ID);
			}
		});
	}

	@Override
	protected synchronized Map<String,String> getLinkExtras(INetworkLink link) {
		final HashMap<String,String> extras = new HashMap<String,String>();
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT key,value FROM Extras WHERE link_id = ?"",
			new String[] { String.valueOf(link.getId()) }
		);
		while (cursor.moveToNext()) {
			extras.put(cursor.getString(0), cursor.getString(1));
		}
		cursor.close();
		return extras;
	}

	@Override
	protected synchronized void setLinkExtras(final INetworkLink link, final Map<String,String> extras) {
		executeAsATransaction(new Runnable() {
			public void run() {
				if (link.getId() == INetworkLink.INVALID_ID) {
					return;
				}
				myDatabase.delete(""Extras"", ""link_id = ?"", new String[] { String.valueOf(link.getId()) });
				for (Map.Entry<String,String> entry : extras.entrySet()) {
					myDatabase.execSQL(
						""INSERT INTO Extras (link_id,key,value) VALUES (?,?,?)"",
						new Object[] { link.getId(), entry.getKey(), entry.getValue() }
					);
				}
			}
		});
	}
	
	private void createTables() {
		myDatabase.execSQL(
			""CREATE TABLE CustomLinks("" +
				""link_id INTEGER PRIMARY KEY,"" +
				""title TEXT UNIQUE NOT NULL,"" +
				""site_name TEXT NOT NULL,"" +
				""summary TEXT,"" +
				""icon TEXT)"");
		myDatabase.execSQL(
			""CREATE TABLE CustomLinkUrls("" +
				""key TEXT NOT NULL,"" +
				""link_id INTEGER NOT NULL REFERENCES CustomLinks(link_id),"" +
				""url TEXT NOT NULL,"" +
				""CONSTRAINT CustomLinkUrls_PK PRIMARY KEY (key, link_id))"");
	}

	private void updateTables1() {
		myDatabase.execSQL(""ALTER TABLE CustomLinks RENAME TO CustomLinks_Obsolete"");
		myDatabase.execSQL(
				""CREATE TABLE CustomLinks("" +
					""link_id INTEGER PRIMARY KEY,"" +
					""title TEXT NOT NULL,"" +
					""site_name TEXT NOT NULL,"" +
					""summary TEXT,"" +
					""icon TEXT)"");
		myDatabase.execSQL(""INSERT INTO CustomLinks (link_id,title,site_name,summary,icon) SELECT link_id,title,site_name,summary,icon FROM CustomLinks_Obsolete"");
		myDatabase.execSQL(""DROP TABLE CustomLinks_Obsolete"");

		myDatabase.execSQL(
				""CREATE TABLE LinkUrls("" +
					""key TEXT NOT NULL,"" +
					""link_id INTEGER NOT NULL REFERENCES CustomLinks(link_id),"" +
					""url TEXT,"" +
					""update_time INTEGER,"" +
					""CONSTRAINT LinkUrls_PK PRIMARY KEY (key, link_id))"");
		myDatabase.execSQL(""INSERT INTO LinkUrls (key,link_id,url) SELECT key,link_id,url FROM CustomLinkUrls"");
		myDatabase.execSQL(""DROP TABLE CustomLinkUrls"");
	}

	private void updateTables2() {
		myDatabase.execSQL(
				""CREATE TABLE Links("" +
					""link_id INTEGER PRIMARY KEY,"" +
					""title TEXT NOT NULL,"" +
					""site_name TEXT NOT NULL,"" +
					""summary TEXT)"");
		myDatabase.execSQL(""INSERT INTO Links (link_id,title,site_name,summary) SELECT link_id,title,site_name,summary FROM CustomLinks"");
		final Cursor cursor = myDatabase.rawQuery(""SELECT link_id,icon FROM CustomLinks"", null);
		while (cursor.moveToNext()) {
			final int id = cursor.getInt(0);
			final String url = cursor.getString(1);
			myDatabase.execSQL(""INSERT INTO LinkUrls (key,link_id,url) VALUES "" +
				""('icon',"" + id + "",'"" + url + ""')"");
		}
		cursor.close();
		myDatabase.execSQL(""DROP TABLE CustomLinks"");
	}

	private void updateTables3() {
		myDatabase.execSQL(""UPDATE LinkUrls SET key='Catalog' WHERE key='main'"");
		myDatabase.execSQL(""UPDATE LinkUrls SET key='Search' WHERE key='search'"");
		myDatabase.execSQL(""UPDATE LinkUrls SET key='Image' WHERE key='icon'"");
	}

	private void updateTables4() {
		myDatabase.execSQL(""ALTER TABLE Links ADD COLUMN is_predefined INTEGER"");
		myDatabase.execSQL(""UPDATE Links SET is_predefined=0"");

		myDatabase.execSQL(""ALTER TABLE Links ADD COLUMN is_enabled INTEGER DEFAULT 1"");

		myDatabase.execSQL(""ALTER TABLE LinkUrls RENAME TO LinkUrls_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE LinkUrls("" +
				""key TEXT NOT NULL,"" +
				""link_id INTEGER NOT NULL REFERENCES Links(link_id),"" +
				""url TEXT,"" +
				""update_time INTEGER,"" +
				""CONSTRAINT LinkUrls_PK PRIMARY KEY (key, link_id))""
		);
		myDatabase.execSQL(""INSERT INTO LinkUrls (key,link_id,url) SELECT key,link_id,url FROM LinkUrls_Obsolete"");
		myDatabase.execSQL(""DROP TABLE LinkUrls_Obsolete"");

		myDatabase.execSQL(
			""CREATE TABLE IF NOT EXISTS Extras("" +
				""link_id INTEGER NOT NULL REFERENCES Links(link_id),"" +
				""key TEXT NOT NULL,"" +
				""value TEXT NOT NULL,"" +
				""CONSTRAINT Extras_PK PRIMARY KEY (key, link_id))""
		);
	}

	private void updateTables5() {
		myDatabase.execSQL(""ALTER TABLE Links RENAME TO Links_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE Links("" +
				""link_id INTEGER PRIMARY KEY,"" +
				""title TEXT NOT NULL,"" +
				""site_name TEXT NOT NULL,"" +
				""summary TEXT,"" +
				""language TEXT,"" +
				""predefined_id TEXT,"" +
				""is_enabled INTEGER)"");
		myDatabase.execSQL(""INSERT INTO Links (link_id,title,site_name,summary,language,predefined_id,is_enabled) SELECT link_id,title,site_name,summary,NULL,NULL,is_enabled FROM Links_Obsolete"");
		myDatabase.execSQL(""DROP TABLE Links_Obsolete"");
	}
}
",True,234,6,26,11,51,1,8,L6
280,org.geometerplus.android.fbreader.network.BookDownloader.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.List;

import android.os.Bundle;
import android.app.Activity;
import android.net.Uri;
import android.content.Intent;

import org.geometerplus.fbreader.network.urlInfo.BookUrlInfo;

public class BookDownloader extends Activity {

	public static boolean acceptsUri(Uri uri) {
		final List<String> path = uri.getPathSegments();
		if ((path == null) || path.isEmpty()) {
			return false;
		}

		if (""epub"".equals(uri.getScheme())) {
			return true;
		}

		final String fileName = path.get(path.size() - 1).toLowerCase();
		return
			fileName.endsWith("".fb2.zip"") ||
			fileName.endsWith("".fb2"") ||
			fileName.endsWith("".epub"") ||
			fileName.endsWith("".mobi"") ||
			fileName.endsWith("".prc"");
	}

	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		final Intent intent = getIntent();
		Uri uri = intent.getData();
		intent.setData(null);
		if (uri == null || !acceptsUri(uri)) {
			finish();
			return;
		}

		if (!intent.hasExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY)) {
			intent.putExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY, 
				BookDownloaderService.Notifications.ALREADY_DOWNLOADING);
		}
		if (""epub"".equals(uri.getScheme())) {
			uri = uri.buildUpon().scheme(""http"").build();
			intent.putExtra(BookDownloaderService.BOOK_FORMAT_KEY,
					BookUrlInfo.Format.EPUB);
		}

		startService(
			new Intent(Intent.ACTION_DEFAULT, uri, this, BookDownloaderService.class)
				.putExtras(intent.getExtras())
		);
		finish();
	}
}
",False,421,0,0,9,99,1,3,L6
281,org.geometerplus.android.fbreader.network.NetworkCatalogActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.Activity;
import android.content.Intent;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.util.PackageUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.authentication.*;
import org.geometerplus.fbreader.network.tree.NetworkTreeFactory;
import org.geometerplus.fbreader.network.tree.NetworkCatalogTree;
import org.geometerplus.fbreader.network.tree.NetworkCatalogRootTree;
import org.geometerplus.fbreader.network.opds.BasketItem;
import org.geometerplus.fbreader.network.urlInfo.UrlInfo;

class NetworkCatalogActions extends NetworkTreeActions {
	public static final int OPEN_CATALOG_ITEM_ID = 0;
	public static final int OPEN_IN_BROWSER_ITEM_ID = 1;
	public static final int RELOAD_ITEM_ID = 2;
	public static final int SIGNUP_ITEM_ID = 3;
	public static final int SIGNIN_ITEM_ID = 4;
	public static final int SIGNOUT_ITEM_ID = 5;
	public static final int TOPUP_ITEM_ID = 6;

	public static final int CUSTOM_CATALOG_EDIT = 7;
	public static final int CUSTOM_CATALOG_REMOVE = 8;

	public static final int BASKET_CLEAR = 9;
	public static final int BASKET_BUY_ALL_BOOKS = 10;

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof NetworkCatalogTree;
	}

	@Override
	public String getTreeTitle(NetworkTree tree) {
		if (tree instanceof NetworkCatalogRootTree) {
			return tree.getName();
		}
		return tree.getName() + "" - "" + ((NetworkCatalogTree)tree).Item.Link.getSiteName();
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		final NetworkCatalogItem item = ((NetworkCatalogTree)tree).Item;
		final NetworkURLCatalogItem urlItem =
			item instanceof NetworkURLCatalogItem ? (NetworkURLCatalogItem)item : null;
		menu.setHeaderTitle(tree.getName());

		boolean hasItems = false;

		final String catalogUrl =
			urlItem != null ? urlItem.getUrl(UrlInfo.Type.Catalog) : null;
		if (catalogUrl != null &&
			(!(item instanceof BasketItem) || item.Link.basket().bookIds().size() > 0)) {
			addMenuItem(menu, OPEN_CATALOG_ITEM_ID, ""openCatalog"");
			hasItems = true;
		}

		if (tree instanceof NetworkCatalogRootTree) {
			if (item.getVisibility() == ZLBoolean3.B3_TRUE) {
				final NetworkAuthenticationManager mgr = item.Link.authenticationManager();
				if (mgr != null) {
					if (mgr.mayBeAuthorised(false)) {
						addMenuItem(menu, SIGNOUT_ITEM_ID, ""signOut"", mgr.currentUserName());
						if (Util.isTopupSupported(activity, item.Link)) {
							final String account = mgr.currentAccount();
							if (account != null) {
								addMenuItem(menu, TOPUP_ITEM_ID, ""topup"", account);
							}
						}
					} else {
						addMenuItem(menu, SIGNIN_ITEM_ID, ""signIn"");
						//if (mgr.passwordRecoverySupported()) {
						//	registerAction(new PasswordRecoveryAction(mgr), true);
						//}
					}
				}
			}
			INetworkLink link = item.Link; 
			if (link instanceof ICustomNetworkLink) {
				addMenuItem(menu, CUSTOM_CATALOG_EDIT, ""editCustomCatalog"");
				addMenuItem(menu, CUSTOM_CATALOG_REMOVE, ""removeCustomCatalog"");
			}
		} else {
			if (urlItem != null && urlItem.getUrl(UrlInfo.Type.HtmlPage) != null) {
				addMenuItem(menu, OPEN_IN_BROWSER_ITEM_ID, ""openInBrowser"");
				hasItems = true;
			}
		}

		if (item.getVisibility() == ZLBoolean3.B3_UNDEFINED &&
			!hasItems && item.Link.authenticationManager() != null) {
			addMenuItem(menu, SIGNIN_ITEM_ID, ""signIn"");
		}
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		final NetworkCatalogItem item = ((NetworkCatalogTree)tree).Item;
		if (!(item instanceof NetworkURLCatalogItem)) {
			return OPEN_CATALOG_ITEM_ID;
		}
		final NetworkURLCatalogItem urlItem = (NetworkURLCatalogItem)item;
		if (urlItem.getUrl(UrlInfo.Type.Catalog) != null) {
			return OPEN_CATALOG_ITEM_ID;
		}
		if (urlItem.getUrl(UrlInfo.Type.HtmlPage) != null) {
			return OPEN_IN_BROWSER_ITEM_ID;
		}
		if (urlItem.getVisibility() == ZLBoolean3.B3_UNDEFINED &&
			urlItem.Link.authenticationManager() != null) {
			return SIGNIN_ITEM_ID;
		}
		return TREE_NO_ACTION;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		if (actionCode == OPEN_IN_BROWSER_ITEM_ID) {
			return getConfirmValue(""openInBrowser"");
		}
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		addOptionsItem(menu, RELOAD_ITEM_ID, ""reload"");
		addOptionsItem(menu, SIGNIN_ITEM_ID, ""signIn"");
		addOptionsItem(menu, SIGNUP_ITEM_ID, ""signUp"");
		addOptionsItem(menu, SIGNOUT_ITEM_ID, ""signOut"", """");
		addOptionsItem(menu, TOPUP_ITEM_ID, ""topup"");
		if (((NetworkCatalogTree)tree).Item instanceof BasketItem) {
			addOptionsItem(menu, BASKET_CLEAR, ""clearBasket"");
			addOptionsItem(menu, BASKET_BUY_ALL_BOOKS, ""buyAllBooks"");
		}
		return true;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		final NetworkCatalogItem item = ((NetworkCatalogTree)tree).Item;
		final NetworkURLCatalogItem urlItem =
			item instanceof NetworkURLCatalogItem ? (NetworkURLCatalogItem)item : null;

		prepareOptionsItem(menu, RELOAD_ITEM_ID,
			urlItem != null &&
			urlItem.getUrl(UrlInfo.Type.Catalog) != null &&
			ItemsLoadingService.getRunnable(tree) == null
		);

		boolean signIn = false;
		boolean signOut = false;
		boolean topup = false;
		String userName = null;
		String account = null;
		NetworkAuthenticationManager mgr = item.Link.authenticationManager();
		if (mgr != null) {
			if (mgr.mayBeAuthorised(false)) {
				userName = mgr.currentUserName();
				signOut = true;
				account = mgr.currentAccount();
				if (account != null && Util.isTopupSupported(activity, item.Link)) {
					topup = true;
				}
			} else {
				signIn = true;
				//if (mgr.passwordRecoverySupported()) {
				//	registerAction(new PasswordRecoveryAction(mgr), true);
				//}
			}
		}
		prepareOptionsItem(menu, SIGNIN_ITEM_ID, signIn);
		prepareOptionsItem(menu, SIGNUP_ITEM_ID, signIn & Util.isRegistrationSupported(activity, item.Link));
		prepareOptionsItem(menu, SIGNOUT_ITEM_ID, signOut, ""signOut"", userName);
		prepareOptionsItem(menu, TOPUP_ITEM_ID, topup);
		return true;
	}

	private boolean consumeByVisibility(final NetworkBaseActivity activity, final NetworkTree tree, final int actionCode) {
		final NetworkCatalogItem item = ((NetworkCatalogTree)tree).Item;
		switch (item.getVisibility()) {
			case B3_TRUE:
				return false;
			case B3_UNDEFINED:
				Util.runAuthenticationDialog(activity, item.Link, null, new Runnable() {
					public void run() {
						if (item.getVisibility() != ZLBoolean3.B3_TRUE) {
							return;
						}
						if (actionCode != SIGNIN_ITEM_ID) {
							runAction(activity, tree, actionCode);
						}
					}
				});
				break;
		}
		return true;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree)tree;
		if (consumeByVisibility(activity, catalogTree, actionCode)) {
			return true;
		}

		final NetworkCatalogItem item = catalogTree.Item;
		switch (actionCode) {
			case OPEN_CATALOG_ITEM_ID:
			{
				if (item instanceof BasketItem && item.Link.basket().bookIds().size() == 0) {
					UIUtil.showErrorMessage(activity, ""emptyBasket"");
				} else {
					doExpandCatalog(activity, catalogTree);
				}
				return true;
			}
			case OPEN_IN_BROWSER_ITEM_ID:
				if (item instanceof NetworkURLCatalogItem) {
					Util.openInBrowser(
						activity,
						item.getUrl(UrlInfo.Type.HtmlPage)
					);
				}
				return true;
			case RELOAD_ITEM_ID:
				doReloadCatalog(activity, catalogTree);
				return true;
			case SIGNIN_ITEM_ID:
				Util.runAuthenticationDialog(activity, item.Link, null, null);
				return true;
			case SIGNUP_ITEM_ID:
				Util.runRegistrationDialog(activity, item.Link);
				return true;
			case SIGNOUT_ITEM_ID:
				doSignOut(activity, catalogTree);
				return true;
			case TOPUP_ITEM_ID:
				new TopupActions().runStandalone(activity, item.Link);
				return true;
			case CUSTOM_CATALOG_EDIT:
			{
				final Intent intent = new Intent(activity, AddCustomCatalogActivity.class);
				NetworkLibraryActivity.addLinkToIntent(
					intent,
					(ICustomNetworkLink)item.Link
				);
				activity.startActivity(intent);
				return true;
			}
			case CUSTOM_CATALOG_REMOVE:
				removeCustomLink((ICustomNetworkLink)item.Link);
				return true;
			case BASKET_CLEAR:
				item.Link.basket().clear();
				return true;
			case BASKET_BUY_ALL_BOOKS:
				return true;
		}
		return false;
	}

	private static class CatalogExpander extends ItemsLoader {
		private final NetworkCatalogTree myTree;
		private final boolean myCheckAuthentication;
		private final boolean myResumeNotLoad;

		public CatalogExpander(Activity activity,
				NetworkCatalogTree tree, boolean checkAuthentication, boolean resumeNotLoad) {
			super(activity);
			myTree = tree;
			myCheckAuthentication = checkAuthentication;
			myResumeNotLoad = resumeNotLoad;
		}

		@Override
		public void doBefore() throws ZLNetworkException {
			final INetworkLink link = myTree.Item.Link;
			if (myCheckAuthentication && link.authenticationManager() != null) {
				final NetworkAuthenticationManager mgr = link.authenticationManager();
				try {
					if (mgr.isAuthorised(true) && mgr.needsInitialization()) {
						mgr.initialize();
					}
				} catch (ZLNetworkException e) {
					mgr.logOut();
				}
			}
		}

		@Override
		public void doLoading(NetworkOperationData.OnNewItemListener doWithListener) throws ZLNetworkException {
			if (myResumeNotLoad) {
				myTree.Item.resumeLoading(doWithListener);
			} else {
				myTree.Item.loadChildren(doWithListener);
			}
		}

		@Override
		protected void updateItems(List<NetworkItem> items) {
			for (NetworkItem item: items) {
				myTree.ChildrenItems.add(item);
				NetworkTreeFactory.createNetworkTree(myTree, item);
			}
			NetworkView.Instance().fireModelChanged();
		}

		@Override
		protected void onFinish(String errorMessage, boolean interrupted,
				Set<NetworkItem> uncommitedItems) {
			if (interrupted &&
					(!myTree.Item.supportsResumeLoading() || errorMessage != null)) {
				myTree.ChildrenItems.clear();
				myTree.clear();
			} else {
				myTree.removeItems(uncommitedItems);
				myTree.updateLoadedTime();
				if (!interrupted) {
					afterUpdateCatalog(errorMessage, myTree.ChildrenItems.size() == 0);
				}
				final NetworkLibrary library = NetworkLibrary.Instance();
				library.invalidateVisibility();
				library.synchronize();
			}
			NetworkView.Instance().fireModelChanged();
		}

		private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
			final NetworkCatalogActivity activity = NetworkCatalogActivity.getByTree(myTree);
			if (activity == null) {
				return;
			}
			if (errorMessage != null) {
				UIUtil.showMessageText(activity, errorMessage);
			} else if (childrenEmpty) {
				UIUtil.showErrorMessage(activity, ""emptyCatalog"");
			}
		}
	}


	private static void processExtraData(final Activity activity, Map<String,String> extraData, final Runnable postRunnable) {
		if (extraData != null && !extraData.isEmpty()) {
			PackageUtil.runInstallPluginDialog(activity, extraData, postRunnable);
		} else {
			postRunnable.run();
		}
	}

	static void doExpandCatalog(final Activity activity, final NetworkCatalogTree tree) {
		NetworkView.Instance().tryResumeLoading(activity, tree, new Runnable() {
			public void run() {
				boolean resumeNotLoad = false;
				if (tree.hasChildren()) {
					if (tree.isContentValid()) {
						if (tree.Item.supportsResumeLoading()) {
							resumeNotLoad = true;
						} else {
							Util.openTree(activity, tree);
							return;
						}
					} else {
						clearTree(activity, tree);
					}
				}

				/* FIXME: if catalog's loading will be very fast
				 * then it is possible that loading message is lost
				 * (see afterUpdateCatalog method).
				 * 
				 * For example, this can be fixed via adding method
				 * NetworkView.postCatalogLoadingResult, that will do the following:
				 * 1) If there is activity, then show message
				 * 2) If there is no activity, then save message, and show when activity is created
				 * 3) Remove unused messages (say, by timeout)
				 */
				ItemsLoadingService.start(
					activity,
					tree,
					new CatalogExpander(activity, tree, true, resumeNotLoad)
				);
				processExtraData(activity, tree.Item.extraData(), new Runnable() {
					public void run() {
						Util.openTree(activity, tree);
					}
				});
			}
		});
	}

	private static void clearTree(Activity activity, final NetworkCatalogTree tree) {
		activity.runOnUiThread(new Runnable() {
			public void run() {
				tree.ChildrenItems.clear();
				tree.clear();
				NetworkView.Instance().fireModelChanged();
			}
		});
	}

	public void doReloadCatalog(NetworkBaseActivity activity, final NetworkCatalogTree tree) {
		if (ItemsLoadingService.getRunnable(tree) != null) {
			return;
		}
		clearTree(activity, tree);
		ItemsLoadingService.start(
			activity,
			tree,
			new CatalogExpander(activity, tree, false, false)
		);
	}

	private void doSignOut(final NetworkBaseActivity activity, NetworkCatalogTree tree) {
		final NetworkAuthenticationManager mgr = tree.Item.Link.authenticationManager();
		final Runnable runnable = new Runnable() {
			public void run() {
				if (mgr.mayBeAuthorised(false)) {
					mgr.logOut();
					activity.runOnUiThread(new Runnable() {
						public void run() {
							final NetworkLibrary library = NetworkLibrary.Instance();
							library.invalidateVisibility();
							library.synchronize();
							NetworkView.Instance().fireModelChanged();
						}
					});
				}
			}
		};
		UIUtil.wait(""signOut"", runnable, activity);
	}

	private void removeCustomLink(ICustomNetworkLink link) {
		final NetworkLibrary library = NetworkLibrary.Instance();
		library.removeCustomLink(link);
		library.synchronize();
		NetworkView.Instance().fireModelChangedAsync();
	}
}
",True,421,0,0,9,96,2,30,L6
282,org.geometerplus.android.fbreader.network.NetworkBaseActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.*;
import android.os.Bundle;
import android.view.*;
import android.widget.*;
import android.content.Intent;
import android.content.DialogInterface;
import android.graphics.Bitmap;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;
import org.geometerplus.zlibrary.ui.android.network.SQLiteCookieDatabase;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;
import org.geometerplus.fbreader.network.tree.AddCustomCatalogItemTree;
import org.geometerplus.fbreader.network.tree.SearchItemTree;

import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

abstract class NetworkBaseActivity extends ListActivity implements NetworkView.EventListener {
	protected static final int BASIC_AUTHENTICATION_CODE = 1;
	protected static final int CUSTOM_AUTHENTICATION_CODE = 2;
	protected static final int SIGNUP_CODE = 3;

	protected final ZLResource myResource = ZLResource.resource(""networkView"");

	public BookDownloaderServiceConnection Connection;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		SQLiteCookieDatabase.init(this);

		Connection = new BookDownloaderServiceConnection();
		bindService(
			new Intent(getApplicationContext(), BookDownloaderService.class),
			Connection,
			BIND_AUTO_CREATE
		);
	}

	@Override
	protected void onStart() {
		super.onStart();

		/*
		 * Set listener in onStart() to give descendants initialize itself in
		 * onCreate methods before onModelChanged() will be called.
		 */
		NetworkView.Instance().addEventListener(this);
	}

	@Override
	public void onResume() {
		super.onResume();
		getListView().setOnCreateContextMenuListener(this);
		onModelChanged(); // do the same update actions as upon onModelChanged
	}

	@Override
	protected void onStop() {
		NetworkView.Instance().removeEventListener(this);
		super.onStop();
	}

	@Override
	public void onDestroy() {
		if (Connection != null) {
			unbindService(Connection);
			Connection = null;
		}
		super.onDestroy();
	}

	// method from NetworkView.EventListener
	public void onModelChanged() {
	}

	private final Runnable myInvalidateViewsRunnable = new Runnable() {
		public void run() {
			getListView().invalidateViews();
		}
	};

	private void setupCover(final ImageView coverView, NetworkTree tree, int width, int height) {
		if (tree instanceof AddCustomCatalogItemTree) {
			coverView.setImageResource(R.drawable.ic_list_plus);
			return;
		}
		if (tree instanceof SearchItemTree) {
			coverView.setImageResource(R.drawable.ic_list_searchresult);
			return;
		}
		if (tree instanceof ZLAndroidTree) {
			coverView.setImageResource(((ZLAndroidTree)tree).getCoverResourceId());
			return;
		}

		Bitmap coverBitmap = null;
		ZLImage cover = tree.getCover();
		if (cover != null) {
			ZLAndroidImageData data = null;
			final ZLAndroidImageManager mgr = (ZLAndroidImageManager)ZLAndroidImageManager.Instance();
			if (cover instanceof ZLLoadableImage) {
				final ZLLoadableImage img = (ZLLoadableImage)cover;
				if (img.isSynchronized()) {
					data = mgr.getImageData(img);
				} else {
					img.startSynchronization(myInvalidateViewsRunnable);
				}
			} else {
				data = mgr.getImageData(cover);
			}
			if (data != null) {
				coverBitmap = data.getBitmap(2 * width, 2 * height);
			}
		}
		if (coverBitmap != null) {
			coverView.setImageBitmap(coverBitmap);
		} else if (tree instanceof NetworkBookTree) {
			coverView.setImageResource(R.drawable.ic_list_library_book);
		} else {
			coverView.setImageResource(R.drawable.ic_list_library_books);
		}
	}

	private int myCoverWidth = -1;
	private int myCoverHeight = -1;

	protected View setupNetworkTreeItemView(View convertView, final ViewGroup parent, NetworkTree tree) {
		final View view = (convertView != null) ? convertView :
			LayoutInflater.from(parent.getContext()).inflate(R.layout.network_tree_item, parent, false);

		((TextView)view.findViewById(R.id.network_tree_item_name)).setText(tree.getName());
		((TextView)view.findViewById(R.id.network_tree_item_childrenlist)).setText(tree.getSecondString());

		if (myCoverWidth == -1) {
			view.measure(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
			myCoverHeight = view.getMeasuredHeight();
			myCoverWidth = myCoverHeight * 15 / 32;
			view.requestLayout();
		}

		final ImageView coverView = (ImageView)view.findViewById(R.id.network_tree_item_icon);
		coverView.getLayoutParams().width = myCoverWidth;
		coverView.getLayoutParams().height = myCoverHeight;
		coverView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
		coverView.requestLayout();
		setupCover(coverView, tree, myCoverWidth, myCoverWidth);

		final ImageView statusView = (ImageView)view.findViewById(R.id.network_tree_item_status);
		final int status = (tree instanceof NetworkBookTree) ?
				NetworkBookActions.getBookStatus(((NetworkBookTree) tree).Book, Connection) : 0;
		if (status != 0) {
			statusView.setVisibility(View.VISIBLE);
			statusView.setImageResource(status);
		} else {
			statusView.setVisibility(View.GONE);
		}
		statusView.requestLayout();

		return view;
	}

	@Override
	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
		if (menuInfo != null) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final NetworkTree tree = (NetworkTree)getListAdapter().getItem(position);
			if (tree != null) {
				final NetworkTreeActions actions = NetworkView.Instance().getActions(tree);
				if (actions != null) {
					actions.buildContextMenu(this, menu, tree);
					return;
				}
			}
		}
		super.onCreateContextMenu(menu, view, menuInfo);
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		if (item != null && item.getMenuInfo() != null) {
			final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
			final NetworkTree tree = (NetworkTree)getListAdapter().getItem(position);
			if (tree != null) {
				final NetworkTreeActions actions = NetworkView.Instance().getActions(tree);
				if (actions != null && actions.runAction(this, tree, item.getItemId())) {
					return true;
				}
			}
		}
		return super.onContextItemSelected(item);
	}

	@Override
	public void onListItemClick(ListView listView, View view, int position, long rowId) {
		final NetworkTree networkTree = (NetworkTree)getListAdapter().getItem(position);
		final NetworkView networkView = NetworkView.Instance();
		final NetworkTreeActions actions = networkView.getActions(networkTree);
		if (actions == null) {
			return;
		}
		final int actionCode = actions.getDefaultActionCode(this, networkTree);
		final String confirm = actions.getConfirmText(networkTree, actionCode);
		if (actionCode == NetworkTreeActions.TREE_SHOW_CONTEXT_MENU) {
			listView.showContextMenuForChild(view);
			return;
		}
		if (actionCode < 0) {
			return;
		}
		if (confirm != null) {
			//final ZLResource resource = myResource.getResource(""confirmQuestions"");
			final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
			new AlertDialog.Builder(this)
				.setTitle(networkTree.getName())
				.setMessage(confirm)
				.setIcon(0)
				.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface dialog, int which) {
						actions.runAction(NetworkBaseActivity.this, networkTree, actionCode);
					}
				})
				.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
				.create().show();
		} else {
			actions.runAction(this, networkTree, actionCode);
		}
	}

	@Override
	public boolean onSearchRequested() {
		return false;
	}
}
",False,421,0,0,8,114,11,18,L6
283,org.geometerplus.android.fbreader.network.AddCustomCatalogActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.view.View;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.TextView;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.OPDSCustomNetworkLink;
import org.geometerplus.fbreader.network.urlInfo.*;

import org.geometerplus.android.util.UIUtil;

public class AddCustomCatalogActivity extends Activity {
	private ZLResource myResource;
	private volatile ICustomNetworkLink myLink;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));
		setContentView(R.layout.add_custom_catalog);

		myResource = ZLResource.resource(""dialog"").getResource(""CustomCatalogDialog"");

		setTitle(myResource.getResource(""title"").getValue());

		setTextFromResource(R.id.add_custom_catalog_title_label, ""catalogTitle"");
		setTextFromResource(R.id.add_custom_catalog_url_label, ""catalogUrl"");
		setTextFromResource(R.id.add_custom_catalog_summary_label, ""catalogSummary"");
		setTextFromResource(R.id.add_custom_catalog_title_example, ""catalogTitleExample"");
		setTextFromResource(R.id.add_custom_catalog_url_example, ""catalogUrlExample"");
		setTextFromResource(R.id.add_custom_catalog_summary_example, ""catalogSummaryExample"");

		setupButton(
			R.id.add_custom_catalog_ok_button, ""ok"", new View.OnClickListener() {
				public void onClick(View view) {
					final InputMethodManager imm =
						(InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
					imm.hideSoftInputFromWindow(findViewById(R.id.add_custom_catalog_url).getWindowToken(), 0);
					imm.hideSoftInputFromWindow(findViewById(R.id.add_custom_catalog_title).getWindowToken(), 0);
					imm.hideSoftInputFromWindow(findViewById(R.id.add_custom_catalog_summary).getWindowToken(), 0);
					onOkButton();
				}
			}
		);
		setupButton(
			R.id.add_custom_catalog_cancel_button, ""cancel"", new View.OnClickListener() {
				public void onClick(View view) {
					finish();
				}
			}
		);

		final Intent intent = getIntent();
		myLink = NetworkLibraryActivity.getLinkFromIntent(intent);
		final Uri uri = intent.getData();

		if (myLink != null) {
			setTextById(R.id.add_custom_catalog_url, myLink.getUrl(UrlInfo.Type.Catalog));
			setTextById(R.id.add_custom_catalog_title, myLink.getTitle());
			setTextById(R.id.add_custom_catalog_summary, myLink.getSummary());
			setExtraFieldsVisibility(true);
		} else if (uri != null) {
			loadInfoByUri(uri);
		} else {
			setExtraFieldsVisibility(false);
		}
	}

	private void onOkButton() {
		final String textUrl = getTextById(R.id.add_custom_catalog_url);
		if (isEmptyString(textUrl)) {
			setErrorByKey(""urlIsEmpty"");
			return;
		}

		final String title = getTextById(R.id.add_custom_catalog_title);
		final String summary = getTextById(R.id.add_custom_catalog_summary);
		Uri uri = null;
		try {
			uri = Uri.parse(textUrl);
			if (isEmptyString(uri.getScheme())) {
				uri = Uri.parse(""http://"" + textUrl);
			}
			if (isEmptyString(uri.getHost())) {
				setErrorByKey(""invalidUrl"");
				return;
			}
		} catch (Throwable t) {
			setErrorByKey(""invalidUrl"");
			return;
		}
		if (myLink == null) {
			loadInfoByUri(uri);
		} else if (isEmptyString(title)) {
			setErrorByKey(""titleIsEmpty"");
		} else {
			myLink.setTitle(title);
			myLink.setSummary(summary);
			myLink.setUrl(UrlInfo.Type.Catalog, uri.toString());

			Intent intent = new Intent(
				NetworkLibraryActivity.ADD_CATALOG,
				uri,
				AddCustomCatalogActivity.this,
				NetworkLibraryActivity.class
			).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
			NetworkLibraryActivity.addLinkToIntent(intent, myLink);
			startActivity(intent);
		}
	}

	private boolean isEmptyString(String s) {
		return s == null || s.length() == 0;
	}

	private void setExtraFieldsVisibility(boolean show) {
		final int visibility = show ? View.VISIBLE : View.GONE;
		runOnUiThread(new Runnable() {
			public void run() {
				findViewById(R.id.add_custom_catalog_title_group).setVisibility(visibility);
				findViewById(R.id.add_custom_catalog_summary_group).setVisibility(visibility);
			}
		});
	}

	private void setTextById(int id, String text) {
		((TextView)findViewById(id)).setText(text);
	}

	private String getTextById(int id) {
		final String text = ((TextView)findViewById(id)).getText().toString();
		return text != null ? text.trim() : null;
	}

	private void setupButton(int id, String resourceKey, View.OnClickListener listener) {
		final Button button = (Button)findViewById(id);
		button.setText(
			ZLResource.resource(""dialog"").getResource(""button"").getResource(resourceKey).getValue()
		);
		button.setOnClickListener(listener);
	}

	private void setTextFromResource(int id, String resourceKey) {
		setTextById(id, myResource.getResource(resourceKey).getValue());
	}

	private void setErrorText(final String errorText) {
		runOnUiThread(new Runnable() {
			public void run() {
				final TextView errorView = (TextView)findViewById(R.id.add_custom_catalog_error);
				if (errorText != null) {
					errorView.setText(errorText);
					errorView.setVisibility(View.VISIBLE);
				} else {
					errorView.setVisibility(View.GONE);
				}
			}
		});
	}

	private void setErrorByKey(final String resourceKey) {
		setErrorText(myResource.getResource(resourceKey).getValue());
	}

	private void runErrorDialog(final String errorText) {
		final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				switch (which) {
					case DialogInterface.BUTTON_POSITIVE:
						setExtraFieldsVisibility(true);
						break;
					case DialogInterface.BUTTON_NEUTRAL:
						break;
					case DialogInterface.BUTTON_NEGATIVE:
						AddCustomCatalogActivity.this.finish();
						break;
				}
			}
		};

		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource boxResource = dialogResource.getResource(""networkError"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		new AlertDialog.Builder(this)
			.setTitle(boxResource.getResource(""title"").getValue())
			.setMessage(errorText)
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""continue"").getValue(), listener)
			.setNeutralButton(buttonResource.getResource(""editUrl"").getValue(), listener)
			.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
			.create().show();
	}

	private void loadInfoByUri(Uri uri) {
		String textUrl = uri.toString();
		if (isEmptyString(uri.getScheme())) {
			textUrl = ""http://"" + textUrl;
			uri = Uri.parse(textUrl);
		} else if (""opds"".equals(uri.getScheme())) {
			textUrl = ""http"" + uri.toString().substring(4);
		}

		setTextById(R.id.add_custom_catalog_url, textUrl);
		final String siteName = uri.getHost();
		if (isEmptyString(siteName)) {
			setErrorByKey(""invalidUrl"");
			return;
		}
		final UrlInfoCollection<UrlInfoWithDate> infos = new UrlInfoCollection<UrlInfoWithDate>();
		infos.addInfo(new UrlInfoWithDate(UrlInfo.Type.Catalog, textUrl));
		myLink = new OPDSCustomNetworkLink(
			ICustomNetworkLink.INVALID_ID, siteName, null, null, null, infos
		);

		final Runnable loadInfoRunnable = new Runnable() {
			private String myError;

			public void run() {
				try {
					myError = null;
					myLink.reloadInfo(false);
				} catch (ZLNetworkException e) {
					myError = e.getMessage();
				}
				runOnUiThread(new Runnable() {
					public void run() {
						if (myError == null) {
							setTextById(R.id.add_custom_catalog_title, myLink.getTitle());
							setTextById(R.id.add_custom_catalog_summary, myLink.getSummary());
							setExtraFieldsVisibility(true);
						} else {
							runErrorDialog(myError);
							myLink = null;
						}
					}
				});
				setErrorText(myError);
			}
		}; 
		UIUtil.wait(""loadingCatalogInfo"", loadInfoRunnable, this);
	}
}
",True,422,0,0,10,90,0,11,L7
284,org.geometerplus.android.fbreader.network.ItemsLoader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.Activity;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkOperationData;
import org.geometerplus.fbreader.network.NetworkItem;

abstract class ItemsLoader implements Runnable {
	private final Activity myActivity;

	private final LinkedList<NetworkItem> myItems = new LinkedList<NetworkItem>();
	private final HashMap<INetworkLink, LinkedList<NetworkItem>> myUncommitedItems = new HashMap<INetworkLink, LinkedList<NetworkItem>>();
	private final Object myItemsMonitor = new Object();

	private volatile boolean myFinishProcessed;
	private final Object myFinishMonitor = new Object();

	private final long myUpdateInterval; // in milliseconds

	private boolean myInterruptRequested;
	private boolean myInterruptConfirmed;
	private final Object myInterruptLock = new Object();

	private volatile boolean myFinished;
	private volatile Runnable myFinishRunnable;
	private final Object myFinishedLock = new Object();

	ItemsLoader(Activity activity) {
		this(activity, 1000);
	}

	private ItemsLoader(Activity activity, long updateIntervalMillis) {
		myActivity = activity;
		myUpdateInterval = updateIntervalMillis;
	}

	public void interruptLoading() {
		synchronized (myInterruptLock) {
			myInterruptRequested = true;
		}
	}

	private boolean confirmInterruptLoading() {
		synchronized (myInterruptLock) {
			if (myInterruptRequested) {
				myInterruptConfirmed = true;
			}
			return myInterruptConfirmed;
		}
	}

	public boolean tryResumeLoading() {
		synchronized (myInterruptLock) {
			if (!myInterruptConfirmed) {
				myInterruptRequested = false;
			}
			return !myInterruptRequested;
		}
	}

	private boolean isLoadingInterrupted() {
		synchronized (myInterruptLock) {
			return myInterruptConfirmed;
		}
	}

	public final void run() {
		try {
			doBefore();
		} catch (ZLNetworkException e) {
			finishOnUiThread(e.getMessage(), false);
			return;
		}
		String error = null;
		try {
			doLoading(new NetworkOperationData.OnNewItemListener() {
				private long myUpdateTime;
				private int myItemsNumber;
				public void onNewItem(INetworkLink link, NetworkItem item) {
					addItem(link, item);
					++myItemsNumber;
					final long now = System.currentTimeMillis();
					if (now > myUpdateTime) {
						updateItemsOnUiThread();
						myUpdateTime = now + myUpdateInterval;
					}
				}
				public boolean confirmInterrupt() {
					return confirmInterruptLoading();
				}
				public void commitItems(INetworkLink link) {
					ItemsLoader.this.commitItems(link);
				}
			});
		} catch (ZLNetworkException e) {
			error = e.getMessage();
		}

		updateItemsOnUiThread();
		ensureItemsProcessed();
		finishOnUiThread(error, isLoadingInterrupted());
		ensureFinishProcessed();
	}

	void runFinishHandler() {
		synchronized (myFinishedLock) {
			if (myFinishRunnable != null) {
				myActivity.runOnUiThread(myFinishRunnable);
			}
			myFinished = true;
		}
	}

	public void runOnFinish(final Runnable runnable) {
		if (myFinishRunnable != null) {
			return;
		}
		synchronized (myFinishedLock) {
			if (myFinished) {
				runnable.run();
			} else {
				myFinishRunnable = runnable;
			}
		}
	}

	private final void updateItemsOnUiThread() {
		myActivity.runOnUiThread(new Runnable() {
			public void run() {
				synchronized (myItemsMonitor) {
					updateItems(myItems);
					myItems.clear();
					// wake up process, that waits for finish condition (see ensureFinish() method)
					myItemsMonitor.notifyAll();
				}
			}
		});
	}

	private final void addItem(INetworkLink link, NetworkItem item) {
		synchronized (myItemsMonitor) {
			myItems.add(item);
			LinkedList<NetworkItem> uncommited = myUncommitedItems.get(link);
			if (uncommited == null) {
				uncommited = new LinkedList<NetworkItem>();
				myUncommitedItems.put(link, uncommited);
			}
			uncommited.add(item);
		}
	}

	private final void commitItems(INetworkLink link) {
		synchronized (myItemsMonitor) {
			LinkedList<NetworkItem> uncommited = myUncommitedItems.get(link);
			if (uncommited != null) {
				uncommited.clear();
			}
		}
	}

	public final void ensureItemsProcessed() {
		synchronized (myItemsMonitor) {
			while (myItems.size() > 0) {
				try {
					myItemsMonitor.wait();
				} catch (InterruptedException e) {
				}
			}
		}
	}

	public final void ensureFinishProcessed() {
		synchronized (myFinishMonitor) {
			while (!myFinishProcessed) {
				try {
					myFinishMonitor.wait();
				} catch (InterruptedException e) {
				}
			}
		}
	}

	private final void finishOnUiThread(final String errorMessage, final boolean interrupted) {
		myActivity.runOnUiThread(new Runnable() {
			public void run() {
				HashSet<NetworkItem> uncommitedItems = new HashSet<NetworkItem>();
				synchronized (myUncommitedItems) {
					for (LinkedList<NetworkItem> items: myUncommitedItems.values()) {
						uncommitedItems.addAll(items);
					}
				}
				synchronized (myFinishMonitor) {
					onFinish(errorMessage, interrupted, uncommitedItems);
					myFinishProcessed = true;
					// wake up process, that waits for finish condition (see ensureFinish() method)
					myFinishMonitor.notifyAll();
				}
			}
		});
	}

	protected abstract void onFinish(String errorMessage, boolean interrupted, Set<NetworkItem> uncommitedItems);

	protected abstract void updateItems(List<NetworkItem> items);

	public abstract void doBefore() throws ZLNetworkException;
	public abstract void doLoading(NetworkOperationData.OnNewItemListener doWithListener) throws ZLNetworkException;

	//public abstract String getResourceKey();
}
",True,195,6,26,12,33,5,4,L6
285,org.geometerplus.android.fbreader.network.NetworkLibraryActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.*;
import android.widget.BaseAdapter;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.util.UIUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.OPDSCustomNetworkLink;
import org.geometerplus.fbreader.network.urlInfo.*;

public class NetworkLibraryActivity extends NetworkBaseActivity {
	static final String ADD_CATALOG = ""android.fbreader.action.ADD_CATALOG"";

	private static final String ADD_CATALOG_TITLE_KEY = ""title"";
	private static final String ADD_CATALOG_SUMMARY_KEY = ""summary"";
	private static final String ADD_CATALOG_ID_KEY = ""id"";
	private static final String ADD_CATALOG_URLS_MAP_KEY = ""urls"";

	static void addLinkToIntent(Intent intent, ICustomNetworkLink link) {
		final String textUrl = link.getUrl(UrlInfo.Type.Catalog);
		intent.setData(Uri.parse(textUrl));
		intent
			.putExtra(ADD_CATALOG_TITLE_KEY, link.getTitle())
			.putExtra(ADD_CATALOG_SUMMARY_KEY, link.getSummary())
			.putExtra(ADD_CATALOG_ID_KEY, link.getId())
			.putExtra(ADD_CATALOG_URLS_MAP_KEY, link.urlInfoMap());
	}

	static ICustomNetworkLink getLinkFromIntent(Intent intent) {
		final Uri uri = intent.getData();
		if (uri == null || !intent.hasExtra(ADD_CATALOG_ID_KEY)) {
			return null;
		}

		return new OPDSCustomNetworkLink(
			intent.getIntExtra(ADD_CATALOG_ID_KEY, ICustomNetworkLink.INVALID_ID),
			uri.getHost(),
			intent.getStringExtra(ADD_CATALOG_TITLE_KEY),
			intent.getStringExtra(ADD_CATALOG_SUMMARY_KEY),
			null,
			(UrlInfoCollection<UrlInfoWithDate>)intent.getSerializableExtra(ADD_CATALOG_URLS_MAP_KEY)
		);
	}

	private NetworkTree myTree;
	private volatile Intent myIntent;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);

		myIntent = getIntent();
	}

	@Override
	protected void onNewIntent(Intent intent) {
		super.onNewIntent(intent);

		processIntent(intent);
	}

	void processSavedIntent() {
		if (myIntent != null) {
			processIntent(myIntent);
			myIntent = null;
		}
	}

	private void processIntent(Intent intent) {
		if (ADD_CATALOG.equals(intent.getAction())) {
			final ICustomNetworkLink link = getLinkFromIntent(intent);
			if (link != null) {
				runOnUiThread(new Runnable() {
					public void run() {
						final NetworkLibrary library = NetworkLibrary.Instance();
						library.addCustomLink(link);
						library.synchronize();
						NetworkView.Instance().fireModelChangedAsync();
						getListView().invalidateViews();
					}
				});
			}
		}
	}

	void prepareView() {
		if (myTree == null) {
			myTree = NetworkLibrary.Instance().getRootTree();
			setListAdapter(new LibraryAdapter());
			getListView().invalidateViews();
		}
	}

	@Override
	public void onResume() {
		super.onResume();
		if (!NetworkView.Instance().isInitialized()) {
			if (NetworkInitializer.Instance == null) {
				new NetworkInitializer(this);
				NetworkInitializer.Instance.start();
			} else {
				NetworkInitializer.Instance.setActivity(this);
			}
		} else {
			prepareView();
			if (myIntent != null) {
				processIntent(myIntent);
				myIntent = null;
			}
		}
	}

	@Override
	public void onDestroy() {
		if (!NetworkView.Instance().isInitialized() && NetworkInitializer.Instance != null) {
			NetworkInitializer.Instance.setActivity(null);
		}
		super.onDestroy();
	}

	private final class LibraryAdapter extends BaseAdapter {
		public final int getCount() {
			if (!NetworkView.Instance().isInitialized()) {
				return 0;
			}
			return myTree.subTrees().size();
		}

		public final NetworkTree getItem(int position) {
			return (NetworkTree)myTree.subTrees().get(position);
		}

		public final long getItemId(int position) {
			return position;
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final NetworkTree tree = getItem(position);
			return setupNetworkTreeItemView(convertView, parent, tree);
		}
	}


	protected MenuItem addMenuItem(Menu menu, int index, String resourceKey, int iconId) {
		final String label = myResource.getResource(""menu"").getResource(resourceKey).getValue();
		return menu.add(0, index, Menu.NONE, label).setIcon(iconId);
	}


	private static final int MENU_SEARCH = 1;
	private static final int MENU_REFRESH = 2;
	private static final int MENU_ADD_CATALOG = 3;
	private static final int MENU_LANGUAGE_FILTER = 4;

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		addMenuItem(menu, MENU_SEARCH, ""networkSearch"", R.drawable.ic_menu_search);
		addMenuItem(menu, MENU_ADD_CATALOG, ""addCustomCatalog"", R.drawable.ic_menu_add);
		addMenuItem(menu, MENU_REFRESH, ""refreshCatalogsList"", R.drawable.ic_menu_refresh);
		addMenuItem(menu, MENU_LANGUAGE_FILTER, ""languages"", R.drawable.ic_menu_languages);
		return true;
	}

	private static boolean searchIsInProgress() {
		return ItemsLoadingService.getRunnable(
			NetworkLibrary.Instance().getSearchItemTree()
		) != null;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		super.onPrepareOptionsMenu(menu);
		menu.findItem(MENU_SEARCH).setEnabled(!searchIsInProgress());
		return true;
	}

	private void runLanguageFilterDialog() {
		final NetworkLibrary library = NetworkLibrary.Instance();

		final List<String> allLanguageCodes = library.languageCodes();
		Collections.sort(allLanguageCodes, new ZLLanguageUtil.CodeComparator());
		final Collection<String> activeLanguageCodes = library.activeLanguageCodes();
		final CharSequence[] languageNames = new CharSequence[allLanguageCodes.size()];
		final boolean[] checked = new boolean[allLanguageCodes.size()];

		for (int i = 0; i < allLanguageCodes.size(); ++i) {
			final String code = allLanguageCodes.get(i);
			languageNames[i] = ZLLanguageUtil.languageName(code);
			checked[i] = activeLanguageCodes.contains(code);
		}

		final DialogInterface.OnMultiChoiceClickListener listener =
			new DialogInterface.OnMultiChoiceClickListener() {
				public void onClick(DialogInterface dialog, int which, boolean isChecked) {
					checked[which] = isChecked;
				}
			};
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final AlertDialog dialog = new AlertDialog.Builder(this)
			.setMultiChoiceItems(languageNames, checked, listener)
			.setTitle(dialogResource.getResource(""languageFilterDialog"").getResource(""title"").getValue())
			.setPositiveButton(dialogResource.getResource(""button"").getResource(""ok"").getValue(), new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
					final TreeSet<String> newActiveCodes = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
					for (int i = 0; i < checked.length; ++i) {
						if (checked[i]) {
							newActiveCodes.add(allLanguageCodes.get(i));
						}
					}
					library.setActiveLanguageCodes(newActiveCodes);
					library.synchronize();
					NetworkView.Instance().fireModelChanged();
				}
			})
			.create();
		dialog.show();
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
			case MENU_SEARCH:
				return onSearchRequested();
			case MENU_ADD_CATALOG:
				AddCustomCatalogItemActions.addCustomCatalog(this);
				return true;
			case MENU_REFRESH:
				refreshCatalogsList();
				return true;
			case MENU_LANGUAGE_FILTER:
				runLanguageFilterDialog();
				return true;
			default:
				return true;
		}
	}

	@Override
	public boolean onSearchRequested() {
		if (searchIsInProgress()) {
			return false;
		}
		final NetworkLibrary library = NetworkLibrary.Instance();
		startSearch(library.NetworkSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	@Override
	public void onModelChanged() {
		getListView().invalidateViews();
	}

	private void refreshCatalogsList() {
		final NetworkView view = NetworkView.Instance();

		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				if (msg.obj == null) {
					view.finishBackgroundUpdate();
				} else {
					final ZLResource dialogResource = ZLResource.resource(""dialog"");
					final ZLResource boxResource = dialogResource.getResource(""networkError"");
					final ZLResource buttonResource = dialogResource.getResource(""button"");
					new AlertDialog.Builder(NetworkLibraryActivity.this)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage((String) msg.obj)
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
				}
			}
		};

		UIUtil.wait(""updatingCatalogsList"", new Runnable() {
			public void run() {
				String error = null;
				try {
					view.runBackgroundUpdate(true);
				} catch (ZLNetworkException e) {
					error = e.getMessage();
				}
				handler.sendMessage(handler.obtainMessage(0, error));
			}
		}, this);
	}
}
",False,422,1,1,9,95,4,19,L6
286,org.geometerplus.android.fbreader.tree.ZLAndroidTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.tree;

public interface ZLAndroidTree {
	int getCoverResourceId();
}
",False,55,5,25,0,0,3,0,L6
