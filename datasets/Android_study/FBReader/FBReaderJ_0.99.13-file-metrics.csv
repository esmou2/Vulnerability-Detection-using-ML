,file_path,source_code,is_vulnerable, size, upperDepth, upperWidth, lowerDepth, lowerWidth, fanIn, fanOut, drhLayer
0,org.geometerplus.fbreader.Paths.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader;

import org.geometerplus.zlibrary.core.options.ZLStringOption;

import android.os.Environment;

public abstract class Paths {
	public static ZLStringOption BooksDirectoryOption() {
		return new ZLStringOption(""Files"", ""BooksDirectory"", Environment.getExternalStorageDirectory() + ""/Books"");
	}

	public static ZLStringOption FontsDirectoryOption() {
		return new ZLStringOption(""Files"", ""FontsDirectory"", Environment.getExternalStorageDirectory() + ""/Fonts"");
	}

	public static ZLStringOption WallpapersDirectoryOption() {
		return new ZLStringOption(""Files"", ""WallpapersDirectory"", Environment.getExternalStorageDirectory() + ""/Wallpapers"");
	}

	public static String cacheDirectory() {
		return BooksDirectoryOption().getValue() + ""/.FBReader"";
	}

	public static String networkCacheDirectory() {
		return cacheDirectory() + ""/cache"";
	}
}
",False,170,7,70,3,1,12,1,L4
1,org.geometerplus.fbreader.formats.FormatPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public abstract class FormatPlugin {
	public abstract boolean acceptsFile(ZLFile file);
	public abstract	boolean readMetaInfo(Book book);
	public abstract boolean readModel(BookModel model);
	public abstract ZLImage readCover(ZLFile file);
	public abstract String readAnnotation(ZLFile file);

	/*
	public static void detectEncodingAndLanguage(Book book, InputStream stream) throws IOException {	
		String language = book.getLanguage();
		String encoding = book.getEncoding();
		if (encoding.length() == 0 || language.length() == 0) {
			PluginCollection collection = PluginCollection.Instance();
			if (language.length() == 0) {
				language = collection.DefaultLanguageOption.getValue();
			}
			if (encoding.length() == 0) {
				encoding = collection.DefaultEncodingOption.getValue();
			}
			if (collection.LanguageAutoDetectOption.getValue() && stream != null) {
				int BUFSIZE = 65536;
				byte[] buffer = new byte[BUFSIZE];
				int size = stream.read(buffer, 0, BUFSIZE);
				stream.close();
				ZLLanguageDetector.LanguageInfo info =
					new ZLLanguageDetector().findInfo(buffer, 0, size);
				buffer = null;
				if (info != null) {
					language = info.Language;
					encoding = info.Encoding;
					if ((encoding == ""US-ASCII"") || (encoding == ""ISO-8859-1"")) {
						encoding = ""windows-1252"";
					}
				}
			}
			book.setEncoding(encoding);
			book.setLanguage(language);
		}
	}
	//Last working version
	public static void detectEncodingAndLanguage(Book book, InputStream stream) {	
		String encoding = book.getEncoding();
		if (encoding.length() == 0) {
			encoding = EncodingDetector.detect(stream, PluginCollection.Instance().DefaultLanguageOption.getValue());
			if (encoding == ""unknown"") {
				encoding = ""windows-1252"";
			}
			book.setEncoding(encoding);
		}

		if (book.getLanguage() == """") {
			if ((encoding.equals(""US-ASCII"")) ||
					(encoding.equals(""ISO-8859-1""))) {
				book.setLanguage(""en"");
			} else if ((book.getEncoding().equals(""KOI8-R"")) ||
					(encoding.equals(""windows-1251"")) ||
					(encoding.equals(""ISO-8859-5"")) ||
					(encoding.equals(""IBM866""))) {
				book.setLanguage(""ru"");
			} /*else if (
	                (PluginCollection.Instance().DefaultLanguageOption.getValue() == EncodingDetector.Language.CZECH) &&
					((encoding == ""windows-1250"") ||
					 (encoding == ""ISO-8859-2"") ||
					 (encoding == ""IBM852""))) {
				book.setLanguage(""cs"");
			}*/
		/*}

	}*/
}
",False,207,7,33,7,38,8,4,L4
2,org.geometerplus.fbreader.formats.PluginCollection.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats;

import java.util.*;

import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.formats.fb2.FB2Plugin;
import org.geometerplus.fbreader.formats.oeb.OEBPlugin;
import org.geometerplus.fbreader.formats.pdb.MobipocketPlugin;

public class PluginCollection {
	private static PluginCollection ourInstance;

	private final ArrayList<FormatPlugin> myPlugins = new ArrayList<FormatPlugin>();
	public ZLStringOption DefaultLanguageOption;
	public ZLStringOption DefaultEncodingOption;
	public ZLBooleanOption LanguageAutoDetectOption;
	
	public static PluginCollection Instance() {
		if (ourInstance == null) {
			ourInstance = new PluginCollection();
			ourInstance.myPlugins.add(new FB2Plugin());
			//ourInstance.myPlugins.add(new PluckerPlugin());
			//ourInstance->myPlugins.push_back(new DocBookPlugin());
			//ourInstance.myPlugins.add(new HtmlPlugin());
			//ourInstance.myPlugins.add(new TxtPlugin());
			//ourInstance.myPlugins.add(new PalmDocPlugin());
			ourInstance.myPlugins.add(new MobipocketPlugin());
			//ourInstance.myPlugins.add(new ZTXTPlugin());
			//ourInstance.myPlugins.add(new TcrPlugin());
			//ourInstance.myPlugins.add(new CHMPlugin());
			ourInstance.myPlugins.add(new OEBPlugin());
			//ourInstance.myPlugins.add(new RtfPlugin());
			//ourInstance.myPlugins.add(new OpenReaderPlugin());
		}
		return ourInstance;
	}
	
	public static void deleteInstance() {
		if (ourInstance != null) {
			ourInstance = null;
		}
	}

	private PluginCollection() {
		LanguageAutoDetectOption = new ZLBooleanOption(""Format"", ""AutoDetect"", true);
		DefaultLanguageOption = new ZLStringOption(""Format"", ""DefaultLanguage"", ""en""); 
		DefaultEncodingOption = new ZLStringOption(""Format"", ""DefaultEncoding"", ""windows-1252"");
	}
		
	public FormatPlugin getPlugin(ZLFile file) {
		for (FormatPlugin plugin : myPlugins) {
			if (plugin.acceptsFile(file)) {
				return plugin;
			}
		}
		return null;
	}
}
",False,206,7,33,7,46,4,7,L4
3,org.geometerplus.fbreader.formats.html.HtmlMetaInfoReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;

public class HtmlMetaInfoReader extends ZLXMLReaderAdapter {
	private final Book myBook;

	private boolean myReadTitle;

	public HtmlMetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle("""");
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}

	public boolean readMetaInfo() {
		myReadTitle = false;
		return readDocument(myBook.File);
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (HtmlTag.getTagByName(tagName)) {
			case HtmlTag.TITLE:
				myReadTitle = true;
				break;
			default:
				break;
		}
		return false;
	}

	public boolean endElementHandler(String tag) {
		switch (HtmlTag.getTagByName(tag)) {
			case HtmlTag.TITLE:
				myReadTitle = false;
				break;
			default:
				break;
		}
		return false;
	}

	public void characterDataHandler(char[] ch, int start, int length) {
		// TODO + length -- remove
		final String text = new String(ch).substring(start, start + length);
		if (myReadTitle) {
			myBook.setTitle(myBook.getTitle() + text);
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file);
	}

}
",False,141,1,1,6,37,1,6,L7
4,org.geometerplus.fbreader.formats.html.HtmlPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.io.IOException;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class HtmlPlugin extends FormatPlugin {
	
	@Override
	public boolean acceptsFile(ZLFile file) {
		return ""htm"".equals(file.getExtension()) 
			|| ""html"".equals(file.getExtension());
	}

	@Override
	public boolean readMetaInfo(Book book) {
		return new HtmlMetaInfoReader(book).readMetaInfo();
	}

	@Override
	public boolean readModel(BookModel model) {
		try {
			return new HtmlReader(model).readBook();
		} catch (IOException e) {
			return false;
		}
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		return null;
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return null;
	}
}
",False,141,0,0,6,36,0,7,L7
5,org.geometerplus.fbreader.formats.html.HtmlTag.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.util.*;

public final class HtmlTag {
	public static final byte UNKNOWN = 0;
	public static final byte HTML = 1;
	public static final byte HEAD = 2;
	public static final byte BODY = 3;
	public static final byte TITLE = 4;
	public static final byte P = 5;
	public static final byte H1 = 6;
	public static final byte H2 = 7;
	public static final byte H3 = 8;
	public static final byte H4 = 9;
	public static final byte H5 = 10;
	public static final byte H6 = 11;
	public static final byte A = 12;
	public static final byte B = 13;
	public static final byte I = 14;
	public static final byte BR = 15;
	public static final byte STRONG = 16;
	public static final byte IMG = 17;
	public static final byte SCRIPT = 18;
	public static final byte OL = 19;
	public static final byte UL = 20;
	public static final byte LI = 21;
	public static final byte SELECT = 22;
	public static final byte DIV = 23;
	public static final byte TR = 24;
	public static final byte STYLE = 25;
	
	public static final byte S = 26;
	public static final byte SUB = 27;
	public static final byte SUP = 28;
	public static final byte PRE = 29;
	public static final byte CODE = 30;
	public static final byte EM = 31;
	public static final byte DFN = 32;
	public static final byte CITE = 33;

	public static final byte HR = 34;
	
	// mobipocket specific tags
	public static final byte REFERENCE = 35;
	public static final byte GUIDE = 36;

	public static final byte TAG_NUMBER = 37;
	
	private static final HashMap<String,Byte> ourTagByName = new HashMap<String,Byte>(256, 0.2f);
	private static final Byte ourUnknownTag;

	static {
		ourTagByName.put(""unknown"", UNKNOWN);
		ourUnknownTag = (Byte)ourTagByName.get(""unknown"");
		ourTagByName.put(""html"", HTML);
		ourTagByName.put(""head"", HEAD);
		ourTagByName.put(""body"", BODY);
		ourTagByName.put(""title"", TITLE);
		ourTagByName.put(""p"", P);
		ourTagByName.put(""h1"", H1);
		ourTagByName.put(""h2"", H2);
		ourTagByName.put(""h3"", H3);
		ourTagByName.put(""h4"", H4);
		ourTagByName.put(""h5"", H5);
		ourTagByName.put(""h6"", H6);
		ourTagByName.put(""a"", A);
		ourTagByName.put(""b"", B);
		ourTagByName.put(""i"", I);
		ourTagByName.put(""br"", BR);
		ourTagByName.put(""strong"", STRONG);
		ourTagByName.put(""img"", IMG);
		ourTagByName.put(""script"", SCRIPT);
		ourTagByName.put(""ol"", OL);
		ourTagByName.put(""ul"", UL);
		ourTagByName.put(""li"", LI);
		ourTagByName.put(""select"", SELECT);
		ourTagByName.put(""tr"", TR);
		ourTagByName.put(""style"", STYLE);
		ourTagByName.put(""s"", S);
		ourTagByName.put(""sub"", SUB);
		ourTagByName.put(""sup"", SUP);
		ourTagByName.put(""pre"", PRE);
		ourTagByName.put(""code"", CODE);
		ourTagByName.put(""em"", EM);
		ourTagByName.put(""def"", DFN);
		ourTagByName.put(""cite"", CITE);
		ourTagByName.put(""hr"", HR);
		ourTagByName.put(""guide"", GUIDE);
		ourTagByName.put(""reference"", REFERENCE);
	}

	public static byte getTagByName(String name) {
		final HashMap<String,Byte> tagByName = ourTagByName;
		Byte num = tagByName.get(name);
		if (num == null) {
			final String lowerCaseName = name.toLowerCase().intern();
			num = (Byte)tagByName.get(lowerCaseName);
			if (num == null) {
				num = ourUnknownTag;
				tagByName.put(lowerCaseName, num);
			}
			tagByName.put(name, num);
		}
		return num.byteValue();
	}
}
",False,146,13,40,0,0,3,0,L4
6,org.geometerplus.fbreader.formats.html.HtmlReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.html;

import java.util.HashMap;
import java.io.*;
import java.nio.charset.*;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.bookmodel.BookReader;
import org.geometerplus.fbreader.bookmodel.FBTextKind;
import org.geometerplus.zlibrary.core.html.*;
import org.geometerplus.zlibrary.core.util.ZLArrayUtils;
import org.geometerplus.zlibrary.text.model.ZLTextParagraph;

import org.geometerplus.zlibrary.core.xml.ZLXMLProcessor;
import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;

public class HtmlReader extends BookReader implements ZLHtmlReader {
	private final byte[] myStyleTable = new byte[HtmlTag.TAG_NUMBER];
	{
		myStyleTable[HtmlTag.H1] = FBTextKind.H1;
		myStyleTable[HtmlTag.H2] = FBTextKind.H2;
		myStyleTable[HtmlTag.H3] = FBTextKind.H3;
		myStyleTable[HtmlTag.H4] = FBTextKind.H4;
		myStyleTable[HtmlTag.H5] = FBTextKind.H5;
		myStyleTable[HtmlTag.H6] = FBTextKind.H6;
		myStyleTable[HtmlTag.B] = FBTextKind.BOLD;
		myStyleTable[HtmlTag.SUB] = FBTextKind.SUB;
		myStyleTable[HtmlTag.SUP] = FBTextKind.SUP;
		myStyleTable[HtmlTag.S] = FBTextKind.STRIKETHROUGH;
		myStyleTable[HtmlTag.PRE] = FBTextKind.PREFORMATTED;
		myStyleTable[HtmlTag.EM] = FBTextKind.EMPHASIS;
		myStyleTable[HtmlTag.DFN] = FBTextKind.DEFINITION;
		myStyleTable[HtmlTag.CITE] = FBTextKind.CITE;
		myStyleTable[HtmlTag.CODE] = FBTextKind.CODE;
		myStyleTable[HtmlTag.STRONG] = FBTextKind.STRONG;
		myStyleTable[HtmlTag.I] = FBTextKind.ITALIC;
	}

	protected final CharsetDecoder myAttributeDecoder;

	private boolean myInsideTitle = false;
	private boolean mySectionStarted = false;
	private byte myHyperlinkType;
	private final char[] SPACE = { ' ' };
	private String myHrefAttribute = ""href"";
	private boolean myOrderedListIsStarted = false;
	//private boolean myUnorderedListIsStarted = false;
	private int myOLCounter = 0;
	private byte[] myControls = new byte[10];
	private byte myControlsNumber = 0;
	
	public HtmlReader(BookModel model) throws UnsupportedEncodingException {
		super(model);
		try {	
			//String encoding = model.Book.getEncoding();
			myAttributeDecoder = createDecoder();
			setByteDecoder(createDecoder());
		} catch (UnsupportedCharsetException e) {
			throw new UnsupportedEncodingException(e.getMessage());
		}
	}

	protected final CharsetDecoder createDecoder() throws UnsupportedEncodingException {
		return Charset.forName(Model.Book.getEncoding()).newDecoder()
			.onMalformedInput(CodingErrorAction.REPLACE)
			.onUnmappableCharacter(CodingErrorAction.REPLACE);
	}

	public boolean readBook() throws IOException {
		return ZLHtmlProcessor.read(this, getInputStream());
	}

	public InputStream getInputStream() throws IOException {
		return Model.Book.File.getInputStream();
	}

	public void startDocumentHandler() {
	}

	public void endDocumentHandler() {
		unsetCurrentTextModel();
	}

	public void byteDataHandler(byte[] data, int start, int length) {
		addByteData(data, start, length);
	}

	private HashMap<String,char[]> myEntityMap;
	public void entityDataHandler(String entity) {
		if (myEntityMap == null) {
			myEntityMap = new HashMap<String,char[]>(ZLXMLProcessor.getEntityMap(XHTMLReader.xhtmlDTDs()));
		}
		char[] data = myEntityMap.get(entity);
		if (data == null) {
			if ((entity.length() > 0) && (entity.charAt(0) == '#')) {
				try {
					int number;
					if (entity.charAt(1) == 'x') {
						number = Integer.parseInt(entity.substring(2), 16);
					} else {
						number = Integer.parseInt(entity.substring(1));
					}
					data = new char[] { (char)number };
				} catch (NumberFormatException e) {
				}
			}
			if (data == null) {
				data = new char[0];
			}
			myEntityMap.put(entity, data);
		}
		addData(data);
	}

	private void openControl(byte control) {
		addControl(control, true);
		if (myControlsNumber == myControls.length) {
			myControls = ZLArrayUtils.createCopy(myControls, myControlsNumber, 2 * myControlsNumber);
		}
		myControls[myControlsNumber++] = control;
	}
	
	private void closeControl(byte control) {
		for (int i = 0; i < myControlsNumber; i++) {
			addControl(myControls[i], false);
		}
		boolean flag = false;
		int removedControl = myControlsNumber;
		for (int i = 0; i < myControlsNumber; i++) {
			if (!flag && (myControls[i] == control)) {
				flag = true;
				removedControl = i;
				continue;
			}
			addControl(myControls[i], true);
		}
		if (removedControl == myControlsNumber) {
			return;
		}
		--myControlsNumber;
		for (int i = removedControl; i < myControlsNumber; i++) {
			myControls[i] = myControls[i + 1];
		}
	}
	
	private void startNewParagraph() {
		endParagraph();
		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
	}
	
	public final void endElementHandler(String tagName) {
		endElementHandler(HtmlTag.getTagByName(tagName));
	}

	public void endElementHandler(byte tag) {
		switch (tag) {
			case HtmlTag.SCRIPT:
			case HtmlTag.SELECT:
			case HtmlTag.STYLE:
			case HtmlTag.P:
				startNewParagraph();
				break;

			case HtmlTag.H1:
			case HtmlTag.H2:
			case HtmlTag.H3:
			case HtmlTag.H4:
			case HtmlTag.H5:
			case HtmlTag.H6:
			case HtmlTag.PRE:
				closeControl(myStyleTable[tag]);
				startNewParagraph();
				break;

			case HtmlTag.A:
				closeControl(myHyperlinkType);
				break;

			case HtmlTag.BODY:
				break;

			case HtmlTag.HTML:
				//unsetCurrentTextModel();
				break;
				
			case HtmlTag.B:
			case HtmlTag.S:
			case HtmlTag.SUB:
			case HtmlTag.SUP:
			case HtmlTag.EM:
			case HtmlTag.DFN:
			case HtmlTag.CITE:
			case HtmlTag.CODE:
			case HtmlTag.STRONG:
			case HtmlTag.I:
				closeControl(myStyleTable[tag]);
				break;

			case HtmlTag.OL:
				myOrderedListIsStarted = false;
				myOLCounter = 0;
				break;
				
			case HtmlTag.UL:
				//myUnorderedListIsStarted = false;
				break;
				
			default:
				break;
		}
	}

	public final void startElementHandler(String tagName, int offset, ZLHtmlAttributeMap attributes) {
		startElementHandler(HtmlTag.getTagByName(tagName), offset, attributes);
	}

	public void startElementHandler(byte tag, int offset, ZLHtmlAttributeMap attributes) {
		switch (tag) {
			case HtmlTag.HTML:
				break;

			case HtmlTag.BODY:
				setMainTextModel();
				pushKind(FBTextKind.REGULAR);
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;

			case HtmlTag.P:
				if (mySectionStarted) {
					mySectionStarted = false;
				} else if (myInsideTitle) {
					addContentsData(SPACE);
				}
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;

			case HtmlTag.A:{
				String ref = attributes.getStringValue(myHrefAttribute, myAttributeDecoder);
				if ((ref != null) && (ref.length() != 0)) {
					if (ref.charAt(0) == '#') {
						myHyperlinkType = FBTextKind.FOOTNOTE;
						ref = ref.substring(1);
					} else if (ref.charAt(0) == '&') {
						myHyperlinkType = FBTextKind.INTERNAL_HYPERLINK;
						ref = ref.substring(1);
					} else {
						myHyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
					}
					addHyperlinkControl(myHyperlinkType, ref);
					myControls[myControlsNumber] = myHyperlinkType;
					myControlsNumber++;
				}
				break;
			}
			
			case HtmlTag.IMG: {
				/*
				String ref = attributes.getStringValue(mySrcAttribute, myAttributeDecoder);
				if ((ref != null) && (ref.length() != 0)) {
					addImageReference(ref, (short)0);
					String filePath = ref;
					if (!"":\\"".equals(ref.substring(1, 3))) {
						filePath = Model.Book.File.getPath();
						filePath = filePath.substring(0, filePath.lastIndexOf('\\') + 1) + ref;
					}
					addImage(ref, new ZLFileImage(MimeTypes.MIME_IMAGE_AUTO, ZLFile.createFileByPath(filePath)));
				}
				*/
				break;
			}
			
			case HtmlTag.B:
			case HtmlTag.S:
			case HtmlTag.SUB:
			case HtmlTag.SUP:
			case HtmlTag.PRE:
			case HtmlTag.STRONG:
			case HtmlTag.CODE:
			case HtmlTag.EM:
			case HtmlTag.CITE:
			case HtmlTag.DFN:
			case HtmlTag.I:
				openControl(myStyleTable[tag]);
				break;
				
			case HtmlTag.H1:
			case HtmlTag.H2:
			case HtmlTag.H3:
			case HtmlTag.H4:
			case HtmlTag.H5:
			case HtmlTag.H6:
				startNewParagraph();
				openControl(myStyleTable[tag]);
				break;
				
			case HtmlTag.OL:
				myOrderedListIsStarted = true;
				break;
				
			case HtmlTag.UL:
				//myUnorderedListIsStarted = true;
				break;
				
			case HtmlTag.LI:
				startNewParagraph();
				if (myOrderedListIsStarted) {
					char[] number = (new Integer(++myOLCounter)).toString().toCharArray();
					addData(number);
					addData(new char[] {'.', ' '});
				} else {
					addData(new char[] {'*', ' '});
				}
				break;
				
			case HtmlTag.SCRIPT:
			case HtmlTag.SELECT:
			case HtmlTag.STYLE:
				endParagraph();
				break;
				
			case HtmlTag.TR: 
			case HtmlTag.BR:
				startNewParagraph();
				break;
			default:
				break;
		}
	}
}
",True,140,1,1,6,45,3,13,L4
7,org.geometerplus.fbreader.formats.util.MiscUtil.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.util;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class MiscUtil {
	public static String htmlDirectoryPrefix(ZLFile file) {
		String shortName = file.getShortName();
		String path = file.getPath();
		return path.substring(0, path.length() - shortName.length());
	}

	public static String archiveEntryName(String fullPath) {
		final int index = fullPath.lastIndexOf(':');
		return (index >= 2) ? fullPath.substring(index + 1) : fullPath;
	}

	private static boolean isHexDigit(char ch) {
		return
			(ch >= '0' && ch <= '9') ||
			(ch >= 'a' && ch <= 'f') ||
			(ch >= 'A' && ch <= 'F');
	}

	public static String decodeHtmlReference(String name) {
		int index = 0;
		while (true) {
			index = name.indexOf('%', index);
			if (index == -1 || index >= name.length() - 2) {
				break;
			}
			if (isHexDigit(name.charAt(index + 1)) &&
				isHexDigit(name.charAt(index + 2))) {
				char c = 0;
				try {
					c = (char)Integer.decode(""0x"" + name.substring(index + 1, index + 3)).intValue();
				} catch (NumberFormatException e) {
				}
				name = name.substring(0, index) + c + name.substring(index + 3);
			}
			index = index + 1;
		}
		return name;
	}
}
",True,165,8,40,5,6,5,1,L4
8,org.geometerplus.fbreader.formats.oeb.OEBCoverBackgroundReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.formats.util.MiscUtil;

class OEBCoverBackgroundReader extends ZLXMLReaderAdapter implements XMLNamespaces, MimeTypes {
	private class XHTMLImageFinder extends ZLXMLReaderAdapter {
		@Override
		public boolean processNamespaces() {
			return true;
		}

		@Override
		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			tag = tag.toLowerCase();
			String href = null;
			if (""img"".equals(tag)) {
				href = attributes.getValue(""src"");
			} else if (""image"".equals(tag)) {
				href = getAttributeValue(attributes, XLink, ""href"");
			}

			if (href != null) {
				myImage = new ZLFileImage(
					MIME_IMAGE_AUTO,
					ZLFile.createFileByPath(myXHTMLPathPrefix + href)
				);
				return true;
			}

			return false;
		}
	}

	private ZLFileImage myImage;
	private String myPathPrefix;
	private String myXHTMLPathPrefix;
	private String myCoverXHTML;
	private boolean myReadGuide;

	public ZLFileImage readCover(ZLFile file) {
		myPathPrefix = MiscUtil.htmlDirectoryPrefix(file);
		myReadGuide = false;
		myImage = null;
		myCoverXHTML = null;
		read(file);
		if (myCoverXHTML != null) {
			final ZLFile coverFile = ZLFile.createFileByPath(myCoverXHTML);
			if (coverFile != null) {
				final String ext = coverFile.getExtension();
				if (""gif"".equals(ext) || ""jpg"".equals(ext) || ""jpeg"".equals(ext)) {
					myImage = new ZLFileImage(MIME_IMAGE_AUTO, coverFile);
				} else {
					myXHTMLPathPrefix = MiscUtil.htmlDirectoryPrefix(coverFile);
					new XHTMLImageFinder().read(coverFile);
				}
			}
		}
		return myImage;
	}

	private static final String GUIDE = ""guide"";
	private static final String REFERENCE = ""reference"";
	private static final String COVER = ""cover"";
	private static final String COVER_IMAGE = ""other.ms-coverimage-standard"";

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (GUIDE == tag) {
			myReadGuide = true;
		} else if (myReadGuide && REFERENCE == tag) {
			final String type = attributes.getValue(""type"");
			if (COVER == type) {
				final String href = attributes.getValue(""href"");
				if (href != null) {
					myCoverXHTML = myPathPrefix + MiscUtil.decodeHtmlReference(href);
					return true;
				}
			} else if (COVER_IMAGE == type) {
				final String href = attributes.getValue(""href"");
				if (href != null) {
					myImage = new ZLFileImage(
						MIME_IMAGE_AUTO,
						ZLFile.createFileByPath(myPathPrefix + MiscUtil.decodeHtmlReference(href))
					);
					return true;
				}
			}
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if (GUIDE == tag) {
			myReadGuide = false;
			return true;
		}
		return false;
	}
}
",True,178,13,40,5,8,1,7,L4
9,org.geometerplus.fbreader.formats.oeb.OEBPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class OEBPlugin extends FormatPlugin {
	public boolean acceptsFile(ZLFile file) {
		final String extension = file.getExtension().intern();
		return (extension == ""opf"") || (extension == ""oebzip"") || (extension == ""epub"");
	}

	private ZLFile getOpfFile(ZLFile oebFile) {
		if (oebFile.getExtension().equals(""opf"")) {
			return oebFile;
		}

		for (ZLFile child : oebFile.children()) {
			if (child.getExtension().equals(""opf"")) {
				return child;
			}
		}
		return null;
	}

	@Override
	public boolean readMetaInfo(Book book) {
		final ZLFile opfFile = getOpfFile(book.File);
		return (opfFile != null) ? new OEBMetaInfoReader(book).readMetaInfo(opfFile) : false;
	}
	
	@Override
	public boolean readModel(BookModel model) {
		model.Book.File.setCached(true);
		final ZLFile opfFile = getOpfFile(model.Book.File);
		return (opfFile != null) ? new OEBBookReader(model).readBook(opfFile) : false;
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		final ZLFile opfFile = getOpfFile(file);
		return (opfFile != null) ? new OEBCoverReader().readCover(opfFile) : null;
	}

	@Override
	public String readAnnotation(ZLFile file) {
		final ZLFile opfFile = getOpfFile(file);
		return (opfFile != null) ? new OEBAnnotationReader().readAnnotation(opfFile) : null;
	}
}
",True,139,0,0,6,35,1,9,L4
10,org.geometerplus.fbreader.formats.oeb.OEBCoverReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.image.ZLImageProxy;

class OEBCoverReader {
	private static class OEBCoverImage extends ZLImageProxy {
		private final ZLFile myFile;

		OEBCoverImage(ZLFile file) {
			myFile = file;
		}

		@Override
		public ZLSingleImage getRealImage() {
			return new OEBCoverBackgroundReader().readCover(myFile);
		}

		@Override
		public int sourceType() {
			return SourceType.DISK;
		}

		@Override
		public String getId() {
			return myFile.getPath();
		}
	}

	public ZLImageProxy readCover(ZLFile file) {
		return new OEBCoverImage(file);
	}
}
",False,182,12,40,5,12,1,4,L4
11,org.geometerplus.fbreader.formats.oeb.OEBBookReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;
import org.geometerplus.fbreader.formats.util.MiscUtil;

class Reference {
	public final String Title;
	public final String HRef;

	public Reference(String title, String href) {
		Title = title;
		HRef = href;
	}
}

class OEBBookReader extends ZLXMLReaderAdapter implements XMLNamespaces {
	private static final char[] Dots = new char[] {'.', '.', '.'};

	private final BookReader myModelReader;
	private final HashMap<String,String> myIdToHref = new HashMap<String,String>();
	private final ArrayList<String> myHtmlFileNames = new ArrayList<String>();
	private final ArrayList<Reference> myTourTOC = new ArrayList<Reference>();
	private final ArrayList<Reference> myGuideTOC = new ArrayList<Reference>();

	private String myOPFSchemePrefix;
	private String myFilePrefix;
	private String myNCXTOCFileName;

	OEBBookReader(BookModel model) {
		myModelReader = new BookReader(model);
	}

	private TreeMap<String,Integer> myFileNumbers = new TreeMap<String,Integer>();
	private TreeMap<String,Integer> myTOCLabels = new TreeMap<String,Integer>();

	boolean readBook(ZLFile file) {
		myFilePrefix = MiscUtil.htmlDirectoryPrefix(file);

		myIdToHref.clear();
		myHtmlFileNames.clear();
		myNCXTOCFileName = null;
		myTourTOC.clear();
		myGuideTOC.clear();
		myState = READ_NONE;

		if (!read(file)) {
			return false;
		}

		myModelReader.setMainTextModel();
		myModelReader.pushKind(FBTextKind.REGULAR);

		for (String name : myHtmlFileNames) {
			final ZLFile xhtmlFile = ZLFile.createFileByPath(myFilePrefix + name);
			final XHTMLReader reader = new XHTMLReader(myModelReader, myFileNumbers);
			final String referenceName = reader.getFileAlias(MiscUtil.archiveEntryName(xhtmlFile.getPath()));

			myModelReader.addHyperlinkLabel(referenceName);
			myTOCLabels.put(referenceName, myModelReader.Model.BookTextModel.getParagraphsNumber());
			reader.readFile(xhtmlFile, referenceName + '#');
			myModelReader.insertEndOfSectionParagraph();
		}

		generateTOC();

		return true;
	}

	private BookModel.Label getTOCLabel(String id) {
		final int index = id.indexOf('#');
		final String path = (index >= 0) ? id.substring(0, index) : id;
		Integer num = myFileNumbers.get(path);
		if (num == null) {
			return null;
		}
		if (index == -1) {
			final Integer para = myTOCLabels.get(num.toString());
			if (para == null) {
				return null;
			}
			return new BookModel.Label(null, para);
		}
		return myModelReader.Model.getLabel(num + id.substring(index));
	}

	private void generateTOC() {
		if (myNCXTOCFileName != null) {
			final NCXReader ncxReader = new NCXReader(myModelReader);
			if (ncxReader.readFile(myFilePrefix + myNCXTOCFileName)) {
				final Map<Integer,NCXReader.NavPoint> navigationMap = ncxReader.navigationMap();
				if (!navigationMap.isEmpty()) {
					int level = 0;
					for (NCXReader.NavPoint point : navigationMap.values()) {
						final BookModel.Label label = getTOCLabel(point.ContentHRef);
						int index = (label != null) ? label.ParagraphIndex : -1;
						while (level > point.Level) {
							myModelReader.endContentsParagraph();
							--level;
						}
						while (++level <= point.Level) {
							myModelReader.beginContentsParagraph(-2);
							myModelReader.addContentsData(Dots);
						}
						myModelReader.beginContentsParagraph(index);
						myModelReader.addContentsData(point.Text.toCharArray());
					}
					while (level > 0) {
						myModelReader.endContentsParagraph();
						--level;
					}
					return;
				}
			}
		}

		for (Reference ref : myTourTOC.isEmpty() ? myGuideTOC : myTourTOC) {
			final BookModel.Label label = getTOCLabel(ref.HRef);
			if (label != null) {
				final int index = label.ParagraphIndex;
				if (index != -1) {
					myModelReader.beginContentsParagraph(index);
					myModelReader.addContentsData(ref.Title.toCharArray());
					myModelReader.endContentsParagraph();
				}
			}
		}
	}

	private static final String MANIFEST = ""manifest"";
	private static final String SPINE = ""spine"";
	private static final String GUIDE = ""guide"";
	private static final String TOUR = ""tour"";
	private static final String SITE = ""site"";
	private static final String REFERENCE = ""reference"";
	private static final String ITEMREF = ""itemref"";
	private static final String ITEM = ""item"";

	private static final String COVER_IMAGE = ""other.ms-coverimage-standard"";

	private static final int READ_NONE = 0;
	private static final int READ_MANIFEST = 1;
	private static final int READ_SPINE = 2;
	private static final int READ_GUIDE = 3;
	private static final int READ_TOUR = 4;
	
	private int myState;

	@Override
	public boolean startElementHandler(String tag, ZLStringMap xmlattributes) {
		tag = tag.toLowerCase();
		if ((myOPFSchemePrefix != null) && tag.startsWith(myOPFSchemePrefix)) {
			tag = tag.substring(myOPFSchemePrefix.length());
		}
		tag = tag.intern();
		if (MANIFEST == tag) {
			myState = READ_MANIFEST;
		} else if (SPINE == tag) {
			myNCXTOCFileName = myIdToHref.get(xmlattributes.getValue(""toc""));
			myState = READ_SPINE;
		} else if (GUIDE == tag) {
			myState = READ_GUIDE;
		} else if (TOUR == tag) {
			myState = READ_TOUR;
		} else if ((myState == READ_MANIFEST) && (ITEM == tag)) {
			final String id = xmlattributes.getValue(""id"");
			String href = xmlattributes.getValue(""href"");
			if ((id != null) && (href != null)) {
				href = MiscUtil.decodeHtmlReference(href);
				myIdToHref.put(id, href);
			}
		} else if ((myState == READ_SPINE) && (ITEMREF == tag)) {
			final String id = xmlattributes.getValue(""idref"");
			if (id != null) {
				final String fileName = myIdToHref.get(id);
				if (fileName != null) {
					myHtmlFileNames.add(fileName);
				}
			}
		} else if ((myState == READ_GUIDE) && (REFERENCE == tag)) {
			final String type = xmlattributes.getValue(""type"");
			final String title = xmlattributes.getValue(""title"");
			String href = xmlattributes.getValue(""href"");
			if (href != null) {
				href = MiscUtil.decodeHtmlReference(href);
				if (title != null) {
					myGuideTOC.add(new Reference(title, href));
				}
				if ((type != null) && (COVER_IMAGE.equals(type))) {
					myModelReader.setMainTextModel();
					final ZLFile imageFile = ZLFile.createFileByPath(myFilePrefix + href);
					final String imageName = imageFile.getLongName();
					myModelReader.addImageReference(imageName, (short)0);
					myModelReader.addImage(imageName, new ZLFileImage(MimeTypes.MIME_IMAGE_AUTO, imageFile));
				}
			}
		} else if ((myState == READ_TOUR) && (SITE == tag)) {
			final String title = xmlattributes.getValue(""title"");
			String href = xmlattributes.getValue(""href"");
			if ((title != null) && (href != null)) {
				href = MiscUtil.decodeHtmlReference(href);
				myTourTOC.add(new Reference(title, href));
			}
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if ((myOPFSchemePrefix != null) && tag.startsWith(myOPFSchemePrefix)) {
			tag = tag.substring(myOPFSchemePrefix.length());
		}
		tag = tag.intern();
		if ((MANIFEST == tag) || (SPINE == tag) || (GUIDE == tag) || (TOUR == tag)) {
			myState = READ_NONE;
		}
		return false;
	}

	@Override
	public boolean processNamespaces() {
		return true;
	}

	@Override
	public void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myOPFSchemePrefix = null;
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			if (OpenPackagingFormat.equals(entry.getValue())) {
				myOPFSchemePrefix = entry.getKey() + "":"";
				break;
			}
		}
	}

	@Override
	public boolean dontCacheAttributeValues() {
		return true;
	}
}
",True,139,0,0,7,33,1,13,L4
12,org.geometerplus.fbreader.formats.oeb.OEBAnnotationReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

class OEBAnnotationReader extends ZLXMLReaderAdapter implements XMLNamespaces {
	private String myDescriptionTag;
	
	private static final int READ_NONE = 0;
	private static final int READ_DESCRIPTION = 1;
	private int myReadState;

	private final StringBuffer myBuffer = new StringBuffer();

	String readAnnotation(ZLFile file) {
		myReadState = READ_NONE;
		myBuffer.delete(0, myBuffer.length());

		if (ZLXMLProcessor.read(this, file, 512)) {
			final int len = myBuffer.length();
			if (len > 1) {
				if (myBuffer.charAt(len - 1) == '\n') {
					myBuffer.delete(len - 1, len);
				}
				return myBuffer.toString();
			}
		}
		return null;
	}

	@Override
	public boolean processNamespaces() {
		return true;
	}

	@Override
	public void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myDescriptionTag = null;
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String id = entry.getValue();
			if (id.startsWith(DublinCorePrefix) || id.startsWith(DublinCoreLegacyPrefix)) {
				myDescriptionTag = entry.getKey() + "":description"";
			}
		}
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		if (tag.equalsIgnoreCase(myDescriptionTag)) {
			myReadState = READ_DESCRIPTION;
		} else if (myReadState == READ_DESCRIPTION) {
			// TODO: process tags
			myBuffer.append("" "");
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int len) {
		if (myReadState == READ_DESCRIPTION) {
			myBuffer.append(new String(data, start, len).trim());
		}
	}

	@Override
	public boolean endElementHandler(String tag) {
		if (myReadState != READ_DESCRIPTION) {
			return false;
		}
		tag = tag.toLowerCase();
		if (tag.equalsIgnoreCase(myDescriptionTag)) {
			return true;
		}
		// TODO: process tags
		myBuffer.append("" "");
		return false;
	}
}
",False,172,12,40,5,7,1,5,L4
13,org.geometerplus.fbreader.formats.oeb.NCXReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.filesystem.ZLArchiveEntryFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.util.MiscUtil;

class NCXReader extends ZLXMLReaderAdapter {
	static class NavPoint {
		final int Order;
		final int Level;
		String Text = """";
		String ContentHRef = """";

		NavPoint(int order, int level) {
			Order = order;
			Level = level;
		}
	}

	private final TreeMap<Integer,NavPoint> myNavigationMap = new TreeMap<Integer,NavPoint>();
	private final ArrayList<NavPoint> myPointStack = new ArrayList<NavPoint>();

	private static final int READ_NONE = 0;
	private static final int READ_MAP = 1;
	private static final int READ_POINT = 2;
	private static final int READ_LABEL = 3;
	private static final int READ_TEXT = 4;

	int myReadState = READ_NONE;
	int myPlayIndex = -65535;
	private String myLocalPathPrefix;

	NCXReader(BookReader modelReader) {
	}

	boolean readFile(String filePath) {
		final ZLFile file = ZLFile.createFileByPath(filePath);
		myLocalPathPrefix = MiscUtil.archiveEntryName(MiscUtil.htmlDirectoryPrefix(file));
		return read(file);
	}

	Map<Integer,NavPoint> navigationMap() {
		return myNavigationMap;
	}

	private static final String TAG_NAVMAP = ""navmap"";
	private static final String TAG_NAVPOINT = ""navpoint"";
	private static final String TAG_NAVLABEL = ""navlabel"";
	private static final String TAG_CONTENT = ""content"";
	private static final String TAG_TEXT = ""text"";

	private static final String ATTRIBUTE_PLAYORDER = ""playOrder"";

	private int atoi(String number) {
		try {
			return Integer.parseInt(number);
		} catch (NumberFormatException e) {
			return 0;
		}
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		switch (myReadState) {
			case READ_NONE:
				if (tag == TAG_NAVMAP) {
					myReadState = READ_MAP;
				}
				break;
			case READ_MAP:
				if (tag == TAG_NAVPOINT) {
					final String order = attributes.getValue(ATTRIBUTE_PLAYORDER);
					final int index = (order != null) ? atoi(order) : myPlayIndex++;
					myPointStack.add(new NavPoint(index, myPointStack.size()));
					myReadState = READ_POINT;
				}
				break;
			case READ_POINT:
				if (tag == TAG_NAVPOINT) {
					final String order = attributes.getValue(ATTRIBUTE_PLAYORDER);
					final int index = (order != null) ? atoi(order) : myPlayIndex++;
					myPointStack.add(new NavPoint(index, myPointStack.size()));
				} else if (tag == TAG_NAVLABEL) {
					myReadState = READ_LABEL;
				} else if (tag == TAG_CONTENT) {
					final int size = myPointStack.size();
					if (size > 0) {
						myPointStack.get(size - 1).ContentHRef =
							ZLArchiveEntryFile.normalizeEntryName(
								myLocalPathPrefix + attributes.getValue(""src"")
							);
					}
				}
				break;
			case READ_LABEL:
				if (TAG_TEXT == tag) {
					myReadState = READ_TEXT;
				}
				break;
			case READ_TEXT:
				break;
		}
		return false;
	}
	
	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase().intern();
		switch (myReadState) {
			case READ_NONE:
				break;
			case READ_MAP:
				if (TAG_NAVMAP == tag) {
					myReadState = READ_NONE;
				}
				break;
			case READ_POINT:
				if (TAG_NAVPOINT == tag) {
					NavPoint last = myPointStack.get(myPointStack.size() - 1);
					if (last.Text.length() == 0) {
						last.Text = ""..."";
					}
					myNavigationMap.put(last.Order, last);
					myPointStack.remove(myPointStack.size() - 1);
					myReadState = (myPointStack.isEmpty()) ? READ_MAP : READ_POINT;
				}
			case READ_LABEL:
				if (TAG_NAVLABEL == tag) {
					myReadState = READ_POINT;
				}
				break;
			case READ_TEXT:
				if (TAG_TEXT == tag) {
					myReadState = READ_LABEL;
				}
				break;
		}
		return false;
	}
	
	@Override
	public void characterDataHandler(char[] ch, int start, int length) {
		if (myReadState == READ_TEXT) {
			final ArrayList<NavPoint> stack = myPointStack;
			final NavPoint last = stack.get(stack.size() - 1);
			last.Text += new String(ch, start, length);
		}
	}

	@Override
	public boolean dontCacheAttributeValues() {
		return true;
	}
}
",True,139,0,0,8,30,1,6,L4
14,org.geometerplus.fbreader.formats.oeb.OEBMetaInfoReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.oeb;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;

class OEBMetaInfoReader extends ZLXMLReaderAdapter implements XMLNamespaces {
	private final Book myBook;

	private String myDCMetadataTag = ""dc-metadata"";
	private String myMetadataTag = ""metadata"";
	private String myOpfMetadataTag = ""metadata"";
	private String myMetadataTagRealName;
	private String myTitleTag;
	private String myAuthorTag;
	private String mySubjectTag;
	private String myLanguageTag;
	private String myMetaTag = ""meta"";

	private String mySeriesTitle = """";
	private int mySeriesIndex = 0;
	
	private final ArrayList<String> myAuthorList = new ArrayList<String>();
	private final ArrayList<String> myAuthorList2 = new ArrayList<String>();

	OEBMetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle(null);
		myBook.setLanguage(null);
	}

	boolean readMetaInfo(ZLFile file) {
		myReadMetaData = false;
		myReadState = READ_NONE;

		if (!ZLXMLProcessor.read(this, file, 512)) {
			return false;
		}

		final ArrayList<String> authors = myAuthorList.isEmpty() ? myAuthorList2 : myAuthorList;
		for (String a : authors) {
			final int index = a.indexOf(',');
			if (index >= 0) {
				a = a.substring(index + 1).trim() + ' ' + a.substring(0, index).trim();
			} else {
				a = a.trim();
			}
			myBook.addAuthor(a);
		}

		return true;
	}

	private static final int READ_NONE = 0;
	private static final int READ_AUTHOR = 1;
	private static final int READ_AUTHOR2 = 2;
	private static final int READ_TITLE = 3;
	private static final int READ_SUBJECT = 4;
	private static final int READ_LANGUAGE = 5;
	private int myReadState;
	private boolean myReadMetaData;

	private final StringBuffer myBuffer = new StringBuffer();

	@Override
	public boolean processNamespaces() {
		return true;
	}

	@Override
	public void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myTitleTag = null;
		myAuthorTag = null;
		mySubjectTag = null;
		myLanguageTag = null;
		myOpfMetadataTag = ""metadata"";
		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String id = entry.getValue();
			if (id.startsWith(DublinCorePrefix) || id.startsWith(DublinCoreLegacyPrefix)) {
				final String name = entry.getKey();
				myTitleTag = (name + "":title"").intern();
				myAuthorTag = (name + "":creator"").intern();
				mySubjectTag = (name + "":subject"").intern();
				myLanguageTag = (name + "":language"").intern();
			} else if (id.equals(OpenPackagingFormat)) {
				final String name = entry.getKey();
				myOpfMetadataTag = (name + "":metadata"").intern();
			}
		}
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (tag == myMetadataTag || tag == myDCMetadataTag || tag == myOpfMetadataTag) {
			myMetadataTagRealName = tag;
			myReadMetaData = true;
		} else if (myReadMetaData) {
			if (tag == myTitleTag) {
				myReadState = READ_TITLE;
			} else if (tag == myAuthorTag) {
				final String role = attributes.getValue(""role"");
				if (role == null) {
					myReadState = READ_AUTHOR2;
				} else if (role.equals(""aut"")) {
					myReadState = READ_AUTHOR;
				}
			} else if (tag == mySubjectTag) {
				myReadState = READ_SUBJECT;
			} else if (tag == myLanguageTag) {
				myReadState = READ_LANGUAGE;
			} else if (tag == myMetaTag) {
				if (attributes.getValue(""name"").equals(""calibre:series"")) {
					mySeriesTitle = attributes.getValue(""content"");
				} else if (attributes.getValue(""name"").equals(""calibre:series_index"")) {
					final String strIndex = attributes.getValue(""content"");
					try {
						mySeriesIndex = Integer.parseInt(strIndex);
					} catch (NumberFormatException e) {
					}
				}
			}
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int len) {
		switch (myReadState) {
			case READ_NONE:
				break;
			case READ_AUTHOR:
			case READ_AUTHOR2:
			case READ_TITLE:
			case READ_SUBJECT:
			case READ_LANGUAGE:
				myBuffer.append(data, start, len);
				break;
		}
	}

	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.toLowerCase();
		if (tag.equals(myMetadataTagRealName)) {
			return true;
		}

		String bufferContent = myBuffer.toString().trim();
		if (bufferContent.length() != 0) {
			switch (myReadState) {
				case READ_TITLE:
					myBook.setTitle(bufferContent);
					break;
				case READ_AUTHOR:
					myAuthorList.add(bufferContent);
					break;
				case READ_AUTHOR2:
					myAuthorList2.add(bufferContent);
					break;
				case READ_SUBJECT:
					myBook.addTag(bufferContent);
					break;
				case READ_LANGUAGE:
					{
						int index = bufferContent.indexOf('_');
						if (index >= 0) {
							bufferContent = bufferContent.substring(0, index);
						}
						index = bufferContent.indexOf('-');
						if (index >= 0) {
							bufferContent = bufferContent.substring(0, index);
						}
						myBook.setLanguage(""cz"".equals(bufferContent) ? ""cs"" : bufferContent);
					}
					break;
			}
		} else {
			if (tag.equals(myMetaTag)) {
				if (!mySeriesTitle.equals("""") && mySeriesIndex > 0) {
					myBook.setSeriesInfo(mySeriesTitle, mySeriesIndex);
				}
			}
		}
		myBuffer.delete(0, myBuffer.length());
		myReadState = READ_NONE;
		return false;
	}
}
",True,139,0,0,6,37,1,6,L4
15,org.geometerplus.fbreader.formats.fb2.FB2AnnotationReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

public class FB2AnnotationReader extends ZLXMLReaderAdapter {
	private final static int READ_NOTHING = 0;
	private final static int READ_ANNOTATION = 1;

	private int myReadState = READ_NOTHING;
	private final StringBuilder myBuffer = new StringBuilder();

	public FB2AnnotationReader() {
	}
	
	public boolean dontCacheAttributeValues() {
		return true;
	}
	
	public String readAnnotation(ZLFile file) {
		myReadState = READ_NOTHING;
		myBuffer.delete(0, myBuffer.length());
		if (readDocument(file)) {
			final int len = myBuffer.length();
			if (len > 1) {
				if (myBuffer.charAt(len - 1) == '\n') {
					myBuffer.delete(len - 1, len);
				}
				return myBuffer.toString();
			}
		}
		return null;
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (FB2Tag.getTagByName(tagName)) {
			case FB2Tag.BODY:
				return true;
			case FB2Tag.ANNOTATION:
				myReadState = READ_ANNOTATION;
				break;
			default:
				if (myReadState == READ_ANNOTATION) {
					// TODO: add tag to buffer
					myBuffer.append("" "");
				}
				break;
		}
		return false;
	}
	
	public boolean endElementHandler(String tag) {
		if (myReadState != READ_ANNOTATION) {
			return false;
		}
		switch (FB2Tag.getTagByName(tag)) {
			case FB2Tag.ANNOTATION:
				return true;
			case FB2Tag.P:
				myBuffer.append(""\n"");
				break;
			default:
				// TODO: add tag to buffer
				myBuffer.append("" "");
				break;
		}
		return false;
	}
	
	public void characterDataHandler(char[] data, int start, int length) {
		if (myReadState == READ_ANNOTATION) {
			myBuffer.append(new String(data, start, length).trim());
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file, 512);
	}
}
",False,172,12,40,5,7,1,5,L4
16,org.geometerplus.fbreader.formats.fb2.Base64EncodedImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.io.*;

import org.geometerplus.zlibrary.core.image.ZLBase64EncodedImage;

import org.geometerplus.fbreader.Paths;

final class Base64EncodedImage extends ZLBase64EncodedImage {
	private static int ourCounter;

	static void resetCounter() {
		ourCounter = 0;
	}

	private final String myDirName;
	private final int myFileNumber;
	private OutputStreamWriter myStreamWriter;
	
	public Base64EncodedImage(String contentType) {
		// TODO: use contentType
		super(contentType);
		myDirName = Paths.cacheDirectory();
		new File(myDirName).mkdirs();
		myFileNumber = ourCounter++;
		try {
			myStreamWriter = new OutputStreamWriter(new FileOutputStream(encodedFileName()), ""UTF-8"");
		} catch (IOException e) {
		}
	}

	@Override
	protected String encodedFileName() {
		return myDirName + ""/image"" + myFileNumber;
	}

	@Override
	protected String decodedFileName() {
		return myDirName + ""/dimage"" + myFileNumber;
	}

	void addData(char[] data, int offset, int length) {
		if (myStreamWriter != null) {
			try {
				myStreamWriter.write(data, offset, length);
			} catch (IOException e) {
			}
		}
	}

	void close() {
		try {
			if (myStreamWriter != null) {
				myStreamWriter.close();
			}
		} catch (IOException e) {
		}
	}
}
",True,155,13,40,4,2,2,2,L4
17,org.geometerplus.fbreader.formats.fb2.FB2Tag.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

final class FB2Tag {
	public static final byte UNKNOWN = 0;
	public static final byte P = 1;
	public static final byte V = 2;
	public static final byte SUBTITLE = 3;
	public static final byte TEXT_AUTHOR = 4;
	public static final byte DATE = 5;
	public static final byte CITE = 6;
	public static final byte SECTION = 7;
	public static final byte POEM = 8;
	public static final byte STANZA = 9;
	public static final byte EPIGRAPH = 10;
	public static final byte ANNOTATION = 11;
	public static final byte COVERPAGE = 12;
	public static final byte A = 13;
	public static final byte EMPTY_LINE = 14;
	public static final byte SUP = 15;
	public static final byte SUB = 16;
	public static final byte EMPHASIS = 17;
	public static final byte STRONG = 18;
	public static final byte CODE = 19;
	public static final byte STRIKETHROUGH = 20;
	public static final byte TITLE = 21;
	public static final byte BODY = 22;
	public static final byte IMAGE = 23;
	public static final byte BINARY = 24;
	public static final byte FICTIONBOOK = 25;
	
	public static final byte TITLE_INFO = 26;
	public static final byte BOOK_TITLE = 27;
	public static final byte AUTHOR = 28;
	public static final byte LANG = 29;
	public static final byte FIRST_NAME = 30;
	public static final byte MIDDLE_NAME = 31;
	public static final byte LAST_NAME = 32;
	public static final byte SEQUENCE = 33;
	public static final byte GENRE = 34;

	public static final byte DESCRIPTION = 35;


	private static final HashMap<String, Byte> ourTagByName = new HashMap<String, Byte>(256, 0.2f);
	private static final Byte ourUnknownTag;

	static {	
		ourTagByName.put(""unknown"", UNKNOWN);
		ourUnknownTag = (Byte)ourTagByName.get(""unknown"");
		ourTagByName.put(""p"", P);
		ourTagByName.put(""v"", V);
		ourTagByName.put(""subtitle"", SUBTITLE);
		ourTagByName.put(""text-author"", TEXT_AUTHOR);
		ourTagByName.put(""date"", DATE);
		ourTagByName.put(""cite"", CITE);
		ourTagByName.put(""section"", SECTION);
		ourTagByName.put(""poem"", POEM);
		ourTagByName.put(""stanza"", STANZA);
		ourTagByName.put(""epigraph"", EPIGRAPH);
		ourTagByName.put(""annotation"", ANNOTATION);
		ourTagByName.put(""coverpage"", COVERPAGE);
		ourTagByName.put(""a"", A);
		ourTagByName.put(""empty-line"", EMPTY_LINE);
		ourTagByName.put(""sup"", SUP);
		ourTagByName.put(""sub"", SUB);
		ourTagByName.put(""emphasis"", EMPHASIS);
		ourTagByName.put(""strong"", STRONG);
		ourTagByName.put(""code"", CODE);
		ourTagByName.put(""strikethrough"", STRIKETHROUGH);
		ourTagByName.put(""title"", TITLE);
		ourTagByName.put(""title-info"", TITLE_INFO);
		ourTagByName.put(""body"", BODY);
		ourTagByName.put(""image"", IMAGE);
		ourTagByName.put(""binary"", BINARY);
		ourTagByName.put(""fictionbook"", FICTIONBOOK);
		ourTagByName.put(""book-title"", BOOK_TITLE);
		ourTagByName.put(""sequence"", SEQUENCE);
		ourTagByName.put(""first-name"", FIRST_NAME);
		ourTagByName.put(""middle-name"", MIDDLE_NAME);
		ourTagByName.put(""last-name"", LAST_NAME);
		ourTagByName.put(""book-title"", BOOK_TITLE);
		ourTagByName.put(""author"", AUTHOR);
		ourTagByName.put(""lang"", LANG);
		ourTagByName.put(""genre"", GENRE);
		ourTagByName.put(""description"", DESCRIPTION);
	}

	public static byte getTagByName(String name) {
		final HashMap<String,Byte> tagByName = ourTagByName;
		Byte num = tagByName.get(name);
		if (num == null) {
			final String upperCaseName = name.toLowerCase().intern();
			num = (Byte)tagByName.get(upperCaseName);
			if (num == null) {
				num = ourUnknownTag;
				tagByName.put(upperCaseName, num);
			}
			tagByName.put(name, num);
		}
		return num.byteValue();
	}

	private FB2Tag() {
	}
}
",False,149,13,40,0,0,4,0,L4
18,org.geometerplus.fbreader.formats.fb2.FB2MetaInfoReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Tag;

public class FB2MetaInfoReader extends ZLXMLReaderAdapter {
	private final static int READ_NOTHING = 0;
	private final static int READ_SOMETHING = 1;
	private final static int READ_TITLE = 2;
	private final static int READ_AUTHOR = 3;
	private final static int READ_AUTHOR_NAME_0 = 4;
	private final static int READ_AUTHOR_NAME_1 = 5;
	private final static int READ_AUTHOR_NAME_2 = 6;
	private final static int READ_LANGUAGE = 7;
	private final static int READ_GENRE = 8;

	private final Book myBook;
	private int myReadState = READ_NOTHING;

	private	final String[] myAuthorNames = new String[3];
	private final StringBuilder myBuffer = new StringBuilder();

	public FB2MetaInfoReader(Book book) {
		myBook = book;
		myBook.setTitle(null);
		myBook.setLanguage(null);
	}
	
	public boolean dontCacheAttributeValues() {
		return true;
	}
	
	public boolean readMetaInfo() {
		myReadState = READ_NOTHING;
		myAuthorNames[0] = """";
		myAuthorNames[1] = """";
		myAuthorNames[2] = """";
		myBuffer.delete(0, myBuffer.length());
		return readDocument(myBook.File);
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		switch (FB2Tag.getTagByName(tagName)) {
			case FB2Tag.BODY:
				return true;
			case FB2Tag.TITLE_INFO:
				myReadState = READ_SOMETHING;
				break;
			case FB2Tag.BOOK_TITLE:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_TITLE;
				}
				break;
			case FB2Tag.GENRE:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_GENRE;
				}
				break;
			case FB2Tag.AUTHOR:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.LANG:
				if (myReadState == READ_SOMETHING) {
					myReadState = READ_LANGUAGE;
				}
				break;
			case FB2Tag.FIRST_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_0;
				}
				break;
			case FB2Tag.MIDDLE_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_1;
				}
				break;
			case FB2Tag.LAST_NAME:
				if (myReadState == READ_AUTHOR) {
					myReadState = READ_AUTHOR_NAME_2;
				}
				break;
			case FB2Tag.SEQUENCE:
				if (myReadState == READ_SOMETHING) {
					String name = attributes.getValue(""name"");
					if (name != null) {
						name.trim();
						if (name.length() != 0) {
							int index = 0;
							try {
								final String sIndex = attributes.getValue(""number"");
								if (sIndex != null) {
									index = Integer.parseInt(sIndex);
								}
							} catch (NumberFormatException e) {
							}
							myBook.setSeriesInfo(name, index);
						}
					}
				}
				break;
		}
		return false;
	}
	
	public boolean endElementHandler(String tag) {
		switch (FB2Tag.getTagByName(tag)) {
			case FB2Tag.TITLE_INFO:
				myReadState = READ_NOTHING;
				break;
			case FB2Tag.BOOK_TITLE:
				if (myReadState == READ_TITLE) {
					myBook.setTitle(myBuffer.toString().trim());
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.GENRE:
				if (myReadState == READ_GENRE) {
					final String genre = myBuffer.toString().trim();
					if (genre.length() > 0) {
						final ArrayList<Tag> tags = FB2TagManager.humanReadableTags(genre);
						if (tags != null) {
							for (Tag t : tags) {
								myBook.addTag(t);
							}
						} else {
							myBook.addTag(genre);
						}
					}
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.AUTHOR:
				if (myReadState == READ_AUTHOR) {
					myAuthorNames[0] = myAuthorNames[0].trim();
					myAuthorNames[1] = myAuthorNames[1].trim();
					myAuthorNames[2] = myAuthorNames[2].trim();
					String fullName = myAuthorNames[0];
					if (fullName.length() != 0 && myAuthorNames[1].length() != 0) {
						fullName += ' ';
					}
					fullName += myAuthorNames[1];
					if (fullName.length() != 0 && myAuthorNames[2].length() != 0) {
						fullName += ' ';
					}
					fullName += myAuthorNames[2];
					myBook.addAuthor(fullName, myAuthorNames[2]);
					myAuthorNames[0] = """";
					myAuthorNames[1] = """";
					myAuthorNames[2] = """";
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.LANG:
				if (myReadState == READ_LANGUAGE) {
					myBook.setLanguage(myBuffer.toString().trim());
					myReadState = READ_SOMETHING;
				}
				break;
			case FB2Tag.FIRST_NAME:
				if (myReadState == READ_AUTHOR_NAME_0) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.MIDDLE_NAME:
				if (myReadState == READ_AUTHOR_NAME_1) {
					myReadState = READ_AUTHOR;
				}
				break;
			case FB2Tag.LAST_NAME:
				if (myReadState == READ_AUTHOR_NAME_2) {
					myReadState = READ_AUTHOR;
				}
				break;
			default:
				break;
		}	
		myBuffer.delete(0, myBuffer.length());
		return false;
	}
	
	public void characterDataHandler(char[] data, int start, int length) {
		switch (myReadState) {
			case READ_AUTHOR_NAME_0:
				myAuthorNames[0] += new String(data, start, length);
				break;
			case READ_AUTHOR_NAME_1:
				myAuthorNames[1] += new String(data, start, length);
				break;
			case READ_AUTHOR_NAME_2:
				myAuthorNames[2] += new String(data, start, length);
				break;
			case READ_TITLE:
			case READ_LANGUAGE:
			case READ_GENRE:
				myBuffer.append(data, start, length);
				break;
		}
	}

	public boolean readDocument(ZLFile file) {
		return ZLXMLProcessor.read(this, file, 512);
	}
}
",True,139,0,0,6,36,1,8,L4
19,org.geometerplus.fbreader.formats.fb2.FB2Reader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.util.*;
import org.geometerplus.zlibrary.text.model.ZLTextParagraph;

import org.geometerplus.fbreader.bookmodel.*;

public final class FB2Reader extends ZLXMLReaderAdapter {
	private final BookReader myBookReader;

	private boolean myInsidePoem = false;
	private boolean myInsideTitle = false;
	private int myBodyCounter = 0;
	private boolean myReadMainText = false;
	private int mySectionDepth = 0;
	private boolean mySectionStarted = false;
	
	private byte myHyperlinkType;
	
	private Base64EncodedImage myCurrentImage;
	private boolean myInsideCoverpage = false;
	private String myCoverImageReference;
	private int myParagraphsBeforeBodyNumber = Integer.MAX_VALUE;

	private final char[] SPACE = { ' ' }; 

	private byte[] myTagStack = new byte[10];
	private int myTagStackSize = 0;

	public FB2Reader(BookModel model) {
 		myBookReader = new BookReader(model);
	}

	boolean readBook() {
		Base64EncodedImage.resetCounter();
		return ZLXMLProcessor.read(this, myBookReader.Model.Book.File);
	}

	public void startDocumentHandler() {
	}

	public void endDocumentHandler() {
	}

	public boolean dontCacheAttributeValues() {
		return true;
	}

	public void characterDataHandler(char[] ch, int start, int length) {
		if (length == 0) {
			return;
		}
		final Base64EncodedImage image = myCurrentImage;
		if (image != null) {
			image.addData(ch, start, length);
		} else {
			myBookReader.addData(ch, start, length, false);
		}		
	}

	public void characterDataHandlerFinal(char[] ch, int start, int length) {
		if (length == 0) {
			return;
		}
		final Base64EncodedImage image = myCurrentImage;
		if (image != null) {
			image.addData(ch, start, length);
		} else {
			myBookReader.addData(ch, start, length, true);
		}		
	}

	public boolean endElementHandler(String tagName) {
		final byte tag = myTagStack[--myTagStackSize];
		switch (tag) {
			case FB2Tag.P:
				myBookReader.endParagraph();		
				break;
			case FB2Tag.SUB:
				myBookReader.addControl(FBTextKind.SUB, false);
				break;
			case FB2Tag.SUP:
				myBookReader.addControl(FBTextKind.SUP, false);
				break;
			case FB2Tag.CODE:
				myBookReader.addControl(FBTextKind.CODE, false);
				break;
			case FB2Tag.EMPHASIS:
				myBookReader.addControl(FBTextKind.EMPHASIS, false);
				break;
			case FB2Tag.STRONG:
				myBookReader.addControl(FBTextKind.STRONG, false);
				break;
			case FB2Tag.STRIKETHROUGH:
				myBookReader.addControl(FBTextKind.STRIKETHROUGH, false);
				break;
			
			case FB2Tag.V:
			case FB2Tag.SUBTITLE:
			case FB2Tag.TEXT_AUTHOR:
			case FB2Tag.DATE:
				myBookReader.popKind();
				myBookReader.endParagraph();
				break;	
			
			case FB2Tag.CITE:
			case FB2Tag.EPIGRAPH:
				myBookReader.popKind();
				break;	
			
			case FB2Tag.POEM:
				myInsidePoem = false;
				break;
			
			case FB2Tag.STANZA:
				myBookReader.beginParagraph(ZLTextParagraph.Kind.AFTER_SKIP_PARAGRAPH);
				myBookReader.endParagraph();
				myBookReader.beginParagraph(ZLTextParagraph.Kind.EMPTY_LINE_PARAGRAPH);
				myBookReader.endParagraph();
				myBookReader.popKind();
				break;
				
			case FB2Tag.SECTION:
				if (myReadMainText) {
					myBookReader.endContentsParagraph();
					--mySectionDepth;
					mySectionStarted = false;
				} else {
					myBookReader.unsetCurrentTextModel();
				}
				break;
			
			case FB2Tag.ANNOTATION:
				myBookReader.popKind();
				if (myBodyCounter == 0) {
					myBookReader.insertEndOfSectionParagraph();
					myBookReader.unsetCurrentTextModel();
				}
				break;
			
			case FB2Tag.TITLE:
				myBookReader.popKind();
				myBookReader.exitTitle();
				myInsideTitle = false;
				break;
				
			case FB2Tag.BODY:
				myBookReader.popKind();
				myReadMainText = false;
				myBookReader.unsetCurrentTextModel();
				break;
			
			case FB2Tag.A:
				myBookReader.addControl(myHyperlinkType, false);
				break;
			
			case FB2Tag.COVERPAGE:
				if (myBodyCounter == 0) {
					myInsideCoverpage = false;
					myBookReader.insertEndOfSectionParagraph();
					myBookReader.unsetCurrentTextModel();
				}
				break;	
			
			case FB2Tag.BINARY:
				if (myCurrentImage != null) {
					myCurrentImage.close();
					myCurrentImage = null;
				}
				break;	
				
			default:
				break;
		}		
		return false;
	}

	public boolean startElementHandler(String tagName, ZLStringMap attributes) {
		String id = attributes.getValue(""id"");
		if (id != null) {
			if (!myReadMainText) {
				myBookReader.setFootnoteTextModel(id);
			}
			myBookReader.addHyperlinkLabel(id);
		}
		final byte tag = FB2Tag.getTagByName(tagName);
		byte[] tagStack = myTagStack;
		if (tagStack.length == myTagStackSize) {
			tagStack = ZLArrayUtils.createCopy(tagStack, myTagStackSize, myTagStackSize * 2);
			myTagStack = tagStack;
		}
		tagStack[myTagStackSize++] = tag;
		switch (tag) {
			case FB2Tag.P:
				if (mySectionStarted) {
					mySectionStarted = false;
				} else if (myInsideTitle) {
					myBookReader.addContentsData(SPACE);
				}
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			
			case FB2Tag.SUB:
				myBookReader.addControl(FBTextKind.SUB, true);
				break;
			case FB2Tag.SUP:
				myBookReader.addControl(FBTextKind.SUP, true);
				break;
			case FB2Tag.CODE:
				myBookReader.addControl(FBTextKind.CODE, true);
				break;
			case FB2Tag.EMPHASIS:
				myBookReader.addControl(FBTextKind.EMPHASIS, true);
				break;
			case FB2Tag.STRONG:
				myBookReader.addControl(FBTextKind.STRONG, true);
				break;
			case FB2Tag.STRIKETHROUGH:
				myBookReader.addControl(FBTextKind.STRIKETHROUGH, true);
				break;
			
			case FB2Tag.V:
				myBookReader.pushKind(FBTextKind.VERSE);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
				
			case FB2Tag.TEXT_AUTHOR:
				myBookReader.pushKind(FBTextKind.AUTHOR);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
				
			case FB2Tag.SUBTITLE:
				myBookReader.pushKind(FBTextKind.SUBTITLE);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			case FB2Tag.DATE:
				myBookReader.pushKind(FBTextKind.DATE);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				break;
			
			case FB2Tag.EMPTY_LINE:
				myBookReader.beginParagraph(ZLTextParagraph.Kind.EMPTY_LINE_PARAGRAPH);
				myBookReader.endParagraph();
				break;
			
			case FB2Tag.CITE:
				myBookReader.pushKind(FBTextKind.CITE);
				break;
			case FB2Tag.EPIGRAPH:
				myBookReader.pushKind(FBTextKind.EPIGRAPH);
				break;
			
			case FB2Tag.POEM:
				myInsidePoem = true;
				break;	
			
			case FB2Tag.STANZA:
				myBookReader.pushKind(FBTextKind.STANZA);
				myBookReader.beginParagraph(ZLTextParagraph.Kind.BEFORE_SKIP_PARAGRAPH);
				myBookReader.endParagraph();
				break;
				
			case FB2Tag.SECTION:
				if (myReadMainText) {
					myBookReader.insertEndOfSectionParagraph();
					++mySectionDepth;
					myBookReader.beginContentsParagraph();
					mySectionStarted = true;
				}
				break;
			
			case FB2Tag.ANNOTATION:
				if (myBodyCounter == 0) {
					myBookReader.setMainTextModel();
				}
				myBookReader.pushKind(FBTextKind.ANNOTATION);
				break;
			
			case FB2Tag.TITLE:
				if (myInsidePoem) {
					myBookReader.pushKind(FBTextKind.POEM_TITLE);
				} else if (mySectionDepth == 0) {
					myBookReader.insertEndOfSectionParagraph();
					myBookReader.pushKind(FBTextKind.TITLE);
				} else {
					myBookReader.pushKind(FBTextKind.SECTION_TITLE);
					myInsideTitle = true;
					myBookReader.enterTitle();
				}
				break;
				
			case FB2Tag.BODY:
				++myBodyCounter;
				myParagraphsBeforeBodyNumber = myBookReader.Model.BookTextModel.getParagraphsNumber();
				if ((myBodyCounter == 1) || (attributes.getValue(""name"") == null)) {
					myBookReader.setMainTextModel();
					myReadMainText = true;
				}
				myBookReader.pushKind(FBTextKind.REGULAR);
				break;
			
			case FB2Tag.A:
			{
				String ref = getAttributeValue(attributes, XMLNamespaces.XLink, ""href"");
				if ((ref != null) && (ref.length() != 0)) {
					final String type = attributes.getValue(""type"");
					if (ref.charAt(0) == '#') {
						myHyperlinkType = ""note"".equals(type) ? FBTextKind.FOOTNOTE : FBTextKind.INTERNAL_HYPERLINK;
						ref = ref.substring(1);
					} else {
						myHyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
					}
					myBookReader.addHyperlinkControl(myHyperlinkType, ref);
				} else {
					myHyperlinkType = FBTextKind.FOOTNOTE;
					myBookReader.addControl(myHyperlinkType, true);
				}
				break;
			}
			case FB2Tag.COVERPAGE:
				if (myBodyCounter == 0) {
					myInsideCoverpage = true;
					myBookReader.setMainTextModel();
				}
				break;	

			case FB2Tag.IMAGE:
			{
				String imgRef = getAttributeValue(attributes, XMLNamespaces.XLink, ""href"");
				if ((imgRef != null) && (imgRef.length() != 0) && (imgRef.charAt(0) == '#')) {
					String vOffset = attributes.getValue(""voffset"");
					short offset = 0;
					try {
						offset = Short.parseShort(vOffset);
					} catch (NumberFormatException e) {
					}
					imgRef = imgRef.substring(1);
					if (!imgRef.equals(myCoverImageReference) ||
							myParagraphsBeforeBodyNumber != myBookReader.Model.BookTextModel.getParagraphsNumber()) {
						myBookReader.addImageReference(imgRef, offset);
					}
					if (myInsideCoverpage) {
						myCoverImageReference = imgRef;
					}
				}
				break;
			}
			case FB2Tag.BINARY:			
				final String contentType = attributes.getValue(""content-type"");
				final String imgId = attributes.getValue(""id"");
				if ((contentType != null) && (id != null)) {
					myCurrentImage = new Base64EncodedImage(contentType);
					myBookReader.addImage(imgId, myCurrentImage);
				}
				break;	

			default:
				break;
		}
		return false;
	}

	public boolean processNamespaces() {
		return true;
	}

	public void addExternalEntities(HashMap<String,char[]> entityMap) {
		entityMap.put(""FBReaderVersion"", ZLibrary.Instance().getVersionName().toCharArray());
	}

	public List<String> externalDTDs() {
		return Collections.emptyList();
	}
}
",True,140,1,1,6,31,2,15,L4
20,org.geometerplus.fbreader.formats.fb2.FB2TagManager.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.library.Tag;

abstract class FB2TagManager {
	private static final HashMap<String,ArrayList<Tag>> ourMap = new HashMap<String,ArrayList<Tag>>();

	static ArrayList<Tag> humanReadableTags(String id) {
		if (ourMap.isEmpty()) {
			new FB2TagInfoReader().read(
				ZLResourceFile.createResourceFile(""formats/fb2/fb2genres.xml"")
			);
		}
		return ourMap.get(id);
	}

	private FB2TagManager() {
	}

	private static class FB2TagInfoReader extends ZLXMLReaderAdapter {
		private final String myLanguage;
		private Tag myCategoryTag;
		private Tag mySubCategoryTag;
		private final ArrayList<String> myGenreIds = new ArrayList<String>();

		FB2TagInfoReader() {
			final String language = Locale.getDefault().getLanguage();
			myLanguage = (""ru"".equals(language)) ? ""ru"" : ""en"";
		}

		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			if ((tag == ""subgenre"") || (tag == ""genre-alt"")) {
				final String id = attributes.getValue(""value"");
				if (id != null) {
					myGenreIds.add(id);
				}
			} else if (tag == ""root-descr"") {
				if (myLanguage == attributes.getValue(""lang"")) {
					myCategoryTag = Tag.getTag(null, attributes.getValue(""genre-title""));
				}
			} else if (tag == ""genre-descr"") {
				if (myLanguage == attributes.getValue(""lang"")) {
					mySubCategoryTag = Tag.getTag(myCategoryTag, attributes.getValue(""title""));
				}
			}
			return false;
		}

		public boolean endElementHandler(String tag) {
			if (tag == ""genre"") {
				myCategoryTag = null;
				mySubCategoryTag = null;
				myGenreIds.clear();
			} else if (tag == ""subgenre"") {
				if (mySubCategoryTag != null) {
					for (String id : myGenreIds) {
						ArrayList<Tag> list = ourMap.get(id);
						if (list == null) {
							list = new ArrayList<Tag>();
							ourMap.put(id, list);
						}
						list.add(mySubCategoryTag);
					}
				}
				mySubCategoryTag = null;
				myGenreIds.clear();
			}
			return false;
		}
	}
}
",True,172,13,40,6,6,1,4,L4
21,org.geometerplus.fbreader.formats.fb2.FB2Plugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class FB2Plugin extends FormatPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		return ""fb2"".equals(file.getExtension());
	}
	
	@Override
	public boolean readMetaInfo(Book book) {
		return new FB2MetaInfoReader(book).readMetaInfo();
	}
	
	@Override
	public boolean readModel(BookModel model) {
		return new FB2Reader(model).readBook();
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		return new FB2CoverReader().readCover(file);
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return new FB2AnnotationReader().readAnnotation(file);
	}
}
",False,139,0,0,6,35,1,9,L4
22,org.geometerplus.fbreader.formats.fb2.FB2CoverReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class FB2CoverReader {
	public FB2CoverImage readCover(ZLFile file) {
		return new FB2CoverImage(file);
	}
}
",False,187,12,40,6,12,1,2,L4
23,org.geometerplus.fbreader.formats.fb2.FB2CoverImage.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.fb2;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.image.ZLImageProxy;
import org.geometerplus.zlibrary.core.xml.*;

class FB2CoverImage extends ZLImageProxy {
	private final ZLFile myFile;

	FB2CoverImage(ZLFile file) {
		myFile = file;
	}

	@Override
	public ZLSingleImage getRealImage() {
		return new BackgroundReader().readCover(myFile);
	}

	@Override
	public int sourceType() {
		return SourceType.DISK;
	}

	@Override
	public String getId() {
		return myFile.getPath();
	}

	private static class BackgroundReader extends ZLXMLReaderAdapter {
		private boolean myReadCoverPage;
		private String myImageReference;
		private Base64EncodedImage myImage;

		Base64EncodedImage readCover(ZLFile file) {
			myReadCoverPage = false;
			myImageReference = null;
			read(file);
			return myImage;
		}

		@Override
		public boolean processNamespaces() {
			return true;
		}

		@Override
		public boolean startElementHandler(String tagName, ZLStringMap attributes) {
			switch (FB2Tag.getTagByName(tagName)) {
			case FB2Tag.COVERPAGE:
				myReadCoverPage = true;
				break;
			case FB2Tag.IMAGE:
				if (myReadCoverPage) {
					final String href = getAttributeValue(attributes, XMLNamespaces.XLink, ""href"");
					if (href != null && href.length() > 1 && href.charAt(0) == '#') {
						myImageReference = href.substring(1);
					}
				}
				break;
			case FB2Tag.BINARY:
				if (myImageReference != null) {
					final String id = attributes.getValue(""id"");
					final String contentType = attributes.getValue(""content-type"");
					if (id != null && contentType != null && myImageReference.equals(id)) {
						// FIXME: make different Base64EncodedImage constructor to use another cache for covers
						myImage = new Base64EncodedImage((contentType != null) ? contentType : MimeTypes.MIME_IMAGE_AUTO);
					}
				}
				break;
			}
			return false;
		}

		@Override
		public boolean endElementHandler(String tag) {
			switch (FB2Tag.getTagByName(tag)) {
			case FB2Tag.COVERPAGE:
				myReadCoverPage = false;
				break;
			case FB2Tag.DESCRIPTION:
				if (myImageReference == null) {
					return true;
				}
				break;
			case FB2Tag.BINARY:
				if (myImage != null) {
					myImage.close();
					return true;
				}
				break;
			}	
			return false;
		}

		@Override
		public void characterDataHandler(char[] data, int start, int length) {
			if (length > 0 && myImage != null) {
				myImage.addData(data, start, length);
			}
		}
	}
}
",False,187,13,40,5,11,1,9,L4
24,org.geometerplus.fbreader.formats.pdb.MobipocketHtmlBookReader.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.util.*;
import java.io.*;
import java.nio.charset.CharsetDecoder;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.html.ZLByteBuffer;
import org.geometerplus.zlibrary.core.html.ZLHtmlAttributeMap;

import org.geometerplus.fbreader.formats.html.HtmlReader;
import org.geometerplus.fbreader.formats.html.HtmlTag;
import org.geometerplus.fbreader.bookmodel.BookModel;

public class MobipocketHtmlBookReader extends HtmlReader {
	private final CharsetDecoder myTocDecoder;
	private MobipocketStream myMobipocketStream;

	MobipocketHtmlBookReader(BookModel model) throws UnsupportedEncodingException {
		super(model);
		myTocDecoder = createDecoder();
	}

	public InputStream getInputStream() throws IOException {
		myMobipocketStream = new MobipocketStream(Model.Book.File);
		return myMobipocketStream;
	}

	private boolean myReadGuide;
	private int myTocStartOffset = Integer.MAX_VALUE;
	private int myTocEndOffset = Integer.MAX_VALUE;
	private final TreeMap<Integer,String> myTocEntries = new TreeMap<Integer,String>();
	private final TreeMap<Integer,Integer> myPositionToParagraph = new TreeMap<Integer,Integer>();
	private final TreeSet<Integer> myFileposReferences = new TreeSet<Integer>();
	private int myCurrentTocPosition = -1;
	private final ZLByteBuffer myTocBuffer = new ZLByteBuffer();

	private boolean tocRangeContainsPosition(int position) {
		return (myTocStartOffset <= position) && (position < myTocEndOffset);
	}

	@Override
	public void startElementHandler(byte tag, int offset, ZLHtmlAttributeMap attributes) {
		final int paragraphIndex = Model.BookTextModel.getParagraphsNumber();
		myPositionToParagraph.put(offset, paragraphIsOpen() ? paragraphIndex - 1 : paragraphIndex);
		switch (tag) {
			case HtmlTag.IMG:
			{
				final ZLByteBuffer recIndex = attributes.getValue(""recindex"");
				if (recIndex != null) {
					try {
						final int index = Integer.parseInt(recIndex.toString());
						if (paragraphIsOpen()) {
							endParagraph();
							addImageReference("""" + index);
							beginParagraph();
						} else {
							addImageReference("""" + index);
						}
					} catch (NumberFormatException e) {
					}
				}
				break;
			}
			case HtmlTag.GUIDE:
				myReadGuide = true;
				break;
			case HtmlTag.REFERENCE:
				if (myReadGuide) {
					final ZLByteBuffer fp = attributes.getValue(""filepos"");
					final ZLByteBuffer title = attributes.getValue(""title"");
					if ((fp != null) && (title != null)) {
						try {
							int filePosition = Integer.parseInt(fp.toString());
							myTocEntries.put(filePosition, title.toString(myAttributeDecoder));
							if (tocRangeContainsPosition(filePosition)) {
								myTocEndOffset = filePosition;
							}
							if (attributes.getValue(""type"").equalsToLCString(""toc"")) {
								myTocStartOffset = filePosition;
								final SortedMap<Integer,String> subMap =
									myTocEntries.tailMap(filePosition + 1);
								if (!subMap.isEmpty()) {
									myTocEndOffset = subMap.firstKey();
								}
							}
						} catch (NumberFormatException e) {
						}
					}
				}
				break;
			case HtmlTag.A:
			{
				final ZLByteBuffer fp = attributes.getValue(""filepos"");
				if (fp != null) {
					try {
						int filePosition = Integer.parseInt(fp.toString());
						if (tocRangeContainsPosition(offset)) {
							myCurrentTocPosition = filePosition;
							if (tocRangeContainsPosition(filePosition)) {
								myTocEndOffset = filePosition;
							}
						}
						myFileposReferences.add(filePosition);
						attributes.put(new ZLByteBuffer(""href""), new ZLByteBuffer(""&filepos"" + filePosition));
					} catch (NumberFormatException e) {
					}
				}
				super.startElementHandler(tag, offset, attributes);
				break;
			}
			default:
				super.startElementHandler(tag, offset, attributes);
				break;
		}
	}

	@Override
	public void endElementHandler(byte tag) {
		switch (tag) {
			case HtmlTag.IMG:
				break;
			case HtmlTag.GUIDE:
				myReadGuide = false;
				break;
			case HtmlTag.REFERENCE:
				break;
			case HtmlTag.A:
				if (myCurrentTocPosition != -1) {
					if (!myTocBuffer.isEmpty()) {
						myTocEntries.put(myCurrentTocPosition, myTocBuffer.toString(myTocDecoder));
						myTocBuffer.clear();
					}
					myCurrentTocPosition = -1;
				}
				super.endElementHandler(tag);
				break;
			default:
				super.endElementHandler(tag);
				break;
		}
	}

	@Override
	public void byteDataHandler(byte[] data, int start, int length) {
		if (myCurrentTocPosition != -1) {
			myTocBuffer.append(data, start, length);
		}
		super.addByteData(data, start, length);
	}

	@Override
	public void startDocumentHandler() {
		super.startDocumentHandler();

		for (int index = 0; ; ++index) {
			final int offset = myMobipocketStream.getImageOffset(index);
			if (offset < 0) {
				break;
			}
			final int length = myMobipocketStream.getImageLength(index);
			if (length <= 0) {
				break;
			}
			addImage("""" + (index + 1), new ZLFileImage(MimeTypes.MIME_IMAGE_AUTO, Model.Book.File, offset, length));
		}
	}

	@Override
	public void endDocumentHandler() {
		for (Integer entry: myFileposReferences) {
			final SortedMap<Integer,Integer> subMap =
				myPositionToParagraph.tailMap(entry);
			if (subMap.isEmpty()) {
				break;
			}
			addHyperlinkLabel(""filepos"" + entry, subMap.get(subMap.firstKey()));
		}

		for (Map.Entry<Integer,String> entry : myTocEntries.entrySet()) {
			final SortedMap<Integer,Integer> subMap =
				myPositionToParagraph.tailMap(entry.getKey());
			if (subMap.isEmpty()) {
				break;
			}
			beginContentsParagraph(subMap.get(subMap.firstKey()));
			addContentsData(entry.getValue().toCharArray());
			endContentsParagraph();
		}
		super.endDocumentHandler();
	}
}
",True,139,0,0,6,36,1,11,L4
25,org.geometerplus.fbreader.formats.pdb.PdbStream.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.util.ZLInputStreamWithOffset;

public abstract class PdbStream extends InputStream {
	protected final ZLInputStreamWithOffset myBase;
	public PdbHeader myHeader;
	protected byte[] myBuffer;

	protected short myBufferLength;
	protected short myBufferOffset;

	public PdbStream(ZLFile file) throws IOException {
		myBase = new ZLInputStreamWithOffset(file.getInputStream());

		myHeader = new PdbHeader(myBase);

		myBase.skip(myHeader.Offsets[0] - myHeader.length());

		myBufferLength = 0;
		myBufferOffset = 0;
	}
	
	public int read() {
		if (!fillBuffer()) {
			return -1;
		}
		return myBuffer[myBufferOffset++];
	}

	public int read(byte[] buffer, int offset, int maxSize) {
		int realSize = 0;
		while (realSize < maxSize) {
			if (!fillBuffer()) {
				break;
			}
			int size = Math.min(maxSize - realSize, myBufferLength - myBufferOffset);
			if (size > 0) {
				if (buffer != null) {
					System.arraycopy(myBuffer, myBufferOffset, buffer, offset + realSize, size);
				}
				realSize += size;
				myBufferOffset += size;
			}
		}
		return (realSize > 0) ? realSize : -1;
	}
	
	public void close() throws IOException {
		if (myBase != null) {
			myBase.close();
		}
		if (myBuffer != null) {
			myBuffer = null;
		}
	}

	public void skip(int offset) throws IOException {
		if (offset > 0) {
			read(null, 0, offset);
		} else {
			throw new IOException(""Cannot skip: "" + offset + "" bytes"");
		}
	}

	protected abstract boolean fillBuffer();
}
",True,169,13,40,5,6,3,3,L4
26,org.geometerplus.fbreader.formats.pdb.PdbPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.fbreader.formats.FormatPlugin;

public abstract class PdbPlugin extends FormatPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		final String extension = file.getExtension();
		return (extension == ""prc"") || (extension == ""pdb"") || (extension == ""mobi"");
	}

	protected static String fileType(final ZLFile file) {
		// TODO: use database instead of option (?)
		ZLStringOption palmTypeOption = new ZLStringOption(file.getPath(), ""PalmType"", """");
		String palmType = palmTypeOption.getValue();
		if (palmType.length() != 8) {
			byte[] id = new byte[8];
			try {
				final InputStream stream = file.getInputStream();
				if (stream == null) {
					return null;
				}
				stream.skip(60);
				stream.read(id);
				stream.close();
			} catch (IOException e) {
			}
			palmType = new String(id).intern();
			palmTypeOption.setValue(palmType);
		}
		return palmType.intern();
	}
}
",True,140,1,1,8,32,2,3,L4
27,org.geometerplus.fbreader.formats.pdb.MobipocketPlugin.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.encoding.ZLEncodingCollection;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.bookmodel.BookModel;

public class MobipocketPlugin extends PdbPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {
		return super.acceptsFile(file) && (fileType(file) == ""BOOKMOBI"");
	}

	@Override
	public boolean readMetaInfo(Book book) {
		InputStream stream = null;
		try {
			stream = book.File.getInputStream();
			final PdbHeader header = new PdbHeader(stream);
			PdbUtil.skip(stream, header.Offsets[0] + 16 - header.length());
			if (PdbUtil.readInt(stream) != 0x4D4F4249) /* ""MOBI"" */ {
				return false;
			}
			final int length = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 4);
			final int encodingCode = (int)PdbUtil.readInt(stream);
			String encodingName = ZLEncodingCollection.Instance().getEncodingName(encodingCode);
			if (encodingName == null) {
				encodingName = ""utf-8"";
			}
			book.setEncoding(encodingName);
			PdbUtil.skip(stream, 52);
			final int fullNameOffset = (int)PdbUtil.readInt(stream);
			final int fullNameLength = (int)PdbUtil.readInt(stream);
			final int languageCode = (int)PdbUtil.readInt(stream);
			book.setLanguage(ZLLanguageUtil.languageByIntCode(languageCode & 0xFF, (languageCode >> 8) & 0xFF));
			PdbUtil.skip(stream, 32);
			int offset = 132;
			if ((PdbUtil.readInt(stream) & 0x40) != 0) {
				PdbUtil.skip(stream, length - 116);
				offset = length + 20;
				if (PdbUtil.readInt(stream) == 0x45585448) /* ""EXTH"" */ {
					PdbUtil.skip(stream, 4);
					final int recordsNumber = (int)PdbUtil.readInt(stream);
					offset += 8;
					for (int i = 0; i < recordsNumber; ++i) {
						final int type = (int)PdbUtil.readInt(stream);
						final int size = (int)PdbUtil.readInt(stream);
						offset += size;
						if (size <= 8) {
							continue;
						}
						switch (type) {
							default:
								PdbUtil.skip(stream, size - 8);
								break;
							case 100:
							{
								final byte[] buffer = new byte[size - 8];
								stream.read(buffer);
								String author = new String(buffer, encodingName);
								final int index = author.indexOf(',');
								if (index != -1) {
									author = author.substring(index + 1).trim() +
											 ' ' +
											 author.substring(0, index).trim(); 
								} else {
									author = author.trim();
								}
								book.addAuthor(author);
								break;
							}
							case 105:
							{
								final byte[] buffer = new byte[size - 8];
								stream.read(buffer);
								book.addTag(new String(buffer, encodingName));
								break;
							}
						}
					}
				}
			}
			PdbUtil.skip(stream, fullNameOffset - offset);
			final byte[] titleBuffer = new byte[fullNameLength];
			stream.read(titleBuffer);
			book.setTitle(new String(titleBuffer, encodingName));
			return true;
		} catch (IOException e) {
			return false;
		} finally {
			if (stream != null) {
				try {
					stream.close();
				} catch (IOException e) {
				}
			}
		}
	}

	@Override
	public boolean readModel(BookModel model) {
		try {
			return new MobipocketHtmlBookReader(model).readBook();
		} catch (IOException e) {
			//e.printStackTrace();
			return false;
		}
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		InputStream stream = null;
		try {
			stream = file.getInputStream();
			final PdbHeader header = new PdbHeader(stream);
			PdbUtil.skip(stream, header.Offsets[0] + 16 - header.length());
			if (PdbUtil.readInt(stream) != 0x4D4F4249) /* ""MOBI"" */ {
				return null;
			}
			final int length = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 104);

			final int exthFlags = (int)PdbUtil.readInt(stream);
			int coverIndex = -1;
			int thumbIndex = -1;

			int offset = 132;
			if ((exthFlags & 0x40) != 0) {
				PdbUtil.skip(stream, length - 116);
				offset = length + 20;
				if (PdbUtil.readInt(stream) != 0x45585448) /* ""EXTH"" */ {
					return null;
				}
				PdbUtil.skip(stream, 4);
				final int recordsNumber = (int)PdbUtil.readInt(stream);
				offset += 8;
				for (int i = 0; i < recordsNumber; ++i) {
					final int type = (int)PdbUtil.readInt(stream);
					final int size = (int)PdbUtil.readInt(stream);
					offset += size;
					if (size <= 8) {
						continue;
					}
					switch (type) {
						default:
							PdbUtil.skip(stream, size - 8);
							break;
						case 201:
						{
							if (size == 12) {
								coverIndex = (int)PdbUtil.readInt(stream);
							} else {
								PdbUtil.skip(stream, size - 8);
							}
							break;
						}
						case 202:
						{
							if (size == 12) {
								thumbIndex = (int)PdbUtil.readInt(stream);
							} else {
								PdbUtil.skip(stream, size - 8);
							}
							break;
						}
					}
				}
			}
			final InputStream tempStream = stream;
			stream = null;
			tempStream.close();

			if (coverIndex == -1) {
				if (thumbIndex == -1) {
					return null;
				}
				coverIndex = thumbIndex;
			}

			MobipocketStream myMobipocketStream = new MobipocketStream(file);
			int start = myMobipocketStream.getImageOffset(coverIndex);
			if (start >= 0) {
				int len = myMobipocketStream.getImageLength(coverIndex);
				if (len > 0) {
					return new ZLFileImage(MimeTypes.MIME_IMAGE_AUTO, file, start, len);
				}
			}
			return null; 
		} catch (IOException e) {
			return null;
		} finally {
			if (stream != null) {
				try {
					stream.close();
				} catch (IOException e) {
				}
			}
		}
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return null;
	}
}
",True,139,0,0,6,38,1,14,L4
28,org.geometerplus.fbreader.formats.pdb.PdbUtil.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class PdbUtil {
	public static void skip(InputStream stream, int numBytes) throws IOException {
		numBytes -= stream.skip(numBytes);
		for (; numBytes > 0; --numBytes) {
			if (stream.read() == -1) {
				throw new IOException(""Unexpected end of stream"");
			}
		}
	}

	public static int readShort(InputStream stream) throws IOException {
		final byte[] tmp = new byte[2];
		stream.read(tmp, 0, 2);
		return (tmp[1] & 0xFF) + ((tmp[0] & 0xFF) << 8);
	}

	public static long readInt(InputStream stream) throws IOException {
		final byte[] tmp = new byte[4];
		stream.read(tmp, 0, 4);
		return (((long)(tmp[0] & 0xFF)) << 24) +
			  + ((tmp[1] & 0xFF) << 16) +
			  + ((tmp[2] & 0xFF) << 8) +
			  + (tmp[3] & 0xFF);
	}
}
",True,151,12,40,0,0,5,0,L4
29,org.geometerplus.fbreader.formats.pdb.MobipocketStream.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

class MobipocketStream extends PalmDocLikeStream {
	private final int myFileSize;
	private final int myImageStartIndex;

	MobipocketStream(ZLFile file) throws IOException {
		super(file);
		myFileSize = (int)file.size();

		myCompressionType = PdbUtil.readShort(myBase);
		PdbUtil.skip(myBase, 6);
		myMaxRecordIndex = Math.min(PdbUtil.readShort(myBase), myHeader.Offsets.length - 1);
		final int maxRecordSize = PdbUtil.readShort(myBase);
		if (maxRecordSize == 0) {
			throw new IOException(""The records are too short"");
		}
		myBuffer = new byte[maxRecordSize];
		myRecordIndex = 0;

		PdbUtil.skip(myBase, 96);
		myImageStartIndex = (int)PdbUtil.readInt(myBase);
	}

	int getImageOffset(int index) {
		try {
			return myHeader.Offsets[index + myImageStartIndex];
		} catch (ArrayIndexOutOfBoundsException e) {
			return -1;
		}
	}

	int getImageLength(int index) {
		try {
			final int i = index + myImageStartIndex;
			final int start = myHeader.Offsets[i];
			final int end = (i == myHeader.Offsets.length) ? myFileSize : myHeader.Offsets[i + 1];
			return end - start;
		} catch (ArrayIndexOutOfBoundsException e) {
			return -1;
		}
	}
}
",False,169,12,40,5,6,2,5,L4
30,org.geometerplus.fbreader.formats.pdb.PdbHeader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;
import java.io.InputStream;

public class PdbHeader {
	public final String DocName;
	public final int Flags;
	public final String Id;
	public final int[] Offsets;

	public PdbHeader(InputStream stream) throws IOException {
		final byte[] buffer = new byte[32];
		if (stream.read(buffer, 0, 32) != 32) {
			throw new IOException(""PdbHeader: cannot reader document name"");
		}
		DocName = new String(buffer);
		Flags = PdbUtil.readShort(stream);

		PdbUtil.skip(stream, 26);
		
		if (stream.read(buffer, 0, 8) != 8) {
			throw new IOException(""PdbHeader: cannot reader palm id"");
		}
		Id = new String(buffer, 0, 8);

		PdbUtil.skip(stream, 8);

		int numRecords = PdbUtil.readShort(stream);
		if (numRecords <= 0) {
			throw new IOException(""PdbHeader: record number = "" + numRecords);
		}
		Offsets = new int[numRecords];

		for (int i = 0; i < numRecords; ++i) {
			Offsets[i] = (int)PdbUtil.readInt(stream);
			PdbUtil.skip(stream, 4);
		}
	}

	public final int length() {
		return 78 + Offsets.length * 8;
	}
}
",False,151,12,40,1,1,6,1,L4
31,org.geometerplus.fbreader.formats.pdb.PalmDocLikeStream.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.IOException;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

abstract class PalmDocLikeStream extends PdbStream {
	protected int myMaxRecordIndex;
	protected int myRecordIndex;
	protected interface CompressionType {
		int NONE = 1;
		int DOC = 2;
		int HUFFDIC = 17480;
	}
	protected int myCompressionType;

	private final long myFileSize;

	PalmDocLikeStream(ZLFile file) throws IOException {
		super(file);
		myFileSize = file.size();
	}

	protected final boolean fillBuffer() {
		while (myBufferOffset == myBufferLength) {
			if (myRecordIndex + 1 > myMaxRecordIndex) {
				return false;
			}
			++myRecordIndex;
			final int currentOffset = myHeader.Offsets[myRecordIndex];

			try {
				myBase.skip(currentOffset - myBase.offset());
				final int nextOffset =
					(myRecordIndex + 1 < myHeader.Offsets.length) ?
						myHeader.Offsets[myRecordIndex + 1] :
						(int)myFileSize;
				if (nextOffset < currentOffset) {
					return false;
				}
				final short recordSize = (short)Math.min(nextOffset - currentOffset, myBuffer.length);

				switch (myCompressionType) {
					case CompressionType.NONE:
						myBase.read(myBuffer, 0, recordSize);
						myBufferLength = recordSize;
						break;
					case CompressionType.DOC:
						myBufferLength = (short)DocDecompressor.decompress(myBase, myBuffer, recordSize);
						break;
					//case CompressionType.HUFFDIC:
					//	myBufferLength = (short)HuffdicDecompressor.decompress(myBase, myBuffer, recordSize);
					//	break;
					default:
						// Unsupported compression type
						return false;
				}
			} catch (IOException e) {
				return false;
			}
			myBufferOffset = 0;
		}
		
		return true;
	}
}
",True,169,13,40,5,6,1,5,L4
32,org.geometerplus.fbreader.formats.pdb.HuffdicDecompressor.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class HuffdicDecompressor {
	public static int decompress(InputStream stream, byte[] targetBuffer, int compressedSize) throws IOException {
		final byte[] sourceBuffer = new byte[compressedSize];

		if (stream.read(sourceBuffer) != compressedSize) {
			return 0;
		}

		int sourceIndex = 0;
		int targetIndex = 0;

		int count0 = 0;
		int count1 = 0;
		int count2 = 0;
		int count3 = 0;
		try {
			while (true) {
				final byte token = sourceBuffer[sourceIndex++];
				switch (token) {
					default:
						++count0;
						targetBuffer[targetIndex++] = token;
						break;
					case 1: case 2: case 3: case 4:
					case 5: case 6: case 7: case 8:
						++count1;
						System.arraycopy(sourceBuffer, sourceIndex, targetBuffer, targetIndex, token);
						sourceIndex += token;
						targetIndex += token;
						break;
					case -64: case -63: case -62: case -61:
					case -60: case -59: case -58: case -57:
					case -56: case -55: case -54: case -53:
					case -52: case -51: case -50: case -49:
					case -48: case -47: case -46: case -45:
					case -44: case -43: case -42: case -41:
					case -40: case -39: case -38: case -37:
					case -36: case -35: case -34: case -33:
					case -32: case -31: case -30: case -29:
					case -28: case -27: case -26: case -25:
					case -24: case -23: case -22: case -21:
					case -20: case -19: case -18: case -17:
					case -16: case -15: case -14: case -13:
					case -12: case -11: case -10: case -9:
					case -8: case -7: case -6: case -5:
					case -4: case -3: case -2: case -1:
						++count2;
						targetBuffer[targetIndex++] = ' ';
						targetBuffer[targetIndex++] = (byte)(token ^ 0x80);
						break;
					case -128: case -127: case -126: case -125:
					case -124: case -123: case -122: case -121:
					case -120: case -119: case -118: case -117:
					case -116: case -115: case -114: case -113:
					case -112: case -111: case -110: case -109:
					case -108: case -107: case -106: case -105:
					case -104: case -103: case -102: case -101:
					case -100: case -99: case -98: case -97:
					case -96: case -95: case -94: case -93:
					case -92: case -91: case -90: case -89:
					case -88: case -87: case -86: case -85:
					case -84: case -83: case -82: case -81:
					case -80: case -79: case -78: case -77:
					case -76: case -75: case -74: case -73:
					case -72: case -71: case -70: case -69:
					case -68: case -67: case -66: case -65:
						++count3;
						final int N = ((token & 0x3F) << 8) + (sourceBuffer[sourceIndex++] & 0xFF);
						int copyLength = (N & 7) + 3;
						int srcIndex = targetIndex - (N >> 3);
						if (targetIndex >= srcIndex + copyLength) {
							System.arraycopy(targetBuffer, srcIndex, targetBuffer, targetIndex, copyLength);
							targetIndex += copyLength;
						} else {
							while (copyLength-- > 0) {
								targetBuffer[targetIndex++] = targetBuffer[srcIndex++];
							}
						}
						break;
				}
			}
		} catch (Exception e) {
			if (targetIndex > targetBuffer.length) {
				targetIndex = targetBuffer.length;
			}
		}

		return targetIndex;
	}
}
",True,1,0,0,0,0,0,0,I0
33,org.geometerplus.fbreader.formats.pdb.DocDecompressor.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.pdb;

import java.io.*;

public abstract class DocDecompressor {
	public static int decompress(InputStream stream, byte[] targetBuffer, int compressedSize) throws IOException {
		final byte[] sourceBuffer = new byte[compressedSize];

		if (stream.read(sourceBuffer) != compressedSize) {
			return 0;
		}

		int sourceIndex = 0;
		int targetIndex = 0;

		int count0 = 0;
		int count1 = 0;
		int count2 = 0;
		int count3 = 0;
		try {
			while (true) {
				final byte token = sourceBuffer[sourceIndex++];
				switch (token) {
					default:
						++count0;
						targetBuffer[targetIndex++] = token;
						break;
					case 1: case 2: case 3: case 4:
					case 5: case 6: case 7: case 8:
						++count1;
						System.arraycopy(sourceBuffer, sourceIndex, targetBuffer, targetIndex, token);
						sourceIndex += token;
						targetIndex += token;
						break;
					case -64: case -63: case -62: case -61:
					case -60: case -59: case -58: case -57:
					case -56: case -55: case -54: case -53:
					case -52: case -51: case -50: case -49:
					case -48: case -47: case -46: case -45:
					case -44: case -43: case -42: case -41:
					case -40: case -39: case -38: case -37:
					case -36: case -35: case -34: case -33:
					case -32: case -31: case -30: case -29:
					case -28: case -27: case -26: case -25:
					case -24: case -23: case -22: case -21:
					case -20: case -19: case -18: case -17:
					case -16: case -15: case -14: case -13:
					case -12: case -11: case -10: case -9:
					case -8: case -7: case -6: case -5:
					case -4: case -3: case -2: case -1:
						++count2;
						targetBuffer[targetIndex++] = ' ';
						targetBuffer[targetIndex++] = (byte)(token ^ 0x80);
						break;
					case -128: case -127: case -126: case -125:
					case -124: case -123: case -122: case -121:
					case -120: case -119: case -118: case -117:
					case -116: case -115: case -114: case -113:
					case -112: case -111: case -110: case -109:
					case -108: case -107: case -106: case -105:
					case -104: case -103: case -102: case -101:
					case -100: case -99: case -98: case -97:
					case -96: case -95: case -94: case -93:
					case -92: case -91: case -90: case -89:
					case -88: case -87: case -86: case -85:
					case -84: case -83: case -82: case -81:
					case -80: case -79: case -78: case -77:
					case -76: case -75: case -74: case -73:
					case -72: case -71: case -70: case -69:
					case -68: case -67: case -66: case -65:
						++count3;
						final int N = ((token & 0x3F) << 8) + (sourceBuffer[sourceIndex++] & 0xFF);
						int copyLength = (N & 7) + 3;
						int srcIndex = targetIndex - (N >> 3);
						if (targetIndex >= srcIndex + copyLength) {
							System.arraycopy(targetBuffer, srcIndex, targetBuffer, targetIndex, copyLength);
							targetIndex += copyLength;
						} else {
							while (copyLength-- > 0) {
								targetBuffer[targetIndex++] = targetBuffer[srcIndex++];
							}
						}
						break;
				}
			}
		} catch (Exception e) {
			if (targetIndex > targetBuffer.length) {
				targetIndex = targetBuffer.length;
			}
		}

		return targetIndex;
	}
}
",True,149,14,40,0,0,3,0,L4
34,org.geometerplus.fbreader.formats.xhtml.XHTMLTagParagraphWithControlAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagParagraphWithControlAction extends XHTMLTagAction {
	final byte myControl;

	XHTMLTagParagraphWithControlAction(byte control) {
		myControl = control;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		if ((myControl == FBTextKind.TITLE) &&
				(modelReader.Model.BookTextModel.getParagraphsNumber() > 1)) {
			modelReader.insertEndOfSectionParagraph();
		}
		modelReader.pushKind(myControl);
		modelReader.beginParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.endParagraph();
		modelReader.popKind();
	}
}
/*
void XHTMLTagParagraphWithControlAction::doAtStart(XHTMLReader &reader, const char**) {
	if ((myControl == TITLE) && (bookReader(reader).model().bookTextModel()->paragraphsNumber() > 1)) {
		bookReader(reader).insertEndOfSectionParagraph();
	}
	bookReader(reader).pushKind(myControl);
	bookReader(reader).beginParagraph();
}
*/
",False,139,0,0,7,33,1,7,L4
35,org.geometerplus.fbreader.formats.xhtml.XHTMLTagAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

public abstract class XHTMLTagAction {
	protected abstract void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes);
	protected abstract void doAtEnd(XHTMLReader reader);
};
",False,139,0,0,9,28,10,2,L4
36,org.geometerplus.fbreader.formats.xhtml.XHTMLTagItemAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagItemAction extends XHTMLTagAction {
	private final char[] BULLET = { '\u2022', '\240' };

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.endParagraph();
		// TODO: increase left indent
		modelReader.beginParagraph();
		// TODO: replace bullet sign by number inside OL tag
		modelReader.addData(BULLET);
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
	}
}
",False,139,0,0,8,32,1,4,L4
37,org.geometerplus.fbreader.formats.xhtml.XHTMLReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import java.util.*;

import org.geometerplus.zlibrary.core.xml.*;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.filesystem.ZLArchiveEntryFile;
import org.geometerplus.zlibrary.core.constants.XMLNamespaces;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.util.MiscUtil;

public class XHTMLReader extends ZLXMLReaderAdapter {
	private static final HashMap<String,XHTMLTagAction> ourTagActions = new HashMap<String,XHTMLTagAction>();

	public static XHTMLTagAction addAction(String tag, XHTMLTagAction action) {
		XHTMLTagAction old = (XHTMLTagAction)ourTagActions.get(tag);
		ourTagActions.put(tag, action);
		return old;
	}

	public static void fillTagTable() {
		if (!ourTagActions.isEmpty()) {
			return;
		}

		//addAction(""html"", new XHTMLTagAction());
		addAction(""body"", new XHTMLTagBodyAction());
		//addAction(""title"", new XHTMLTagAction());
		//addAction(""meta"", new XHTMLTagAction());
		//addAction(""script"", new XHTMLTagAction());

		//addAction(""font"", new XHTMLTagAction());
		//addAction(""style"", new XHTMLTagAction());

		addAction(""p"", new XHTMLTagParagraphAction());
		addAction(""h1"", new XHTMLTagParagraphWithControlAction(FBTextKind.H1));
		addAction(""h2"", new XHTMLTagParagraphWithControlAction(FBTextKind.H2));
		addAction(""h3"", new XHTMLTagParagraphWithControlAction(FBTextKind.H3));
		addAction(""h4"", new XHTMLTagParagraphWithControlAction(FBTextKind.H4));
		addAction(""h5"", new XHTMLTagParagraphWithControlAction(FBTextKind.H5));
		addAction(""h6"", new XHTMLTagParagraphWithControlAction(FBTextKind.H6));

		//addAction(""ol"", new XHTMLTagAction());
		//addAction(""ul"", new XHTMLTagAction());
		//addAction(""dl"", new XHTMLTagAction());
		addAction(""li"", new XHTMLTagItemAction());

		addAction(""strong"", new XHTMLTagControlAction(FBTextKind.STRONG));
		addAction(""b"", new XHTMLTagControlAction(FBTextKind.BOLD));
		addAction(""em"", new XHTMLTagControlAction(FBTextKind.EMPHASIS));
		addAction(""i"", new XHTMLTagControlAction(FBTextKind.ITALIC));
		final XHTMLTagAction codeControlAction = new XHTMLTagControlAction(FBTextKind.CODE);
		addAction(""code"", codeControlAction);
		addAction(""tt"", codeControlAction);
		addAction(""kbd"", codeControlAction);
		addAction(""var"", codeControlAction);
		addAction(""samp"", codeControlAction);
		addAction(""cite"", new XHTMLTagControlAction(FBTextKind.CITE));
		addAction(""sub"", new XHTMLTagControlAction(FBTextKind.SUB));
		addAction(""sup"", new XHTMLTagControlAction(FBTextKind.SUP));
		addAction(""dd"", new XHTMLTagControlAction(FBTextKind.DEFINITION_DESCRIPTION));
		addAction(""dfn"", new XHTMLTagControlAction(FBTextKind.DEFINITION));
		addAction(""strike"", new XHTMLTagControlAction(FBTextKind.STRIKETHROUGH));

		addAction(""a"", new XHTMLTagHyperlinkAction());

		addAction(""img"", new XHTMLTagImageAction(null, ""src""));
		addAction(""image"", new XHTMLTagImageAction(XMLNamespaces.XLink, ""href""));
		addAction(""object"", new XHTMLTagImageAction(null, ""data""));

		//addAction(""area"", new XHTMLTagAction());
		//addAction(""map"", new XHTMLTagAction());

		//addAction(""base"", new XHTMLTagAction());
		//addAction(""blockquote"", new XHTMLTagAction());
		addAction(""br"", new XHTMLTagRestartParagraphAction());
		//addAction(""center"", new XHTMLTagAction());
		addAction(""div"", new XHTMLTagParagraphAction());
		addAction(""dt"", new XHTMLTagParagraphAction());
		//addAction(""head"", new XHTMLTagAction());
		//addAction(""hr"", new XHTMLTagAction());
		//addAction(""link"", new XHTMLTagAction());
		//addAction(""param"", new XHTMLTagAction());
		//addAction(""q"", new XHTMLTagAction());
		//addAction(""s"", new XHTMLTagAction());

		addAction(""pre"", new XHTMLTagPreAction());
		//addAction(""big"", new XHTMLTagAction());
		//addAction(""small"", new XHTMLTagAction());
		//addAction(""u"", new XHTMLTagAction());

		//addAction(""table"", new XHTMLTagAction());
		addAction(""td"", new XHTMLTagParagraphAction());
		addAction(""th"", new XHTMLTagParagraphAction());
		//addAction(""tr"", new XHTMLTagAction());
		//addAction(""caption"", new XHTMLTagAction());
		//addAction(""span"", new XHTMLTagAction());
	}

	private final BookReader myModelReader;
	String myPathPrefix;
	String myLocalPathPrefix;
	String myReferencePrefix;
	boolean myPreformatted;
	boolean myInsideBody;
	private final Map<String,Integer> myFileNumbers;

	public XHTMLReader(BookReader modelReader, Map<String,Integer> fileNumbers) {
		myModelReader = modelReader;
		myFileNumbers = fileNumbers;
	}

	final BookReader getModelReader() {
		return myModelReader;
	}

	public final String getFileAlias(String fileName) {
		fileName = MiscUtil.decodeHtmlReference(fileName);
		fileName = ZLArchiveEntryFile.normalizeEntryName(fileName);
		Integer num = myFileNumbers.get(fileName);
		if (num == null) {
			num = myFileNumbers.size();
			myFileNumbers.put(fileName, num);
		}
		return num.toString();
	}

	public boolean readFile(ZLFile file, String referencePrefix) {
		fillTagTable();

		myReferencePrefix = referencePrefix;

		myPathPrefix = MiscUtil.htmlDirectoryPrefix(file);
		myLocalPathPrefix = MiscUtil.archiveEntryName(myPathPrefix);

		myPreformatted = false;
		myInsideBody = false;

		return read(file);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		String id = attributes.getValue(""id"");
		if (id != null) {
			myModelReader.addHyperlinkLabel(myReferencePrefix + id);
		}

		XHTMLTagAction action = (XHTMLTagAction)ourTagActions.get(tag.toLowerCase());
		if (action != null) {
			action.doAtStart(this, attributes);
		}
		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		XHTMLTagAction action = (XHTMLTagAction)ourTagActions.get(tag.toLowerCase());
		if (action != null) {
			action.doAtEnd(this);
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int len) {
		if (myPreformatted) {
			final char first = data[start]; 
			if ((first == '\r') || (first == '\n')) {
				myModelReader.addControl(FBTextKind.CODE, false);
				myModelReader.endParagraph();
				myModelReader.beginParagraph();
				myModelReader.addControl(FBTextKind.CODE, true);
			}
			int spaceCounter = 0;
cycle:
			while (spaceCounter < len) {
				switch (data[start + spaceCounter]) {
					case 0x08:
					case 0x09:
					case 0x0A:
					case 0x0B:
					case 0x0C:
					case 0x0D:
					case ' ':
						break;
					default:
						break cycle;
				}
				++spaceCounter;
			}
			myModelReader.addFixedHSpace((short)spaceCounter);
			start += spaceCounter;
			len -= spaceCounter;
		}
		if (len > 0) {
			if (myInsideBody && !myModelReader.paragraphIsOpen()) {
				myModelReader.beginParagraph();
			}
			myModelReader.addData(data, start, len, false);
		}
	}

	private static ArrayList<String> ourExternalDTDs = new ArrayList<String>();

	public static List<String> xhtmlDTDs() {
		if (ourExternalDTDs.isEmpty()) {
			ourExternalDTDs.add(""formats/xhtml/xhtml-lat1.ent"");
			ourExternalDTDs.add(""formats/xhtml/xhtml-special.ent"");
			ourExternalDTDs.add(""formats/xhtml/xhtml-symbol.ent"");
		}
		return ourExternalDTDs;
	}

	@Override
	public List<String> externalDTDs() {
		return xhtmlDTDs();
	}

	@Override
	public boolean dontCacheAttributeValues() {
		return true;
	}

	@Override
	public boolean processNamespaces() {
		return true;
	}
}
",False,224,9,25,8,28,13,18,L4
38,org.geometerplus.fbreader.formats.xhtml.XHTMLTagImageAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.formats.util.MiscUtil;
import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagImageAction extends XHTMLTagAction {
	private final String myNamespace;
	private final String myNameAttribute;

	XHTMLTagImageAction(String namespace, String nameAttribute) {
		myNamespace = namespace;
		myNameAttribute = nameAttribute;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		String fileName = reader.getAttributeValue(xmlattributes, myNamespace, myNameAttribute);
		if (fileName != null) {
			fileName = MiscUtil.decodeHtmlReference(fileName);
			final ZLFile imageFile = ZLFile.createFileByPath(reader.myPathPrefix + fileName);
			if (imageFile != null) {
				final BookReader modelReader = reader.getModelReader();
				boolean flag = modelReader.paragraphIsOpen() && !modelReader.paragraphIsNonEmpty();
				if (flag) {
					modelReader.endParagraph();
				}
				final String imageName = imageFile.getLongName();
				modelReader.addImageReference(imageName, (short)0);
				modelReader.addImage(imageName, new ZLFileImage(MimeTypes.MIME_IMAGE_AUTO, imageFile));
				if (flag) {
					modelReader.beginParagraph();
				}
			}
		}
	}

	protected void doAtEnd(XHTMLReader reader) {
	}
}
",False,139,0,0,8,28,1,9,L4
39,org.geometerplus.fbreader.formats.xhtml.XHTMLTagHyperlinkAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.util.ZLArrayUtils;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagHyperlinkAction extends XHTMLTagAction {
	private byte[] myHyperlinkStack = new byte[10];
	private int myHyperlinkStackSize;

	private static boolean isReference(String text) {
		return
			text.startsWith(""http://"") ||
			text.startsWith(""https://"") ||
			text.startsWith(""mailto:"") ||
			text.startsWith(""ftp://"");
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		final String href = xmlattributes.getValue(""href"");
		if (myHyperlinkStackSize == myHyperlinkStack.length) {
			myHyperlinkStack = ZLArrayUtils.createCopy(myHyperlinkStack, myHyperlinkStackSize, 2 * myHyperlinkStackSize);
		}
		if ((href != null) && (href.length() > 0)) {
			String link = href;
			final byte hyperlinkType;
			if (isReference(link)) {
				hyperlinkType = FBTextKind.EXTERNAL_HYPERLINK;
			} else {
				hyperlinkType = FBTextKind.INTERNAL_HYPERLINK;
				final int index = href.indexOf('#');
				if (index == 0) {
					link = reader.myReferencePrefix + href.substring(1);
				} else if (index > 0) {
					link = reader.getFileAlias(reader.myLocalPathPrefix + href.substring(0, index)) + href.substring(index);
				} else {
					link = reader.getFileAlias(reader.myLocalPathPrefix + href);
				}
			}
			myHyperlinkStack[myHyperlinkStackSize++] = hyperlinkType;
			modelReader.addHyperlinkControl(hyperlinkType, link);
		} else {
			myHyperlinkStack[myHyperlinkStackSize++] = FBTextKind.REGULAR;
		}
		final String name = xmlattributes.getValue(""name"");
		if (name != null) {
			modelReader.addHyperlinkLabel(reader.myReferencePrefix + name);
		}
	}

	protected void doAtEnd(XHTMLReader reader) {
		byte kind = myHyperlinkStack[--myHyperlinkStackSize];
		if (kind != FBTextKind.REGULAR) {
			reader.getModelReader().addControl(kind, false);
		}
	}
}
",False,139,0,0,8,32,1,6,L4
40,org.geometerplus.fbreader.formats.xhtml.XHTMLTagParagraphAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagParagraphAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.getModelReader().beginParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
	}
}
",False,139,0,0,8,32,1,4,L4
41,org.geometerplus.fbreader.formats.xhtml.XHTMLTagRestartParagraphAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagRestartParagraphAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.getModelReader().beginParagraph();
		reader.getModelReader().endParagraph();
	}

	protected void doAtEnd(XHTMLReader reader) {
	}
}
",False,139,0,0,8,32,1,4,L4
42,org.geometerplus.fbreader.formats.xhtml.XHTMLTagPreAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.*;

class XHTMLTagPreAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.myPreformatted = true;
		final BookReader modelReader = reader.getModelReader();
		modelReader.beginParagraph();
		modelReader.addControl(FBTextKind.CODE, true);
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.addControl(FBTextKind.CODE, false);
		modelReader.endParagraph();
		reader.myPreformatted = false;
	}
}
",False,139,0,0,8,32,1,5,L4
43,org.geometerplus.fbreader.formats.xhtml.XHTMLTagBodyAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

class XHTMLTagBodyAction extends XHTMLTagAction {
	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		reader.myInsideBody = true;
	}

	protected void doAtEnd(XHTMLReader reader) {
		reader.getModelReader().endParagraph();
		reader.myInsideBody = false;
	}
}
",False,139,0,0,8,32,1,4,L4
44,org.geometerplus.fbreader.formats.xhtml.XHTMLTagControlAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.xhtml;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.bookmodel.BookReader;

class XHTMLTagControlAction extends XHTMLTagAction {
	final byte myControl;

	XHTMLTagControlAction(byte control) {
		myControl = control;
	}

	protected void doAtStart(XHTMLReader reader, ZLStringMap xmlattributes) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.pushKind(myControl);
		modelReader.addControl(myControl, true);
	}

	protected void doAtEnd(XHTMLReader reader) {
		final BookReader modelReader = reader.getModelReader();
		modelReader.addControl(myControl, false);
		modelReader.popKind();
	}
}
",False,139,0,0,8,32,1,4,L4
45,org.geometerplus.fbreader.formats.plucker.PluckerTextStream.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;

import org.geometerplus.fbreader.formats.pdb.PdbStream;
import org.geometerplus.fbreader.formats.pdb.PdbUtil;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class PluckerTextStream extends PdbStream {
	private short myCompressionVersion;
	private	byte[] myFullBuffer;
	private	int myRecordIndex;

	public PluckerTextStream(ZLFile file) throws IOException {
		super(file);
		myFullBuffer = null;
	}
	
	public int read() {
		return 0;
	}
	
	public boolean open() throws IOException {
		//if (!super.open()) {
		//	return false;
		//}

		myCompressionVersion = (short) PdbUtil.readShort(myBase);

		myBuffer = new byte[65536];
		myFullBuffer = new byte[65536];

		myRecordIndex = 0;

		return true;
	}
	
	public	void close() throws IOException {
		if (myFullBuffer != null) {
			myFullBuffer = null;
		}
		super.close();
	}

	protected boolean fillBuffer() {
		while (myBufferOffset == myBufferLength) {
			if (myRecordIndex + 1 > myHeader.Offsets.length - 1) {
				return false;
			}
			++myRecordIndex;
			int currentOffset = myHeader.Offsets[myRecordIndex];
			//if (currentOffset < myBase.offset()) {
			//	return false;
			//}
			//((PdbStream)myBase).seek(currentOffset, true);
			int nextOffset =
				(myRecordIndex + 1 < myHeader.Offsets.length) ?
						myHeader.Offsets[myRecordIndex + 1] : 0;//myBase.sizeOfOpened();
			if (nextOffset < currentOffset) {
				return false;
			}
			try {
				processRecord(nextOffset - currentOffset);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return true;
	}

	private void processRecord(int recordSize) throws IOException {
		myBase.skip(2);

		int paragraphs = PdbUtil.readShort(myBase);
		int size = PdbUtil.readShort(myBase);
		
		char type = (char)myBase.read(); 
		if (type > 1) { // this record is not text record
			return;
		}

		myBase.skip(1);

		final int[] pars = new int[paragraphs];
		for (int i = 0; i < paragraphs; ++i) {
			pars[i] = PdbUtil.readShort(myBase);
			myBase.skip(2);
		}

		boolean doProcess = false;
		if (type == 0) {
			doProcess = myBase.read(myFullBuffer, 0, size) == size;
		} else if (myCompressionVersion == 1) {
			//doProcess =
				//DocDecompressor().decompress(myBase, myFullBuffer, recordSize - 8 - 4 * paragraphs, size) == size;
		} else if (myCompressionVersion == 2) {
			myBase.skip(2);
			//doProcess =
				//ZLZDecompressor(recordSize - 10 - 4 * paragraphs).decompress(myBase, myFullBuffer, size) == size;
		}
		if (doProcess) {
			myBufferLength = 0;
			myBufferOffset = 0;

			int start = 0;
			int end = 0;

			for (int i = 0; i < paragraphs; ++i) {
				start = end;
				end = start + pars[i];
				if (end > myFullBuffer[size]) {
					break;
				}
				processTextParagraph(myFullBuffer.toString().toCharArray(), start, end);
			}
		}
	}
	
	private	void processTextParagraph(char[] data, int start, int end) {
		int textStart = start;
		boolean functionFlag = false;
		for (int ptr = start; ptr < end; ++ptr) {
			if (data[ptr] == 0) {
				functionFlag = true;
				if (ptr != textStart) {
					//memcpy(myBuffer + myBufferLength, textStart, ptr - textStart);
					myBufferLength += ptr - textStart;
				}
			} else if (functionFlag) {
				int paramCounter = (data[ptr]) % 8;
				if (end - ptr > paramCounter + 1) {
					ptr += paramCounter;
				} else {
					ptr = end - 1;
				}
				functionFlag = false;
				textStart = ptr + 1;
			}
		}
		if (end != textStart) {
			//memcpy(myBuffer + myBufferLength, textStart, end - textStart);
			myBufferLength += end - textStart;
		}
	}
}
",True,23,1,1,5,6,1,5,L7
46,org.geometerplus.fbreader.formats.plucker.PluckerPlugin.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.pdb.PdbPlugin;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;

public class PluckerPlugin extends PdbPlugin {
	@Override
	public boolean acceptsFile(ZLFile file) {		
		return ""DataPlkr"".equals(fileType(file));
	}
	
	@Override
	public boolean readMetaInfo(Book book) {
		try {
			PluckerTextStream stream = new PluckerTextStream(book.File);
			if (stream.open()) {
				//detectEncodingAndLanguage(book, stream);
				stream.close();
			}
		} catch (IOException e) {
		}
		
		if (book.getEncoding().length() == 0) {
			return false;
		}

		return true;
	}
	
	@Override
	public boolean readModel(BookModel model)  {
		return new PluckerBookReader(model.Book.File, model, model.Book.getEncoding()).readDocument();
	}

	@Override
	public ZLImage readCover(ZLFile file) {
		return null;
	}

	@Override
	public String readAnnotation(ZLFile file) {
		return null;
	}
}
",True,145,0,0,7,34,0,7,L7
47,org.geometerplus.fbreader.formats.plucker.PluckerBookReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.util.*;
import java.util.zip.*;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.util.ZLInputStreamWithOffset;
import org.geometerplus.zlibrary.core.image.*;
import org.geometerplus.zlibrary.text.model.*;

import org.geometerplus.fbreader.bookmodel.*;
import org.geometerplus.fbreader.formats.pdb.*;

public class PluckerBookReader extends BookReader {
	private final ZLFile myFile;
	private final int myFileSize;
	private ZLInputStreamWithOffset myStream;
	private	int myFont;
	private	char[] myCharBuffer;
	private	String myConvertedTextBuffer;
	private	boolean myParagraphStarted = false;
	private	boolean myBufferIsEmpty;
	//private	ZLTextForcedControlEntry myForcedEntry;
	private	final ArrayList/*<std::pair<FBTextKind,bool> >*/ myDelayedControls = new ArrayList();
	private	final ArrayList/*<std::string> */myDelayedHyperlinks = new ArrayList();
	private	short myCompressionVersion;
	private	char myBytesToSkip;

	private	final ArrayList/*<std::pair<int, int> >*/ myReferencedParagraphs = new ArrayList();
	private	final HashMap/*<int, std::vector<int> >*/ myParagraphMap = new HashMap(); /*<int, vector<pair<int, int>>>*/
	private	ArrayList/*<Integer, Integer>*/ myParagraphVector = new ArrayList();
	private	boolean myParagraphStored;
	
	public PluckerBookReader(ZLFile file, BookModel model, String encoding){
		super(model);
		//myConverter = new EncodedTextReader(encoding).getConverter(); 
		myFile = file; 
		myFileSize = (int)file.size();
		//System.out.println(filePath + ""  "" + encoding);
		myFont = FontType.FT_REGULAR;
		myCharBuffer = new char[65535];
		//myForcedEntry = null;
	}

	public boolean readDocument() {
		try {
			myStream = new ZLInputStreamWithOffset(myFile.getInputStream());
        
			PdbHeader header = new PdbHeader(myStream);
        
			setMainTextModel();
			myFont = FontType.FT_REGULAR;
        
			for (int index = 0; index < header.Offsets.length; ++index) {
				int currentOffset = myStream.offset();
				int pit = header.Offsets[index];
				if (currentOffset > pit) {
					break;
				}
				//myStream.seek(pit - currentOffset, false);
				myStream.skip(pit - currentOffset);
				
				if (myStream.offset() != pit) {
					break;
				}
				int recordSize = ((index != header.Offsets.length - 1) ? header.Offsets[index + 1] : myFileSize) - pit;
				readRecord(recordSize);
			}
			myStream.close();
		} catch (IOException e) {
			return false;
		}

		for (Iterator it = myReferencedParagraphs.iterator(); it.hasNext();) {
			Pair pair = (Pair)it.next();
			int first = (Integer)pair.myFirst;
			int second = (Integer)pair.mySecond;
			ArrayList/*<Integer>*/ list = (ArrayList)myParagraphMap.get(first);
			if (list != null) {
				for(int k = second; k < list.size(); ++k) {
					if (((Integer) ((Pair)list.get(k)).myFirst) != -1) {
						//addHyperlinkLabel(fromNumber(first) + '#' + fromNumber(second), (Integer)list.get(k));
						final Pair p = (Pair)list.get(k);
						//addHyperlinkLabel(fromNumber(first) + '#' + fromNumber(second), (Integer) p.mySecond, (Integer) p.myFirst);
						break;						
					}
				}
			}
		}
		myReferencedParagraphs.clear();
		myParagraphMap.clear();
		return true;
	}

	private class FontType {
			public static final int FT_REGULAR = 0;
			public static final int FT_H1 = 1;
			public static final int FT_H2 = 2;
			public static final int FT_H3 = 3;
			public static final int FT_H4 = 4;
			public static final int FT_H5 = 5;
			public static final int FT_H6 = 6;
			public static final int FT_BOLD = 7;
			public static final int FT_TT = 8;
			public static final int FT_SMALL = 9;
			public static final int FT_SUB = 10;
			public static final int FT_SUP = 11;
		};

	private	void readRecord(int recordSize) throws IOException {
		int uid = PdbUtil.readShort(myStream);
		if (uid == 1) {
			myCompressionVersion = (short) PdbUtil.readShort(myStream );
		} else {
			int paragraphs = PdbUtil.readShort(myStream);

			int size = PdbUtil.readShort(myStream);
            //TODO ??????  
			int type = myStream.read();

			int flags = myStream.read();

			switch (type) {
				case 0: // text (TODO: found sample file and test this code)
				case 1: // compressed text
				{
					ArrayList/*<Integer>*/ pars = new ArrayList();
					for (int i = 0; i < paragraphs; ++i) {
						int pSize = PdbUtil.readShort(myStream);
						pars.add(pSize);
						myStream.skip(2);
					}

					boolean doProcess = false;
					if (type == 0) {//?
						byte[] buf = new byte[size];
						doProcess = myStream.read(buf, 0, (int)size) == size;
						if (doProcess) {
							// TODO: use encoding!!!!
							// TODO: don't create any new objects!!!!
							myCharBuffer = new String(buf).toCharArray();
						}
					} else if (myCompressionVersion == 1) {
						byte[] buf = new byte[size];
						doProcess =
							DocDecompressor.decompress(myStream, buf, recordSize - 8 - 4 * paragraphs) == size;
						if (doProcess) {
							myCharBuffer = new String(buf).toCharArray();
						}
					} else if (myCompressionVersion == 2) {
						byte input [] = new byte[(int) (recordSize - 10 - 4 * paragraphs)];
						final int inputSize = myStream.read(input);
						Inflater decompressor = new Inflater();
						decompressor.setInput(input, 0, inputSize);
						byte output [] = new byte[size];
						try {
							doProcess = decompressor.inflate(output) == size;
							decompressor.end();
							myCharBuffer = new String(output, 0, size).toCharArray();
						} catch (DataFormatException e) {
							// TODO Auto-generated catch block
							//e.printStackTrace();
							//System.out.println(e.getMessage());
						}
						//doProcess =
							//ZLZDecompressor(recordSize - 10 - 4 * paragraphs).
								//decompress(myStream, myCharBuffer, size) == size;
					}
					if (doProcess) {
						addHyperlinkLabel(fromNumber(uid));
						myParagraphMap.put(uid, new ArrayList());
						myParagraphVector = (ArrayList)myParagraphMap.get(uid);
						processTextRecord(size, pars);
						if ((flags & 0x1) == 0) {
//							insertEndOfTextParagraph();
							//setNewTextModel();
						}
					}
					break;
				}
				case 2: // image
				case 3: // compressed image
				{
					ZLImage image = null;
					if (type == 2) {
						//System.out.println(""non-compressed image"");
						image = new PluckerFileImage(MimeTypes.MIME_IMAGE_PALM, myFile, myStream.offset(), recordSize - 8);
					} else if (myCompressionVersion == 1) {
						//System.out.println(""DocCompressedImage"");
						image = new DocCompressedFileImage(MimeTypes.MIME_IMAGE_PALM, myFile, myStream.offset(), recordSize - 8);
					} else if (myCompressionVersion == 2) {
						//System.out.println(""ZCompressedImage"");
						image = new ZCompressedFileImage(MimeTypes.MIME_IMAGE_PALM, myFile, myStream.offset() + 2, recordSize - 10);
					}
					if (image != null) {
						addImage(fromNumber(uid), image);
					}
					break;
				}
				case 9: // category record is ignored
					break;
				case 10:
					short typeCode = (short) PdbUtil.readShort(myStream);
					break;
				case 11: // style sheet record is ignored
					break;
				case 12: // font page record is ignored
					break;
				case 13: // TODO: process tables
				case 14: // TODO: process tables
					break;
				case 15: // multiimage
				{
					short columns = (short) PdbUtil.readShort(myStream);
					short rows = (short) PdbUtil.readShort(myStream);
					//System.out.println(""multiimage"");
					/*PluckerMultiImage image = new PluckerMultiImage(rows, columns, Model.getImageMap());
					for (int i = 0; i < size / 2 - 2; ++i) {
						short us = (short)myStream.read();
						PdbUtil.readShort(myStream, us);
						image.addId(fromNumber(us));
					}
					addImage(fromNumber(uid), image);
					*/break;
				}
				default:
					//std::cerr << ""type = "" << (int)type << ""\n"";
					break;
			}
		}	
	}
	
    private	void processTextRecord(int size, ArrayList/*<Integer>*/ pars) {
    	int start = 0;
    	int end = 0;

    	for (Iterator it = pars.iterator(); it.hasNext();) {
    		start = end;
    		end = start + (Integer)it.next();
    		if (end > size) {
    			return;
    		}
    		myParagraphStored = false;
    		processTextParagraph(myCharBuffer, start, end);
    		if (!myParagraphStored) {
    			myParagraphVector.add(new Pair(-1, -1));
    		}
    	}
    }
    
    private	void processTextParagraph(char[] data, int start, int end) {
    	changeFont(FontType.FT_REGULAR);
    	while (popKind()) {}

    	myParagraphStarted = false;
    	myBytesToSkip = 0;

    	int textStart = start;
    	boolean functionFlag = false;
    	for (int ptr = start; ptr < end; ++ptr) {
    		if (data[ptr] == 0) {
    			functionFlag = true;
    			if (ptr > textStart) {
    				safeBeginParagraph();
    	//			myConvertedTextBuffer = """";//.erase();
    				myConvertedTextBuffer = """";//myConverter.convert(data, textStart, ptr);
    				addData(myConvertedTextBuffer.toCharArray());
    				myBufferIsEmpty = false;
    			}
    		} else if (functionFlag) {
    			int paramCounter = (data[ptr]) % 8;
    			if (end - ptr > paramCounter) {
    				processTextFunction(data, ptr);
    				ptr += paramCounter;
    			} else {
    				ptr = end - 1;
    			}
    			functionFlag = false;
    			if (myBytesToSkip > 0) {
    				ptr += myBytesToSkip;
    				myBytesToSkip = 0;
    			}
    			textStart = ptr + 1;
    		} else {
    			if (data[ptr] == 0xA0) {
    				data[ptr] = 0x20;
    			}
    			if (!myParagraphStarted && (textStart == ptr) && (data[ptr] == ' ')) {
    				++textStart;
    			}
    		}
    	}
    	if (end > textStart) {
    		safeBeginParagraph();
    	//	myConvertedTextBuffer = """";//erase();
    		myConvertedTextBuffer = """";//myConverter.convert(data, textStart, end);
    		addData(myConvertedTextBuffer.toCharArray());
    		myBufferIsEmpty = false;
    	}
    	safeEndParagraph();
    	//if (myForcedEntry != null) {
    	//	myForcedEntry = null;
    	//}
    	myDelayedControls.clear();
    }
    
    private	void processTextFunction(char[] ptr, int cur) {
			switch (ptr[cur]) {
				case 0x08:
					safeAddControl(FBTextKind.INTERNAL_HYPERLINK, false);
					break;
				case 0x0A:
					safeAddHyperlinkControl(fromNumber(twoBytes(ptr, cur+ 1)));
					break;
				case 0x0C:
				{
					int sectionNum = twoBytes(ptr, cur + 1);
					int paragraphNum = twoBytes(ptr, cur + 3);
					safeAddHyperlinkControl(fromNumber(sectionNum) + '#' + fromNumber(paragraphNum));
					myReferencedParagraphs.add(new Pair(sectionNum, paragraphNum));
					break;
				}
				case 0x11:
					changeFont((ptr[cur + 1]));
					break;
				case 0x1A:
					safeBeginParagraph();
			//		System.out.println(""image ref"");
					addImageReference(fromNumber(twoBytes(ptr, cur + 1)), (short) 0);
					break;
				case 0x22:
					if (!myParagraphStarted) {
						//if (myForcedEntry == null) {
						//	myForcedEntry = new ZLTextForcedControlEntry();
						//}
						//myForcedEntry.setLeftIndent((short)ptr[cur + 1]);
						//myForcedEntry.setRightIndent((short)ptr[cur + 2]);
					}
					break;
				case 0x29:
					if (!myParagraphStarted) {
						//if (myForcedEntry == null) {
						//	myForcedEntry = new ZLTextForcedControlEntry();
						//}
						//switch (ptr[cur + 1]) {
						//	case 0: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_LEFT); break;
						//	case 1: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_RIGHT); break;
						//	case 2: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_CENTER); break;
						//	case 3: myForcedEntry.setAlignmentType(ZLTextAlignmentType.ALIGN_JUSTIFY); break;
						//}
					}
					break;
				case 0x33: // just break line instead of horizontal rule (TODO: draw horizontal rule?)
					safeEndParagraph();
					break;
				case 0x38:
					safeEndParagraph();
					break;
				case 0x40: 
					safeAddControl(FBTextKind.EMPHASIS, true);
					break;
				case 0x48:
					safeAddControl(FBTextKind.EMPHASIS, false);
					break;
				case 0x53: // color setting is ignored
					break;
				case 0x5C:
		//			System.out.println(""image ref"");
					addImageReference(fromNumber(twoBytes(ptr, cur + 3)), (short) 0);
					break;
				case 0x60: // underlined text is ignored
					break;
				case 0x68: // underlined text is ignored
					break;
				case 0x70: // strike-through text is ignored
					break;
				case 0x78: // strike-through text is ignored
					break;
				case 0x83: 
				{
					safeBeginParagraph();
					addData(new char[] { (char)twoBytes(ptr, cur + 2) });
					myBufferIsEmpty = false;
					myBytesToSkip = ptr[cur+1];
					break;
				}
				case 0x85: // TODO: process 4-byte unicode character
					break;
				case 0x8E: // custom font operations are ignored
				case 0x8C:
				case 0x8A:
				case 0x88:
					break;
				case 0x90: // TODO: add table processing
				case 0x92: // TODO: process table
				case 0x97: // TODO: process table
					break;
				default: // this should be impossible
					//std::cerr << ""Oops... function #"" << (int)(unsigned char)*ptr << ""\n"";
					break;
	}	
    }
    
    private	void setFont(int font, boolean start) {
			switch (font) {
				case FontType.FT_REGULAR:
					break;
				case FontType.FT_H1:
				case FontType.FT_H2:
				case FontType.FT_H3:
				case FontType.FT_H4:
				case FontType.FT_H5:
				case FontType.FT_H6:
					processHeader(font, start);
					break;
				case FontType.FT_BOLD:
					safeAddControl(FBTextKind.BOLD, start);
					break;
				case FontType.FT_TT:
					safeAddControl(FBTextKind.CODE, start);
					break;
				case FontType.FT_SMALL:
					break;
				case FontType.FT_SUB:
					safeAddControl(FBTextKind.SUB, start);
					break;
				case FontType.FT_SUP:
					safeAddControl(FBTextKind.SUP, start);
					break;
	    }
    }

    private	void changeFont(int font) {
    	if (myFont == font) {
    		return;
    	}
    	setFont(myFont, false);
    	myFont = font;
    	setFont(myFont, true);
    }

    private void safeAddControl(byte kind, boolean start) {
    	if (myParagraphStarted) {
    		addControl((Byte)kind, (Boolean)start);
    	} else {
    		myDelayedControls.add(new Pair(kind, start));
    	}
    }
    private void safeAddHyperlinkControl(String id) {
    	if (myParagraphStarted) {
    		addHyperlinkControl(FBTextKind.INTERNAL_HYPERLINK, id);
    	} else {
    		myDelayedHyperlinks.add(id);
    	}
    }
    
    private void safeBeginParagraph() {
    	if (!myParagraphStarted) {
    		myParagraphStarted = true;
    		myBufferIsEmpty = true;
    		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
    		if (!myParagraphStored) {
    			//final ArrayList models = Model.getBookTextModels();
    			//myParagraphVector.add(new Pair(((ZLTextPlainModel) models.get(models.size()-1)/*BookTextModel*/).getParagraphsNumber() - 1, models.size() - 1));
    			myParagraphStored = true;
    		}
    		for (Iterator it = myDelayedControls.iterator(); it.hasNext(); ) {
    			Pair pit = (Pair)it.next();
    			addControl((Byte)pit.myFirst, (Boolean)pit.mySecond);
    		}
    		//if (myForcedEntry != null) {
    		//	addControl(myForcedEntry);
    		//} else {
    			addControl(FBTextKind.REGULAR, true);
    		//}
    		for (Iterator it = myDelayedHyperlinks.iterator(); it.hasNext(); ) {
    			addHyperlinkControl(FBTextKind.INTERNAL_HYPERLINK, (String)it.next());
    		}
    		myDelayedHyperlinks.clear();
    	}
    }
    
    private void safeEndParagraph() {
    	if (myParagraphStarted) {
    		if (myBufferIsEmpty) {
    			final String SPACE = "" "";
    			addData(SPACE.toCharArray());
    		}
    		endParagraph();
    		myParagraphStarted = false;
    	}
    }

    private void processHeader(int font, boolean start) {
    	if (start) {
    		enterTitle();
    		int kind;
    		switch (font) {
    			case FontType.FT_H1:
    				kind = FBTextKind.H1;
    				break;
    			case FontType.FT_H2:
    				kind = FBTextKind.H2;
    				break;
    			case FontType.FT_H3:
    				kind = FBTextKind.H3;
    				break;
    			case FontType.FT_H4:
    				kind = FBTextKind.H4;
    				break;
    			case FontType.FT_H5:
    				kind = FBTextKind.H5;
    				break;
    			case FontType.FT_H6:
    			default:
    				kind = FBTextKind.H6;
    				break;
    		}
    		pushKind((byte)kind);
    	} else {
    		popKind();
    		exitTitle();
    	}
    }
	
	static private class Pair {
		public Object myFirst;
		public Object mySecond;
		Pair(Object first, Object second) {
			this.myFirst = first;
			this.mySecond = second;
		}
	}

	static private int twoBytes(char[] ptr, int offset) {
		return 256 * ptr[offset] + ptr[offset+1];
	}

	static String fromNumber(int num) {
		String str = """";
		str += num;
		//ZLStringUtil.appendNumber(str, num);
		return str;
	}
}
",True,144,1,1,7,31,1,14,L7
48,org.geometerplus.fbreader.formats.plucker.PluckerFileImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class PluckerFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int mySize;

	public PluckerFileImage(String mimeType, final ZLFile file, final int offset, final int size) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		mySize = size;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	public byte[] byteData() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return new byte[0];
			}

			stream.skip(myOffset);
			byte [] buffer = new byte[mySize];
			stream.read(buffer, 0, mySize);
			return buffer;
		} catch (IOException e) {}
		
		return new byte[0];
	}
}
",True,22,2,1,5,6,1,2,L7
49,org.geometerplus.fbreader.formats.plucker.DocCompressedFileImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.io.InputStream;

import org.geometerplus.fbreader.formats.pdb.DocDecompressor;
import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class DocCompressedFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int myCompressedSize;
	
	public DocCompressedFileImage(String mimeType, final ZLFile file, final int offset, final int compressedSize) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		myCompressedSize = compressedSize;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	public byte[] byteData() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return new byte[0];
			}

			stream.skip(myOffset);
			byte [] targetBuffer = new byte[65535];
			final int size = DocDecompressor.decompress(stream, targetBuffer, myCompressedSize);
			if (size > 0 && size != 65535) {
				byte [] buffer = new byte[size];
				System.arraycopy(targetBuffer, 0, buffer, 0, size);
				return buffer;
			}
			return targetBuffer;
		} catch (IOException e) {}
		
		return new byte[0];
	}
}
",True,23,2,1,5,6,1,3,L7
50,org.geometerplus.fbreader.formats.plucker.ZCompressedFileImage.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.formats.plucker;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.zip.DataFormatException;
import java.util.zip.Inflater;

import org.geometerplus.zlibrary.core.image.ZLSingleImage;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

public class ZCompressedFileImage extends ZLSingleImage {
	private final ZLFile myFile;
	private final int myOffset;
	private final int myCompressedSize;
	
	public ZCompressedFileImage(String mimeType, final ZLFile file, final int offset, final int compressedSize) {
		super(mimeType);
		myFile = file;
		myOffset = offset;
		myCompressedSize = compressedSize;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	public byte[] byteData() {
		try {
			final InputStream stream = myFile.getInputStream();
			if (stream == null) {
				return new byte[0];
			}
			
			final ArrayList<byte[]> data = new ArrayList<byte[]>();
			byte[] buffer;
			int sizeOfBufferData;

			stream.skip(myOffset);
			byte [] targetBuffer = new byte[myCompressedSize];
			stream.read(targetBuffer, 0, myCompressedSize);
			Inflater decompressor = new Inflater();
			decompressor.setInput(targetBuffer, 0, myCompressedSize);
			do {
				buffer = new byte[4096];
				sizeOfBufferData = decompressor.inflate(buffer);
				data.add(buffer);
			} while (sizeOfBufferData == 4096);
			decompressor.end();
			final int dataSizeMinus1 = data.size() - 1;
			buffer = new byte[dataSizeMinus1 * 4096 + sizeOfBufferData];
			for (int i = 0; i < dataSizeMinus1; ++i) {
				System.arraycopy(data.get(i), 0, buffer, i * 4096, 4096);
			}
			System.arraycopy(data.get(dataSizeMinus1), 0, buffer, dataSizeMinus1 * 4096, sizeOfBufferData);
			return buffer;
		} catch (IOException e) {
		} catch (DataFormatException e) {
		}
		return new byte[0];
	}
}
",True,22,2,1,5,6,1,2,L7
51,org.geometerplus.fbreader.library.SeriesInfo.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class SeriesInfo {
	public final String Name;
	public final long Index;

	public SeriesInfo(String name, long index) {
		Name = name;
		Index = index;
	}
}
",False,146,11,39,0,0,7,0,L4
52,org.geometerplus.fbreader.library.BookInSeriesTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.fbreader.tree.FBTree;

public final class BookInSeriesTree extends BookTree {
	BookInSeriesTree(LibraryTree parent, Book book) {
		super(parent, book, false);
	}

	@Override
	public int compareTo(FBTree tree) {
		if (tree instanceof BookInSeriesTree) {
			final long difference =
				Book.getSeriesInfo().Index - ((BookTree)tree).Book.getSeriesInfo().Index;
			if (difference != 0) {
				return (int)difference;
			}
		}
		return super.compareTo(tree);
	}
}
",False,149,0,0,7,45,1,5,L5
53,org.geometerplus.fbreader.library.BooksDatabase.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.zlibrary.text.view.ZLTextPosition;

public abstract class BooksDatabase {
	private static BooksDatabase ourInstance;

	public static BooksDatabase Instance() {
		return ourInstance;
	}

	protected BooksDatabase() {
		ourInstance = this;
	}

	protected Book createBook(long id, long fileId, String title, String encoding, String language) {
		final FileInfoSet infos = new FileInfoSet(fileId);
		return createBook(id, infos.getFile(fileId), title, encoding, language);
	}
	protected Book createBook(long id, ZLFile file, String title, String encoding, String language) {
		return (file != null) ? new Book(id, file, title, encoding, language) : null;
	}
	protected void addAuthor(Book book, Author author) {
		book.addAuthorWithNoCheck(author);
	}
	protected void addTag(Book book, Tag tag) {
		book.addTagWithNoCheck(tag);
	}
	protected void setSeriesInfo(Book book, String series, long index) {
		book.setSeriesInfoWithNoCheck(series, index);
	}

	protected abstract void executeAsATransaction(Runnable actions);

	// returns map fileId -> book
	protected abstract Map<Long,Book> loadBooks(FileInfoSet infos);
	protected abstract Book loadBook(long bookId);
	protected abstract void reloadBook(Book book);
	protected abstract Book loadBookByFile(long fileId, ZLFile file);

	protected abstract List<Author> loadAuthors(long bookId);
	protected abstract List<Tag> loadTags(long bookId);
	protected abstract SeriesInfo loadSeriesInfo(long bookId);
	protected abstract void updateBookInfo(long bookId, long fileId, String encoding, String language, String title);
	protected abstract long insertBookInfo(ZLFile file, String encoding, String language, String title);
	protected abstract void deleteAllBookAuthors(long bookId);
	protected abstract void saveBookAuthorInfo(long bookId, long index, Author author);
	protected abstract void deleteAllBookTags(long bookId);
	protected abstract void saveBookTagInfo(long bookId, Tag tag);
	protected abstract void saveBookSeriesInfo(long bookId, SeriesInfo seriesInfo);

	protected FileInfo createFileInfo(long id, String name, FileInfo parent) {
		return new FileInfo(name, parent, id);
	}

	protected abstract Collection<FileInfo> loadFileInfos();
	protected abstract Collection<FileInfo> loadFileInfos(ZLFile file);
	protected abstract Collection<FileInfo> loadFileInfos(long fileId);
	protected abstract void removeFileInfo(long fileId);
	protected abstract void saveFileInfo(FileInfo fileInfo);

	protected abstract List<Long> loadRecentBookIds();
	protected abstract void saveRecentBookIds(final List<Long> ids);

	protected abstract List<Long> loadFavoritesIds();
	protected abstract void addToFavorites(long bookId);
	protected abstract void removeFromFavorites(long bookId);

	protected Bookmark createBookmark(long id, long bookId, String bookTitle, String text, Date creationDate, Date modificationDate, Date accessDate, int accessCounter, String modelId, int paragraphIndex, int wordIndex, int charIndex, boolean isVisible) {
		return new Bookmark(id, bookId, bookTitle, text, creationDate, modificationDate, accessDate, accessCounter, modelId, paragraphIndex, wordIndex, charIndex, isVisible);
	}

	protected abstract List<Bookmark> loadBookmarks(long bookId, boolean isVisible);
	protected abstract List<Bookmark> loadAllVisibleBookmarks();
	protected abstract long saveBookmark(Bookmark bookmark);
	protected abstract void deleteBookmark(Bookmark bookmark);

	protected abstract ZLTextPosition getStoredPosition(long bookId);
	protected abstract void storePosition(long bookId, ZLTextPosition position);

	protected abstract boolean insertIntoBookList(long bookId);
	protected abstract boolean deleteFromBookList(long bookId);
	protected abstract boolean checkBookList(long bookId);
}
",False,207,5,23,7,35,10,9,L4
54,org.geometerplus.fbreader.library.Book.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.text.view.ZLTextPosition;

import org.geometerplus.fbreader.formats.*;

import org.geometerplus.fbreader.Paths;

public class Book {
	public static Book getById(long bookId) {
		final Book book = BooksDatabase.Instance().loadBook(bookId);
		if (book == null) {
			return null;
		}
		book.loadLists();

		final ZLFile bookFile = book.File;
		final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
		if (physicalFile == null) {
			return book;
		}
		if (!physicalFile.exists()) {
			return null;
		}

		FileInfoSet fileInfos = new FileInfoSet(physicalFile);
		if (fileInfos.check(physicalFile, physicalFile != bookFile)) {
			return book;
		}
		fileInfos.save();

		return book.readMetaInfo() ? book : null;
	}

	public static Book getByFile(ZLFile bookFile) {
		if (bookFile == null) {
			return null;
		}

		final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
		if (physicalFile != null && !physicalFile.exists()) {
			return null;
		}

		final FileInfoSet fileInfos = new FileInfoSet(bookFile);

		Book book = BooksDatabase.Instance().loadBookByFile(fileInfos.getId(bookFile), bookFile);
		if (book != null) {
			book.loadLists();
		}

		if (book != null && fileInfos.check(physicalFile, physicalFile != bookFile)) {
			return book;
		}
		fileInfos.save();

		if (book == null) {
			book = new Book(bookFile);
		}
		if (book.readMetaInfo()) {
			book.save();
			return book;
		}
		return null;
	}

	public final ZLFile File;

	private long myId;

	private String myEncoding;
	private String myLanguage;
	private String myTitle;
	private List<Author> myAuthors;
	private List<Tag> myTags;
	private SeriesInfo mySeriesInfo;

	private boolean myIsSaved;

	Book(long id, ZLFile file, String title, String encoding, String language) {
		myId = id;
		File = file;
		myTitle = title;
		myEncoding = encoding;
		myLanguage = language;
		myIsSaved = true;
	}

	Book(ZLFile file) {
		myId = -1;
		File = file;
	}

	public void reloadInfoFromFile() {
		if (readMetaInfo()) {
			save();
		}
	}

	public void reloadInfoFromDatabase() {
		final BooksDatabase database = BooksDatabase.Instance();
		database.reloadBook(this);
		myAuthors = database.loadAuthors(myId);
		myTags = database.loadTags(myId);
		mySeriesInfo = database.loadSeriesInfo(myId);
		myIsSaved = true;
	}

	boolean readMetaInfo() {
		final FormatPlugin plugin = PluginCollection.Instance().getPlugin(File);
		if ((plugin == null) || !plugin.readMetaInfo(this)) {
			return false;
		}
		if ((myTitle == null) || (myTitle.length() == 0)) {
			final String fileName = File.getShortName();
			final int index = fileName.lastIndexOf('.');
			setTitle(index > 0 ? fileName.substring(0, index) : fileName);
		}
		final String demoPathPrefix = Paths.BooksDirectoryOption().getValue() + java.io.File.separator + ""Demos"" + java.io.File.separator;
		if (File.getPath().startsWith(demoPathPrefix)) {
			final String demoTag = ZLResource.resource(""library"").getResource(""demo"").getValue();
			setTitle(getTitle() + "" ("" + demoTag + "")"");
			addTag(demoTag);
		}
		return true;
	}

	private void loadLists() {
		final BooksDatabase database = BooksDatabase.Instance();
		myAuthors = database.loadAuthors(myId);
		myTags = database.loadTags(myId);
		mySeriesInfo = database.loadSeriesInfo(myId);
		myIsSaved = true;
	}

	public List<Author> authors() {
		return (myAuthors != null) ? Collections.unmodifiableList(myAuthors) : Collections.<Author>emptyList();
	}

	void addAuthorWithNoCheck(Author author) {
		if (myAuthors == null) {
			myAuthors = new ArrayList<Author>();
		}
		myAuthors.add(author);
	}

	private void addAuthor(Author author) {
		if (author == null) {
			return;
		}
		if (myAuthors == null) {
			myAuthors = new ArrayList<Author>();
			myAuthors.add(author);
			myIsSaved = false;
		} else if (!myAuthors.contains(author)) {
			myAuthors.add(author);
			myIsSaved = false;
		}
	}

	public void addAuthor(String name) {
		addAuthor(name, """");
	}

	public void addAuthor(String name, String sortKey) {
		String strippedName = name;
		strippedName.trim();
		if (strippedName.length() == 0) {
			return;
		}

		String strippedKey = sortKey;
		strippedKey.trim();
		if (strippedKey.length() == 0) {
			int index = strippedName.lastIndexOf(' ');
			if (index == -1) {
				strippedKey = strippedName;
			} else {
				strippedKey = strippedName.substring(index + 1);
				while ((index >= 0) && (strippedName.charAt(index) == ' ')) {
					--index;
				}
				strippedName = strippedName.substring(0, index + 1) + ' ' + strippedKey;
			}
		}

		addAuthor(new Author(strippedName, strippedKey));
	}

	public long getId() {
		return myId;
	}

	public String getTitle() {
		return myTitle;
	}

	public void setTitle(String title) {
		if (!ZLMiscUtil.equals(myTitle, title)) {
			myTitle = title;
			myIsSaved = false;
		}
	}

	public SeriesInfo getSeriesInfo() {
		return mySeriesInfo;
	}

	void setSeriesInfoWithNoCheck(String name, long index) {
		mySeriesInfo = new SeriesInfo(name, index);
	}

	public void setSeriesInfo(String name, long index) {
		if (mySeriesInfo == null) {
			if (name != null) {
				mySeriesInfo = new SeriesInfo(name, index);
				myIsSaved = false;
			}
		} else if (name == null) {
			mySeriesInfo = null;
			myIsSaved = false;
		} else if (!mySeriesInfo.Name.equals(name) || (mySeriesInfo.Index != index)) {
			mySeriesInfo = new SeriesInfo(name, index);
			myIsSaved = false;
		}
	}

	public String getLanguage() {
		return myLanguage;
	}

	public void setLanguage(String language) {
		if (!ZLMiscUtil.equals(myLanguage, language)) {
			myLanguage = language;
			myIsSaved = false;
		}
	}

	public String getEncoding() {
		return myEncoding;
	}

	public void setEncoding(String encoding) {
		if (!ZLMiscUtil.equals(myEncoding, encoding)) {
			myEncoding = encoding;
			myIsSaved = false;
		}
	}

	public List<Tag> tags() {
		return (myTags != null) ? Collections.unmodifiableList(myTags) : Collections.<Tag>emptyList();
	}

	void addTagWithNoCheck(Tag tag) {
		if (myTags == null) {
			myTags = new ArrayList<Tag>();
		}
		myTags.add(tag);
	}

	public void addTag(Tag tag) {
		if (tag != null) {
			if (myTags == null) {
				myTags = new ArrayList<Tag>();
			}
			if (!myTags.contains(tag)) {
				myTags.add(tag);
				myIsSaved = false;
			}
		}
	}

	public void addTag(String tagName) {
		addTag(Tag.getTag(null, tagName));
	}

	boolean matches(String pattern) {
		if ((myTitle != null) && ZLMiscUtil.matchesIgnoreCase(myTitle, pattern)) {
			return true;
		}
		if ((mySeriesInfo != null) && ZLMiscUtil.matchesIgnoreCase(mySeriesInfo.Name, pattern)) {
			return true;
		}
		if (myAuthors != null) {
			for (Author author : myAuthors) {
				if (ZLMiscUtil.matchesIgnoreCase(author.DisplayName, pattern)) {
					return true;
				}
			}
		}
		if (myTags != null) {
			for (Tag tag : myTags) {
				if (ZLMiscUtil.matchesIgnoreCase(tag.Name, pattern)) {
					return true;
				}
			}
		}
		return false;
	}

	public boolean save() {
		if (myIsSaved) {
			return false;
		}
		final BooksDatabase database = BooksDatabase.Instance();
		database.executeAsATransaction(new Runnable() {
			public void run() {
				if (myId >= 0) {
					final FileInfoSet fileInfos = new FileInfoSet(File);
					database.updateBookInfo(myId, fileInfos.getId(File), myEncoding, myLanguage, myTitle);
				} else {
					myId = database.insertBookInfo(File, myEncoding, myLanguage, myTitle);
				}

				long index = 0;
				database.deleteAllBookAuthors(myId);
				for (Author author : authors()) {
					database.saveBookAuthorInfo(myId, index++, author);
				}
				database.deleteAllBookTags(myId);
				for (Tag tag : tags()) {
					database.saveBookTagInfo(myId, tag);
				}
				database.saveBookSeriesInfo(myId, mySeriesInfo);
			}
		});

		myIsSaved = true;
		return true;
	}

	public ZLTextPosition getStoredPosition() {
		return BooksDatabase.Instance().getStoredPosition(myId);
	}

	public void storePosition(ZLTextPosition position) {
		if (myId != -1) {
			BooksDatabase.Instance().storePosition(myId, position);
		}
	}

	public void insertIntoBookList() {
		if (myId != -1) {
			BooksDatabase.Instance().insertIntoBookList(myId);
		}
	}

	@Override
	public int hashCode() {
		return (int)myId;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof Book)) {
			return false;
		}
		return myId == ((Book)o).myId;
	}
}
",True,210,5,33,6,45,32,14,L4
55,org.geometerplus.fbreader.library.Bookmark.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.text.view.*;

public final class Bookmark extends ZLTextFixedPosition {
	public final static int CREATION = 0;
	public final static int MODIFICATION = 1;
	public final static int ACCESS = 2;
	public final static int LATEST = 3;

	public static List<Bookmark> bookmarks() {
		return BooksDatabase.Instance().loadAllVisibleBookmarks();
	}

	public static List<Bookmark> invisibleBookmarks(Book book) {
		final List<Bookmark> list = BooksDatabase.Instance().loadBookmarks(book.getId(), false);
		Collections.sort(list, new ByTimeComparator());
		return list;
	}

	private long myId;
	private final long myBookId;
	private final String myBookTitle;
	private String myText;
	private final Date myCreationDate;
	private Date myModificationDate;
	private Date myAccessDate;
	private int myAccessCount;
	private Date myLatestDate;

	public final String ModelId;
	public final boolean IsVisible;

	private boolean myIsChanged;

	Bookmark(long id, long bookId, String bookTitle, String text, Date creationDate, Date modificationDate, Date accessDate, int accessCount, String modelId, int paragraphIndex, int elementIndex, int charIndex, boolean isVisible) {
		super(paragraphIndex, elementIndex, charIndex);

		myId = id;
		myBookId = bookId;
		myBookTitle = bookTitle;
		myText = text;
		myCreationDate = creationDate;
		myModificationDate = modificationDate;
		myLatestDate = (modificationDate != null) ? modificationDate : creationDate;
		if (accessDate != null) {
			myAccessDate = accessDate;
			if (myLatestDate.compareTo(accessDate) < 0) {
				myLatestDate = accessDate;
			}
		}
		myAccessCount = accessCount;
		ModelId = modelId;
		IsVisible = isVisible;
		myIsChanged = false;
	}

	public Bookmark(Book book, String modelId, ZLTextWordCursor cursor, int maxLength, boolean isVisible) {
		super(cursor);

		myId = -1;
		myBookId = book.getId();
		myBookTitle = book.getTitle();
		myText = createBookmarkText(cursor, maxLength);
		myCreationDate = new Date();
		ModelId = modelId;
		IsVisible = isVisible;
		myIsChanged = true;
	}

	public long getId() {
		return myId;
	}

	public long getBookId() {
		return myBookId;
	}

	public String getText() {
		return myText;
	}

	public String getBookTitle() {
		return myBookTitle;
	}

	public Date getTime(int timeStamp) {
		switch (timeStamp) {
			default:
			case CREATION:
				return myCreationDate;
			case MODIFICATION:
				return myModificationDate;
			case ACCESS:
				return myAccessDate;
			case LATEST:
				return myLatestDate;
		}
	}

	public int getAccessCount() {
		return myAccessCount;
	}

	public void setText(String text) {
		if (!text.equals(myText)) {
			myText = text;
			myModificationDate = new Date();
			myLatestDate = myModificationDate;
			myIsChanged = true;
		}
	}

	public void onOpen() {
		myAccessDate = new Date();
		++myAccessCount;
		myLatestDate = myAccessDate;
		myIsChanged = true;
	}

	public void save() {
		if (myIsChanged) {
			myId = BooksDatabase.Instance().saveBookmark(this);
			myIsChanged = false;
		}
	}

	public void delete() {
		if (myId != -1) {
			BooksDatabase.Instance().deleteBookmark(this);
		}
	}

	public static class ByTimeComparator implements Comparator<Bookmark> {
		public int compare(Bookmark bm0, Bookmark bm1) {
			return bm1.getTime(LATEST).compareTo(bm0.getTime(LATEST));
		}
	}

	private static String createBookmarkText(ZLTextWordCursor cursor, int maxWords) {
		cursor = new ZLTextWordCursor(cursor);

		final StringBuilder builder = new StringBuilder();
		final StringBuilder sentenceBuilder = new StringBuilder();
		final StringBuilder phraseBuilder = new StringBuilder();

		int wordCounter = 0;
		int sentenceCounter = 0;
		int storedWordCounter = 0;
		boolean lineIsNonEmpty = false;
		boolean appendLineBreak = false;
mainLoop:
		while (wordCounter < maxWords && sentenceCounter < 3) {
			while (cursor.isEndOfParagraph()) {
				if (!cursor.nextParagraph()) {
					break mainLoop;
				}
				if ((builder.length() > 0) && cursor.getParagraphCursor().isEndOfSection()) {
					break mainLoop;
				}
				if (phraseBuilder.length() > 0) {
					sentenceBuilder.append(phraseBuilder);
					phraseBuilder.delete(0, phraseBuilder.length());
				}
				if (sentenceBuilder.length() > 0) {
					if (appendLineBreak) {
						builder.append(""\n"");
					}
					builder.append(sentenceBuilder);
					sentenceBuilder.delete(0, sentenceBuilder.length());
					++sentenceCounter;
					storedWordCounter = wordCounter;
				}
				lineIsNonEmpty = false;
				if (builder.length() > 0) {
					appendLineBreak = true;
				}
			}
			final ZLTextElement element = cursor.getElement();
			if (element instanceof ZLTextWord) {
				final ZLTextWord word = (ZLTextWord)element;
				if (lineIsNonEmpty) {
					phraseBuilder.append("" "");
				}
				phraseBuilder.append(word.Data, word.Offset, word.Length);
				++wordCounter;
				lineIsNonEmpty = true;
				switch (word.Data[word.Offset + word.Length - 1]) {
					case ',':
					case ':':
					case ';':
					case ')':
						sentenceBuilder.append(phraseBuilder);
						phraseBuilder.delete(0, phraseBuilder.length());
						break;
					case '.':
					case '!':
					case '?':
						++sentenceCounter;
						if (appendLineBreak) {
							builder.append(""\n"");
							appendLineBreak = false;
						}
						sentenceBuilder.append(phraseBuilder);
						phraseBuilder.delete(0, phraseBuilder.length());
						builder.append(sentenceBuilder);
						sentenceBuilder.delete(0, sentenceBuilder.length());
						storedWordCounter = wordCounter;
						break;
				}
			}
			cursor.nextWord();
		}
		if (storedWordCounter < 4) {
			if (sentenceBuilder.length() == 0) {
				sentenceBuilder.append(phraseBuilder);
			}
			if (appendLineBreak) {
				builder.append(""\n"");
			}
			builder.append(sentenceBuilder);
		}
		return builder.toString();
	}
}
",False,198,6,31,7,32,4,7,L4
56,org.geometerplus.fbreader.library.FileInfo.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.tree.ZLTree;

public final class FileInfo extends ZLTree<FileInfo> {
	public final String Name;
	public long Id;
	public long FileSize = -1;

	FileInfo(String name, FileInfo parent) {
		this(name, parent, -1);
	}

	FileInfo(String name, FileInfo parent, long id) {
		super(parent);
		Name = name;
		Id = id;
	}
}
",False,147,12,40,1,1,3,1,L4
57,org.geometerplus.fbreader.library.Author.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class Author {
	public final String DisplayName;
	public final String SortKey;

	public Author(String displayName, String sortKey) {
		DisplayName = displayName;
		SortKey = sortKey;
	}
		
	public static int hashCode(Author author) {
		return author == null ? 0 : author.hashCode();
	}

	@Override
	public boolean equals(Object o) {
		if (o == this) {
			return true;
		}
		if (!(o instanceof Author)) {
			return false;
		}
		Author a = (Author)o;
		return SortKey.equals(a.SortKey) && DisplayName.equals(a.DisplayName);
	}

	@Override
	public int hashCode() {
		return SortKey.hashCode() + DisplayName.hashCode();
	}
}
",False,146,11,35,0,0,8,0,L4
58,org.geometerplus.fbreader.library.TagTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.resources.ZLResource;

public final class TagTree extends LibraryTree {
	public final Tag Tag;

	TagTree(LibraryTree parent, Tag tag) {
		super(parent);
		Tag = tag;
	}

	@Override
	public String getName() {
		return
			(Tag != null) ?
				Tag.Name :
				ZLResource.resource(""library"").getResource(""booksWithNoTags"").getValue();
	}

	protected String getSortKey() {
		return (Tag != null) ? Tag.Name : null;
	}
}
",False,193,8,18,7,44,3,3,L5
59,org.geometerplus.fbreader.library.BookTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.image.ZLImage;

public class BookTree extends LibraryTree {
	public final Book Book;
	private final boolean myShowAuthors;

	BookTree(LibraryTree parent, Book book, boolean showAuthors) {
		super(parent);
		Book = book;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return Book.getTitle();
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors) {
			return super.getSummary();
		}
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (Author author : Book.authors()) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(author.DisplayName);
			if (count == 5) {
				break;
			}
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		return Library.getCover(Book.File);
	}
}
",False,193,8,18,7,43,5,6,L5
60,org.geometerplus.fbreader.library.RootTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

final class RootTree extends LibraryTree {
	public String getName() {
		return null;
	}
}
",False,149,0,0,8,45,1,1,L5
61,org.geometerplus.fbreader.library.TitleTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class TitleTree extends LibraryTree {
	public final String Title;

	TitleTree(LibraryTree parent, String title) {
		super(parent);
		Title = title;
	}

	@Override
	public String getName() {
		return Title;
	}
}
",False,193,8,18,8,45,3,1,L5
62,org.geometerplus.fbreader.library.FileInfoSet.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.filesystem.*;

public final class FileInfoSet {
	private static final class Pair {
		private final String myName;
		private final FileInfo myParent;

		Pair(String name, FileInfo parent) {
			myName = name;
			myParent = parent;
		}

		@Override
		public int hashCode() {
			return (myParent == null) ? myName.hashCode() : myParent.hashCode() + myName.hashCode();
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof Pair)) {
				return false;
			}
			Pair p = (Pair)o;
			return (myName.equals(p.myName)) && ZLMiscUtil.equals(myParent, p.myParent);
		}
	}

	private final HashMap<ZLFile,FileInfo> myInfosByFile = new HashMap<ZLFile,FileInfo>();
	private final HashMap<FileInfo,ZLFile> myFilesByInfo = new HashMap<FileInfo,ZLFile>();
	private final HashMap<Pair,FileInfo> myInfosByPair = new HashMap<Pair,FileInfo>();
	private final HashMap<Long,FileInfo> myInfosById = new HashMap<Long,FileInfo>();

	private final LinkedHashSet<FileInfo> myInfosToSave = new LinkedHashSet<FileInfo>();
	private final LinkedHashSet<FileInfo> myInfosToRemove = new LinkedHashSet<FileInfo>();

	public FileInfoSet() {
		load(BooksDatabase.Instance().loadFileInfos());
	}

	public FileInfoSet(ZLFile file) {
		load(BooksDatabase.Instance().loadFileInfos(file));
	}

	FileInfoSet(long fileId) {
		load(BooksDatabase.Instance().loadFileInfos(fileId));
	}

	private void load(Collection<FileInfo> infos) {
		for (FileInfo info : infos) {
			myInfosByPair.put(new Pair(info.Name, info.Parent), info);
			myInfosById.put(info.Id, info);
		}
	}

	public void save() {
		final BooksDatabase database = BooksDatabase.Instance();
		database.executeAsATransaction(new Runnable() {
			public void run() {
				for (FileInfo info : myInfosToRemove) {
					database.removeFileInfo(info.Id);
					myInfosByPair.remove(new Pair(info.Name, info.Parent));
				}
				myInfosToRemove.clear();
				for (FileInfo info : myInfosToSave) {
					database.saveFileInfo(info);
				}
				myInfosToSave.clear();
			}
		});
	}

	public boolean check(ZLPhysicalFile file, boolean processChildren) {
		if (file == null) {
			return true;
		}
		final long fileSize = file.size();
		FileInfo info = get(file);
		if (info.FileSize == fileSize) {
			return true;
		} else {
			info.FileSize = fileSize;
			if (processChildren) {
				removeChildren(info);
				myInfosToSave.add(info);
				addChildren(file);
			} else {
				myInfosToSave.add(info);
			}
			return false;
		}
	}

	public List<ZLFile> archiveEntries(ZLFile file) {
		final FileInfo info = get(file);
		if (!info.hasChildren()) {
			return Collections.emptyList();
		}
		final LinkedList<ZLFile> entries = new LinkedList<ZLFile>();
		for (FileInfo child : info.subTrees()) {
			if (!myInfosToRemove.contains(child)) {
				entries.add(ZLArchiveEntryFile.createArchiveEntryFile(file, child.Name));
			}
		}
		return entries;
	}

	private FileInfo get(String name, FileInfo parent) {
		final Pair pair = new Pair(name, parent);
		FileInfo info = myInfosByPair.get(pair);
		if (info == null) {
			info = new FileInfo(name, parent);
			myInfosByPair.put(pair, info);
			myInfosToSave.add(info);
		}
		return info;
	}


	private FileInfo get(ZLFile file) {
		if (file == null) {
			return null;
		}
		FileInfo info = myInfosByFile.get(file);
		if (info == null) {
			info = get(file.getLongName(), get(file.getParent()));
			myInfosByFile.put(file, info);
		}
		return info;
	}

	public long getId(ZLFile file) {
		final FileInfo info = get(file);
		if (info == null) {
			return -1;
		}
		if (info.Id == -1) {
			save();
		}
		return info.Id;
	}	

	private ZLFile getFile(FileInfo info) {
		if (info == null) {
			return null;
		}
		ZLFile file = myFilesByInfo.get(info);
		if (file == null) {
			file = ZLFile.createFile(getFile(info.Parent), info.Name);
			myFilesByInfo.put(info, file);
		}
		return file;
	}

	public ZLFile getFile(long id) {
		return getFile(myInfosById.get(id));
	}

	private void removeChildren(FileInfo info) {
		for (FileInfo child : info.subTrees()) {
			if (myInfosToSave.contains(child)) {
				myInfosToSave.remove(child);
			} else {
				myInfosToRemove.add(child);
			}
			removeChildren(child);
		}
	}

	private void addChildren(ZLFile file) {
		for (ZLFile child : file.children()) {
			final FileInfo info = get(child);
			if (myInfosToRemove.contains(info)) {
				myInfosToRemove.remove(info);
			} else {
				myInfosToSave.add(info);
			}
			addChildren(child);
		}
	}
}
",False,207,6,33,8,31,4,7,L4
63,org.geometerplus.fbreader.library.AuthorTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import org.geometerplus.zlibrary.core.resources.ZLResource;

public class AuthorTree extends LibraryTree {
	public final Author Author;

	AuthorTree(LibraryTree parent, Author author) {
		super(parent);
		Author = author;
	}

	SeriesTree createSeriesSubTree(String series) {
		return new SeriesTree(this, series);
	}

	@Override
	public String getName() {
		return
			(Author != null) ?
				Author.DisplayName :
				ZLResource.resource(""library"").getResource(""unknownAuthor"").getValue();
	}

	protected String getSortKey() {
		return (Author != null) ? Author.SortKey : null;
	}
}
",False,193,8,18,7,44,3,4,L5
64,org.geometerplus.fbreader.library.Library.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.io.File;
import java.io.PrintWriter;
import java.util.*;
import java.lang.ref.WeakReference;

import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

import org.geometerplus.fbreader.formats.FormatPlugin;
import org.geometerplus.fbreader.formats.PluginCollection;
import org.geometerplus.fbreader.Paths;

public final class Library {
	public static final int STATE_NOT_INITIALIZED = 0;
	public static final int STATE_FULLY_INITIALIZED = 1;

	private final LinkedList<Book> myBooks = new LinkedList<Book>();
	private final HashSet<Book> myExternalBooks = new HashSet<Book>();
	private final LibraryTree myLibraryByAuthor = new RootTree();
	private final LibraryTree myLibraryByTitle = new RootTree();
	private final LibraryTree myLibraryByTag = new RootTree();
	private final LibraryTree myRecentBooks = new RootTree();
	private final LibraryTree myFavorites = new RootTree();
	private LibraryTree mySearchResult = new RootTree();

	private volatile int myState = STATE_NOT_INITIALIZED;
	private volatile boolean myInterrupted = false;

	public Library() {
	}

	public boolean hasState(int state) {
		return myState >= state || myInterrupted;
	}

	public void waitForState(int state) {
		while (myState < state && !myInterrupted) {
			synchronized(this) {
				if (myState < state && !myInterrupted) {
					try {
						wait();
					} catch (InterruptedException e) {
					}
				}
			}
		}
	}

	public static ZLResourceFile getHelpFile() {
		final ZLResourceFile file = ZLResourceFile.createResourceFile(
			""data/help/MiniHelp."" + Locale.getDefault().getLanguage() + "".fb2""
		);
		if (file.exists()) {
			return file;
		}

		return ZLResourceFile.createResourceFile(""data/help/MiniHelp.en.fb2"");
	}

	private static Book getBook(ZLFile bookFile, FileInfoSet fileInfos, Map<Long,Book> saved, boolean doReadMetaInfo) {
		Book book = saved.remove(fileInfos.getId(bookFile));
		if (book == null) {
			doReadMetaInfo = true;
			book = new Book(bookFile);
		}

		if (doReadMetaInfo && !book.readMetaInfo()) {
			return null;
		}
		return book;
	}

	private void collectBooks(
		ZLFile file,
		FileInfoSet fileInfos,
		Map<Long,Book> savedBooks,
		boolean doReadMetaInfo
	) {
		Book book = getBook(file, fileInfos, savedBooks, doReadMetaInfo);
		if (book != null) {
			myBooks.add(book);
		} else if (file.isArchive()) {
			for (ZLFile entry : fileInfos.archiveEntries(file)) {
				collectBooks(entry, fileInfos, savedBooks, doReadMetaInfo);
			}
		}
	}

	private void collectExternalBooks(FileInfoSet fileInfos, Map<Long,Book> savedBooks) {
		final HashSet<ZLPhysicalFile> myUpdatedFiles = new HashSet<ZLPhysicalFile>();
		final HashSet<Long> files = new HashSet<Long>(savedBooks.keySet());
		for (Long fileId: files) {
			final ZLFile bookFile = fileInfos.getFile(fileId);
			if (bookFile == null) {
				continue;
			}
			final ZLPhysicalFile physicalFile = bookFile.getPhysicalFile();
			if (physicalFile == null || !physicalFile.exists()) {
				continue;
			}
			boolean reloadMetaInfo = false; 
			if (myUpdatedFiles.contains(physicalFile)) {
				reloadMetaInfo = true;
			} else if (!fileInfos.check(physicalFile, physicalFile != bookFile)) {
				reloadMetaInfo = true;
				myUpdatedFiles.add(physicalFile);
			}
			final Book book = getBook(bookFile, fileInfos, savedBooks, reloadMetaInfo);
			if (book == null) {
				continue;
			}
			final long bookId = book.getId();
			if (bookId != -1 && BooksDatabase.Instance().checkBookList(bookId)) {
				myBooks.add(book);
				myExternalBooks.add(book);
			}
		}
	}

	private List<ZLPhysicalFile> collectPhysicalFiles() {
		final Queue<ZLFile> dirQueue = new LinkedList<ZLFile>();
		final HashSet<ZLFile> dirSet = new HashSet<ZLFile>();
		final LinkedList<ZLPhysicalFile> fileList = new LinkedList<ZLPhysicalFile>();

		dirQueue.offer(new ZLPhysicalFile(new File(Paths.BooksDirectoryOption().getValue())));

		while (!dirQueue.isEmpty()) {
			for (ZLFile file : dirQueue.poll().children()) {
				if (file.isDirectory()) {
					if (!dirSet.contains(file)) {
						dirQueue.add(file);
						dirSet.add(file);
					}
				} else {
					file.setCached(true);
					fileList.add((ZLPhysicalFile)file);
				}
			}
		}
		return fileList;
	}

	private void collectBooks() {
		final List<ZLPhysicalFile> physicalFilesList = collectPhysicalFiles();

		FileInfoSet fileInfos = new FileInfoSet();

		final Map<Long,Book> savedBooks = BooksDatabase.Instance().loadBooks(fileInfos);

		for (ZLPhysicalFile file : physicalFilesList) {
			// TODO: better value for this flag
			final boolean flag = !""epub"".equals(file.getExtension());
			collectBooks(file, fileInfos, savedBooks, !fileInfos.check(file, flag));
			file.setCached(false);
		}
		final Book helpBook = getBook(getHelpFile(), fileInfos, savedBooks, false);
		if (helpBook != null) {
			myBooks.add(helpBook);
		}

		collectExternalBooks(fileInfos, savedBooks);

		fileInfos.save();
	}

	private static class AuthorSeriesPair {
		private final Author myAuthor;
		private final String mySeries;

		AuthorSeriesPair(Author author, String series) {
			myAuthor = author;
			mySeries = series;
		}

		public boolean equals(Object object) {
			if (this == object) {
				return true;
			}
			if (!(object instanceof AuthorSeriesPair)) {
				return false;
			}
			AuthorSeriesPair pair = (AuthorSeriesPair)object;
			return ZLMiscUtil.equals(myAuthor, pair.myAuthor) && mySeries.equals(pair.mySeries);
		}

		public int hashCode() {
			return Author.hashCode(myAuthor) + mySeries.hashCode();
		}
	}

	private final ArrayList myNullList = new ArrayList(1);
	{
		myNullList.add(null);
	}

	private TagTree getTagTree(Tag tag, HashMap<Tag,TagTree> tagTreeMap) {
		TagTree tagTree = tagTreeMap.get(tag);
		if (tagTree == null) {
			LibraryTree parent =
				((tag != null) && (tag.Parent != null)) ?
					getTagTree(tag.Parent, tagTreeMap) : myLibraryByTag;
			tagTree = parent.createTagSubTree(tag);
			tagTreeMap.put(tag, tagTree);
		}
		return tagTree;
	}

	private void build() {
		final HashMap<Tag,TagTree> tagTreeMap = new HashMap<Tag,TagTree>();
		final HashMap<Author,AuthorTree> authorTreeMap = new HashMap<Author,AuthorTree>();
		final HashMap<AuthorSeriesPair,SeriesTree> seriesTreeMap = new HashMap<AuthorSeriesPair,SeriesTree>();
		final HashMap<Long,Book> bookById = new HashMap<Long,Book>();

		collectBooks();

		for (Book book : myBooks) {
			bookById.put(book.getId(), book);
			List<Author> authors = book.authors();
			if (authors.isEmpty()) {
				authors = (List<Author>)myNullList;
			}
			final SeriesInfo seriesInfo = book.getSeriesInfo();
			for (Author a : authors) {
				AuthorTree authorTree = authorTreeMap.get(a);
				if (authorTree == null) {
					authorTree = myLibraryByAuthor.createAuthorSubTree(a);
					authorTreeMap.put(a, authorTree);
				}
				if (seriesInfo == null) {
					authorTree.createBookSubTree(book, false);
				} else {
					final String series = seriesInfo.Name;
					final AuthorSeriesPair pair = new AuthorSeriesPair(a, series);
					SeriesTree seriesTree = seriesTreeMap.get(pair);
					if (seriesTree == null) {
						seriesTree = authorTree.createSeriesSubTree(series);
						seriesTreeMap.put(pair, seriesTree);
					}
					seriesTree.createBookInSeriesSubTree(book);
				}
			}

			List<Tag> tags = book.tags();
			if (tags.isEmpty()) {
				tags = (List<Tag>)myNullList;
			}
			for (Tag t : tags) {
				getTagTree(t, tagTreeMap).createBookSubTree(book, true);
			}
		}

		boolean doGroupTitlesByFirstLetter = false;
		if (myBooks.size() > 10) {
			final HashSet<Character> letterSet = new HashSet<Character>();
			for (Book book : myBooks) {
				String title = book.getTitle();
				if (title != null) {
					title = title.trim();
					if (!"""".equals(title)) {
						letterSet.add(title.charAt(0));
					}
				}
			}
			doGroupTitlesByFirstLetter = letterSet.size() > myBooks.size() + 4;
		}
		if (doGroupTitlesByFirstLetter) {
			final HashMap<Character,TitleTree> letterTrees = new HashMap<Character,TitleTree>();
			for (Book book : myBooks) {
				String title = book.getTitle();
				if (title == null) {
					continue;
				}
				title = title.trim();
				if ("""".equals(title)) {
					continue;
				}
				Character c = title.charAt(0);
				TitleTree tree = letterTrees.get(c);
				if (tree == null) {
					tree = myLibraryByTitle.createTitleSubTree(c.toString());
					letterTrees.put(c, tree);
				}
				tree.createBookSubTree(book, true);
			}
		} else {
			for (Book book : myBooks) {
				myLibraryByTitle.createBookSubTree(book, true);
			}
		}

		final BooksDatabase db = BooksDatabase.Instance();
		for (long id : db.loadRecentBookIds()) {
			Book book = bookById.get(id);
			if (book != null) {
				myRecentBooks.createBookSubTree(book, true);
			}
		}

		for (long id : db.loadFavoritesIds()) {
			Book book = bookById.get(id);
			if (book != null) {
				myFavorites.createBookSubTree(book, true);
			}
		}

		myFavorites.sortAllChildren();
		myLibraryByAuthor.sortAllChildren();
		myLibraryByTitle.sortAllChildren();
		myLibraryByTag.sortAllChildren();

		db.executeAsATransaction(new Runnable() {
			public void run() {
				for (Book book : myBooks) {
					book.save();
				}
			}
		});

		myState = STATE_FULLY_INITIALIZED;
	}

	public synchronized void synchronize() {
		if (myState == STATE_NOT_INITIALIZED) {
			try {
				myInterrupted = false;
				build();
			} catch (Throwable t) {
				myInterrupted = true;
			}
			notifyAll();
		}
	}

	public LibraryTree byAuthor() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myLibraryByAuthor;
	}

	public LibraryTree byTitle() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myLibraryByTitle;
	}

	public LibraryTree byTag() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myLibraryByTag;
	}

	public LibraryTree recentBooks() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myRecentBooks;
	}

	public static Book getRecentBook() {
		List<Long> recentIds = BooksDatabase.Instance().loadRecentBookIds();
		return (recentIds.size() > 0) ? Book.getById(recentIds.get(0)) : null;
	}

	public static Book getPreviousBook() {
		List<Long> recentIds = BooksDatabase.Instance().loadRecentBookIds();
		return (recentIds.size() > 1) ? Book.getById(recentIds.get(1)) : null;
	}

	public LibraryTree favorites() {
		waitForState(STATE_FULLY_INITIALIZED);
		return myFavorites;
	}

	public LibraryTree searchResults() {
		return mySearchResult;
	}

	public LibraryTree searchBooks(String pattern) {
		waitForState(STATE_FULLY_INITIALIZED);
		final RootTree newSearchResults = new RootTree();
		if (pattern != null) {
			pattern = pattern.toLowerCase();
			for (Book book : myBooks) {
				if (book.matches(pattern)) {
					newSearchResults.createBookSubTree(book, true);
				}
			}
			newSearchResults.sortAllChildren();
			if (newSearchResults.hasChildren()) {
				mySearchResult = newSearchResults;
			}
		}
		return newSearchResults;
	}

	public static void addBookToRecentList(Book book) {
		final BooksDatabase db = BooksDatabase.Instance();
		final List<Long> ids = db.loadRecentBookIds();
		final Long bookId = book.getId();
		ids.remove(bookId);
		ids.add(0, bookId);
		if (ids.size() > 12) {
			ids.remove(12);
		}
		db.saveRecentBookIds(ids);
	}

	public boolean isBookInFavorites(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		return myFavorites.containsBook(book);
	}

	public void addBookToFavorites(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		if (!myFavorites.containsBook(book)) {
			myFavorites.createBookSubTree(book, true);
			myFavorites.sortAllChildren();
			BooksDatabase.Instance().addToFavorites(book.getId());
		}
	}

	public void removeBookFromFavorites(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		if (myFavorites.removeBook(book)) {
			BooksDatabase.Instance().removeFromFavorites(book.getId());
		}
	}

	public static final int REMOVE_DONT_REMOVE = 0x00;
	public static final int REMOVE_FROM_LIBRARY = 0x01;
	public static final int REMOVE_FROM_DISK = 0x02;
	public static final int REMOVE_FROM_LIBRARY_AND_DISK = REMOVE_FROM_LIBRARY | REMOVE_FROM_DISK;

	public int getRemoveBookMode(Book book) {
		waitForState(STATE_FULLY_INITIALIZED);
		return (myExternalBooks.contains(book) ? REMOVE_FROM_LIBRARY : REMOVE_DONT_REMOVE)
			| (canDeleteBookFile(book) ? REMOVE_FROM_DISK : REMOVE_DONT_REMOVE);
	}

	private boolean canDeleteBookFile(Book book) {
		ZLFile file = book.File;
		if (file.getPhysicalFile() == null) {
			return false;
		}
		while (file instanceof ZLArchiveEntryFile) {
			file = file.getParent();
			if (file.children().size() != 1) {
				return false;
			}
		}
		return true;
	}

	public void removeBook(Book book, int removeMode) {
		if (removeMode == REMOVE_DONT_REMOVE) {
			return;
		}
		waitForState(STATE_FULLY_INITIALIZED);
		myBooks.remove(book);
		myLibraryByAuthor.removeBook(book);
		myLibraryByTag.removeBook(book);
		if (myRecentBooks.removeBook(book)) {
			final BooksDatabase db = BooksDatabase.Instance();
			final List<Long> ids = db.loadRecentBookIds();
			ids.remove(book.getId());
			db.saveRecentBookIds(ids);
		}
		mySearchResult.removeBook(book);
		myFavorites.removeBook(book);

		BooksDatabase.Instance().deleteFromBookList(book.getId());
		if ((removeMode & REMOVE_FROM_DISK) != 0) {
			book.File.getPhysicalFile().delete();
		}
	}

	private static final HashMap<String,WeakReference<ZLImage>> ourCoverMap =
		new HashMap<String,WeakReference<ZLImage>>();
	private static final WeakReference<ZLImage> NULL_IMAGE = new WeakReference<ZLImage>(null);

	public static ZLImage getCover(ZLFile file) {
		synchronized(ourCoverMap) {
			final String path = file.getPath();
			final WeakReference<ZLImage> ref = ourCoverMap.get(path);
			if (ref == NULL_IMAGE) {
				return null;
			} else if (ref != null) {
				final ZLImage image = ref.get();
				if (image != null) {
					return image;
				}
			}
			ZLImage image = null;
			final FormatPlugin plugin = PluginCollection.Instance().getPlugin(file);
			if (plugin != null) {
				image = plugin.readCover(file);
			}
			if (image == null) {
				ourCoverMap.put(path, NULL_IMAGE);
			} else {
				ourCoverMap.put(path, new WeakReference<ZLImage>(image));
			}
			return image;
		}
	}

	public static String getAnnotation(ZLFile file) {
		final FormatPlugin plugin = PluginCollection.Instance().getPlugin(file);
		return plugin != null ? plugin.readAnnotation(file) : null;
	}
}
",True,207,6,30,6,44,9,24,L5
65,org.geometerplus.fbreader.library.LibraryTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.*;

//import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.fbreader.tree.FBTree;

public abstract class LibraryTree extends FBTree {
	protected LibraryTree() {
		super();
	}

	protected LibraryTree(LibraryTree parent) {
		super(parent);
	}

	TagTree createTagSubTree(Tag tag) {
		return new TagTree(this, tag);
	}

	TitleTree createTitleSubTree(String title) {
		return new TitleTree(this, title);
	}

	AuthorTree createAuthorSubTree(Author author) {
		return new AuthorTree(this, author);
	}

	BookTree createBookSubTree(Book book, boolean showAuthors) {
		return new BookTree(this, book, showAuthors);
	}

	public boolean containsBook(Book book) {
		for (FBTree tree : this) {
			if ((tree instanceof BookTree) && ((BookTree)tree).Book.equals(book)) {
				return true;
			}
		}
		return false;
	}

	public boolean removeBook(Book book) {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();
		for (FBTree tree : this) {
			if ((tree instanceof BookTree) && ((BookTree)tree).Book.equals(book)) {
				toRemove.add(tree);
			}
		}
		for (FBTree tree : toRemove) {
			tree.removeSelf();
			FBTree parent = tree.Parent;
			for (; (parent != null) && !parent.hasChildren(); parent = parent.Parent) {
				parent.removeSelf();
			}
			for (; parent != null; parent = parent.Parent) {
				((LibraryTree)parent).invalidateChildren();
			}
		}
		return !toRemove.isEmpty();
	}
}
",False,193,8,18,7,45,9,9,L5
66,org.geometerplus.fbreader.library.SeriesTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

public final class SeriesTree extends LibraryTree {
	public final String Series;

	SeriesTree(LibraryTree parent, String series) {
		super(parent);
		Series = series;
	}

	@Override
	public String getName() {
		return Series;
	}

	BookTree createBookInSeriesSubTree(Book book) {
		return new BookInSeriesTree(this, book);
	}
}
",False,193,8,18,7,45,3,4,L5
67,org.geometerplus.fbreader.library.Tag.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.library;

import java.util.HashMap;

public final class Tag {
	private static final HashMap<Tag,Tag> ourTagSet = new HashMap<Tag,Tag>();

	public static Tag getTag(Tag parent, String name) {
		if (name == null) {
			return parent;
		}
		name = name.trim();
		if (name.length() == 0) {
			return parent;
		}
		Tag tag = new Tag(parent, name);
		Tag stored = ourTagSet.get(tag);
		if (stored != null) {
			return stored;
		}
		ourTagSet.put(tag, tag);
		return tag;
	}

	public final Tag Parent;
	public final String Name;

	private Tag(Tag parent, String name) {
		Parent = parent;
		Name = name;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof Tag)) {
			return false;
		}
		Tag t = (Tag)o;
		return (Parent == t.Parent) && Name.equals(t.Name);
	}

	@Override
	public int hashCode() {
		return (Parent == null) ? Name.hashCode() : Parent.hashCode() + Name.hashCode();
	}
}
",False,147,11,35,0,0,10,0,L4
68,org.geometerplus.fbreader.bookmodel.FBTextKind.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

public interface FBTextKind {
	byte REGULAR = 0;
	byte TITLE = 1;
	byte SECTION_TITLE = 2;
	byte POEM_TITLE = 3;
	byte SUBTITLE = 4;
	byte ANNOTATION = 5;
	byte EPIGRAPH = 6;
	byte STANZA = 7;
	byte VERSE = 8;
	byte PREFORMATTED = 9;
	byte IMAGE = 10;
	//byte END_OF_SECTION = 11;
	byte CITE = 12;
	byte AUTHOR = 13;
	byte DATE = 14;
	byte INTERNAL_HYPERLINK = 15;
	byte FOOTNOTE = 16;
	byte EMPHASIS = 17;
	byte STRONG = 18;
	byte SUB = 19;
	byte SUP = 20;
	byte CODE = 21;
	byte STRIKETHROUGH = 22;
	//byte CONTENTS_TABLE_ENTRY = 23;
	//byte LIBRARY_AUTHOR_ENTRY = 24;
	//byte LIBRARY_BOOK_ENTRY = 25;
	//byte RECENT_BOOK_LIST = 26;
	byte ITALIC = 27;
	byte BOLD = 28;
	byte DEFINITION = 29;
	byte DEFINITION_DESCRIPTION = 30;
	byte H1 = 31;
	byte H2 = 32;
	byte H3 = 33;
	byte H4 = 34;
	byte H5 = 35;
	byte H6 = 36;
	byte EXTERNAL_HYPERLINK = 37;
};
",False,146,8,35,0,0,10,0,L4
69,org.geometerplus.fbreader.bookmodel.TOCTree.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.text.model.ZLTextModel;

public class TOCTree extends ZLTree<TOCTree> {
	private String myText;
	private Reference myReference;

	protected TOCTree() {
		super();
	}

	public TOCTree(TOCTree parent) {
		super(parent);
	}

	public final String getText() {
		return myText;
	}

	public final void setText(String text) {
		myText = text;
	}
	
	public Reference getReference() {
		return myReference;
	}
	
	public void setReference(ZLTextModel model, int reference) {
		myReference = new Reference(reference, model);
	}

	public static class Reference {
		public final int ParagraphIndex;
		public final ZLTextModel Model;
		
		public Reference(final int paragraphIndex, final ZLTextModel model) {
			ParagraphIndex = paragraphIndex;
			Model = model;
		}
	}
}
",False,153,9,34,4,2,4,2,L4
70,org.geometerplus.fbreader.bookmodel.BookModel.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import java.util.*;

import org.geometerplus.zlibrary.core.image.*;

import org.geometerplus.zlibrary.text.model.*;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.formats.*;
import org.geometerplus.fbreader.Paths;

public final class BookModel {
	public static BookModel createModel(Book book) {
		FormatPlugin plugin = PluginCollection.Instance().getPlugin(book.File);
		if (plugin == null) {
			return null;
		}
		BookModel model = new BookModel(book);
		if (plugin.readModel(model)) {
			return model;
		}
		return null;
	}

	private final ZLImageMap myImageMap = new ZLImageMap(); 
	
	public final Book Book;
	public final ZLTextModel BookTextModel;
	public final TOCTree TOCTree = new TOCTree();

	private final HashMap<String,ZLTextModel> myFootnotes = new HashMap<String,ZLTextModel>();

	public static final class Label {
		public final String ModelId;
		public final int ParagraphIndex;
		
		public Label(String modelId, int paragraphIndex) {
			ModelId = modelId;
			ParagraphIndex = paragraphIndex;
		}
	}
	
	//private static String linksFileName(int index) {
	//	return Constants.CACHE_DIRECTORY + ""/links"" + index + "".cache"";
	//}

	private BookModel(Book book) {
		Book = book;
		BookTextModel = new ZLTextWritablePlainModel(null, book.getLanguage(), 1024, 65536, Paths.cacheDirectory(), ""cache"", myImageMap);
		//for (int i = 0; i < 50; ++i) {
		//	new File(linksFileName(i)).delete();
		//}
	}

	public ZLTextModel getFootnoteModel(String id) {
		ZLTextModel model = myFootnotes.get(id);
		if (model == null) {
			model = new ZLTextWritablePlainModel(id, Book.getLanguage(), 8, 512, Paths.cacheDirectory(), ""cache"" + myFootnotes.size(), myImageMap); 
			myFootnotes.put(id, model); 
		}
		return model;
	}
	
	private final CharStorage myInternalHyperlinks = new CachedCharStorage(32768, Paths.cacheDirectory(), ""links"");
	private char[] myCurrentLinkBlock;
	private int myCurrentLinkBlockOffset;

	void addHyperlinkLabel(String label, ZLTextModel model, int paragraphNumber) {
		final String modelId = model.getId();
		final int labelLength = label.length();
		final int idLength = (modelId != null) ? modelId.length() : 0;
		final int len = 4 + labelLength + idLength;

		/*
		try {
			final OutputStreamWriter writer =
				new OutputStreamWriter(
					new FileOutputStream(linksFileName(label.hashCode() % 50), true),
					""UTF-16LE""
				);
			writer.write(labelLength);
			writer.write(label);
			writer.write(idLength);
			if (idLength > 0) {
				writer.write(modelId);
			}
			writer.write(paragraphNumber >> 16);
			writer.write(paragraphNumber);
			writer.close();
		} catch (IOException e) {
		}
		*/

		char[] block = myCurrentLinkBlock;
		int offset = myCurrentLinkBlockOffset;
		if ((block == null) || (offset + len > block.length)) {
			if (block != null) {
				myInternalHyperlinks.freezeLastBlock();
			}
			block = myInternalHyperlinks.createNewBlock(len);
			myCurrentLinkBlock = block;
			offset = 0;
		}
		block[offset++] = (char)labelLength;
		label.getChars(0, labelLength, block, offset);
		offset += labelLength;
		block[offset++] = (char)idLength;
		if (idLength > 0) {
			modelId.getChars(0, idLength, block, offset);
			offset += idLength;
		}
		block[offset++] = (char)(paragraphNumber >> 16);
		block[offset++] = (char)paragraphNumber;
		myCurrentLinkBlockOffset = offset;
	}

	public Label getLabel(String id) {
		final int len = id.length();
		final int size = myInternalHyperlinks.size();
		/*
		try {
			final File file = new File(linksFileName(id.hashCode() % 50));
			if (!file.exists()) {
				return null;
			}
			final char[] block = new char[(int)file.length()];
			final InputStreamReader reader =
				new InputStreamReader(
					new FileInputStream(file),
					""UTF-16LE""
				);
			reader.read(block);
			reader.close();
			for (int offset = 0; offset < block.length; ) {
				final int labelLength = (int)block[offset++];
				if (labelLength == 0) {
					break;
				}
				final int idLength = (int)block[offset + labelLength];
				if ((labelLength != len) || !id.equals(new String(block, offset, labelLength))) {
					offset += labelLength + idLength + 3;
					continue;
				}
				offset += labelLength + 1;
				final String modelId = (idLength > 0) ? new String(block, offset, idLength) : null;
				offset += idLength;
				final int paragraphNumber = (((int)block[offset++]) << 16) + (int)block[offset];
				return new Label(modelId, paragraphNumber);
			}
		} catch (IOException e) {
		}
		*/
		for (int i = 0; i < size; ++i) {
			final char[] block = myInternalHyperlinks.block(i);
			for (int offset = 0; offset < block.length; ) {
				final int labelLength = (int)block[offset++];
				if (labelLength == 0) {
					break;
				}
				final int idLength = (int)block[offset + labelLength];
				if ((labelLength != len) || !id.equals(new String(block, offset, labelLength))) {
					offset += labelLength + idLength + 3;
					continue;
				}
				offset += labelLength + 1;
				final String modelId = (idLength > 0) ? new String(block, offset, idLength) : null;
				offset += idLength;
				final int paragraphNumber = (((int)block[offset++]) << 16) + (int)block[offset];
				return new Label(modelId, paragraphNumber);
			}
		}
		return null;
	}
	
	void addImage(String id, ZLImage image) {
		myImageMap.put(id, image);
	}
}
",False,202,5,26,6,34,23,11,L4
71,org.geometerplus.fbreader.bookmodel.BookReader.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

import org.geometerplus.zlibrary.core.util.*;

import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.CharsetDecoder;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.text.model.*;

public class BookReader {
	public final BookModel Model;

	private ZLTextWritableModel myCurrentTextModel = null;
	
	private boolean myTextParagraphExists = false;
	private boolean myTextParagraphIsNonEmpty = false;
	
	private char[] myTextBuffer = new char[4096];
	private int myTextBufferLength;
	private StringBuilder myContentsBuffer = new StringBuilder();

	private byte[] myKindStack = new byte[20];
	private int myKindStackSize;
	
	private byte myHyperlinkKind;
	private String myHyperlinkReference = """";
	
	private boolean myInsideTitle = false;
	private boolean mySectionContainsRegularContents = false;
	
	private TOCTree myCurrentContentsTree;

	private CharsetDecoder myByteDecoder;

	public BookReader(BookModel model) {
		Model = model;
		myCurrentContentsTree = model.TOCTree;
	}

	public final void setByteDecoder(CharsetDecoder decoder) {
		myByteDecoder = decoder;
	}
	
	private final void flushTextBufferToParagraph() {
		if (myTextBufferLength > 0) {
			myCurrentTextModel.addText(myTextBuffer, 0, myTextBufferLength);
			myTextBufferLength = 0;
			if (myByteDecoder != null) {
				myByteDecoder.reset();
			}
		}
	}
	
	public final void addControl(byte kind, boolean start) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addControl(kind, start);
		}
		if (!start && (myHyperlinkReference.length() != 0) && (kind == myHyperlinkKind)) {
			myHyperlinkReference = """";
		}
	}
	
	/*
	public final void addControl(ZLTextForcedControlEntry entry) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addControl(entry);
		}
	}
	*/
	
	public final void pushKind(byte kind) {
		byte[] stack = myKindStack;
		if (stack.length == myKindStackSize) {
			stack = ZLArrayUtils.createCopy(stack, myKindStackSize, myKindStackSize << 1);
			myKindStack = stack;
		}
		stack[myKindStackSize++] = kind;
	}
	
	public final boolean popKind() {
		if (myKindStackSize != 0) {
			--myKindStackSize;
			return true;
		}
		return false;
	}
	
	public final void beginParagraph() {
		beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
	}

	public final void beginParagraph(byte kind) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			textModel.createParagraph(kind);
			final byte[] stack = myKindStack;
			final int size = myKindStackSize;
			for (int i = 0; i < size; ++i) {
				textModel.addControl(stack[i], true);
			}
			if (myHyperlinkReference.length() != 0) {
				textModel.addHyperlinkControl(myHyperlinkKind, hyperlinkType(myHyperlinkKind), myHyperlinkReference);
			}
			myTextParagraphExists = true;
		}		
	}
	
	public final void endParagraph() {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myTextParagraphExists = false;
			myTextParagraphIsNonEmpty = false;
		}
	}
	
	private final void insertEndParagraph(byte kind) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if ((textModel != null) && mySectionContainsRegularContents) {
			int size = textModel.getParagraphsNumber();
			if ((size > 0) && (textModel.getParagraph(size-1).getKind() != kind)) {
				textModel.createParagraph(kind);
				mySectionContainsRegularContents = false;
			}
		}
	}
	
	public final void insertEndOfSectionParagraph() {
		insertEndParagraph(ZLTextParagraph.Kind.END_OF_SECTION_PARAGRAPH);
	}
	
/*	public final void insertEndOfTextParagraph() {
		insertEndParagraph(ZLTextParagraph.Kind.END_OF_TEXT_PARAGRAPH);
	}
*/	
	public final void unsetCurrentTextModel() {
		if (myCurrentTextModel != null) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = null;
	}
	
	public final void enterTitle() {
		myInsideTitle = true;
	}
	
	public final void exitTitle() {
		myInsideTitle = false;
	}
	
	public final void setMainTextModel() {
		if ((myCurrentTextModel != null) && (myCurrentTextModel != Model.BookTextModel)) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = (ZLTextWritableModel)Model.BookTextModel;
	}
	
	public final void setFootnoteTextModel(String id) {
		if ((myCurrentTextModel != null) && (myCurrentTextModel != Model.BookTextModel)) {
			myCurrentTextModel.stopReading();
		}
		myCurrentTextModel = (ZLTextWritableModel)Model.getFootnoteModel(id);
	}
	
	public final void addData(char[] data) {
		addData(data, 0, data.length, false);
	}

	public final void addData(char[] data, int offset, int length, boolean direct) {
		if (!myTextParagraphExists || (length == 0)) {
			return;
		}
		myTextParagraphIsNonEmpty = true;

		if (direct && (myTextBufferLength == 0) && !myInsideTitle) {
			myCurrentTextModel.addText(data, offset, length);
		} else {
			final int oldLength = myTextBufferLength;
			final int newLength = oldLength + length;
			if (myTextBuffer.length < newLength) {
				myTextBuffer = ZLArrayUtils.createCopy(myTextBuffer, oldLength, newLength);
			}
			System.arraycopy(data, offset, myTextBuffer, oldLength, length);
			myTextBufferLength = newLength;
			if (myInsideTitle) {
				addContentsData(myTextBuffer, oldLength, length);
			}
		}
		if (!myInsideTitle) {
			mySectionContainsRegularContents = true;
		}
	}

	private byte[] myUnderflowByteBuffer = new byte[4];
	private int myUnderflowLength;

	public final void addByteData(byte[] data, int start, int length) {
		if (!myTextParagraphExists || (length == 0)) {
			return;
		}
		myTextParagraphIsNonEmpty = true;

		final int oldLength = myTextBufferLength;
		if (myTextBuffer.length < oldLength + length) {
			myTextBuffer = ZLArrayUtils.createCopy(myTextBuffer, oldLength, oldLength + length);
		}
		final CharBuffer cb = CharBuffer.wrap(myTextBuffer, myTextBufferLength, length);

		if (myUnderflowLength > 0) {
			int l = myUnderflowLength;
			while (length-- > 0) {
				myUnderflowByteBuffer[l++] = data[start++];
				final ByteBuffer ubb = ByteBuffer.wrap(myUnderflowByteBuffer);
				myByteDecoder.decode(ubb, cb, false);
				if (cb.position() != oldLength) {
					myUnderflowLength = 0;
					break;
				}
			}
			if (length == 0) {
				myUnderflowLength = l;
				return;
			}
		}

		ByteBuffer bb = ByteBuffer.wrap(data, start, length);
		myByteDecoder.decode(bb, cb, false);
		myTextBufferLength = cb.position();
		int rem = bb.remaining();
		if (rem > 0) {
			for (int i = 0, j = start + length - rem; i < rem;) {
				myUnderflowByteBuffer[i++] = data[j++];
			}
			myUnderflowLength = rem;
		}

		if (myInsideTitle) {
			addContentsData(myTextBuffer, oldLength, myTextBufferLength - oldLength);
		} else {
			mySectionContainsRegularContents = true;
		}
	}
	
	private static byte hyperlinkType(byte kind) {
		return (kind == FBTextKind.EXTERNAL_HYPERLINK) ?
			FBHyperlinkType.EXTERNAL : FBHyperlinkType.INTERNAL;
	}

	public final void addHyperlinkControl(byte kind, String label) {
		if (myTextParagraphExists) {
			flushTextBufferToParagraph();
			myCurrentTextModel.addHyperlinkControl(kind, hyperlinkType(kind), label);
		}
		myHyperlinkKind = kind;
		myHyperlinkReference = label;
	}
	
	public final void addHyperlinkLabel(String label) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			int paragraphNumber = textModel.getParagraphsNumber();
			if (myTextParagraphExists) {
				--paragraphNumber;
			}
			Model.addHyperlinkLabel(label, textModel, paragraphNumber);
		}
	}
	
	public final void addHyperlinkLabel(String label, int paragraphIndex) {
		Model.addHyperlinkLabel(label, myCurrentTextModel, paragraphIndex);
	}
	
	public final void addContentsData(char[] data) {
		addContentsData(data, 0, data.length);
	}

	public final void addContentsData(char[] data, int offset, int length) {
		if ((length != 0) && (myCurrentContentsTree != null)) {
			myContentsBuffer.append(data, offset, length);
		}
	}
	
	public final void beginContentsParagraph(int referenceNumber) {
		beginContentsParagraph(Model.BookTextModel, referenceNumber);
	}

	public final void beginContentsParagraph(ZLTextModel bookTextModel, int referenceNumber) {
		final ZLTextModel textModel = myCurrentTextModel;
		if (textModel == bookTextModel) {
			if (referenceNumber == -1) {
				referenceNumber = textModel.getParagraphsNumber();
			}
			TOCTree parentTree = myCurrentContentsTree;
			if (parentTree.Level > 0) {
				if (myContentsBuffer.length() > 0) {
					parentTree.setText(myContentsBuffer.toString());
					myContentsBuffer.delete(0, myContentsBuffer.length());
				} else if (parentTree.getText() == null) {
					parentTree.setText(""..."");
				}
			} else {
				myContentsBuffer.delete(0, myContentsBuffer.length());
			}
			TOCTree tree = new TOCTree(parentTree);
			tree.setReference(myCurrentTextModel, referenceNumber);
			myCurrentContentsTree = tree;
		}
	}
	
	public final void endContentsParagraph() {
		final TOCTree tree = myCurrentContentsTree;
		if (tree.Level == 0) {
			myContentsBuffer.delete(0, myContentsBuffer.length());
			return;
		}
		if (myContentsBuffer.length() > 0) {
			tree.setText(myContentsBuffer.toString());
			myContentsBuffer.delete(0, myContentsBuffer.length());
		} else if (tree.getText() == null) {
			tree.setText(""..."");
		}
		myCurrentContentsTree = tree.Parent;
	}

	public final void setReference(int contentsParagraphNumber, int referenceNumber) {
		setReference(contentsParagraphNumber, myCurrentTextModel, referenceNumber);
	}
	
	public final void setReference(int contentsParagraphNumber, ZLTextWritableModel textModel, int referenceNumber) {
		final TOCTree contentsTree = Model.TOCTree;
		if (contentsParagraphNumber < contentsTree.getSize()) {
			contentsTree.getTreeByParagraphNumber(contentsParagraphNumber).setReference(
				textModel, referenceNumber
			);
		}
	}
	
	public final boolean paragraphIsOpen() {
		return myTextParagraphExists;
	}
	
	public boolean paragraphIsNonEmpty() {
		return myTextParagraphIsNonEmpty;
	}

	public final boolean contentsParagraphIsOpen() {
		return myCurrentContentsTree.Level > 0;
	}

	public final void beginContentsParagraph() {
		beginContentsParagraph(-1);
	}
	
	public final void addImageReference(String ref) {
		addImageReference(ref, (short)0);
	}

	public final void addImageReference(String ref, short vOffset) {
		final ZLTextWritableModel textModel = myCurrentTextModel;
		if (textModel != null) {
			mySectionContainsRegularContents = true;
			if (myTextParagraphExists) {
				flushTextBufferToParagraph();
				textModel.addImage(ref, vOffset);
			} else {
				beginParagraph(ZLTextParagraph.Kind.TEXT_PARAGRAPH);
				textModel.addControl(FBTextKind.IMAGE, true);
				textModel.addImage(ref, vOffset);
				textModel.addControl(FBTextKind.IMAGE, false);
				endParagraph();
			}
		}
	}

	public final void addImage(String id, ZLImage image) {
		Model.addImage(id, image);
	}

	public final void addFixedHSpace(short length) {
		if (myTextParagraphExists) {
			myCurrentTextModel.addFixedHSpace(length);
		}
	}
}
",False,141,2,1,7,32,16,10,L4
72,org.geometerplus.fbreader.bookmodel.FBHyperlinkType.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.bookmodel;

public interface FBHyperlinkType {
	byte NONE = 0;
	byte INTERNAL = 1;
	byte EXTERNAL = 2;
}
",False,146,9,34,0,0,3,0,L4
73,org.geometerplus.fbreader.fbreader.ScrollingPreferences.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.options.ZLEnumOption;
import org.geometerplus.zlibrary.core.view.ZLView;

public class ScrollingPreferences {
	private static ScrollingPreferences ourInstance;

	public static ScrollingPreferences Instance() {
		return (ourInstance != null) ? ourInstance : new ScrollingPreferences();
	}

	public enum FingerScrolling {
		byTap, byFlick, byTapAndFlick
	}
	public final ZLEnumOption<FingerScrolling> FingerScrollingOption =
		new ZLEnumOption<FingerScrolling>(""Scrolling"", ""Finger"", FingerScrolling.byTapAndFlick);

	public final ZLBooleanOption VolumeKeysOption =
		new ZLBooleanOption(""Scrolling"", ""VolumeKeys"", true);

	public final ZLEnumOption<ZLView.Animation> AnimationOption =
		new ZLEnumOption<ZLView.Animation>(""Scrolling"", ""Animation"", ZLView.Animation.slide);

	public final ZLBooleanOption HorizontalOption =
		new ZLBooleanOption(""Scrolling"", ""Horizontal"", true);
	public final ZLBooleanOption InvertVolumeKeysOption =
		new ZLBooleanOption(""Scrolling"", ""InvertVolumeKeys"", false);

	private ScrollingPreferences() {
		ourInstance = this;
	}
}
",False,85,7,23,7,6,4,3,L5
74,org.geometerplus.fbreader.fbreader.FindNextAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class FindNextAction extends FBAction {
	FindNextAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public boolean isEnabled() {
		FBView view = Reader.getTextView();
		return (view != null) && view.canFindNext();
	}

	public void run() {
		Reader.getTextView().findNext();
	}
}
",False,204,0,0,7,58,1,4,L5
75,org.geometerplus.fbreader.fbreader.ActionCode.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

public interface ActionCode {
	String SHOW_LIBRARY = ""library"";
	String SHOW_PREFERENCES = ""preferences"";
	String SHOW_BOOK_INFO = ""bookInfo"";
	String SHOW_CONTENTS = ""toc"";
	String SHOW_BOOKMARKS = ""bookmarks"";
	String SHOW_NETWORK_LIBRARY = ""networkLibrary"";

	String SWITCH_TO_NIGHT_PROFILE = ""night"";
	String SWITCH_TO_DAY_PROFILE = ""day"";

	String SEARCH = ""search"";
	String FIND_PREVIOUS = ""findPrevious"";
	String FIND_NEXT = ""findNext"";
	String CLEAR_FIND_RESULTS = ""clearFindResults"";

	String SET_TEXT_VIEW_MODE_VISIT_HYPERLINKS = ""hyperlinksOnlyMode"";
	String SET_TEXT_VIEW_MODE_VISIT_ALL_WORDS = ""dictionaryMode"";

	String TURN_PAGE_BACK = ""previousPage"";
	String TURN_PAGE_FORWARD = ""nextPage"";

	String VOLUME_KEY_SCROLL_FORWARD = ""volumeKeyScrollForward"";
	String VOLUME_KEY_SCROLL_BACK = ""volumeKeyScrollBackward"";
	String SHOW_MENU = ""menu"";
	String SHOW_NAVIGATION = ""navigate"";
	String CANCEL = ""cancel"";
	String ROTATE = ""rotate"";
	String INCREASE_FONT = ""increaseFont"";
	String DECREASE_FONT = ""decreaseFont"";

	String COPY_SELECTED_TEXT_TO_CLIPBOARD = ""copyToClipboard"";
	String CLEAR_SELECTION = ""clearSelection"";

	String PROCESS_HYPERLINK = ""processHyperlink"";
}
",False,59,5,30,0,0,4,0,L5
76,org.geometerplus.fbreader.fbreader.FBAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.application.ZLApplication;

public abstract class FBAction extends ZLApplication.ZLAction {
	protected final FBReaderApp Reader;

	public FBAction(FBReaderApp fbreader) {
		Reader = fbreader;
	}
}
",False,248,6,12,7,66,18,2,L5
77,org.geometerplus.fbreader.fbreader.FBReaderApp.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.*;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.filesystem.*;
import org.geometerplus.zlibrary.core.application.*;
import org.geometerplus.zlibrary.core.dialogs.ZLDialogManager;
import org.geometerplus.zlibrary.core.options.*;

import org.geometerplus.zlibrary.text.hyphenation.ZLTextHyphenator;
import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Library;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Bookmark;

public final class FBReaderApp extends ZLApplication {
	public final ZLBooleanOption AllowScreenBrightnessAdjustmentOption =
		new ZLBooleanOption(""LookNFeel"", ""AllowScreenBrightnessAdjustment"", true);
	public final ZLStringOption TextSearchPatternOption =
		new ZLStringOption(""TextSearch"", ""Pattern"", """");

	public final ZLBooleanOption UseSeparateBindingsOption =
		new ZLBooleanOption(""KeysOptions"", ""UseSeparateBindings"", false);

	public final ZLBooleanOption EnableDoubleTapOption =
		new ZLBooleanOption(""Options"", ""EnableDoubleTap"", false);
	public final ZLBooleanOption NavigateAllWordsOption =
		new ZLBooleanOption(""Options"", ""NavigateAllWords"", false);

	public enum DictionaryTappingAction {
		doNothing, selectWord, openDictionary
	}
	public final ZLEnumOption<DictionaryTappingAction> DictionaryTappingActionOption =
		new ZLEnumOption<DictionaryTappingAction>(""Options"", ""DictionaryTappingAction"", DictionaryTappingAction.selectWord);

	public final ZLIntegerRangeOption LeftMarginOption =
		new ZLIntegerRangeOption(""Options"", ""LeftMargin"", 0, 30, 4);
	public final ZLIntegerRangeOption RightMarginOption =
		new ZLIntegerRangeOption(""Options"", ""RightMargin"", 0, 30, 4);
	public final ZLIntegerRangeOption TopMarginOption =
		new ZLIntegerRangeOption(""Options"", ""TopMargin"", 0, 30, 0);
	public final ZLIntegerRangeOption BottomMarginOption =
		new ZLIntegerRangeOption(""Options"", ""BottomMargin"", 0, 30, 4);

	public final ZLIntegerRangeOption ScrollbarTypeOption =
		new ZLIntegerRangeOption(""Options"", ""ScrollbarType"", 0, 3, FBView.SCROLLBAR_SHOW_AS_FOOTER);
	public final ZLIntegerRangeOption FooterHeightOption =
		new ZLIntegerRangeOption(""Options"", ""FooterHeight"", 8, 20, 9);
	public final ZLBooleanOption FooterShowTOCMarksOption =
		new ZLBooleanOption(""Options"", ""FooterShowTOCMarks"", true);
	public final ZLIntegerRangeOption FooterLongTapOption =
		new ZLIntegerRangeOption(""Options"", ""FooterLongTap"", 0, 1, 0/*revert*/);
	public final ZLBooleanOption FooterShowClockOption =
		new ZLBooleanOption(""Options"", ""ShowClockInFooter"", true);
	public final ZLBooleanOption FooterShowBatteryOption =
		new ZLBooleanOption(""Options"", ""ShowBatteryInFooter"", true);
	public final ZLBooleanOption FooterShowProgressOption =
		new ZLBooleanOption(""Options"", ""ShowProgressInFooter"", true);
	public final ZLBooleanOption FooterIsSensitiveOption =
		new ZLBooleanOption(""Options"", ""FooterIsSensitive"", false);
	public final ZLStringOption FooterFontOption =
		new ZLStringOption(""Options"", ""FooterFont"", ""Droid Sans"");

	final ZLBooleanOption SelectionEnabledOption =
		new ZLBooleanOption(""Options"", ""IsSelectionEnabled"", true);

	final ZLStringOption ColorProfileOption =
		new ZLStringOption(""Options"", ""ColorProfile"", ColorProfile.DAY);

	private final ZLKeyBindings myBindings = new ZLKeyBindings(""Keys"");

	public final FBView BookTextView;
	public final FBView FootnoteView;

	public BookModel Model;

	private final String myArg0;

	public FBReaderApp(String arg) {
		myArg0 = arg;

		addAction(ActionCode.INCREASE_FONT, new ChangeFontSizeAction(this, +2));
		addAction(ActionCode.DECREASE_FONT, new ChangeFontSizeAction(this, -2));
		addAction(ActionCode.ROTATE, new RotateAction(this));

		addAction(ActionCode.FIND_NEXT, new FindNextAction(this));
		addAction(ActionCode.FIND_PREVIOUS, new FindPreviousAction(this));
		addAction(ActionCode.CLEAR_FIND_RESULTS, new ClearFindResultsAction(this));

		addAction(ActionCode.TURN_PAGE_FORWARD, new TurnPageAction(this, true));
		addAction(ActionCode.TURN_PAGE_BACK, new TurnPageAction(this, false));

		addAction(ActionCode.VOLUME_KEY_SCROLL_FORWARD, new VolumeKeyTurnPageAction(this, true));
		addAction(ActionCode.VOLUME_KEY_SCROLL_BACK, new VolumeKeyTurnPageAction(this, false));

		//addAction(ActionCode.COPY_SELECTED_TEXT_TO_CLIPBOARD, new DummyAction(this));
		//addAction(ActionCode.OPEN_SELECTED_TEXT_IN_DICTIONARY, new DummyAction(this));
		//addAction(ActionCode.CLEAR_SELECTION, new DummyAction(this));

		addAction(ActionCode.SWITCH_TO_DAY_PROFILE, new SwitchProfileAction(this, ColorProfile.DAY));
		addAction(ActionCode.SWITCH_TO_NIGHT_PROFILE, new SwitchProfileAction(this, ColorProfile.NIGHT));

		BookTextView = new FBView(this);
		FootnoteView = new FBView(this);

		setView(BookTextView);
	}

	public void initWindow() {
		super.initWindow();
		ZLDialogManager.Instance().wait(""loadingBook"", new Runnable() {
			public void run() {
				Book book = createBookForFile(ZLFile.createFileByPath(myArg0));
				if (book == null) {
					book = Library.getRecentBook();
				}
				if ((book == null) || !book.File.exists()) {
					book = Book.getByFile(Library.getHelpFile());
				}
				openBookInternal(book, null);
			}
		});
	}

	public void openBook(final Book book, final Bookmark bookmark) {
		if (book == null) {
			return;
		}
		if (Model != null) {
			if (bookmark == null & book.File.getPath().equals(Model.Book.File.getPath())) {
				return;
			}
		}
		ZLDialogManager.Instance().wait(""loadingBook"", new Runnable() {
			public void run() {
				openBookInternal(book, bookmark);
			}
		});
	}

	private ColorProfile myColorProfile;

	public ColorProfile getColorProfile() {
		if (myColorProfile == null) {
			myColorProfile = ColorProfile.get(getColorProfileName());
		}
		return myColorProfile;
	}

	public String getColorProfileName() {
		return ColorProfileOption.getValue();
	}

	public void setColorProfileName(String name) {
		ColorProfileOption.setValue(name);
		myColorProfile = null;
	}

	public ZLKeyBindings keyBindings() {
		return myBindings;
	}

	public FBView getTextView() {
		return (FBView)getCurrentView();
	}

	public void tryOpenFootnote(String id) {
		if (Model != null) {
			BookModel.Label label = Model.getLabel(id);
			if (label != null) {
				addInvisibleBookmark();
				if (label.ModelId == null) {
					BookTextView.gotoPosition(label.ParagraphIndex, 0, 0);
				} else {
					FootnoteView.setModel(Model.getFootnoteModel(label.ModelId));
					setView(FootnoteView);
					FootnoteView.gotoPosition(label.ParagraphIndex, 0, 0);
				}
				repaintView();
			}
		}
	}

	public void clearTextCaches() {
		BookTextView.clearCaches();
		FootnoteView.clearCaches();
	}

	void openBookInternal(Book book, Bookmark bookmark) {
		if (book != null) {
			onViewChanged();

			if (Model != null) {
				Model.Book.storePosition(BookTextView.getStartCursor());
			}
			BookTextView.setModel(null);
			FootnoteView.setModel(null);
			clearTextCaches();

			Model = null;
			System.gc();
			System.gc();
			Model = BookModel.createModel(book);
			if (Model != null) {
				ZLTextHyphenator.Instance().load(book.getLanguage());
				BookTextView.setModel(Model.BookTextModel);
				BookTextView.gotoPosition(book.getStoredPosition());
				if (bookmark == null) {
					setView(BookTextView);
				} else {
					gotoBookmark(bookmark);
				}
				Library.addBookToRecentList(book);
			}
		}
		repaintView();
	}

	public void gotoBookmark(Bookmark bookmark) {
		addInvisibleBookmark();
		final String modelId = bookmark.ModelId;
		if (modelId == null) {
			BookTextView.gotoPosition(bookmark);
			setView(BookTextView);
		} else {
			FootnoteView.setModel(Model.getFootnoteModel(modelId));
			FootnoteView.gotoPosition(bookmark);
			setView(FootnoteView);
		}
		repaintView();
	}

	public void showBookTextView() {
		setView(BookTextView);
	}

	private Book createBookForFile(ZLFile file) {
		if (file == null) {
			return null;
		}
		Book book = Book.getByFile(file);
		if (book != null) {
			book.insertIntoBookList();
			return book;
		}
		if (file.isArchive()) {
			for (ZLFile child : file.children()) {
				book = Book.getByFile(child);
				if (book != null) {
					book.insertIntoBookList();
					return book;
				}
			}
		}
		return null;
	}

	@Override
	public void openFile(ZLFile file) {
		final Book book = createBookForFile(file);
		if (book != null) {
			openBook(book, null);
		}
	}

	public void onWindowClosing() {
		if (Model != null && BookTextView != null) {
			Model.Book.storePosition(BookTextView.getStartCursor());
		}
	}

	static enum CancelActionType {
		previousBook,
		returnTo,
		close
	}

	public static class CancelActionDescription {
		final CancelActionType Type;
		public final String Title;
		public final String Summary;

		CancelActionDescription(CancelActionType type, String summary) {
			final ZLResource resource = ZLResource.resource(""cancelMenu"");
			Type = type;
			Title = resource.getResource(type.toString()).getValue();
			Summary = summary;
		}
	}

	private static class BookmarkDescription extends CancelActionDescription {
		final Bookmark Bookmark;
		
		BookmarkDescription(Bookmark b) {
			super(CancelActionType.returnTo, b.getText());
			Bookmark = b;
		}
	}

	private final ArrayList<CancelActionDescription> myCancelActionsList =
		new ArrayList<CancelActionDescription>();

	public List<CancelActionDescription> getCancelActionsList() {
		myCancelActionsList.clear();
		final Book previousBook = Library.getPreviousBook();
		if (previousBook != null) {
			myCancelActionsList.add(new CancelActionDescription(
				CancelActionType.previousBook, previousBook.getTitle()
			));
		}
		if (Model != null && Model.Book != null) {
			for (Bookmark bookmark : Bookmark.invisibleBookmarks(Model.Book)) {
				myCancelActionsList.add(new BookmarkDescription(bookmark));
			}
		}
		myCancelActionsList.add(new CancelActionDescription(
			CancelActionType.close, null
		));
		return myCancelActionsList;
	}

	public void runCancelAction(int index) {
		if (index < 0 || index >= myCancelActionsList.size()) {
			return;
		}

		final CancelActionDescription description = myCancelActionsList.get(index);
		switch (description.Type) {
			case previousBook:
				openBook(Library.getPreviousBook(), null);
				break;
			case returnTo:
			{
				final Bookmark b = ((BookmarkDescription)description).Bookmark;
				b.delete();
				gotoBookmark(b);
				break;
			}
			case close:
				closeWindow();
				break;
		}
	}

	private void updateInvisibleBookmarksList(Bookmark b) {
		if (Model.Book != null && b != null) {
			for (Bookmark bm : Bookmark.invisibleBookmarks(Model.Book)) {
				if (b.equals(bm)) {
					bm.delete();
				}
			}
			b.save();
			final List<Bookmark> bookmarks = Bookmark.invisibleBookmarks(Model.Book);
			for (int i = 3; i < bookmarks.size(); ++i) {
				bookmarks.get(i).delete();
			}
		}
	}

	public void addInvisibleBookmark(ZLTextWordCursor cursor) {
		if (cursor != null && Model != null && Model.Book != null && getTextView() == BookTextView) {
			updateInvisibleBookmarksList(new Bookmark(
				Model.Book,
				getTextView().getModel().getId(),
				cursor,
				6,
				false
			));
		}
	}

	public void addInvisibleBookmark() {
		if (Model.Book != null && getTextView() == BookTextView) {
			updateInvisibleBookmarksList(addBookmark(6, false));
		}
	}

	public Bookmark addBookmark(int maxLength, boolean visible) {
		final FBView view = getTextView();
		final ZLTextWordCursor cursor = view.getStartCursor();

		if (cursor.isNull()) {
			return null;
		}

		return new Bookmark(
			Model.Book,
			view.getModel().getId(),
			cursor,
			maxLength,
			visible
		);
	}
}
",True,251,5,19,6,68,29,29,L5
78,org.geometerplus.fbreader.fbreader.TurnPageAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

class TurnPageAction extends FBAction {
	private final boolean myForward;

	TurnPageAction(FBReaderApp fbreader, boolean forward) {
		super(fbreader);
		myForward = forward;
	}

	public boolean isEnabled() {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();

		final ScrollingPreferences.FingerScrolling fingerScrolling =
			preferences.FingerScrollingOption.getValue();
		if (fingerScrolling != ScrollingPreferences.FingerScrolling.byTap &&
			fingerScrolling != ScrollingPreferences.FingerScrolling.byTapAndFlick) {
			return false;
		}

		if (myForward) {
			ZLTextWordCursor cursor = Reader.getTextView().getEndCursor();
			return
				cursor != null &&
				!cursor.isNull() &&
				(!cursor.isEndOfParagraph() || !cursor.getParagraphCursor().isLast());
		} else {
			ZLTextWordCursor cursor = Reader.getTextView().getStartCursor();
			return
				cursor != null &&
				!cursor.isNull() &&
				(!cursor.isStartOfParagraph() || !cursor.getParagraphCursor().isFirst());
		}
	}

	public void run() {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();
		final FBView view = Reader.getTextView();
		if (view.getAnimationType() != FBView.Animation.none) {
			final boolean horizontal = preferences.HorizontalOption.getValue();
			if (myForward) {
				view.startAutoScrolling(horizontal ? FBView.PAGE_RIGHT : FBView.PAGE_BOTTOM);
			} else {
				view.startAutoScrolling(horizontal ? FBView.PAGE_LEFT : FBView.PAGE_TOP);
			}
		} else {
			view.scrollPage(myForward, FBView.ScrollingMode.NO_OVERLAPPING, 0);
			Reader.repaintView();
		}
	}
}
",False,204,0,0,7,63,1,11,L5
79,org.geometerplus.fbreader.fbreader.ChangeFontSizeAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;
import org.geometerplus.zlibrary.text.view.style.ZLTextStyleCollection;

class ChangeFontSizeAction extends FBAction {
	private final int myDelta;

	ChangeFontSizeAction(FBReaderApp fbreader, int delta) {
		super(fbreader);
		myDelta = delta;
	}

	public void run() {
		ZLIntegerRangeOption option =
			ZLTextStyleCollection.Instance().getBaseStyle().FontSizeOption;
		option.setValue(option.getValue() + myDelta);
		Reader.clearTextCaches();
		Reader.repaintView();
	}
}
",False,204,0,0,7,64,1,6,L5
80,org.geometerplus.fbreader.fbreader.WallpapersUtil.java,"/*
 * Copyright (C) 2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.List;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.Paths;

public abstract class WallpapersUtil {
	public static List<ZLFile> predefinedWallpaperFiles() {
		return ZLFile.createFileByPath(""wallpapers"").children();
	}

	public static List<ZLFile> externalWallpaperFiles() {
		return ZLFile.createFileByPath(Paths.WallpapersDirectoryOption().getValue()).children();
	}
}
",False,68,8,18,5,6,1,3,L6
81,org.geometerplus.fbreader.fbreader.ClearFindResultsAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class ClearFindResultsAction extends FBAction {
	ClearFindResultsAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public void run() {
		Reader.getTextView().clearFindResults();
	}
}
",False,204,0,0,7,57,1,3,L5
82,org.geometerplus.fbreader.fbreader.FindPreviousAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.text.view.ZLTextView;

class FindPreviousAction extends FBAction {
	FindPreviousAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public boolean isEnabled() {
		ZLTextView view = Reader.getTextView();
		return (view != null) && view.canFindPrevious();
	}

	public void run() {
		Reader.getTextView().findPrevious();
	}
}
",False,204,0,0,7,57,1,3,L5
83,org.geometerplus.fbreader.fbreader.FBView.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.*;

import org.geometerplus.zlibrary.core.application.ZLApplication;
import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.view.ZLPaintContext;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;

import org.geometerplus.zlibrary.text.model.ZLTextModel;
import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.bookmodel.FBHyperlinkType;
import org.geometerplus.fbreader.bookmodel.TOCTree;

public final class FBView extends ZLTextView {
	private FBReaderApp myReader;

	FBView(FBReaderApp reader) {
		myReader = reader;
	}

	public void setModel(ZLTextModel model) {
		myIsManualScrollingActive = false;
		super.setModel(model);
		if (myFooter != null) {
			myFooter.resetTOCMarks();
		}
	}

	public void onScrollingFinished(int viewPage) {
		super.onScrollingFinished(viewPage);
	}

	private int myStartX;
	private int myStartY;
	private boolean myIsManualScrollingActive;
	private boolean myIsBrightnessAdjustmentInProgress;
	private int myStartBrightness;

	private static class TapZone {
		int HIndex;
		int VIndex;
		
		TapZone(int h, int v) {
			HIndex = h;
			VIndex = v;
		}

		void mirror45() {
			final int swap = HIndex;
			HIndex = VIndex;
			VIndex = swap;
		}

		@Override
		public boolean equals(Object o) {
			if (o == this) {
				return true;
			}

			if (!(o instanceof TapZone)) {
				return false;
			}

			final TapZone tz = (TapZone)o;
			return HIndex == tz.HIndex && VIndex == tz.VIndex;
		}

		@Override
		public int hashCode() {
			return (HIndex << 3) + VIndex;
		}
	}

	private enum ZoneMap {
		HORIZONTAL_RIGHT_TO_LEFT,
		HORIZONTAL_LEFT_TO_RIGHT,
		VERTICAL_UP,
		VERTICAL_DOWN
	}
	private ZoneMap myZoneMapId;
	private final HashMap<TapZone,String> myZoneMap = new HashMap<TapZone,String>();

	private Map<TapZone,String> getZoneMap() {
		final ZoneMap id = ScrollingPreferences.Instance().HorizontalOption.getValue()
			? ZoneMap.HORIZONTAL_RIGHT_TO_LEFT : ZoneMap.VERTICAL_UP;
		if (id != myZoneMapId) {
			myZoneMapId = id;
			myZoneMap.clear();
			switch (id) {
				case HORIZONTAL_RIGHT_TO_LEFT:
					myZoneMap.put(new TapZone(0, 0), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(0, 1), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(0, 2), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(1, 0), ActionCode.SHOW_NAVIGATION);
					myZoneMap.put(new TapZone(1, 2), ActionCode.SHOW_MENU);
					myZoneMap.put(new TapZone(2, 0), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(2, 1), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(2, 2), ActionCode.TURN_PAGE_FORWARD);
					break;
				case HORIZONTAL_LEFT_TO_RIGHT:
					myZoneMap.put(new TapZone(0, 0), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(0, 1), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(0, 2), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(1, 0), ActionCode.SHOW_NAVIGATION);
					myZoneMap.put(new TapZone(1, 2), ActionCode.SHOW_MENU);
					myZoneMap.put(new TapZone(2, 0), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(2, 1), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(2, 2), ActionCode.TURN_PAGE_BACK);
					break;
				case VERTICAL_UP:
					myZoneMap.put(new TapZone(0, 0), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(1, 0), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(2, 0), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(0, 1), ActionCode.SHOW_NAVIGATION);
					myZoneMap.put(new TapZone(2, 1), ActionCode.SHOW_MENU);
					myZoneMap.put(new TapZone(0, 2), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(1, 2), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(2, 2), ActionCode.TURN_PAGE_FORWARD);
					break;
				case VERTICAL_DOWN:
					myZoneMap.put(new TapZone(0, 0), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(1, 0), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(2, 0), ActionCode.TURN_PAGE_FORWARD);
					myZoneMap.put(new TapZone(0, 1), ActionCode.SHOW_NAVIGATION);
					myZoneMap.put(new TapZone(2, 1), ActionCode.SHOW_MENU);
					myZoneMap.put(new TapZone(0, 2), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(1, 2), ActionCode.TURN_PAGE_BACK);
					myZoneMap.put(new TapZone(2, 2), ActionCode.TURN_PAGE_BACK);
					break;
			}
		}
		return myZoneMap;
	}

	private TapZone getZoneByCoordinates(int x, int y, int grid) {
		return new TapZone(
			x * grid / myContext.getWidth(),
			y * grid / myContext.getHeight()
		);
	}

	public boolean onFingerSingleTap(int x, int y) {
		if (super.onFingerSingleTap(x, y)) {
			return true;
		}

		if (isScrollingActive()) {
			return false;
		}

		if (myReader.FooterIsSensitiveOption.getValue()) {
			Footer footer = getFooterArea();
			if (footer != null && y > myContext.getHeight() - footer.getTapHeight()) {
				myReader.addInvisibleBookmark();
				footer.setProgress(x);
				return true;
			}
		}

		final ZLTextElementRegion region = findRegion(x, y, 10, ZLTextElementRegion.HyperlinkFilter);
		if (region != null) {
			selectRegion(region);
			myReader.repaintView();
			myReader.doAction(ActionCode.PROCESS_HYPERLINK);
			return true;
		}

		myReader.doAction(getZoneMap().get(getZoneByCoordinates(x, y, 3)));

		return true;
	}

	@Override
	public boolean isDoubleTapSupported() {
		return myReader.EnableDoubleTapOption.getValue();
	}

	@Override
	public boolean onFingerDoubleTap(int x, int y) {
		if (super.onFingerDoubleTap(x, y)) {
			return true;
		}
		if (y <= myContext.getHeight() / 2) {
			myReader.doAction(ActionCode.SHOW_NAVIGATION);
		} else {
			myReader.doAction(ActionCode.SHOW_MENU);
		}
		return true;
	}

	public boolean onFingerPress(int x, int y) {
		if (super.onFingerPress(x, y)) {
			return true;
		}

		if (isScrollingActive()) {
			return false;
		}

		if (myReader.FooterIsSensitiveOption.getValue()) {
			Footer footer = getFooterArea();
			if (footer != null && y > myContext.getHeight() - footer.getTapHeight()) {
				footer.setProgress(x);
				return true;
			}
		}

		if (myReader.AllowScreenBrightnessAdjustmentOption.getValue() && x < myContext.getWidth() / 10) {
			myIsBrightnessAdjustmentInProgress = true;
			myStartY = y;
			myStartBrightness = ZLibrary.Instance().getScreenBrightness();
			return true;
		}

		startManualScrolling(x, y);
		return true;
	}

	private void startManualScrolling(int x, int y) {
		final ScrollingPreferences.FingerScrolling fingerScrolling =
			ScrollingPreferences.Instance().FingerScrollingOption.getValue();
		if (fingerScrolling == ScrollingPreferences.FingerScrolling.byFlick ||
			fingerScrolling == ScrollingPreferences.FingerScrolling.byTapAndFlick) {
			myStartX = x;
			myStartY = y;
			setScrollingActive(true);
			myIsManualScrollingActive = true;
		}
	}

	public boolean onFingerMove(int x, int y) {
		if (super.onFingerMove(x, y)) {
			return true;
		}

		synchronized (this) {
			if (myIsBrightnessAdjustmentInProgress) {
				if (x >= myContext.getWidth() / 5) {
					myIsBrightnessAdjustmentInProgress = false;
					startManualScrolling(x, y);
				} else {
					final int delta = (myStartBrightness + 30) * (myStartY - y) / myContext.getHeight();
					ZLibrary.Instance().setScreenBrightness(myStartBrightness + delta);
					return true;
				}
			}

			if (isScrollingActive() && myIsManualScrollingActive) {
				final boolean horizontal = ScrollingPreferences.Instance().HorizontalOption.getValue();
				final int diff = horizontal ? x - myStartX : y - myStartY;
				if (diff > 0) {
					ZLTextWordCursor cursor = getStartCursor();
					if (cursor == null || cursor.isNull()) {
						return false;
					}
					if (!cursor.isStartOfParagraph() || !cursor.getParagraphCursor().isFirst()) {
						myReader.scrollViewTo(horizontal ? PAGE_LEFT : PAGE_TOP, diff);
					}
				} else if (diff < 0) {
					ZLTextWordCursor cursor = getEndCursor();
					if (cursor == null || cursor.isNull()) {
						return false;
					}
					if (!cursor.isEndOfParagraph() || !cursor.getParagraphCursor().isLast()) {
						myReader.scrollViewTo(horizontal ? PAGE_RIGHT : PAGE_BOTTOM, -diff);
					}
				} else {
					myReader.scrollViewTo(PAGE_CENTRAL, 0);
				}
				return true;
			}
		}

		return false;
	}

	public boolean onFingerRelease(int x, int y) {
		if (super.onFingerRelease(x, y)) {
			return true;
		}

		synchronized (this) {
			myIsBrightnessAdjustmentInProgress = false;
			if (isScrollingActive() && myIsManualScrollingActive) {
				setScrollingActive(false);
				myIsManualScrollingActive = false;
				final boolean horizontal = ScrollingPreferences.Instance().HorizontalOption.getValue();
				final int diff = horizontal ? x - myStartX : y - myStartY;
				boolean doScroll = false;
				if (diff > 0) {
					ZLTextWordCursor cursor = getStartCursor();
					if (cursor != null && !cursor.isNull()) {
						doScroll = !cursor.isStartOfParagraph() || !cursor.getParagraphCursor().isFirst();
					}
				} else if (diff < 0) {
					ZLTextWordCursor cursor = getEndCursor();
					if (cursor != null && !cursor.isNull()) {
						doScroll = !cursor.isEndOfParagraph() || !cursor.getParagraphCursor().isLast();
					}
				}
				if (doScroll) {
					final int h = myContext.getHeight();
					final int w = myContext.getWidth();
					final int minDiff = horizontal ?
						((w > h) ? w / 4 : w / 3) :
						((h > w) ? h / 4 : h / 3);
					int viewPage = PAGE_CENTRAL;
					if (Math.abs(diff) > minDiff) {
						viewPage = horizontal ?
							((diff < 0) ? PAGE_RIGHT : PAGE_LEFT) :
							((diff < 0) ? PAGE_BOTTOM : PAGE_TOP);
					}
					if (getAnimationType() != Animation.none) {
						startAutoScrolling(viewPage);
					} else {
						myReader.scrollViewTo(PAGE_CENTRAL, 0);
						onScrollingFinished(viewPage);
						myReader.repaintView();
						setScrollingActive(false);
					}
				}
				return true;
			}
		}
		return false;
	}

	public boolean onFingerLongPress(int x, int y) {
		if (super.onFingerLongPress(x, y)) {
			return true;
		}

		if (myReader.DictionaryTappingActionOption.getValue() !=
			FBReaderApp.DictionaryTappingAction.doNothing) {
			final ZLTextElementRegion region = findRegion(x, y, 10, ZLTextElementRegion.AnyRegionFilter);
			if (region != null) {
				selectRegion(region);
				myReader.repaintView();
				return true;
			}
		}

		return false;
	}

	public boolean onFingerMoveAfterLongPress(int x, int y) {
		if (super.onFingerMoveAfterLongPress(x, y)) {
			return true;
		}

		if (myReader.DictionaryTappingActionOption.getValue() !=
			FBReaderApp.DictionaryTappingAction.doNothing) {
			final ZLTextElementRegion region = findRegion(x, y, 10, ZLTextElementRegion.AnyRegionFilter);
			if (region != null) {
				selectRegion(region);
				myReader.repaintView();
			}
		}
		return true;
	}

	public boolean onFingerReleaseAfterLongPress(int x, int y) {
		if (super.onFingerReleaseAfterLongPress(x, y)) {
			return true;
		}

		if (myReader.DictionaryTappingActionOption.getValue() ==
			FBReaderApp.DictionaryTappingAction.openDictionary) {
			final ZLTextElementRegion region = currentRegion();
			myReader.doAction(ActionCode.PROCESS_HYPERLINK);
			return true;
		}

		return false;
	}

	public boolean onTrackballRotated(int diffX, int diffY) {
		if (diffX == 0 && diffY == 0) {
			return true;
		}

		final int direction = (diffY != 0) ?
			(diffY > 0 ? Direction.DOWN : Direction.UP) :
			(diffX > 0 ? Direction.RIGHT : Direction.LEFT);

		ZLTextElementRegion region = currentRegion();
		final ZLTextElementRegion.Filter filter =
			region instanceof ZLTextWordRegion || myReader.NavigateAllWordsOption.getValue()
				? ZLTextElementRegion.AnyRegionFilter : ZLTextElementRegion.ImageOrHyperlinkFilter;
		region = nextRegion(direction, filter);
		if (region != null) {
			selectRegion(region);
		} else {
			if (direction == Direction.DOWN) {
				scrollPage(true, ZLTextView.ScrollingMode.SCROLL_LINES, 1);
			} else if (direction == Direction.UP) {
				scrollPage(false, ZLTextView.ScrollingMode.SCROLL_LINES, 1);
			}
		}

		myReader.repaintView();

		return true;
	}

	@Override
	public int getLeftMargin() {
		return myReader.LeftMarginOption.getValue();
	}

	@Override
	public int getRightMargin() {
		return myReader.RightMarginOption.getValue();
	}

	@Override
	public int getTopMargin() {
		return myReader.TopMarginOption.getValue();
	}

	@Override
	public int getBottomMargin() {
		return myReader.BottomMarginOption.getValue();
	}

	@Override
	public ZLFile getWallpaperFile() {
		final String filePath = myReader.getColorProfile().WallpaperOption.getValue();
		if ("""".equals(filePath)) {
			return null;
		}
		
		final ZLFile file = ZLFile.createFileByPath(filePath);
		if (file == null || !file.exists()) {
			return null;
		}
		return file;
	}

	@Override
	public ZLColor getBackgroundColor() {
		return myReader.getColorProfile().BackgroundOption.getValue();
	}

	@Override
	public ZLColor getSelectedBackgroundColor() {
		return myReader.getColorProfile().SelectionBackgroundOption.getValue();
	}

	@Override
	public ZLColor getTextColor(byte hyperlinkType) {
		final ColorProfile profile = myReader.getColorProfile();
		switch (hyperlinkType) {
			default:
			case FBHyperlinkType.NONE:
				return profile.RegularTextOption.getValue();
			case FBHyperlinkType.INTERNAL:
			case FBHyperlinkType.EXTERNAL:
				return profile.HyperlinkTextOption.getValue();
		}
	}

	@Override
	public ZLColor getHighlightingColor() {
		return myReader.getColorProfile().HighlightingOption.getValue();
	}

	private class Footer implements FooterArea {
		private Runnable UpdateTask = new Runnable() {
			public void run() {
				ZLApplication.Instance().repaintView();
			}
		};

		private ArrayList<TOCTree> myTOCMarks;

		public int getHeight() {
			return myReader.FooterHeightOption.getValue();
		}

		public synchronized void resetTOCMarks() {
			myTOCMarks = null;
		}

		private final int MAX_TOC_MARKS_NUMBER = 100;
		private synchronized void updateTOCMarks(BookModel model) {
			myTOCMarks = new ArrayList<TOCTree>();
			TOCTree toc = model.TOCTree;
			if (toc == null) {
				return;
			}
			int maxLevel = Integer.MAX_VALUE;
			if (toc.getSize() >= MAX_TOC_MARKS_NUMBER) {
				final int[] sizes = new int[10];
				for (TOCTree tocItem : toc) {
					if (tocItem.Level < 10) {
						++sizes[tocItem.Level];
					}
				}
				for (int i = 1; i < sizes.length; ++i) {
					sizes[i] += sizes[i - 1];
				}
				for (maxLevel = sizes.length - 1; maxLevel >= 0; --maxLevel) {
					if (sizes[maxLevel] < MAX_TOC_MARKS_NUMBER) {
						break;
					}
				}
			}
			for (TOCTree tocItem : toc.allSubTrees(maxLevel)) {
				myTOCMarks.add(tocItem);
			}
		}

		public synchronized void paint(ZLPaintContext context) {
			final FBReaderApp reader = myReader;
			if (reader == null) {
				return;
			}
			final BookModel model = reader.Model;
			if (model == null) {
				return;
			}

			final ZLColor bgColor = getBackgroundColor();
			// TODO: separate color option for footer color
			final ZLColor fgColor = getTextColor(FBHyperlinkType.NONE);
			final ZLColor fillColor = reader.getColorProfile().FooterFillOption.getValue();

			final int left = getLeftMargin();
			final int right = context.getWidth() - getRightMargin();
			final int height = getHeight();
			final int lineWidth = height <= 10 ? 1 : 2;
			final int delta = height <= 10 ? 0 : 1;
			context.setFont(
				reader.FooterFontOption.getValue(),
				height <= 10 ? height + 3 : height + 1,
				height > 10, false, false
			);

			final int pagesProgress = computeCurrentPage();
			final int bookLength = computePageNumber();

			final StringBuilder info = new StringBuilder();
			if (reader.FooterShowProgressOption.getValue()) {
				info.append(pagesProgress);
				info.append(""/"");
				info.append(bookLength);
			}
			if (reader.FooterShowBatteryOption.getValue()) {
				if (info.length() > 0) {
					info.append("" "");
				}
				info.append(reader.getBatteryLevel());
				info.append(""%"");
			}
			if (reader.FooterShowClockOption.getValue()) {
				if (info.length() > 0) {
					info.append("" "");
				}
				info.append(ZLibrary.Instance().getCurrentTimeString());
			}
			final String infoString = info.toString();

			final int infoWidth = context.getStringWidth(infoString);
			final ZLFile wallpaper = getWallpaperFile();
			if (wallpaper != null) {
				context.clear(wallpaper, wallpaper instanceof ZLResourceFile);
			} else {
				context.clear(getBackgroundColor());
			}

			// draw info text
			context.setTextColor(fgColor);
			context.drawString(right - infoWidth, height - delta, infoString);

			// draw gauge
			final int gaugeRight = right - (infoWidth == 0 ? 0 : infoWidth + 10);
			myGaugeWidth = gaugeRight - left - 2 * lineWidth;

			context.setLineColor(fgColor);
			context.setLineWidth(lineWidth);
			context.drawLine(left, lineWidth, left, height - lineWidth);
			context.drawLine(left, height - lineWidth, gaugeRight, height - lineWidth);
			context.drawLine(gaugeRight, height - lineWidth, gaugeRight, lineWidth);
			context.drawLine(gaugeRight, lineWidth, left, lineWidth);

			final int gaugeInternalRight =
				left + lineWidth + (int)(1.0 * myGaugeWidth * pagesProgress / bookLength);

			context.setFillColor(fillColor);
			context.fillRectangle(left + lineWidth, height - 2 * lineWidth, gaugeInternalRight, 2 * lineWidth);

			if (reader.FooterShowTOCMarksOption.getValue()) {
				if (myTOCMarks == null) {
					updateTOCMarks(model);
				}
				final int fullLength = sizeOfFullText();
				for (TOCTree tocItem : myTOCMarks) {
					TOCTree.Reference reference = tocItem.getReference();
					if (reference != null) {
						final int refCoord = sizeOfTextBeforeParagraph(reference.ParagraphIndex);
						final int xCoord =
							left + 2 * lineWidth + (int)(1.0 * myGaugeWidth * refCoord / fullLength);
						context.drawLine(xCoord, height - lineWidth, xCoord, lineWidth);
					}
				}
			}
		}

		// TODO: remove
		int myGaugeWidth = 1;
		public int getGaugeWidth() {
			return myGaugeWidth;
		}

		public int getTapHeight() {
			return 30;
		}

		public void setProgress(int x) {
			// set progress according to tap coordinate
			int gaugeWidth = getGaugeWidth();
			float progress = 1.0f * Math.min(x, gaugeWidth) / gaugeWidth;
			int page = (int)(progress * computePageNumber());
			if (page <= 1) {
				gotoHome();
			} else {
				gotoPage(page);
			}
			myReader.repaintView();
		}
	}

	private Footer myFooter;

	@Override
	public Footer getFooterArea() {
		if (myReader.ScrollbarTypeOption.getValue() == SCROLLBAR_SHOW_AS_FOOTER) {
			if (myFooter == null) {
				myFooter = new Footer();
				ZLApplication.Instance().addTimerTask(myFooter.UpdateTask, 15000);
			}
		} else {
			if (myFooter != null) {
				ZLApplication.Instance().removeTimerTask(myFooter.UpdateTask);
				myFooter = null;
			}
		}
		return myFooter;
	}

	@Override
	protected boolean isSelectionEnabled() {
		return myReader.SelectionEnabledOption.getValue();
	}

	public static final int SCROLLBAR_SHOW_AS_FOOTER = 3;

	@Override
	public int scrollbarType() {
		return myReader.ScrollbarTypeOption.getValue();
	}

	@Override
	public Animation getAnimationType() {
		return ScrollingPreferences.Instance().AnimationOption.getValue();
	}
}
",True,249,7,18,6,61,5,26,L5
84,org.geometerplus.fbreader.fbreader.RotateAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class RotateAction extends FBAction {
	RotateAction(FBReaderApp fbreader) {
		super(fbreader);
	}

	public void run() {
		Reader.rotateScreen();
	}

	public boolean isVisible() {
		return Reader.canRotateScreen();
	}
}
",False,204,0,0,7,66,1,3,L5
85,org.geometerplus.fbreader.fbreader.ColorProfile.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.options.*;

public class ColorProfile {
	public static final String DAY = ""defaultLight"";
	public static final String NIGHT = ""defaultDark"";

	private static final ArrayList<String> ourNames = new ArrayList<String>();
	private static final HashMap<String,ColorProfile> ourProfiles = new HashMap<String,ColorProfile>();

	public static List<String> names() {
		if (ourNames.isEmpty()) {
			final int size = new ZLIntegerOption(""Colors"", ""NumberOfSchemes"", 0).getValue();
			if (size == 0) {
				ourNames.add(DAY);
				ourNames.add(NIGHT);
			} else for (int i = 0; i < size; ++i) {
				ourNames.add(new ZLStringOption(""Colors"", ""Scheme"" + i, """").getValue());
			}
		}
		return Collections.unmodifiableList(ourNames);
	}

	public static ColorProfile get(String name) {
		ColorProfile profile = ourProfiles.get(name);
		if (profile == null) {
			profile = new ColorProfile(name);
			ourProfiles.put(name, profile);
		}
		return profile;
	}

	public final ZLStringOption WallpaperOption;
	public final ZLColorOption BackgroundOption;
	public final ZLColorOption SelectionBackgroundOption;
	public final ZLColorOption HighlightingOption;
	public final ZLColorOption RegularTextOption;
	public final ZLColorOption HyperlinkTextOption;
	public final ZLColorOption FooterFillOption;

	private ColorProfile(String name, ColorProfile base) {
		this(name);
		BackgroundOption.setValue(base.BackgroundOption.getValue());
		SelectionBackgroundOption.setValue(base.SelectionBackgroundOption.getValue());
		HighlightingOption.setValue(base.HighlightingOption.getValue());
		RegularTextOption.setValue(base.RegularTextOption.getValue());
		HyperlinkTextOption.setValue(base.HyperlinkTextOption.getValue());
		FooterFillOption.setValue(base.FooterFillOption.getValue());
	}

	private static ZLColorOption createOption(String profileName, String optionName, int r, int g, int b) {
		return new ZLColorOption(""Colors"", profileName + ':' + optionName, new ZLColor(r, g, b));
	}

	private ColorProfile(String name) {
		if (NIGHT.equals(name)) {
			WallpaperOption =
				new ZLStringOption(""Colors"", name + "":Wallpaper"", """");
			BackgroundOption =
				createOption(name, ""Background"", 0, 0, 0);
			SelectionBackgroundOption =
				createOption(name, ""SelectionBackground"", 82, 131, 194);
			HighlightingOption =
				createOption(name, ""Highlighting"", 96, 96, 128);
			RegularTextOption =
				createOption(name, ""Text"", 192, 192, 192);
			HyperlinkTextOption =
				createOption(name, ""Hyperlink"", 60, 142, 224);
			FooterFillOption =
				createOption(name, ""FooterFillOption"", 85, 85, 85);
		} else {
			WallpaperOption =
				new ZLStringOption(""Colors"", name + "":Wallpaper"", ""wallpapers/sepia.jpg"");
			BackgroundOption =
				createOption(name, ""Background"", 255, 255, 255);
			SelectionBackgroundOption =
				createOption(name, ""SelectionBackground"", 82, 131, 194);
			HighlightingOption =
				createOption(name, ""Highlighting"", 255, 192, 128);
			RegularTextOption =
				createOption(name, ""Text"", 0, 0, 0);
			HyperlinkTextOption =
				createOption(name, ""Hyperlink"", 60, 139, 255);
			FooterFillOption =
				createOption(name, ""FooterFillOption"", 170, 170, 170);
		}
	}
}
",True,66,6,27,3,4,4,4,L5
86,org.geometerplus.fbreader.fbreader.VolumeKeyTurnPageAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

class VolumeKeyTurnPageAction extends FBAction {
	private final boolean myForward;

	VolumeKeyTurnPageAction(FBReaderApp fbreader, boolean forward) {
		super(fbreader);
		myForward = forward;
	}

	public boolean isEnabled() {
		return ScrollingPreferences.Instance().VolumeKeysOption.getValue();
	}

	public void run() {
		final ScrollingPreferences preferences = ScrollingPreferences.Instance();

		boolean forward = myForward;
		if (preferences.InvertVolumeKeysOption.getValue()) {
			forward = !forward;
		}

		if (forward) {
			ZLTextWordCursor cursor = Reader.getTextView().getEndCursor();
			if (cursor == null || cursor.isNull() ||
				(cursor.isEndOfParagraph() && cursor.getParagraphCursor().isLast())) {
				return;
			}
		} else {
			ZLTextWordCursor cursor = Reader.getTextView().getStartCursor();
			if (cursor == null || cursor.isNull() ||
				(cursor.isStartOfParagraph() && cursor.getParagraphCursor().isFirst())) {
				return;
			}
		}
		final FBView view = Reader.getTextView();
		if (view.getAnimationType() != FBView.Animation.none) {
			final boolean horizontal = preferences.HorizontalOption.getValue();
			if (forward) {
				view.startAutoScrolling(horizontal ? FBView.PAGE_RIGHT : FBView.PAGE_BOTTOM);
			} else {
				view.startAutoScrolling(horizontal ? FBView.PAGE_LEFT : FBView.PAGE_TOP);
			}
		} else {
			view.scrollPage(forward, FBView.ScrollingMode.NO_OVERLAPPING, 0);
			Reader.repaintView();
		}
	}
}
",False,204,0,0,7,64,1,10,L5
87,org.geometerplus.fbreader.fbreader.SwitchProfileAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.fbreader;

class SwitchProfileAction extends FBAction {
	private String myProfileName;

	SwitchProfileAction(FBReaderApp fbreader, String profileName) {
		super(fbreader);
		myProfileName = profileName;
	}

	public boolean isVisible() {
		return !myProfileName.equals(Reader.getColorProfileName());
	}

	public void run() {
		Reader.setColorProfileName(myProfileName);
		Reader.repaintView();
	}
}
",False,204,0,0,7,66,1,3,L5
88,org.geometerplus.fbreader.network.BookReference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.File;
import java.net.URI;

import org.geometerplus.fbreader.Paths;

public class BookReference {

	public interface Type {
		int UNKNOWN = 0; // Unknown reference type
		int DOWNLOAD_FULL = 1; // reference for download full version of the book
		int DOWNLOAD_FULL_CONDITIONAL = 2; // reference for download full version of the book, useful only when book is bought
		int DOWNLOAD_DEMO = 3; // reference for downloading demo version of the book
		int DOWNLOAD_FULL_OR_DEMO = 4; // reference for downloading unknown version of the book
		int BUY = 5; // reference for buying the book (useful only when authentication is supported)
		int BUY_IN_BROWSER = 6; // reference to the site page, when it is possible to buy the book
	}
	// resolvedReferenceType -- reference type without any ambiguity (for example, DOWNLOAD_FULL_OR_DEMO is ambiguous)

	public interface Format {
		int NONE = 0;
		int MOBIPOCKET = 1;
		int FB2_ZIP = 2;
		int EPUB = 3;
	}

	public final String URL;
	public final int BookFormat;
	public final int ReferenceType;

	public BookReference(String url, int format, int type) {
		URL = url;
		BookFormat = format;
		ReferenceType = type;
	}

	// returns clean URL without any account/user-specific parts
	public String cleanURL() {
		return URL;
	}

	private static final String TOESCAPE = ""<>:\""|?*\\"";

	public static String makeBookFileName(String url, int format, int resolvedReferenceType) {
		URI uri;
		try {
			uri = new URI(url);
		} catch (java.net.URISyntaxException ex) {
			return null;
		}

		String host = uri.getHost();

		StringBuilder path = new StringBuilder(host);
		if (host.startsWith(""www."")) {
			path.delete(0, 4);
		}
		path.insert(0, File.separator);
		if (resolvedReferenceType == Type.DOWNLOAD_DEMO) {
			path.insert(0, ""Demos"");
			path.insert(0, File.separator);
		}
		path.insert(0, Paths.BooksDirectoryOption().getValue());

		int index = path.length();
		path.append(uri.getPath());
		int nameIndex = index;
		while (index < path.length()) {
			char ch = path.charAt(index);
			if (TOESCAPE.indexOf(ch) != -1) {
				path.setCharAt(index, '_');
			}
			if (ch == '/') {
				if (index + 1 == path.length()) {
					path.deleteCharAt(index);
				} else {
					path.setCharAt(index, File.separatorChar);
					nameIndex = index + 1;
				}
			}
			++index;
		}

		String ext = null;
		switch (format) {
			case Format.EPUB:
				ext = "".epub"";
				break;
			case Format.MOBIPOCKET:
				ext = "".mobi"";
				break;
			case Format.FB2_ZIP:
				ext = "".fb2.zip"";
				break;
		}

		if (ext == null) {
			int j = path.indexOf(""."", nameIndex); // using not lastIndexOf to preserve extensions like `.fb2.zip`
			if (j != -1) {
				ext = path.substring(j);
				path.delete(j, path.length());
			} else {
				return null;
			}
		} else if (path.length() > ext.length() && path.substring(path.length() - ext.length()).equals(ext)) {
			path.delete(path.length() - ext.length(), path.length());
		}

		String query = uri.getQuery();
		if (query != null) {
			index = 0;
			while (index < query.length()) {
				int j = query.indexOf(""&"", index);
				if (j == -1) {
					j = query.length();
				}
				String param = query.substring(index, j);
				if (!param.startsWith(""username="")
					&& !param.startsWith(""password="")
					&& !param.endsWith(""="")) {
					int k = path.length();
					path.append(""_"").append(param);
					while (k < path.length()) {
						char ch = path.charAt(k);
						if (TOESCAPE.indexOf(ch) != -1 || ch == '/') {
							path.setCharAt(k, '_');
						}
						++k;
					}
				}
				index = j + 1;
			}
		}
		return path.append(ext).toString();
	}

	public final String makeBookFileName(int resolvedReferenceType) {
		return makeBookFileName(cleanURL(), BookFormat, resolvedReferenceType);
	}

	public final String localCopyFileName(int resolvedReferenceType) {
		String fileName = makeBookFileName(resolvedReferenceType);
		if (fileName != null && new File(fileName).exists()) {
			return fileName;
		}
		return null;
	}

	public String toString() {
		return ""BookReference[type="" + ReferenceType + "";format="" + BookFormat + "";URL="" + URL + ""]"";
	}
}
",False,90,5,26,3,2,10,2,L6
89,org.geometerplus.fbreader.network.Base64EncodedImage.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.*;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.image.ZLBase64EncodedImage;

import org.geometerplus.fbreader.Paths;

final class Base64EncodedImage extends ZLBase64EncodedImage {
	private static final String ENCODED_SUFFIX = "".base64"";

	private String myDecodedFileName;

	// mimeType string MUST be interned
	public Base64EncodedImage(String mimeType) {
		super(mimeType);
		new File(makeImagesDir()).mkdirs();
	}

	public static String makeImagesDir() {
		return Paths.networkCacheDirectory() + ""/base64"";
	}

	public void setData(String data) {
		myDecodedFileName = makeImagesDir() + File.separator + Integer.toHexString(data.hashCode());
		String type = mimeType();
		if (type == MimeTypes.MIME_IMAGE_PNG) {
			myDecodedFileName += "".png"";
		} else if (type == MimeTypes.MIME_IMAGE_JPEG) {
			myDecodedFileName += "".jpg"";
		}

		if (isCacheValid(new File(myDecodedFileName))) {
			return;
		}

		File file = new File(encodedFileName());
		if (isCacheValid(file)) {
			return;
		}
		try {
			final OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(file), ""UTF-8"");
			try {
				writer.write(data, 0, data.length());
			} finally {
				writer.close();
			}
		} catch (IOException e) {
		}
	}

	@Override
	protected boolean isCacheValid(File file) {
		if (file.exists()) {
			final long diff = System.currentTimeMillis() - file.lastModified();
			final long valid = 24 * 60 * 60 * 1000; // one day in milliseconds; FIXME: hardcoded const
			if (diff >= 0 && diff <= valid) {
				return true;
			}
			file.delete();
		}
		return false;
	}

	@Override
	protected String encodedFileName() {
		return myDecodedFileName + ENCODED_SUFFIX;
	}

	@Override
	protected String decodedFileName() {
		return myDecodedFileName;
	}
}
",True,68,6,21,4,4,1,4,L6
90,org.geometerplus.fbreader.network.NetworkTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.LinkedList;
import java.util.Set;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.tree.FBTree;

public abstract class NetworkTree extends FBTree {
	protected NetworkTree(int level) {
		super(level);
	}

	protected NetworkTree() {
		super();
	}

	protected NetworkTree(NetworkTree parent) {
		super(parent);
	}

	protected NetworkTree(NetworkTree parent, int position) {
		super(parent, position);
	}

	public static ZLImage createCover(NetworkLibraryItem item) {
		if (item.Cover == null) {
			return null;
		}
		return createCover(item.Cover, null);
	}

	private static final String DATA_PREFIX = ""data:"";

	public static ZLImage createCover(String url, String mimeType) {
		if (url == null) {
			return null;
		}
		if (mimeType == null) {
			mimeType = MimeTypes.MIME_IMAGE_AUTO;
		}
		if (url.startsWith(""http://"") || url.startsWith(""https://"") || url.startsWith(""ftp://"")) {
			return new NetworkImage(url, mimeType);
		} else if (url.startsWith(DATA_PREFIX)) {
			int commaIndex = url.indexOf(',');
			if (commaIndex == -1) {
				return null;
			}
			if (mimeType == MimeTypes.MIME_IMAGE_AUTO) {
				int index = url.indexOf(';');
				if (index == -1 || index > commaIndex) {
					index = commaIndex;
				}
	 			// string starts with ""data:image/""
				if (url.startsWith(MimeTypes.MIME_IMAGE_PREFIX, DATA_PREFIX.length())) {
					mimeType = url.substring(DATA_PREFIX.length(), index);
				}
			}
			int key = url.indexOf(""base64"");
			if (key != -1 && key < commaIndex) {
				Base64EncodedImage img = new Base64EncodedImage(mimeType);
				img.setData(url.substring(commaIndex + 1));
				return img;
			}
		}
		return null;
	}


	public abstract NetworkLibraryItem getHoldedItem();

	public void removeItems(Set<NetworkLibraryItem> items) {
		if (items.isEmpty() || subTrees().isEmpty()) {
			return;
		}
		final LinkedList<FBTree> treesList = new LinkedList<FBTree>();
		for (FBTree tree: subTrees()) {
			final NetworkLibraryItem treeItem = ((NetworkTree)tree).getHoldedItem();
			if (treeItem != null && items.contains(treeItem)) {
				treesList.add(tree);
				items.remove(treeItem);
			}
		}
		for (FBTree tree: treesList) {
			tree.removeSelf();
		}
		if (items.isEmpty()) {
			return;
		}
		treesList.clear();
		treesList.addAll(subTrees());
		while (!treesList.isEmpty()) {
			final NetworkTree tree = (NetworkTree) treesList.remove(treesList.size() - 1);
			tree.removeItems(items);
		}
	}
}
",True,227,5,21,15,23,21,7,L6
91,org.geometerplus.fbreader.network.NetworkImage.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.io.*;
import java.net.*;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLFileImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.Paths;

public final class NetworkImage extends ZLLoadableImage implements MimeTypes {
	public final String Url;

	public NetworkImage(String url, String mimeType) {
		super(mimeType);
		Url = url;
		new File(Paths.networkCacheDirectory()).mkdirs();
	}

	private static final String TOESCAPE = ""<>:\""|?*\\"";

	public static String makeImageFilePath(String url, String mimeType) {
		URI uri;
		try {
			uri = new URI(url);
		} catch (java.net.URISyntaxException ex) {
			return null;
		}

		String host = uri.getHost();

		StringBuilder path = new StringBuilder(host);
		if (host.startsWith(""www."")) {
			path.delete(0, 4);
		}
		path.insert(0, File.separator);
		path.insert(0, Paths.networkCacheDirectory());

		int index = path.length();

		path.append(uri.getPath());

		int nameIndex = index;
		while (index < path.length()) {
			char ch = path.charAt(index);
			if (TOESCAPE.indexOf(ch) != -1) {
				path.setCharAt(index, '_');
			}
			if (ch == '/') {
				if (index + 1 == path.length()) {
					path.deleteCharAt(index);
				} else {
					path.setCharAt(index, '_');
					nameIndex = index + 1;
				}
			}
			++index;
		}

		String ext = null;
		if (MIME_IMAGE_PNG.equals(mimeType)) {
			ext = "".png"";
		} else if (MIME_IMAGE_JPEG.equals(mimeType)) {
			if (path.length() > 5 && path.substring(path.length() - 5).equals("".jpeg"")) {
				ext = "".jpeg"";
			} else {
				ext = "".jpg"";
			}
		}

		if (ext == null) {
			int j = path.lastIndexOf(""."");
			if (j > nameIndex) {
				ext = path.substring(j);
				path.delete(j, path.length());
			} else {
				ext = """";
			}
		} else if (path.length() > ext.length() && path.substring(path.length() - ext.length()).equals(ext)) {
			path.delete(path.length() - ext.length(), path.length());
		}

		String query = uri.getQuery();
		if (query != null) {
			index = 0;
			while (index < query.length()) {
				int j = query.indexOf(""&"", index);
				if (j == -1) {
					j = query.length();
				}
				String param = query.substring(index, j);
				if (!param.startsWith(""username="")
					&& !param.startsWith(""password="")
					&& !param.endsWith(""="")) {
					int k = path.length();
					path.append(""_"").append(param);
					while (k < path.length()) {
						char ch = path.charAt(k);
						if (TOESCAPE.indexOf(ch) != -1 || ch == '/') {
							path.setCharAt(k, '_');
						}
						++k;
					}
				}
				index = j + 1;
			}
		}
		return path.append(ext).toString();
	}

	public String getFilePath() {
		return makeImageFilePath(Url, mimeType());
	}

	@Override
	public int sourceType() {
		return SourceType.NETWORK;
	}

	@Override
	public String getId() {
		return Url;
	}

	public String getURI() {
		// TODO: implement
		return null;
	}

	@Override
	public void synchronize() {
		synchronizeInternal(false);
	}

	@Override
	public void synchronizeFast() {
		synchronizeInternal(true);
	}

	private final void synchronizeInternal(boolean doFast) {
		if (isSynchronized()) {
			return;
		}
		try {
			final String path = getFilePath();
			if (path == null) {
				// TODO: error message ???
				return;
			}
			final int index = path.lastIndexOf(File.separator);
			if (index != -1) {
				final String dir = path.substring(0, index);
				final File dirFile = new File(dir);
				if (!dirFile.exists() && !dirFile.mkdirs()) {
					// TODO: error message ???
					return;
				}
				if (!dirFile.exists() || !dirFile.isDirectory()) {
					// TODO: error message ???
					return;
				}
			}
			final File imageFile = new File(path);
			if (imageFile.exists()) {
				final long diff = System.currentTimeMillis() - imageFile.lastModified();
				final long valid = 7 * 24 * 60 * 60 * 1000; // one week in milliseconds; FIXME: hardcoded const
				if (diff >= 0 && diff <= valid) {
					return;
				}
				imageFile.delete();
			}
			if (doFast) {
				return;
			}

			try {
				ZLNetworkManager.Instance().downloadToFile(Url, imageFile);
			} catch (ZLNetworkException e) {
			}
		} finally {
			setSynchronized();
		}
	}

	@Override
	public byte[] byteData() {
		if (!isSynchronized()) {
			return null;
		}
		final String path = getFilePath();
		if (path == null) {
			return null;
		}
		return new ZLFileImage(mimeType(), ZLFile.createFileByPath(path)).byteData();
	}
}
",True,104,6,21,7,11,1,8,L6
92,org.geometerplus.fbreader.network.AbstractNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

public abstract class AbstractNetworkLink implements INetworkLink {
	protected String mySiteName;
	protected String myTitle;
	protected String mySummary;
	protected String myIcon;
	protected final String myLanguage;
	protected final TreeMap<String, String> myLinks;

	/**
	 * Creates new NetworkLink instance.
	 *
	 * @param siteName   name of the corresponding website. Must be not <code>null</code>.
	 * @param title      title of the corresponding library item. Must be not <code>null</code>.
	 * @param summary    description of the corresponding library item. Can be <code>null</code>.
	 * @param icon       string contains link's icon data/url. Can be <code>null</code>.
	 * @param language   language of the catalog. If <code>null</code> we assume this catalog is multilanguage.
	 * @param links      map contains URLs with their identifiers; must always contain one URL with <code>URL_MAIN</code> identifier
	 */
	public AbstractNetworkLink(String siteName, String title, String summary, String icon, String language, Map<String, String> links) {
		mySiteName = siteName;
		myTitle = title;
		mySummary = summary;
		myIcon = icon;
		myLanguage = language != null ? language : ""multi"";
		myLinks = new TreeMap<String, String>(links);
	}

	public String getSiteName() {
		return mySiteName;
	}

	public String getTitle() {
		return myTitle;
	}

	public String getSummary() {
		return mySummary;
	}

	public String getIcon() {
		return myIcon;
	}

	public String getLanguage() {
		return myLanguage;
	}

	public String getLink(String urlKey) {
		return myLinks.get(urlKey);
	}

	public Set<String> getLinkKeys() {
		return myLinks.keySet();
	}

	public NetworkOperationData createOperationData(INetworkLink link,
			NetworkOperationData.OnNewItemListener listener) {
		return new NetworkOperationData(link, listener);
	}

	@Override
	public String toString() {
		String icon = myIcon;
		if (icon.length() > 64) {
			icon = icon.substring(0, 61) + ""..."";
		}
		icon = icon.replaceAll(""\n"", """");
		return ""AbstractNetworkLink: {""
			+ ""siteName="" + mySiteName
			+ ""; title="" + myTitle
			+ ""; summary="" + mySummary
			+ ""; icon="" + icon
			+ ""; links="" + myLinks
			+ ""}"";
	}


	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof AbstractNetworkLink)) {
			return false;
		}
		final AbstractNetworkLink lnk = (AbstractNetworkLink) o;
		if (!mySiteName.equals(lnk.mySiteName)
				|| !myTitle.equals(lnk.myTitle)
				|| !ZLMiscUtil.equals(mySummary, lnk.mySummary)
				|| !ZLMiscUtil.equals(myIcon, lnk.myIcon)
				|| !ZLMiscUtil.mapsEquals(myLinks, lnk.myLinks)) {
			return false;
		}
		return true;
	}
}
",True,220,7,17,14,23,2,3,L6
93,org.geometerplus.fbreader.network.NetworkBookItemComparator.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Comparator;
import java.util.LinkedList;


public final class NetworkBookItemComparator implements Comparator<NetworkLibraryItem> {

	public int compare(NetworkLibraryItem item0, NetworkLibraryItem item1) {
		final boolean item0isABook = item0 instanceof NetworkBookItem;
		final boolean item1isABook = item1 instanceof NetworkBookItem;

		if (!item0isABook && !item1isABook) {
			return item0.Title.compareTo(item1.Title);
		}
		if (!item0isABook || !item1isABook) {
			return item0isABook ? 1 : -1;
		}

		final NetworkBookItem book0 = (NetworkBookItem) item0;
		final NetworkBookItem book1 = (NetworkBookItem) item1;

		final LinkedList<NetworkBookItem.AuthorData> authors0 = book0.Authors;
		final LinkedList<NetworkBookItem.AuthorData> authors1 = book1.Authors;
		
		final boolean authors0empty = authors0.size() == 0;
		final boolean authors1empty = authors1.size() == 0;

		if (authors0empty && !authors1empty) {
			return -1;
		}
		if (authors1empty && !authors0empty) {
			return 1;
		}
		if (!authors0empty && !authors1empty) {
			final int diff = authors0.get(0).SortKey.compareTo(authors1.get(0).SortKey);
			if (diff != 0) {
				return diff;
			}
		}

		/*if (book0.Index != book1.Index) {
			return book0.Index - book1.Index;
		}*/

		final boolean book0HasSeriesTitle = book0.SeriesTitle != null;
		final boolean book1HasSeriesTitle = book1.SeriesTitle != null;

		if (book0HasSeriesTitle && book1HasSeriesTitle) {
			final int comp = book0.SeriesTitle.compareTo(book1.SeriesTitle);
			if (comp != 0) {
				return comp;
			} else {
				final int diff = book0.IndexInSeries - book1.IndexInSeries;
				if (diff != 0) {
					return diff;
				}
			}
			return book0.Title.compareTo(book1.Title);
		}

		final String book0Key = book0HasSeriesTitle ? book0.SeriesTitle : book0.Title;
		final String book1Key = book1HasSeriesTitle ? book1.SeriesTitle : book1.Title;
		final int comp = book0Key.compareTo(book1Key);
		if (comp != 0) {
			return comp;
		}
		return book1HasSeriesTitle ? -1 : 1;
	}
}
",False,221,10,17,14,23,1,2,L6
94,org.geometerplus.fbreader.network.NetworkBookItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;
import java.io.File;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


public final class NetworkBookItem extends NetworkLibraryItem {

	public static class AuthorData implements Comparable<AuthorData> {
		public final String DisplayName;
		public final String SortKey;

		/**
		 * Creates new AuthorData instance. 
		 *
		 * @param displayName author's name. Must be not <code>null</code>.
		 * @param sortKey     string that defines sorting order of book's authors. Must be not <code>null</code>.
		 */
		public AuthorData(String displayName, String sortKey) {
			DisplayName = displayName.intern();
			SortKey = sortKey.intern();
		}

		public int compareTo(AuthorData data) {
			final int key = SortKey.compareTo(data.SortKey);
			if (key != 0) {
				return key;
			}
			return DisplayName.compareTo(data.DisplayName);
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) {
				return true;
			}
			if (!(o instanceof AuthorData)) {
				return false;
			}
			final AuthorData data = (AuthorData) o;
			return SortKey == data.SortKey && DisplayName == data.DisplayName;
		}

		@Override
		public int hashCode() {
			return SortKey.hashCode() + DisplayName.hashCode();
		}
	}

	public final int Index;
	public final String Id;
	//public final String Language;
	//public final String Date;
	public final LinkedList<AuthorData> Authors;
	public final LinkedList<String> Tags;
	public final String SeriesTitle;
	public final int IndexInSeries;

	private final LinkedList<BookReference> myReferences;

	/**
	 * Creates new NetworkLibraryItem instance.
	 *
	 * @param link          corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param id            string that uniquely identifies this book item. Must be not <code>null</code>.
	 * @param index         sequence number of this book in corresponding catalog
	 * @param title         title of this book. Must be not <code>null</code>.
	 * @param summary       description of this book. Can be <code>null</code>.
	 * //@param langage       string specifies language of this book. Can be <code>null</code>.
	 * //@param date          string specifies release date of this book. Can be <code>null</code>.
	 * @param authors       list of book authors. Should contain at least one author.
	 * @param tags          list of book tags. Must be not <code>null</code> (can be empty).
	 * @param seriesTitle   title of this book's series. Can be <code>null</code>.
	 * @param indexInSeries	sequence number of this book within book's series. Ignored if seriesTitle is <code>null</code>.
	 * @param cover         cover url. Can be <code>null</code>.
	 * @param references    list of references related to this book. Must be not <code>null</code>.
	 */
	public NetworkBookItem(INetworkLink link, String id, int index,
		String title, String summary, /*String language, String date,*/
		List<AuthorData> authors, List<String> tags, String seriesTitle, int indexInSeries,
		String cover,
		List<BookReference> references) {
		super(link, title, summary, cover);
		Index = index;
		Id = id;
		//Language = language;
		//Date = date;
		Authors = new LinkedList<AuthorData>(authors);
		Tags = new LinkedList<String>(tags);
		SeriesTitle = seriesTitle;
		IndexInSeries = indexInSeries;
		myReferences = new LinkedList<BookReference>(references);
	}

	public BookReference reference(int type) {
		BookReference reference = null;
		for (BookReference ref: myReferences) {
			if (ref.ReferenceType == type &&
					(reference == null || ref.BookFormat > reference.BookFormat)) {
				reference = ref;
			}
		}

		if (reference == null && type == BookReference.Type.DOWNLOAD_FULL) {
			reference = this.reference(BookReference.Type.DOWNLOAD_FULL_CONDITIONAL);
			if (reference != null) {
				NetworkAuthenticationManager authManager = Link.authenticationManager();
				if (authManager == null || authManager.needPurchase(this)) {
					return null;
				}
				reference = authManager.downloadReference(this);
			}
		}

		if (reference == null &&
				type == BookReference.Type.DOWNLOAD_FULL &&
				this.reference(BookReference.Type.BUY) == null &&
				this.reference(BookReference.Type.BUY_IN_BROWSER) == null) {
			reference = this.reference(BookReference.Type.DOWNLOAD_FULL_OR_DEMO);
		}

		if (reference == null &&
				type == BookReference.Type.DOWNLOAD_DEMO &&
				(this.reference(BookReference.Type.BUY) != null ||
				 this.reference(BookReference.Type.BUY_IN_BROWSER) != null)) {
			reference = this.reference(BookReference.Type.DOWNLOAD_FULL_OR_DEMO);
		}

		return reference;
	}

	public String localCopyFileName() {
		final boolean hasBuyReference =
			this.reference(BookReference.Type.BUY) != null ||
			this.reference(BookReference.Type.BUY_IN_BROWSER) != null;
		BookReference reference = null;
		String fileName = null;
		for (BookReference ref: myReferences) {
			final int type = ref.ReferenceType;
			if ((type == BookReference.Type.DOWNLOAD_FULL ||
					type == BookReference.Type.DOWNLOAD_FULL_CONDITIONAL ||
					(!hasBuyReference && type == BookReference.Type.DOWNLOAD_FULL_OR_DEMO)) &&
					(reference == null || ref.BookFormat > reference.BookFormat)) {
				String name = ref.localCopyFileName(BookReference.Type.DOWNLOAD_FULL);
				if (name != null) {
					reference = ref;
					fileName = name;
				}
			}
		}
		return fileName;
	}

	public void removeLocalFiles() {
		final boolean hasBuyReference =
			this.reference(BookReference.Type.BUY) != null ||
			this.reference(BookReference.Type.BUY_IN_BROWSER) != null;
		for (BookReference ref: myReferences) {
			final int type = ref.ReferenceType;
			if (type == BookReference.Type.DOWNLOAD_FULL ||
					type == BookReference.Type.DOWNLOAD_FULL_CONDITIONAL ||
					(!hasBuyReference && type == BookReference.Type.DOWNLOAD_FULL_OR_DEMO)) {
				String fileName = ref.localCopyFileName(BookReference.Type.DOWNLOAD_FULL);
				if (fileName != null) {
					// TODO: remove a book from the library
					// TODO: remove a record from the database
					new File(fileName).delete();
				}
			}
		}
	}

}
",False,230,6,16,13,23,17,4,L6
95,org.geometerplus.fbreader.network.NetworkDatabase.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Map;

public abstract class NetworkDatabase {
	private static NetworkDatabase ourInstance;

	public static NetworkDatabase Instance() {
		return ourInstance;
	}

	protected NetworkDatabase() {
		ourInstance = this;
	}

	protected abstract void executeAsATransaction(Runnable actions);

	public interface ICustomLinksHandler {
		void handleCustomLinkData(int id, String siteName, String title, String summary, String icon, Map<String, String> links);
	}

	protected abstract void loadCustomLinks(ICustomLinksHandler handler);
	protected abstract void saveCustomLink(ICustomNetworkLink link);
	protected abstract void deleteCustomLink(ICustomNetworkLink link);
}
",False,216,5,17,15,24,2,1,L6
96,org.geometerplus.fbreader.network.NetworkLibrary.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.library.ZLibrary;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.tree.*;
import org.geometerplus.fbreader.network.opds.OPDSLinkReader;


public class NetworkLibrary {
	private static NetworkLibrary ourInstance;

	public static NetworkLibrary Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkLibrary();
		}
		return ourInstance;
	}

	private static class LinksComparator implements Comparator<INetworkLink> {
		private static String filterLinkTitle(String title) {
			for (int index = 0; index < title.length(); ++index) {
				final char ch = title.charAt(index);
				if (ch < 128 && Character.isLetter(ch)) {
					return title.substring(index);
				}
			}
			return title;
		}

		private static int languageOrder(String language) {
			if (language == ZLLanguageUtil.MULTI_LANGUAGE_CODE) {
				return 1;
			}
			if (language.equals(Locale.getDefault().getLanguage())) {
				return 0;
			}
			return 2;
		}

		public int compare(INetworkLink link1, INetworkLink link2) {
			final int languageOrder1 = languageOrder(link1.getLanguage());
			final int languageOrder2 = languageOrder(link2.getLanguage());
			if (languageOrder1 != languageOrder2) {
				return languageOrder1 - languageOrder2;
			}
			final String title1 = filterLinkTitle(link1.getTitle());
			final String title2 = filterLinkTitle(link2.getTitle());
			return title1.compareToIgnoreCase(title2);
		}
	}

	
	public interface OnNewLinkListener {
		void onNewLink(INetworkLink link);
	}

	public final ZLStringOption NetworkSearchPatternOption = new ZLStringOption(""NetworkSearch"", ""Pattern"", """");

	private final ArrayList<INetworkLink> myLinks = new ArrayList<INetworkLink>();

	public List<String> languageCodes() {
		final TreeSet<String> languageSet = new TreeSet<String>();
		for (INetworkLink link : myLinks) {
			languageSet.add(link.getLanguage());
		}
		return new ArrayList<String>(languageSet);
	}

	private ZLStringOption myActiveLanguageCodesOption;
	private ZLStringOption activeLanguageCodesOption() {
 		if (myActiveLanguageCodesOption == null) {
			final TreeSet<String> defaultCodes = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
			defaultCodes.addAll(ZLibrary.Instance().defaultLanguageCodes());
			myActiveLanguageCodesOption =
				new ZLStringOption(
					""Options"",
					""ActiveLanguages"",
					commaSeparatedString(defaultCodes)
				);
		}
		return myActiveLanguageCodesOption;
	}

	public Collection<String> activeLanguageCodes() {
		return Arrays.asList(activeLanguageCodesOption().getValue().split("",""));
	}

	public void setActiveLanguageCodes(Collection<String> codes) {
		final TreeSet<String> allCodes = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
		allCodes.addAll(ZLibrary.Instance().defaultLanguageCodes());
		allCodes.removeAll(languageCodes());
		allCodes.addAll(codes);
		activeLanguageCodesOption().setValue(commaSeparatedString(allCodes));
	}

	private String commaSeparatedString(Collection<String> codes) {
		final StringBuilder builder = new StringBuilder();
		for (String code : codes) {
			builder.append(code);
			builder.append("","");
		}
		if (builder.length() > 0) {
			builder.delete(builder.length() - 1, builder.length());
		}
		return builder.toString();
	}

	private List<INetworkLink> activeLinks() {
		final LinkedList<INetworkLink> filteredList = new LinkedList<INetworkLink>();
		final Collection<String> codes = activeLanguageCodes();
		synchronized (myLinks) {
			for (INetworkLink link : myLinks) {
				if (link instanceof ICustomNetworkLink ||
					codes.contains(link.getLanguage())) {
					filteredList.add(link);
				}
			}
		}
		return filteredList;
	}

	private final RootTree myRootTree = new RootTree();

	private boolean myUpdateChildren = true;
	private boolean myInvalidateChildren;
	private boolean myUpdateVisibility;

	private NetworkLibrary() {
	}

	private boolean myIsAlreadyInitialized;
	public synchronized void initialize() throws ZLNetworkException {
		if (myIsAlreadyInitialized) {
			return;
		}

		try {
			OPDSLinkReader.loadOPDSLinks(OPDSLinkReader.CACHE_LOAD, new OnNewLinkListener() {
				public void onNewLink(INetworkLink link) {
					addLinkInternal(link);
				}
			});
		} catch (ZLNetworkException e) {
			removeAllLoadedLinks();
			throw e;
		}

		final NetworkDatabase db = NetworkDatabase.Instance();
		if (db != null) {
			db.loadCustomLinks(
				new NetworkDatabase.ICustomLinksHandler() {
					public void handleCustomLinkData(int id, String siteName,
							String title, String summary, String icon, Map<String, String> links) {
						final ICustomNetworkLink link = OPDSLinkReader.createCustomLink(id, siteName, title, summary, icon, links);
						if (link != null) {
							addLinkInternal(link);
							link.setSaveLinkListener(myChangesListener);
						}
					}
				}
			);
		}

		/*testDate(new ATOMUpdated(2010,  1,  1,  1,  0,  0,  0,  2,  0),
				 new ATOMUpdated(2009, 12, 31, 23,  0,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2010, 12, 31, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2011,  1,  1,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2010,  1, 31, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2010,  2,  1,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2010,  2, 28, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2010,  3,  1,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2012,  2, 28, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2012,  2, 29,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0, -1, -30),
				 new ATOMUpdated(2012,  2, 16,  1, 10,  0,  0,  0,  0));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  1,  0,  3, 30),
				 new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0,  3, 30));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0,  3, 30),
				 new ATOMUpdated(2012,  2, 15, 23, 40,  1,  0,  3, 30));
		testDate(new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0.001f,  3, 30),
				 new ATOMUpdated(2012,  2, 15, 23, 40,  0,  0,  3, 30));*/
		myIsAlreadyInitialized = true;
	}

	private void removeAllLoadedLinks() {
		synchronized (myLinks) {
			final LinkedList<INetworkLink> toRemove = new LinkedList<INetworkLink>();
			for (INetworkLink link : myLinks) {
				if (!(link instanceof ICustomNetworkLink)) {
					toRemove.add(link);
				}
			}
			myLinks.removeAll(toRemove);
		}
	}

	/*private void testDate(ATOMDateConstruct date1, ATOMDateConstruct date2) {
		String sign = "" == "";
		final int diff = date1.compareTo(date2);
		if (diff > 0) {
			sign = "" > "";
		} else if (diff < 0) {
			sign = "" < "";
		}
		Log.w(""FBREADER"", """" + date1 + sign + date2);
	}*/

	private ArrayList<INetworkLink> myBackgroundLinks;
	private Object myBackgroundLock = new Object();

	// This method must be called from background thread
	public void runBackgroundUpdate(boolean clearCache) throws ZLNetworkException {
		synchronized (myBackgroundLock) {
			myBackgroundLinks = new ArrayList<INetworkLink>();

			final int cacheMode = clearCache ? OPDSLinkReader.CACHE_CLEAR : OPDSLinkReader.CACHE_UPDATE;
			try {
				OPDSLinkReader.loadOPDSLinks(cacheMode, new OnNewLinkListener() {
					public void onNewLink(INetworkLink link) {
						myBackgroundLinks.add(link);
					}
				});
			} catch (ZLNetworkException e) {
				myBackgroundLinks = null;
				throw e;
			} finally {
				if (myBackgroundLinks != null) {
					if (myBackgroundLinks.isEmpty()) {
						myBackgroundLinks = null;
					}
				}
			}
		}
	}

	// This method MUST be called from main thread
	// This method has effect only when runBackgroundUpdate method has returned null.
	//
	// synchronize() method MUST be called after this method
	public void finishBackgroundUpdate() {
		synchronized (myBackgroundLock) {
			if (myBackgroundLinks == null) {
				return;
			}
			synchronized (myLinks) {
				removeAllLoadedLinks();
				myLinks.addAll(myBackgroundLinks);
				updateChildren();
			}
		}
	}


	public String rewriteUrl(String url, boolean externalUrl) {
		final String host = ZLNetworkUtil.hostFromUrl(url).toLowerCase();
		synchronized (myLinks) {
			for (INetworkLink link : myLinks) {
				if (host.contains(link.getSiteName())) {
					url = link.rewriteUrl(url, externalUrl);
				}
			}
		}
		return url;
	}

	public void invalidateChildren() {
		myInvalidateChildren = true;
	}

	public void updateChildren() {
		myUpdateChildren = true;
	}

	public void invalidateVisibility() {
		myUpdateVisibility = true;
	}


	private static boolean linksEqual(INetworkLink l1, INetworkLink l2) {
		return l1 == l2 || l1.getSiteName().equals(l2.getSiteName());
	}

	private static boolean linkIsInvalid(INetworkLink link, INetworkLink nodeLink) {
		if (link instanceof ICustomNetworkLink) {
			if (link != nodeLink) {
				throw new RuntimeException(""Two equal custom links!!! That's impossible"");
			}
			return ((ICustomNetworkLink) link).hasChanges();
		}
		return !link.equals(nodeLink);
	}

	private static void makeValid(INetworkLink link) {
		if (link instanceof ICustomNetworkLink) {
			((ICustomNetworkLink) link).resetChanges();
		}
	}

	private void makeUpToDate() {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();

		ListIterator<FBTree> nodeIterator = myRootTree.subTrees().listIterator();
		FBTree currentNode = null;
		int nodeCount = 0;

		synchronized (myLinks) {
			final ArrayList<INetworkLink> links = new ArrayList<INetworkLink>(activeLinks());
			Collections.sort(links, new LinksComparator());
			for (int i = 0; i < links.size(); ++i) {
				INetworkLink link = links.get(i);
				boolean processed = false;
				while (currentNode != null || nodeIterator.hasNext()) {
					if (currentNode == null) {
						currentNode = nodeIterator.next();
					}
					if (!(currentNode instanceof NetworkCatalogTree)) {
						currentNode = null;
						++nodeCount;
						continue;
					}
					final INetworkLink nodeLink = ((NetworkCatalogTree) currentNode).Item.Link;
					if (linksEqual(link, nodeLink)) {
						if (linkIsInvalid(link, nodeLink)) {
							toRemove.add(currentNode);
						} else {
							processed = true;
						}
						currentNode = null;
						++nodeCount;
						break;
					} else {
						INetworkLink newNodeLink = null;
						for (int j = i; j < links.size(); ++j) {
							final INetworkLink jlnk = links.get(j);
							if (linksEqual(nodeLink, jlnk)) {
								newNodeLink = jlnk;
								break;
							}
						}
						if (newNodeLink == null || linkIsInvalid(newNodeLink, nodeLink)) {
							toRemove.add(currentNode);
							currentNode = null;
							++nodeCount;
						} else {
							break;
						}
					}
				}
				if (!processed) {
					makeValid(link);
					final int nextIndex = nodeIterator.nextIndex();
					new NetworkCatalogRootTree(myRootTree, link, nodeCount++).Item.onDisplayItem();
					nodeIterator = myRootTree.subTrees().listIterator(nextIndex + 1);
				}
			}
		}

		while (currentNode != null || nodeIterator.hasNext()) {
			if (currentNode == null) {
				currentNode = nodeIterator.next();
			}
			if (currentNode instanceof NetworkCatalogTree) {
				toRemove.add(currentNode);
			}
			currentNode = null;
		}

		for (FBTree tree : toRemove) {
			tree.removeSelf();
		}
	}

	private void updateVisibility() {
		for (FBTree tree : myRootTree.subTrees()) {
			if (!(tree instanceof NetworkCatalogTree)) {
				continue;
			}
			((NetworkCatalogTree) tree).updateVisibility();
		}
	}

	public void synchronize() {
		if (myUpdateChildren || myInvalidateChildren) {
			myUpdateChildren = false;
			myInvalidateChildren = false;
			makeUpToDate();
		}
		if (myUpdateVisibility) {
			myUpdateVisibility = false;
			updateVisibility();
		}
	}

	public NetworkTree getTree() {
		return myRootTree;
	}


	public void simpleSearch(String pattern, final NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		LinkedList<ZLNetworkRequest> requestList = new LinkedList<ZLNetworkRequest>();
		LinkedList<NetworkOperationData> dataList = new LinkedList<NetworkOperationData>();

		final NetworkOperationData.OnNewItemListener synchronizedListener = new NetworkOperationData.OnNewItemListener() {
			public synchronized void onNewItem(INetworkLink link, NetworkLibraryItem item) {
				listener.onNewItem(link, item);
			}
			public synchronized boolean confirmInterrupt() {
				return listener.confirmInterrupt();
			}
			public synchronized void commitItems(INetworkLink link) {
				listener.commitItems(link);
			}
		};

		synchronized (myLinks) {
			for (INetworkLink link : activeLinks()) {
				final NetworkOperationData data = link.createOperationData(link, synchronizedListener);
				final ZLNetworkRequest request = link.simpleSearchRequest(pattern, data);
				if (request != null) {
					dataList.add(data);
					requestList.add(request);
				}
			}
		}

		while (requestList.size() != 0) {
			ZLNetworkManager.Instance().perform(requestList);

			requestList.clear();

			if (listener.confirmInterrupt()) {
				return;
			}
			for (NetworkOperationData data : dataList) {
				ZLNetworkRequest request = data.resume();
				if (request != null) {
					requestList.add(request);
				}
			}
		}
	}

	private ICustomNetworkLink.SaveLinkListener myChangesListener = new ICustomNetworkLink.SaveLinkListener() {
		public void onSaveLink(ICustomNetworkLink link) {
			NetworkDatabase.Instance().saveCustomLink(link);
		}
	};

	private <T extends INetworkLink> void addLinkInternal(T link) {
		synchronized (myLinks) {
			myLinks.add(link);
		}
	}

	public void addCustomLink(ICustomNetworkLink link) {
		addLinkInternal(link);
		link.setSaveLinkListener(myChangesListener);
		link.saveLink();
	}

	public void removeCustomLink(ICustomNetworkLink link) {
		synchronized (myLinks) {
			myLinks.remove(link);
		}
		NetworkDatabase.Instance().deleteCustomLink(link);
		link.setSaveLinkListener(null);
	}

	public boolean hasCustomLinkTitle(String title, INetworkLink exceptFor) {
		synchronized (myLinks) {
			for (INetworkLink link : myLinks) {
				if (link != exceptFor && link.getTitle().equals(title)) {
					return true;
				}
			}
		}
		return false;
	}

	public boolean hasCustomLinkSite(String siteName, INetworkLink exceptFor) {
		synchronized (myLinks) {
			for (INetworkLink link : myLinks) {
				if (link != exceptFor && link.getSiteName().equals(siteName)) {
					return true;
				}
			}
		}
		return false;
	}
}
",True,258,4,17,13,37,11,20,L6
97,org.geometerplus.fbreader.network.NetworkLibraryItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

public abstract class NetworkLibraryItem {

	public final INetworkLink Link;
	public final String Title;
	public final String Summary;
	public final String Cover;

	//public org.geometerplus.fbreader.network.atom.ATOMEntry dbgEntry;

	/**
	 * Creates new NetworkLibraryItem instance.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param cover      cover url. Can be <code>null</code>.
	 */
	protected NetworkLibraryItem(INetworkLink link, String title, String summary, String cover) {
		Link = link;
		Title = title;
		Summary = summary;
		Cover = cover;
	}
}
",False,234,5,23,14,23,28,1,L6
98,org.geometerplus.fbreader.network.NetworkOperationData.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;


public class NetworkOperationData {

	public interface OnNewItemListener {
		void onNewItem(INetworkLink link, NetworkLibraryItem item);

		void commitItems(INetworkLink link);

		// returns true to confirm interrupt reading; return false to continue reading.
		// once true has been returned, all next calls must return true.
		boolean confirmInterrupt();
	}

	public final INetworkLink Link;
	public OnNewItemListener Listener;
	public String ResumeURI;

	public NetworkOperationData(INetworkLink link, OnNewItemListener listener) {
		Link = link;
		Listener = listener;
	}

	public void clear() {
		ResumeURI = null;
	}

	public ZLNetworkRequest resume() {
		final ZLNetworkRequest request = Link.resume(this);
		clear();
		return request;
	}
}
",False,222,5,17,14,23,11,3,L6
99,org.geometerplus.fbreader.network.SearchResult.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.LinkedHashMap;
import java.util.LinkedList;

public class SearchResult {

	public final String Summary;
	public final LinkedHashMap<NetworkBookItem.AuthorData, LinkedList<NetworkBookItem>> BooksMap;

	public SearchResult(String summary) {
		Summary = summary;
		BooksMap = new LinkedHashMap<NetworkBookItem.AuthorData, LinkedList<NetworkBookItem>>();
	}

	public void addBook(NetworkBookItem book) {
		for (NetworkBookItem.AuthorData author: book.Authors) {
			LinkedList<NetworkBookItem> list = BooksMap.get(author);
			if (list == null) {
				list = new LinkedList<NetworkBookItem>();
				BooksMap.put(author, list);
			}
			list.add(book);
		}
	}

	public boolean empty() {
		return BooksMap.size() == 0;
	}
}
",False,211,6,17,14,23,3,1,L6
100,org.geometerplus.fbreader.network.DecoratedBookReference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;


public class DecoratedBookReference extends BookReference {

	private final String myCleanURL;

	public DecoratedBookReference(BookReference base, String url) {
		super(url, base.BookFormat, base.ReferenceType);
		myCleanURL = base.cleanURL();
	}

	public String cleanURL() {
		return myCleanURL;
	}
}
",False,89,8,29,4,2,1,1,L6
101,org.geometerplus.fbreader.network.NetworkException.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

public abstract class NetworkException extends ZLNetworkException {
	private static final long serialVersionUID = 8931535868304063605L;

	public static final String ERROR_INTERNAL = ""internalError"";
	public static final String ERROR_PURCHASE_NOT_ENOUGH_MONEY = ""purchaseNotEnoughMoney"";
	public static final String ERROR_PURCHASE_MISSING_BOOK = ""purchaseMissingBook"";
	public static final String ERROR_PURCHASE_ALREADY_PURCHASED = ""purchaseAlreadyPurchased"";
	public static final String ERROR_BOOK_NOT_PURCHASED = ""bookNotPurchased"";
	public static final String ERROR_DOWNLOAD_LIMIT_EXCEEDED = ""downloadLimitExceeded"";

	public static final String ERROR_EMAIL_WAS_NOT_SPECIFIED = ""emailNotSpecified"";

	public static final String ERROR_NO_USER_EMAIL = ""noUserEmail"";

	public static final String ERROR_UNSUPPORTED_OPERATION = ""unsupportedOperation"";

	public static final String ERROR_NOT_AN_OPDS = ""notAnOPDS"";
	public static final String ERROR_NO_REQUIRED_INFORMATION = ""noRequiredInformation"";
	public static final String ERROR_CACHE_DIRECTORY_ERROR = ""cacheDirectoryError"";

	private NetworkException() {
		super(null);
	}
}
",False,116,6,26,8,8,8,1,L6
102,org.geometerplus.fbreader.network.NetworkCatalogItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.*;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

public abstract class NetworkCatalogItem extends NetworkLibraryItem {

	// catalog types:
	public static enum CatalogType {
		OTHER,
		BY_AUTHOR,
		BY_SERIES
	}

	// catalog accessibility types:
	public static enum Accessibility {
		NEVER,
		ALWAYS,
		SIGNED_IN,
		HAS_BOOKS
	}

	// URL type values:
	public static final int URL_NONE = 0;
	public static final int URL_CATALOG = 1;
	public static final int URL_HTML_PAGE = 2;

	private final Accessibility myAccessibility;
	private final CatalogType myCatalogType;
	public final TreeMap<Integer, String> URLByType;

	/**
	 * Creates new NetworkCatalogItem instance with <code>Accessibility.ALWAYS</code> accessibility and <code>CatalogType.OTHER</code> type.
	 *
	 * @param link       corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title      title of this library item. Must be not <code>null</code>.
	 * @param summary    description of this library item. Can be <code>null</code>.
	 * @param cover      cover url. Can be <code>null</code>.
	 * @param urlByType  map contains URLs and their types. Must be not <code>null</code>.
	 */
	public NetworkCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer,String> urlByType) {
		this(link, title, summary, cover, urlByType, Accessibility.ALWAYS, CatalogType.OTHER);
	}

	/**
	 * Creates new NetworkCatalogItem instance with specified accessibility and <code>CatalogType.OTHER</code> type.
	 *
	 * @param link          corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title         title of this library item. Must be not <code>null</code>.
	 * @param summary       description of this library item. Can be <code>null</code>.
	 * @param cover         cover url. Can be <code>null</code>.
	 * @param urlByType     map contains URLs and their types. Must be not <code>null</code>.
	 * @param accessibility value defines when this library item will be accessible
	 *                      in the network library view. 
	 */
	public NetworkCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, Accessibility accessibility) {
		this(link, title, summary, cover, urlByType, accessibility, CatalogType.OTHER);
	}

	/**
	 * Creates new NetworkCatalogItem instance with specified accessibility and type.
	 *
	 * @param link          corresponding NetworkLink object. Must be not <code>null</code>.
	 * @param title         title of this library item. Must be not <code>null</code>.
	 * @param summary       description of this library item. Can be <code>null</code>.
	 * @param cover         cover url. Can be <code>null</code>.
	 * @param urlByType     map contains URLs and their types. Must be not <code>null</code>.
	 * @param accessibility value defines when this library item will be accessible
	 *                      in the network library view. 
	 * @param catalogType   value defines type of this catalog.
	 */
	public NetworkCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, Accessibility accessibility, CatalogType catalogType) {
		super(link, title, summary, cover);
		myAccessibility = accessibility;
		myCatalogType = catalogType;
		URLByType = new TreeMap<Integer, String>(urlByType);
	}

	public Map<String,String> extraData() {
		return Collections.emptyMap();
	}

	public abstract void loadChildren(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException;

	public boolean supportsResumeLoading() {
		return false;
	}

	public void resumeLoading(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}


	/**
	 * Method is called each time this item is displayed to the user.
	 *
	 * This method is called when UI-element corresponding to this item is shown to the User.
	 */
	public void onDisplayItem() {
	}

	public final CatalogType getCatalogType() {
		return myCatalogType;
	}

	public ZLBoolean3 getVisibility() {
		final NetworkAuthenticationManager mgr = Link.authenticationManager();
		switch (myAccessibility) {
			default:
				return ZLBoolean3.B3_FALSE;
			case ALWAYS:
				return ZLBoolean3.B3_TRUE;
			case SIGNED_IN:
				if (mgr == null) {
					return ZLBoolean3.B3_FALSE;
				}
				try {
					return mgr.isAuthorised(false) ?
							ZLBoolean3.B3_TRUE : ZLBoolean3.B3_UNDEFINED;
				} catch (ZLNetworkException e) {
					return ZLBoolean3.B3_UNDEFINED;
				}
			case HAS_BOOKS:
				if (mgr != null && mgr.purchasedBooks().size() > 0) {
					return ZLBoolean3.B3_TRUE;
				} else {
					return ZLBoolean3.B3_FALSE;
				}
		}
	}
}
",False,224,5,17,13,23,14,7,L6
103,org.geometerplus.fbreader.network.INetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import java.util.Set;

import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


public interface INetworkLink {

	String URL_MAIN = ""main"";
	String URL_SEARCH = ""search"";
	String URL_SIGN_IN = ""signIn"";
	String URL_SIGN_OUT = ""signOut"";
	String URL_SIGN_UP = ""signUp"";
	String URL_REFILL_ACCOUNT = ""refillAccount"";
	String URL_RECOVER_PASSWORD = ""recoverPassword"";

	String getSiteName();
	String getTitle();
	String getSummary();
	String getIcon();
	String getLink(String urlKey);
	String getLanguage();

	Set<String> getLinkKeys();

	NetworkOperationData createOperationData(INetworkLink link,
			NetworkOperationData.OnNewItemListener listener);

	ZLNetworkRequest simpleSearchRequest(String pattern, NetworkOperationData data);
	ZLNetworkRequest resume(NetworkOperationData data);

	NetworkCatalogItem libraryItem();
	NetworkAuthenticationManager authenticationManager();

	String rewriteUrl(String url, boolean isUrlExternal);
}
",True,228,5,23,13,23,31,4,L6
104,org.geometerplus.fbreader.network.ICustomNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

public interface ICustomNetworkLink extends INetworkLink {

	public static final int INVALID_ID = -1;

	int getId();
	void setId(int id);

	interface SaveLinkListener {
		void onSaveLink(ICustomNetworkLink link);
	}

	void setSaveLinkListener(SaveLinkListener listener);
	void saveLink();

	void setSiteName(String name);
	void setTitle(String title);
	void setSummary(String summary);
	void setIcon(String icon);

	void setLink(String urlKey, String url);
	void removeLink(String urlKey);

	void reloadInfo() throws ZLNetworkException;

	// returns true if next methods have changed link's data:
	//   setSiteName, setTitle, setSummary, setIcon, setLink, removeLink
	boolean hasChanges();

	// resets hasChanged() result
	void resetChanges();
}
",False,217,5,17,14,24,7,2,L6
105,org.geometerplus.fbreader.network.BuyBookReference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network;

public class BuyBookReference extends BookReference {

	public final String Price;

	public BuyBookReference(String url, int format, int type, String price) {
		super(url, format, type);
		Price = price;
	}

	public static String price(String price, String currency) {
		if (price == null || currency == null) {
			return price;
		} else if (currency.equals(""RUB"")) {
			return price + "" \u0440."";
		} else if (currency.equals(""USD"")) {
			return ""$"" + price;
		} else if (currency.equals(""GBP"")) {
			return ""\u00A3"" + price;
		} else if (currency.equals(""EUR"")) {
			return ""\u20AC"" + price;
		} else if (currency.equals(""JPY"")) {
			return ""\u00A5"" + price;
		}
		return currency + "" "" + price;
	}

}
",False,89,7,22,4,2,3,1,L6
106,org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication;

import java.util.*;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;

import org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager;


public abstract class NetworkAuthenticationManager {
	private static final HashMap<String, NetworkAuthenticationManager> ourManagers = new HashMap<String, NetworkAuthenticationManager>();

	public static NetworkAuthenticationManager createManager(INetworkLink link, String sslCertificate, Class<? extends NetworkAuthenticationManager> managerClass) {
		NetworkAuthenticationManager mgr = ourManagers.get(link.getSiteName());
		if (mgr == null) {
			if (managerClass == LitResAuthenticationManager.class) {
				mgr = new LitResAuthenticationManager(link, sslCertificate);
			}
			if (mgr != null) {
				ourManagers.put(link.getSiteName(), mgr);
			}
		}
		return mgr;
	}


	public final INetworkLink Link;
	public final ZLStringOption UserNameOption;
	public final String SSLCertificate;

	protected NetworkAuthenticationManager(INetworkLink link, String sslCertificate) {
		Link = link;
		UserNameOption = new ZLStringOption(link.getSiteName(), ""userName"", """");
		SSLCertificate = sslCertificate;
	}

	/*
	 * Common manager methods
	 */
	public abstract boolean isAuthorised(boolean useNetwork /* = true */) throws ZLNetworkException;
	public abstract void authorise(String password) throws ZLNetworkException;
	public abstract void logOut();
	public abstract BookReference downloadReference(NetworkBookItem book);
	public abstract Map<String,String> getSmsRefillingData();


	public final boolean mayBeAuthorised(boolean useNetwork) {
		try {
			return isAuthorised(useNetwork);
		} catch (ZLNetworkException e) {
		}
		return true;
	}

	/*
	 * Account specific methods (can be called only if authorised!!!)
	 */
	public abstract String currentUserName();

	public boolean needsInitialization() {
		return false;
	}

	public void initialize() throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}

	// returns true if link must be purchased before downloading
	public boolean needPurchase(NetworkBookItem book) {
		return true;
	}

	public void purchaseBook(NetworkBookItem book) throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}

	public List<NetworkBookItem> purchasedBooks() {
		return Collections.emptyList();
	}

	public String currentAccount() {
		return null;
	}

	//public abstract ZLNetworkSSLCertificate certificate();

	/*
	 * refill account
	 */

	public String refillAccountLink() {
		return null;
	}

	public abstract void initUser(String userName, String sid) throws ZLNetworkException;

	/*
	 * Password Recovery
	 */
	public boolean passwordRecoverySupported() {
		return false;
	}

	public void recoverPassword(String email) throws ZLNetworkException {
		throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
	}
}
",True,221,7,16,12,23,13,7,L6
107,org.geometerplus.fbreader.network.authentication.litres.LitResLoginXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkException;

class LitResLoginXMLReader extends LitResAuthenticationXMLReader {
	private static final String TAG_AUTHORIZATION_OK = ""catalit-authorization-ok"";
	private static final String TAG_AUTHORIZATION_FAILED = ""catalit-authorization-failed"";

	public String FirstName;
	public String LastName;
	public String UserId;
	public String Sid;

	public LitResLoginXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_AUTHORIZATION_FAILED == tag) {
			setException(new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED));
		} else if (TAG_AUTHORIZATION_OK == tag) {
			FirstName = attributes.getValue(""first-name"");
			LastName = attributes.getValue(""first-name"");
			UserId = attributes.getValue(""user-id"");
			Sid = attributes.getValue(""sid"");
		} else {
			setException(new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, HostName));
		}
		return true;
	}
}
",True,115,8,29,7,6,1,4,L6
108,org.geometerplus.fbreader.network.authentication.litres.LitResPasswordRecoveryXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkException;

class LitResPasswordRecoveryXMLReader extends LitResAuthenticationXMLReader {
	private static final String TAG_PASSWORD_RECOVERY_OK = ""catalit-pass-recover-ok"";
	private static final String TAG_PASSWORD_RECOVERY_FAILED = ""catalit-pass-recover-failed"";

	public LitResPasswordRecoveryXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_PASSWORD_RECOVERY_FAILED == tag) {
			final String error = attributes.getValue(""error"");
			if (""1"".equals(error)) {
				setException(new ZLNetworkException(NetworkException.ERROR_NO_USER_EMAIL));
			} else if (""2"".equals(error)) {
				setException(new ZLNetworkException(NetworkException.ERROR_EMAIL_WAS_NOT_SPECIFIED));
			} else {
				setException(new ZLNetworkException(NetworkException.ERROR_INTERNAL));
			}
		} else if (TAG_PASSWORD_RECOVERY_OK == tag) {
			// NOP
		} else {
			setException(new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, HostName));
		}
		return true;
	}
}
",True,115,8,29,7,6,1,4,L6
109,org.geometerplus.fbreader.network.authentication.litres.LitResNetworkRequest.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.io.InputStream;
import java.io.IOException;
import java.net.URLConnection;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

public class LitResNetworkRequest extends ZLNetworkRequest {
	public final LitResAuthenticationXMLReader Reader;

	public LitResNetworkRequest(String url, String sslCertificate, LitResAuthenticationXMLReader reader) {
		super(url, sslCertificate, null);
		Reader = reader;
	}

	@Override
	public void handleStream(URLConnection connection, InputStream inputStream) throws IOException, ZLNetworkException {
		Reader.read(inputStream);
		ZLNetworkException e = Reader.getException();
		if (e != null) {
			throw e;
		}
	}
}
",False,115,8,29,6,8,1,4,L6
110,org.geometerplus.fbreader.network.authentication.litres.LitResXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.HtmlToString;


class LitResXMLReader extends LitResAuthenticationXMLReader {

	public final INetworkLink Link;
	public final List<NetworkLibraryItem> Books;

	private int myIndex;

	private String myBookId;
	private String myTitle;
	//private String myLanguage;
	//private String myDate;
	private String mySeriesTitle;
	private int myIndexInSeries;

	private String mySummary;

	private String myCover;

	private String myAuthorFirstName;
	private String myAuthorMiddleName;
	private String myAuthorLastName;
	private LinkedList<NetworkBookItem.AuthorData> myAuthors = new LinkedList<NetworkBookItem.AuthorData>();

	private LinkedList<String> myTags = new LinkedList<String>();
	private HashMap<Integer, String> myURLByType = new HashMap<Integer, String>(); // TODO: remove
	private LinkedList<BookReference> myReferences = new LinkedList<BookReference>();

	public LitResXMLReader(INetworkLink link, List<NetworkLibraryItem> books) {
		super(link.getSiteName());
		Link = link;
		Books = books;
	}


	private static final int START = 0;
	private static final int CATALOG = 1;
	private static final int BOOK = 2;
	private static final int BOOK_DESCRIPTION = 3;
	private static final int HIDDEN = 4;
	private static final int TITLE_INFO = 5;
	private static final int GENRE = 6;
	private static final int AUTHOR = 7;
	private static final int FIRST_NAME = 8;
	private static final int MIDDLE_NAME = 9;
	private static final int LAST_NAME = 10;
	private static final int BOOK_TITLE = 11;
	private static final int ANNOTATION = 12;
	private static final int DATE = 13;
	private static final int LANGUAGE = 14;

	private static final String TAG_CATALOG = ""catalit-fb2-books"";
	private static final String TAG_BOOK = ""fb2-book"";
	private static final String TAG_TEXT_DESCRIPTION = ""text_description"";
	private static final String TAG_HIDDEN = ""hidden"";
	private static final String TAG_TITLE_INFO = ""title-info"";
	private static final String TAG_GENRE = ""genre"";
	private static final String TAG_AUTHOR = ""author"";
	private static final String TAG_FIRST_NAME = ""first-name"";
	private static final String TAG_MIDDLE_NAME = ""middle-name"";
	private static final String TAG_LAST_NAME = ""last-name"";
	private static final String TAG_BOOK_TITLE = ""book-title"";
	private static final String TAG_ANNOTATION = ""annotation"";
	private static final String TAG_DATE = ""date"";
	private static final String TAG_SEQUENCE = ""sequence"";
	private static final String TAG_LANGUAGE = ""lang"";

	private int myState = START;
	private final StringBuilder myBuffer = new StringBuilder();
	private HtmlToString myHtmlToString = new HtmlToString();

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.intern();

		final char[] bufferContentArray = myBuffer.toString().trim().toCharArray();
		final String bufferContent;
		if (bufferContentArray.length == 0) {
			bufferContent = null;
		} else {
			bufferContent = new String(bufferContentArray);
		}
		myBuffer.delete(0, myBuffer.length());

		switch(myState) {
		case START:
			if (TAG_CATALOG == tag) {
				myState = CATALOG;
			}
			break;
		case CATALOG:
			if (TAG_BOOK == tag) {
				myBookId = attributes.getValue(""hub_id"");
				myCover = attributes.getValue(""cover_preview"");

				final String url = attributes.getValue(""url"");
				if (url != null) {
					myURLByType.put(NetworkCatalogItem.URL_HTML_PAGE, url);
				}

				myReferences.add(new BookReference(
					""https://robot.litres.ru/pages/catalit_download_book/?art="" + myBookId,
					BookReference.Format.FB2_ZIP,
					BookReference.Type.DOWNLOAD_FULL_CONDITIONAL
				));
				myState = BOOK;
			}
			break;
		case BOOK:
			if (TAG_TEXT_DESCRIPTION == tag) {
				myState = BOOK_DESCRIPTION;
			}
			break;
		case BOOK_DESCRIPTION:
			if (TAG_HIDDEN == tag) {
				myState = HIDDEN;
			}
			break;
		case HIDDEN:
			if (TAG_TITLE_INFO == tag) {
				myState = TITLE_INFO;
			}
			break;
		case TITLE_INFO:
			if (TAG_GENRE == tag) {
				myState = GENRE;
			} else if (TAG_AUTHOR == tag) {
				myState = AUTHOR;
			} else if (TAG_BOOK_TITLE == tag) {
				myState = BOOK_TITLE;
			} else if (TAG_ANNOTATION == tag) {
				myHtmlToString.setupTextContent(MimeTypes.MIME_TEXT_XHTML);
				myState = ANNOTATION;
			} else if (TAG_DATE == tag) {
				myState = DATE;
			} else if (TAG_LANGUAGE == tag) {
				myState = LANGUAGE;
			} else if (TAG_SEQUENCE == tag) {
				mySeriesTitle = attributes.getValue(""name"");
				if (mySeriesTitle != null) {
					myIndexInSeries = 0;
					final String indexInSeries = attributes.getValue(""number"");
					if (indexInSeries != null) {
						try {
							myIndexInSeries = Integer.parseInt(indexInSeries);
						} catch (NumberFormatException e) {
						}
					}
				}
				//myState = SEQUENCE; // handled through attributes without state
			}
			break;
		case AUTHOR:
			if (TAG_FIRST_NAME == tag) {
				myState = FIRST_NAME;
			} else if (TAG_MIDDLE_NAME == tag) {
				myState = MIDDLE_NAME;
			} else if (TAG_LAST_NAME == tag) {
				myState = LAST_NAME;
			}
			break;
		case ANNOTATION:
			myHtmlToString.processTextContent(false, tag, attributes, bufferContent);
			break;
		}
		return false;
	}


	@Override
	public boolean endElementHandler(String tag) {
		tag = tag.intern();

		final char[] bufferContentArray = myBuffer.toString().trim().toCharArray();
		final String bufferContent;
		if (bufferContentArray.length == 0) {
			bufferContent = null;
		} else {
			bufferContent = new String(bufferContentArray);
		}
		myBuffer.delete(0, myBuffer.length());

		switch (myState) {
		case CATALOG:
			if (TAG_CATALOG == tag) {
				myState = START;
			}
			break;
		case BOOK:
			if (TAG_BOOK == tag) {

				Books.add(new NetworkBookItem(
					Link,
					myBookId,
					myIndex++,
					myTitle,
					mySummary,
					//myLanguage,
					//myDate,
					myAuthors,
					myTags,
					mySeriesTitle,
					myIndexInSeries,
					myCover,
					myReferences
				));

				myBookId = myTitle = /*myLanguage = myDate = */mySeriesTitle = mySummary = myCover = null;
				myIndexInSeries = 0;
				myAuthors.clear();
				myTags.clear();
				myURLByType.clear();
				myReferences.clear();
				myState = CATALOG;
			}
			break;
		case BOOK_DESCRIPTION:
			if (TAG_TEXT_DESCRIPTION == tag) {
				myState = BOOK;
			}
			break;
		case HIDDEN:
			if (TAG_HIDDEN == tag) {
				myState = BOOK_DESCRIPTION;
			}
			break;
		case TITLE_INFO:
			if (TAG_TITLE_INFO == tag) {
				myState = HIDDEN;
			}
			break;
		case AUTHOR:
			if (TAG_AUTHOR == tag) {
				StringBuilder displayName = new StringBuilder();
				if (myAuthorFirstName != null) {
					displayName.append(myAuthorFirstName).append("" "");
				}
				if (myAuthorMiddleName != null) {
					displayName.append(myAuthorMiddleName).append("" "");
				}
				if (myAuthorLastName != null) {
					displayName.append(myAuthorLastName).append("" "");
				}
				myAuthors.add(new NetworkBookItem.AuthorData(displayName.toString().trim(), myAuthorLastName));
				myAuthorFirstName = null;
				myAuthorMiddleName = null;
				myAuthorLastName = null;
				myState = TITLE_INFO;
			}
			break;
		case FIRST_NAME:
			if (TAG_FIRST_NAME == tag) {
				myAuthorFirstName = bufferContent;
				myState = AUTHOR;
			}
			break;
		case MIDDLE_NAME:
			if (TAG_MIDDLE_NAME == tag) {
				myAuthorMiddleName = bufferContent;
				myState = AUTHOR;
			}
			break;
		case LAST_NAME:
			if (TAG_LAST_NAME == tag) {
				myAuthorLastName = bufferContent;
				myState = AUTHOR;
			}
			break;
		case GENRE:
			if (TAG_GENRE == tag) {
				/*if (bufferContent != null) {
					const std::map<std::string,shared_ptr<LitResGenre> > &genresMap =
						LitResGenreMap::Instance().genresMap();
					const std::map<shared_ptr<LitResGenre>,std::string> &genresTitles =
						LitResGenreMap::Instance().genresTitles();

					std::map<std::string, shared_ptr<LitResGenre> >::const_iterator it = genresMap.find(bufferContent);
					if (it != genresMap.end()) {
						std::map<shared_ptr<LitResGenre>, std::string>::const_iterator jt = genresTitles.find(it->second);
						if (jt != genresTitles.end()) {
							myTags.push_back(jt->second);
						}
					}
				}*/
				myState = TITLE_INFO;
			}
			break;
		case BOOK_TITLE:
			if (TAG_BOOK_TITLE == tag) {
				myTitle = bufferContent;
				myState = TITLE_INFO;
			}
			break;
		case ANNOTATION:
			if (TAG_ANNOTATION == tag) {
				mySummary = myHtmlToString.finishTextContent(bufferContent);
				myState = TITLE_INFO;
			} else {
				myHtmlToString.processTextContent(true, tag, null, bufferContent);
			}
			break;
		case DATE:
			if (TAG_DATE == tag) {
				//myDate = bufferContent;
				myState = TITLE_INFO;
			}
			break;
		case LANGUAGE:
			if (TAG_LANGUAGE == tag) {
				//myLanguage = bufferContent;
				myState = TITLE_INFO;
			}
			break;
		}
		return false;
	}

	@Override
	public void characterDataHandler(char[] data, int start, int length) {
		myBuffer.append(data, start, length);
	}
}
",True,165,0,0,10,27,1,9,L6
111,org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.authentication.*;

public class LitResAuthenticationManager extends NetworkAuthenticationManager {
	private boolean mySidChecked;

	private final ZLStringOption mySidUserNameOption;
	private final ZLStringOption mySidOption;
	private final ZLStringOption myUserIdOption;

	private String myInitializedDataSid;
	private String myAccount;
	private final HashMap<String, NetworkLibraryItem> myPurchasedBooks = new HashMap<String, NetworkLibraryItem>();

	public LitResAuthenticationManager(INetworkLink link, String sslCertificate) {
		super(link, sslCertificate);
		mySidUserNameOption = new ZLStringOption(link.getSiteName(), ""sidUserName"", """");
		mySidOption = new ZLStringOption(link.getSiteName(), ""sid"", """");
		myUserIdOption = new ZLStringOption(link.getSiteName(), ""userId"", """");
	}

	@Override
	public synchronized void initUser(String userName, String sid) throws ZLNetworkException {
		mySidChecked = false;
		mySidUserNameOption.setValue(userName);
		mySidOption.setValue(sid);
		if (!isAuthorised(true)) {
			throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
		}
	}

	private synchronized void initUser(String userName, String sid, String userId) {
		mySidChecked = true;
		mySidUserNameOption.setValue(userName);
		mySidOption.setValue(sid);
		myUserIdOption.setValue(userId);
	}

	@Override
	public synchronized void logOut() {
		initUser("""", """", """");
	}

	@Override
	public boolean isAuthorised(boolean useNetwork /* = true */) throws ZLNetworkException {
		final String sid;
		synchronized (this) {
			boolean authState =
				mySidUserNameOption.getValue().length() != 0 &&
				mySidOption.getValue().length() != 0;

			if (mySidChecked || !useNetwork) {
				return authState;
			}

			if (!authState) {
				logOut();
				return false;
			}
			sid = mySidOption.getValue();
		}

		String url = Link.getLink(INetworkLink.URL_SIGN_IN);
		if (url == null) {
			throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
		}
		url = ZLNetworkUtil.appendParameter(url, ""sid"", sid);

		final LitResLoginXMLReader xmlReader = new LitResLoginXMLReader(Link.getSiteName());

		ZLNetworkException exception = null;
		try {
			ZLNetworkManager.Instance().perform(new LitResNetworkRequest(url, SSLCertificate, xmlReader));
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (exception != null) {
				if (NetworkException.ERROR_AUTHENTICATION_FAILED.equals(exception.getCode())) {
					throw exception;
				}
				logOut();
				return false;
			}
			initUser(UserNameOption.getValue(), xmlReader.Sid, xmlReader.UserId);
			return true;
		}
	}

	@Override
	public void authorise(String password) throws ZLNetworkException {
		String url = Link.getLink(INetworkLink.URL_SIGN_IN);
		if (url == null) {
			throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
		}
		final String login;
		synchronized (this) {
			login = UserNameOption.getValue();
		}
		url = ZLNetworkUtil.appendParameter(url, ""login"", login);
		url = ZLNetworkUtil.appendParameter(url, ""pwd"", password);

		final LitResLoginXMLReader xmlReader = new LitResLoginXMLReader(Link.getSiteName());

		ZLNetworkException exception = null;
		try {
			ZLNetworkManager.Instance().perform(new LitResNetworkRequest(url, SSLCertificate, xmlReader));
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			mySidChecked = true;
			if (exception != null) {
				logOut();
				throw exception;
			}
			initUser(UserNameOption.getValue(), xmlReader.Sid, xmlReader.UserId);
		}
	}

	@Override
	public BookReference downloadReference(NetworkBookItem book) {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			return null;
		}
		BookReference reference = book.reference(BookReference.Type.DOWNLOAD_FULL_CONDITIONAL);
		if (reference == null) {
			return null;
		}
		String url = reference.URL;
		url = ZLNetworkUtil.appendParameter(url, ""sid"", sid);
		return new DecoratedBookReference(reference, url);
	}


	@Override
	public String currentUserName() {
		final String value;
		synchronized (this) {
			value = mySidUserNameOption.getValue();
		}
		if (value.length() == 0) {
			return null;
		}
		return value;
	}


	@Override
	public synchronized boolean needPurchase(NetworkBookItem book) {
		return !myPurchasedBooks.containsKey(book.Id);
	}

	@Override
	public void purchaseBook(NetworkBookItem book) throws ZLNetworkException {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
		}

		BookReference reference = book.reference(BookReference.Type.BUY);
		if (reference == null) {
			throw new ZLNetworkException(NetworkException.ERROR_BOOK_NOT_PURCHASED); // TODO: more correct error message???
		}
		String query = reference.URL;
		query = ZLNetworkUtil.appendParameter(query, ""sid"", sid);

		final LitResPurchaseXMLReader xmlReader = new LitResPurchaseXMLReader(Link.getSiteName());

		ZLNetworkException exception = null;
		try {
			ZLNetworkManager.Instance().perform(new LitResNetworkRequest(query, SSLCertificate, xmlReader));
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (xmlReader.Account != null) {
				myAccount = BuyBookReference.price(xmlReader.Account, ""RUB"");
			}
			if (exception != null) {
				final String code = exception.getCode();
				if (NetworkException.ERROR_AUTHENTICATION_FAILED.equals(code)) {
					logOut();
				} else if (NetworkException.ERROR_PURCHASE_ALREADY_PURCHASED.equals(code)) {
					myPurchasedBooks.put(book.Id, book);
				}
				throw exception;
			}
			if (xmlReader.BookId == null || !xmlReader.BookId.equals(book.Id)) {
				throw new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, Link.getSiteName());
			}
			myPurchasedBooks.put(book.Id, book);
		}
	}

	@Override
	public String refillAccountLink() {
		final String sid;
		synchronized (this) {
			sid = mySidOption.getValue();
		}
		if (sid.length() == 0) {
			return null;
		}
		final String url = Link.getLink(INetworkLink.URL_REFILL_ACCOUNT);
		if (url == null) {
			return null;
		}
		return ZLNetworkUtil.appendParameter(url, ""sid"", sid);
	}

	@Override
	public synchronized String currentAccount() {
		return myAccount;
	}

	void reloadPurchasedBooks() throws ZLNetworkException {
		final LitResNetworkRequest networkRequest;
		synchronized (this) {
			final String sid = mySidOption.getValue();
			if (sid.length() == 0) {
				throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
			}
			if (!sid.equals(myInitializedDataSid)) {
				logOut();
				throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
			}
			networkRequest = loadPurchasedBooks();
		}

		ZLNetworkException exception = null;
		try {
			ZLNetworkManager.Instance().perform(networkRequest);
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (exception != null) {
				//loadPurchasedBooksOnError();
				if (NetworkException.ERROR_AUTHENTICATION_FAILED.equals(exception.getCode())) {
					logOut();
				}
				throw exception;
			}
			loadPurchasedBooksOnSuccess(networkRequest);
		}
	}

	@Override
	public synchronized List<NetworkBookItem> purchasedBooks() {
		return new ArrayList(myPurchasedBooks.values());
	}

	@Override
	public synchronized boolean needsInitialization() {
		final String sid = mySidOption.getValue();
		if (sid.length() == 0) {
			return false;
		}
		return !sid.equals(myInitializedDataSid);
	}

	@Override
	public void initialize() throws ZLNetworkException {
		final String sid;
		final LitResNetworkRequest purchasedBooksRequest;
		final LitResNetworkRequest accountRequest;
		synchronized (this) {
			sid = mySidOption.getValue();
			if (sid.length() == 0) {
				throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
			}
			if (sid.equals(myInitializedDataSid)) {
				return;
			}

			purchasedBooksRequest = loadPurchasedBooks();
			accountRequest = loadAccount();
		}

		final LinkedList<ZLNetworkRequest> requests = new LinkedList<ZLNetworkRequest>();
		requests.add(purchasedBooksRequest);
		requests.add(accountRequest);

		ZLNetworkException exception = null;
		try {
			ZLNetworkManager.Instance().perform(requests);
		} catch (ZLNetworkException e) {
			exception = e;
		}

		synchronized (this) {
			if (exception != null) {
				myInitializedDataSid = null;
				loadPurchasedBooksOnError();
				loadAccountOnError();
				throw exception;
			}
			myInitializedDataSid = sid;
			loadPurchasedBooksOnSuccess(purchasedBooksRequest);
			loadAccountOnSuccess(accountRequest);
		}
	}

	private LitResNetworkRequest loadPurchasedBooks() {
		final String sid = mySidOption.getValue();

		String query = ""pages/catalit_browser/"";
		query = ZLNetworkUtil.appendParameter(query, ""my"", ""1"");
		query = ZLNetworkUtil.appendParameter(query, ""sid"", sid);

		return new LitResNetworkRequest(
			LitResUtil.url(Link, query),
			SSLCertificate,
			new LitResXMLReader(Link, new LinkedList<NetworkLibraryItem>())
		);
	}

	private void loadPurchasedBooksOnError() {
		myPurchasedBooks.clear();
	}

	private void loadPurchasedBooksOnSuccess(LitResNetworkRequest purchasedBooksRequest) {
		LitResXMLReader reader = (LitResXMLReader)purchasedBooksRequest.Reader;
		myPurchasedBooks.clear();
		for (NetworkLibraryItem item: reader.Books) {
			if (item instanceof NetworkBookItem) {
				NetworkBookItem book = (NetworkBookItem)item;
				myPurchasedBooks.put(book.Id, book);
			}
		}
	}

	private LitResNetworkRequest loadAccount() {
		final String sid = mySidOption.getValue();

		String query = ""pages/purchase_book/"";
		query = ZLNetworkUtil.appendParameter(query, ""sid"", sid);
		query = ZLNetworkUtil.appendParameter(query, ""art"", ""0"");

		return new LitResNetworkRequest(
			LitResUtil.url(Link, query),
			SSLCertificate,
			new LitResPurchaseXMLReader(Link.getSiteName())
		);
	}

	private void loadAccountOnError() {
		myAccount = null;
	}

	private void loadAccountOnSuccess(LitResNetworkRequest accountRequest) {
		LitResPurchaseXMLReader reader = (LitResPurchaseXMLReader)accountRequest.Reader;
		myAccount = BuyBookReference.price(reader.Account, ""RUB"");
	}

	@Override
	public boolean passwordRecoverySupported() {
		return true;
	}

	@Override
	public void recoverPassword(String email) throws ZLNetworkException {
		String url = Link.getLink(INetworkLink.URL_RECOVER_PASSWORD);
		if (url == null) {
			throw new ZLNetworkException(NetworkException.ERROR_UNSUPPORTED_OPERATION);
		}
		url = ZLNetworkUtil.appendParameter(url, ""mail"", email);
		final LitResPasswordRecoveryXMLReader xmlReader =  new LitResPasswordRecoveryXMLReader(Link.getSiteName());
		ZLNetworkManager.Instance().perform(new LitResNetworkRequest(url, SSLCertificate, xmlReader));
	}

	@Override
	public Map<String,String> getSmsRefillingData() {
		final HashMap<String,String> map = new HashMap<String,String>();
		map.put(""litres:userId"", myUserIdOption.getValue());
		map.put(""litres:sid"", mySidOption.getValue());
		return map;
	}
}
",False,220,7,17,11,23,4,19,L6
112,org.geometerplus.fbreader.network.authentication.litres.LitResRecommendationsItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.Map;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkBookItem;
import org.geometerplus.fbreader.network.opds.OPDSCatalogItem;

public class LitResRecommendationsItem extends OPDSCatalogItem {
	public LitResRecommendationsItem(INetworkLink link, String title, String summary, String cover, Map<Integer,String> urlByType, Accessibility accessibility) {
		super(link, title, summary, cover, urlByType, accessibility, CatalogType.BY_SERIES);
	}

	@Override
	protected String getUrl() {
		final LitResAuthenticationManager mgr =
			(LitResAuthenticationManager)Link.authenticationManager();
		final StringBuilder builder = new StringBuilder();
		boolean flag = false;
		for (NetworkBookItem book : mgr.purchasedBooks()) {
			if (flag) {
				builder.append(',');
			} else {
				flag = true;
			}
			builder.append(book.Id);
		}

		return ZLNetworkUtil.appendParameter(URLByType.get(URL_CATALOG), ""ids"", builder.toString());
	}
}
",False,194,0,0,12,34,1,7,L6
113,org.geometerplus.fbreader.network.authentication.litres.LitResPurchaseXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkException;

class LitResPurchaseXMLReader extends LitResAuthenticationXMLReader {
	private static final String TAG_AUTHORIZATION_FAILED = ""catalit-authorization-failed"";
	private static final String TAG_PURCHASE_OK = ""catalit-purchase-ok"";
	private static final String TAG_PURCHASE_FAILED = ""catalit-purchase-failed"";

	public String Account;
	public String BookId;

	public LitResPurchaseXMLReader(String hostName) {
		super(hostName);
	}

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		tag = tag.toLowerCase().intern();
		if (TAG_AUTHORIZATION_FAILED == tag) {
			setException(new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED));
		} else {
			Account = attributes.getValue(""account"");
			BookId = attributes.getValue(""art"");
			if (TAG_PURCHASE_OK == tag) {
				// nop
			} else if (TAG_PURCHASE_FAILED == tag) {
				final String error = attributes.getValue(""error"");
				if (""1"".equals(error)) {
					setException(new ZLNetworkException(NetworkException.ERROR_PURCHASE_NOT_ENOUGH_MONEY));
				} else if (""2"".equals(error)) {
					setException(new ZLNetworkException(NetworkException.ERROR_PURCHASE_MISSING_BOOK));
				} else if (""3"".equals(error)) {
					setException(new ZLNetworkException(NetworkException.ERROR_PURCHASE_ALREADY_PURCHASED));
				} else {
					setException(new ZLNetworkException(NetworkException.ERROR_INTERNAL));
				}
			} else {
				setException(new ZLNetworkException(NetworkException.ERROR_SOMETHING_WRONG, HostName));
			}
		}
		return true;
	}
}
",True,115,8,29,7,6,1,4,L6
114,org.geometerplus.fbreader.network.authentication.litres.LitResGenre.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.LinkedList;

class LitResGenre {
	public String Id;
	public String Title;
	public LinkedList<LitResGenre> Children;
}
",False,1,0,0,0,0,0,0,I0
115,org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

class LitResAuthenticationXMLReader extends ZLXMLReaderAdapter {
	public final String HostName;

	public LitResAuthenticationXMLReader(String hostName) {
		HostName = hostName;
	}

	private ZLNetworkException myException;

	protected void setException(ZLNetworkException e) {
		myException = e;
	}

	protected void setErrorMessage(String errorMessage) {
		myException = new ZLNetworkException(true, errorMessage);
	}

	public ZLNetworkException getException() {
		return myException;
	}
}
",False,117,9,28,6,8,5,2,L6
116,org.geometerplus.fbreader.network.authentication.litres.LitResBookshelfItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import java.util.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;

public class LitResBookshelfItem extends NetworkCatalogItem {
	private boolean myForceReload;

	public LitResBookshelfItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, Accessibility accessibility) {
		super(link, title, summary, cover, urlByType, accessibility);
	}

	@Override
	public void onDisplayItem() {
		myForceReload = false;
	}

	@Override
	public void loadChildren(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		final LitResAuthenticationManager mgr =
			(LitResAuthenticationManager)Link.authenticationManager();

		// TODO: Maybe it's better to call isAuthorised(true) directly 
		// and let exception fly through???
		if (!mgr.mayBeAuthorised(true)) {
			throw new ZLNetworkException(NetworkException.ERROR_AUTHENTICATION_FAILED);
		}
		try {
			if (myForceReload) {
				mgr.reloadPurchasedBooks();
			}
		} finally {
			myForceReload = true;
			// TODO: implement asynchronous loading
			ArrayList<NetworkBookItem> children =
				new ArrayList<NetworkBookItem>(mgr.purchasedBooks());
			Collections.sort(children, new NetworkBookItemComparator());
			for (NetworkLibraryItem item : children) {
				listener.onNewItem(Link, item);
			}
			listener.commitItems(Link);
		}
	}
}
",False,221,9,17,12,23,1,9,L6
117,org.geometerplus.fbreader.network.authentication.litres.LitResUtil.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.INetworkLink;


class LitResUtil {

	public static String url(String path) {
		String url = ""://robot.litres.ru/"" + path;
		if (ZLNetworkUtil.hasParameter(url, ""sid"") ||
				ZLNetworkUtil.hasParameter(url, ""pwd"")) {
			url = ""https"" + url;
		} else {
			url = ""http"" + url;
		}
		return url;
	}

	public static String url(INetworkLink link, String path) {
		return link.rewriteUrl(url(path), false);
	}
}
",False,165,0,0,14,23,1,2,L6
118,org.geometerplus.fbreader.network.authentication.litres.LitResGenreMap.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.authentication.litres;

/*import java.util.LinkedList;
import java.util.HashMap;

class LitResGenreMap {

	private static LitResGenreMap ourInstance;

	LinkedList<LitResGenre> myGenresTree;
	HashMap<String, LitResGenre> myGenresMap;
	HashMap<LitResGenre, String> myGenresTitles;

	public static LitResGenreMap Instance() {
		if (ourInstance == null) {
			ourInstance = new LitResGenreMap();
		}
		return ourInstance;
	}

	private LitResGenreMap() {
	}
}
*/",False,1,0,0,0,0,0,0,I0
119,org.geometerplus.fbreader.network.atom.ATOMDateConstruct.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public abstract class ATOMDateConstruct extends ATOMCommonAttributes implements Comparable<ATOMDateConstruct> {

	public int Year;
	public int Month;
	public int Day;
	public int Hour;
	public int Minutes;
	public int Seconds;
	public float SecondFraction;
	public int TZHour;
	public int TZMinutes;

	public ATOMDateConstruct() {
	}

	public ATOMDateConstruct(int year) {
		Year = year;
	}

	public ATOMDateConstruct(int year, int month, int day) {
		Year = year;
		Month = month;
		Day = day;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
		SecondFraction = sfract;
	}

	public ATOMDateConstruct(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		Year = year;
		Month = month;
		Day = day;
		Hour = hour;
		Minutes = minutes;
		Seconds = seconds;
		TZHour = tzhour;
		TZMinutes = tzminutes;
		SecondFraction = sfract;
	}

	public static boolean parse(String str, ATOMDateConstruct dateTime) {
		dateTime.Year = 0;
		dateTime.Month = 0;
		dateTime.Day = 0;
		dateTime.Hour = 0;
		dateTime.Minutes = 0;
		dateTime.Seconds = 0;
		dateTime.SecondFraction = 0.0f;
		dateTime.TZHour = 0;
		dateTime.TZMinutes = 0;

		if (str == null || dateTime == null) {
			return false;
		}

		final int len = str.length();
		if (len != 4 && len != 7 && len != 10 && len != 17 && len != 20 && len < 22) {
			return false;
		}

		int num = 0, sign = 1;
		float fnum = 0.0f, fmult = 0.1f;
		int start, end, log;
		char ch;
		end = 4; start = 0; log = 0;
		while (start < len) {
			ch = str.charAt(start++);
			if (!Character.isDigit(ch)) {
				return false;
			}
			num = 10 * num + ((int) (ch - '0'));
			fnum += fmult * ((int) (ch - '0'));
			fmult *= 0.1f;
			if (start == end) {
				switch (log) {
				case 0: dateTime.Year = num; break;
				case 1: dateTime.Month = num; break;
				case 2: dateTime.Day = num; break;
				case 3: dateTime.Hour = num; break;
				case 4: dateTime.Minutes = num; break;
				case 5: dateTime.Seconds = num; break;
				case 6: dateTime.SecondFraction = fnum; break;
				case 7: dateTime.TZHour = sign * num; break;
				case 8: dateTime.TZMinutes = sign * num; break;
				default: return false;
				}
				num = 0; fnum = 0.0f; fmult = 0.1f;
				if (start == len) return true;
				switch (log) {
				case 0:
				case 1:
					if (str.charAt(start++) != '-') return false;
					end = start + 2;
					break;
				case 2:
					if (str.charAt(start++) != 'T') return false;
					end = start + 2;
					break;
				case 3:
				case 7:
					if (str.charAt(start++) != ':') return false;
					end = start + 2;
					break;
				case 4:
					ch = str.charAt(start++);
					if (ch == ':') {
						end = start + 2;
					} else if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						log += 2;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				case 5:
					ch = str.charAt(start++);
					if (ch == '.') {
						end = start;
						while (Character.isDigit(str.charAt(++end))) /* NOP */;
					} else if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						log += 1;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				case 6:
					ch = str.charAt(start++);
					if (ch == '+' || ch == '-') {
						sign = (ch == '-') ? -1 : 1;
						end = start + 2;
					} else if (ch == 'Z') {
						return true;
					} else return false;
					break;
				//case 8:
				default: return false;
				}
				++log;
			}
		}
		return false;
	}

	private static void appendChars(StringBuilder buffer, char ch, int count) {
		while (count-- > 0) {
			buffer.append(ch);
		}
	}

	public final String getDateTime(boolean brief) {
		StringBuilder timezone = new StringBuilder(""Z"");
		if (TZMinutes != 0 || TZHour != 0) {
			int tzminnum = TZMinutes;
			int tzhournum = TZHour;
			char sign;
			if (tzhournum == 0) {
				sign = (tzminnum >= 0) ? '+' : '-';
			} else {
				sign = (tzhournum > 0) ? '+' : '-';
				if (tzhournum > 0 && tzminnum < 0) {
					--tzhournum;
					tzminnum = 60 + tzminnum;
				} else if (tzhournum < 0 && tzminnum > 0) {
					++tzhournum;
					tzminnum = 60 - tzminnum;
				}
			}
			String tzmin = String.valueOf(tzminnum < 0 ? -tzminnum : tzminnum);
			String tzhour = String.valueOf(tzhournum < 0 ? -tzhournum : tzhournum);
			timezone.append(sign);
			appendChars(timezone, '0', 2 - tzhour.length());
			timezone.append(tzhour);
			timezone.append(':');
			appendChars(timezone, '0', 2 - tzmin.length());
			timezone.append(tzmin);
		}

		StringBuilder time = new StringBuilder();
		StringBuilder temp = new StringBuilder();
		if (SecondFraction >= 0.01f) {
			int sfrnum = Math.round(100 * SecondFraction);
			String sfr = String.valueOf(sfrnum);
			time.append('.');
			appendChars(time, '0', 2 - sfr.length());
			time.append(sfr);
		}
		if (!brief || time.length() != 0 || Seconds != 0) {
			String sec = String.valueOf(Seconds);
			temp.append(':');
			appendChars(temp, '0', 2 - sec.length());
			temp.append(sec);
			time.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}
		if (!brief || time.length() != 0 || Hour != 0 || Minutes != 0 || timezone.length() > 1) {
			String hour = String.valueOf(Hour);
			String min = String.valueOf(Minutes);
			appendChars(temp, '0', 2 - hour.length());
			temp.append(hour);
			temp.append(':');
			appendChars(temp, '0', 2 - min.length());
			temp.append(min);
			time.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}

		StringBuilder date = new StringBuilder();
		if (!brief || time.length() != 0 || Day != 0) {
			String day = String.valueOf(Day);
			date.append('-');
			appendChars(date, '0', 2 - day.length());
			date.append(day);
		}
		if (!brief || date.length() != 0 || Month != 0) {
			String month = String.valueOf(Month);
			temp.append('-');
			appendChars(temp, '0', 2 - month.length());
			temp.append(month);
			date.insert(0, temp.toString());
			temp.delete(0, temp.length());
		}

		String year = String.valueOf(Year);
		appendChars(temp, '0', 4 - year.length());
		temp.append(year);
		date.insert(0, temp.toString());
		temp.delete(0, temp.length());

		if (!brief || time.length() != 0) {
			date.append('T');
			date.append(time.toString());
			date.append(timezone.toString());
		}
		return date.toString();
	}

	@Override
	public String toString() {
		return getDateTime(false);
	}

	private static final int[] DAYS_IN_MONTHS = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	private int daysInMonth(int month, int year) {
		--month;
		while (month > 11) month -= 12;
		while (month < 0) month += 12;
		if (month == 1 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) {
			return DAYS_IN_MONTHS[1] + 1;
		}
		return DAYS_IN_MONTHS[month];
	}

	public int compareTo(ATOMDateConstruct date) {
		int dateYear = date.Year;
		int dateMonth = date.Month;
		int dateDay = date.Day;
		int dateHour = date.Hour;
		int dateMinutes = date.Minutes;
		if (TZHour != date.TZHour || TZMinutes != date.TZMinutes) {
			dateMinutes += TZMinutes - date.TZMinutes;
			while (dateMinutes < 0) { dateMinutes += 60; --dateHour; }
			while (dateMinutes > 59) { dateMinutes -= 60; ++dateHour; }
			dateHour += TZHour - date.TZHour;
			while (dateHour < 0) { dateHour += 24; --dateDay; }
			while (dateHour > 23) { dateHour -= 24; ++dateDay; }
			while (dateDay < 1) dateDay += daysInMonth(--dateMonth, dateYear);
			while (dateDay > daysInMonth(dateMonth, dateYear)) dateDay -= daysInMonth(dateMonth++, dateYear);
			while (dateMonth < 1) { dateMonth += 12; --dateYear; }
			while (dateMonth > 12) { dateMonth -= 12; ++dateYear; }
		}
		if (Year != dateYear) return Year - dateYear;
		if (Month != dateMonth) return Month - dateMonth;
		if (Day != dateDay) return Day - dateDay;
		if (Hour != dateHour) return Hour - dateHour;
		if (Minutes != dateMinutes) return Minutes - dateMinutes;
		if (Seconds != date.Seconds) return Seconds - date.Seconds;
		return Math.round(100 * SecondFraction) - Math.round(100 * date.SecondFraction);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof ATOMDateConstruct)) {
			return false;
		}
		return compareTo((ATOMDateConstruct) obj) == 0;
	}
};

",True,67,7,17,3,1,5,1,L6
120,org.geometerplus.fbreader.network.atom.ATOMUpdated.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMUpdated extends ATOMDateConstruct {

	public ATOMUpdated() {
	}

	public ATOMUpdated(int year) {
		super(year);
	}

	public ATOMUpdated(int year, int month, int day) {
		super(year, month, day);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public ATOMUpdated(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
}
",False,65,6,17,4,1,5,1,L6
121,org.geometerplus.fbreader.network.atom.ATOMLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


public class ATOMLink extends ATOMCommonAttributes {

	public static final String HREF = ""href"";
	public static final String REL = ""rel"";
	public static final String TYPE = ""type"";
	public static final String HREFLANG = ""hreflang"";
	public static final String TITLE = ""title"";
	public static final String LENGTH = ""length"";

	@Override
	public void readAttributes(ZLStringMap source) {
		super.readAttributes(source);
		readAttribute(HREF, source);
		readAttribute(REL, source);
		readAttribute(TYPE, source);
		readAttribute(HREFLANG, source);
		readAttribute(TITLE, source);
		readAttribute(LENGTH, source);
	}

	public final String getHref() {
		return getAttribute(HREF);
	}

	public final String getRel() {
		return getAttribute(REL);
	}

	public final String getType() {
		return getAttribute(TYPE);
	}

	public final String getHrefLang() {
		return getAttribute(HREFLANG);
	}

	public final String getTitle() {
		return getAttribute(TITLE);
	}

	public final String getLength() {
		return getAttribute(LENGTH);
	}
}
",False,65,7,17,2,2,7,2,L6
122,org.geometerplus.fbreader.network.atom.ATOMGenerator.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


public class ATOMGenerator extends ATOMCommonAttributes {

	public static final String URI = ""uri"";
	public static final String VERSION = ""version"";

	public String Text;

	@Override
	public void readAttributes(ZLStringMap source) {
		super.readAttributes(source);
		readAttribute(URI, source);
		readAttribute(VERSION, source);
	}

	public final String getUri() {
		return getAttribute(URI);
	}

	public final String getVersion() {
		return getAttribute(VERSION);
	}
}
",False,4,0,0,2,2,0,2,L7
123,org.geometerplus.fbreader.network.atom.ATOMIcon.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMIcon extends ATOMCommonAttributes {

	public String Uri;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,62,8,17,3,1,3,1,L6
124,org.geometerplus.fbreader.network.atom.ATOMId.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMId extends ATOMCommonAttributes {

	public String Uri;

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof ATOMId)) {
			return false;
		}
		ATOMId id = (ATOMId) o;
		return Uri.equals(id.Uri);
	}

	@Override
	public int hashCode() {
		return Uri.hashCode();
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,64,7,17,3,1,5,1,L6
125,org.geometerplus.fbreader.network.atom.ATOMEntry.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import java.util.*;


public class ATOMEntry extends ATOMCommonAttributes {

	public ATOMId Id;

	public LinkedList<ATOMAuthor> Authors = new LinkedList<ATOMAuthor>();
	public LinkedList<ATOMCategory> Categories = new LinkedList<ATOMCategory>();
	public LinkedList<ATOMContributor> Contributors = new LinkedList<ATOMContributor>();
	public LinkedList<ATOMLink> Links = new LinkedList<ATOMLink>();
	public ATOMPublished Published;
	//public String Rights;  // TODO: implement ATOMTextConstruct
	//public final ATOMSource Source; // TODO: implement ATOMSource
	public String Summary; // TODO: implement ATOMTextConstruct
	public String Content; // TODO: implement ATOMContent
	public String Title;   // TODO: implement ATOMTextConstruct
	public ATOMUpdated Updated;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["")
			.append(super.toString())
			.append("",\nId="").append(Id)
			.append("",\nAuthors:[\n"");

		boolean first = true;
		for (ATOMAuthor author: Authors) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(author.toString());
		}
		buf.append(""],\nCategories:[\n"");
		first = true;
		for (ATOMCategory category: Categories) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(category.toString());
		}
		buf.append(""],\nLinks:[\n"");
		first = true;
		for (ATOMLink link: Links) {
			if (!first) buf.append("",\n"");
			first = false;
			buf.append(link.toString());
		}
		return buf
			.append(""]"")
			.append("",\nPublished="").append(Published)
			//.append("",\nRights="").append(Rights)
			.append("",\nSummary="").append(Summary)
			.append("",\nTitle="").append(Title)
			.append("",\nUpdated="").append(Updated)
			.append(""]"")
			.toString();
	}
}
",False,70,7,17,3,9,4,9,L6
126,org.geometerplus.fbreader.network.atom.ATOMPublished.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMPublished extends ATOMDateConstruct {

	public ATOMPublished() {
	}

	public ATOMPublished(int year) {
		super(year);
	}

	public ATOMPublished(int year, int month, int day) {
		super(year, month, day);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public ATOMPublished(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
}
",False,63,8,17,4,1,2,1,L6
127,org.geometerplus.fbreader.network.atom.ATOMCommonAttributes.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


abstract class ATOMCommonAttributes {
	public static final String XML_BASE = ""xml:base"";
	public static final String XML_LANG = ""xml:lang"";

	private ZLStringMap myAttributes;

	public void readAttributes(ZLStringMap source) {
		readAttribute(XML_BASE, source);
		readAttribute(XML_LANG, source);
	}

	protected final void readAttribute(String name, ZLStringMap source) {
		String value = source.getValue(name);
		if (value != null) {
			value = value.trim().intern();
			if (value.length() > 0) {
				if (myAttributes == null) {
					myAttributes = new ZLStringMap();
				}
				myAttributes.put(name, value);
			}
		}
	}

	public final String getAttribute(String name) {
		if (myAttributes == null) {
			return null;
		}
		return myAttributes.getValue(name);
	}

	public final String getLang() {
		return getAttribute(XML_LANG);
	}

	public final String getBase() {
		return getAttribute(XML_BASE);
	}

	// FIXME: HACK: addAttribute is used ONLY to add OPDSPrice to the ATOMLink... Must be killed + SEE NetworkOPDSFeedReader
	// name and value MUST BE not null AND MUST BE INTERNED String objects
	public void addAttribute(String name, String value) {
		if (value != null) {
			value = value.trim().intern();
			if (value.length() > 0) {
				if (myAttributes == null) {
					myAttributes = new ZLStringMap();
				}
				myAttributes.put(name, value);
			}
		}
	}

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""[Attributes:\n"");
		if (myAttributes != null) {
			for (int i = 0; i < myAttributes.getSize(); ++i) {
				String key = myAttributes.getKey(i);
				String value = myAttributes.getValue(key);
				if (i != 0) {
					buf.append("",\n"");
				}
				buf.append(key).append(""="").append(value);
			}
		}
		buf.append(""]"");
		return buf.toString();
	}
}
",False,77,8,17,2,1,12,1,L1
128,org.geometerplus.fbreader.network.atom.ATOMConstants.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public interface ATOMConstants {

	String TYPE_TEXT = ""text"";
	String TYPE_HTML = ""html"";
	String TYPE_XHTML = ""xhtml"";
	String TYPE_DEFAULT = TYPE_TEXT;

	String REL_ALTERNATE = ""alternate"";
	String REL_RELATED = ""related"";
	String REL_SELF = ""self"";
	String REL_ENCLOSURE = ""enclosure"";
	String REL_VIA = ""via"";
}
",False,86,9,25,0,0,2,0,L6
129,org.geometerplus.fbreader.network.atom.ATOMFeedMetadata.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import java.util.*;


public class ATOMFeedMetadata extends ATOMCommonAttributes {

	public ATOMId Id;

	public LinkedList<ATOMAuthor> Authors = new LinkedList<ATOMAuthor>();
	public LinkedList<ATOMCategory> Categories = new LinkedList<ATOMCategory>();
	//public LinkedList<ATOMContributor> Contributors = new LinkedList<ATOMContributor>();
	//public ATOMGenerator Generator;
	public ATOMIcon Icon;
	public LinkedList<ATOMLink> Links = new LinkedList<ATOMLink>();
	//public ATOMLogo Logo;
	//public String Rights;   // TODO: implement ATOMTextConstruct
	public String Subtitle; // TODO: implement ATOMTextConstruct
	public String Title;    // TODO: implement ATOMTextConstruct
	public ATOMUpdated Updated;
}
",False,69,7,17,3,7,5,7,L6
130,org.geometerplus.fbreader.network.atom.ATOMCategory.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

import org.geometerplus.zlibrary.core.xml.ZLStringMap;


public class ATOMCategory extends ATOMCommonAttributes {

	public static final String TERM = ""term"";
	public static final String SCHEME = ""scheme"";
	public static final String LABEL = ""label"";

	@Override
	public void readAttributes(ZLStringMap source) {
		super.readAttributes(source);
		readAttribute(TERM, source);
		readAttribute(SCHEME, source);
		readAttribute(LABEL, source);
	}

	public final String getTerm() {
		return getAttribute(TERM);
	}

	public final String getScheme() {
		return getAttribute(SCHEME);
	}

	public final String getLabel() {
		return getAttribute(LABEL);
	}
}
",False,64,8,17,2,2,4,2,L6
131,org.geometerplus.fbreader.network.atom.ATOMAuthor.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMAuthor extends ATOMPersonConstruct {
}
",False,65,8,17,4,1,4,1,L6
132,org.geometerplus.fbreader.network.atom.ATOMContributor.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMContributor extends ATOMPersonConstruct {
}
",False,63,8,17,4,1,1,1,L6
133,org.geometerplus.fbreader.network.atom.ATOMLogo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

public class ATOMLogo extends ATOMCommonAttributes {

	public String Uri;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nUri="").append(Uri);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,4,0,0,3,1,0,1,L7
134,org.geometerplus.fbreader.network.atom.ATOMPersonConstruct.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.atom;

abstract class ATOMPersonConstruct extends ATOMCommonAttributes {

	public String Name;
	public String Uri;
	public String Email;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",\nName="").append(Name);
		buf.append("",\nUri="").append(Uri);
		buf.append("",\nEmail="").append(Email);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,66,8,17,3,1,5,1,L6
135,org.geometerplus.fbreader.network.opds.RelationAlias.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

class RelationAlias implements Comparable<RelationAlias> {
	final String Alias;
	final String Type;

	// `alias` and `type` parameters must be either null or interned String.
	RelationAlias(String alias, String type) {
		Alias = alias;
		Type = type;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof RelationAlias)) {
			return false;
		}
		RelationAlias r = (RelationAlias) o;
		return Alias == r.Alias && Type == r.Type;
	}

	@Override
	public int hashCode() {
		return (Alias == null ? 0 : Alias.hashCode()) +
			(Type == null ? 0 : Type.hashCode());
	}

	public int compareTo(RelationAlias r) {
		if (Alias != r.Alias) {
			if (Alias == null) {
				return -1;
			} else if (r.Alias == null) {
				return 1;
			}
			return Alias.compareTo(r.Alias);
		}
		if (Type != r.Type) {
			if (Type == null) {
				return -1;
			} else if (r.Type == null) {
				return 1;
			}
			return Type.compareTo(r.Type);
		}
		return 0;
	}

	@Override
	public String toString() {
		return ""Alias("" + Alias + ""; "" + Type + "")"";
	}
}

",True,55,7,17,0,0,2,0,L6
136,org.geometerplus.fbreader.network.opds.OpenSearchDescription.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

class OpenSearchDescription {

	public static OpenSearchDescription createDefault(String template) {
		return new OpenSearchDescription(template, 20, -1, -1);
	}

	public final String Template;
	public final int IndexOffset;
	public final int PageOffset;

	public final int ItemsPerPage;

	public OpenSearchDescription(String template, int itemsPerPage, int indexOffset, int pageOffset) {
		Template = template;
		IndexOffset = indexOffset;
		PageOffset = pageOffset;
		ItemsPerPage = itemsPerPage;
	}

	public boolean isValid() {
		return makeQuery("""") != null;
	}

	// searchTerms -- an HTML-encoded string
	public String makeQuery(String searchTerms) {
		final StringBuffer query = new StringBuffer();
		final Matcher m = Pattern.compile(""\\{(.*)\\}"").matcher(Template);
		while (m.find()) {
			String name = m.group(1);
			if (name == null || name.length() == 0 || name.contains("":"")) {
				return null;
			}
			final boolean optional = name.endsWith(""?"");
			if (optional) {
				name = name.substring(0, name.length() - 1);
			}
			name = name.intern();
			if (name == ""searchTerms"") {
				m.appendReplacement(query, searchTerms);
			} else if (name == ""count"") {
				if (ItemsPerPage > 0) {
					m.appendReplacement(query, String.valueOf(ItemsPerPage));
				} else if (optional) {
					m.appendReplacement(query, """");
				} else {
					return null;
				}
			} else if (optional) {
				m.appendReplacement(query, """");
			} else if (name == ""startIndex"") {
				if (IndexOffset > 0) {
					m.appendReplacement(query, String.valueOf(IndexOffset));
				} else {
					return null;
				}
			} else if (name == ""startPage"") {
				if (PageOffset > 0) {
					m.appendReplacement(query, String.valueOf(PageOffset));
				} else {
					return null;
				}
			} else if (name == ""language"") {
				m.appendReplacement(query, ""*"");
			} else if (name == ""inputEncoding"" || name == ""outputEncoding"") {
				m.appendReplacement(query, ""UTF-8"");
			} else {
				return null;
			}
		}
		m.appendTail(query);
		return query.toString();
	}
}
",True,52,7,17,0,0,4,0,L6
137,org.geometerplus.fbreader.network.opds.OPDSCatalogItem.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;

public class OPDSCatalogItem extends NetworkCatalogItem {
	static class State extends NetworkOperationData {
		public String LastLoadedId;
		public final HashSet<String> LoadedIds = new HashSet<String>();

		public State(INetworkLink link, OnNewItemListener listener) {
			super(link, listener);
		}
	}
	private State myLoadingState;
	private final Map<String,String> myExtraData;

	OPDSCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, Map<String,String> extraData) {
		super(link, title, summary, cover, urlByType);
		myExtraData = extraData;
	}

	public OPDSCatalogItem(INetworkLink link, String title, String summary, String cover, Map<Integer, String> urlByType, Accessibility accessibility, CatalogType catalogType) {
		super(link, title, summary, cover, urlByType, accessibility, catalogType);
		myExtraData = null;
	}

	private void doLoadChildren(NetworkOperationData.OnNewItemListener listener,
			ZLNetworkRequest networkRequest) throws ZLNetworkException {
		while (networkRequest != null) {
			try {
				ZLNetworkManager.Instance().perform(networkRequest);
			} catch (ZLNetworkException e) {
				myLoadingState = null;
				throw e;
			}
			if (listener.confirmInterrupt()) {
				return;
			}
			networkRequest = myLoadingState.resume();
		}
	}

	@Override
	public final Map<String,String> extraData() {
		return myExtraData;
	}

	protected String getUrl() {
		return URLByType.get(URL_CATALOG);
	}

	@Override
	public final void loadChildren(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		OPDSNetworkLink opdsLink = (OPDSNetworkLink) Link;

		myLoadingState = opdsLink.createOperationData(Link, listener);

		ZLNetworkRequest networkRequest =
			opdsLink.createNetworkData(getUrl(), myLoadingState);

		doLoadChildren(listener, networkRequest);
	}

	@Override
	public final boolean supportsResumeLoading() {
		return true;
	}

	@Override
	public final void resumeLoading(NetworkOperationData.OnNewItemListener listener) throws ZLNetworkException {
		if (myLoadingState != null) {
			myLoadingState.Listener = listener;
			ZLNetworkRequest networkRequest = myLoadingState.resume();
			doLoadChildren(listener, networkRequest);
		}
	}
}
",False,194,0,0,12,38,3,8,L6
138,org.geometerplus.fbreader.network.opds.OPDSNetworkLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.io.InputStream;
import java.io.IOException;
import java.io.UnsupportedEncodingException;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

class OPDSNetworkLink extends AbstractNetworkLink {
	private TreeMap<RelationAlias, String> myRelationAliases;

	private TreeMap<String,NetworkCatalogItem.Accessibility> myUrlConditions;
	private final LinkedList<URLRewritingRule> myUrlRewritingRules = new LinkedList<URLRewritingRule>();
	private final Map<String,String> myExtraData = new HashMap<String,String>();
	private NetworkAuthenticationManager myAuthenticationManager;

	private final boolean myHasStableIdentifiers;

	OPDSNetworkLink(String siteName, String title, String summary, String icon, String language,
			Map<String, String> links, boolean hasStableIdentifiers) {
		super(siteName, title, summary, icon, language, links);
		myHasStableIdentifiers = hasStableIdentifiers;
	}

	final void setRelationAliases(Map<RelationAlias, String> relationAliases) {
		if (relationAliases != null && relationAliases.size() > 0) {
			myRelationAliases = new TreeMap<RelationAlias, String>(relationAliases);
		} else {
			myRelationAliases = null;
		}
	}

	final void setUrlConditions(Map<String,NetworkCatalogItem.Accessibility> conditions) {
		if (conditions != null && conditions.size() > 0) {
			myUrlConditions = new TreeMap<String,NetworkCatalogItem.Accessibility>(conditions);
		} else {
			myUrlConditions = null;
		}
	}

	final void setUrlRewritingRules(List<URLRewritingRule> rules) {
		myUrlRewritingRules.clear();
		myUrlRewritingRules.addAll(rules);
	}

	final void setExtraData(Map<String,String> extraData) {
		myExtraData.clear();
		myExtraData.putAll(extraData);
	}

	final void setAuthenticationManager(NetworkAuthenticationManager mgr) {
		myAuthenticationManager = mgr;
	}

	ZLNetworkRequest createNetworkData(String url, final OPDSCatalogItem.State result) {
		if (url == null) {
			return null;
		}
		url = rewriteUrl(url, false);
		return new ZLNetworkRequest(url) {
			@Override
			public void handleStream(URLConnection connection, InputStream inputStream) throws IOException, ZLNetworkException {
				if (result.Listener.confirmInterrupt()) {
					return;
				}

				new OPDSXMLReader(
					new NetworkOPDSFeedReader(URL, result)
				).read(inputStream);

				if (result.Listener.confirmInterrupt()) {
					if (!myHasStableIdentifiers && result.LastLoadedId != null) {
						// If current catalog doesn't have stable identifiers
						// and catalog wasn't completely loaded (i.e. LastLoadedIdentifier is not null)
						// then reset state to load current page from the beginning 
						result.LastLoadedId = null;
					} else {
						result.Listener.commitItems(OPDSNetworkLink.this);
					}
				} else {
					result.Listener.commitItems(OPDSNetworkLink.this);
				}
			}
		};
	}

	@Override
	public OPDSCatalogItem.State createOperationData(INetworkLink link,
			NetworkOperationData.OnNewItemListener listener) {
		return new OPDSCatalogItem.State(link, listener);
	}

	public ZLNetworkRequest simpleSearchRequest(String pattern, NetworkOperationData data) {
		final String url = getLink(URL_SEARCH);
		if (url == null) {
			return null;
		}
		try {
			pattern = URLEncoder.encode(pattern, ""utf-8"");
		} catch (UnsupportedEncodingException e) {
		}
		return createNetworkData(url.replace(""%s"", pattern), (OPDSCatalogItem.State)data);
	}

	public ZLNetworkRequest resume(NetworkOperationData data) {
		return createNetworkData(data.ResumeURI, (OPDSCatalogItem.State) data);
	}

	public NetworkCatalogItem libraryItem() {
		TreeMap<Integer, String> urlMap = new TreeMap<Integer, String>();
		urlMap.put(NetworkCatalogItem.URL_CATALOG, getLink(URL_MAIN));
		return new OPDSCatalogItem(this, getTitle(), getSummary(), getIcon(), urlMap, myExtraData);
	}

	public NetworkAuthenticationManager authenticationManager() {
		return myAuthenticationManager;
	}

	public String rewriteUrl(String url, boolean isUrlExternal) {
		for (URLRewritingRule rule: myUrlRewritingRules) {
			if (rule.Apply != URLRewritingRule.APPLY_ALWAYS) {
				if ((rule.Apply == URLRewritingRule.APPLY_EXTERNAL && !isUrlExternal)
					|| (rule.Apply == URLRewritingRule.APPLY_INTERNAL && isUrlExternal)) {
					continue;
				}
			}
			switch (rule.Type) {
			case URLRewritingRule.ADD_URL_PARAMETER:
				url = ZLNetworkUtil.appendParameter(url, rule.Name, rule.Value);
				break;
			}
		}
		return url;
	}

	NetworkCatalogItem.Accessibility getCondition(String url) {
		if (myUrlConditions == null) {
			return NetworkCatalogItem.Accessibility.ALWAYS;
		}
		NetworkCatalogItem.Accessibility cond = myUrlConditions.get(url);
		return cond != null ? cond : NetworkCatalogItem.Accessibility.ALWAYS;
	}

	// rel and type must be either null or interned String objects.
	String relation(String rel, String type) {
		if (myRelationAliases == null) {
			return rel;
		}
		RelationAlias alias = new RelationAlias(rel, type);
		String mapped = myRelationAliases.get(alias);
		if (mapped != null) {
			return mapped;
		}
		if (type != null) {
			alias = new RelationAlias(rel, null);
			mapped = myRelationAliases.get(alias);
			if (mapped != null) {
				return mapped;
			}
		}
		return rel;
	}

	@Override
	public String toString() {
		return ""OPDSNetworkLink: {super="" + super.toString()
			+ ""; stableIds="" + myHasStableIdentifiers
			+ ""; authManager="" + (myAuthenticationManager != null ? myAuthenticationManager.getClass().getName() : null)
			+ ""; relationAliases="" + myRelationAliases
			+ ""; urlConditions="" + myUrlConditions
			+ ""; rewritingRules="" + myUrlRewritingRules
			+ ""}"";
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof OPDSNetworkLink)) {
			return false;
		}
		if (!super.equals(o)) {
			return false;
		}
		final OPDSNetworkLink lnk = (OPDSNetworkLink) o;
		if (myHasStableIdentifiers != lnk.myHasStableIdentifiers
				|| !ZLMiscUtil.mapsEquals(myRelationAliases, lnk.myRelationAliases)
				|| !ZLMiscUtil.mapsEquals(myUrlConditions, lnk.myUrlConditions)
				|| !ZLMiscUtil.listsEquals(myUrlRewritingRules, lnk.myUrlRewritingRules)
				|| myAuthenticationManager != lnk.myAuthenticationManager) {
			return false;
		}
		return true;
	}
}
",True,244,7,17,11,39,5,15,L6
139,org.geometerplus.fbreader.network.opds.NetworkOPDSFeedReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.atom.*;
import org.geometerplus.fbreader.network.authentication.litres.LitResBookshelfItem;
import org.geometerplus.fbreader.network.authentication.litres.LitResRecommendationsItem;

class NetworkOPDSFeedReader implements OPDSFeedReader, OPDSConstants, MimeTypes {
	private final String myBaseURL;
	private final OPDSCatalogItem.State myData;

	private int myIndex;

	private String myNextURL;
	private String mySkipUntilId;
	private boolean myFoundNewIds;

	private int myItemsToLoad = -1;

	/**
	 * Creates new OPDSFeedReader instance that can be used to get NetworkLibraryItem objects from OPDS feeds.
	 *
	 * @param baseURL    string that contains URL of the OPDS feed, that will be read using this instance of the reader
	 * @param result     network results buffer. Must be created using OPDSNetworkLink corresponding to the OPDS feed, 
	 *                   that will be read using this instance of the reader.
	 */
	NetworkOPDSFeedReader(String baseURL, OPDSCatalogItem.State result) {
		myBaseURL = baseURL;
		myData = result;
		mySkipUntilId = myData.LastLoadedId;
		myFoundNewIds = mySkipUntilId != null;
		if (!(result.Link instanceof OPDSNetworkLink)) {
			throw new IllegalArgumentException(""Parameter `result` has invalid `Link` field value: result.Link must be an instance of OPDSNetworkLink class."");
		}
	}

	public void processFeedStart() {
		myData.ResumeURI = myBaseURL;
	}

	public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
		if (beforeEntries) {
			myIndex = feed.OpensearchStartIndex - 1;
			if (feed.OpensearchItemsPerPage > 0) {
				myItemsToLoad = feed.OpensearchItemsPerPage;
				final int len = feed.OpensearchTotalResults - myIndex;
				if (len > 0 && len < myItemsToLoad) {
					myItemsToLoad = len;
				}
			}
			return false;
		}
		final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
		for (ATOMLink link: feed.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (MIME_APP_ATOM.equals(type) && ""next"".equals(rel)) {
				myNextURL = ZLNetworkUtil.url(myBaseURL, link.getHref());
			}
		}
		return false;
	}

	public void processFeedEnd() {
		if (mySkipUntilId != null) {
			// Last loaded element was not found => resume error => DO NOT RESUME
			// TODO: notify user about error???
			// TODO: do reload???
			myNextURL = null;
		}
		myData.ResumeURI = myFoundNewIds ? myNextURL : null;
		myData.LastLoadedId = null;
	}


	// returns BookReference.Format value for specified String. String MUST BE interned.
	private static int formatByMimeType(String mimeType) {
		if (MIME_APP_FB2ZIP.equals(mimeType)) {
			return BookReference.Format.FB2_ZIP;
		} else if (MIME_APP_EPUB.equals(mimeType)) {
			return BookReference.Format.EPUB;
		} else if (MIME_APP_MOBI.equals(mimeType)) {
			return BookReference.Format.MOBIPOCKET;
		}
		return BookReference.Format.NONE;
	}

	// returns BookReference.Type value for specified String. String MUST BE interned.
	private static int typeByRelation(String rel) {
		if (rel == null || REL_ACQUISITION.equals(rel) || REL_ACQUISITION_OPEN.equals(rel)) {
			return BookReference.Type.DOWNLOAD_FULL;
		} else if (REL_ACQUISITION_SAMPLE.equals(rel)) {
			return BookReference.Type.DOWNLOAD_DEMO;
		} else if (REL_ACQUISITION_CONDITIONAL.equals(rel)) {
			return BookReference.Type.DOWNLOAD_FULL_CONDITIONAL;
		} else if (REL_ACQUISITION_SAMPLE_OR_FULL.equals(rel)) {
			return BookReference.Type.DOWNLOAD_FULL_OR_DEMO;
		} else if (REL_ACQUISITION_BUY.equals(rel)) {
			return BookReference.Type.BUY;
		} else {
			return BookReference.Type.UNKNOWN;
		}
	}

	private boolean tryInterrupt() {
		final int noninterruptableRemainder = 10;
		return (myItemsToLoad < 0 || myItemsToLoad > noninterruptableRemainder)
				&& myData.Listener.confirmInterrupt();
	}

	private String calculateEntryId(OPDSEntry entry) {
		if (entry.Id != null) {
			return entry.Id.Uri;
		}

		String id = null;
		int idType = 0;

		final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
		for (ATOMLink link: entry.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);

			if (rel == null && MIME_APP_ATOM.equals(type)) {
				return ZLNetworkUtil.url(myBaseURL, link.getHref());
			}
			int relType = BookReference.Format.NONE;
			if (rel == null || rel.startsWith(REL_ACQUISITION_PREFIX)
					|| rel.startsWith(REL_FBREADER_ACQUISITION_PREFIX)) {
				relType = formatByMimeType(type);
			}
			if (relType != BookReference.Format.NONE
					&& (id == null || idType < relType
							|| (idType == relType && REL_ACQUISITION.equals(rel)))) {
				id = ZLNetworkUtil.url(myBaseURL, link.getHref());
				idType = relType;
			}
		}
		return id;
	}

	public boolean processFeedEntry(OPDSEntry entry) {
		if (myItemsToLoad >= 0) {
			--myItemsToLoad;
		}

		if (entry.Id == null) {
			final String id = calculateEntryId(entry);
			if (id == null) {
				return tryInterrupt();
			}
			entry.Id = new ATOMId();
			entry.Id.Uri = id;
		}

		if (mySkipUntilId != null) {
			if (mySkipUntilId.equals(entry.Id.Uri)) {
				mySkipUntilId = null;
			}
			return tryInterrupt();
		}
		myData.LastLoadedId = entry.Id.Uri;
		if (!myFoundNewIds && !myData.LoadedIds.contains(entry.Id.Uri)) {
			myFoundNewIds = true;
		}
		myData.LoadedIds.add(entry.Id.Uri);

		final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
		boolean hasBookLink = false;
		for (ATOMLink link: entry.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (rel == null
					? (formatByMimeType(type) != BookReference.Format.NONE)
					: (rel.startsWith(REL_ACQUISITION_PREFIX)
							|| rel.startsWith(REL_FBREADER_ACQUISITION_PREFIX))) {
				hasBookLink = true;
				break;
			}
		}

		NetworkLibraryItem item;
		if (hasBookLink) {
			item = readBookItem(entry);
		} else {
			item = readCatalogItem(entry);
		}
		if (item != null) {
			myData.Listener.onNewItem(myData.Link, item);
		}
		return tryInterrupt();
	}

	private static final String AuthorPrefix = ""author:"";
	private static final String AuthorsPrefix = ""authors:"";

	private NetworkLibraryItem readBookItem(OPDSEntry entry) {
		final OPDSNetworkLink opdsNetworkLink = (OPDSNetworkLink)myData.Link;
		/*final String date;
		if (entry.DCIssued != null) {
			date = entry.DCIssued.getDateTime(true);
		} else {
			date = null;
		}*/

		final LinkedList<String> tags = new LinkedList<String>();
		for (ATOMCategory category: entry.Categories) {
			String label = category.getLabel();
			if (label == null) {
				label = category.getTerm();
			}
			if (label != null) {
				tags.add(label);
			}
		}

		String cover = null;
		LinkedList<BookReference> references = new LinkedList<BookReference>();
		for (ATOMLink link: entry.Links) {
			final String href = ZLNetworkUtil.url(myBaseURL, link.getHref());
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsNetworkLink.relation(link.getRel(), type);
			final int referenceType = typeByRelation(rel);
			if (REL_IMAGE_THUMBNAIL.equals(rel) || REL_THUMBNAIL.equals(rel)) {
				if (MIME_IMAGE_PNG.equals(type) || MIME_IMAGE_JPEG.equals(type)) {
					cover = href;
				}
			} else if ((rel != null && rel.startsWith(REL_IMAGE_PREFIX)) || REL_COVER.equals(rel)) {
				if (cover == null &&
						(MIME_IMAGE_PNG.equals(type) || MIME_IMAGE_JPEG.equals(type))) {
					cover = href;
				}
			} else if (BookReference.Type.BUY == referenceType) {
				final OPDSLink opdsLink = (OPDSLink)link; 
				String price = null;
				final OPDSPrice opdsPrice = opdsLink.selectBestPrice();
				if (opdsPrice != null) {
					price = BuyBookReference.price(opdsPrice.Price, opdsPrice.Currency);
				}
				if (price == null) {
					// FIXME: HACK: price handling must be implemented not through attributes!!!
					price = BuyBookReference.price(entry.getAttribute(OPDSXMLReader.KEY_PRICE), null);
				}
				if (price == null) {
					price = """";
				}
				if (MIME_TEXT_HTML.equals(type)) {
					collectReferences(references, opdsLink, href,
							BookReference.Type.BUY_IN_BROWSER, price, true);
				} else {
					collectReferences(references, opdsLink, href,
							BookReference.Type.BUY, price, false);
				}
			} else if (referenceType != BookReference.Type.UNKNOWN) {
				final int format = formatByMimeType(type);
				if (format != BookReference.Format.NONE) {
					references.add(new BookReference(href, format, referenceType));
				}
			}
		}

		LinkedList<NetworkBookItem.AuthorData> authors = new LinkedList<NetworkBookItem.AuthorData>();
		for (ATOMAuthor author: entry.Authors) {
			String name = author.Name;
			final String lowerCased = name.toLowerCase();
			int index = lowerCased.indexOf(AuthorPrefix);
			if (index != -1) {
				name = name.substring(index + AuthorPrefix.length());
			} else {
				index = lowerCased.indexOf(AuthorsPrefix);
				if (index != -1) {
					name = name.substring(index + AuthorsPrefix.length());
				}
			}
			index = name.indexOf(',');
			NetworkBookItem.AuthorData authorData;
			if (index != -1) {
				final String before = name.substring(0, index).trim();
				final String after = name.substring(index + 1).trim();
				authorData = new NetworkBookItem.AuthorData(after + ' ' + before, before);
			} else {
				name = name.trim();
				index = name.lastIndexOf(' ');
				authorData = new NetworkBookItem.AuthorData(name, name.substring(index + 1));
			}
			authors.add(authorData);
		}

		//entry.dcPublisher();
		//entry.updated();
		//entry.published();
		/*for (size_t i = 0; i < entry.contributors().size(); ++i) {
			ATOMContributor &contributor = *(entry.contributors()[i]);
			std::cerr << ""\t\t<contributor>"" << std::endl;
			std::cerr << ""\t\t\t<name>""  << contributor.name()  << ""</name>""  << std::endl;
			if (!contributor.uri().empty())   std::cerr << ""\t\t\t<uri>""   << contributor.uri()   << ""</uri>""   << std::endl;
			if (!contributor.email().empty()) std::cerr << ""\t\t\t<email>"" << contributor.email() << ""</email>"" << std::endl;
			std::cerr << ""\t\t</contributor>"" << std::endl;
		}*/
		//entry.rights();

		final String annotation;
		if (entry.Summary != null) {
			annotation = entry.Summary;
		} else if (entry.Content != null) {
			annotation = entry.Content;
		} else {
			annotation = null;
		}

		return new NetworkBookItem(
			opdsNetworkLink,
			entry.Id.Uri,
			myIndex++,
			entry.Title,
			annotation,
			//entry.DCLanguage,
			//date,
			authors,
			tags,
			entry.SeriesTitle,
			entry.SeriesIndex,
			cover,
			references
		);
	}

	private void collectReferences(LinkedList<BookReference> references,
			OPDSLink opdsLink, String href, int type, String price, boolean addWithoutFormat) {
		boolean added = false;
		for (String mime: opdsLink.Formats) {
			final int format = formatByMimeType(mime);
			if (format != BookReference.Format.NONE) {
				references.add(new BuyBookReference(
					href, format, type, price
				));
				added = true;
			}
		}
		if (!added && addWithoutFormat) {
			references.add(new BuyBookReference(
				href, BookReference.Format.NONE, type, price
			));
		}
	}

	private NetworkLibraryItem readCatalogItem(OPDSEntry entry) {
		final OPDSNetworkLink opdsLink = (OPDSNetworkLink)myData.Link;
		String coverURL = null;
		String url = null;
		boolean urlIsAlternate = false;
		String htmlURL = null;
		String litresRel = null;
		NetworkCatalogItem.CatalogType catalogType = NetworkCatalogItem.CatalogType.OTHER;
		for (ATOMLink link : entry.Links) {
			final String href = ZLNetworkUtil.url(myBaseURL, link.getHref());
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = opdsLink.relation(link.getRel(), type);
			if (MIME_IMAGE_PNG.equals(type) || MIME_IMAGE_JPEG.equals(type)) {
				if (REL_IMAGE_THUMBNAIL.equals(rel) || REL_THUMBNAIL.equals(rel) ||
						(coverURL == null && (REL_COVER.equals(rel) || 
								(rel != null && rel.startsWith(REL_IMAGE_PREFIX))))) {
					coverURL = href;
				}
			} else if (MIME_APP_ATOM.equals(type)) {
				if (ATOMConstants.REL_ALTERNATE.equals(rel)) {
					if (url == null) {
						url = href;
						urlIsAlternate = true;
					}
				} else if (url == null || rel == null || rel.equals(REL_SUBSECTION)) {
					url = href;
					urlIsAlternate = false;
					if (REL_CATALOG_AUTHOR.equals(rel)) {
						catalogType = NetworkCatalogItem.CatalogType.BY_AUTHOR;
					} else if (REL_CATALOG_SERIES.equals(rel)) {
						catalogType = NetworkCatalogItem.CatalogType.BY_SERIES;
					}
				}
			} else if (MIME_TEXT_HTML.equals(type)) {
				if (REL_ACQUISITION.equals(rel) ||
					REL_ACQUISITION_OPEN.equals(rel) ||
					ATOMConstants.REL_ALTERNATE.equals(rel) ||
					rel == null) {
					htmlURL = href;
				}
			} else if (MIME_APP_LITRES.equals(type)) {
				litresRel = rel;
				url = href;
			}
		}

		if (url == null && htmlURL == null) {
			return null;
		}

		if (url != null && !urlIsAlternate) {
			htmlURL = null;
		}

		final String annotation;
		if (entry.Summary != null) {
			annotation = entry.Summary.replace(""\n"", """");
		} else if (entry.Content != null) {
			annotation = entry.Content.replace(""\n"", """");
		} else {
			annotation = null;
		}

		HashMap<Integer, String> urlMap = new HashMap<Integer, String>();
		if (url != null) {
			urlMap.put(NetworkCatalogItem.URL_CATALOG, url);
		}
		if (htmlURL != null) {
			urlMap.put(NetworkCatalogItem.URL_HTML_PAGE, htmlURL);
		}
		if (litresRel != null) {
			if (REL_BOOKSHELF.equals(litresRel)) {
				return new LitResBookshelfItem(
					opdsLink,
					entry.Title,
					annotation,
					coverURL,
					urlMap,
					opdsLink.getCondition(entry.Id.Uri)
				);
			} else if (REL_RECOMMENDATIONS.equals(litresRel)) {
				return new LitResRecommendationsItem(
					opdsLink,
					entry.Title,
					annotation,
					coverURL,
					urlMap,
					opdsLink.getCondition(entry.Id.Uri)
				);
			} else {
				return null;
			}
		} else {
			return new OPDSCatalogItem(
				opdsLink,
				entry.Title,
				annotation,
				coverURL,
				urlMap,
				opdsLink.getCondition(entry.Id.Uri),
				catalogType
			);
		}
	}
}
",False,194,0,0,11,27,1,27,L6
140,org.geometerplus.fbreader.network.opds.URLRewritingRule.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

class URLRewritingRule {

	// rule types:
	public static final int ADD_URL_PARAMETER = 0;

	// apply values:
	public static final int APPLY_ALWAYS = 0;
	public static final int APPLY_EXTERNAL = 1;
	public static final int APPLY_INTERNAL = 2;


	public final int Type;
	public final int Apply;
	public final String Name;
	public final String Value;

	public URLRewritingRule(int type, int apply, String name, String value) {
		Type = type;
		Apply = apply;
		Name = name;
		Value = value;
	}

	@Override
	public String toString() {
		return ""Rule: {type="" + Type
			+ ""; apply="" + Apply
			+ ""; name="" + Name
			+ ""; value="" + Value
			+ ""}"";
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (!(o instanceof URLRewritingRule)) {
			return false;
		}
		final URLRewritingRule rule = (URLRewritingRule) o;
		if (Type != rule.Type
				|| Apply != rule.Apply
				|| !ZLMiscUtil.equals(Name, rule.Name)
				|| !ZLMiscUtil.equals(Value, rule.Value)) {
			return false;
		}
		return true;
	}
}
",False,56,7,17,1,1,2,1,L6
141,org.geometerplus.fbreader.network.opds.OPDSFeedMetadata.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.atom.*;

class OPDSFeedMetadata extends ATOMFeedMetadata {

	public int OpensearchTotalResults;
	public int OpensearchItemsPerPage;
	public int OpensearchStartIndex = 1;
}
",False,69,7,17,4,7,5,1,L6
142,org.geometerplus.fbreader.network.opds.OPDSXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.xml.*;

import org.geometerplus.fbreader.network.atom.*;

class OPDSXMLReader extends ZLXMLReaderAdapter {
	public static final String KEY_PRICE = ""price"";


	protected final OPDSFeedReader myFeedReader;

	private OPDSFeedMetadata myFeed;
	private OPDSEntry myEntry;

	private ATOMAuthor myAuthor;
	private ATOMId myId;
	private OPDSLink myLink;
	private ATOMCategory myCategory;
	private ATOMUpdated myUpdated;
	private ATOMPublished myPublished;
	private DCDate myDCIssued;
	private ATOMIcon myIcon;

	private String myPriceCurrency;

	//private ATOMTitle myTitle;      // TODO: implement ATOMTextConstruct & ATOMTitle
	//private ATOMSummary mySummary;  // TODO: implement ATOMTextConstruct & ATOMSummary


	public OPDSXMLReader(OPDSFeedReader feedReader) {
		myFeedReader = feedReader;
	}


	protected String myDublinCoreNamespaceId;
	protected String myAtomNamespaceId;
	protected String myOpenSearchNamespaceId;
	protected String myCalibreNamespaceId;
	protected String myOpdsNamespaceId;

	@Override
	public final boolean processNamespaces() {
		return true;
	}

	public static String intern(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		return str.intern();
	}

	@Override
	public void namespaceMapChangedHandler(Map<String,String> namespaceMap) {
		myDublinCoreNamespaceId = null;
		myAtomNamespaceId = null;
		myOpenSearchNamespaceId = null;
		myCalibreNamespaceId = null;
		myOpdsNamespaceId = null;

		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String value = entry.getValue();
			if (value == XMLNamespaces.DublinCoreTerms) {
				myDublinCoreNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespaces.Atom) {
				myAtomNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespaces.OpenSearch) {
				myOpenSearchNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespaces.CalibreMetadata) {
				myCalibreNamespaceId = intern(entry.getKey());
			} else if (value == XMLNamespaces.Opds) {
				myOpdsNamespaceId = intern(entry.getKey());
			}
		}
	}


	protected static final int START = 0;
	protected static final int FEED = 1;
	protected static final int F_ENTRY = 2;
	protected static final int F_ID = 3;
	protected static final int F_LINK = 4;
	protected static final int F_CATEGORY = 5;
	protected static final int F_TITLE = 6;
	protected static final int F_UPDATED = 7;
	protected static final int F_AUTHOR = 8;
	protected static final int FA_NAME = 9;
	protected static final int FA_URI = 10;
	protected static final int FA_EMAIL = 11;
	protected static final int FE_AUTHOR = 12;
	protected static final int FE_ID = 13;
	protected static final int FE_CATEGORY = 14;
	protected static final int FE_LINK = 15;
	protected static final int FE_PUBLISHED = 16;
	protected static final int FE_SUMMARY = 17;
	protected static final int FE_CONTENT = 18;
	protected static final int FE_TITLE = 19;
	protected static final int FE_UPDATED = 20;
	protected static final int FE_DC_LANGUAGE = 21;
	protected static final int FE_DC_ISSUED = 22;
	protected static final int FE_DC_PUBLISHER = 23;
	protected static final int FE_CALIBRE_SERIES = 24;
	protected static final int FE_CALIBRE_SERIES_INDEX = 25;
	protected static final int FEL_PRICE = 26;
	protected static final int FEL_FORMAT = 27;
	protected static final int FEA_NAME = 28;
	protected static final int FEA_URI = 29;
	protected static final int FEA_EMAIL = 30;
	protected static final int OPENSEARCH_TOTALRESULTS = 31;
	protected static final int OPENSEARCH_ITEMSPERPAGE = 32;
	protected static final int OPENSEARCH_STARTINDEX = 33;
	protected static final int FEC_HACK_SPAN = 34;
	protected static final int F_SUBTITLE = 35;
	protected static final int F_ICON = 36;


	protected static final String TAG_FEED = ""feed"";
	protected static final String TAG_ENTRY = ""entry"";
	protected static final String TAG_AUTHOR = ""author"";
	protected static final String TAG_NAME = ""name"";
	protected static final String TAG_URI = ""uri"";
	protected static final String TAG_EMAIL = ""email"";
	protected static final String TAG_ID = ""id"";
	protected static final String TAG_CATEGORY = ""category"";
	protected static final String TAG_LINK = ""link"";
	protected static final String TAG_PUBLISHED = ""published"";
	protected static final String TAG_SUMMARY = ""summary"";
	protected static final String TAG_CONTENT = ""content"";
	protected static final String TAG_TITLE = ""title"";
	protected static final String TAG_UPDATED = ""updated"";
	protected static final String TAG_PRICE = ""price"";
	protected static final String TAG_SUBTITLE = ""subtitle"";
	protected static final String TAG_ICON = ""icon"";

	protected static final String TAG_HACK_SPAN = ""span"";

	protected static final String DC_TAG_LANGUAGE = ""language"";
	protected static final String DC_TAG_ISSUED = ""issued"";
	protected static final String DC_TAG_PUBLISHER = ""publisher"";
	protected static final String DC_TAG_FORMAT = ""format"";

	protected static final String CALIBRE_TAG_SERIES = ""series"";
	protected static final String CALIBRE_TAG_SERIES_INDEX = ""series_index"";

	protected static final String OPENSEARCH_TAG_TOTALRESULTS = ""totalResults"";
	protected static final String OPENSEARCH_TAG_ITEMSPERPAGE = ""itemsPerPage"";
	protected static final String OPENSEARCH_TAG_STARTINDEX = ""startIndex"";


	private int myState = START;

	private final StringBuffer myBuffer = new StringBuffer();
	private HtmlToString myHtmlToString = new HtmlToString();

	private boolean myFeedMetadataProcessed;

	protected final int getState() {
		return myState;
	}

	@Override
	public final boolean startElementHandler(String tag, ZLStringMap attributes) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}
		return startElementHandler(tagPrefix, tag, attributes, extractBufferContent());
	}

	@Override
	public final boolean endElementHandler(String tag) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}
		return endElementHandler(tagPrefix, tag, extractBufferContent());
	}

	private final String extractBufferContent() {
		final char[] bufferContentArray = myBuffer.toString().trim().toCharArray();
		myBuffer.delete(0, myBuffer.length());
		if (bufferContentArray.length == 0) {
			return null;
		}
		return new String(bufferContentArray);
	}

	public boolean startElementHandler(final String tagPrefix, final String tag,
			final ZLStringMap attributes, final String bufferContent) {
		boolean interruptReading = false;
		switch (myState) {
			case START:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_FEED) {
					myFeedReader.processFeedStart();
					myFeed = new OPDSFeedMetadata();
					myFeed.readAttributes(attributes);
					myState = FEED;
					myFeedMetadataProcessed = false;
				}
				break;
			case FEED:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_AUTHOR) {
						myAuthor = new ATOMAuthor();
						myAuthor.readAttributes(attributes);
						myState = F_AUTHOR;
					} else if (tag == TAG_ID) {
						myId = new ATOMId();
						myId.readAttributes(attributes);
						myState = F_ID;
					} else if (tag == TAG_ICON) {
						myIcon = new ATOMIcon();
						myIcon.readAttributes(attributes);
						myState = F_ICON;
					} else if (tag == TAG_LINK) {
						myLink = new OPDSLink();
						myLink.readAttributes(attributes);
						myState = F_LINK;
					} else if (tag == TAG_CATEGORY) {
						myCategory = new ATOMCategory();
						myCategory.readAttributes(attributes);
						myState = F_CATEGORY;
					} else if (tag == TAG_TITLE) {
						//myTitle = new ATOMTitle(); // TODO:implement ATOMTextConstruct & ATOMTitle
						//myTitle.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = F_TITLE;
					} else if (tag == TAG_SUBTITLE) {
						//mySubtitle = new ATOMTitle(); // TODO:implement ATOMTextConstruct & ATOMSubtitle
						//mySubtitle.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = F_SUBTITLE;
					} else if (tag == TAG_UPDATED) {
						myUpdated = new ATOMUpdated();
						myUpdated.readAttributes(attributes);
						myState = F_UPDATED;
					} else if (tag == TAG_ENTRY) {
						myEntry = new OPDSEntry();
						myEntry.readAttributes(attributes);
						myState = F_ENTRY;
						// Process feed metadata just before first feed entry
						if (myFeed != null && !myFeedMetadataProcessed) {
							interruptReading = myFeedReader.processFeedMetadata(myFeed, true);
							myFeedMetadataProcessed = true;
						}
					} 
				} else if (tagPrefix == myOpenSearchNamespaceId) {
					if (tag == OPENSEARCH_TAG_TOTALRESULTS) {
						myState = OPENSEARCH_TOTALRESULTS;
					} else if (tag == OPENSEARCH_TAG_ITEMSPERPAGE) {
						myState = OPENSEARCH_ITEMSPERPAGE;
					} else if (tag == OPENSEARCH_TAG_STARTINDEX) {
						myState = OPENSEARCH_STARTINDEX;
					} 
				} 
				break;
			case F_ENTRY:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_AUTHOR) {
						myAuthor = new ATOMAuthor();
						myAuthor.readAttributes(attributes);
						myState = FE_AUTHOR;
					} else if (tag == TAG_ID) {
						myId = new ATOMId();
						myId.readAttributes(attributes);
						myState = FE_ID;
					} else if (tag == TAG_CATEGORY) {
						myCategory = new ATOMCategory();
						myCategory.readAttributes(attributes);
						myState = FE_CATEGORY;
					} else if (tag == TAG_LINK) {
						myLink = new OPDSLink();
						myLink.readAttributes(attributes);
						myState = FE_LINK;
					} else if (tag == TAG_PUBLISHED) {
						myPublished = new ATOMPublished();
						myPublished.readAttributes(attributes);
						myState = FE_PUBLISHED;
					} else if (tag == TAG_SUMMARY) {
						//mySummary = new ATOMSummary(); // TODO:implement ATOMTextConstruct & ATOMSummary
						//mySummary.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = FE_SUMMARY;
					} else if (tag == TAG_CONTENT) {
						//myConent = new ATOMContent(); // TODO:implement ATOMContent
						//myConent.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = FE_CONTENT;
					} else if (tag == TAG_TITLE) {
						//myTitle = new ATOMTitle(); // TODO:implement ATOMTextConstruct & ATOMTitle
						//myTitle.readAttributes(attributes);
						myHtmlToString.setupTextContent(attributes.getValue(""type""));
						myState = FE_TITLE;
					} else if (tag == TAG_UPDATED) {
						myUpdated = new ATOMUpdated();
						myUpdated.readAttributes(attributes);
						myState = FE_UPDATED;
					}
				} else if (tagPrefix == myDublinCoreNamespaceId) {
					if (tag == DC_TAG_LANGUAGE) {
						myState = FE_DC_LANGUAGE;
					} else if (tag == DC_TAG_ISSUED) {
						myDCIssued = new DCDate();
						myDCIssued.readAttributes(attributes);
						myState = FE_DC_ISSUED;
					} else if (tag == DC_TAG_PUBLISHER) {
						myState = FE_DC_PUBLISHER;
					} 
				} else if (tagPrefix == myCalibreNamespaceId) {
					if (tag == CALIBRE_TAG_SERIES) {
						myState = FE_CALIBRE_SERIES;
					} else if (tag == CALIBRE_TAG_SERIES_INDEX) {
						myState = FE_CALIBRE_SERIES_INDEX;
					}
				}
				break;
			case F_AUTHOR:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_NAME) {
						myState = FA_NAME;
					} else if (tag == TAG_URI) {
						myState = FA_URI;
					} else if (tag == TAG_EMAIL) {
						myState = FA_EMAIL;
					} 
				} 
				break;
			case FE_AUTHOR:
				if (tagPrefix == myAtomNamespaceId) {
					if (tag == TAG_NAME) {
						myState = FEA_NAME;
					} else if (tag == TAG_URI) {
						myState = FEA_URI;
					} else if (tag == TAG_EMAIL) {
						myState = FEA_EMAIL;
					} 
				}
				break;
			case FE_LINK:
				if (tagPrefix == myOpdsNamespaceId && tag == TAG_PRICE) {
					myPriceCurrency = attributes.getValue(""currencycode"");
					myState = FEL_PRICE;
				} if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_FORMAT) {
					myState = FEL_FORMAT;
				}
				break;
			case FE_CONTENT:
				myHtmlToString.processTextContent(false, tag, attributes, bufferContent);
				// FIXME: HACK: html handling must be implemeted neatly
				if (tag == TAG_HACK_SPAN || attributes.getValue(""class"") == ""price"") {
					myState = FEC_HACK_SPAN;
				}
				break;
			case FE_SUMMARY:
			case FE_TITLE:
			case F_TITLE:
			case F_SUBTITLE:
				myHtmlToString.processTextContent(false, tag, attributes, bufferContent);
				break;
			default:
				break;
		}

		return interruptReading;
	}

	public boolean endElementHandler(final String tagPrefix, final String tag,
			final String bufferContent) {
		boolean interruptReading = false;
		switch (myState) {
			case START:
				break;
			case FEED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_FEED) {
					if (myFeed != null) {
						interruptReading = myFeedReader.processFeedMetadata(myFeed, false);
					}
					myFeed = null;
					myFeedReader.processFeedEnd();
					myState = START;
				} 
				break;
			case F_ENTRY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ENTRY) {
					if (myEntry != null) {
						interruptReading = myFeedReader.processFeedEntry(myEntry);
					}
					myEntry = null;
					myState = FEED;
				}
				break;
			case F_ID:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ID) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null && myFeed != null) {
						myId.Uri = bufferContent;
						myFeed.Id = myId;
					}
					myId = null;
					myState = FEED;
				} 
				break;
			case F_ICON:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ICON) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null && myFeed != null) {
						myIcon.Uri = bufferContent;
						myFeed.Icon = myIcon;
					}
					myIcon = null;
					myState = FEED;
				} 
				break;
			case F_LINK:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_LINK) {
					if (myFeed != null) {
						myFeed.Links.add(myLink);
					}
					myLink = null;
					myState = FEED;
				} 
				break;
			case F_CATEGORY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_CATEGORY) {
					if (myFeed != null) {
						myFeed.Categories.add(myCategory);
					}
					myCategory = null;
					myState = FEED;
				} 
				break;
			case F_TITLE:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_TITLE) {
					// TODO:implement ATOMTextConstruct & ATOMTitle
					final String title = myHtmlToString.finishTextContent(bufferContent);
					if (myFeed != null) {
						myFeed.Title = title;
					}
					myState = FEED;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				} 
				break;
			case F_SUBTITLE:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_SUBTITLE) {
					// TODO:implement ATOMTextConstruct & ATOMSubtitle
					final String subtitle = myHtmlToString.finishTextContent(bufferContent);
					if (myFeed != null) {
						myFeed.Subtitle = subtitle;
					}
					myState = FEED;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				} 
				break;
			case F_UPDATED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_UPDATED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myUpdated) && myFeed != null) {
						myFeed.Updated = myUpdated;
					}
					myUpdated = null;
					myState = FEED;
				} 
				break;
			case F_AUTHOR:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_AUTHOR) {
					if (myFeed != null && myAuthor.Name != null) {
						myFeed.Authors.add(myAuthor);
					}
					myAuthor = null;
					myState = FEED;
				} 
				break;
			case FA_NAME:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_NAME) {
					myAuthor.Name = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_NAME:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_NAME) {
					myAuthor.Name = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FA_URI:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_URI) {
					myAuthor.Uri = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_URI:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_URI) {
					myAuthor.Uri = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FA_EMAIL:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_EMAIL) {
					myAuthor.Email = bufferContent;
					myState = F_AUTHOR;
				}
				break;
			case FEA_EMAIL:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_EMAIL) {
					myAuthor.Email = bufferContent;
					myState = FE_AUTHOR;
				}
				break;
			case FEL_PRICE:
				if (tagPrefix == myOpdsNamespaceId && tag == TAG_PRICE) {
					if (bufferContent != null && myPriceCurrency != null) {
						myLink.Prices.add(new OPDSPrice(bufferContent.intern(), myPriceCurrency));
						myPriceCurrency = null;
					}
					myState = FE_LINK;
				}
				break;
			case FEL_FORMAT:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_FORMAT) {
					if (bufferContent != null) {
						myLink.Formats.add(bufferContent.intern());
					}
					myState = FE_LINK;
				}
				break;
			case FE_AUTHOR:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_AUTHOR) {
					if (myAuthor.Name != null) {
						myEntry.Authors.add(myAuthor);
					}
					myAuthor = null;
					myState = F_ENTRY;
				} 
				break;
			case FE_ID:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_ID) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (bufferContent != null) {
						myId.Uri = bufferContent;
						myEntry.Id = myId;
					}
					myId = null;
					myState = F_ENTRY;
				}
				break;
			case FE_CATEGORY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_CATEGORY) {
					myEntry.Categories.add(myCategory);
					myCategory = null;
					myState = F_ENTRY;
				}
				break;
			case FE_LINK:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_LINK) {
					myEntry.Links.add(myLink);
					myLink = null;
					myState = F_ENTRY;
				}
				break;
			case FE_PUBLISHED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_PUBLISHED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myPublished)) {
						myEntry.Published = myPublished;
					}
					myPublished = null;
					myState = F_ENTRY;
				}
				break;
			case FE_SUMMARY:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_SUMMARY) {
					// TODO:implement ATOMTextConstruct & ATOMSummary
					myEntry.Summary = myHtmlToString.finishTextContent(bufferContent);
					myState = F_ENTRY;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				}
				break;
			case FE_CONTENT:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_CONTENT) {
					// TODO:implement ATOMContent
					myEntry.Content = myHtmlToString.finishTextContent(bufferContent);
					myState = F_ENTRY;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				}
				break;
			case FE_TITLE:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_TITLE) {
					// TODO:implement ATOMTextConstruct & ATOMTitle
					myEntry.Title = myHtmlToString.finishTextContent(bufferContent);
					myState = F_ENTRY;
				} else {
					myHtmlToString.processTextContent(true, tag, null, bufferContent);
				}
				break;
			case FE_UPDATED:
				if (tagPrefix == myAtomNamespaceId && tag == TAG_UPDATED) {
					// FIXME:uri can be lost:buffer will be truncated, if there are extension tags inside the <id> tag
					if (ATOMDateConstruct.parse(bufferContent, myUpdated)) {
						myEntry.Updated = myUpdated;
					}
					myUpdated = null;
					myState = F_ENTRY;
				}
				break;
			case FEC_HACK_SPAN:
				// FIXME: HACK
				myHtmlToString.processTextContent(true, tag, null, bufferContent);
				if (bufferContent != null) {
					myEntry.addAttribute(KEY_PRICE, bufferContent.intern());
				}
				myState = FE_CONTENT;
				break;
			case FE_DC_LANGUAGE:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_LANGUAGE) {
					// FIXME:language can be lost:buffer will be truncated, if there are extension tags inside the <dc:language> tag
					myEntry.DCLanguage = bufferContent;
					myState = F_ENTRY;
				}
				break;
			case FE_DC_ISSUED:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_ISSUED) {
					// FIXME:issued can be lost:buffer will be truncated, if there are extension tags inside the <dc:issued> tag
					if (ATOMDateConstruct.parse(bufferContent, myDCIssued)) {
						myEntry.DCIssued = myDCIssued;
					}
					myDCIssued = null;
					myState = F_ENTRY;
				}
				break;
			case FE_DC_PUBLISHER:
				if (tagPrefix == myDublinCoreNamespaceId && tag == DC_TAG_PUBLISHER) {
					// FIXME:publisher can be lost:buffer will be truncated, if there are extension tags inside the <dc:publisher> tag
					myEntry.DCPublisher = bufferContent;
					myState = F_ENTRY;
				}
				break;
			case FE_CALIBRE_SERIES:
				if (tagPrefix == myCalibreNamespaceId && tag == CALIBRE_TAG_SERIES) {
					myEntry.SeriesTitle = bufferContent;
					myState = F_ENTRY;
				}
				break;
			case FE_CALIBRE_SERIES_INDEX:
				if (tagPrefix == myCalibreNamespaceId && tag == CALIBRE_TAG_SERIES_INDEX) {
					if (bufferContent != null) {
						try {
							myEntry.SeriesIndex = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = F_ENTRY;
				}
				break;
			case OPENSEARCH_TOTALRESULTS:
				if (tagPrefix == myOpenSearchNamespaceId &&
						tag == OPENSEARCH_TAG_TOTALRESULTS) {
					if (myFeed != null && bufferContent != null) {
						try {
							myFeed.OpensearchTotalResults = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				break;
			case OPENSEARCH_ITEMSPERPAGE:
				if (tagPrefix == myOpenSearchNamespaceId &&
						tag == OPENSEARCH_TAG_ITEMSPERPAGE) {
					if (myFeed != null && bufferContent != null) {
						try {
							myFeed.OpensearchItemsPerPage = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				break;
			case OPENSEARCH_STARTINDEX:
				if (tagPrefix == myOpenSearchNamespaceId &&
						tag == OPENSEARCH_TAG_STARTINDEX) {
					if (myFeed != null && bufferContent != null) {
						try {
							myFeed.OpensearchStartIndex = Integer.parseInt(bufferContent);
						} catch (NumberFormatException ex) {
						}
					}
					myState = FEED;
				}
				break;
		}

		return interruptReading;
	}

	@Override
	public final void characterDataHandler(char[] data, int start, int length) {
		final int startIndex = myBuffer.length();
		myBuffer.append(data, start, length);
		int index = startIndex;
		while ((index = myBuffer.indexOf(""\r\n"", index)) != -1) {
			myBuffer.replace(index, index + 2, ""\n"");
		}
		index = startIndex;
		while ((index = myBuffer.indexOf(""\r"", index)) != -1) {
			myBuffer.setCharAt(index, '\n');
		}
	}
}
",True,214,7,17,10,26,4,21,L6
143,org.geometerplus.fbreader.network.opds.OpenSearchXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;
import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;

class OpenSearchXMLReader extends ZLXMLReaderAdapter {

	private final List<OpenSearchDescription> myDescriptions;
	private final int myItemsPerPage;

	private final String myBaseURL;

	public OpenSearchXMLReader(String baseUrl, List<OpenSearchDescription> descriptions, int itemsPerPage) {
		myDescriptions = descriptions;
		myItemsPerPage = itemsPerPage;
		myBaseURL = baseUrl;
	}

	private String myOpenSearchNamespaceId;

	@Override
	public boolean processNamespaces() {
		return true;
	}

	private static String intern(String str) {
		if (str == null || str.length() == 0) {
			return null;
		}
		return str.intern();
	}

	@Override
	public void namespaceMapChangedHandler(Map<String, String> namespaces) {
		myOpenSearchNamespaceId = null;

		for (Map.Entry<String,String> entry : namespaces.entrySet()) {
			final String value = entry.getValue();
			if (value == XMLNamespaces.OpenSearch) {
				myOpenSearchNamespaceId = intern(entry.getKey());
			}
		}
	}

	private int parseInt(String value) {
		if (value == null || value.length() == 0) {
			return -1;
		}
		try {
			return Integer.valueOf(value);
		} catch (NumberFormatException e) {
			return -1;
		}
	}

	private static final int START = 0;
	private static final int DESCRIPTION = 1;

	private static final String TAG_DESCRIPTION = ""OpenSearchDescription"";
	private static final String TAG_URL = ""Url"";

	private int myState = START;

	@Override
	public boolean startElementHandler(String tag, ZLStringMap attributes) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}

		switch (myState) {
		case START:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_DESCRIPTION) {
				myState = DESCRIPTION;
			}
			break;
		case DESCRIPTION:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_URL) {
				final String type = attributes.getValue(""type"");
				final String rel = attributes.getValue(""rel"");
				if (type == MimeTypes.MIME_APP_ATOM
						&& (rel == null || rel == ""results"")) {
					final String template = ZLNetworkUtil.url(myBaseURL, attributes.getValue(""template""));
					final int indexOffset = parseInt(attributes.getValue(""indexOffset""));
					final int pageOffset = parseInt(attributes.getValue(""pageOffset""));
					final OpenSearchDescription descr =
						new OpenSearchDescription(template, myItemsPerPage, indexOffset, pageOffset);
					if (descr.isValid()) {
						myDescriptions.add(descr);
					}
				}
			}
			break;
		}

		return false;
	}

	@Override
	public boolean endElementHandler(String tag) {
		final int index = tag.indexOf(':');
		final String tagPrefix;
		if (index != -1) {
			tagPrefix = tag.substring(0, index).intern();
			tag = tag.substring(index + 1).intern();
		} else {
			tagPrefix = null;
			tag = tag.intern();
		}

		switch (myState) {
		case DESCRIPTION:
			if (tagPrefix == myOpenSearchNamespaceId && tag == TAG_DESCRIPTION) {
				myState = START;
			}
			break;
		}
		return false;
	}
}
",True,79,7,17,6,6,1,6,L6
144,org.geometerplus.fbreader.network.opds.OPDSFeedReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

interface OPDSFeedReader {

	void processFeedStart();

	// return true to interrupt reading; return false to continue reading
	boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries);

	// return true to interrupt reading; return false to continue reading
	boolean processFeedEntry(OPDSEntry entry);

	void processFeedEnd();
}
",False,74,7,17,5,11,4,2,L6
145,org.geometerplus.fbreader.network.opds.OPDSLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.Currency;
import java.util.LinkedList;
import java.util.Locale;

import org.geometerplus.fbreader.network.atom.ATOMLink;


class OPDSPrice {

	public final String Price;
	public final String Currency;

	// @param price     price value; must be not null
	// @param currency  currency code value; must be not null;
	//                  http://www.iso.org/iso/en/prods-services/popstds/currencycodeslist.html
	public OPDSPrice(String price, String currency) {
		Price = price;
		Currency = currency;
	}
}

class OPDSLink extends ATOMLink {

	public final LinkedList<OPDSPrice> Prices = new LinkedList<OPDSPrice>();
	public final LinkedList<String> Formats = new LinkedList<String>();

	private OPDSPrice getPrice(String currency) {
		for (OPDSPrice p: Prices) {
			if (currency.equals(p.Currency)) {
				return p;
			}
		}
		return null;
	}

	public OPDSPrice selectBestPrice() {
		if (Prices.isEmpty()) {
			return null;
		} else if (Prices.size() == 1) {
			return Prices.get(0);
		}
		OPDSPrice price;
		final Locale locale = Locale.getDefault();
		if (locale.getCountry().length() == 2) {
			final String bestCode = Currency.getInstance(locale).getCurrencyCode();
			if (bestCode != null) {
				price = getPrice(bestCode);
				if (price != null) {
					return price;
				}
			}
		}
		price = getPrice(""USD"");
		if (price != null) {
			return price;
		}
		price = getPrice(""EUR"");
		if (price != null) {
			return price;
		}
		return Prices.get(0);
	}
}
",False,60,8,17,3,2,2,1,L6
146,org.geometerplus.fbreader.network.opds.OPDSEntry.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.atom.*;

class OPDSEntry extends ATOMEntry {

	public String DCLanguage;
	public String DCPublisher;
	public DCDate DCIssued;

	public String SeriesTitle;
	public int SeriesIndex;

	@Override
	public String toString() {
		StringBuilder buf = new StringBuilder(""["");
		buf.append(super.toString());
		buf.append("",DCLanguage="").append(DCLanguage);
		buf.append("",DCPublisher="").append(DCPublisher);
		buf.append("",DCIssued="").append(DCIssued);
		buf.append("",SeriesTitle="").append(SeriesTitle);
		buf.append("",SeriesIndex="").append(SeriesIndex);
		buf.append(""]"");
		return buf.toString();
	}
}
",False,71,7,17,4,10,5,2,L6
147,org.geometerplus.fbreader.network.opds.DCDate.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import org.geometerplus.fbreader.network.atom.*;

class DCDate extends ATOMDateConstruct {

	public DCDate() {
	}

	public DCDate(int year) {
		super(year);
	}

	public DCDate(int year, int month, int day) {
		super(year, month, day);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds) {
		super(year, month, day, hour, minutes, seconds);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds, float sfract) {
		super(year, month, day, hour, minutes, seconds, sfract);
	}

	public DCDate(int year, int month, int day, int hour, int minutes, int seconds, float sfract, int tzhour, int tzminutes) {
		super(year, month, day, hour, minutes, seconds, sfract, tzhour, tzminutes);
	}
}
",False,62,8,17,4,1,2,1,L6
148,org.geometerplus.fbreader.network.opds.OPDSCustomLink.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.io.IOException;
import java.io.InputStream;
import java.net.URLConnection;
import java.util.*;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;
import org.geometerplus.zlibrary.core.util.ZLMiscUtil;

import org.geometerplus.fbreader.network.ICustomNetworkLink;
import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkException;


class OPDSCustomLink extends OPDSNetworkLink implements ICustomNetworkLink {

	private int myId;
	private SaveLinkListener myListener;

	private boolean myHasChanges;

	OPDSCustomLink(int id, String siteName, String title, String summary, String icon, Map<String, String> links) {
		super(siteName, title, summary, icon, null, links, false);
		myId = id;
	}

	public int getId() {
		return myId;
	}

	public void setId(int id) {
		myId = id;
	}

	public void setSaveLinkListener(SaveLinkListener listener) {
		myListener = listener;
	}

	public void saveLink() {
		if (myListener != null) {
			myListener.onSaveLink(this);
		} else {
			throw new RuntimeException(""Unable to save link: SaveLinkListener hasn't been set"");
		}
	}

	public boolean hasChanges() {
		return myHasChanges;
	}

	public void resetChanges() {
		myHasChanges = false;
	}


	public final void setIcon(String icon) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(myIcon, icon);
		myIcon = icon;
	}

	public final void setSiteName(String name) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(mySiteName, name);
		mySiteName = name;
	}

	public final void setSummary(String summary) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(mySummary, summary);
		mySummary = summary;
	}

	public final void setTitle(String title) {
		myHasChanges = myHasChanges || !ZLMiscUtil.equals(myTitle, title);
		myTitle = title;
	}

	public final void setLink(String urlKey, String url) {
		if (url == null) {
			removeLink(urlKey);
		} else {
			final String oldUrl = myLinks.put(urlKey, url);
			myHasChanges = myHasChanges || !url.equals(oldUrl);
		}
	}

	public final void removeLink(String urlKey) {
		final String oldUrl = myLinks.remove(urlKey);
		myHasChanges = myHasChanges || oldUrl != null;
	}


	public void reloadInfo() throws ZLNetworkException {
		final LinkedList<String> opensearchDescriptionURLs = new LinkedList<String>();
		final List<OpenSearchDescription> descriptions = Collections.synchronizedList(new LinkedList<OpenSearchDescription>());

		ZLNetworkException error = null;
		try {
			ZLNetworkManager.Instance().perform(new ZLNetworkRequest(getLink(INetworkLink.URL_MAIN)) {
				@Override
				public void handleStream(URLConnection connection, InputStream inputStream) throws IOException, ZLNetworkException {
					final CatalogInfoReader info = new CatalogInfoReader(URL, OPDSCustomLink.this, opensearchDescriptionURLs);
					new OPDSXMLReader(info).read(inputStream);
        
					if (!info.FeedStarted) {
						throw new ZLNetworkException(NetworkException.ERROR_NOT_AN_OPDS);
					}
					if (info.Title == null) {
						throw new ZLNetworkException(NetworkException.ERROR_NO_REQUIRED_INFORMATION);
					}
					myTitle = info.Title;
					if (info.Icon != null) {
						myIcon = info.Icon;
					}
					if (info.Summary != null) {
						mySummary = info.Summary;
					}
					if (info.DirectOpenSearchDescription != null) {
						descriptions.add(info.DirectOpenSearchDescription);
					}
				}
			});
		} catch (ZLNetworkException e) {
			error = e;
		}

		// TODO: Use ALL available descriptions and not only Direct
		if (descriptions.isEmpty() && !opensearchDescriptionURLs.isEmpty()) {
			LinkedList<ZLNetworkRequest> requests = new LinkedList<ZLNetworkRequest>();
			for (String url: opensearchDescriptionURLs) {
				requests.add(new ZLNetworkRequest(url) {
					@Override
					public void handleStream(URLConnection connection, InputStream inputStream) throws IOException, ZLNetworkException {
						new OpenSearchXMLReader(URL, descriptions, 20).read(inputStream);
					}
				});
			}
			try {
				ZLNetworkManager.Instance().perform(requests);
			} catch (ZLNetworkException e) {
				if (error == null) {
					error = e;
				}
			}
		}

		if (!descriptions.isEmpty()) {
			// TODO: May be do not use '%s'??? Use Description instead??? (this needs to rewrite SEARCH engine logic a little)
			setLink(URL_SEARCH, descriptions.get(0).makeQuery(""%s""));
		}
		if (error != null) {
			throw error;
		}
	}
}
",False,247,6,17,11,35,1,14,L6
149,org.geometerplus.fbreader.network.opds.HtmlToString.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.HashMap;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;

import org.geometerplus.zlibrary.core.html.*;
import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.xml.ZLXMLProcessor;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.formats.xhtml.XHTMLReader;
import org.geometerplus.fbreader.network.atom.ATOMConstants;

public class HtmlToString {
	private String myLastOpenedTag;
	private String myTextType;
	private StringBuilder myTextContent = new StringBuilder();

	private HtmlToStringReader myHtmlToStringReader = new HtmlToStringReader();

	public void setupTextContent(String type) {
		if (type == null) {
			myTextType = ATOMConstants.TYPE_DEFAULT;
		} else {
			myTextType = type;
		}
		myTextContent.delete(0, myTextContent.length());
	}

	public String finishTextContent(String bufferContent) {
		if (bufferContent != null) {
			myTextContent.append(bufferContent);
		}
		char[] contentArray = myTextContent.toString().trim().toCharArray();
		String result;
		if (contentArray.length == 0) {
			result = null;
		} else {
			result = new String(contentArray);
		}
		if (result != null) {
			if (myTextType == ATOMConstants.TYPE_HTML || myTextType == ATOMConstants.TYPE_XHTML ||
				myTextType == MimeTypes.MIME_TEXT_HTML || myTextType == MimeTypes.MIME_TEXT_XHTML) {
				myHtmlToStringReader.readFromString(result);
				result = myHtmlToStringReader.getString();
			}
		}
		myTextType = null;
		myTextContent.delete(0, myTextContent.length());
		return result;
	}

	public void processTextContent(boolean closeTag, String tag, ZLStringMap attributes, String bufferContent) {
		if (myTextType == ATOMConstants.TYPE_XHTML || myTextType == MimeTypes.MIME_TEXT_XHTML) {
			if (bufferContent != null) {
				myTextContent.append(bufferContent);
			}
			if (closeTag) {
				final int index = myTextContent.length() - 1;
				if (tag == myLastOpenedTag && bufferContent == null && myTextContent.charAt(index) == '>') {
					myTextContent.insert(index, '/'); // TODO: Is it necessary in HTML???????
				} else {
					myTextContent.append(""</"").append(tag).append("">"");
				}
				myLastOpenedTag = null;
			} else {
				myLastOpenedTag = tag;
				StringBuilder buffer = new StringBuilder(""<"").append(tag);
				for (int i = 0; i < attributes.getSize(); ++i) {
					final String key = attributes.getKey(i);
					final String value = attributes.getValue(key);
					buffer.append("" "").append(key).append(""=\"""");
					if (value != null) {
						buffer.append(value);
					}
					buffer.append(""\"""");
				}
				buffer.append("" >"");
				myTextContent.append(buffer.toString());
			}
		} else {
			if (bufferContent != null) {
				myTextContent.append(bufferContent);
			}
		}
	}

	private static class HtmlToStringReader implements ZLHtmlReader {

		private StringBuilder myBuffer = new StringBuilder();
		private byte[] myByteData;
		private int myByteDataLength;
		private HashMap<String,char[]> myEntityMap;

		public void readFromString(String htmlString) {
			final StringBuilder html = new StringBuilder();
			html.append(""<!DOCTYPE html PUBLIC \""-//W3C//DTD XHTML 1.0 Transitional//EN\"" \""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"">"")
				.append(""<html><head>"")
				.append(""<meta http-equiv=\""Content-Type\"" content=\""text/html; charset=utf-8\"" />"")
				.append(""<title></title>"")
				.append(""</head><body>"")
				.append(htmlString)
				.append(""</body></html>"");
			final byte[] bytes;
			try {
				bytes = html.toString().getBytes(""UTF-8"");
			} catch (UnsupportedEncodingException ex) {
				throw new RuntimeException(""It's impossible!!! UTF-8 charset is not supported!!!"", ex);
			}
			ZLHtmlProcessor.read(this, new ByteArrayInputStream(bytes));
		}

		public String getString() {
			return new String(myBuffer.toString().trim().toCharArray());
		}


		public void startDocumentHandler() {
			myBuffer.delete(0, myBuffer.length());
			myByteDataLength = 0;
		}

		public void endDocumentHandler() {
			processByteData();
		}

		public void startElementHandler(String tag, int offset, ZLHtmlAttributeMap attributes) {
			processByteData();
			tag = tag.toLowerCase().intern();
			if (tag == ""br"") {
				if (myBuffer.length() > 0) {
					myBuffer.append('\n');
				}
			} else if (tag == ""hr"") {
				if (myBuffer.length() > 0) {
					if (myBuffer.charAt(myBuffer.length() - 1) != '\n') {
						myBuffer.append('\n');
					}
					myBuffer.append('\n');
				}
			}
		}

		public void endElementHandler(String tag) {
			processByteData();
			tag = tag.toLowerCase().intern();
			if (tag == ""p"") {
				if (myBuffer.length() > 0) {
					myBuffer.append('\n');
				}
			}
		}

		private void processByteData() {
			if (myByteDataLength == 0) {
				return;
			}
			final String data;
			try {
				data = new String(myByteData, 0, myByteDataLength, ""UTF-8"");
			} catch (UnsupportedEncodingException ex) {
				throw new RuntimeException(""It's impossible!!! UTF-8 charset is not supported!!!"", ex);
			}
			myByteDataLength = 0;
			if (data.length() == 0) {
				return;
			}
			if (myBuffer.length() > 0 && !Character.isWhitespace(myBuffer.charAt(myBuffer.length() - 1))) {
				myBuffer.append(' ');
			}
			int index = 0;
			while (index < data.length() && Character.isWhitespace(data.charAt(index))) {
				++index;
			}
			boolean lastSpace = false;
			while (index < data.length()) {
				final char ch = data.charAt(index++);
				if (Character.isWhitespace(ch)) {
					lastSpace = true;
				} else {
					if (lastSpace) {
						myBuffer.append(' ');
						lastSpace = false;
					}
					myBuffer.append(ch);
				}
			}
		}

		public void entityDataHandler(String entity) {
			processByteData();

			if (entity.length() == 0) {
				return;
			}

			if (myEntityMap == null) {
				myEntityMap = new HashMap<String,char[]>(ZLXMLProcessor.getEntityMap(XHTMLReader.xhtmlDTDs()));
			}
			char[] data = myEntityMap.get(entity);
			if (data == null) {
				if (entity.charAt(0) == '#') {
					try {
						int number;
						if (entity.charAt(1) == 'x') {
							number = Integer.parseInt(entity.substring(2), 16);
						} else {
							number = Integer.parseInt(entity.substring(1));
						}
						data = new char[] { (char)number };
					} catch (NumberFormatException e) {
					}
				}
				if (data == null) {
					data = new char[0];
				}
				myEntityMap.put(entity, data);
			}
//System.err.println(""FBREADER -- ENTITY: &"" + entity + ""; --> "" + new String(data));
			myBuffer.append(data);
		}

		public void byteDataHandler(byte[] data, int start, int length) {
			if (length <= 0) {
				return;
			}
			if (myByteData == null) {
				myByteData = new byte[length];
				System.arraycopy(data, start, myByteData, 0, length);
				myByteDataLength = length;
			} else {
				if (myByteData.length < myByteDataLength + length) {
					final byte[] oldData = myByteData;
					myByteData = new byte[myByteDataLength + length];
					System.arraycopy(oldData, 0, myByteData, 0, myByteDataLength);
				}
				System.arraycopy(data, start, myByteData, myByteDataLength, length);
				myByteDataLength += length;
			}
		}
	}
}
",True,225,8,25,9,28,2,8,L6
150,org.geometerplus.fbreader.network.opds.OPDSLinkReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.net.URLConnection;

import org.geometerplus.zlibrary.core.network.ZLNetworkManager;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.network.ZLNetworkRequest;

import org.geometerplus.fbreader.Paths;
import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.atom.ATOMUpdated;

public class OPDSLinkReader {
	static final String CATALOGS_URL = ""http://data.fbreader.org/catalogs/generic-1.2.xml"";

	public static ICustomNetworkLink createCustomLink(int id, String siteName, String title, String summary, String icon, Map<String, String> links) {
		if (siteName == null || title == null || links.get(INetworkLink.URL_MAIN) == null) {
			return null;
		}
		return new OPDSCustomLink(id, siteName, title, summary, icon, links);
	}

	public static ICustomNetworkLink createCustomLinkWithoutInfo(String siteName, String url) {
		final HashMap<String, String> links = new HashMap<String, String>();
		links.put(INetworkLink.URL_MAIN, url);
		return new OPDSCustomLink(ICustomNetworkLink.INVALID_ID, siteName, null, null, null, links);
	}

	public static final int CACHE_LOAD = 0;
	public static final int CACHE_UPDATE = 1;
	public static final int CACHE_CLEAR = 2;

	public static void loadOPDSLinks(int cacheMode, final NetworkLibrary.OnNewLinkListener listener) throws ZLNetworkException {
		final File dirFile = new File(Paths.networkCacheDirectory());
		if (!dirFile.exists() && !dirFile.mkdirs()) {
			ZLNetworkManager.Instance().perform(new ZLNetworkRequest(CATALOGS_URL) {
				@Override
				public void handleStream(URLConnection connection, InputStream inputStream) throws IOException, ZLNetworkException {
					new OPDSLinkXMLReader(listener, null).read(inputStream);
				}
			});
			// TODO: Is this error is needed?
			//throw new ZLNetworkException(NetworkException.ERROR_CACHE_DIRECTORY_ERROR);
			return;
		}

		final String fileName = ""fbreader_catalogs-""
			+ CATALOGS_URL.substring(CATALOGS_URL.lastIndexOf(File.separator) + 1);

		boolean cacheIsGood = false;
		File oldCache = null;
		ATOMUpdated cacheUpdatedTime = null;
		final File catalogsFile = new File(dirFile, fileName);
		if (catalogsFile.exists()) {
			switch (cacheMode) {
			case CACHE_UPDATE:
				final long diff = System.currentTimeMillis() - catalogsFile.lastModified();
				final long valid = 7 * 24 * 60 * 60 * 1000; // one week in milliseconds; FIXME: hardcoded const
				if (diff >= 0 && diff <= valid) {
					return;
				}
				/* FALLTHROUGH */
			case CACHE_CLEAR:
				try {
					final OPDSLinkXMLReader reader = new OPDSLinkXMLReader();
					reader.read(new FileInputStream(catalogsFile));
					cacheUpdatedTime = reader.getUpdatedTime();
				} catch (FileNotFoundException e) {
					throw new RuntimeException(""That's impossible!!!"", e); 
				}

				oldCache = new File(dirFile, ""_"" + fileName);
				oldCache.delete();
				if (!catalogsFile.renameTo(oldCache)) {
					catalogsFile.delete();
					oldCache = null;
				}
				break;
			case CACHE_LOAD:
				cacheIsGood = true;
				break;
			default:
				throw new IllegalArgumentException(""Invalid cacheMode value ("" + cacheMode
						+ "") in OPDSLinkReader.loadOPDSLinks method"");
			}
		}

		if (!cacheIsGood) {
			try {
				ZLNetworkManager.Instance().downloadToFile(CATALOGS_URL, catalogsFile);
			} catch (ZLNetworkException e) {
				if (oldCache == null) {
					throw e;
				}
				catalogsFile.delete();
				if (!oldCache.renameTo(catalogsFile)) {
					oldCache.delete();
					oldCache = null;
					throw e;
				}
			} finally {
				if (oldCache != null) {
					oldCache.delete();
					oldCache = null;
				}
			}
		}

		try {
			new OPDSLinkXMLReader(listener, cacheUpdatedTime).read(new FileInputStream(catalogsFile));
		} catch (FileNotFoundException e) {
			throw new RuntimeException(""That's impossible!!!"", e); 
		}
	}
}
",True,257,8,17,12,44,2,11,L6
151,org.geometerplus.fbreader.network.opds.OPDSConstants.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;


interface OPDSConstants {
	// Feed level
	String REL_BOOKSHELF = ""http://data.fbreader.org/rel/bookshelf"";
	String REL_RECOMMENDATIONS = ""http://data.fbreader.org/rel/recommendations"";
	//String REL_SUBSCRIPTIONS = ""http://opds-spec.org/subscriptions"";

	// Entry level / catalog types
	String REL_CATALOG_AUTHOR = ""http://data.fbreader.org/catalog/author"";
	String REL_CATALOG_SERIES = ""http://data.fbreader.org/catalog/series"";
	String REL_SUBSECTION = ""subsection"";

	// Entry level / acquisition links
	String REL_ACQUISITION_PREFIX = ""http://opds-spec.org/acquisition"";
	String REL_FBREADER_ACQUISITION_PREFIX = ""http://data.fbreader.org/acquisition"";
	String REL_ACQUISITION = ""http://opds-spec.org/acquisition"";
	String REL_ACQUISITION_OPEN = ""http://opds-spec.org/acquisition/open-access"";
	String REL_ACQUISITION_SAMPLE = ""http://opds-spec.org/acquisition/sample"";
	String REL_ACQUISITION_BUY = ""http://opds-spec.org/acquisition/buy"";
	//String REL_ACQUISITION_BORROW = ""http://opds-spec.org/acquisition/borrow"";
	//String REL_ACQUISITION_SUBSCRIBE = ""http://opds-spec.org/acquisition/subscribe"";
	String REL_ACQUISITION_CONDITIONAL = ""http://data.fbreader.org/acquisition/conditional"";
	String REL_ACQUISITION_SAMPLE_OR_FULL = ""http://data.fbreader.org/acquisition/sampleOrFull"";

	// Entry level / other
	String REL_IMAGE_PREFIX = ""http://opds-spec.org/image"";
	//String REL_IMAGE = ""http://opds-spec.org/image"";
	String REL_IMAGE_THUMBNAIL = ""http://opds-spec.org/image/thumbnail"";
	// FIXME: This relations have been removed from OPDS-1.0 standard. Use RelationAlias instead???
	String REL_COVER = ""http://opds-spec.org/cover"";
	String REL_THUMBNAIL = ""http://opds-spec.org/thumbnail"";

	// Entry level / OPDS Link Relations
	String REL_LINK_SIGN_IN = ""http://data.fbreader.org/catalog/sign-in"";
	String REL_LINK_SIGN_OUT = ""http://data.fbreader.org/catalog/sign-out"";
	String REL_LINK_SIGN_UP = ""http://data.fbreader.org/catalog/sign-up"";
	String REL_LINK_REFILL_ACCOUNT = ""http://data.fbreader.org/catalog/refill-account"";
	String REL_LINK_RECOVER_PASSWORD = ""http://data.fbreader.org/catalog/recover-password"";

	// Entry level / OPDS Link Conditions
	String REL_CONDITION_NEVER = ""http://data.fbreader.org/condition/never"";
	String REL_CONDITION_SIGNED_IN = ""http://data.fbreader.org/condition/signed-in"";
	String REL_CONDITION_HAS_BOOKS = ""http://data.fbreader.org/condition/has-books"";
}
",True,55,7,17,0,0,2,0,L6
152,org.geometerplus.fbreader.network.opds.OPDSLinkXMLReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.*;

import org.geometerplus.zlibrary.core.constants.XMLNamespaces;
import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.filesystem.ZLResourceFile;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkLibrary;
import org.geometerplus.fbreader.network.NetworkCatalogItem;
import org.geometerplus.fbreader.network.atom.ATOMLink;
import org.geometerplus.fbreader.network.atom.ATOMUpdated;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;
import org.geometerplus.fbreader.network.authentication.litres.LitResAuthenticationManager;

class OPDSLinkXMLReader extends OPDSXMLReader implements OPDSConstants, MimeTypes {
	private static class LinkReader implements OPDSFeedReader {
		private NetworkLibrary.OnNewLinkListener myListener;

		private String myAuthenticationType;
		private boolean myHasStableIdentifiers;
		private final LinkedList<URLRewritingRule> myUrlRewritingRules = new LinkedList<URLRewritingRule>();
		private final HashMap<RelationAlias, String> myRelationAliases = new HashMap<RelationAlias, String>();
		private final LinkedHashMap<String,String> myExtraData = new LinkedHashMap<String,String>(); 

		private ATOMUpdated myUpdatedTime;
		private ATOMUpdated myReadAfterTime;

		public LinkReader(NetworkLibrary.OnNewLinkListener listener, ATOMUpdated readAfter) {
			myListener = listener;
			myReadAfterTime = readAfter;
		}

		public void setAuthenticationType(String type) {
			myAuthenticationType = type;
		}

		public void setHasStableIdentifiers(boolean value) {
			myHasStableIdentifiers = value;
		}

		public void addUrlRewritingRule(URLRewritingRule rule) {
			myUrlRewritingRules.add(rule);
		}

		public void addRelationAlias(RelationAlias alias, String relation) {
			myRelationAliases.put(alias, relation);
		}

		public void putExtraData(String name, String value) {
			myExtraData.put(name, value);
		}

		public void clear() {
			myAuthenticationType = null;
			myHasStableIdentifiers = false;
			myUrlRewritingRules.clear();
			myRelationAliases.clear();
			myExtraData.clear();
		}

		public ATOMUpdated getUpdatedTime() {
			return myUpdatedTime;
		}

		private static final String ENTRY_ID_PREFIX = ""urn:fbreader-org-catalog:"";

		public boolean processFeedEntry(OPDSEntry entry) {
			final String id = entry.Id.Uri;
			if (id == null || id.length() <= ENTRY_ID_PREFIX.length()
					|| !id.startsWith(ENTRY_ID_PREFIX)) {
				return false;
			}
			final String siteName = id.substring(ENTRY_ID_PREFIX.length());
			final String title = entry.Title;
			final String summary = entry.Content;
			final String language = entry.DCLanguage;

			String icon = null; 
			final HashMap<String,String> links = new HashMap<String,String>();
			final HashMap<String,NetworkCatalogItem.Accessibility> urlConditions =
				new HashMap<String,NetworkCatalogItem.Accessibility>();
			for (ATOMLink link: entry.Links) {
				final String href = link.getHref();
				final String type = ZLNetworkUtil.filterMimeType(link.getType());
				final String rel = link.getRel();
				if (rel == REL_IMAGE_THUMBNAIL || rel == REL_THUMBNAIL) {
					if (type == MIME_IMAGE_PNG || type == MIME_IMAGE_JPEG) {
						icon = href;
					}
				} else if ((rel != null && rel.startsWith(REL_IMAGE_PREFIX)) || rel == REL_COVER) {
					if (icon == null && (type == MIME_IMAGE_PNG || type == MIME_IMAGE_JPEG)) {
						icon = href;
					}
				} else if (rel == null) {
					if (type == MIME_APP_ATOM) {
						links.put(INetworkLink.URL_MAIN, href);
					}
				} else if (rel == ""search"") {
					if (type == MIME_APP_ATOM) {
						final OpenSearchDescription descr = OpenSearchDescription.createDefault(href);
						if (descr.isValid()) {
							// TODO: May be do not use '%s'??? Use Description instead??? (this needs to rewrite SEARCH engine logic a little)
							links.put(INetworkLink.URL_SEARCH, descr.makeQuery(""%s""));
						}
					}
				} else if (rel == REL_LINK_SIGN_IN) {
					links.put(INetworkLink.URL_SIGN_IN, href);
				} else if (rel == REL_LINK_SIGN_OUT) {
					links.put(INetworkLink.URL_SIGN_OUT, href);
				} else if (rel == REL_LINK_SIGN_UP) {
					links.put(INetworkLink.URL_SIGN_UP, href);
				} else if (rel == REL_LINK_REFILL_ACCOUNT) {
					links.put(INetworkLink.URL_REFILL_ACCOUNT, href);
				} else if (rel == REL_LINK_RECOVER_PASSWORD) {
					links.put(INetworkLink.URL_RECOVER_PASSWORD, href);
				} else if (rel == REL_CONDITION_NEVER) {
					urlConditions.put(href, NetworkCatalogItem.Accessibility.NEVER);
				} else if (rel == REL_CONDITION_SIGNED_IN) {
					urlConditions.put(href, NetworkCatalogItem.Accessibility.SIGNED_IN);
				} else if (rel == REL_CONDITION_HAS_BOOKS) {
					urlConditions.put(href, NetworkCatalogItem.Accessibility.HAS_BOOKS);
				}
			}

			final String sslCertificate;
			final String path = ""network/"" + siteName + "".crt"";
			if (ZLResourceFile.createResourceFile(path).exists()) {
				sslCertificate = path;
			} else {
				sslCertificate = null;
			}

			INetworkLink result = link(siteName, title, summary, icon, language, links, urlConditions, sslCertificate);
			if (result != null) {
				myListener.onNewLink(result);
			}
			return false; 
		}

		private INetworkLink link(
			String siteName,
			String title,
			String summary,
			String icon,
			String language,
			Map<String,String> links,
			HashMap<String,NetworkCatalogItem.Accessibility> urlConditions,
			String sslCertificate
		) {
			if (siteName == null || title == null || links.get(INetworkLink.URL_MAIN) == null) {
				return null;
			}

			OPDSNetworkLink opdsLink = new OPDSNetworkLink(
				siteName,
				title,
				summary,
				icon,
				language,
				links,
				myHasStableIdentifiers
			);

			/*if (!mySearchType.empty()) {
				opdsLink.setupAdvancedSearch(
					mySearchType,
					mySearchFields[""titleOrSeries""],
					mySearchFields[""author""],
					mySearchFields[""tag""],
					mySearchFields[""annotation""]
				);
			}*/
			opdsLink.setRelationAliases(myRelationAliases);
			opdsLink.setUrlConditions(urlConditions);
			opdsLink.setUrlRewritingRules(myUrlRewritingRules);
			opdsLink.setExtraData(myExtraData);

			NetworkAuthenticationManager authManager = null;
			if (myAuthenticationType == ""basic"") {
				//authManager = NetworkAuthenticationManager.createManager(opdsLink, sslCertificate, BasicAuthenticationManager.class);
			} else if (myAuthenticationType == ""litres"") {
				authManager = NetworkAuthenticationManager.createManager(opdsLink, sslCertificate, LitResAuthenticationManager.class);
			}
			opdsLink.setAuthenticationManager(authManager);

			return opdsLink;
		}

		public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
			myUpdatedTime = feed.Updated;
			if (myUpdatedTime != null && myReadAfterTime != null
					&& myUpdatedTime.compareTo(myReadAfterTime) <= 0) {
				return true;
			}
			return myListener == null; // no listener -- no need to proceed
		}

		public void processFeedStart() {
			myUpdatedTime = null;
		}

		public void processFeedEnd() {
		}
	}

	public OPDSLinkXMLReader() {
		super(new LinkReader(null, null));
	}

	public OPDSLinkXMLReader(NetworkLibrary.OnNewLinkListener listener, ATOMUpdated readAfter) {
		super(new LinkReader(listener, readAfter));
	}

	public ATOMUpdated getUpdatedTime() {
		return ((LinkReader) myFeedReader).getUpdatedTime();
	}

	private String myFBReaderNamespaceId;

	@Override
	public void namespaceMapChangedHandler(Map<String, String> namespaceMap) {
		super.namespaceMapChangedHandler(namespaceMap);

		myFBReaderNamespaceId = null;

		for (Map.Entry<String,String> entry : namespaceMap.entrySet()) {
			final String value = entry.getValue();
			if (value == XMLNamespaces.FBReaderCatalogMetadata) {
				myFBReaderNamespaceId = intern(entry.getKey());
			}
		}
	}


	private static final String FBREADER_ADVANCED_SEARCH = ""advancedSearch"";
	private static final String FBREADER_AUTHENTICATION = ""authentication"";
	private static final String FBREADER_STABLE_IDENTIFIERS = ""hasStableIdentifiers"";
	private static final String FBREADER_REWRITING_RULE = ""urlRewritingRule"";
	private static final String FBREADER_RELATION_ALIAS = ""relationAlias"";
	private static final String FBREADER_EXTRA = ""extra"";

	@Override
	public boolean startElementHandler(final String tagPrefix, final String tag,
			final ZLStringMap attributes, final String bufferContent) {
		switch (getState()) {
		case FEED:
			if (tagPrefix == myAtomNamespaceId && tag == TAG_ENTRY) {
				((LinkReader) myFeedReader).clear();
			}
			break;
		case F_ENTRY:
			if (tagPrefix == myFBReaderNamespaceId) {
				if (tag == FBREADER_ADVANCED_SEARCH) {
					return false;
				} else if (tag == FBREADER_AUTHENTICATION) {
					final String type = attributes.getValue(""type"");
					((LinkReader) myFeedReader).setAuthenticationType(type);
					return false;
				} else if (tag == FBREADER_RELATION_ALIAS) {
					final String name = attributes.getValue(""name"");
					final String type = attributes.getValue(""type"");
					String alias = attributes.getValue(""alias"");
					if (alias != null && name != null) {
						if (alias.length() == 0) {
							alias = null;
						}
						((LinkReader) myFeedReader).addRelationAlias(new RelationAlias(alias, type), name);
					}
					return false;
				} else if (tag == FBREADER_REWRITING_RULE) {
					final String type = attributes.getValue(""type"");
					final String apply = attributes.getValue(""apply"");
					final String name = attributes.getValue(""name"");
					final String value = attributes.getValue(""value"");
					final int typeValue;
					if (type == ""addUrlParameter"") {
						typeValue = URLRewritingRule.ADD_URL_PARAMETER;
					} else {
						return false;
					}
					final int applyValue;
					if (apply == ""external"") {
						applyValue = URLRewritingRule.APPLY_EXTERNAL;
					} else if (apply == ""internal"") {
						applyValue = URLRewritingRule.APPLY_INTERNAL;
					} else {
						applyValue = URLRewritingRule.APPLY_ALWAYS;
					}
					((LinkReader) myFeedReader).addUrlRewritingRule(new URLRewritingRule(typeValue, applyValue, name, value));
					return false;
				} else if (tag == FBREADER_STABLE_IDENTIFIERS) {
					((LinkReader) myFeedReader).setHasStableIdentifiers(true);
					return false;
				} else if (tag == FBREADER_EXTRA) {
					final String name = attributes.getValue(""name"");
					final String value = attributes.getValue(""value"");
					if (name != null && value != null) {
						((LinkReader) myFeedReader).putExtraData(name, value);
					}
				}
			}
			break;
		}
		return super.startElementHandler(tagPrefix, tag, attributes, bufferContent);
	}
}
",True,213,0,0,11,48,1,26,L6
153,org.geometerplus.fbreader.network.opds.CatalogInfoReader.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.opds;

import java.util.List;

import org.geometerplus.zlibrary.core.constants.MimeTypes;
import org.geometerplus.zlibrary.core.util.ZLNetworkUtil;

import org.geometerplus.fbreader.network.atom.ATOMLink;

class CatalogInfoReader implements OPDSFeedReader {

	public boolean FeedStarted;
	public String Icon;
	public String Title;
	public String Summary;

	public OpenSearchDescription DirectOpenSearchDescription;
	private final List<String> myOpensearchDescriptionURLs;

	private final String myBaseURL;
	private final OPDSNetworkLink myLink;

	public CatalogInfoReader(String baseUrl, OPDSNetworkLink link, List<String> opensearchDescriptionURLs) {
		myBaseURL = baseUrl;
		myLink = link;
		myOpensearchDescriptionURLs = opensearchDescriptionURLs;
	}

	public boolean processFeedMetadata(OPDSFeedMetadata feed, boolean beforeEntries) {
		Icon = (feed.Icon != null) ? feed.Icon.Uri : null;
		Title = feed.Title;
		Summary = feed.Subtitle;

		for (ATOMLink link: feed.Links) {
			final String type = ZLNetworkUtil.filterMimeType(link.getType());
			final String rel = myLink.relation(link.getRel(), type);
			if (rel == ""search"") {
				if (type == MimeTypes.MIME_APP_OPENSEARCHDESCRIPTION) {
					myOpensearchDescriptionURLs.add(ZLNetworkUtil.url(myBaseURL, link.getHref()));
				} else if (type == MimeTypes.MIME_APP_ATOM) {
					final String template = ZLNetworkUtil.url(myBaseURL, link.getHref());
					final OpenSearchDescription descr = OpenSearchDescription.createDefault(template);
					if (descr.isValid()) {
						DirectOpenSearchDescription = descr;
					}
				}
			}
		}
		return true;
	}

	public void processFeedStart() {
		FeedStarted = true;
	}

	public void processFeedEnd() {
	}

	public boolean processFeedEntry(OPDSEntry entry) {
		return true;
	}
}
",True,245,7,17,12,26,1,10,L6
154,org.geometerplus.fbreader.network.tree.NetworkTreeFactory.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.network.*;

public class NetworkTreeFactory {

	public static NetworkTree createNetworkTree(NetworkCatalogTree parent, NetworkLibraryItem item) {
		return createNetworkTree(parent, item, -1);
	}

	public static NetworkTree createNetworkTree(NetworkCatalogTree parent, NetworkLibraryItem item, int position) {
		final int subtreesSize = parent.subTrees().size();
		if (position == -1) {
			position = subtreesSize;
		} else if (position < 0 || position > subtreesSize) {
			throw new IndexOutOfBoundsException(""`position` value equals "" + position + "" but must be in range [0; "" + subtreesSize + ""]"");
		}

		if (item instanceof NetworkCatalogItem) {
			NetworkCatalogItem catalogItem = (NetworkCatalogItem) item;
			if (catalogItem.getVisibility() == ZLBoolean3.B3_FALSE) {
				return null;
			}
			NetworkCatalogTree tree = new NetworkCatalogTree(parent, catalogItem, position);
			catalogItem.onDisplayItem();
			return tree;
		} else if (item instanceof NetworkBookItem) {
			if (position != subtreesSize) {
				throw new RuntimeException(""Unable to insert NetworkBookItem to the middle of the catalog"");
			}

			final NetworkCatalogItem.CatalogType catalogType = parent.Item.getCatalogType();
			final boolean showAuthors = catalogType != NetworkCatalogItem.CatalogType.BY_AUTHOR;

			NetworkBookItem book = (NetworkBookItem) item;
			String seriesTitle = book.SeriesTitle;
			if (seriesTitle == null || catalogType == NetworkCatalogItem.CatalogType.BY_SERIES) {
				return new NetworkBookTree(parent, (NetworkBookItem) item, position, showAuthors);
			}

			if (position > 0) {
				final NetworkTree previous = (NetworkTree) parent.subTrees().get(position - 1);
				if (previous instanceof NetworkSeriesTree) {
					final NetworkSeriesTree seriesTree = (NetworkSeriesTree) previous;
					if (seriesTitle.equals(seriesTree.SeriesTitle)) {
						seriesTree.invalidateChildren(); // call to update secondString
						return new NetworkBookTree(seriesTree, book, showAuthors);
					}
				} else if (previous instanceof NetworkBookTree) {
					final NetworkBookTree bookTree = (NetworkBookTree) previous;
					final NetworkBookItem previousBook = bookTree.Book;
					if (seriesTitle.equals(previousBook.SeriesTitle)) {
						bookTree.removeSelf();
						final NetworkSeriesTree seriesTree = new NetworkSeriesTree(parent, seriesTitle, --position, showAuthors);
						new NetworkBookTree(seriesTree, previousBook, showAuthors);
						return new NetworkBookTree(seriesTree, book, showAuthors);
					}
				}
			}

			return new NetworkBookTree(parent, book, position, showAuthors);
		}
		return null;
	}
}
",False,218,7,17,14,23,2,10,L6
155,org.geometerplus.fbreader.network.tree.NetworkCatalogRootTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.fbreader.network.*;

public class NetworkCatalogRootTree extends NetworkCatalogTree {

	public NetworkCatalogRootTree(RootTree parent, INetworkLink link, int position) {
		super(parent, (NetworkCatalogItem) link.libraryItem(), position);
	}
}
",False,223,5,17,14,23,3,4,L6
156,org.geometerplus.fbreader.network.tree.NetworkBookTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.network.*;


public class NetworkBookTree extends NetworkTree {

	public final NetworkBookItem Book;

	private final boolean myShowAuthors;

	NetworkBookTree(NetworkTree parent, NetworkBookItem book, boolean showAuthors) {
		super(parent);
		Book = book;
		myShowAuthors = showAuthors;
	}

	NetworkBookTree(NetworkTree parent, NetworkBookItem book, int position, boolean showAuthors) {
		super(parent, position);
		Book = book;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return Book.Title;
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors && Book.Authors.size() < 2) {
			return null;
		}
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (NetworkBookItem.AuthorData author: Book.Authors) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(author.DisplayName);
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		return createCover(Book);
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return Book;
	}
}
",False,225,6,16,14,23,5,4,L6
157,org.geometerplus.fbreader.network.tree.NetworkCatalogTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.util.ZLBoolean3;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;

public class NetworkCatalogTree extends NetworkTree {

	public final NetworkCatalogItem Item;
	public final ArrayList<NetworkLibraryItem> ChildrenItems = new ArrayList<NetworkLibraryItem>();

	private long myLoadedTime = -1;

	NetworkCatalogTree(RootTree parent, NetworkCatalogItem item, int position) {
		super(parent, position);
		Item = item;
	}

	NetworkCatalogTree(NetworkCatalogTree parent, NetworkCatalogItem item, int position) {
		super(parent, position);
		Item = item;
	}

	@Override
	public String getName() {
		return Item.Title;
	}

	@Override
	public String getSummary() {
		if (Item.Summary == null) {
			return """";
		}
		return Item.Summary;
	}

	@Override
	protected ZLImage createCover() {
		return createCover(Item);
	}


	public boolean isContentValid() {
		if (myLoadedTime < 0) {
			return false;
		}
		final int reloadTime = 15 * 60 * 1000; // 15 minutes in milliseconds
		return System.currentTimeMillis() - myLoadedTime < reloadTime;
	}

	public void updateLoadedTime() {
		myLoadedTime = System.currentTimeMillis();
		FBTree tree = Parent;
		while (tree instanceof NetworkCatalogTree) {
			((NetworkCatalogTree) tree).myLoadedTime = myLoadedTime;
			tree = tree.Parent;
		}
	}


	public void updateVisibility() {
		final LinkedList<FBTree> toRemove = new LinkedList<FBTree>();

		ListIterator<FBTree> nodeIterator = subTrees().listIterator();
		FBTree currentNode = null;
		int nodeCount = 0;

		for (int i = 0; i < ChildrenItems.size(); ++i) {
			NetworkLibraryItem currentItem = ChildrenItems.get(i);
			if (!(currentItem instanceof NetworkCatalogItem)) {
				continue;
			}
			boolean processed = false;
			while (currentNode != null || nodeIterator.hasNext()) {
				if (currentNode == null) {
					currentNode = nodeIterator.next();
				}
				if (!(currentNode instanceof NetworkCatalogTree)) {
					currentNode = null;
					++nodeCount;
					continue;
				}
				NetworkCatalogTree child = (NetworkCatalogTree) currentNode;
				if (child.Item == currentItem) {
					switch (child.Item.getVisibility()) {
						case B3_TRUE:
							child.updateVisibility();
							break;
						case B3_FALSE:
							toRemove.add(child);
							break;
						case B3_UNDEFINED:
							child.clear();
							child.ChildrenItems.clear();
							break;
					}
					currentNode = null;
					++nodeCount;
					processed = true;
					break;
				} else {
					boolean found = false;
					for (int j = i + 1; j < ChildrenItems.size(); ++j) {
						if (child.Item == ChildrenItems.get(j)) {
							found = true;
							break;
						}
					}
					if (!found) {
						toRemove.add(currentNode);
						currentNode = null;
						++nodeCount;
					} else {
						break;
					}
				}
			}
			final int nextIndex = nodeIterator.nextIndex();
			if (!processed && NetworkTreeFactory.createNetworkTree(this, currentItem, nodeCount) != null) {
				++nodeCount;
				nodeIterator = subTrees().listIterator(nextIndex + 1);
			}
		}

		while (currentNode != null || nodeIterator.hasNext()) {
			if (currentNode == null) {
				currentNode = nodeIterator.next();
			}
			if (currentNode instanceof NetworkCatalogTree) {
				toRemove.add(currentNode);
			}
			currentNode = null;
		}

		for (FBTree tree: toRemove) {
			tree.removeSelf();
		}
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return Item;
	}

	@Override
	public void removeItems(Set<NetworkLibraryItem> items) {
		ChildrenItems.removeAll(items);
		super.removeItems(items);
	}
}
",False,224,5,17,14,23,6,9,L6
158,org.geometerplus.fbreader.network.tree.RootTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import org.geometerplus.fbreader.network.NetworkLibraryItem;
import org.geometerplus.fbreader.network.NetworkTree;

public final class RootTree extends NetworkTree {
	@Override
	public String getName() {
		return null;
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}
}
",False,222,5,17,15,23,3,2,L6
159,org.geometerplus.fbreader.network.tree.NetworkSeriesTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.image.ZLImage;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;


public class NetworkSeriesTree extends NetworkTree {

	public final String SeriesTitle;

	private final boolean myShowAuthors;

	NetworkSeriesTree(NetworkTree parent, String seriesTitle, int position, boolean showAuthors) {
		super(parent, position);
		SeriesTitle = seriesTitle;
		myShowAuthors = showAuthors;
	}

	@Override
	public String getName() {
		return SeriesTitle;
	}

	@Override
	public String getSummary() {
		if (!myShowAuthors) {
			return super.getSummary();
		}

		StringBuilder builder = new StringBuilder();
		int count = 0;

		Set<NetworkBookItem.AuthorData> authorSet = new TreeSet<NetworkBookItem.AuthorData>();
		for (FBTree tree: subTrees()) {
			if (!(tree instanceof NetworkBookTree)) {
				continue;
			}
			final NetworkBookItem book = ((NetworkBookTree) tree).Book;

			for (NetworkBookItem.AuthorData author: book.Authors) {
				if (!authorSet.contains(author)) {
					authorSet.add(author);
					if (count++ > 0) {
						builder.append("",  "");
					}
					builder.append(author.DisplayName);
					if (count == 5) {
						return builder.toString();
					}
				}
			}
		}
		return builder.toString();
	}

	@Override
	protected ZLImage createCover() {
		for (FBTree tree: subTrees()) {
			if (tree instanceof NetworkBookTree) {
				return ((NetworkBookTree) tree).createCover();
			}
		}
		return null;
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}

	@Override
	public void removeItems(Set<NetworkLibraryItem> items) {
		super.removeItems(items);
		if (subTrees().isEmpty()) {
			removeSelf();
		}
	}
}
",False,225,7,16,14,23,4,7,L6
160,org.geometerplus.fbreader.network.tree.NetworkAuthorTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.network.tree;

import java.util.*;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;


public class NetworkAuthorTree extends NetworkTree {

	public final NetworkBookItem.AuthorData Author;

	private int myBooksNumber;
	private HashMap<String, Integer> mySeriesMap;

	public NetworkAuthorTree(NetworkTree parent, NetworkBookItem.AuthorData author) {
		super(parent);
		Author = author;
	}

	@Override
	public String getName() {
		return Author.DisplayName;
	}

	@Override
	protected String getSortKey() {
		return Author.SortKey;
	}

	private int getSeriesIndex(String seriesName) {
		if (mySeriesMap == null) {
			return -1;
		}
		Integer value = mySeriesMap.get(seriesName);
		if (value == null) {
			return -1;
		}
		return value.intValue();
	}

	private void setSeriesIndex(String seriesName, int index) {
		if (mySeriesMap == null) {
			mySeriesMap = new HashMap<String, Integer>();
		}
		mySeriesMap.put(seriesName, Integer.valueOf(index));
	}

	public void updateSubTrees(LinkedList<NetworkBookItem> books) {
		if (myBooksNumber >= books.size()) {
			return;
		}
		invalidateChildren(); // call to update secondString

		ListIterator<NetworkBookItem> booksIterator = books.listIterator(myBooksNumber);
		while (booksIterator.hasNext()) {
			NetworkBookItem book = booksIterator.next();

			if (book.SeriesTitle != null) {
				final int seriesPosition = getSeriesIndex(book.SeriesTitle);
				if (seriesPosition == -1) {
					final int insertAt = subTrees().size();
					setSeriesIndex(book.SeriesTitle, insertAt);
					new NetworkBookTree(this, book, false);
				} else {
					FBTree treeAtSeriesPosition = subTrees().get(seriesPosition);
					if (treeAtSeriesPosition instanceof NetworkBookTree) {
						final NetworkBookTree bookTree = (NetworkBookTree) treeAtSeriesPosition;
						bookTree.removeSelf();
						final NetworkSeriesTree seriesTree = new NetworkSeriesTree(this, book.SeriesTitle, seriesPosition, false);
						new NetworkBookTree(seriesTree, bookTree.Book, false);
						treeAtSeriesPosition = seriesTree;
					}

					if (!(treeAtSeriesPosition instanceof NetworkSeriesTree)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					final NetworkSeriesTree seriesTree = (NetworkSeriesTree) treeAtSeriesPosition;
					ListIterator<FBTree> nodesIterator = seriesTree.subTrees().listIterator();
					int insertAt = 0;
					while (nodesIterator.hasNext()) {
						FBTree tree = nodesIterator.next();
						if (!(tree instanceof NetworkBookTree)) {
							throw new RuntimeException(""That's impossible!!!"");
						}
						NetworkBookTree bookTree = (NetworkBookTree) tree;
						if (bookTree.Book.IndexInSeries > book.IndexInSeries) {
							break;
						}
						++insertAt;
					}
					seriesTree.invalidateChildren(); // call to update secondString
					new NetworkBookTree(seriesTree, book, insertAt, false);
				}
			} else {
				new NetworkBookTree(this, book, false);
			}
		}

		myBooksNumber = books.size();
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}
}
",False,217,7,17,14,23,3,7,L6
161,org.geometerplus.fbreader.tree.FBTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.fbreader.tree;

import java.util.*;

import org.geometerplus.zlibrary.core.tree.ZLTree;
import org.geometerplus.zlibrary.core.image.ZLImage;

public abstract class FBTree extends ZLTree<FBTree> implements Comparable<FBTree> {

	private ZLImage myCover;
	private boolean myCoverRequested;

	protected FBTree(int level) {
		super(level);
	}

	protected FBTree() {
		super();
	}

	protected FBTree(FBTree parent) {
		super(parent);
	}

	protected FBTree(FBTree parent, int position) {
		super(parent, position);
	}

	public abstract String getName();

	public final FBTree getSubTreeByName(String name) {
		if (name == null) {
			return null;
		}
		for (FBTree t : subTrees()) {
			if (name.equals(t.getName())) {
				return t;
			}
		}
		return null;
	}

	protected String getSortKey() {
		return getName();
	}

	public int compareTo(FBTree ct) {
		final String key0 = getSortKey();
		final String key1 = ct.getSortKey();
		if (key0 == null) {
			return (key1 == null) ? 0 : -1;
		}
		if (key1 == null) {
			return 1;
		}
		return key0.toLowerCase().compareTo(key1.toLowerCase());
	}

	public final void sortAllChildren() {
		List<FBTree> children = subTrees();
		if (!children.isEmpty()) {
			Collections.sort(children);
			for (FBTree tree : children) {
				tree.sortAllChildren();
			}
		}
	}

	private String mySecondString;

	public final void invalidateChildren() {
		mySecondString = null;
	}

	public final String getSecondString() {
		if (mySecondString == null) {
			mySecondString = getSummary();
			if (mySecondString == null) {
				mySecondString = """";
			}
		}
		return mySecondString;
	}

	protected String getSummary() {
		StringBuilder builder = new StringBuilder();
		int count = 0;
		for (FBTree subtree : subTrees()) {
			if (count++ > 0) {
				builder.append("",  "");
			}
			builder.append(subtree.getName());
			if (count == 5) {
				break;
			}
		}
		return builder.toString();
	}

	protected ZLImage createCover() {
		return null;
	}

	public final ZLImage getCover() {
		if (!myCoverRequested) {
			myCover = createCover();
			if (myCover == null && Parent != null) {
				myCover = Parent.getCover();
			}
			myCoverRequested = true;
		}
		return myCover;
	}
}
",False,85,5,30,1,2,21,2,L5
162,org.geometerplus.android.fbreader.RunActivityAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

abstract class RunActivityAction extends FBAction {
	private final FBReader myBaseActivity;
	private final Class<?> myActivityClass;

	RunActivityAction(FBReader baseActivity, FBReaderApp fbreader, Class<?> activityClass) {
		super(fbreader);
		myBaseActivity = baseActivity;
		myActivityClass = activityClass;
	}

	public void run() {
		myBaseActivity.startActivity(new Intent(myBaseActivity.getApplicationContext(), myActivityClass));
	}
}
",False,377,0,0,9,90,3,3,L6
163,org.geometerplus.android.fbreader.PackageInfo.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

public class PackageInfo {
	public final String Id;
	public final String PackageName;
	public final String ClassName;
	public final String Title;

	public final String IntentAction;
	public final String IntentKey;
	public final String IntentDataPattern;

	PackageInfo(String id, String packageName, String className, String title, String intentAction, String intentKey, String intentDataPattern) {
		Id = id;
		PackageName = packageName;
		ClassName = className;
		Title = title;

		IntentAction = intentAction;
		IntentKey = intentKey;
		IntentDataPattern = intentDataPattern;
	}
}
",False,48,7,17,0,0,2,0,L6
164,org.geometerplus.android.fbreader.FBReader.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.SearchManager;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.Menu;
import android.view.WindowManager;
import android.view.Window;
import android.widget.RelativeLayout;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.zlibrary.text.hyphenation.ZLTextHyphenator;

import org.geometerplus.zlibrary.ui.android.R;
import org.geometerplus.zlibrary.ui.android.library.ZLAndroidActivity;
import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.fbreader.ActionCode;
import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.bookmodel.BookModel;
import org.geometerplus.fbreader.library.Book;

import org.geometerplus.android.fbreader.library.KillerCallback;

import org.geometerplus.android.util.UIUtil;

public final class FBReader extends ZLAndroidActivity {
	public static final String BOOK_PATH_KEY = ""BookPath"";

	final static int REPAINT_CODE = 1;
	final static int CANCEL_CODE = 2;

	private int myFullScreenFlag;

	private static TextSearchButtonPanel ourTextSearchPanel;
	private static NavigationButtonPanel ourNavigatePanel;

	@Override
	protected ZLFile fileFromIntent(Intent intent) {
		String filePath = intent.getStringExtra(BOOK_PATH_KEY);
		if (filePath == null) {
			final Uri data = intent.getData();
			if (data != null) {
				filePath = data.getPath();
			}
		}
		return filePath != null ? ZLFile.createFileByPath(filePath) : null;
	}

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();
		myFullScreenFlag =
			application.ShowStatusBarOption.getValue() ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN;
		getWindow().setFlags(
			WindowManager.LayoutParams.FLAG_FULLSCREEN, myFullScreenFlag
		);

		final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
		if (ourTextSearchPanel == null) {
			ourTextSearchPanel = new TextSearchButtonPanel(fbReader);
		}
		if (ourNavigatePanel == null) {
			ourNavigatePanel = new NavigationButtonPanel(fbReader);
		}

		fbReader.addAction(ActionCode.SHOW_LIBRARY, new ShowLibraryAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_PREFERENCES, new ShowPreferencesAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_BOOK_INFO, new ShowBookInfoAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_CONTENTS, new ShowTOCAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_BOOKMARKS, new ShowBookmarksAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_NETWORK_LIBRARY, new ShowNetworkLibraryAction(this, fbReader));
		
		fbReader.addAction(ActionCode.SHOW_MENU, new ShowMenuAction(this, fbReader));
		fbReader.addAction(ActionCode.SHOW_NAVIGATION, new ShowNavigationAction(this, fbReader));
		fbReader.addAction(ActionCode.SEARCH, new SearchAction(this, fbReader));

		fbReader.addAction(ActionCode.PROCESS_HYPERLINK, new ProcessHyperlinkAction(this, fbReader));

		fbReader.addAction(ActionCode.CANCEL, new CancelAction(this, fbReader));
	}

 	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();
		if (!application.ShowStatusBarOption.getValue() &&
			application.ShowStatusBarWhenMenuIsActiveOption.getValue()) {
			getWindow().addFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
		}
		return super.onPrepareOptionsMenu(menu);
	}

	@Override
	public void onOptionsMenuClosed(Menu menu) {
		super.onOptionsMenuClosed(menu);
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();
		if (!application.ShowStatusBarOption.getValue() &&
			application.ShowStatusBarWhenMenuIsActiveOption.getValue()) {
			getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
		}
	}

	@Override
	protected void onNewIntent(Intent intent) {
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			final String pattern = intent.getStringExtra(SearchManager.QUERY);
			final Handler successHandler = new Handler() {
				public void handleMessage(Message message) {
					ourTextSearchPanel.show(true);
				}
			};
			final Handler failureHandler = new Handler() {
				public void handleMessage(Message message) {
					UIUtil.showErrorMessage(FBReader.this, ""textNotFound"");
					ourTextSearchPanel.StartPosition = null;
				}
			};
			final Runnable runnable = new Runnable() {
				public void run() {
					ourTextSearchPanel.initPosition();
					final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
					fbReader.TextSearchPatternOption.setValue(pattern);
					if (fbReader.getTextView().search(pattern, true, false, false, false) != 0) {
						successHandler.sendEmptyMessage(0);
					} else {
						failureHandler.sendEmptyMessage(0);
					}
				}
			};
			UIUtil.wait(""search"", runnable, this);
		} else {
			super.onNewIntent(intent);
		}
	}

	@Override
	public void onStart() {
		super.onStart();
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();

		final int fullScreenFlag =
			application.ShowStatusBarOption.getValue() ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN;
		if (fullScreenFlag != myFullScreenFlag) {
			finish();
			startActivity(new Intent(this, this.getClass()));
		}

		final RelativeLayout root = (RelativeLayout)findViewById(R.id.root_view);
		if (!ourTextSearchPanel.hasControlPanel()) {
			ourTextSearchPanel.createControlPanel(this, root);
		}
		if (!ourNavigatePanel.hasControlPanel()) {
			ourNavigatePanel.createControlPanel(this, root);
		}
	}

	@Override
	public void onResume() {
		super.onResume();
		try {
			sendBroadcast(new Intent(getApplicationContext(), KillerCallback.class));
		} catch (Throwable t) {
		}
		ControlButtonPanel.restoreVisibilities(FBReaderApp.Instance());
	}

	@Override
	public void onPause() {
		ControlButtonPanel.saveVisibilities(FBReaderApp.Instance());
		super.onPause();
	}

	@Override
	public void onStop() {
		ControlButtonPanel.removeControlPanels(FBReaderApp.Instance());
		super.onStop();
	}

	@Override
	protected FBReaderApp createApplication(ZLFile file) {
		if (SQLiteBooksDatabase.Instance() == null) {
			new SQLiteBooksDatabase(this, ""READER"");
		}
		return new FBReaderApp(file != null ? file.getPath() : null);
	}

	@Override
	public boolean onSearchRequested() {
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		ControlButtonPanel.saveVisibilities(fbreader);
		ControlButtonPanel.hideAllPendingNotify(fbreader);
		final SearchManager manager = (SearchManager)getSystemService(SEARCH_SERVICE);
		manager.setOnCancelListener(new SearchManager.OnCancelListener() {
			public void onCancel() {
				ControlButtonPanel.restoreVisibilities(fbreader);
				manager.setOnCancelListener(null);
			}
		});
		startSearch(fbreader.TextSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		switch (requestCode) {
			case REPAINT_CODE:
			{
				final BookModel model = fbreader.Model;
				if (model != null) {
					final Book book = model.Book;
					if (book != null) {
						book.reloadInfoFromDatabase();
						ZLTextHyphenator.Instance().load(book.getLanguage());
					}
				}
				fbreader.clearTextCaches();
				fbreader.repaintView();
				break;
			}
			case CANCEL_CODE:
				fbreader.runCancelAction(resultCode);
				break;
		}
	}

	public void navigate() {
		ourNavigatePanel.runNavigation();
	}
}
",True,377,0,0,8,99,19,30,L6
165,org.geometerplus.android.fbreader.BookInfoActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.io.File;
import java.text.DateFormat;
import java.util.Date;
import java.util.HashSet;

import android.app.Activity;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.view.View;
import android.view.Window;
import android.widget.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;

import org.geometerplus.zlibrary.ui.android.R;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;

import org.geometerplus.fbreader.library.*;

import org.geometerplus.android.fbreader.preferences.EditBookInfoActivity;

public class BookInfoActivity extends Activity {
	private static final boolean ENABLE_EXTENDED_FILE_INFO = false;

	public static final String CURRENT_BOOK_PATH_KEY = ""CurrentBookPath"";
	public static final String HIDE_OPEN_BUTTON_KEY = ""hideOpenButton"";

	private final ZLResource myResource = ZLResource.resource(""bookInfo"");
	private ZLFile myFile;
	private ZLImage myImage;
	private boolean myHideOpenButton;

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(
			new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this)
		);

		final String path = getIntent().getStringExtra(CURRENT_BOOK_PATH_KEY);
		myHideOpenButton = getIntent().getBooleanExtra(HIDE_OPEN_BUTTON_KEY, false);
		myFile = ZLFile.createFileByPath(path);

		myImage = Library.getCover(myFile);

		if (SQLiteBooksDatabase.Instance() == null) {
			new SQLiteBooksDatabase(this, ""LIBRARY"");
		}

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.book_info);
	}

	@Override
	protected void onStart() {
		super.onStart();

		final Book book = Book.getByFile(myFile);

		if (book != null) {
			setupCover(book);
			setupBookInfo(book);
			setupAnnotation(book);
			setupFileInfo(book);
		}

		if (myHideOpenButton) {
			findButton(R.id.book_info_button_open).setVisibility(View.GONE);
		} else {
			setupButton(R.id.book_info_button_open, ""openBook"", new View.OnClickListener() {
				public void onClick(View view) {
					startActivity(
						new Intent(getApplicationContext(), FBReader.class)
							.setAction(Intent.ACTION_VIEW)
							.putExtra(FBReader.BOOK_PATH_KEY, myFile.getPath())
							.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
					);
				}
			});
		}
		setupButton(R.id.book_info_button_edit, ""editInfo"", new View.OnClickListener() {
			public void onClick(View view) {
				startActivityForResult(
					new Intent(getApplicationContext(), EditBookInfoActivity.class)
						.putExtra(CURRENT_BOOK_PATH_KEY, myFile.getPath()),
					1
				);
			}
		});
		setupButton(R.id.book_info_button_reload, ""reloadInfo"", new View.OnClickListener() {
			public void onClick(View view) {
				if (book != null) {
					book.reloadInfoFromFile();
					setupBookInfo(book);
				}
			}
		});

		final View root = findViewById(R.id.book_info_root);
		root.invalidate();
		root.requestLayout();
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		final Book book = Book.getByFile(myFile);
		if (book != null) {
			setupBookInfo(book);
		}
	}

	private Button findButton(int buttonId) {
		return (Button)findViewById(buttonId);
	}

	private void setupButton(int buttonId, String resourceKey, View.OnClickListener listener) {
		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		final Button button = findButton(buttonId);
		button.setText(buttonResource.getResource(resourceKey).getValue());
		button.setOnClickListener(listener);
	}

	private void setupInfoPair(int id, String key, CharSequence value) {
		LinearLayout layout = (LinearLayout)findViewById(id);
		if (value == null || value.length() == 0) {
			layout.setVisibility(View.GONE);
			return;
		}
		layout.setVisibility(View.VISIBLE);
		((TextView)layout.findViewById(R.id.book_info_key)).setText(myResource.getResource(key).getValue());
		((TextView)layout.findViewById(R.id.book_info_value)).setText(value);
	}

	private void setupCover(Book book) {
		final ImageView coverView = (ImageView)findViewById(R.id.book_cover);

		final DisplayMetrics metrics = new DisplayMetrics();
		getWindowManager().getDefaultDisplay().getMetrics(metrics);

		final int maxHeight = metrics.heightPixels * 2 / 3;
		final int maxWidth = maxHeight * 2 / 3;

		coverView.setVisibility(View.GONE);
		coverView.setImageDrawable(null);

		if (myImage == null) {
			return;
		}

		if (myImage instanceof ZLLoadableImage) {
			final ZLLoadableImage loadableImage = (ZLLoadableImage)myImage;
			if (!loadableImage.isSynchronized()) {
				loadableImage.synchronize();
			}
		}
		final ZLAndroidImageData data =
			((ZLAndroidImageManager)ZLAndroidImageManager.Instance()).getImageData(myImage);
		if (data == null) {
			return;
		}

		final Bitmap coverBitmap = data.getBitmap(2 * maxWidth, 2 * maxHeight);
		if (coverBitmap == null) {
			return;
		}

		coverView.setVisibility(View.VISIBLE);
		coverView.getLayoutParams().width = maxWidth;
		coverView.getLayoutParams().height = maxHeight;
		coverView.setImageBitmap(coverBitmap);
	}

	private void setupBookInfo(Book book) {
		((TextView)findViewById(R.id.book_info_title)).setText(myResource.getResource(""bookInfo"").getValue());

		setupInfoPair(R.id.book_title, ""title"", book.getTitle());

		final StringBuilder buffer = new StringBuilder();
		for (Author author: book.authors()) {
			if (buffer.length() > 0) {
				buffer.append("", "");
			}
			buffer.append(author.DisplayName);
		}
		setupInfoPair(R.id.book_authors, ""authors"", buffer);

		SeriesInfo series = book.getSeriesInfo();
		setupInfoPair(R.id.book_series, ""series"",
				(series == null) ? null : series.Name);
		setupInfoPair(R.id.book_series_index, ""indexInSeries"",
				(series == null || series.Index <= 0) ? null : String.valueOf(series.Index));

		buffer.delete(0, buffer.length());
		final HashSet<String> tagNames = new HashSet<String>();
		for (Tag tag : book.tags()) {
			if (!tagNames.contains(tag.Name)) {
				if (buffer.length() > 0) {
					buffer.append("", "");
				}
				buffer.append(tag.Name);
				tagNames.add(tag.Name);
			}
		}
		setupInfoPair(R.id.book_tags, ""tags"", buffer);
		String language = book.getLanguage();
		if (!ZLLanguageUtil.languageCodes().contains(language)) {
			language = ZLLanguageUtil.OTHER_LANGUAGE_CODE;
		}
		setupInfoPair(R.id.book_language, ""language"", ZLLanguageUtil.languageName(language));
	}

	private void setupAnnotation(Book book) {
		final TextView titleView = (TextView)findViewById(R.id.book_info_annotation_title);
		final TextView bodyView = (TextView)findViewById(R.id.book_info_annotation_body);
		final String annotation = Library.getAnnotation(book.File);	
		if (annotation == null) {
			titleView.setVisibility(View.GONE);
			bodyView.setVisibility(View.GONE);
		} else {
			titleView.setText(myResource.getResource(""annotation"").getValue());
			bodyView.setText(annotation);
		}
	}

	private void setupFileInfo(Book book) {
		((TextView)findViewById(R.id.file_info_title)).setText(myResource.getResource(""fileInfo"").getValue());

		setupInfoPair(R.id.file_name, ""name"", book.File.getPath());
		if (ENABLE_EXTENDED_FILE_INFO) {
			setupInfoPair(R.id.file_type, ""type"", book.File.getExtension());
        
			final ZLFile physFile = book.File.getPhysicalFile();
			final File file = physFile == null ? null : new File(physFile.getPath());
			if (file != null && file.exists() && file.isFile()) {
				setupInfoPair(R.id.file_size, ""size"", formatSize(file.length()));
				setupInfoPair(R.id.file_time, ""time"", formatDate(file.lastModified()));
			} else {
				setupInfoPair(R.id.file_size, ""size"", null);
				setupInfoPair(R.id.file_time, ""time"", null);
			}
		} else {
			setupInfoPair(R.id.file_type, ""type"", null);
			setupInfoPair(R.id.file_size, ""size"", null);
			setupInfoPair(R.id.file_time, ""time"", null);
		}
	}

	private String formatSize(long size) {
		if (size <= 0) {
			return null;
		}
		final int kilo = 1024;
		if (size < kilo) { // less than 1 kilobyte
			return myResource.getResource(""sizeInBytes"").getValue().replaceAll(""%s"", String.valueOf(size));
		}
		final String value;
		if (size < kilo * kilo) { // less than 1 megabyte
			value = String.format(""%.2f"", ((float)size) / kilo);
		} else {
			value = String.valueOf(size / kilo);
		}
		return myResource.getResource(""sizeInKiloBytes"").getValue().replaceAll(""%s"", value);
	}

	private String formatDate(long date) {
		if (date == 0) {
			return null;
		}
		return DateFormat.getDateTimeInstance().format(new Date(date));
	}
}
",False,377,0,0,9,88,3,18,L6
166,org.geometerplus.android.fbreader.TextSearchButtonPanel.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.ArrayList;

import android.content.Context;
import android.view.View;
import android.widget.RelativeLayout;
import android.widget.ZoomButton;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.fbreader.ActionCode;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ActionButton extends ZoomButton {
	final String ActionId;
	final boolean IsCloseButton;

	ActionButton(Context context, String actionId, boolean isCloseButton) {
		super(context);
		ActionId = actionId;
		IsCloseButton = isCloseButton;
	}
}

final class TextSearchButtonPanel extends ControlButtonPanel implements View.OnClickListener {
	private final ArrayList<ActionButton> myButtons = new ArrayList<ActionButton>();

	TextSearchButtonPanel(FBReaderApp fbReader) {
		super(fbReader);
	}

	@Override
	public void onHide() {
		Reader.getTextView().clearFindResults();
	}

	@Override
	public void createControlPanel(FBReader activity, RelativeLayout root) {
		myControlPanel = new ControlPanel(activity, root, false);

		addButton(ActionCode.FIND_PREVIOUS, false, R.drawable.text_search_previous);
		addButton(ActionCode.CLEAR_FIND_RESULTS, true, R.drawable.text_search_close);
		addButton(ActionCode.FIND_NEXT, false, R.drawable.text_search_next);
	}

	private void addButton(String actionId, boolean isCloseButton, int imageId) {
		final ActionButton button = new ActionButton(myControlPanel.getContext(), actionId, isCloseButton);
		button.setImageResource(imageId);
		myControlPanel.addView(button);
		button.setOnClickListener(this);
		myButtons.add(button);
	}

	@Override
	public void updateStates() {
		for (ActionButton button : myButtons) {
			button.setEnabled(Reader.isActionEnabled(button.ActionId));
		}
	}

	public void onClick(View view) {
		final ActionButton button = (ActionButton)view;
		Reader.doAction(button.ActionId);
		if (button.IsCloseButton && myControlPanel != null) {
			storePosition();
			StartPosition = null;
			myControlPanel.hide(true);
		}
	}
}
",False,377,0,0,9,78,1,7,L6
167,org.geometerplus.android.fbreader.NavigationButtonPanel.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.view.View;
import android.widget.Button;
import android.widget.RelativeLayout;
import android.widget.SeekBar;
import android.widget.TextView;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.text.view.ZLTextView;
import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

final class NavigationButtonPanel extends ControlButtonPanel {
	private volatile boolean myIsInProgress;

	NavigationButtonPanel(FBReaderApp fbReader) {
		super(fbReader);
	}

	public void runNavigation() {
		if (!getVisibility()) {
			myIsInProgress = false;
			initPosition();
			show(true);
		}
	}

	@Override
	public void onShow() {
		if (myControlPanel != null) {
			setupNavigation(myControlPanel);
		}
	}

	@Override
	public void updateStates() {
		super.updateStates();
		if (!myIsInProgress && myControlPanel != null) {
			setupNavigation(myControlPanel);
		}
	}

	@Override
	public void createControlPanel(FBReader activity, RelativeLayout root) {
		myControlPanel = new ControlPanel(activity, root, true);

		final View layout = activity.getLayoutInflater().inflate(R.layout.navigate, myControlPanel, false);

		final SeekBar slider = (SeekBar)layout.findViewById(R.id.book_position_slider);
		final TextView text = (TextView)layout.findViewById(R.id.book_position_text);

		slider.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
			private void gotoPage(int page) {
				final ZLTextView view = Reader.getTextView();
				if (page == 1) {
					view.gotoHome();
				} else {
					view.gotoPage(page);
				}
				Reader.repaintView();
			}

			public void onStopTrackingTouch(SeekBar seekBar) {
				myIsInProgress = false;
			}

			public void onStartTrackingTouch(SeekBar seekBar) {
				myIsInProgress = true;
			}

			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				if (fromUser) {
					final int page = progress + 1;
					final int pagesNumber = seekBar.getMax() + 1;
					text.setText(makeProgressText(page, pagesNumber));
					gotoPage(page);
				}
			}
		});

		final Button btnOk = (Button)layout.findViewById(android.R.id.button1);
		final Button btnCancel = (Button)layout.findViewById(android.R.id.button3);
		View.OnClickListener listener = new View.OnClickListener() {
			public void onClick(View v) {
				final ZLTextWordCursor position = StartPosition;
				if (v == btnCancel && position != null) {
					Reader.getTextView().gotoPosition(position);
				} else if (v == btnOk) {
					storePosition();
				}
				StartPosition = null;
				hide(true);
			}
		};
		btnOk.setOnClickListener(listener);
		btnCancel.setOnClickListener(listener);
		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		btnOk.setText(buttonResource.getResource(""ok"").getValue());
		btnCancel.setText(buttonResource.getResource(""cancel"").getValue());

		myControlPanel.addView(layout);
	}

	private void setupNavigation(ControlPanel panel) {
		final SeekBar slider = (SeekBar)panel.findViewById(R.id.book_position_slider);
		final TextView text = (TextView)panel.findViewById(R.id.book_position_text);

		final ZLTextView textView = Reader.getTextView();
		final int page = textView.computeCurrentPage();
		final int pagesNumber = textView.computePageNumber();

		if (slider.getMax() != pagesNumber - 1 || slider.getProgress() != page - 1) {
			slider.setMax(pagesNumber - 1);
			slider.setProgress(page - 1);
			text.setText(makeProgressText(page, pagesNumber));
		}
	}

	private static String makeProgressText(int page, int pagesNumber) {
		return page + "" / "" + pagesNumber;
	}
}
",False,377,0,0,9,76,1,8,L6
168,org.geometerplus.android.fbreader.ShowNavigationAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.zlibrary.text.model.ZLTextModel;
import org.geometerplus.zlibrary.text.view.ZLTextView;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowNavigationAction extends FBAction {
	private final FBReader myActivity;

	ShowNavigationAction(FBReader activity, FBReaderApp fbreader) {
		super(fbreader);
		myActivity = activity;
	}

	@Override
	public boolean isVisible() {
		final ZLTextView view = (ZLTextView)Reader.getCurrentView();
		final ZLTextModel textModel = view.getModel();
		return textModel != null && textModel.getParagraphsNumber() != 0;
	}

	public void run() {
		myActivity.navigate();
	}
}
",False,377,0,0,9,78,1,6,L6
169,org.geometerplus.android.fbreader.ControlPanel.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.Handler;
import android.os.Message;
import android.content.Context;
import android.view.*;
import android.view.animation.AlphaAnimation;
import android.widget.*;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.application.ZLApplication;

public class ControlPanel extends LinearLayout {
	public ControlPanel(Context context, RelativeLayout root, boolean fillWidth) {
		super(context);

		setFocusable(false);
		
		final LayoutInflater inflater =
			(LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
		inflater.inflate(R.layout.control_panel, this, true);

		RelativeLayout.LayoutParams p = new RelativeLayout.LayoutParams(
			fillWidth ? ViewGroup.LayoutParams.FILL_PARENT : ViewGroup.LayoutParams.WRAP_CONTENT,
			RelativeLayout.LayoutParams.WRAP_CONTENT
		);
		p.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
		p.addRule(RelativeLayout.CENTER_HORIZONTAL);
		root.addView(this, p);

		setVisibility(View.GONE);
	}

	@Override
	public boolean onTouchEvent(MotionEvent event) {
		return true;
	}

	private interface VisibilityAction {
		int SHOW_ANIMATED = 0;
		int SHOW_INSTANTLY = 1;
		int HIDE_ANIMATED = 2;
		int HIDE_INSTANTLY = 3;
	}
	
	private Handler myVisibilityHandler = new Handler() {
		public void handleMessage(Message message) {
			switch (message.what) {
				case VisibilityAction.SHOW_ANIMATED:
					fade(View.VISIBLE, 0.0f, 1.0f);
					break;
				case VisibilityAction.SHOW_INSTANTLY:
					setVisibility(View.VISIBLE);
					break;
				case VisibilityAction.HIDE_ANIMATED:
					fade(View.GONE, 1.0f, 0.0f);
					break;
				case VisibilityAction.HIDE_INSTANTLY:
					setVisibility(View.GONE);
					break;
			}
		}
	};

	public void show(boolean animate) {
		myVisibilityHandler.sendEmptyMessage(animate ? VisibilityAction.SHOW_ANIMATED : VisibilityAction.SHOW_INSTANTLY);
	}

	public void hide(boolean animate) {
		myVisibilityHandler.sendEmptyMessage(animate ? VisibilityAction.HIDE_ANIMATED : VisibilityAction.HIDE_INSTANTLY);
	}
	
	private void fade(int visibility, float startAlpha, float endAlpha) {
		final AlphaAnimation animation = new AlphaAnimation(startAlpha, endAlpha);
		animation.setDuration(500);
		startAnimation(animation);
		setVisibility(visibility);
	}

	public void addView(View view) {
		((LinearLayout)findViewById(R.id.tools_plate)).addView(view);
	}
}
",False,86,6,16,6,14,3,1,L6
170,org.geometerplus.android.fbreader.SQLiteBooksDatabase.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;
import android.database.SQLException;
import android.database.Cursor;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.options.ZLIntegerOption;
import org.geometerplus.zlibrary.core.config.ZLConfig;
import org.geometerplus.zlibrary.text.view.ZLTextPosition;
import org.geometerplus.zlibrary.text.view.ZLTextFixedPosition;

import org.geometerplus.fbreader.library.*;

import org.geometerplus.android.util.UIUtil;

public final class SQLiteBooksDatabase extends BooksDatabase {
	private final String myInstanceId;
	private final SQLiteDatabase myDatabase;

	public SQLiteBooksDatabase(Context context, String instanceId) {
		myInstanceId = instanceId;
		myDatabase = context.openOrCreateDatabase(""books.db"", Context.MODE_PRIVATE, null);
		migrate(context);
	}

	protected void executeAsATransaction(Runnable actions) {
		myDatabase.beginTransaction();
		try {
			actions.run();
			myDatabase.setTransactionSuccessful();
		} finally {
			myDatabase.endTransaction();
		}
	}

	private void migrate(Context context) {
		final int version = myDatabase.getVersion();
		final int currentVersion = 14;
		if (version >= currentVersion) {
			return;
		}
		UIUtil.wait((version == 0) ? ""creatingBooksDatabase"" : ""updatingBooksDatabase"", new Runnable() {
			public void run() {
				myDatabase.beginTransaction();

				switch (version) {
					case 0:
						createTables();
					case 1:
						updateTables1();
					case 2:
						updateTables2();
					case 3:
						updateTables3();
					case 4:
						updateTables4();
					case 5:
						updateTables5();
					case 6:
						updateTables6();
					case 7:
						updateTables7();
					case 8:
						updateTables8();
					case 9:
						updateTables9();
					case 10:
						updateTables10();
					case 11:
						updateTables11();
					case 12:
						updateTables12();
					case 13:
						updateTables13();
				}
				myDatabase.setTransactionSuccessful();
				myDatabase.endTransaction();

				myDatabase.execSQL(""VACUUM"");
				myDatabase.setVersion(currentVersion);
			}
		}, context);
	}

	private static void bindString(SQLiteStatement statement, int index, String value) {
		if (value != null) {
			statement.bindString(index, value);
		} else {
			statement.bindNull(index);
		}
	}

	private static void bindDate(SQLiteStatement statement, int index, Date value) {
		if (value != null) {
			statement.bindLong(index, value.getTime());
		} else {
			statement.bindNull(index);
		}
	}

	private static Date getDate(Cursor cursor, int index) {
		if (cursor.isNull(index)) {
			return null;
		}
		return new Date(cursor.getLong(index));
	}

	@Override
	protected Book loadBook(long bookId) {
		Book book = null;
		final Cursor cursor = myDatabase.rawQuery(""SELECT file_id,title,encoding,language FROM Books WHERE book_id = "" + bookId, null);
		if (cursor.moveToNext()) {
			book = createBook(
				bookId, cursor.getLong(0), cursor.getString(1), cursor.getString(2), cursor.getString(3)
			);
		}
		cursor.close();
		return book;
	}

	@Override
	protected void reloadBook(Book book) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT title,encoding,language FROM Books WHERE book_id = "" + book.getId(), null);
		if (cursor.moveToNext()) {
			book.setTitle(cursor.getString(0));
			book.setEncoding(cursor.getString(1));
			book.setLanguage(cursor.getString(2));
		}
		cursor.close();
	}

	protected Book loadBookByFile(long fileId, ZLFile file) {
		if (fileId == -1) {
			return null;
		}
		Book book = null;
		final Cursor cursor = myDatabase.rawQuery(""SELECT book_id,title,encoding,language FROM Books WHERE file_id = "" + fileId, null);
		if (cursor.moveToNext()) {
			book = createBook(
				cursor.getLong(0), file, cursor.getString(1), cursor.getString(2), cursor.getString(3)
			);
		}
		cursor.close();
		return book;
	}

	private boolean myTagCacheIsInitialized;
	private final HashMap<Tag,Long> myIdByTag = new HashMap<Tag,Long>();
	private final HashMap<Long,Tag> myTagById = new HashMap<Long,Tag>();

	private void initTagCache() {
		if (myTagCacheIsInitialized) {
			return;
		}
		myTagCacheIsInitialized = true;
        
		Cursor cursor = myDatabase.rawQuery(""SELECT tag_id,parent_id,name FROM Tags ORDER BY tag_id"", null);
		while (cursor.moveToNext()) {
			long id = cursor.getLong(0);
			if (myTagById.get(id) == null) {
				final Tag tag = Tag.getTag(myTagById.get(cursor.getLong(1)), cursor.getString(2));
				myIdByTag.put(tag, id);
				myTagById.put(id, tag);
			}
		}
		cursor.close();
	}

	@Override
	protected Map<Long,Book> loadBooks(FileInfoSet infos) {
		Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id,file_id,title,encoding,language FROM Books"", null
		);
		final HashMap<Long,Book> booksById = new HashMap<Long,Book>();
		final HashMap<Long,Book> booksByFileId = new HashMap<Long,Book>();
		while (cursor.moveToNext()) {
			final long id = cursor.getLong(0);
			final long fileId = cursor.getLong(1);
			final Book book = createBook(
				id, infos.getFile(fileId), cursor.getString(2), cursor.getString(3), cursor.getString(4)
			);
			if (book != null) {
				booksById.put(id, book);
				booksByFileId.put(fileId, book);
			}
		}
		cursor.close();

		initTagCache();

		cursor = myDatabase.rawQuery(
			""SELECT author_id,name,sort_key FROM Authors"", null
		);
		final HashMap<Long,Author> authorById = new HashMap<Long,Author>();
		while (cursor.moveToNext()) {
			authorById.put(cursor.getLong(0), new Author(cursor.getString(1), cursor.getString(2)));
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,author_id FROM BookAuthor ORDER BY author_index"", null
		);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				Author author = authorById.get(cursor.getLong(1));
				if (author != null) {
					addAuthor(book, author);
				}
			}
		}
		cursor.close();

		cursor = myDatabase.rawQuery(""SELECT book_id,tag_id FROM BookTag"", null);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				addTag(book, getTagById(cursor.getLong(1)));
			}
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT series_id,name FROM Series"", null
		);
		final HashMap<Long,String> seriesById = new HashMap<Long,String>();
		while (cursor.moveToNext()) {
			seriesById.put(cursor.getLong(0), cursor.getString(1));
		}
		cursor.close();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,series_id,book_index FROM BookSeries"", null
		);
		while (cursor.moveToNext()) {
			Book book = booksById.get(cursor.getLong(0));
			if (book != null) {
				String series = seriesById.get(cursor.getLong(1));
				if (series != null) {
					setSeriesInfo(book, series, cursor.getLong(2));
				}
			}
		}
		cursor.close();
		return booksByFileId;
	}

	private SQLiteStatement myUpdateBookInfoStatement;
	protected void updateBookInfo(long bookId, long fileId, String encoding, String language, String title) {
		if (myUpdateBookInfoStatement == null) {
			myUpdateBookInfoStatement = myDatabase.compileStatement(
				""UPDATE Books SET file_id = ?, encoding = ?, language = ?, title = ? WHERE book_id = ?""
			);
		}
		myUpdateBookInfoStatement.bindLong(1, fileId);
		bindString(myUpdateBookInfoStatement, 2, encoding);
		bindString(myUpdateBookInfoStatement, 3, language);
		myUpdateBookInfoStatement.bindString(4, title);
		myUpdateBookInfoStatement.bindLong(5, bookId);
		myUpdateBookInfoStatement.execute();
	}

	private SQLiteStatement myInsertBookInfoStatement;
	protected long insertBookInfo(ZLFile file, String encoding, String language, String title) {
		if (myInsertBookInfoStatement == null) {
			myInsertBookInfoStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Books (encoding,language,title,file_id) VALUES (?,?,?,?)""
			);
		}
		bindString(myInsertBookInfoStatement, 1, encoding);
		bindString(myInsertBookInfoStatement, 2, language);
		myInsertBookInfoStatement.bindString(3, title);
		final FileInfoSet infoSet = new FileInfoSet(file);
		myInsertBookInfoStatement.bindLong(4, infoSet.getId(file));
		return myInsertBookInfoStatement.executeInsert();
	}

	private SQLiteStatement myDeleteBookAuthorsStatement;
	protected void deleteAllBookAuthors(long bookId) {
		if (myDeleteBookAuthorsStatement == null) {
			myDeleteBookAuthorsStatement = myDatabase.compileStatement(
				""DELETE FROM BookAuthor WHERE book_id = ?""
			);
		}
		myDeleteBookAuthorsStatement.bindLong(1, bookId);
		myDeleteBookAuthorsStatement.execute();
	}

	private SQLiteStatement myGetAuthorIdStatement;
	private SQLiteStatement myInsertAuthorStatement;
	private SQLiteStatement myInsertBookAuthorStatement;
	protected void saveBookAuthorInfo(long bookId, long index, Author author) {
		if (myGetAuthorIdStatement == null) {
			myGetAuthorIdStatement = myDatabase.compileStatement(
				""SELECT author_id FROM Authors WHERE name = ? AND sort_key = ?""
			);
			myInsertAuthorStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Authors (name,sort_key) VALUES (?,?)""
			);
			myInsertBookAuthorStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookAuthor (book_id,author_id,author_index) VALUES (?,?,?)""
			);
		}

		long authorId;
		try {
			myGetAuthorIdStatement.bindString(1, author.DisplayName);
			myGetAuthorIdStatement.bindString(2, author.SortKey);
			authorId = myGetAuthorIdStatement.simpleQueryForLong();
		} catch (SQLException e) {
			myInsertAuthorStatement.bindString(1, author.DisplayName);
			myInsertAuthorStatement.bindString(2, author.SortKey);
			authorId = myInsertAuthorStatement.executeInsert();
		}
		myInsertBookAuthorStatement.bindLong(1, bookId);
		myInsertBookAuthorStatement.bindLong(2, authorId);
		myInsertBookAuthorStatement.bindLong(3, index);
		myInsertBookAuthorStatement.execute();
	}

	protected List<Author> loadAuthors(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Authors.name,Authors.sort_key FROM BookAuthor INNER JOIN Authors ON Authors.author_id = BookAuthor.author_id WHERE BookAuthor.book_id = ?"", new String[] { """" + bookId });
		if (!cursor.moveToNext()) {
			cursor.close();
			return null;
		}
		final ArrayList<Author> list = new ArrayList<Author>();
		do {
			list.add(new Author(cursor.getString(0), cursor.getString(1)));
		} while (cursor.moveToNext());
		cursor.close();	
		return list;
	}

	private SQLiteStatement myGetTagIdStatement;
	private SQLiteStatement myCreateTagIdStatement;
	private long getTagId(Tag tag) {
		if (myGetTagIdStatement == null) {
			myGetTagIdStatement = myDatabase.compileStatement(
				""SELECT tag_id FROM Tags WHERE parent_id = ? AND name = ?""
			);
			myCreateTagIdStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Tags (parent_id,name) VALUES (?,?)""
			);
		}	
		{
			final Long id = myIdByTag.get(tag);
			if (id != null) {
				return id;
			}
		}
		if (tag.Parent != null) {
			myGetTagIdStatement.bindLong(1, getTagId(tag.Parent));
		} else {
			myGetTagIdStatement.bindNull(1);
		}
		myGetTagIdStatement.bindString(2, tag.Name);
		long id;
		try {
			id = myGetTagIdStatement.simpleQueryForLong();
		} catch (SQLException e) {
			if (tag.Parent != null) {
				myCreateTagIdStatement.bindLong(1, getTagId(tag.Parent));
			} else {
				myCreateTagIdStatement.bindNull(1);
			}
			myCreateTagIdStatement.bindString(2, tag.Name);
			id = myCreateTagIdStatement.executeInsert();
		}
		myIdByTag.put(tag, id);
		myTagById.put(id, tag);
		return id;
	}

	private SQLiteStatement myDeleteBookTagsStatement;
	protected void deleteAllBookTags(long bookId) {
		if (myDeleteBookTagsStatement == null) {
			myDeleteBookTagsStatement = myDatabase.compileStatement(
				""DELETE FROM BookTag WHERE book_id = ?""
			);
		}
		myDeleteBookTagsStatement.bindLong(1, bookId);
		myDeleteBookTagsStatement.execute();
	}

	private SQLiteStatement myInsertBookTagStatement;
	protected void saveBookTagInfo(long bookId, Tag tag) {
		if (myInsertBookTagStatement == null) {
			myInsertBookTagStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO BookTag (book_id,tag_id) VALUES (?,?)""
			);
		}
		myInsertBookTagStatement.bindLong(1, bookId);
		myInsertBookTagStatement.bindLong(2, getTagId(tag));
		myInsertBookTagStatement.execute();
	}

	private Tag getTagById(long id) {
		Tag tag = myTagById.get(id);
		if (tag == null) {
			final Cursor cursor = myDatabase.rawQuery(""SELECT parent_id,name FROM Tags WHERE tag_id = ?"", new String[] { """" + id });
			if (cursor.moveToNext()) {
				final Tag parent = cursor.isNull(0) ? null : getTagById(cursor.getLong(0));
				tag = Tag.getTag(parent, cursor.getString(1));
				myIdByTag.put(tag, id);
				myTagById.put(id, tag);
			}
			cursor.close();
		}
		return tag;
	}

	protected List<Tag> loadTags(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Tags.tag_id FROM BookTag INNER JOIN Tags ON Tags.tag_id = BookTag.tag_id WHERE BookTag.book_id = ?"", new String[] { """" + bookId });
		if (!cursor.moveToNext()) {
			cursor.close();
			return null;
		}
		ArrayList<Tag> list = new ArrayList<Tag>();
		do {
			list.add(getTagById(cursor.getLong(0)));
		} while (cursor.moveToNext());
		cursor.close();	
		return list;
	}

	private SQLiteStatement myGetSeriesIdStatement;
	private SQLiteStatement myInsertSeriesStatement;
	private SQLiteStatement myInsertBookSeriesStatement;
	private SQLiteStatement myDeleteBookSeriesStatement;
	protected void saveBookSeriesInfo(long bookId, SeriesInfo seriesInfo) {
		if (myGetSeriesIdStatement == null) {
			myGetSeriesIdStatement = myDatabase.compileStatement(
				""SELECT series_id FROM Series WHERE name = ?""
			);
			myInsertSeriesStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Series (name) VALUES (?)""
			);
			myInsertBookSeriesStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookSeries (book_id,series_id,book_index) VALUES (?,?,?)""
			);
			myDeleteBookSeriesStatement = myDatabase.compileStatement(
				""DELETE FROM BookSeries WHERE book_id = ?""
			);
		}

		if (seriesInfo == null) {
			myDeleteBookSeriesStatement.bindLong(1, bookId);
			myDeleteBookSeriesStatement.execute();
		} else {
			long seriesId;
			try {
				myGetSeriesIdStatement.bindString(1, seriesInfo.Name);
				seriesId = myGetSeriesIdStatement.simpleQueryForLong();
			} catch (SQLException e) {
				myInsertSeriesStatement.bindString(1, seriesInfo.Name);
				seriesId = myInsertSeriesStatement.executeInsert();
			}
			myInsertBookSeriesStatement.bindLong(1, bookId);
			myInsertBookSeriesStatement.bindLong(2, seriesId);
			myInsertBookSeriesStatement.bindLong(3, seriesInfo.Index);
			myInsertBookSeriesStatement.execute();
		}
	}

	protected SeriesInfo loadSeriesInfo(long bookId) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT Series.name,BookSeries.book_index FROM BookSeries INNER JOIN Series ON Series.series_id = BookSeries.series_id WHERE BookSeries.book_id = ?"", new String[] { """" + bookId });
		SeriesInfo info = null;
		if (cursor.moveToNext()) {
			info = new SeriesInfo(cursor.getString(0), cursor.getLong(1));
		}
		cursor.close();	
		return info;
	}

	private SQLiteStatement myRemoveFileInfoStatement;
	protected void removeFileInfo(long fileId) {
		if (fileId == -1) {
			return;
		}
		if (myRemoveFileInfoStatement == null) {
			myRemoveFileInfoStatement = myDatabase.compileStatement(
				""DELETE FROM Files WHERE file_id = ?""
			);
		}
		myRemoveFileInfoStatement.bindLong(1, fileId);
		myRemoveFileInfoStatement.execute();
	}

	private SQLiteStatement myInsertFileInfoStatement;
	private SQLiteStatement myUpdateFileInfoStatement;
	protected void saveFileInfo(FileInfo fileInfo) {
		final long id = fileInfo.Id;
		SQLiteStatement statement;
		if (id == -1) {
			if (myInsertFileInfoStatement == null) {
				myInsertFileInfoStatement = myDatabase.compileStatement(
					""INSERT OR IGNORE INTO Files (name,parent_id,size) VALUES (?,?,?)""
				);
			}
			statement = myInsertFileInfoStatement;
		} else {
			if (myUpdateFileInfoStatement == null) {
				myUpdateFileInfoStatement = myDatabase.compileStatement(
					""UPDATE Files SET name = ?, parent_id = ?, size = ? WHERE file_id = ?""
				);
			}
			statement = myUpdateFileInfoStatement;
		}
		statement.bindString(1, fileInfo.Name);
		final FileInfo parent = fileInfo.Parent;
		if (parent != null) {
			statement.bindLong(2, parent.Id);
		} else {
			statement.bindNull(2);
		}
		final long size = fileInfo.FileSize;
		if (size != -1) {
			statement.bindLong(3, size);
		} else {
			statement.bindNull(3);
		}
		if (id == -1) {
			fileInfo.Id = statement.executeInsert();
		} else {
			statement.bindLong(4, id);
			statement.execute();
		}
	}

	protected Collection<FileInfo> loadFileInfos() {
		Cursor cursor = myDatabase.rawQuery(
			""SELECT file_id,name,parent_id,size FROM Files"", null
		);
		HashMap<Long,FileInfo> infosById = new HashMap<Long,FileInfo>();
		while (cursor.moveToNext()) {
			final long id = cursor.getLong(0);
			final FileInfo info = createFileInfo(id,
				cursor.getString(1),
				cursor.isNull(2) ? null : infosById.get(cursor.getLong(2))
			);
			if (!cursor.isNull(3)) {
				info.FileSize = cursor.getLong(3);
			}
			infosById.put(id, info);
		}
		cursor.close();
		return infosById.values();
	}

	protected Collection<FileInfo> loadFileInfos(ZLFile file) {
		final LinkedList<ZLFile> fileStack = new LinkedList<ZLFile>();
		for (; file != null; file = file.getParent()) {
			fileStack.addFirst(file);
		}

		final ArrayList<FileInfo> infos = new ArrayList<FileInfo>(fileStack.size());
		final String[] parameters = { null };
		FileInfo current = null;
		for (ZLFile f : fileStack) {
			parameters[0] = f.getLongName();
			final Cursor cursor = myDatabase.rawQuery(
				(current == null) ?
					""SELECT file_id,size FROM Files WHERE name = ?"" :
					""SELECT file_id,size FROM Files WHERE parent_id = "" + current.Id + "" AND name = ?"",
				parameters
			);
			if (cursor.moveToNext()) {
				current = createFileInfo(cursor.getLong(0), parameters[0], current);
				if (!cursor.isNull(1)) {
					current.FileSize = cursor.getLong(1);
				}
				infos.add(current);
				cursor.close();
			} else {
				cursor.close();
				break;
			}
		}

		return infos;
	}

	protected Collection<FileInfo> loadFileInfos(long fileId) {
		final ArrayList<FileInfo> infos = new ArrayList<FileInfo>();
		while (fileId != -1) {
			final Cursor cursor = myDatabase.rawQuery(
				""SELECT name,size,parent_id FROM Files WHERE file_id = "" + fileId, null
			);
			if (cursor.moveToNext()) {
				FileInfo info = createFileInfo(fileId, cursor.getString(0), null);
				if (!cursor.isNull(1)) {
					info.FileSize = cursor.getLong(1);
				}
				infos.add(0, info);
				fileId = cursor.isNull(2) ? -1 : cursor.getLong(2);
			} else {
				fileId = -1;
			}
			cursor.close();
		}
		for (int i = 1; i < infos.size(); ++i) {
			final FileInfo oldInfo = infos.get(i);
			final FileInfo newInfo = createFileInfo(oldInfo.Id, oldInfo.Name, infos.get(i - 1));
			newInfo.FileSize = oldInfo.FileSize;
			infos.set(i, newInfo);
		}
		return infos;
	}

	private SQLiteStatement mySaveRecentBookStatement;
	protected void saveRecentBookIds(final List<Long> ids) {
		if (mySaveRecentBookStatement == null) {
			mySaveRecentBookStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO RecentBooks (book_id) VALUES (?)""
			);
		}
		executeAsATransaction(new Runnable() {
			public void run() {
				myDatabase.delete(""RecentBooks"", null, null);
				for (long id : ids) {
					mySaveRecentBookStatement.bindLong(1, id);
					mySaveRecentBookStatement.execute();
				}
			}
		});
	}

	protected List<Long> loadRecentBookIds() {
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id FROM RecentBooks ORDER BY book_index"", null
		);
		final LinkedList<Long> ids = new LinkedList<Long>();
		while (cursor.moveToNext()) {
			ids.add(cursor.getLong(0));
		}
		cursor.close();
		return ids;
	}

	private SQLiteStatement myAddToFavoritesStatement;
	protected void addToFavorites(long bookId) {
		if (myAddToFavoritesStatement == null) {
			myAddToFavoritesStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO Favorites(book_id) VALUES (?)""
			);
		}
		myAddToFavoritesStatement.bindLong(1, bookId);
		myAddToFavoritesStatement.execute();
	}

	private SQLiteStatement myRemoveFromFavoritesStatement;
	protected void removeFromFavorites(long bookId) {
		if (myRemoveFromFavoritesStatement == null) {
			myRemoveFromFavoritesStatement = myDatabase.compileStatement(
				""DELETE FROM Favorites WHERE book_id = ?""
			);
		}
		myRemoveFromFavoritesStatement.bindLong(1, bookId);
		myRemoveFromFavoritesStatement.execute();
	}

	protected List<Long> loadFavoritesIds() {
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id FROM Favorites"", null
		);
		final LinkedList<Long> ids = new LinkedList<Long>();
		while (cursor.moveToNext()) {
			ids.add(cursor.getLong(0));
		}
		cursor.close();
		return ids;
	}

	@Override
	protected List<Bookmark> loadBookmarks(long bookId, boolean visible) {
		LinkedList<Bookmark> list = new LinkedList<Bookmark>();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT Bookmarks.bookmark_id,Bookmarks.book_id,Books.title,Bookmarks.bookmark_text,Bookmarks.creation_time,Bookmarks.modification_time,Bookmarks.access_time,Bookmarks.access_counter,Bookmarks.model_id,Bookmarks.paragraph,Bookmarks.word,Bookmarks.char FROM Bookmarks INNER JOIN Books ON Books.book_id = Bookmarks.book_id WHERE Bookmarks.book_id = ? AND Bookmarks.visible = ?"", new String[] { """" + bookId, visible ? ""1"" : ""0"" }
		);
		while (cursor.moveToNext()) {
			list.add(createBookmark(
				cursor.getLong(0),
				cursor.getLong(1),
				cursor.getString(2),
				cursor.getString(3),
				getDate(cursor, 4),
				getDate(cursor, 5),
				getDate(cursor, 6),
				(int)cursor.getLong(7),
				cursor.getString(8),
				(int)cursor.getLong(9),
				(int)cursor.getLong(10),
				(int)cursor.getLong(11),
				visible
			));
		}
		cursor.close();
		return list;
	}

	@Override
	protected List<Bookmark> loadAllVisibleBookmarks() {
		LinkedList<Bookmark> list = new LinkedList<Bookmark>();
		myDatabase.execSQL(""DELETE FROM Bookmarks WHERE book_id = -1"");
		Cursor cursor = myDatabase.rawQuery(
			""SELECT Bookmarks.bookmark_id,Bookmarks.book_id,Books.title,Bookmarks.bookmark_text,Bookmarks.creation_time,Bookmarks.modification_time,Bookmarks.access_time,Bookmarks.access_counter,Bookmarks.model_id,Bookmarks.paragraph,Bookmarks.word,Bookmarks.char FROM Bookmarks INNER JOIN Books ON Books.book_id = Bookmarks.book_id WHERE Bookmarks.visible = 1"", null
		);
		while (cursor.moveToNext()) {
			list.add(createBookmark(
				cursor.getLong(0),
				cursor.getLong(1),
				cursor.getString(2),
				cursor.getString(3),
				getDate(cursor, 4),
				getDate(cursor, 5),
				getDate(cursor, 6),
				(int)cursor.getLong(7),
				cursor.getString(8),
				(int)cursor.getLong(9),
				(int)cursor.getLong(10),
				(int)cursor.getLong(11),
				true
			));
		}
		cursor.close();
		return list;
	}

	private SQLiteStatement myInsertBookmarkStatement;
	private SQLiteStatement myUpdateBookmarkStatement;
	@Override
	protected long saveBookmark(Bookmark bookmark) {
		SQLiteStatement statement;
		if (bookmark.getId() == -1) {
			if (myInsertBookmarkStatement == null) {
				myInsertBookmarkStatement = myDatabase.compileStatement(
					""INSERT OR IGNORE INTO Bookmarks (book_id,bookmark_text,creation_time,modification_time,access_time,access_counter,model_id,paragraph,word,char,visible) VALUES (?,?,?,?,?,?,?,?,?,?,?)""
				);
			}
			statement = myInsertBookmarkStatement;
		} else {
			if (myUpdateBookmarkStatement == null) {
				myUpdateBookmarkStatement = myDatabase.compileStatement(
					""UPDATE Bookmarks SET book_id = ?, bookmark_text = ?, creation_time =?, modification_time = ?,access_time = ?, access_counter = ?, model_id = ?, paragraph = ?, word = ?, char = ?, visible = ? WHERE bookmark_id = ?""
				);
			}
			statement = myUpdateBookmarkStatement;
		}

		statement.bindLong(1, bookmark.getBookId());
		statement.bindString(2, bookmark.getText());
		bindDate(statement, 3, bookmark.getTime(Bookmark.CREATION));
		bindDate(statement, 4, bookmark.getTime(Bookmark.MODIFICATION));
		bindDate(statement, 5, bookmark.getTime(Bookmark.ACCESS));
		statement.bindLong(6, bookmark.getAccessCount());
		bindString(statement, 7, bookmark.ModelId);
		statement.bindLong(8, bookmark.ParagraphIndex);
		statement.bindLong(9, bookmark.ElementIndex);
		statement.bindLong(10, bookmark.CharIndex);
		statement.bindLong(11, bookmark.IsVisible ? 1 : 0);

		if (statement == myInsertBookmarkStatement) {
			return statement.executeInsert();
		} else {
			final long id = bookmark.getId();
			statement.bindLong(12, id);
			statement.execute();
			return id;
		}
	}

	private SQLiteStatement myDeleteBookmarkStatement;
	@Override
	protected void deleteBookmark(Bookmark bookmark) {
		if (myDeleteBookmarkStatement == null) {
			myDeleteBookmarkStatement = myDatabase.compileStatement(
				""DELETE FROM Bookmarks WHERE bookmark_id = ?""
			);
		}
		myDeleteBookmarkStatement.bindLong(1, bookmark.getId());
		myDeleteBookmarkStatement.execute();
	}

	protected ZLTextPosition getStoredPosition(long bookId) {
		ZLTextPosition position = null;
		Cursor cursor = myDatabase.rawQuery(
			""SELECT paragraph,word,char FROM BookState WHERE book_id = "" + bookId, null
		);
		if (cursor.moveToNext()) {
			position = new ZLTextFixedPosition(
				(int)cursor.getLong(0),
				(int)cursor.getLong(1),
				(int)cursor.getLong(2)
			);
		}
		cursor.close();
		return position;
	}

	private SQLiteStatement myStorePositionStatement;
	protected void storePosition(long bookId, ZLTextPosition position) {
		if (myStorePositionStatement == null) {
			myStorePositionStatement = myDatabase.compileStatement(
				""INSERT OR REPLACE INTO BookState (book_id,paragraph,word,char) VALUES (?,?,?,?)""
			);
		}
		myStorePositionStatement.bindLong(1, bookId);
		myStorePositionStatement.bindLong(2, position.getParagraphIndex());
		myStorePositionStatement.bindLong(3, position.getElementIndex());
		myStorePositionStatement.bindLong(4, position.getCharIndex());
		myStorePositionStatement.execute();
	}

	private SQLiteStatement myInsertIntoBookListStatement;
	protected boolean insertIntoBookList(long bookId) {
		if (myInsertIntoBookListStatement == null) {
			myInsertIntoBookListStatement = myDatabase.compileStatement(
				""INSERT OR IGNORE INTO BookList(book_id) VALUES (?)""
			);
		}
		myInsertIntoBookListStatement.bindLong(1, bookId);
		myInsertIntoBookListStatement.execute();
		return true;
	}

	private SQLiteStatement myDeleteFromBookListStatement;
	protected boolean deleteFromBookList(long bookId) {
		if (myDeleteFromBookListStatement == null) {
			myDeleteFromBookListStatement = myDatabase.compileStatement(
				""DELETE FROM BookList WHERE book_id = ?""
			);
		}
		myDeleteFromBookListStatement.bindLong(1, bookId);
		myDeleteFromBookListStatement.execute();
		return true;
	}

	private SQLiteStatement myCheckBookListStatement;
	protected boolean checkBookList(long bookId) {
		if (myCheckBookListStatement == null) {
			myCheckBookListStatement = myDatabase.compileStatement(
				""SELECT COUNT(*) FROM BookList WHERE book_id = ?""
			);
		}
		myCheckBookListStatement.bindLong(1, bookId);
		return myCheckBookListStatement.simpleQueryForLong() > 0;
	}


	private void createTables() {
		myDatabase.execSQL(
			""CREATE TABLE Books("" +
				""book_id INTEGER PRIMARY KEY,"" +
				""encoding TEXT,"" +
				""language TEXT,"" +
				""title TEXT NOT NULL,"" +
				""file_name TEXT UNIQUE NOT NULL)"");
		myDatabase.execSQL(
			""CREATE TABLE Authors("" +
				""author_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""sort_key TEXT NOT NULL,"" +
				""CONSTRAINT Authors_Unique UNIQUE (name, sort_key))"");
		myDatabase.execSQL(
			""CREATE TABLE BookAuthor("" +
				""author_id INTEGER NOT NULL REFERENCES Authors(author_id),"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""author_index INTEGER NOT NULL,"" +
				""CONSTRAINT BookAuthor_Unique0 UNIQUE (author_id, book_id),"" +
				""CONSTRAINT BookAuthor_Unique1 UNIQUE (book_id, author_index))"");
		myDatabase.execSQL(
			""CREATE TABLE Series("" +
				""series_id INTEGER PRIMARY KEY,"" +
				""name TEXT UNIQUE NOT NULL)"");
		myDatabase.execSQL(
			""CREATE TABLE BookSeries("" +
				""series_id INTEGER NOT NULL REFERENCES Series(series_id),"" +
				""book_id INTEGER NOT NULL UNIQUE REFERENCES Books(book_id),"" +
				""book_index INTEGER)"");
		myDatabase.execSQL(
			""CREATE TABLE Tags("" +
				""tag_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent INTEGER REFERENCES Tags(tag_id),"" +
				""CONSTRAINT Tags_Unique UNIQUE (name, parent))"");
		myDatabase.execSQL(
			""CREATE TABLE BookTag("" +
				""tag_id INTEGER REFERENCES Tags(tag_id),"" +
				""book_id INTEGER REFERENCES Books(book_id),"" +
				""CONSTRAINT BookTag_Unique UNIQUE (tag_id, book_id))"");
	}

	private void updateTables1() {
		myDatabase.execSQL(""ALTER TABLE Tags RENAME TO Tags_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE Tags("" +
				""tag_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent_id INTEGER REFERENCES Tags(tag_id),"" +
				""CONSTRAINT Tags_Unique UNIQUE (name, parent_id))"");
		myDatabase.execSQL(""INSERT INTO Tags (tag_id,name,parent_id) SELECT tag_id,name,parent FROM Tags_Obsolete"");
		myDatabase.execSQL(""DROP TABLE Tags_Obsolete"");

		myDatabase.execSQL(""ALTER TABLE BookTag RENAME TO BookTag_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE BookTag("" +
				""tag_id INTEGER NOT NULL REFERENCES Tags(tag_id),"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""CONSTRAINT BookTag_Unique UNIQUE (tag_id, book_id))"");
		myDatabase.execSQL(""INSERT INTO BookTag (tag_id,book_id) SELECT tag_id,book_id FROM BookTag_Obsolete"");
		myDatabase.execSQL(""DROP TABLE BookTag_Obsolete"");
	}

	private void updateTables2() {
		myDatabase.execSQL(""CREATE INDEX BookAuthor_BookIndex ON BookAuthor (book_id)"");
		myDatabase.execSQL(""CREATE INDEX BookTag_BookIndex ON BookTag (book_id)"");
		myDatabase.execSQL(""CREATE INDEX BookSeries_BookIndex ON BookSeries (book_id)"");
	}

	private void updateTables3() {
		myDatabase.execSQL(
			""CREATE TABLE Files("" +
				""file_id INTEGER PRIMARY KEY,"" +
				""name TEXT NOT NULL,"" +
				""parent_id INTEGER REFERENCES Files(file_id),"" +
				""size INTEGER,"" +
				""CONSTRAINT Files_Unique UNIQUE (name, parent_id))"");
	}

	private void updateTables4() {
		final FileInfoSet fileInfos = new FileInfoSet();
		final Cursor cursor = myDatabase.rawQuery(
			""SELECT file_name FROM Books"", null
		);
		while (cursor.moveToNext()) {
			fileInfos.check(ZLFile.createFileByPath(cursor.getString(0)).getPhysicalFile(), false);
		}
		cursor.close();
		fileInfos.save();

		myDatabase.execSQL(
			""CREATE TABLE RecentBooks("" +
				""book_index INTEGER PRIMARY KEY,"" +
				""book_id INTEGER REFERENCES Books(book_id))"");
		final ArrayList<Long> ids = new ArrayList<Long>();

		final SQLiteStatement statement = myDatabase.compileStatement(
			""SELECT book_id FROM Books WHERE file_name = ?""
		);

		for (int i = 0; i < 20; ++i) {
			final ZLStringOption option = new ZLStringOption(""LastOpenedBooks"", ""Book"" + i, """");
			final String fileName = option.getValue();
			option.setValue("""");
			try {
				statement.bindString(1, fileName);
				final long bookId = statement.simpleQueryForLong();
				if (bookId != -1) {
					ids.add(bookId);
				}
			} catch (SQLException e) {
			}
		}
		saveRecentBookIds(ids);
	}

	private void updateTables5() {
		myDatabase.execSQL(
			""CREATE TABLE Bookmarks("" +
				""bookmark_id INTEGER PRIMARY KEY,"" +
				""book_id INTEGER NOT NULL REFERENCES Books(book_id),"" +
				""bookmark_text TEXT NOT NULL,"" +
				""creation_time INTEGER NOT NULL,"" +
				""modification_time INTEGER,"" +
				""access_time INTEGER,"" +
				""access_counter INTEGER NOT NULL,"" +
				""paragraph INTEGER NOT NULL,"" +
				""word INTEGER NOT NULL,"" +
				""char INTEGER NOT NULL)"");

		myDatabase.execSQL(
			""CREATE TABLE BookState("" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books(book_id),"" +
				""paragraph INTEGER NOT NULL,"" +
				""word INTEGER NOT NULL,"" +
				""char INTEGER NOT NULL)"");
		Cursor cursor = myDatabase.rawQuery(
			""SELECT book_id,file_name FROM Books"", null
		);
		final SQLiteStatement statement = myDatabase.compileStatement(""INSERT INTO BookState (book_id,paragraph,word,char) VALUES (?,?,?,?)"");
		while (cursor.moveToNext()) {
			final long bookId = cursor.getLong(0);
			final String fileName = cursor.getString(1);
			final int position = new ZLIntegerOption(fileName, ""PositionInBuffer"", 0).getValue();
			final int paragraph = new ZLIntegerOption(fileName, ""Paragraph_"" + position, 0).getValue();
			final int word = new ZLIntegerOption(fileName, ""Word_"" + position, 0).getValue();
			final int chr = new ZLIntegerOption(fileName, ""Char_"" + position, 0).getValue();
			if ((paragraph != 0) || (word != 0) || (chr != 0)) {
				statement.bindLong(1, bookId);
				statement.bindLong(2, paragraph);
				statement.bindLong(3, word);
				statement.bindLong(4, chr);
				statement.execute();
			}
			ZLConfig.Instance().removeGroup(fileName);
		}
		cursor.close();
	}

	private void updateTables6() {
		myDatabase.execSQL(
			""ALTER TABLE Bookmarks ADD COLUMN model_id TEXT""
		);

		myDatabase.execSQL(
			""ALTER TABLE Books ADD COLUMN file_id INTEGER""
		);

		myDatabase.execSQL(""DELETE FROM Files"");
		final FileInfoSet infoSet = new FileInfoSet();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT file_name FROM Books"", null
		);
		while (cursor.moveToNext()) {
			infoSet.check(ZLFile.createFileByPath(cursor.getString(0)).getPhysicalFile(), false);
		}
		cursor.close();
		infoSet.save();

		cursor = myDatabase.rawQuery(
			""SELECT book_id,file_name FROM Books"", null
		);
		final SQLiteStatement deleteStatement = myDatabase.compileStatement(""DELETE FROM Books WHERE book_id = ?"");
		final SQLiteStatement updateStatement = myDatabase.compileStatement(""UPDATE Books SET file_id = ? WHERE book_id = ?"");
		while (cursor.moveToNext()) {
			final long bookId = cursor.getLong(0);
			final long fileId = infoSet.getId(ZLFile.createFileByPath(cursor.getString(1)));

			if (fileId == -1) {
				deleteStatement.bindLong(1, bookId);
				deleteStatement.execute();
			} else {
				updateStatement.bindLong(1, fileId);
				updateStatement.bindLong(2, bookId);
				updateStatement.execute();
			}
		}
		cursor.close();

		myDatabase.execSQL(""ALTER TABLE Books RENAME TO Books_Obsolete"");
		myDatabase.execSQL(
			""CREATE TABLE Books("" +
				""book_id INTEGER PRIMARY KEY,"" +
				""encoding TEXT,"" +
				""language TEXT,"" +
				""title TEXT NOT NULL,"" +
				""file_id INTEGER UNIQUE NOT NULL REFERENCES Files(file_id))"");
		myDatabase.execSQL(""INSERT INTO Books (book_id,encoding,language,title,file_id) SELECT book_id,encoding,language,title,file_id FROM Books_Obsolete"");
		myDatabase.execSQL(""DROP TABLE Books_Obsolete"");
	}

	private void updateTables7() {
		final ArrayList<Long> seriesIDs = new ArrayList<Long>();
		Cursor cursor = myDatabase.rawQuery(
			""SELECT series_id,name FROM Series"", null
		);
		while (cursor.moveToNext()) {
			if (cursor.getString(1).length() > 200) {
				seriesIDs.add(cursor.getLong(0));
			}
		}
		cursor.close();
		if (seriesIDs.isEmpty()) {
			return;
		}

		final ArrayList<Long> bookIDs = new ArrayList<Long>();
		for (Long id : seriesIDs) {
			cursor = myDatabase.rawQuery(
				""SELECT book_id FROM BookSeries WHERE series_id="" + id, null
			);
			while (cursor.moveToNext()) {
				bookIDs.add(cursor.getLong(0));
			}
			cursor.close();
			myDatabase.execSQL(""DELETE FROM BookSeries WHERE series_id="" + id);
			myDatabase.execSQL(""DELETE FROM Series WHERE series_id="" + id);
		}

		for (Long id : bookIDs) {
			myDatabase.execSQL(""DELETE FROM Books WHERE book_id="" + id);
			myDatabase.execSQL(""DELETE FROM BookAuthor WHERE book_id="" + id);
			myDatabase.execSQL(""DELETE FROM BookTag WHERE book_id="" + id);
		}
	}

	private void updateTables8() {
		myDatabase.execSQL(
			""CREATE TABLE IF NOT EXISTS BookList ( "" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books (book_id))"");
	}

	private void updateTables9() {
		myDatabase.execSQL(""CREATE INDEX BookList_BookIndex ON BookList (book_id)"");
	}

	private void updateTables10() {
		myDatabase.execSQL(
			""CREATE TABLE IF NOT EXISTS Favorites("" +
				""book_id INTEGER UNIQUE NOT NULL REFERENCES Books(book_id))"");
	}

	private void updateTables11() {
		myDatabase.execSQL(""UPDATE Files SET size = size + 1"");
	}

	private void updateTables12() {
		myDatabase.execSQL(""DELETE FROM Files WHERE parent_id IN (SELECT file_id FROM Files WHERE name LIKE '%.epub')"");
	}

	private void updateTables13() {
		myDatabase.execSQL(
			""ALTER TABLE Bookmarks ADD COLUMN visible INTEGER DEFAULT 1""
		);
	}
}
",True,186,5,18,7,34,4,16,L6
171,org.geometerplus.android.fbreader.ShowPreferencesAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

import org.geometerplus.android.fbreader.preferences.PreferenceActivity;

class ShowPreferencesAction extends FBAction {
	private final FBReader myBaseActivity;

	ShowPreferencesAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(fbreader);
		myBaseActivity = baseActivity;
	}

	public void run() {
		myBaseActivity.startActivityForResult(
			new Intent(myBaseActivity.getApplicationContext(), PreferenceActivity.class),
			FBReader.REPAINT_CODE
		);
	}
}
",False,377,0,0,9,96,1,4,L6
172,org.geometerplus.android.fbreader.TOCActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.Bundle;
import android.view.*;
import android.widget.*;
import android.app.ListActivity;

import org.geometerplus.zlibrary.core.application.ZLApplication;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;
import org.geometerplus.fbreader.bookmodel.TOCTree;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

public class TOCActivity extends ListActivity {
	private TOCAdapter myAdapter;
	private ZLTree<?> mySelectedItem;

	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		requestWindowFeature(Window.FEATURE_NO_TITLE);

		final FBReaderApp fbreader = (FBReaderApp)ZLApplication.Instance();
		final TOCTree root = fbreader.Model.TOCTree;
		myAdapter = new TOCAdapter(root);
		final ZLTextWordCursor cursor = fbreader.BookTextView.getStartCursor();
		int index = cursor.getParagraphIndex();	
		if (cursor.isEndOfParagraph()) {
			++index;
		}
		TOCTree treeToSelect = null;
		// TODO: process multi-model texts
		for (TOCTree tree : root) {
			final TOCTree.Reference reference = tree.getReference();
			if (reference == null) {
				continue;
			}
			if (reference.ParagraphIndex > index) {
				break;
			}
			treeToSelect = tree;
		}
		myAdapter.selectItem(treeToSelect);
		mySelectedItem = treeToSelect;
	}

	private static final int PROCESS_TREE_ITEM_ID = 0;
	private static final int READ_BOOK_ITEM_ID = 1;

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final TOCTree tree = (TOCTree)myAdapter.getItem(position);
		switch (item.getItemId()) {
			case PROCESS_TREE_ITEM_ID:
				myAdapter.runTreeItem(tree);
				return true;
			case READ_BOOK_ITEM_ID:
				myAdapter.openBookText(tree);
				return true;
		}
		return super.onContextItemSelected(item);
	}

	private final class TOCAdapter extends ZLTreeAdapter {
		TOCAdapter(TOCTree root) {
			super(getListView(), root);
		}

		@Override
		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final TOCTree tree = (TOCTree)getItem(position);
			if (tree.hasChildren()) {
				menu.setHeaderTitle(tree.getText());
				final ZLResource resource = ZLResource.resource(""tocView"");
				menu.add(0, PROCESS_TREE_ITEM_ID, 0, resource.getResource(isOpen(tree) ? ""collapseTree"" : ""expandTree"").getValue());
				menu.add(0, READ_BOOK_ITEM_ID, 0, resource.getResource(""readText"").getValue());
			}
		}

		@Override
		public View getView(int position, View convertView, ViewGroup parent) {
			final View view = (convertView != null) ? convertView :
				LayoutInflater.from(parent.getContext()).inflate(R.layout.toc_tree_item, parent, false);
			final TOCTree tree = (TOCTree)getItem(position);
			view.setBackgroundColor((tree == mySelectedItem) ? 0xff808080 : 0);
			setIcon((ImageView)view.findViewById(R.id.toc_tree_item_icon), tree);
			((TextView)view.findViewById(R.id.toc_tree_item_text)).setText(tree.getText());
			return view;
		}

		void openBookText(TOCTree tree) {
			final TOCTree.Reference reference = tree.getReference();
			if (reference != null) {
				finish();
				final FBReaderApp fbreader = (FBReaderApp)ZLApplication.Instance();
				fbreader.addInvisibleBookmark();
				fbreader.BookTextView.gotoPosition(reference.ParagraphIndex, 0, 0);
				fbreader.showBookTextView();
			}
		}

		@Override
		protected boolean runTreeItem(ZLTree<?> tree) {
			if (super.runTreeItem(tree)) {
				return true;
			}
			openBookText((TOCTree)tree);
			return true;
		}
	}
}
",False,208,0,0,6,62,0,10,L7
173,org.geometerplus.android.fbreader.ShowNetworkLibraryAction.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

import org.geometerplus.android.fbreader.network.NetworkLibraryActivity;

class ShowNetworkLibraryAction extends RunActivityAction {
	ShowNetworkLibraryAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader, NetworkLibraryActivity.class);
	}
}
",False,377,0,0,8,123,1,4,L6
174,org.geometerplus.android.fbreader.ShowLibraryAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.bookmodel.BookModel;

import org.geometerplus.android.fbreader.library.LibraryTopLevelActivity;

class ShowLibraryAction extends FBAction {
	private final FBReader myBaseActivity;

	ShowLibraryAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(fbreader);
		myBaseActivity = baseActivity;
	}

	public void run() {
		final BookModel model = Reader.Model;
		Intent intent = new Intent(myBaseActivity.getApplicationContext(), LibraryTopLevelActivity.class);
		if (model != null && model.Book != null) {
			intent.putExtra(LibraryTopLevelActivity.SELECTED_BOOK_PATH_KEY, model.Book.File.getPath());
		}
		myBaseActivity.startActivity(intent);
	}
}
",False,377,0,0,9,85,1,8,L6
175,org.geometerplus.android.fbreader.ControlButtonPanel.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.view.View;
import android.view.ViewGroup;
import android.widget.RelativeLayout;

import org.geometerplus.zlibrary.core.application.ZLApplication;

import org.geometerplus.zlibrary.text.view.ZLTextWordCursor;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

abstract class ControlButtonPanel implements ZLApplication.ButtonPanel {
	public final FBReaderApp Reader;
	public ZLTextWordCursor StartPosition;

	private boolean myVisible;

	protected ControlPanel myControlPanel;

	ControlButtonPanel(FBReaderApp fbReader) {
		Reader = fbReader;
		fbReader.registerButtonPanel(this);
	}

	public final void hide() {
		hide(false);
	}

	public void updateStates() {
	}

	public final boolean hasControlPanel() {
		return myControlPanel != null;
	}

	private final void removeControlPanel() {
		if (myControlPanel != null) {
			ViewGroup root = (ViewGroup)myControlPanel.getParent();
			myControlPanel.hide(false);
			root.removeView(myControlPanel);
			myControlPanel = null;
		}
	}

	public static void removeControlPanels(ZLApplication application) {
		for (ZLApplication.ButtonPanel panel : application.buttonPanels()) {
			((ControlButtonPanel)panel).removeControlPanel();
		}
	}

	public static void restoreVisibilities(ZLApplication application) {
		for (ZLApplication.ButtonPanel panel : application.buttonPanels()) {
			final ControlButtonPanel p = (ControlButtonPanel)panel;
			p.setVisibility(p.myVisible);
		}
	}

	public static void saveVisibilities(ZLApplication application) {
		for (ZLApplication.ButtonPanel panel : application.buttonPanels()) {
			final ControlButtonPanel p = (ControlButtonPanel)panel;
			p.myVisible = p.getVisibility();
		}
	}

	public static void hideAllPendingNotify(ZLApplication application) {
		for (ZLApplication.ButtonPanel panel : application.buttonPanels()) {
			final ControlButtonPanel p = (ControlButtonPanel)panel;
			if (p.myControlPanel != null && p.getVisibility()) {
				p.myControlPanel.hide(false);
			}
		}
	}

	public final boolean getVisibility() {
		if (myControlPanel != null) {
			return myControlPanel.getVisibility() == View.VISIBLE;
		}
		return false;
	}

	private void setVisibility(boolean visible) {
		if (visible) {
			show(false);
		} else {
			hide(false);
		}
	}

	private void hideOthers() {
		for (ZLApplication.ButtonPanel panel : Reader.buttonPanels()) {
			if (panel != this) {
				((ControlButtonPanel)panel).hide(false);
			}
		}
	}

	public final void show(boolean animate) {
		if (myControlPanel != null && !getVisibility()) {
			hideOthers();
			onShow();
			myControlPanel.show(animate);
		}
	}

	public final void initPosition() {
		if (StartPosition == null) {
			StartPosition = new ZLTextWordCursor(Reader.getTextView().getStartCursor());
		}
	}

	public final void storePosition() {
		if (StartPosition != null &&
			!StartPosition.equals(Reader.getTextView().getStartCursor())) {
			Reader.addInvisibleBookmark(StartPosition);
		}
	}

	public final void hide(boolean animate) {
		if (myControlPanel != null && getVisibility()) {
			onHide();
			myControlPanel.hide(animate);
		}
	}

	public abstract void createControlPanel(FBReader activity, RelativeLayout root);

	// callback methods
	public void onShow() {}
	public void onHide() {}
}
",False,377,0,0,9,78,3,7,L6
176,org.geometerplus.android.fbreader.BookmarksActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.app.*;
import android.os.*;
import android.view.*;
import android.widget.*;
import android.content.*;

import org.geometerplus.zlibrary.core.util.ZLMiscUtil;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.library.*;

import org.geometerplus.android.util.UIUtil;

public class BookmarksActivity extends TabActivity implements MenuItem.OnMenuItemClickListener {
	private static final int OPEN_ITEM_ID = 0;
	private static final int EDIT_ITEM_ID = 1;
	private static final int DELETE_ITEM_ID = 2;

	List<Bookmark> AllBooksBookmarks;
	private final List<Bookmark> myThisBookBookmarks = new LinkedList<Bookmark>();
	private final List<Bookmark> mySearchResults = new LinkedList<Bookmark>();

	private ListView myThisBookView;
	private ListView myAllBooksView;
	private ListView mySearchResultsView;

	private final ZLResource myResource = ZLResource.resource(""bookmarksView"");
	private final ZLStringOption myBookmarkSearchPatternOption =
		new ZLStringOption(""BookmarkSearch"", ""Pattern"", """");

	private ListView createTab(String tag, int id) {
		final TabHost host = getTabHost();
		final String label = myResource.getResource(tag).getValue();
		host.addTab(host.newTabSpec(tag).setIndicator(label).setContent(id));
		return (ListView)findViewById(id);
	}

	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);

		final SearchManager manager = (SearchManager)getSystemService(SEARCH_SERVICE);
		manager.setOnCancelListener(null);

		final TabHost host = getTabHost();
		LayoutInflater.from(this).inflate(R.layout.bookmarks, host.getTabContentView(), true);

		AllBooksBookmarks = Bookmark.bookmarks();
		Collections.sort(AllBooksBookmarks, new Bookmark.ByTimeComparator());
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();

		if (fbreader.Model != null) {
			final long bookId = fbreader.Model.Book.getId();
			for (Bookmark bookmark : AllBooksBookmarks) {
				if (bookmark.getBookId() == bookId) {
					myThisBookBookmarks.add(bookmark);
				}
			}
        
			myThisBookView = createTab(""thisBook"", R.id.this_book);
			new BookmarksAdapter(myThisBookView, myThisBookBookmarks, true);
		} else {
			findViewById(R.id.this_book).setVisibility(View.GONE);
		}

		myAllBooksView = createTab(""allBooks"", R.id.all_books);
		new BookmarksAdapter(myAllBooksView, AllBooksBookmarks, false);

		findViewById(R.id.search_results).setVisibility(View.GONE);
	}

	@Override
	protected void onNewIntent(Intent intent) {
		if (!Intent.ACTION_SEARCH.equals(intent.getAction())) {
			return;
		}
	   	String pattern = intent.getStringExtra(SearchManager.QUERY);
		myBookmarkSearchPatternOption.setValue(pattern);

		final LinkedList<Bookmark> bookmarks = new LinkedList<Bookmark>();
		pattern = pattern.toLowerCase();
		for (Bookmark b : AllBooksBookmarks) {
			if (ZLMiscUtil.matchesIgnoreCase(b.getText(), pattern)) {
				bookmarks.add(b);
			}
		}
		if (!bookmarks.isEmpty()) {
			showSearchResultsTab(bookmarks);
		} else {
			UIUtil.showErrorMessage(this, ""bookmarkNotFound"");
		}
	}

	@Override
	public void onPause() {
		for (Bookmark bookmark : AllBooksBookmarks) {
			bookmark.save();
		}
		super.onPause();
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		final MenuItem item = menu.add(
			0, 1, Menu.NONE,
			myResource.getResource(""menu"").getResource(""search"").getValue()
		);
		item.setOnMenuItemClickListener(this);
		item.setIcon(R.drawable.ic_menu_search);
		return true;
	}

	@Override
	public boolean onSearchRequested() {
		startSearch(myBookmarkSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	void showSearchResultsTab(LinkedList<Bookmark> results) {
		if (mySearchResultsView == null) {
			mySearchResultsView = createTab(""searchResults"", R.id.search_results);
			new BookmarksAdapter(mySearchResultsView, mySearchResults, false);
		} else {
			mySearchResults.clear();
		}
		mySearchResults.addAll(results);
		mySearchResultsView.invalidateViews();
		mySearchResultsView.requestLayout();
		getTabHost().setCurrentTabByTag(""searchResults"");
	}

	public boolean onMenuItemClick(MenuItem item) {
		switch (item.getItemId()) {
			case 1:
				return onSearchRequested();
			default:
				return true;
		}
	}

	private void invalidateAllViews() {
		myThisBookView.invalidateViews();
		myThisBookView.requestLayout();
		myAllBooksView.invalidateViews();
		myAllBooksView.requestLayout();
		if (mySearchResultsView != null) {
			mySearchResultsView.invalidateViews();
			mySearchResultsView.requestLayout();
		}
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final ListView view = (ListView)getTabHost().getCurrentView();
		final Bookmark bookmark = ((BookmarksAdapter)view.getAdapter()).getItem(position);
		switch (item.getItemId()) {
			case OPEN_ITEM_ID:
				gotoBookmark(bookmark);
				return true;
			case EDIT_ITEM_ID:
        		final Intent intent = new Intent(this, BookmarkEditActivity.class);
        		startActivityForResult(intent, 1);
				// TODO: implement
				return true;
			case DELETE_ITEM_ID:
				bookmark.delete();
				myThisBookBookmarks.remove(bookmark);
				AllBooksBookmarks.remove(bookmark);
				mySearchResults.remove(bookmark);
				invalidateAllViews();
				return true;
		}
		return super.onContextItemSelected(item);
	}

	private void addBookmark() {
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		final Bookmark bookmark = fbreader.addBookmark(20, true);
		if (bookmark != null) {
			myThisBookBookmarks.add(0, bookmark);
			AllBooksBookmarks.add(0, bookmark);
			invalidateAllViews();
		}
	}

	private void gotoBookmark(Bookmark bookmark) {
		bookmark.onOpen();
		final FBReaderApp fbreader = (FBReaderApp)FBReaderApp.Instance();
		final long bookId = bookmark.getBookId();
		if ((fbreader.Model == null) || (fbreader.Model.Book.getId() != bookId)) {
			final Book book = Book.getById(bookId);
			if (book != null) {
				finish();
				fbreader.openBook(book, bookmark);
			} else {
				Toast.makeText(
					this,
					ZLResource.resource(""errorMessage"").getResource(""cannotOpenBook"").getValue(),
					Toast.LENGTH_SHORT
				).show();
			}
		} else {
			finish();
			fbreader.gotoBookmark(bookmark);
		}
	}

	private final class BookmarksAdapter extends BaseAdapter implements AdapterView.OnItemClickListener, View.OnCreateContextMenuListener {
		private final List<Bookmark> myBookmarks;
		private final boolean myCurrentBook;

		BookmarksAdapter(ListView listView, List<Bookmark> bookmarks, boolean currentBook) {
			myBookmarks = bookmarks;
			myCurrentBook = currentBook;
			listView.setAdapter(this);
			listView.setOnItemClickListener(this);
			listView.setOnCreateContextMenuListener(this);
		}

		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			if (getItem(position) != null) {
				menu.setHeaderTitle(getItem(position).getText());
				final ZLResource resource = ZLResource.resource(""bookmarksView"");
				menu.add(0, OPEN_ITEM_ID, 0, resource.getResource(""open"").getValue());
				//menu.add(0, EDIT_ITEM_ID, 0, resource.getResource(""edit"").getValue());
				menu.add(0, DELETE_ITEM_ID, 0, resource.getResource(""delete"").getValue());
			}
		}

		public View getView(int position, View convertView, ViewGroup parent) {
			final View view = (convertView != null) ? convertView :
				LayoutInflater.from(parent.getContext()).inflate(R.layout.bookmark_item, parent, false);
			final ImageView imageView = (ImageView)view.findViewById(R.id.bookmark_item_icon);
			final TextView textView = (TextView)view.findViewById(R.id.bookmark_item_text);
			final TextView bookTitleView = (TextView)view.findViewById(R.id.bookmark_item_booktitle);

			final Bookmark bookmark = getItem(position);
			if (bookmark == null) {
				imageView.setVisibility(View.VISIBLE);
				imageView.setImageResource(R.drawable.ic_list_plus);
				textView.setText(ZLResource.resource(""bookmarksView"").getResource(""new"").getValue());
				bookTitleView.setVisibility(View.GONE);
			} else {
				imageView.setVisibility(View.GONE);
				textView.setText(bookmark.getText());
				if (myCurrentBook) {
					bookTitleView.setVisibility(View.GONE);
				} else {
					bookTitleView.setVisibility(View.VISIBLE);
					bookTitleView.setText(bookmark.getBookTitle());
				}
			}
			return view;
		}

		public final boolean areAllItemsEnabled() {
			return true;
		}

		public final boolean isEnabled(int position) {
			return true;
		}

		public final long getItemId(int position) {
			return position;
		}
	
		public final Bookmark getItem(int position) {
			if (myCurrentBook) {
				--position;
			}
			return (position >= 0) ? myBookmarks.get(position) : null;
		}

		public final int getCount() {
			return myCurrentBook ? myBookmarks.size() + 1 : myBookmarks.size();
		}

		public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
			final Bookmark bookmark = getItem(position);
			if (bookmark != null) {
				gotoBookmark(bookmark);
			} else {
				addBookmark();
			}
		}
	}
}
",True,208,0,0,6,58,0,10,L7
177,org.geometerplus.android.fbreader.ShowMenuAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowMenuAction extends FBAction {
	private final FBReader myActivity;

	ShowMenuAction(FBReader activity, FBReaderApp fbreader) {
		super(fbreader);
		myActivity = activity;
	}

	public void run() {
		myActivity.openOptionsMenu();
	}
}
",False,377,0,0,9,91,1,3,L6
178,org.geometerplus.android.fbreader.CancelActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.app.ListActivity;
import android.content.Intent;
import android.os.Bundle;
import android.widget.*;
import android.view.*;

import org.geometerplus.zlibrary.ui.android.R;

public class CancelActivity extends ListActivity {
	static final String LIST_SIZE = ""listSize"";
	static final String ITEM_TITLE = ""title"";
	static final String ITEM_SUMMARY = ""summary"";

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		final ActionListAdapter adapter = new ActionListAdapter(getIntent());
		setListAdapter(adapter);
		getListView().setOnItemClickListener(adapter);
		setResult(-1);
	}

	private class ActionListAdapter extends BaseAdapter implements AdapterView.OnItemClickListener {
		private final Intent myIntent;

		ActionListAdapter(Intent intent) {
			myIntent = intent;
		}

		@Override
		public final int getCount() {
			return myIntent.getIntExtra(LIST_SIZE, 0);
		}

		@Override
		public final Integer getItem(int position) {
			return position;
		}

		@Override
		public final long getItemId(int position) {
			return position;
		}

		@Override
		public View getView(int position, View convertView, final ViewGroup parent) {
			final View view = convertView != null
				? convertView
				: LayoutInflater.from(parent.getContext()).inflate(R.layout.cancel_item, parent, false);
			final TextView titleView = (TextView)view.findViewById(R.id.cancel_item_title);
			final TextView summaryView = (TextView)view.findViewById(R.id.cancel_item_summary);
			final String title = myIntent.getStringExtra(ITEM_TITLE + position);
			final String summary = myIntent.getStringExtra(ITEM_SUMMARY + position);
			titleView.setText(title);
			if (summary != null) {
				summaryView.setVisibility(View.VISIBLE);
				summaryView.setText(summary);
        		titleView.setLayoutParams(new LinearLayout.LayoutParams(
					LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.WRAP_CONTENT
				));
			} else {
				summaryView.setVisibility(View.GONE);
        		titleView.setLayoutParams(new LinearLayout.LayoutParams(
					LinearLayout.LayoutParams.FILL_PARENT, LinearLayout.LayoutParams.FILL_PARENT
				));
			}
			return view;
		}

		public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
			setResult((int)id);
			finish();
		}
	}
}
",False,45,6,18,0,0,1,0,L6
179,org.geometerplus.android.fbreader.SearchAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.fbreader.FBAction;

class SearchAction extends FBAction {
	private final FBReader myActivity;

	SearchAction(FBReader activity, FBReaderApp fbreader) {
		super(fbreader);
		myActivity = activity;
	}

	public boolean isVisible() {
		return Reader.Model != null;
	}

	public void run() {
		myActivity.onSearchRequested();
	}
}
",False,377,0,0,9,91,1,3,L6
180,org.geometerplus.android.fbreader.DictionaryUtil.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.*;

import android.app.*;
import android.content.*;
import android.net.Uri;
import android.util.DisplayMetrics;
import android.view.Gravity;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.xml.ZLXMLReaderAdapter;
import org.geometerplus.zlibrary.core.xml.ZLStringMap;

import org.geometerplus.zlibrary.text.view.ZLTextWordRegion;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.util.PackageUtil;

public abstract class DictionaryUtil {
	// Map: dictionary info -> hide if package is not installed
	private static LinkedHashMap<PackageInfo,Boolean> ourDictionaryInfos =
		new LinkedHashMap<PackageInfo,Boolean>();
	private static ZLStringOption ourDictionaryOption;

	private static class InfoReader extends ZLXMLReaderAdapter {
		@Override
		public boolean dontCacheAttributeValues() {
			return true;
		}

		@Override
		public boolean startElementHandler(String tag, ZLStringMap attributes) {
			if (""dictionary"".equals(tag)) {
				final String id = attributes.getValue(""id"");
				final String title = attributes.getValue(""title"");
				ourDictionaryInfos.put(new PackageInfo(
					id,
					attributes.getValue(""package""),
					attributes.getValue(""class""),
					title != null ? title : id,
					attributes.getValue(""action""),
					attributes.getValue(""dataKey""),
					attributes.getValue(""pattern"")
				), !""always"".equals(attributes.getValue(""list"")));
			}
			return false;
		}
	}

	private interface ColorDict3 {
		String ACTION = ""colordict.intent.action.SEARCH"";
		String QUERY = ""EXTRA_QUERY"";
		String HEIGHT = ""EXTRA_HEIGHT"";
		String WIDTH = ""EXTRA_WIDTH"";
		String GRAVITY = ""EXTRA_GRAVITY"";
		String MARGIN_LEFT = ""EXTRA_MARGIN_LEFT"";
		String MARGIN_TOP = ""EXTRA_MARGIN_TOP"";
		String MARGIN_BOTTOM = ""EXTRA_MARGIN_BOTTOM"";
		String MARGIN_RIGHT = ""EXTRA_MARGIN_RIGHT"";
		String FULLSCREEN = ""EXTRA_FULLSCREEN"";
	}

	private static Map<PackageInfo,Boolean> infos() {
		if (ourDictionaryInfos.isEmpty()) {
			new InfoReader().read(ZLFile.createFileByPath(""dictionaries.xml""));
		}
		return ourDictionaryInfos;
	}

	public static List<PackageInfo> dictionaryInfos(Context context) {
		final LinkedList<PackageInfo> list = new LinkedList<PackageInfo>();
		for (Map.Entry<PackageInfo,Boolean> entry : infos().entrySet()) {
			final PackageInfo info = entry.getKey();
			if (!entry.getValue() ||
				PackageUtil.canBeStarted(context, getDictionaryIntent(info, ""test""))) {
				list.add(info);
			}
		}
		return list;
	}

	private static PackageInfo firstInfo() {
		for (Map.Entry<PackageInfo,Boolean> entry : infos().entrySet()) {
			if (!entry.getValue()) {
				return entry.getKey();
			}
		}
		throw new RuntimeException(""There are no available dictionary infos"");
	}

	public static ZLStringOption dictionaryOption() {
		if (ourDictionaryOption == null) {
			ourDictionaryOption = new ZLStringOption(""Dictionary"", ""Id"", firstInfo().Id);
		}
		return ourDictionaryOption;
	}

	private static PackageInfo getCurrentDictionaryInfo() {
		final String id = dictionaryOption().getValue();
		for (PackageInfo info : infos().keySet()) {
			if (info.Id.equals(id)) {
				return info;
			}
		}
		return firstInfo();
	}

	private static Intent getDictionaryIntent(String text) {
		return getDictionaryIntent(getCurrentDictionaryInfo(), text);
	}

	public static Intent getDictionaryIntent(PackageInfo dictionaryInfo, String text) {
		final Intent intent = new Intent(dictionaryInfo.IntentAction);
		if (dictionaryInfo.PackageName != null) {
			String cls = dictionaryInfo.ClassName;
			if (cls != null && cls.startsWith(""."")) {
				cls = dictionaryInfo.PackageName + cls;
			}
			intent.setComponent(new ComponentName(
				dictionaryInfo.PackageName, cls
			));
		}
		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
		text = dictionaryInfo.IntentDataPattern.replace(""%s"", text);
		if (dictionaryInfo.IntentKey != null) {
			return intent.putExtra(dictionaryInfo.IntentKey, text);
		} else {
			return intent.setData(Uri.parse(text));
		}			
	}

	public static void openWordInDictionary(Activity activity, ZLTextWordRegion region) { 
		String text = region.Word.toString();
		int start = 0;
		int end = text.length();
		for (; start < end && !Character.isLetterOrDigit(text.charAt(start)); ++start);
		for (; start < end && !Character.isLetterOrDigit(text.charAt(end - 1)); --end);
		if (start == end) {
			return;
		}

		final PackageInfo info = getCurrentDictionaryInfo();
		final Intent intent = getDictionaryIntent(info, text.substring(start, end));
		try {
			if (""ColorDict"".equals(info.Id)) {
				final DisplayMetrics metrics = new DisplayMetrics();
				activity.getWindowManager().getDefaultDisplay().getMetrics(metrics);
				final int screenHeight = metrics.heightPixels;
				final int topSpace = region.getTop();
				final int bottomSpace = metrics.heightPixels - region.getBottom();
				final boolean showAtBottom = bottomSpace >= topSpace;
				final int space = (showAtBottom ? bottomSpace : topSpace) - 20;
				final int maxHeight = Math.min(400, screenHeight * 2 / 3);
				final int minHeight = Math.min(200, screenHeight * 2 / 3);
				intent.putExtra(ColorDict3.HEIGHT, Math.max(minHeight, Math.min(maxHeight, space)));
				intent.putExtra(ColorDict3.GRAVITY, showAtBottom ? Gravity.BOTTOM : Gravity.TOP);
				final ZLAndroidApplication application = ZLAndroidApplication.Instance();
				intent.putExtra(ColorDict3.FULLSCREEN, !application.ShowStatusBarOption.getValue());
			}
			activity.startActivity(intent);
		} catch(ActivityNotFoundException e){
			DictionaryUtil.installDictionaryIfNotInstalled(activity);
		}
	}

	public static void installDictionaryIfNotInstalled(final Activity activity) {
		if (PackageUtil.canBeStarted(activity, getDictionaryIntent(""test""))) {
			return;
		}
		final PackageInfo dictionaryInfo = getCurrentDictionaryInfo();

		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource installResource = dialogResource.getResource(""installDictionary"");
		new AlertDialog.Builder(activity)
			.setTitle(installResource.getResource(""title"").getValue())
			.setMessage(installResource.getResource(""message"").getValue().replace(""%s"", dictionaryInfo.Title))
			.setIcon(0)
			.setPositiveButton(
				buttonResource.getResource(""install"").getValue(),
				new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface dialog, int which) {
						installDictionary(activity, dictionaryInfo);
					}
				}
			)
			.setNegativeButton(buttonResource.getResource(""skip"").getValue(), null)
			.create().show();
	}

	private static void installDictionary(Activity activity, PackageInfo dictionaryInfo) {
		if (!PackageUtil.installFromMarket(activity, dictionaryInfo.PackageName)) {
			UIUtil.showErrorMessage(activity, ""cannotRunAndroidMarket"", dictionaryInfo.Title);
		}
	}
}
",False,132,6,18,7,25,2,13,L6
181,org.geometerplus.android.fbreader.ShowBookInfoAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowBookInfoAction extends FBAction {
	private final FBReader myBaseActivity;

	ShowBookInfoAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(fbreader);
		myBaseActivity = baseActivity;
	}

	public boolean isVisible() {
		return Reader.Model != null;
	}

	public void run() {
		myBaseActivity.startActivityForResult(
			new Intent(myBaseActivity.getApplicationContext(), BookInfoActivity.class)
				.putExtra(BookInfoActivity.CURRENT_BOOK_PATH_KEY, Reader.Model.Book.File.getPath())
				.putExtra(BookInfoActivity.HIDE_OPEN_BUTTON_KEY, true),
			FBReader.REPAINT_CODE
		);
	}
}
",False,377,0,0,9,89,1,7,L6
182,org.geometerplus.android.fbreader.BookmarkEditActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.os.Bundle;
import android.app.Activity;
import android.view.*;
import android.widget.*;
import android.content.Context;


class SimpleContainer extends ViewGroup {
	private final View myEditText;
	private final Button myOkButton;
	private final Button myCancelButton;

	SimpleContainer(Context context) {
		super(context);
		myEditText = new EditText(context);
		myOkButton = new Button(context);
		myOkButton.setText(""ok"");
		myCancelButton = new Button(context);
		myCancelButton.setText(""cancel"");
		addView(myOkButton);
		addView(myCancelButton);
		addView(myEditText);
	}

	protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
		final int buttonHeight = Math.max(54, Math.max(myOkButton.getHeight(), myCancelButton.getHeight()));
		myEditText.layout(left + 8, top + 8, right - 8, bottom - buttonHeight - 16);
		myOkButton.layout(left + 8, bottom - buttonHeight - 8, (left + right) / 2 - 4, bottom - 8);
		myCancelButton.layout((left + right) / 2 + 4, bottom - buttonHeight - 8, right - 8, bottom - 8);
	}
}

public class BookmarkEditActivity extends Activity {
	@Override
	public void onCreate(Bundle bundle) {
		super.onCreate(bundle);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		final SimpleContainer container = new SimpleContainer(this);
		setContentView(container);
	}
}
",False,1,0,0,0,0,0,0,I0
183,org.geometerplus.android.fbreader.ShowBookmarksAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowBookmarksAction extends RunActivityAction {
	ShowBookmarksAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader, BookmarksActivity.class);
	}
}
",False,377,0,0,9,90,1,3,L6
184,org.geometerplus.android.fbreader.ProcessHyperlinkAction.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import android.content.Intent;
import android.content.ActivityNotFoundException;
import android.net.Uri;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.zlibrary.text.view.*;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;
import org.geometerplus.fbreader.bookmodel.FBHyperlinkType;
import org.geometerplus.fbreader.network.NetworkLibrary;

import org.geometerplus.android.fbreader.network.BookDownloader;
import org.geometerplus.android.fbreader.network.BookDownloaderService;
import org.geometerplus.android.fbreader.image.ImageViewActivity;

class ProcessHyperlinkAction extends FBAction {
	private final FBReader myBaseActivity;

	ProcessHyperlinkAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(fbreader);
		myBaseActivity = baseActivity;
	}

	public boolean isEnabled() {
		return Reader.getTextView().getSelectedRegion() != null;
	}

	public void run() {
		final ZLTextElementRegion region = Reader.getTextView().getSelectedRegion();
		if (region instanceof ZLTextHyperlinkRegion) {
			final ZLTextHyperlink hyperlink = ((ZLTextHyperlinkRegion)region).Hyperlink;
			switch (hyperlink.Type) {
				case FBHyperlinkType.EXTERNAL:
					openInBrowser(hyperlink.Id);
					break;
				case FBHyperlinkType.INTERNAL:
					Reader.tryOpenFootnote(hyperlink.Id);
					break;
			}
			return;
		} else if (region instanceof ZLTextImageRegion) {
			final String uriString = ((ZLTextImageRegion)region).ImageElement.URI;
			if (uriString != null) {
				try {
					final Intent intent = new Intent();
					intent.setClass(myBaseActivity, ImageViewActivity.class);
					intent.setData(Uri.parse(uriString));
					myBaseActivity.startActivity(intent);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		} else if (region instanceof ZLTextWordRegion) {
			DictionaryUtil.openWordInDictionary(
				myBaseActivity, (ZLTextWordRegion)region
			);
		}
	}

	private void openInBrowser(String urlString) {
		final Intent intent = new Intent(Intent.ACTION_VIEW);
		boolean externalUrl = true;
		if (BookDownloader.acceptsUri(Uri.parse(urlString))) {
			intent.setClass(myBaseActivity, BookDownloader.class);
			intent.putExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY, BookDownloaderService.Notifications.ALL);
			externalUrl = false;
		}
		final NetworkLibrary nLibrary = NetworkLibrary.Instance();
		try {
			nLibrary.initialize();
		} catch (ZLNetworkException e) {
		}
		intent.setData(Uri.parse(NetworkLibrary.Instance().rewriteUrl(urlString, externalUrl)));
		try {
			myBaseActivity.startActivity(intent);
		} catch (ActivityNotFoundException e) {
			// TODO: show an error message
		}
	}
}
",True,377,0,0,7,100,1,18,L6
185,org.geometerplus.android.fbreader.CancelAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.List;

import android.content.Intent;

import org.geometerplus.fbreader.fbreader.FBAction;
import org.geometerplus.fbreader.fbreader.FBReaderApp;

class CancelAction extends FBAction {
	private final FBReader myBaseActivity;

	CancelAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(fbreader);
		myBaseActivity = baseActivity;
	}

	public void run() {
		if (Reader.getCurrentView() != Reader.BookTextView) {
			Reader.showBookTextView();
		} else {
			final List<FBReaderApp.CancelActionDescription> descriptionList =
				Reader.getCancelActionsList();
			if (descriptionList.size() == 1) {
				Reader.closeWindow();
			} else {
				final Intent intent = new Intent();
				intent.setClass(myBaseActivity, CancelActivity.class);
				intent.putExtra(CancelActivity.LIST_SIZE, descriptionList.size());
				int index = 0;
				for (FBReaderApp.CancelActionDescription description : descriptionList) {
					intent.putExtra(CancelActivity.ITEM_TITLE + index, description.Title);
					intent.putExtra(CancelActivity.ITEM_SUMMARY + index, description.Summary);
					++index;
				}
				myBaseActivity.startActivityForResult(intent, FBReader.CANCEL_CODE);
			}
		}
	}
}
",False,377,0,0,9,89,1,5,L6
186,org.geometerplus.android.fbreader.ZLTreeAdapter.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import java.util.HashSet;

import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.tree.ZLTree;

import org.geometerplus.zlibrary.ui.android.R;

abstract class ZLTreeAdapter extends BaseAdapter implements AdapterView.OnItemClickListener, View.OnCreateContextMenuListener {
	private final ListView myParent;
	private ZLTree<?> myTree;
	private ZLTree<?>[] myItems;
	private final HashSet<ZLTree<?>> myOpenItems = new HashSet<ZLTree<?>>();

	protected ZLTreeAdapter(ListView parent, ZLTree<?> tree) {
		myParent = parent;
		myTree = tree;
		myItems = new ZLTree[tree.getSize() - 1];
		myOpenItems.add(tree);

		parent.setAdapter(this);
		parent.setOnItemClickListener(this);
		parent.setOnCreateContextMenuListener(this);
	}

	protected final void openTree(ZLTree<?> tree) {
		if (tree == null) {
			return;
		}
		while (!myOpenItems.contains(tree)) {
			myOpenItems.add(tree);
			tree = tree.Parent;
		}
	}

	public final void expandOrCollapseTree(ZLTree<?> tree) {
		if (!tree.hasChildren()) {
			return;
		}
		if (isOpen(tree)) {
			myOpenItems.remove(tree);
		} else {
			myOpenItems.add(tree);
		}
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public final boolean isOpen(ZLTree<?> tree) {
		return myOpenItems.contains(tree);
	}

	public final void selectItem(ZLTree<?> tree) {
		if (tree == null) {
			return;
		}
		openTree(tree.Parent);
		int index = 0;
		while (true) {
			ZLTree<?> parent = tree.Parent;
			if (parent == null) {
				break;
			}
			for (ZLTree<?> sibling : parent.subTrees()) {
				if (sibling == tree) {
					break;
				}
				index += getCount(sibling);
			}
			tree = parent;
			++index;
		}
		if (index > 0) {
			myParent.setSelection(index - 1);
		}
	}

	private int getCount(ZLTree<?> tree) {
		int count = 1;
		if (isOpen(tree)) {
			for (ZLTree<?> subtree : tree.subTrees()) {
				count += getCount(subtree);
			}
		}
		return count;
	}

	public final int getCount() {
		return getCount(myTree) - 1;
	}

	private final int indexByPosition(int position, ZLTree<?> tree) {
		if (position == 0) {
			return 0;
		}
		--position;
		int index = 1;
		for (ZLTree<?> subtree : tree.subTrees()) {
			int count = getCount(subtree);
			if (count <= position) {
				position -= count;
				index += subtree.getSize();
			} else {
				return index + indexByPosition(position, subtree);
			}
		}
		throw new RuntimeException(""That's impossible!!!"");
	}

	public final ZLTree<?> getItem(int position) {
		final int index = indexByPosition(position + 1, myTree) - 1;
		ZLTree<?> item = myItems[index];
		if (item == null) {
			item = myTree.getTreeByParagraphNumber(index + 1);
			myItems[index] = item;
		}
		return item;
	}

	public final boolean areAllItemsEnabled() {
		return true;
	}

	public final boolean isEnabled(int position) {
		return true;
	}

	public final long getItemId(int position) {
		return indexByPosition(position + 1, myTree);
	}

	protected boolean runTreeItem(ZLTree<?> tree) {
		if (!tree.hasChildren()) {
			return false;
		}
		expandOrCollapseTree(tree);
		return true;
	}

	protected void resetTree(ZLTree<?> tree) {
		myTree = tree;
		myItems = new ZLTree[tree.getSize() - 1];
		myOpenItems.clear();
		myOpenItems.add(tree);
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public void resetTree() {
		myItems = new ZLTree[myTree.getSize() - 1];
		//myParent.invalidateViews();
		//myParent.requestLayout();
		notifyDataSetChanged();
	}

	public final void onItemClick(AdapterView<?> parent, View view, int position, long id) {
		runTreeItem(getItem(position));
	}

	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
	}

	public abstract View getView(int position, View convertView, ViewGroup parent);

	protected final void setIcon(ImageView imageView, ZLTree<?> tree) {
		if (tree.hasChildren()) {
			if (isOpen(tree)) {
				imageView.setImageResource(R.drawable.ic_list_group_open);
			} else {
				imageView.setImageResource(R.drawable.ic_list_group_closed);
			}
		} else {
			imageView.setImageResource(R.drawable.ic_list_group_empty);
		}
		imageView.setPadding(25 * (tree.Level - 1), imageView.getPaddingTop(), 0, imageView.getPaddingBottom());
	}
}
",False,3,1,1,1,1,1,1,L7
187,org.geometerplus.android.fbreader.ShowTOCAction.java,"/*
 * Copyright (C) 2007-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader;

import org.geometerplus.fbreader.fbreader.FBReaderApp;

class ShowTOCAction extends RunActivityAction {
	ShowTOCAction(FBReader baseActivity, FBReaderApp fbreader) {
		super(baseActivity, fbreader, TOCActivity.class);
	}

	public boolean isVisible() {
		return (Reader.Model != null) && Reader.Model.TOCTree.hasChildren();
	}
}
",False,377,0,0,9,90,1,6,L6
188,org.geometerplus.android.fbreader.image.ImageViewActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.image;

import android.app.Activity;
import android.graphics.*;
import android.net.Uri;
import android.os.Bundle;
import android.view.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.*;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;

public class ImageViewActivity extends Activity {
	Bitmap myBitmap;

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		final ZLAndroidApplication application = ZLAndroidApplication.Instance();
		final boolean showStatusBar = application.ShowStatusBarOption.getValue();
		getWindow().setFlags(
			WindowManager.LayoutParams.FLAG_FULLSCREEN,
			showStatusBar ? 0 : WindowManager.LayoutParams.FLAG_FULLSCREEN
		);

		Thread.setDefaultUncaughtExceptionHandler(
			new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this)
		);

		setContentView(new ImageView());

		final Uri uri = getIntent().getData();
		if (""imagefile"".equals(uri.getScheme())) {
			try {
				final String[] data = uri.getPath().split(""\000"");
				final ZLFileImage image = new ZLFileImage(
					""image/auto"",
					ZLFile.createFileByPath(data[0]),
					Integer.parseInt(data[1]),
					Integer.parseInt(data[2])
				);
				final ZLImageData imageData = ZLImageManager.Instance().getImageData(image);
				myBitmap = ((ZLAndroidImageData)imageData).getFullSizeBitmap();
			} catch (Exception e) {
				// TODO: error message (?)
				finish();
			}
		} else {
			// TODO: error message (?)
			finish();
		}
	}

	@Override
	protected void onDestroy() {
		super.onDestroy();
		if (myBitmap != null) {
			myBitmap.recycle();
		}
		myBitmap = null;
	}

	private class ImageView extends View {
		private final Paint myPaint = new Paint();

		private int myDx;
		private int myDy;

		ImageView() {
			super(ImageViewActivity.this);
		}

		@Override
		protected void onDraw(final Canvas canvas) {
			myPaint.setColor(Color.rgb(128, 128, 128));
			final int w = getWidth();
			final int h = getHeight();
			canvas.drawRect(0, 0, w, h, myPaint);
			if (myBitmap == null || myBitmap.isRecycled()) {
				return;
			}

			final int bw = myBitmap.getWidth();
			final int bh = myBitmap.getHeight();
			
			final int left, top;
			if (bw <= w) {
				left = (w - bw) / 2;
			} else {
				left = Math.max(w - bw, Math.min(0, (w - bw) / 2 + myDx));
			}
			if (bh <= h) {
				top = (h - bh) / 2;
			} else {
				top = Math.max(h - bh, Math.min(0, (h - bh) / 2 + myDy));
			}
			canvas.drawBitmap(myBitmap, left, top, myPaint);
		}

		private void shift(int dx, int dy) {
			if (myBitmap == null || myBitmap.isRecycled()) {
				return;
			}

			final int w = getWidth();
			final int h = getHeight();
			final int bw = myBitmap.getWidth();
			final int bh = myBitmap.getHeight();

			final int newDx, newDy;

			if (w < bw) {
				final int delta = bw - w;
				newDx = Math.max(-delta, Math.min(delta, myDx + dx));
			} else {
				newDx = myDx;
			}
			if (h < bh) {
				final int delta = bh - h;
				newDy = Math.max(-delta, Math.min(delta, myDy + dy));
			} else {
				newDy = myDy;
			}

			if (newDx != myDx || newDy != myDy) {
				myDx = newDx;
				myDy = newDy;
				postInvalidate();
			}
		}

		private boolean myMotionControl;
		private int mySavedX;
		private int mySavedY;
		@Override
		public boolean onTouchEvent(MotionEvent event) {
			int x = (int)event.getX();
			int y = (int)event.getY();

			switch (event.getAction()) {
				case MotionEvent.ACTION_UP:
					myMotionControl = false;
					break;
				case MotionEvent.ACTION_DOWN:
					myMotionControl = true;
					mySavedX = x;
					mySavedY = y;
					break;
				case MotionEvent.ACTION_MOVE:
					if (myMotionControl) {
						shift(x - mySavedX, y - mySavedY);
					}
					myMotionControl = true;
					mySavedX = x;
					mySavedY = y;
					break;
			}
			return true;
		}
	}
}
",True,116,6,18,7,15,1,8,L6
189,org.geometerplus.android.fbreader.library.LibraryTreeActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.ListView;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.BookTree;
import org.geometerplus.fbreader.tree.FBTree;

public class LibraryTreeActivity extends LibraryBaseActivity {
	private String myTreePathString;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		if (DatabaseInstance == null || LibraryInstance == null) {
			finish();
			return;
		}

		final Intent intent = getIntent();
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			if (runSearch(intent)) {
				startActivity(intent
					.setAction(ACTION_FOUND)
					.setClass(getApplicationContext(), LibraryTopLevelActivity.class)
					.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK)
				);
			} else {
				showNotFoundToast();
				finish();
			}
			return;
		}

		myTreePathString = intent.getStringExtra(TREE_PATH_KEY);
        
		final String[] path = myTreePathString.split(""\000"");
        
		String title = null;
		if (path.length == 1) {
			title = myResource.getResource(path[0]).getResource(""summary"").getValue();
			final String parameter = intent.getStringExtra(PARAMETER_KEY);
			if (parameter != null) {
				title = title.replace(""%s"", parameter);
			}
		} else {
			title = path[path.length - 1];
		}
		setTitle(title);

		FBTree tree = null;
		if (PATH_RECENT.equals(path[0])) {
			tree = LibraryInstance.recentBooks();
		} else if (PATH_SEARCH_RESULTS.equals(path[0])) {
			tree = LibraryInstance.searchResults();
		} else if (PATH_BY_AUTHOR.equals(path[0])) {
			tree = LibraryInstance.byAuthor();
		} else if (PATH_BY_TITLE.equals(path[0])) {
			tree = LibraryInstance.byTitle();
		} else if (PATH_BY_TAG.equals(path[0])) {
			tree = LibraryInstance.byTag();
		} else if (PATH_FAVORITES.equals(path[0])) {
			tree = LibraryInstance.favorites();
		}
        
		for (int i = 1; i < path.length; ++i) {
			if (tree == null) {
				break;
			}
			tree = tree.getSubTreeByName(path[i]);
		}

		mySelectedBook = null;
		if (mySelectedBookPath != null) {
			final ZLFile file = ZLFile.createFileByPath(mySelectedBookPath);
			if (file != null) {
				mySelectedBook = Book.getByFile(file);
			}
		}
        
		if (tree != null) {
			final LibraryAdapter adapter = new LibraryAdapter(tree.subTrees());
			setListAdapter(adapter);
			getListView().setOnCreateContextMenuListener(adapter);
			System.err.println(""SELECTED: "" + adapter.getFirstSelectedItemIndex());
			setSelection(adapter.getFirstSelectedItemIndex());
		}
	}

	@Override
	public void onListItemClick(ListView listView, View view, int position, long rowId) {
		FBTree tree = ((LibraryAdapter)getListAdapter()).getItem(position);
		if (tree instanceof BookTree) {
			showBookInfo(((BookTree)tree).Book);
		} else {
			new OpenTreeRunnable(LibraryInstance, myTreePathString + ""\000"" + tree.getName()).run();
		}
	}
}
",True,378,0,0,10,100,0,9,L7
190,org.geometerplus.android.fbreader.library.InitializationService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.app.Service;
import android.content.Intent;
import android.os.IBinder;
import android.os.Handler;
import android.os.Message;

public class InitializationService extends Service {
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				stopSelf();
			}
		};

		final Thread libraryInitializer = new Thread(""LibraryInitializer"") {
			public void run() {
				try {
					LibraryBaseActivity.LibraryInstance.synchronize();
				} finally {
					handler.sendMessage(handler.obtainMessage(0));
				}
			}
		};
		libraryInitializer.setPriority(Thread.MIN_PRIORITY);
		libraryInitializer.start();
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		onStart(intent, startId);
		return 0;
	}
}
",True,378,0,0,10,97,0,2,L7
191,org.geometerplus.android.fbreader.library.BaseActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.app.*;
import android.content.DialogInterface;
import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.library.*;

import org.geometerplus.android.fbreader.FBReader;
import org.geometerplus.android.fbreader.BookInfoActivity;

abstract class BaseActivity extends ListActivity {
	public static final String SELECTED_BOOK_PATH_KEY = ""SelectedBookPath"";
	private static final int OPEN_BOOK_ITEM_ID = 0;
	private static final int SHOW_BOOK_INFO_ITEM_ID = 1;
	private static final int ADD_TO_FAVORITES_ITEM_ID = 2;
	private static final int REMOVE_FROM_FAVORITES_ITEM_ID = 3;
	private static final int DELETE_BOOK_ITEM_ID = 4;

	protected static final int CHILD_LIST_REQUEST = 0;
	protected static final int BOOK_INFO_REQUEST = 1;
	protected static final int RESULT_DONT_INVALIDATE_VIEWS = 0;
	protected static final int RESULT_DO_INVALIDATE_VIEWS = 1;

	static BooksDatabase DatabaseInstance;
	static Library LibraryInstance;

	protected final ZLResource myResource = ZLResource.resource(""libraryView"");
	protected String mySelectedBookPath;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		mySelectedBookPath = getIntent().getStringExtra(SELECTED_BOOK_PATH_KEY);
		setResult(RESULT_DONT_INVALIDATE_VIEWS);
	}

	protected void openBook(Book book) {
		startActivity(
			new Intent(getApplicationContext(), FBReader.class)
				.setAction(Intent.ACTION_VIEW)
				.putExtra(FBReader.BOOK_PATH_KEY, book.File.getPath())
				.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
		);
	}

	protected void createBookContextMenu(ContextMenu menu, Book book) {
		menu.setHeaderTitle(book.getTitle());
		menu.add(0, OPEN_BOOK_ITEM_ID, 0, myResource.getResource(""openBook"").getValue());
		menu.add(0, SHOW_BOOK_INFO_ITEM_ID, 0, myResource.getResource(""showBookInfo"").getValue());
		if (LibraryInstance.isBookInFavorites(book)) {
			menu.add(0, REMOVE_FROM_FAVORITES_ITEM_ID, 0, myResource.getResource(""removeFromFavorites"").getValue());
		} else {
			menu.add(0, ADD_TO_FAVORITES_ITEM_ID, 0, myResource.getResource(""addToFavorites"").getValue());
		}
		if ((LibraryInstance.getRemoveBookMode(book) & Library.REMOVE_FROM_DISK) != 0) {
			menu.add(0, DELETE_BOOK_ITEM_ID, 0, myResource.getResource(""deleteBook"").getValue());
        }
	}

	protected View createView(View convertView, ViewGroup parent, String name, String summary) {
		final View view = (convertView != null) ?  convertView :
			LayoutInflater.from(parent.getContext()).inflate(R.layout.library_tree_item, parent, false);

        ((TextView)view.findViewById(R.id.library_tree_item_name)).setText(name);
		((TextView)view.findViewById(R.id.library_tree_item_childrenlist)).setText(summary);
		return view;
	}

	private int myCoverWidth = -1;
	private int myCoverHeight = -1;
	private final Runnable myInvalidateViewsRunnable = new Runnable() {
		public void run() {
			getListView().invalidateViews();
		}
	};

	protected ImageView getCoverView(View parent) {
		if (myCoverWidth == -1) {
			parent.measure(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
			myCoverHeight = parent.getMeasuredHeight();
			myCoverWidth = myCoverHeight * 15 / 32;
			parent.requestLayout();
		}

		final ImageView coverView = (ImageView)parent.findViewById(R.id.library_tree_item_icon);
		coverView.getLayoutParams().width = myCoverWidth;
		coverView.getLayoutParams().height = myCoverHeight;
		coverView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
		coverView.requestLayout();
		return coverView;
	}

	protected Bitmap getCoverBitmap(ZLImage cover) {
		if (cover == null) {
			return null;
		}

		ZLAndroidImageData data = null;
		final ZLAndroidImageManager mgr = (ZLAndroidImageManager)ZLAndroidImageManager.Instance();
		if (cover instanceof ZLLoadableImage) {
			final ZLLoadableImage img = (ZLLoadableImage)cover;
			if (img.isSynchronized()) {
				data = mgr.getImageData(img);
			} else {
				img.startSynchronization(myInvalidateViewsRunnable);
			}
		} else {
			data = mgr.getImageData(cover);
		}
		return data != null ? data.getBitmap(2 * myCoverWidth, 2 * myCoverHeight) : null;
	}

	private class BookDeleter implements DialogInterface.OnClickListener {
		private final Book myBook;
		private final int myMode;

		BookDeleter(Book book, int removeMode) {
			myBook = book;
			myMode = removeMode;
		}

		public void onClick(DialogInterface dialog, int which) {
			deleteBook(myBook, myMode);
			setResult(RESULT_DO_INVALIDATE_VIEWS);
		}
	}

	private void tryToDeleteBook(Book book) {
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource boxResource = dialogResource.getResource(""deleteBookBox"");
		new AlertDialog.Builder(this)
			.setTitle(book.getTitle())
			.setMessage(boxResource.getResource(""message"").getValue())
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new BookDeleter(book, Library.REMOVE_FROM_DISK))
			.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
			.create().show();
	}

	protected void deleteBook(Book book, int mode) {
		LibraryInstance.removeBook(book, mode);
	}

	protected void showBookInfo(Book book) {
		startActivityForResult(
			new Intent(getApplicationContext(), BookInfoActivity.class)
				.putExtra(BookInfoActivity.CURRENT_BOOK_PATH_KEY, book.File.getPath()),
			BOOK_INFO_REQUEST
		);
	}

	protected boolean onContextItemSelected(int itemId, Book book) {
		switch (itemId) {
			case OPEN_BOOK_ITEM_ID:
				openBook(book);
				return true;
			case SHOW_BOOK_INFO_ITEM_ID:
				showBookInfo(book);
				return true;
			case ADD_TO_FAVORITES_ITEM_ID:
				LibraryInstance.addBookToFavorites(book);
				return true;
			case REMOVE_FROM_FAVORITES_ITEM_ID:
				LibraryInstance.removeBookFromFavorites(book);
				getListView().invalidateViews();
				return true;
			case DELETE_BOOK_ITEM_ID:
				tryToDeleteBook(book);
				return true;
		}
		return false;
	}
}
",False,380,1,3,9,87,6,13,L6
192,org.geometerplus.android.fbreader.library.FileManager.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import java.util.*;

import android.content.Intent;
import android.graphics.Bitmap;
import android.os.Bundle;
import android.os.Environment;
import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.filesystem.ZLFile;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.Paths;
import org.geometerplus.fbreader.library.Book;
import org.geometerplus.fbreader.library.Library;
import org.geometerplus.fbreader.formats.PluginCollection;

import org.geometerplus.android.util.UIUtil;

public final class FileManager extends BaseActivity {
	public static String FILE_MANAGER_PATH = ""FileManagerPath"";
	
	private String myPath;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		if (DatabaseInstance == null || LibraryInstance == null) {
			finish();
			return;
		}

		FileListAdapter adapter = new FileListAdapter();
		setListAdapter(adapter);

		myPath = getIntent().getStringExtra(FILE_MANAGER_PATH);

		if (myPath == null) {
			setTitle(myResource.getResource(""fileTree"").getValue());
			addItem(Paths.BooksDirectoryOption().getValue(), ""fileTreeLibrary"");
			addItem(""/"", ""fileTreeRoot"");
			addItem(Environment.getExternalStorageDirectory().getPath(), ""fileTreeCard"");
			adapter.notifyDataSetChanged();
		} else {
			setTitle(myPath);
			startUpdate();
		}

		getListView().setOnCreateContextMenuListener(adapter);
		getListView().setTextFilterEnabled(true);
		getListView().setOnItemClickListener(new AdapterView.OnItemClickListener() {
			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
				runItem(((FileListAdapter)getListAdapter()).getItem(position));
			}
		});
	}

	private void startUpdate() {
		new Thread(
			new SmartFilter(ZLFile.createFileByPath(myPath))
		).start();
	}

	@Override
	protected void onActivityResult(int requestCode, int returnCode, Intent intent) {
		if (requestCode == CHILD_LIST_REQUEST && returnCode == RESULT_DO_INVALIDATE_VIEWS) {
			if (myPath != null) {
				((FileListAdapter)getListAdapter()).clear();
				startUpdate();
			}
			getListView().invalidateViews();
			setResult(RESULT_DO_INVALIDATE_VIEWS);
		} else if (requestCode == BOOK_INFO_REQUEST) {
			getListView().invalidateViews();
		}
	} 

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final FileItem fileItem = ((FileListAdapter)getListAdapter()).getItem(position);
		final Book book = fileItem.getBook(); 
		if (book != null) {
			return onContextItemSelected(item.getItemId(), book);
		}
		return super.onContextItemSelected(item);
	}

	@Override
	protected void deleteBook(Book book, int mode) {
		super.deleteBook(book, mode);
		((FileListAdapter)getListAdapter()).deleteFile(book.File);
		getListView().invalidateViews();
	}

	private void runItem(FileItem item) {
		final ZLFile file = item.getFile();
		final Book book = item.getBook();
		if (book != null) {
			showBookInfo(book);
		} else if (file.isDirectory() || file.isArchive()) {
			startActivityForResult(
				new Intent(this, FileManager.class)
					.putExtra(SELECTED_BOOK_PATH_KEY, mySelectedBookPath)
					.putExtra(FILE_MANAGER_PATH, file.getPath()),
				CHILD_LIST_REQUEST
			);
		} else {
			UIUtil.showErrorMessage(FileManager.this, ""permissionDenied"");
		}
	}

	private void addItem(String path, String resourceKey) {
		final ZLResource resource = myResource.getResource(resourceKey);
		((FileListAdapter)getListAdapter()).add(new FileItem(
			ZLFile.createFileByPath(path),
			resource.getValue(),
			resource.getResource(""summary"").getValue()
		));
	}

	private boolean isItemSelected(FileItem item) {
		if (mySelectedBookPath == null || !item.isSelectable()) {
			return false;
		}

		final ZLFile file = item.getFile();
		final String path = file.getPath();
		if (mySelectedBookPath.equals(path)) {
			return true;
		}

		String prefix = path;
		if (file.isDirectory()) {
			if (!prefix.endsWith(""/"")) {
				prefix += '/';
			}
		} else if (file.isArchive()) {
			prefix += ':';
		} else {
			return false;
		}
		return mySelectedBookPath.startsWith(prefix);
	}

	private final class FileListAdapter extends BaseAdapter implements View.OnCreateContextMenuListener {
		private List<FileItem> myItems = new ArrayList<FileItem>();

		public synchronized void clear() {
			myItems.clear();
		}

		public synchronized void add(FileItem item){
			myItems.add(item);
		}

		public synchronized void deleteFile(ZLFile file) {
			for (FileItem item : myItems) {
				if (file.equals(item.getFile())) {
					myItems.remove(item);
					break;
				}
			}
		}

		public synchronized int getCount() {
			return myItems.size();
		}

		public synchronized FileItem getItem(int position) {
			return myItems.get(position);
		}

		public long getItemId(int position) {
			return position;
		}

		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final Book book = getItem(position).getBook();
			if (book != null) {
				createBookContextMenu(menu, book); 
			}
		}

		public View getView(int position, View convertView, ViewGroup parent) {
            final FileItem item = getItem(position);
			final View view = createView(convertView, parent, item.getName(), item.getSummary());
			if (isItemSelected(item)) {
				view.setBackgroundColor(0xff555555);
			} else {
				view.setBackgroundColor(0);
			}
			final ImageView coverView = getCoverView(view);
			final Bitmap coverBitmap = getCoverBitmap(item.getCover());

			if (coverBitmap != null) {
				coverView.setImageBitmap(coverBitmap);
			} else {
				coverView.setImageResource(item.getIcon());
			}

            return view;
		}
	}

	private final class FileItem {
		private final ZLFile myFile;
		private final String myName;
		private final String mySummary;
		private final boolean myIsSelectable;

		private ZLImage myCover = null;
		private boolean myCoverIsInitialized = false;

		public FileItem(ZLFile file, String name, String summary) {
			myFile = file;
			myName = name;
			mySummary = summary;
			myIsSelectable = false;
		}

		public FileItem(ZLFile file) {
			if (file.isArchive() && file.getPath().endsWith("".fb2.zip"")) {
				final List<ZLFile> children = file.children();
				if (children.size() == 1) {
					final ZLFile child = children.get(0);
					if (child.getPath().endsWith("".fb2"")) {
						myFile = child;
						myName = file.getLongName();
						mySummary = null;
						myIsSelectable = true;
						return;
					}
				} 
			}
			myFile = file;
			myName = null;
			mySummary = null;
			myIsSelectable = true;
		}

		public String getName() {
			return myName != null ? myName : myFile.getShortName();
		}

		public String getSummary() {
			if (mySummary != null) {
				return mySummary;
			}

			final Book book = getBook();
			if (book != null) {
				return book.getTitle();
			}

			return null;
		}

		public boolean isSelectable() {
			return myIsSelectable;
		}

		public int getIcon() {
			if (getBook() != null) {
				return R.drawable.ic_list_library_book;
			} else if (myFile.isDirectory()) {
				if (myFile.isReadable()) {
					return R.drawable.ic_list_library_folder;
				} else {
					return R.drawable.ic_list_library_permission_denied;
				}
			} else if (myFile.isArchive()) {
				return R.drawable.ic_list_library_zip;
			} else {
				System.err.println(
					""File "" + myFile.getPath() +
					"" that is not a directory, not a book and not an archive "" +
					""has been found in getIcon()""
				);
				return R.drawable.ic_list_library_permission_denied;
			}
		}

		public ZLImage getCover() {
			if (!myCoverIsInitialized) {
				myCoverIsInitialized = true;
				myCover = Library.getCover(myFile);
			}
			return myCover;
		}

		public ZLFile getFile() {
			return myFile;
		}

		public Book getBook() {
			return Book.getByFile(myFile);
		}
	}

	private final class SmartFilter implements Runnable {
		private final ZLFile myFile;

		public SmartFilter(ZLFile file) {
			myFile = file;
		}

		public void run() {
			if (!myFile.isReadable()) {
				runOnUiThread(new Runnable() {
					public void run() {
						UIUtil.showErrorMessage(FileManager.this, ""permissionDenied"");
					}
				});
				finish();
				return;
			}

			final ArrayList<ZLFile> children = new ArrayList<ZLFile>(myFile.children());
			Collections.sort(children, new FileComparator());
			for (final ZLFile file : children) {
				if (Thread.currentThread().isInterrupted()) {
					break;
				}
				if (file.isDirectory() || file.isArchive() ||
					PluginCollection.Instance().getPlugin(file) != null) {
					runOnUiThread(new Runnable() {
						public void run() {
							final FileListAdapter adapter = (FileListAdapter)getListAdapter();
							adapter.add(new FileItem(file));
							adapter.notifyDataSetChanged();
						}
					});
				}
			}
		}
	}

	private static class FileComparator implements Comparator<ZLFile> {
		public int compare(ZLFile f0, ZLFile f1) {
			return f0.getShortName().compareToIgnoreCase(f1.getShortName());
		}
	}
}
",True,378,0,0,10,103,0,10,L7
193,org.geometerplus.android.fbreader.library.KillerCallback.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Process;

public class KillerCallback extends BroadcastReceiver {
	@Override
	public void onReceive(Context context, Intent intent) {
		Process.killProcess(Process.myPid());
	}
}
",False,45,5,19,0,0,1,0,L6
194,org.geometerplus.android.fbreader.library.LibraryBaseActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import java.util.List;

import android.app.*;
import android.content.Intent;
import android.graphics.Bitmap;
import android.view.*;
import android.widget.*;

import org.geometerplus.zlibrary.core.options.ZLStringOption;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.library.*;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

abstract class LibraryBaseActivity extends BaseActivity implements MenuItem.OnMenuItemClickListener {
	static final String TREE_PATH_KEY = ""TreePath"";
	static final String PARAMETER_KEY = ""Parameter"";

	static final String PATH_FAVORITES = ""favorites"";
	static final String PATH_SEARCH_RESULTS = ""searchResults"";
	static final String PATH_RECENT = ""recent"";
	static final String PATH_BY_AUTHOR = ""byAuthor"";
	static final String PATH_BY_TITLE = ""byTitle"";
	static final String PATH_BY_TAG = ""byTag"";

	static final ZLStringOption BookSearchPatternOption =
		new ZLStringOption(""BookSearch"", ""Pattern"", """");

	protected Book mySelectedBook;

	@Override
	protected void onActivityResult(int requestCode, int returnCode, Intent intent) {
		if (requestCode == CHILD_LIST_REQUEST && returnCode == RESULT_DO_INVALIDATE_VIEWS) {
			getListView().invalidateViews();
			setResult(RESULT_DO_INVALIDATE_VIEWS);
		}
	}

	@Override
	public boolean onSearchRequested() {
		startSearch(BookSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	protected static final String ACTION_FOUND = ""fbreader.library.intent.FOUND"";

	protected boolean runSearch(Intent intent) {
	   	final String pattern = intent.getStringExtra(SearchManager.QUERY);
		if (pattern == null || pattern.length() == 0) {
			return false;
		}
		BookSearchPatternOption.setValue(pattern);
		return LibraryInstance.searchBooks(pattern).hasChildren();
	}

	protected void showNotFoundToast() {
		UIUtil.showErrorMessage(this, ""bookNotFound"");
	}

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        super.onCreateOptionsMenu(menu);
        addMenuItem(menu, 1, ""localSearch"", R.drawable.ic_menu_search);
        return true;
    }

    private MenuItem addMenuItem(Menu menu, int index, String resourceKey, int iconId) {
        final String label = myResource.getResource(""menu"").getResource(resourceKey).getValue();
        final MenuItem item = menu.add(0, index, Menu.NONE, label);
        item.setOnMenuItemClickListener(this);
        item.setIcon(iconId);
        return item;
    }

    public boolean onMenuItemClick(MenuItem item) {
        switch (item.getItemId()) {
            case 1:
                return onSearchRequested();
            default:
                return true;
        }
    }

	protected final class LibraryAdapter extends BaseAdapter implements View.OnCreateContextMenuListener {
		private final List<FBTree> myItems;

		public LibraryAdapter(List<FBTree> items) {
			myItems = items;
		}

		public final int getCount() {
			return myItems.size();
		}

		public int getFirstSelectedItemIndex() {
			int index = 0;
			for (FBTree t : myItems) {
				if (isTreeSelected(t)) {
					return index;
				}
				++index;
			}
			return -1;
		}

		public final FBTree getItem(int position) {
			return myItems.get(position);
		}

		public final long getItemId(int position) {
			return position;
		}

		public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			final LibraryTree tree = (LibraryTree)getItem(position);
			if (tree instanceof BookTree) {
				createBookContextMenu(menu, ((BookTree)tree).Book);
			}
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final FBTree tree = getItem(position);
			final View view = createView(convertView, parent, tree.getName(), tree.getSecondString());
			if (isTreeSelected(tree)) {
				view.setBackgroundColor(0xff555555);
			} else {
				view.setBackgroundColor(0);
			}

			final ImageView coverView = getCoverView(view);

			if (tree instanceof ZLAndroidTree) {
				coverView.setImageResource(((ZLAndroidTree)tree).getCoverResourceId());
			} else {
				final Bitmap coverBitmap = getCoverBitmap(tree.getCover());
				if (coverBitmap != null) {
					coverView.setImageBitmap(coverBitmap);
				} else if (tree instanceof AuthorTree) {
					coverView.setImageResource(R.drawable.ic_list_library_author);
				} else if (tree instanceof TagTree) {
					coverView.setImageResource(R.drawable.ic_list_library_tag);
				} else if (tree instanceof BookTree) {
					coverView.setImageResource(R.drawable.ic_list_library_book);
				} else {
					coverView.setImageResource(R.drawable.ic_list_library_books);
				}
			}

			return view;
		}
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
		final FBTree tree = ((LibraryAdapter)getListAdapter()).getItem(position);
		if (tree instanceof BookTree) {
			return onContextItemSelected(item.getItemId(), ((BookTree)tree).Book);
		}
		return super.onContextItemSelected(item);
	}

	@Override
	protected void deleteBook(Book book, int mode) {
		super.deleteBook(book, mode);
		getListView().invalidateViews();
	}

	protected boolean isTreeSelected(FBTree tree) {
		if (mySelectedBook == null) {
			return false;
		}

		if (tree instanceof BookTree) {
			return mySelectedBook.equals(((BookTree)tree).Book);
		}
		if (tree instanceof AuthorTree) {
			return mySelectedBook.authors().contains(((AuthorTree)tree).Author);
		}
		if (tree instanceof TitleTree) {
			final String title = mySelectedBook.getTitle();
			return tree != null && title.trim().startsWith(((TitleTree)tree).Title);
		}
		if (tree instanceof SeriesTree) {
			final SeriesInfo info = mySelectedBook.getSeriesInfo();
			final String series = ((SeriesTree)tree).Series;
			return info != null && series != null && series.equals(info.Name);
		}
		if (tree instanceof TagTree) {
			final Tag tag = ((TagTree)tree).Tag;
			for (Tag t : mySelectedBook.tags()) {
				for (; t != null; t = t.Parent) {
					if (t == tag) {
						return true;
					}
				}
			}
			return false;
		}
		return false;
	}

	protected class StartTreeActivityRunnable implements Runnable {
		private final String myTreePath;
		private final String myParameter;

		public StartTreeActivityRunnable(String treePath, String parameter) {
			myTreePath = treePath;
			myParameter = parameter;
		}

		public void run() {
			startActivityForResult(
				new Intent(LibraryBaseActivity.this, LibraryTreeActivity.class)
					.putExtra(SELECTED_BOOK_PATH_KEY, mySelectedBookPath)
					.putExtra(TREE_PATH_KEY, myTreePath)
					.putExtra(PARAMETER_KEY, myParameter),
				CHILD_LIST_REQUEST
			);
		}
	}

	protected class OpenTreeRunnable implements Runnable {
		private final Library myLibrary;
		private final Runnable myPostRunnable;

		public OpenTreeRunnable(Library library, String treePath) {
			this(library, treePath, null);
		}

		public OpenTreeRunnable(Library library, String treePath, String parameter) {
			this(library, new StartTreeActivityRunnable(treePath, parameter));
		}

		public OpenTreeRunnable(Library library, Runnable postRunnable) {
			myLibrary = library;
			myPostRunnable = postRunnable;
		}

		public void run() {
			if (myLibrary == null) {
				return;
			}
			if (myLibrary.hasState(Library.STATE_FULLY_INITIALIZED)) {
				myPostRunnable.run();
			} else {
				UIUtil.runWithMessage(LibraryBaseActivity.this, ""loadingBookList"",
				new Runnable() {
					public void run() {
						myLibrary.waitForState(Library.STATE_FULLY_INITIALIZED);
					}
				},
				myPostRunnable);
			}
		}
	}
}
",True,378,1,1,10,97,2,17,L6
195,org.geometerplus.android.fbreader.library.LibraryTopLevelActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.library;

import java.util.LinkedList;

import android.app.SearchManager;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.widget.ListView;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.library.Library;
import org.geometerplus.fbreader.tree.FBTree;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.fbreader.SQLiteBooksDatabase;
import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

public class LibraryTopLevelActivity extends LibraryBaseActivity {
	private LinkedList<FBTree> myItems;
	private TopLevelTree mySearchResultsItem;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		requestWindowFeature(Window.FEATURE_NO_TITLE);

		DatabaseInstance = SQLiteBooksDatabase.Instance();
		if (DatabaseInstance == null) {
			DatabaseInstance = new SQLiteBooksDatabase(this, ""LIBRARY"");
		}
		if (LibraryInstance == null) {
			LibraryInstance = new Library();
			startService(new Intent(getApplicationContext(), InitializationService.class));
		}

		myItems = new LinkedList<FBTree>();
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_FAVORITES),
			R.drawable.ic_list_library_favorites,
			new OpenTreeRunnable(LibraryInstance, new StartTreeActivityRunnable(PATH_FAVORITES, null) {
				public void run() {
					if (LibraryInstance.favorites().hasChildren()) {
						super.run();
					} else {
						UIUtil.showErrorMessage(LibraryTopLevelActivity.this, ""noFavorites"");
					}
				}
			})
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_RECENT),
			R.drawable.ic_list_library_recent,
			new OpenTreeRunnable(LibraryInstance, PATH_RECENT)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_BY_AUTHOR),
			R.drawable.ic_list_library_authors,
			new OpenTreeRunnable(LibraryInstance, PATH_BY_AUTHOR)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_BY_TITLE),
			R.drawable.ic_list_library_books,
			new OpenTreeRunnable(LibraryInstance, PATH_BY_TITLE)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(PATH_BY_TAG),
			R.drawable.ic_list_library_tags,
			new OpenTreeRunnable(LibraryInstance, PATH_BY_TAG)
		));
		myItems.add(new TopLevelTree(
			myResource.getResource(""fileTree""),
			R.drawable.ic_list_library_folder,
			new Runnable() {
				public void run() {
					startActivity(
						new Intent(LibraryTopLevelActivity.this, FileManager.class)
							.putExtra(SELECTED_BOOK_PATH_KEY, mySelectedBookPath)
					);
				}
			}
		));
		setListAdapter(new LibraryAdapter(myItems));

		onNewIntent(getIntent());
	}

	@Override
	public void onDestroy() {
		LibraryInstance = null;
		super.onDestroy();
	}

	@Override
	public void onListItemClick(ListView listView, View view, int position, long rowId) {
		TopLevelTree tree = (TopLevelTree)((LibraryAdapter)getListAdapter()).getItem(position);
		tree.run();
	}

	private void setSearchResults(Intent intent) {
		if (myItems.get(0) == mySearchResultsItem) {
			myItems.remove(0);
		}
		final String pattern = intent.getStringExtra(SearchManager.QUERY);
		mySearchResultsItem = new TopLevelTree(
			myResource.getResource(PATH_SEARCH_RESULTS),
			pattern,
			R.drawable.ic_list_library_books,
			new OpenTreeRunnable(LibraryInstance, PATH_SEARCH_RESULTS, pattern)
		);
		myItems.add(0, mySearchResultsItem);
		getListView().invalidateViews();
		mySearchResultsItem.run();
	}

	public void onNewIntent(Intent intent) {
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			if (runSearch(intent)) {
				setSearchResults(intent);
			} else {
				showNotFoundToast();
			}
		} else if (ACTION_FOUND.equals(intent.getAction())) {
			setSearchResults(intent);
		}
	}
}

class TopLevelTree extends FBTree implements ZLAndroidTree {
	private final ZLResource myResource;
	private final String myParameter;
	private final int myCoverResourceId;
	private final Runnable myAction;

	public TopLevelTree(ZLResource resource, String parameter, int coverResourceId, Runnable action) {
		myResource = resource;
		myParameter = parameter;
		myCoverResourceId = coverResourceId;
		myAction = action;
	}

	public TopLevelTree(ZLResource resource, int coverResourceId, Runnable action) {
		this(resource, null, coverResourceId, action);
	}

	@Override
	public String getName() {
		return myResource.getValue();
	}

	@Override
	public String getSummary() {
		final String summary = myResource.getResource(""summary"").getValue();
		return myParameter == null ? summary : summary.replace(""%s"", myParameter);
	}

	public int getCoverResourceId() {
		return myCoverResourceId;
	}

	public void run() {
		myAction.run();
	}
}
",True,377,0,0,10,94,1,10,L6
196,org.geometerplus.android.fbreader.preferences.ZLPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

interface ZLPreference {
	void onAccept();
}
",False,64,8,20,0,0,8,0,L0
197,org.geometerplus.android.fbreader.preferences.PreferenceActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Intent;

import org.geometerplus.zlibrary.core.options.ZLIntegerOption;
import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;

import org.geometerplus.zlibrary.text.view.style.*;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;
import org.geometerplus.zlibrary.ui.android.view.AndroidFontUtil;

import org.geometerplus.fbreader.fbreader.*;
import org.geometerplus.fbreader.Paths;
import org.geometerplus.fbreader.bookmodel.FBTextKind;

public class PreferenceActivity extends ZLPreferenceActivity {
	public PreferenceActivity() {
		super(""Preferences"");
	}

	@Override
	protected void init(Intent intent) {
		final FBReaderApp fbReader = (FBReaderApp)FBReaderApp.Instance();
		final ZLAndroidApplication androidApp = ZLAndroidApplication.Instance();
		final ColorProfile profile = fbReader.getColorProfile();

		final Screen directoriesScreen = createPreferenceScreen(""directories"");
		directoriesScreen.addOption(Paths.BooksDirectoryOption(), ""books"");
		if (AndroidFontUtil.areExternalFontsSupported()) {
			directoriesScreen.addOption(Paths.FontsDirectoryOption(), ""fonts"");
		}
		directoriesScreen.addOption(Paths.WallpapersDirectoryOption(), ""wallpapers"");

		final ZLPreferenceSet statusBarPreferences = new ZLPreferenceSet();
		final Screen appearanceScreen = createPreferenceScreen(""appearance"");
		appearanceScreen.addOption(androidApp.AutoOrientationOption, ""autoOrientation"");
		appearanceScreen.addPreference(
			new ZLBooleanPreference(
				this, androidApp.ShowStatusBarOption, appearanceScreen.Resource, ""showStatusBar""
			) {
				@Override
				public void onClick() {
					super.onClick();
					statusBarPreferences.setEnabled(!isChecked());
				}
			}
		);
		statusBarPreferences.add(
			appearanceScreen.addOption(
				androidApp.ShowStatusBarWhenMenuIsActiveOption,
				""showStatusBarWhenMenuIsActive""
			)
		);
		statusBarPreferences.setEnabled(!androidApp.ShowStatusBarOption.getValue());

		final Screen textScreen = createPreferenceScreen(""text"");
		final ZLTextStyleCollection collection = ZLTextStyleCollection.Instance();
		final ZLTextBaseStyle baseStyle = collection.getBaseStyle();
		textScreen.addPreference(new FontOption(
			this, textScreen.Resource, ""font"",
			baseStyle.FontFamilyOption, false
		));
		textScreen.addPreference(new ZLIntegerRangePreference(
			this, textScreen.Resource.getResource(""fontSize""),
			baseStyle.FontSizeOption
		));
		textScreen.addPreference(new FontStylePreference(
			this, textScreen.Resource, ""fontStyle"",
			baseStyle.BoldOption, baseStyle.ItalicOption
		));
		final ZLIntegerRangeOption spaceOption = baseStyle.LineSpaceOption;
		final String[] spacings = new String[spaceOption.MaxValue - spaceOption.MinValue + 1];
		for (int i = 0; i < spacings.length; ++i) {
			final int val = spaceOption.MinValue + i;
			spacings[i] = (char)(val / 10 + '0') + ""."" + (char)(val % 10 + '0');
		}
		textScreen.addPreference(new ZLChoicePreference(
			this, textScreen.Resource, ""lineSpacing"",
			spaceOption, spacings
		));
		final String[] alignments = { ""left"", ""right"", ""center"", ""justify"" };
		textScreen.addPreference(new ZLChoicePreference(
			this, textScreen.Resource, ""alignment"",
			baseStyle.AlignmentOption, alignments
		));
		textScreen.addPreference(new ZLBooleanPreference(
			this, baseStyle.AutoHyphenationOption,
			textScreen.Resource, ""autoHyphenations""
		));

		final Screen moreStylesScreen = textScreen.createPreferenceScreen(""more"");

		byte styles[] = {
			FBTextKind.REGULAR,
			FBTextKind.TITLE,
			FBTextKind.SECTION_TITLE,
			FBTextKind.SUBTITLE,
			FBTextKind.H1,
			FBTextKind.H2,
			FBTextKind.H3,
			FBTextKind.H4,
			FBTextKind.H5,
			FBTextKind.H6,
			FBTextKind.ANNOTATION,
			FBTextKind.EPIGRAPH,
			FBTextKind.AUTHOR,
			FBTextKind.POEM_TITLE,
			FBTextKind.STANZA,
			FBTextKind.VERSE,
			FBTextKind.CITE,
			FBTextKind.INTERNAL_HYPERLINK,
			FBTextKind.EXTERNAL_HYPERLINK,
			FBTextKind.FOOTNOTE,
			FBTextKind.ITALIC,
			FBTextKind.EMPHASIS,
			FBTextKind.BOLD,
			FBTextKind.STRONG,
			FBTextKind.DEFINITION,
			FBTextKind.DEFINITION_DESCRIPTION,
			FBTextKind.PREFORMATTED,
			FBTextKind.CODE
		};
		for (int i = 0; i < styles.length; ++i) {
			final ZLTextStyleDecoration decoration = collection.getDecoration(styles[i]);
			if (decoration == null) {
				continue;
			}
			ZLTextFullStyleDecoration fullDecoration =
				decoration instanceof ZLTextFullStyleDecoration ?
					(ZLTextFullStyleDecoration)decoration : null;

			final Screen formatScreen = moreStylesScreen.createPreferenceScreen(decoration.getName());
			formatScreen.addPreference(new FontOption(
				this, textScreen.Resource, ""font"",
				decoration.FontFamilyOption, true
			));
			formatScreen.addPreference(new ZLIntegerRangePreference(
				this, textScreen.Resource.getResource(""fontSizeDifference""),
				decoration.FontSizeDeltaOption
			));
			formatScreen.addPreference(new ZLBoolean3Preference(
				this, textScreen.Resource, ""bold"",
				decoration.BoldOption
			));
			formatScreen.addPreference(new ZLBoolean3Preference(
				this, textScreen.Resource, ""italic"",
				decoration.ItalicOption
			));
			if (fullDecoration != null) {
				final String[] allAlignments = { ""unchanged"", ""left"", ""right"", ""center"", ""justify"" };
				formatScreen.addPreference(new ZLChoicePreference(
					this, textScreen.Resource, ""alignment"",
					fullDecoration.AlignmentOption, allAlignments
				));
			}
			formatScreen.addPreference(new ZLBoolean3Preference(
				this, textScreen.Resource, ""allowHyphenations"",
				decoration.AllowHyphenationsOption
			));
			if (fullDecoration != null) {
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""spaceBefore""),
					fullDecoration.SpaceBeforeOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""spaceAfter""),
					fullDecoration.SpaceAfterOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""leftIndent""),
					fullDecoration.LeftIndentOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""rightIndent""),
					fullDecoration.RightIndentOption
				));
				formatScreen.addPreference(new ZLIntegerRangePreference(
					this, textScreen.Resource.getResource(""firstLineIndent""),
					fullDecoration.FirstLineIndentDeltaOption
				));
				final ZLIntegerOption spacePercentOption = fullDecoration.LineSpacePercentOption;
				final int[] spacingValues = new int[17];
				final String[] spacingKeys = new String[17];
				spacingValues[0] = -1;
				spacingKeys[0] = ""unchanged"";
				for (int j = 1; j < spacingValues.length; ++j) {
					final int val = 4 + j;
					spacingValues[j] = 10 * val;
					spacingKeys[j] = (char)(val / 10 + '0') + ""."" + (char)(val % 10 + '0');
				}
				formatScreen.addPreference(new ZLIntegerChoicePreference(
					this, textScreen.Resource, ""lineSpacing"",
					spacePercentOption, spacingValues, spacingKeys
				));
			}
				
		}

		final ZLPreferenceSet footerPreferences = new ZLPreferenceSet();
		final ZLPreferenceSet bgPreferences = new ZLPreferenceSet();

		final Screen colorsScreen = createPreferenceScreen(""colors"");
		colorsScreen.addPreference(new WallpaperPreference(
			this, profile, colorsScreen.Resource, ""background""
		) {
			@Override
			protected void onDialogClosed(boolean result) {
				super.onDialogClosed(result);
				bgPreferences.setEnabled("""".equals(getValue()));
			}
		});
		bgPreferences.add(
			colorsScreen.addOption(profile.BackgroundOption, ""backgroundColor"")
		);
		bgPreferences.setEnabled("""".equals(profile.WallpaperOption.getValue()));
		/*
		colorsScreen.addOption(profile.SelectionBackgroundOption, ""selectionBackground"");
		*/
		colorsScreen.addOption(profile.HighlightingOption, ""highlighting"");
		colorsScreen.addOption(profile.RegularTextOption, ""text"");
		colorsScreen.addOption(profile.HyperlinkTextOption, ""hyperlink"");
		colorsScreen.addOption(profile.FooterFillOption, ""footer"");

		final Screen marginsScreen = createPreferenceScreen(""margins"");
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""left""),
			fbReader.LeftMarginOption
		));
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""right""),
			fbReader.RightMarginOption
		));
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""top""),
			fbReader.TopMarginOption
		));
		marginsScreen.addPreference(new ZLIntegerRangePreference(
			this, marginsScreen.Resource.getResource(""bottom""),
			fbReader.BottomMarginOption
		));

		final Screen statusLineScreen = createPreferenceScreen(""scrollBar"");

		final String[] scrollBarTypes = {""hide"", ""show"", ""showAsProgress"", ""showAsFooter""};
		statusLineScreen.addPreference(new ZLChoicePreference(
			this, statusLineScreen.Resource, ""scrollbarType"",
			fbReader.ScrollbarTypeOption, scrollBarTypes
		) {
			@Override
			protected void onDialogClosed(boolean result) {
				super.onDialogClosed(result);
				footerPreferences.setEnabled(
					findIndexOfValue(getValue()) == FBView.SCROLLBAR_SHOW_AS_FOOTER
				);
			}
		});

		footerPreferences.add(statusLineScreen.addPreference(new ZLIntegerRangePreference(
			this, statusLineScreen.Resource.getResource(""footerHeight""),
			fbReader.FooterHeightOption
		)));
		footerPreferences.add(statusLineScreen.addOption(profile.FooterFillOption, ""footerColor""));
		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowTOCMarksOption, ""tocMarks""));

		/*
		String[] footerLongTaps = {""longTapRevert"", ""longTapNavigate""};
		footerPreferences.add(statusLineScreen.addPreference(new ZLChoicePreference(
			this, statusLineScreen.Resource, ""footerLongTap"",
			fbReader.FooterLongTapOption, footerLongTaps
		)));
		*/

		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowClockOption, ""showClock""));
		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowBatteryOption, ""showBattery""));
		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterShowProgressOption, ""showProgress""));
		footerPreferences.add(statusLineScreen.addOption(fbReader.FooterIsSensitiveOption, ""isSensitive""));
		footerPreferences.add(statusLineScreen.addPreference(new FontOption(
			this, statusLineScreen.Resource, ""font"",
			fbReader.FooterFontOption, false
		)));
		footerPreferences.setEnabled(
			fbReader.ScrollbarTypeOption.getValue() == FBView.SCROLLBAR_SHOW_AS_FOOTER
		);

		final Screen displayScreen = createPreferenceScreen(""display"");
		displayScreen.addPreference(new ZLBooleanPreference(
			this,
			fbReader.AllowScreenBrightnessAdjustmentOption,
			displayScreen.Resource,
			""allowScreenBrightnessAdjustment""
		) {
			public void onAccept() {
				super.onAccept();
				if (!isChecked()) {
					androidApp.ScreenBrightnessLevelOption.setValue(0);
				}
			}
		});
		displayScreen.addPreference(new BatteryLevelToTurnScreenOffPreference(
			this,
			androidApp.BatteryLevelToTurnScreenOffOption,
			displayScreen.Resource,
			""dontTurnScreenOff""
		));
		/*
		displayScreen.addPreference(new ZLBooleanPreference(
			this,
			androidApp.DontTurnScreenOffDuringChargingOption,
			displayScreen.Resource,
			""dontTurnScreenOffDuringCharging""
		));
		*/

		/*
		final Screen colorProfileScreen = createPreferenceScreen(""colorProfile"");
		final ZLResource resource = colorProfileScreen.Resource;
		colorProfileScreen.setSummary(ColorProfilePreference.createTitle(resource, fbreader.getColorProfileName()));
		for (String key : ColorProfile.names()) {
			colorProfileScreen.addPreference(new ColorProfilePreference(
				this, fbreader, colorProfileScreen, key, ColorProfilePreference.createTitle(resource, key)
			));
		}
		*/

		final Screen scrollingScreen = createPreferenceScreen(""scrolling"");
		final ScrollingPreferences scrollingPreferences = ScrollingPreferences.Instance();
		scrollingScreen.addOption(scrollingPreferences.FingerScrollingOption, ""fingerScrolling"");
		scrollingScreen.addOption(fbReader.EnableDoubleTapOption, ""enableDoubleTapDetection"");

		final ZLPreferenceSet volumeKeysPreferences = new ZLPreferenceSet();
		scrollingScreen.addPreference(new ZLBooleanPreference(
			this, scrollingPreferences.VolumeKeysOption, scrollingScreen.Resource, ""volumeKeys""
		) {
			@Override
			protected void onClick() {
				super.onClick();
				volumeKeysPreferences.setEnabled(isChecked());
			}
		});	
		volumeKeysPreferences.add(scrollingScreen.addOption(
			scrollingPreferences.InvertVolumeKeysOption, ""invertVolumeKeys""
		));
		volumeKeysPreferences.setEnabled(scrollingPreferences.VolumeKeysOption.getValue());

		scrollingScreen.addOption(scrollingPreferences.AnimationOption, ""animation"");
		scrollingScreen.addOption(scrollingPreferences.HorizontalOption, ""horizontal"");

		final Screen dictionaryScreen = createPreferenceScreen(""dictionary"");
		dictionaryScreen.addPreference(new DictionaryPreference(
			this,
			dictionaryScreen.Resource,
			""dictionary""
		));
		dictionaryScreen.addPreference(new ZLBooleanPreference(
			this,
			fbReader.NavigateAllWordsOption,
			dictionaryScreen.Resource,
			""navigateOverAllWords""
		));
		dictionaryScreen.addOption(fbReader.DictionaryTappingActionOption, ""tappingAction"");
	}
}
",False,292,6,18,7,73,1,31,L6
198,org.geometerplus.android.fbreader.preferences.ZLColorPreference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.content.DialogInterface;
import android.graphics.*;
import android.graphics.drawable.*;
import android.preference.DialogPreference;
import android.view.View;
import android.widget.SeekBar;

import org.geometerplus.zlibrary.core.util.ZLColor;
import org.geometerplus.zlibrary.core.options.ZLColorOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.R;
import org.geometerplus.zlibrary.ui.android.util.ZLAndroidColorUtil;

class ZLColorPreference extends DialogPreference implements ZLPreference {
	private final ZLColorOption myOption;

	private SeekBar myRedSlider;
	private SeekBar myGreenSlider;
	private SeekBar myBlueSlider;
	private final GradientDrawable myPreviewDrawable = new GradientDrawable();

	ZLColorPreference(Context context, ZLResource resource, String resourceKey, ZLColorOption option) {
		super(context, null);
		myOption = option;
		final String title = resource.getResource(resourceKey).getValue();
		setTitle(title);
		setDialogTitle(title);
		setDialogLayoutResource(R.layout.color_dialog);

		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		setPositiveButtonText(buttonResource.getResource(""ok"").getValue());
		setNegativeButtonText(buttonResource.getResource(""cancel"").getValue());
	}

	private SeekBar createSlider(View view, int id, int value, String resourceKey) {
		final SeekBar slider = (SeekBar)view.findViewById(id);
		slider.setProgress(value);
		slider.setProgressDrawable(new SeekBarDrawable(
			slider.getProgressDrawable(),
			ZLResource.resource(""color"").getResource(resourceKey).getValue(),
			slider
		));
		return slider;
	}

	@Override
	protected void onBindDialogView(View view) {
		final ZLColor color = myOption.getValue();

		myRedSlider = createSlider(view, R.id.color_red, color.Red, ""red"");
		myGreenSlider = createSlider(view, R.id.color_green, color.Green, ""green"");
		myBlueSlider = createSlider(view, R.id.color_blue, color.Blue, ""blue"");

		final View colorBox = view.findViewById(R.id.color_box);
		colorBox.setBackgroundDrawable(myPreviewDrawable);
		myPreviewDrawable.setCornerRadius(7);
		myPreviewDrawable.setColor(ZLAndroidColorUtil.rgb(color));

		final SeekBar.OnSeekBarChangeListener listener = new SeekBar.OnSeekBarChangeListener() {
			public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
				myPreviewDrawable.setColor(Color.rgb(
					myRedSlider.getProgress(),
					myGreenSlider.getProgress(),
					myBlueSlider.getProgress()
				));
				myPreviewDrawable.invalidateSelf();
			}

			public void onStartTrackingTouch(SeekBar seekBar) {
			}

			public void onStopTrackingTouch(SeekBar seekBar) {
				myPreviewDrawable.setColor(Color.rgb(
					myRedSlider.getProgress(),
					myGreenSlider.getProgress(),
					myBlueSlider.getProgress()
				));
				myPreviewDrawable.invalidateSelf();
			}
		};
		myRedSlider.setOnSeekBarChangeListener(listener);
		myGreenSlider.setOnSeekBarChangeListener(listener);
		myBlueSlider.setOnSeekBarChangeListener(listener);

		super.onBindDialogView(view);
	}

	@Override
	public void onClick(DialogInterface dialog, int which) {
		if (which == DialogInterface.BUTTON_POSITIVE) {
			myOption.setValue(new ZLColor(
				myRedSlider.getProgress(),
				myGreenSlider.getProgress(),
				myBlueSlider.getProgress()
			));
		}
	}

	/*
	@Override
	protected void onBindView(View view) {
		final ImageView colorView = (ImageView)view.findViewById(R.id.color_preference_color);
		//colorView.setImageResource(R.drawable.fbreader);
		final Drawable drawable = new ColorDrawable(0x00FF00);
		colorView.setImageDrawable(drawable);
		
		super.onBindView(view);
	}
	*/

	public void onAccept() {
	}

	static class SeekBarDrawable extends Drawable {
		private final SeekBar mySlider;
		private final Drawable myBase;
		private final String myText;
		private final Paint myPaint;
		private final Paint myOutlinePaint;
		private boolean myLabelOnRight;

		public SeekBarDrawable(Drawable base, String text, SeekBar slider) {
			mySlider = slider;
			myBase = base;
			myText = text;

			myPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
			myPaint.setTypeface(Typeface.DEFAULT_BOLD);
			myPaint.setColor(Color.BLACK);
			myPaint.setAlpha(255);

			myOutlinePaint = new Paint(myPaint);
			myOutlinePaint.setStyle(Paint.Style.STROKE);
			myOutlinePaint.setStrokeWidth(3);
			myOutlinePaint.setColor(0xFFAAAAAA);

			myLabelOnRight = mySlider.getProgress() < 128;
		}

		@Override
		protected void onBoundsChange(Rect bounds) {
			myBase.setBounds(bounds);
		}
		
		@Override
		protected boolean onStateChange(int[] state) {
			invalidateSelf();
			return false;
		}
		
		@Override
		public boolean isStateful() {
			return true;
		}
		
		@Override
		protected boolean onLevelChange(int level) {
			if (level < 4000) {
				myLabelOnRight = true;
			} else if (level > 6000) {
				myLabelOnRight = false;
			}
			return myBase.setLevel(level);
		}
		
		@Override
		public void draw(Canvas canvas) {
			myBase.draw(canvas);

			final Rect bounds = getBounds();
			final int textSize = bounds.height() * 2 / 3;
			myPaint.setTextSize(textSize);
			myOutlinePaint.setTextSize(textSize);
			final Rect textBounds = new Rect();
			myPaint.getTextBounds(""a"", 0, 1, textBounds);
			final String text = myText + "": "" + mySlider.getProgress();
			final float textWidth = myOutlinePaint.measureText(text);
			final float x = myLabelOnRight ? bounds.width() - textWidth - 6 : 6;
			final float y = bounds.height() / 2 + textBounds.height();
			canvas.drawText(text, x, y, myOutlinePaint);
			canvas.drawText(text, x, y, myPaint);
		}

		@Override
		public int getOpacity() {
			return PixelFormat.TRANSLUCENT;
		}

		@Override
		public void setAlpha(int alpha) {
		}

		@Override
		public void setColorFilter(ColorFilter cf) {
		}
	}
}
",False,81,8,20,7,8,1,5,L6
199,org.geometerplus.android.fbreader.preferences.DictionaryPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.List;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.android.fbreader.DictionaryUtil;
import org.geometerplus.android.fbreader.PackageInfo;

class DictionaryPreference extends ZLStringListPreference {
	private final ZLStringOption myOption;

	DictionaryPreference(Context context, ZLResource resource, String resourceKey) {
		super(context, resource, resourceKey);

		myOption = DictionaryUtil.dictionaryOption();
		final List<PackageInfo> infos = DictionaryUtil.dictionaryInfos(context);
		
		final String[] values = new String[infos.size()];
		final String[] texts = new String[infos.size()];
		int index = 0;
		for (PackageInfo i : infos) {
			values[index] = i.Id;
			texts[index] = i.Title;
			++index;
		}
		setLists(values, texts);

		setInitialValue(myOption.getValue());
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,134,7,18,8,24,1,5,L6
200,org.geometerplus.android.fbreader.preferences.FontStylePreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class FontStylePreference extends ZLStringListPreference {
	private final ZLBooleanOption myBoldOption;
	private final ZLBooleanOption myItalicOption;
	private final String[] myValues = { ""regular"", ""bold"", ""italic"", ""boldItalic"" };

	FontStylePreference(Context context, ZLResource resource, String resourceKey, ZLBooleanOption boldOption, ZLBooleanOption italicOption) {
		super(context, resource, resourceKey);

		myBoldOption = boldOption;
		myItalicOption = italicOption;
		setList(myValues);

		final int intValue =
			(boldOption.getValue() ? 1 : 0) |
			(italicOption.getValue() ? 2 : 0);
		setInitialValue(myValues[intValue]);
	}

	public void onAccept() {
		final int intValue = findIndexOfValue(getValue());
		myBoldOption.setValue((intValue & 0x1) == 0x1);
		myItalicOption.setValue((intValue & 0x2) == 0x2);
	}
}
",False,79,7,18,7,8,1,3,L6
201,org.geometerplus.android.fbreader.preferences.ZLIntegerChoicePreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLIntegerOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLIntegerChoicePreference extends ZLStringListPreference {
	private final ZLIntegerOption myOption;
	private final int[] myValues;

	ZLIntegerChoicePreference(Context context, ZLResource resource, String resourceKey, ZLIntegerOption option, int[] values, String[] valueResourceKeys) {
		super(context, resource, resourceKey);
		assert(values.length == valueResourceKeys.length);

		myOption = option;
		myValues = values;
		setList(valueResourceKeys);

		final int initialValue = option.getValue();
		int index = 0;
		int minDiff = Math.abs(values[0] - initialValue);
		for (int i = 1; i < values.length; ++i) {
			final int diff = Math.abs(values[i] - initialValue);
			if (diff < minDiff) {
				minDiff = diff;
				index = i;
			}
		}
		setInitialValue(valueResourceKeys[index]);
	}

	public void onAccept() {
		myOption.setValue(myValues[findIndexOfValue(getValue())]);
	}
}
",False,79,7,18,7,8,1,3,L6
202,org.geometerplus.android.fbreader.preferences.ZLPreferenceActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.ArrayList;

import android.os.Bundle;
import android.preference.*;
import android.content.Intent;

import org.geometerplus.zlibrary.core.options.*;
import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLPreferenceActivity extends android.preference.PreferenceActivity {
	private final ArrayList<ZLPreference> myPreferences = new ArrayList<ZLPreference>();

	protected class Screen {
		public final ZLResource Resource;
		private final PreferenceScreen myScreen;

		private Screen(ZLResource root, String resourceKey) {
			Resource = root.getResource(resourceKey);
			myScreen = getPreferenceManager().createPreferenceScreen(ZLPreferenceActivity.this);
			myScreen.setTitle(Resource.getValue());
			myScreen.setSummary(Resource.getResource(""summary"").getValue());
		}

		public void setSummary(CharSequence summary) {
			myScreen.setSummary(summary);
		}

		public Screen createPreferenceScreen(String resourceKey) {
			Screen screen = new Screen(Resource, resourceKey);
			myScreen.addPreference(screen.myScreen);
			return screen;
		}

		public ZLPreference addPreference(ZLPreference preference) {
			myScreen.addPreference((Preference)preference);
			myPreferences.add(preference);
			return preference;
		}

		public ZLPreference addOption(ZLBooleanOption option, String resourceKey) {
			return addPreference(
				new ZLBooleanPreference(ZLPreferenceActivity.this, option, Resource, resourceKey)
			);
		}

		public ZLPreference addOption(ZLStringOption option, String resourceKey) {
			return addPreference(
				new ZLStringOptionPreference(ZLPreferenceActivity.this, option, Resource, resourceKey)
			);
		}

		public ZLPreference addOption(ZLColorOption option, String resourceKey) {
			return addPreference(
				new ZLColorPreference(ZLPreferenceActivity.this, Resource, resourceKey, option)
			);
		}

		public <T extends Enum<T>> ZLPreference addOption(ZLEnumOption<T> option, String resourceKey) {
			return addPreference(
				new ZLEnumPreference<T>(ZLPreferenceActivity.this, option, Resource, resourceKey)
			);
		}

		public void close() {
			myScreen.getDialog().dismiss();
			ZLPreferenceActivity.this.getListView().invalidateViews();
		}

		public void setOnPreferenceClickListener(PreferenceScreen.OnPreferenceClickListener onPreferenceClickListener) {
			myScreen.setOnPreferenceClickListener(onPreferenceClickListener);
		}
	}

	private PreferenceScreen myScreen;
	final ZLResource Resource;

	ZLPreferenceActivity(String resourceKey) {
		Resource = ZLResource.resource(""dialog"").getResource(resourceKey);
	}

	Screen createPreferenceScreen(String resourceKey) {
		Screen screen = new Screen(Resource, resourceKey);
		myScreen.addPreference(screen.myScreen);
		return screen;
	}

	public ZLPreference addPreference(ZLPreference preference) {
		myScreen.addPreference((Preference)preference);
		myPreferences.add(preference);
		return preference;
	}

	public ZLPreference addOption(ZLBooleanOption option, String resourceKey) {
		ZLBooleanPreference preference =
			new ZLBooleanPreference(ZLPreferenceActivity.this, option, Resource, resourceKey);
		myScreen.addPreference(preference);
		myPreferences.add(preference);
		return preference;
	}

	/*
	protected Category createCategory() {
		return new CategoryImpl(myScreen, Resource);
	}
	*/

	protected abstract void init(Intent intent);

	@Override
	protected void onCreate(Bundle bundle) {
		super.onCreate(bundle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		myScreen = getPreferenceManager().createPreferenceScreen(this);

		init(getIntent());

		setPreferenceScreen(myScreen);
	}

	@Override
	protected void onPause() {
		for (ZLPreference preference : myPreferences) {
			preference.onAccept();
		}
		super.onPause();
	}
}
",False,91,7,20,7,11,2,11,L6
203,org.geometerplus.android.fbreader.preferences.ZLPreferenceSet.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.LinkedList;

import android.preference.Preference;

class ZLPreferenceSet {
	private final LinkedList<ZLPreference> myPreferences = new LinkedList<ZLPreference>();

	final void add(ZLPreference preference) {
		myPreferences.add(preference);
	}

	final void setEnabled(boolean enable) {
		for (ZLPreference preference : myPreferences) {
			((Preference)preference).setEnabled(enable);
		}
	}
}
",False,47,7,18,1,1,1,1,L6
204,org.geometerplus.android.fbreader.preferences.EditBookInfoActivity.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.TreeSet;

import android.content.Context;
import android.content.Intent;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.library.Book;

import org.geometerplus.android.fbreader.BookInfoActivity;
import org.geometerplus.android.fbreader.SQLiteBooksDatabase;

class BookTitlePreference extends ZLStringPreference {
	private final Book myBook;

	BookTitlePreference(Context context, ZLResource rootResource, String resourceKey, Book book) {
		super(context, rootResource, resourceKey);
		myBook = book;
		setValue(book.getTitle());
	}

	public void onAccept() {
		myBook.setTitle(getValue());
	}
}

class LanguagePreference extends ZLStringListPreference {
	private final Book myBook;

	LanguagePreference(Context context, ZLResource rootResource, String resourceKey, Book book) {
		super(context, rootResource, resourceKey);
		myBook = book;
		final TreeSet<String> set = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
		set.addAll(ZLLanguageUtil.languageCodes());
		set.add(ZLLanguageUtil.OTHER_LANGUAGE_CODE);

		final int size = set.size();
		String[] codes = new String[size];
		String[] names = new String[size];
		int index = 0;
		for (String code : set) {
			codes[index] = code;
			names[index] = ZLLanguageUtil.languageName(code);
			++index;
		}
		setLists(codes, names);
		String language = myBook.getLanguage();
		if (language == null) {
			language = ZLLanguageUtil.OTHER_LANGUAGE_CODE;
		}
		if (!setInitialValue(language)) {
			setInitialValue(ZLLanguageUtil.OTHER_LANGUAGE_CODE);
		}
	}

	public void onAccept() {
		final String value = getValue();
		myBook.setLanguage((value.length() != 0) ? value : null);
	}
}

public class EditBookInfoActivity extends ZLPreferenceActivity {
	private Book myBook;

	public EditBookInfoActivity() {
		super(""BookInfo"");
	}

	@Override
	protected void init(Intent intent) {
		if (SQLiteBooksDatabase.Instance() == null) {
			new SQLiteBooksDatabase(this, ""LIBRARY"");
		}

		final String path = intent.getStringExtra(BookInfoActivity.CURRENT_BOOK_PATH_KEY);
		final ZLFile file = ZLFile.createFileByPath(path);
		myBook = Book.getByFile(file);

		addPreference(new BookTitlePreference(this, Resource, ""title"", myBook));
		addPreference(new LanguagePreference(this, Resource, ""language"", myBook));
	}

	@Override
	protected void onPause() {
		super.onPause();
		myBook.save();
	}
}
",False,377,0,0,10,96,1,10,L6
205,org.geometerplus.android.fbreader.preferences.WallpaperPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.*;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.filesystem.ZLFile;

import org.geometerplus.fbreader.fbreader.ColorProfile;
import org.geometerplus.fbreader.fbreader.WallpapersUtil;

class WallpaperPreference extends ZLStringListPreference {
	private final ZLStringOption myOption;

	WallpaperPreference(Context context, ColorProfile profile, ZLResource resource, String resourceKey) {
		super(context, resource, resourceKey);

		myOption = profile.WallpaperOption;
		final List<ZLFile> predefined = WallpapersUtil.predefinedWallpaperFiles();
		final List<ZLFile> external = WallpapersUtil.externalWallpaperFiles();
		
		final int size = 1 + predefined.size() + external.size();
		final String[] values = new String[size];
		final String[] texts = new String[size];

		final ZLResource optionResource = resource.getResource(resourceKey);
		values[0] = """";
		texts[0] = optionResource.getResource(""solidColor"").getValue();
		int index = 1;
		for (ZLFile f : predefined) {
			values[index] = f.getPath();
			final String name = f.getShortName();
			texts[index] = optionResource.getResource(
				name.substring(0, name.indexOf("".""))
			).getValue();
			++index;
		}
		for (ZLFile f : external) {
			values[index] = f.getPath();
			texts[index] = f.getShortName();
			++index;
		}
		setLists(values, texts);

		setInitialValue(myOption.getValue());
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,85,7,18,6,12,1,6,L6
206,org.geometerplus.android.fbreader.preferences.ZLStringOptionPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import android.content.Context;

class ZLStringOptionPreference extends ZLStringPreference {
	private final ZLStringOption myOption;

	ZLStringOptionPreference(Context context, ZLStringOption option, ZLResource rootResource, String resourceKey) {
		super(context, rootResource, resourceKey);
		myOption = option;
		setValue(myOption.getValue());
	}

	public void onAccept() {
		myOption.setValue(getValue());
	}
}
",False,80,8,20,7,8,1,3,L6
207,org.geometerplus.android.fbreader.preferences.ZLEnumPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLEnumOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLEnumPreference<T extends Enum<T>> extends ZLStringListPreference {
	private final ZLEnumOption<T> myOption;

	ZLEnumPreference(Context context, ZLEnumOption<T> option, ZLResource resource, String resourceKey) {
		super(context, resource, resourceKey);
		myOption = option;

		final T initialValue = option.getValue();
		final Enum[] allValues = initialValue.getClass().getEnumConstants();
		final String[] stringValues = new String[allValues.length];
		for (int i = 0; i < stringValues.length; ++i) {
			stringValues[i] = allValues[i].toString();
		}
		setList(stringValues);
		setInitialValue(initialValue.toString());
	}

	public void onAccept() {
		myOption.setValue((T)Enum.valueOf(myOption.getValue().getClass(), getValue()));
	}
}
",False,80,8,20,7,8,1,3,L6
208,org.geometerplus.android.fbreader.preferences.ZLChoicePreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLChoicePreference extends ZLStringListPreference {
	private final ZLIntegerRangeOption myOption;

	ZLChoicePreference(Context context, ZLResource resource, String resourceKey, ZLIntegerRangeOption option, String[] valueResourceKeys) {
		super(context, resource, resourceKey);

		assert(option.MaxValue - option.MinValue + 1 == valueResourceKeys.length);

		myOption = option;
		setList(valueResourceKeys);

		setInitialValue(valueResourceKeys[option.getValue() - option.MinValue]);
	}

	public void onAccept() {
		myOption.setValue(myOption.MinValue + findIndexOfValue(getValue()));
	}
}
",False,79,7,18,7,8,1,3,L6
209,org.geometerplus.android.fbreader.preferences.BatteryLevelToTurnScreenOffPreference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;

class BatteryLevelToTurnScreenOffPreference extends ZLStringListPreference {
	private final ZLIntegerRangeOption myOption;

	BatteryLevelToTurnScreenOffPreference(Context context, ZLIntegerRangeOption option, ZLResource rootResource, String resourceKey) {
		super(context, rootResource, resourceKey);
		myOption = option;
		String[] entries = { ""0"", ""25"", ""50"", ""100"" };
		setList(entries);

		int value = option.getValue();
		if (value <= 0) {
			setInitialValue(""0"");
		} else if (value <= 25) {
			setInitialValue(""25"");
		} else if (value <= 50) {
			setInitialValue(""50"");
		} else {
			setInitialValue(""100"");
		}
	}

	public void onAccept() {
		try {
			myOption.setValue(Integer.parseInt(getValue()));
		} catch (NumberFormatException e) {
		}
	}
}
",True,79,7,18,7,8,1,3,L6
210,org.geometerplus.android.fbreader.preferences.FontOption.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import java.util.ArrayList;

import android.content.Context;

import org.geometerplus.zlibrary.core.options.ZLStringOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.view.AndroidFontUtil;

class FontOption extends ZLStringListPreference {
	private final ZLStringOption myOption;

	private static String UNCHANGED = ""unchanged"";

	FontOption(Context context, ZLResource resource, String resourceKey, ZLStringOption option, boolean includeDummyValue) {
		super(context, resource, resourceKey);

		myOption = option;
		final ArrayList<String> fonts = new ArrayList<String>();
		AndroidFontUtil.fillFamiliesList(fonts, true);
		if (includeDummyValue) {
			fonts.add(0, UNCHANGED);
		}
		setList((String[])fonts.toArray(new String[fonts.size()]));

		final String optionValue = option.getValue();
		final String initialValue = optionValue.length() > 0 ?
			AndroidFontUtil.realFontFamilyName(optionValue) : UNCHANGED;
		for (String fontName : fonts) {
			if (initialValue.equals(fontName)) {
				setInitialValue(fontName);
				return;
			}
		}
		for (String fontName : fonts) {
			if (initialValue.equals(AndroidFontUtil.realFontFamilyName(fontName))) {
				setInitialValue(fontName);
				return;
			}
		}
	}

	public void onAccept() {
		final String value = getValue();
		myOption.setValue(UNCHANGED.equals(value) ? """" : value);
	}
}
",False,84,7,18,7,8,1,4,L6
211,org.geometerplus.android.fbreader.preferences.InfoPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.Preference;

class InfoPreference extends Preference implements ZLPreference {
	InfoPreference(Context context, String title, String value) {
		super(context);
		setTitle(title);
		setSummary(value);
		setEnabled(false);
	}

	public void onAccept() {
	}
}
",False,2,0,0,1,1,0,1,L7
212,org.geometerplus.android.fbreader.preferences.ZLStringListPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.ListPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLStringListPreference extends ListPreference implements ZLPreference {
	private final ZLResource myResource;

	ZLStringListPreference(Context context, ZLResource rootResource, String resourceKey) {
		super(context);

		myResource = rootResource.getResource(resourceKey);
		setTitle(myResource.getValue());
	}

	protected final void setList(String[] values) {
		String[] texts = new String[values.length];
		for (int i = 0; i < values.length; ++i) {
			final ZLResource resource = myResource.getResource(values[i]);
			texts[i] = (resource.hasValue()) ? resource.getValue() : values[i];
		}
		setLists(values, texts);
	}

	protected final void setLists(String[] values, String[] texts) {
		assert(values.length == texts.length);
		setEntries(texts);
		setEntryValues(values);
	}

	protected final boolean setInitialValue(String value) {
		final int index = findIndexOfValue(value);
		if (index >= 0) {
			setValueIndex(index);
			setSummary(getEntry());
			return true;
		}
		return false;
	}

	@Override
	protected void onDialogClosed(boolean result) {
		super.onDialogClosed(result);
		if (result) {
			setSummary(getEntry());
		}
	}
}
",False,85,7,20,7,8,11,2,L6
213,org.geometerplus.android.fbreader.preferences.ZLBoolean3Preference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;

import org.geometerplus.zlibrary.core.util.ZLBoolean3;
import org.geometerplus.zlibrary.core.options.ZLBoolean3Option;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLBoolean3Preference extends ZLStringListPreference {
	private static final String ON = ""on"";
	private static final String OFF = ""off"";
	private static final String UNCHANGED = ""unchanged"";

	private final ZLBoolean3Option myOption;

	ZLBoolean3Preference(Context context, ZLResource resource, String resourceKey, ZLBoolean3Option option) {
		super(context, resource, resourceKey);

		myOption = option;
		setList(new String[] { ON, OFF, UNCHANGED });

		switch (option.getValue()) {
			case B3_TRUE:
				setInitialValue(ON);
				break;
			case B3_FALSE:
				setInitialValue(OFF);
				break;
			case B3_UNDEFINED:
				setInitialValue(UNCHANGED);
				break;
		}
	}

	public void onAccept() {
		final String value = getValue();
		if (ON.equals(value)) {
			myOption.setValue(ZLBoolean3.B3_TRUE);
		} else if (OFF.equals(value)) {
			myOption.setValue(ZLBoolean3.B3_FALSE);
		} else {
			myOption.setValue(ZLBoolean3.B3_UNDEFINED);
		}
	}
}
",False,80,7,18,7,8,1,4,L6
214,org.geometerplus.android.fbreader.preferences.ZLBooleanPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.CheckBoxPreference;

import org.geometerplus.zlibrary.core.options.ZLBooleanOption;
import org.geometerplus.zlibrary.core.resources.ZLResource;

class ZLBooleanPreference extends CheckBoxPreference implements ZLPreference {
	private final ZLBooleanOption myOption;

	ZLBooleanPreference(Context context, ZLBooleanOption option, ZLResource rootResource, String resourceKey) {
		super(context);
		myOption = option;

		ZLResource resource = rootResource.getResource(resourceKey);
		setTitle(resource.getValue());
		setSummaryOn(resource.getResource(""summaryOn"").getValue());
		setSummaryOff(resource.getResource(""summaryOff"").getValue());
		setChecked(option.getValue());
	}

	@Override
	protected void onClick() {
		super.onClick();
		myOption.setValue(isChecked());
	}

	public void onAccept() {
	}
}
",False,79,7,17,7,8,2,3,L6
215,org.geometerplus.android.fbreader.preferences.ZLStringPreference.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.EditTextPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;

abstract class ZLStringPreference extends EditTextPreference implements ZLPreference {
	private String myValue;

	ZLStringPreference(Context context, ZLResource rootResource, String resourceKey) {
		super(context);

		ZLResource resource = rootResource.getResource(resourceKey);
		setTitle(resource.getValue());
	}

	protected final void setValue(String value) {
		setSummary(value);
		setText(value);
		myValue = value;
	}

	protected final String getValue() {
		return myValue;
	}

	@Override
	protected void onDialogClosed(boolean result) {
		if (result) {
			setValue(getEditText().getText().toString());
		}
		super.onDialogClosed(result);
	}
}
",False,77,8,14,7,8,2,2,L6
216,org.geometerplus.android.fbreader.preferences.ZLIntegerRangePreference.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.preferences;

import android.content.Context;
import android.preference.ListPreference;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.options.ZLIntegerRangeOption;

class ZLIntegerRangePreference extends ListPreference implements ZLPreference {
	private final ZLIntegerRangeOption myOption;

	ZLIntegerRangePreference(Context context, ZLResource resource, ZLIntegerRangeOption option) {
		super(context);
		myOption = option;
		setTitle(resource.getValue());
		String[] entries = new String[option.MaxValue - option.MinValue + 1];
		for (int i = 0; i < entries.length; ++i) {
			entries[i] = ((Integer)(i + option.MinValue)).toString();
		}
		setEntries(entries);
		setEntryValues(entries);
		setValueIndex(option.getValue() - option.MinValue);
		setSummary(getValue());
	}

	@Override
	protected void onDialogClosed(boolean result) {
		super.onDialogClosed(result);
		if (result) {
			final String value = getValue();
			setSummary(value);
			myOption.setValue(myOption.MinValue + findIndexOfValue(value));
		}
	}

	public void onAccept() {
	}
}
",False,78,7,18,7,8,1,3,L6
217,org.geometerplus.android.fbreader.network.RefillAccountActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.View;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class RefillAccountActions extends NetworkTreeActions {
	public static final int REFILL_VIA_SMS_ITEM_ID = 0;
	public static final int REFILL_VIA_BROWSER_ITEM_ID = 1;


	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof RefillAccountTree;
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(getTitleValue(""refillTitle""));

		final INetworkLink link = ((RefillAccountTree)tree).Link;
		if (Util.isSmsAccountRefillingSupported(activity, link)) {
			addMenuItem(menu, REFILL_VIA_SMS_ITEM_ID, ""refillViaSms"");
		}
		if (Util.isBrowserAccountRefillingSupported(activity, link)) {
			addMenuItem(menu, REFILL_VIA_BROWSER_ITEM_ID, ""refillViaBrowser"");
		}
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		return getDefaultActionCode(activity, ((RefillAccountTree)tree).Link);
	}
	private int getDefaultActionCode(Activity activity, INetworkLink link) {
		final boolean sms = Util.isSmsAccountRefillingSupported(activity, link);
		final boolean browser = Util.isBrowserAccountRefillingSupported(activity, link);

		if (sms && browser) {
			return TREE_SHOW_CONTEXT_MENU;
		} else if (sms) {
			return REFILL_VIA_SMS_ITEM_ID;
		} else /* if (browser) */ { 
			return REFILL_VIA_BROWSER_ITEM_ID;
		}
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		final INetworkLink link = ((RefillAccountTree)tree).Link;
		return runAction(activity, link, actionCode);
	}
	public boolean runAction(Activity activity, INetworkLink link, int actionCode) {
		Runnable refillRunnable = null;
		switch (actionCode) {
			case REFILL_VIA_SMS_ITEM_ID:
				refillRunnable = smsRefillRunnable(activity, link);
				break;
			case REFILL_VIA_BROWSER_ITEM_ID:
				refillRunnable = browserRefillRunnable(activity, link);
				break;
		}

		if (refillRunnable == null) {
			return false;
		}
		doRefill(activity, link, refillRunnable);
		return true;
	}

	private Runnable browserRefillRunnable(final Activity activity, final INetworkLink link) {
		return new Runnable() {
			public void run() {
				Util.openInBrowser(
					activity,
					link.authenticationManager().refillAccountLink()
				);
			}
		};
	}

	private Runnable smsRefillRunnable(final Activity activity, final INetworkLink link) {
		return new Runnable() {
			public void run() {
				Util.runSmsDialog(activity, link);
			}
		};
	}

	private void doRefill(final Activity activity, final INetworkLink link, final Runnable refiller) {
		final NetworkAuthenticationManager mgr = link.authenticationManager();
		if (mgr.mayBeAuthorised(false)) {
			refiller.run();
		} else {
			NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, link, new Runnable() {
				public void run() {
					if (mgr.mayBeAuthorised(false)) {
						refiller.run();
					}
				}
			});
		}
	}

	public void runStandalone(Activity activity, INetworkLink link) {
		final int refillActionCode = getDefaultActionCode(activity, link);
		if (refillActionCode == TREE_SHOW_CONTEXT_MENU) {
			//activity.getListView().showContextMenu();
			View view = null;
			if (activity instanceof NetworkBaseActivity) {	
				view = ((NetworkBaseActivity)activity).getListView();
			} else if (activity instanceof NetworkBookInfoActivity) {
				view = ((NetworkBookInfoActivity)activity).getMainView();
			}
			if (view != null) {
				view.showContextMenu();
			}
		} else if (refillActionCode >= 0) {
			runAction(activity, link, refillActionCode);
		}
	}
}
",True,377,0,0,9,110,4,9,L6
218,org.geometerplus.android.fbreader.network.NetworkBookInfoActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Set;

import android.app.Activity;
import android.app.Dialog;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.view.View;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.widget.ImageView;
import android.widget.TextView;
import android.content.Intent;
import android.graphics.Bitmap;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;

import org.geometerplus.fbreader.network.*;

public class NetworkBookInfoActivity extends Activity implements NetworkView.EventListener {
	private NetworkBookItem myBook;
	private View myMainView;

	private final ZLResource myResource = ZLResource.resource(""networkBookView"");
	private BookDownloaderServiceConnection myConnection;

	@Override
	protected void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		if (!NetworkView.Instance().isInitialized()) {
			finish();
			return;
		}

		myBook = NetworkView.Instance().getBookInfoItem();
		if (myBook == null) {
			finish();
			return;
		}

		myConnection = new BookDownloaderServiceConnection();
		bindService(
			new Intent(getApplicationContext(), BookDownloaderService.class),
			myConnection,
			BIND_AUTO_CREATE
		);

		setTitle(myBook.Title);
		myMainView = getLayoutInflater().inflate(R.layout.network_book, null, false);
		setContentView(myMainView);
		myMainView.setOnCreateContextMenuListener(this);

		setupDescription();
		setupInfo();
		setupCover();
		setupButtons();
	}

	View getMainView() {
		return myMainView;
	}

	@Override
	public void onDestroy() {
		if (myConnection != null) {
			unbindService(myConnection);
			myConnection = null;
		}
		super.onDestroy();
	}

	@Override
	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
		new RefillAccountActions().buildContextMenu(this, menu, new RefillAccountTree(myBook.Link));
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		new RefillAccountActions().runAction(this, myBook.Link, item.getItemId());
		return true;
	}

	private final void setupDescription() {
		((TextView) findViewById(R.id.network_book_description_title)).setText(myResource.getResource(""description"").getValue());

		final TextView descriptionView = (TextView) findViewById(R.id.network_book_description);
		final String description;
		if (myBook.Summary != null) {
			description = myBook.Summary;
		} else {
			description = myResource.getResource(""noDescription"").getValue();
		}
		descriptionView.setText(description);
	}

	private void setupInfo() {
		((TextView) findViewById(R.id.network_book_info_title)).setText(myResource.getResource(""bookInfo"").getValue());

		((TextView) findViewById(R.id.network_book_title_key)).setText(myResource.getResource(""title"").getValue());
		((TextView) findViewById(R.id.network_book_authors_key)).setText(myResource.getResource(""authors"").getValue());
		((TextView) findViewById(R.id.network_book_series_key)).setText(myResource.getResource(""series"").getValue());
		((TextView) findViewById(R.id.network_book_series_index_key)).setText(myResource.getResource(""indexInSeries"").getValue());
		((TextView) findViewById(R.id.network_book_tags_key)).setText(myResource.getResource(""tags"").getValue());


		((TextView) findViewById(R.id.network_book_title_value)).setText(myBook.Title);

		if (myBook.Authors.size() > 0) {
			findViewById(R.id.network_book_authors).setVisibility(View.VISIBLE);
			final StringBuilder authorsText = new StringBuilder();
			for (NetworkBookItem.AuthorData author: myBook.Authors) {
				if (authorsText.length() > 0) {
					authorsText.append("", "");
				}
				authorsText.append(author.DisplayName);
			}
			((TextView) findViewById(R.id.network_book_authors_value)).setText(authorsText);
		} else {
			findViewById(R.id.network_book_authors).setVisibility(View.GONE);
		}

		if (myBook.SeriesTitle != null) {
			findViewById(R.id.network_book_series).setVisibility(View.VISIBLE);
			((TextView) findViewById(R.id.network_book_series_value)).setText(myBook.SeriesTitle);
			if (myBook.IndexInSeries > 0) {
				((TextView) findViewById(R.id.network_book_series_index_value)).setText(String.valueOf(myBook.IndexInSeries));
				findViewById(R.id.network_book_series_index).setVisibility(View.VISIBLE);
			} else {
				findViewById(R.id.network_book_series_index).setVisibility(View.GONE);
			}
		} else {
			findViewById(R.id.network_book_series).setVisibility(View.GONE);
			findViewById(R.id.network_book_series_index).setVisibility(View.GONE);
		}

		if (myBook.Tags.size() > 0) {
			findViewById(R.id.network_book_tags).setVisibility(View.VISIBLE);
			final StringBuilder tagsText = new StringBuilder();
			for (String tag: myBook.Tags) {
				if (tagsText.length() > 0) {
					tagsText.append("", "");
				}
				tagsText.append(tag);
			}
			((TextView) findViewById(R.id.network_book_tags_value)).setText(tagsText);
		} else {
			findViewById(R.id.network_book_tags).setVisibility(View.GONE);
		}
	}

	private final void setupCover() {
		final View rootView = findViewById(R.id.network_book_root);
		final ImageView coverView = (ImageView) findViewById(R.id.network_book_cover);

		final DisplayMetrics metrics = new DisplayMetrics();
		getWindowManager().getDefaultDisplay().getMetrics(metrics);

		final int maxHeight = metrics.heightPixels * 2 / 3;
		final int maxWidth = maxHeight * 2 / 3;
		Bitmap coverBitmap = null;
		final ZLImage cover = NetworkTree.createCover(myBook);
		if (cover != null) {
			ZLAndroidImageData data = null;
			final ZLAndroidImageManager mgr = (ZLAndroidImageManager)ZLAndroidImageManager.Instance();
			if (cover instanceof ZLLoadableImage) {
				final ZLLoadableImage img = (ZLLoadableImage)cover;
				img.startSynchronization(new Runnable() {
					public void run() {
						img.synchronizeFast();
						final ZLAndroidImageData data = mgr.getImageData(img);
						if (data != null) {
							final Bitmap coverBitmap = data.getBitmap(maxWidth, maxHeight);
							if (coverBitmap != null) {
								coverView.setImageBitmap(coverBitmap);
								coverView.setVisibility(View.VISIBLE);
								rootView.invalidate();
								rootView.requestLayout();
							}
						}
					}
				});
			} else {
				data = mgr.getImageData(cover);
			}
			if (data != null) {
				coverBitmap = data.getBitmap(maxWidth, maxHeight);
			}
		}
		if (coverBitmap != null) {
			coverView.setImageBitmap(coverBitmap);
			coverView.setVisibility(View.VISIBLE);
		} else {
			coverView.setVisibility(View.GONE);
		}
	}

	private final void setupButtons() {
		final ZLResource resource = ZLResource.resource(""networkView"");
		final int buttons[] = new int[] {
				R.id.network_book_button0,
				R.id.network_book_button1,
				R.id.network_book_button2,
				R.id.network_book_button3,
		};
		final Set<NetworkBookActions.Action> actions = NetworkBookActions.getContextMenuActions(myBook, myConnection);

		final boolean skipSecondButton = actions.size() < buttons.length && (actions.size() % 2) == 1;
		int buttonNumber = 0;
		for (final NetworkBookActions.Action a: actions) {
			if (skipSecondButton && buttonNumber == 1) {
				++buttonNumber;
			}
			if (buttonNumber >= buttons.length) {
				break;
			}

			final String text;
			if (a.Arg == null) {
				text = resource.getResource(a.Key).getValue();
			} else {
				text = resource.getResource(a.Key).getValue().replace(""%s"", a.Arg);
			}

			final int buttonId = buttons[buttonNumber++];
			TextView button = (TextView) findViewById(buttonId);
			button.setText(text);
			button.setVisibility(View.VISIBLE);
			button.setOnClickListener(new View.OnClickListener() {
				public void onClick(View v) {
					NetworkBookActions.runAction(NetworkBookInfoActivity.this, myBook, a.Id);
					NetworkBookInfoActivity.this.updateView();
				}
			});
			button.setEnabled(a.Id != NetworkTreeActions.TREE_NO_ACTION);
		}
		findViewById(R.id.network_book_left_spacer).setVisibility(skipSecondButton ? View.VISIBLE : View.GONE);
		findViewById(R.id.network_book_right_spacer).setVisibility(skipSecondButton ? View.VISIBLE : View.GONE);
		if (skipSecondButton) {
			final int buttonId = buttons[1];
			View button = findViewById(buttonId);
			button.setVisibility(View.GONE);
			button.setOnClickListener(null);
		}
		while (buttonNumber < buttons.length) {
			final int buttonId = buttons[buttonNumber++];
			View button = findViewById(buttonId);
			button.setVisibility(View.GONE);
			button.setOnClickListener(null);
		}
	}

	private void updateView() {
		setupButtons();
		final View rootView = findViewById(R.id.network_book_root);
		rootView.invalidate();
		rootView.requestLayout();
	}

	@Override
	protected void onStart() {
		super.onStart();
		NetworkView.Instance().addEventListener(this);
	}

	@Override
	protected void onStop() {
		NetworkView.Instance().removeEventListener(this);
		super.onStop();
	}

	public void onModelChanged() {
		updateView();
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		if (!NetworkView.Instance().isInitialized()) {
			return null;
		}
		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			return dlg.createDialog(this);
		}
		return null;
	}

	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		super.onPrepareDialog(id, dialog);

		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			dlg.prepareDialog(this, dialog);
		}		
	}
}
",False,377,0,0,8,101,1,16,L6
219,org.geometerplus.android.fbreader.network.LibraryInitializationService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.app.Service;
import android.content.Intent;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

public class LibraryInitializationService extends Service {
	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);

		final NetworkView view = NetworkView.Instance();
		if (!view.isInitialized()) {
			stopSelf();
			return;
		}

		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				if (msg.what > 0 && msg.obj == null) {
					view.finishBackgroundUpdate();
				}
				stopSelf();
			}
		};

		final Thread thread = new Thread(new Runnable() {
			public void run() {
				int code = 0;
				String error = null;
				try {
					try {
						view.runBackgroundUpdate(false);
					} catch (ZLNetworkException e) {
						error = e.getMessage();
					}
					code = 1;
				} finally {
					handler.sendMessage(handler.obtainMessage(code, error));
				}
			}
		});
		thread.setPriority(Thread.MIN_PRIORITY);
		thread.start();
	}
}
",True,378,0,0,9,109,0,2,L7
220,org.geometerplus.android.fbreader.network.UserRegistrationConstants.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

public interface UserRegistrationConstants {
	int USER_REGISTRATION_REQUEST_CODE = 12345;

	String USER_REGISTRATION_USERNAME = ""userName"";
	String USER_REGISTRATION_PASSWORD = ""password"";
	String USER_REGISTRATION_EMAIL = ""eMail"";
	String USER_REGISTRATION_LITRES_SID = ""litres:sid"";
}
",True,46,7,17,0,0,2,0,L6
221,org.geometerplus.android.fbreader.network.Util.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Map;

import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Intent;
import android.content.Context;
import android.net.Uri;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkLibrary;
import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

import org.geometerplus.android.util.PackageUtil;

abstract class Util implements UserRegistrationConstants {
	private static final String REGISTRATION_ACTION =
		""android.fbreader.action.NETWORK_LIBRARY_REGISTER"";
	private static final String SMS_REFILLING_ACTION =
		""android.fbreader.action.NETWORK_LIBRARY_SMS_REFILLING"";

	private static boolean testService(Activity activity, String action, String url) {
		return url != null && PackageUtil.canBeStarted(activity, new Intent(action, Uri.parse(url)));
	}

	static boolean isRegistrationSupported(Activity activity, INetworkLink link) {
		return testService(
			activity,
			REGISTRATION_ACTION,
			link.getLink(INetworkLink.URL_SIGN_UP)
		);
	}

	static void runRegistrationDialog(Activity activity, INetworkLink link) {
		try {
			final Intent intent = new Intent(
				REGISTRATION_ACTION,
				Uri.parse(link.getLink(INetworkLink.URL_SIGN_UP))
			);
			if (PackageUtil.canBeStarted(activity, intent)) {
				activity.startActivityForResult(new Intent(
					REGISTRATION_ACTION,
					Uri.parse(link.getLink(INetworkLink.URL_SIGN_UP))
				), USER_REGISTRATION_REQUEST_CODE);
			}
		} catch (ActivityNotFoundException e) {
		}
	}

	static void runAfterRegistration(NetworkAuthenticationManager mgr, Intent data) throws ZLNetworkException {
		final String userName = data.getStringExtra(USER_REGISTRATION_USERNAME);
		final String litresSid = data.getStringExtra(USER_REGISTRATION_LITRES_SID);
		mgr.initUser(userName, litresSid);
		if (userName.length() > 0 && litresSid.length() > 0) {
			try {
				mgr.initialize();
			} catch (ZLNetworkException e) {
				mgr.logOut();
				throw e;
			}
		}
	}

	static boolean isAccountRefillingSupported(Activity activity, INetworkLink link) {
		return
			isBrowserAccountRefillingSupported(activity, link) ||
			isSmsAccountRefillingSupported(activity, link);
	}

	static boolean isSmsAccountRefillingSupported(Activity activity, INetworkLink link) {
		return testService(
			activity,
			SMS_REFILLING_ACTION,
			link.getLink(INetworkLink.URL_MAIN)
		);
	}

	static void runSmsDialog(Activity activity, INetworkLink link) {
		try {
			final Intent intent = new Intent(
				SMS_REFILLING_ACTION,
				Uri.parse(link.getLink(INetworkLink.URL_MAIN))
			);
			final NetworkAuthenticationManager mgr = link.authenticationManager();
			if (mgr != null) {
				for (Map.Entry<String,String> entry : mgr.getSmsRefillingData().entrySet()) {
					intent.putExtra(entry.getKey(), entry.getValue());
				}
			}
			if (PackageUtil.canBeStarted(activity, intent)) {
				activity.startActivity(intent);
			}
		} catch (ActivityNotFoundException e) {
		}
	}

	static boolean isBrowserAccountRefillingSupported(Activity activity, INetworkLink link) {
		return link.getLink(INetworkLink.URL_REFILL_ACCOUNT) != null;
	}

	static void openInBrowser(Context context, String url) {
		if (url != null) {
			url = NetworkLibrary.Instance().rewriteUrl(url, true);
			context.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url)));
		}
	}
}
",True,261,7,17,13,34,5,6,L6
222,org.geometerplus.android.fbreader.network.NetworkBookActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Set;
import java.util.LinkedHashSet;
import java.io.File;

import android.app.AlertDialog;
import android.app.Activity;
import android.os.Message;
import android.os.Handler;
import android.net.Uri;
import android.content.Intent;
import android.content.DialogInterface;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.fbreader.FBReader;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;
import org.geometerplus.fbreader.network.tree.NetworkAuthorTree;
import org.geometerplus.fbreader.network.tree.NetworkSeriesTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;


class NetworkBookActions extends NetworkTreeActions {
	private static final String PACKAGE = ""org.geometerplus.android.fbreader.network"";

	public static final int DOWNLOAD_BOOK_ITEM_ID = 0;
	public static final int DOWNLOAD_DEMO_ITEM_ID = 1;
	public static final int READ_BOOK_ITEM_ID = 2;
	public static final int READ_DEMO_ITEM_ID = 3;
	public static final int DELETE_BOOK_ITEM_ID = 4;
	public static final int DELETE_DEMO_ITEM_ID = 5;
	public static final int BUY_DIRECTLY_ITEM_ID = 6;
	public static final int BUY_IN_BROWSER_ITEM_ID = 7;
	public static final int SHOW_BOOK_ACTIVITY_ITEM_ID = 8;

	public static final int SHOW_BOOKS_ITEM_ID = 9;

	private static boolean useFullReferences(NetworkBookItem book) {
		return book.reference(BookReference.Type.DOWNLOAD_FULL) != null ||
			book.reference(BookReference.Type.DOWNLOAD_FULL_CONDITIONAL) != null;
	}

	private static boolean useDemoReferences(NetworkBookItem book) {
		return book.reference(BookReference.Type.DOWNLOAD_DEMO) != null &&
			book.localCopyFileName() == null &&
			book.reference(BookReference.Type.DOWNLOAD_FULL) == null;
	}

	private static boolean useBuyReferences(NetworkBookItem book) {
		return book.localCopyFileName() == null &&
			book.reference(BookReference.Type.DOWNLOAD_FULL) == null;
	}

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof NetworkBookTree
			|| tree instanceof NetworkAuthorTree
			|| tree instanceof NetworkSeriesTree;
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(tree.getName());
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			addMenuItem(menu, SHOW_BOOKS_ITEM_ID, ""showBooks"");
			return;
		}

		final NetworkBookTree bookTree = (NetworkBookTree) tree;
		final NetworkBookItem book = bookTree.Book;

		Set<Action> actions = getContextMenuActions(book, ((NetworkBaseActivity)activity).Connection);
		for (Action a: actions) {
			if (a.Arg == null) {
				addMenuItem(menu, a.Id, a.Key);
			} else {
				addMenuItem(menu, a.Id, a.Key, a.Arg);
			}
		}
	}

	static class Action {
		public final int Id;
		public final String Key;
		public final String Arg;

		public Action(int id, String key) {
			Id = id;
			Key = key;
			Arg = null;
		}

		public Action(int id, String key, String arg) {
			Id = id;
			Key = key;
			Arg = arg;
		}
	}

	static int getBookStatus(NetworkBookItem book, BookDownloaderServiceConnection connection) {
		if (useFullReferences(book)) {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_FULL);
			if (reference != null
					&& connection != null && connection.isBeingDownloaded(reference.URL)) {
				return R.drawable.ic_list_download;
			} else if (book.localCopyFileName() != null) {
				return R.drawable.ic_list_flag;
			} else if (reference != null) {
				return R.drawable.ic_list_download;
			}
		}
		if (useBuyReferences(book)
				&& book.reference(BookReference.Type.BUY) != null
				|| book.reference(BookReference.Type.BUY_IN_BROWSER) != null) {
			return R.drawable.ic_list_buy;
		}
		return 0;
	}

	static Set<Action> getContextMenuActions(NetworkBookItem book, BookDownloaderServiceConnection connection) {
		LinkedHashSet<Action> actions = new LinkedHashSet<Action>();
		if (useFullReferences(book)) {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_FULL);
			if (reference != null
					&& connection != null && connection.isBeingDownloaded(reference.URL)) {
				actions.add(new Action(TREE_NO_ACTION, ""alreadyDownloading""));
			} else if (book.localCopyFileName() != null) {
				actions.add(new Action(READ_BOOK_ITEM_ID, ""read""));
				actions.add(new Action(DELETE_BOOK_ITEM_ID, ""delete""));
			} else if (reference != null) {
				actions.add(new Action(DOWNLOAD_BOOK_ITEM_ID, ""download""));
			}
		}
		if (useDemoReferences(book)) {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_DEMO);
			if (connection != null && connection.isBeingDownloaded(reference.URL)) {
				actions.add(new Action(TREE_NO_ACTION, ""alreadyDownloadingDemo""));
			} else if (reference.localCopyFileName(BookReference.Type.DOWNLOAD_DEMO) != null) {
				actions.add(new Action(READ_DEMO_ITEM_ID, ""readDemo""));
				actions.add(new Action(DELETE_DEMO_ITEM_ID, ""deleteDemo""));
			} else {
				actions.add(new Action(DOWNLOAD_DEMO_ITEM_ID, ""downloadDemo""));
			}
		}
		if (useBuyReferences(book)) {
			int id = TREE_NO_ACTION;
			BookReference reference = null;
			if (book.reference(BookReference.Type.BUY) != null) {
				reference = book.reference(BookReference.Type.BUY);
				id = BUY_DIRECTLY_ITEM_ID;
			} else if (book.reference(BookReference.Type.BUY_IN_BROWSER) != null) {
				reference = book.reference(BookReference.Type.BUY_IN_BROWSER);
				id = BUY_IN_BROWSER_ITEM_ID;
			}
			if (reference != null) {
				final String price = ((BuyBookReference) reference).Price;
				actions.add(new Action(id, ""buy"", price));
			}
		}
		return actions;
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			return SHOW_BOOKS_ITEM_ID;
		}
		return SHOW_BOOK_ACTIVITY_ITEM_ID;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		if (tree instanceof NetworkAuthorTree || tree instanceof NetworkSeriesTree) {
			switch (actionCode) {
			case SHOW_BOOKS_ITEM_ID:
				showBooks(activity, tree);
				return true;
			}
			return false;
		}
		return runAction(activity, ((NetworkBookTree) tree).Book, actionCode);
	}


	private void showBooks(NetworkBaseActivity activity, NetworkTree tree) {
		String key = null;
		if (tree instanceof NetworkAuthorTree) {
			key = PACKAGE + "".Authors:"" + ((NetworkAuthorTree) tree).Author.DisplayName;
		} else if (tree instanceof NetworkSeriesTree) {
			key = PACKAGE + "".Series:"" + ((NetworkSeriesTree) tree).SeriesTitle;
		}
		if (key != null) {
			NetworkView.Instance().openTree(activity, tree, key);
		}
	}

	static boolean runAction(Activity activity, NetworkBookItem book, int actionCode) {
		switch (actionCode) {
			case DOWNLOAD_BOOK_ITEM_ID:
				doDownloadBook(activity, book, false);
				return true;
			case DOWNLOAD_DEMO_ITEM_ID:
				doDownloadBook(activity, book, true);
				return true;
			case READ_BOOK_ITEM_ID:
				doReadBook(activity, book, false);
				return true;
			case READ_DEMO_ITEM_ID:
				doReadBook(activity, book, true);
				return true;
			case DELETE_BOOK_ITEM_ID:
				tryToDeleteBook(activity, book, false);
				return true;
			case DELETE_DEMO_ITEM_ID:
				tryToDeleteBook(activity, book, true);
				return true;
			case BUY_DIRECTLY_ITEM_ID:
				doBuyDirectly(activity, book);
				return true;
			case BUY_IN_BROWSER_ITEM_ID:
				doBuyInBrowser(activity, book);
				return true;
			case SHOW_BOOK_ACTIVITY_ITEM_ID:
				NetworkView.Instance().showBookInfoActivity(activity, book);
				return true;
		}
		return false;
	}

	private static void doDownloadBook(Activity activity, final NetworkBookItem book, boolean demo) {
		int resolvedType = demo ? BookReference.Type.DOWNLOAD_DEMO : BookReference.Type.DOWNLOAD_FULL;
		BookReference ref = book.reference(resolvedType);
		if (ref != null) {
			final String sslCertificate;
			if (book.Link.authenticationManager() != null) {
				sslCertificate = book.Link.authenticationManager().SSLCertificate;
			} else {
				sslCertificate = null;
			}
			activity.startService(
				new Intent(Intent.ACTION_VIEW, Uri.parse(ref.URL), 
						activity.getApplicationContext(), BookDownloaderService.class)
					.putExtra(BookDownloaderService.BOOK_FORMAT_KEY, ref.BookFormat)
					.putExtra(BookDownloaderService.REFERENCE_TYPE_KEY, resolvedType)
					.putExtra(BookDownloaderService.CLEAN_URL_KEY, ref.cleanURL())
					.putExtra(BookDownloaderService.TITLE_KEY, book.Title)
					.putExtra(BookDownloaderService.SSL_CERTIFICATE_KEY, sslCertificate)
			);
		}
	}

	private static void doReadBook(Activity activity, final NetworkBookItem book, boolean demo) {
		String local = null;
		if (!demo) {
			local = book.localCopyFileName();
		} else {
			BookReference reference = book.reference(BookReference.Type.DOWNLOAD_DEMO);
			if (reference != null) {
				local = reference.localCopyFileName(BookReference.Type.DOWNLOAD_DEMO);
			}
		}
		if (local != null) {
			activity.startActivity(
				new Intent(Intent.ACTION_VIEW,
					Uri.fromFile(new File(local)),
					activity.getApplicationContext(),
					FBReader.class
				).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
			);
		}
	}

	private static void tryToDeleteBook(Activity activity, final NetworkBookItem book, final boolean demo) {
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");
		final ZLResource boxResource = dialogResource.getResource(""deleteBookBox"");
		new AlertDialog.Builder(activity)
			.setTitle(book.Title)
			.setMessage(boxResource.getResource(""message"").getValue())
			.setIcon(0)
			.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
					// TODO: remove information about book from Library???
					if (!demo) {
						book.removeLocalFiles();
					} else {
						final BookReference reference = book.reference(BookReference.Type.DOWNLOAD_DEMO);
						if (reference != null) {
							final String fileName = reference.localCopyFileName(BookReference.Type.DOWNLOAD_DEMO);
							if (fileName != null) {
								new File(fileName).delete();
							}
						}
					}
					if (NetworkView.Instance().isInitialized()) {
						NetworkView.Instance().fireModelChangedAsync();
					}
				}
			})
			.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
			.create().show();
	}

	private static void doBuyDirectly(final Activity activity, final NetworkBookItem book) {
		final NetworkAuthenticationManager mgr = book.Link.authenticationManager();
		if (mgr == null) {
			return;
		}
		/*if (!NetworkOperationRunnable::tryConnect()) {
			return;
		}*/


		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final ZLResource buttonResource = dialogResource.getResource(""button"");

		final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				if (which == DialogInterface.BUTTON_NEGATIVE) {
					return;
				}
				if (!mgr.needPurchase(book)) {
					return;
				}
				final boolean downloadBook = which == DialogInterface.BUTTON_NEUTRAL;
				final Handler handler = new Handler() {
					public void handleMessage(Message message) {
						final ZLNetworkException exception = (ZLNetworkException)message.obj;
						if (exception != null) {
							String buttonKey;
							DialogInterface.OnClickListener action = null;
							if (NetworkException.ERROR_PURCHASE_NOT_ENOUGH_MONEY.equals(
								exception.getCode())
							) {
								buttonKey = ""refillAccount"";
								action = new DialogInterface.OnClickListener() {
									public void onClick(DialogInterface dialog, int which) {
										new RefillAccountActions().runStandalone(activity, book.Link);
									}
								};
							} else {
								buttonKey = ""ok"";
							}
							final ZLResource boxResource = dialogResource.getResource(""networkError"");
							new AlertDialog.Builder(activity)
								.setTitle(boxResource.getResource(""title"").getValue())
								.setMessage(exception.getMessage())
								.setIcon(0)
								.setPositiveButton(buttonResource.getResource(buttonKey).getValue(), action)
								.create().show();
						} else if (downloadBook) {
							doDownloadBook(activity, book, false);
						}
						if (!mgr.mayBeAuthorised(true)) {
							final NetworkLibrary library = NetworkLibrary.Instance();
							library.invalidateVisibility();
							library.synchronize();
						}
						if (NetworkView.Instance().isInitialized()) {
							NetworkView.Instance().fireModelChangedAsync();
						}
					}
				}; // end Handler
				final Runnable runnable = new Runnable() {
					public void run() {
						ZLNetworkException exception = null;
						try {
							mgr.purchaseBook(book);
						} catch (ZLNetworkException e) {
							exception = e;
						}
						handler.sendMessage(handler.obtainMessage(0, exception));
					}
				}; // end Runnable
				UIUtil.wait(""purchaseBook"", runnable, activity);
			} // end onClick
		}; // end listener

		final Runnable buyRunnable = new Runnable() {
			public void run() {
				if (!mgr.needPurchase(book)) {
					final ZLResource boxResource = dialogResource.getResource(""alreadyPurchasedBox"");
					new AlertDialog.Builder(activity)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage(boxResource.getResource(""message"").getValue())
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
					return;
				}
				final ZLResource boxResource = dialogResource.getResource(""purchaseConfirmBox"");
				new AlertDialog.Builder(activity)
					.setTitle(boxResource.getResource(""title"").getValue())
					.setMessage(boxResource.getResource(""message"").getValue().replace(""%s"", book.Title))
					.setIcon(0)
					.setPositiveButton(buttonResource.getResource(""buy"").getValue(), listener)
					.setNeutralButton(buttonResource.getResource(""buyAndDownload"").getValue(), listener)
					.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
					.create().show();
			}
		};

		try {
			if (mgr.isAuthorised(true)) {
				buyRunnable.run();
				return;
			}
		} catch (ZLNetworkException e) {
		}
		NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, book.Link, buyRunnable);
	}

	private static void doBuyInBrowser(Activity activity, final NetworkBookItem book) {
		BookReference reference = book.reference(BookReference.Type.BUY_IN_BROWSER);
		if (reference != null) {
			Util.openInBrowser(activity, reference.URL);
		}
	}

}
",True,377,0,0,7,112,3,25,L6
223,org.geometerplus.android.fbreader.network.BookDownloaderServiceConnection.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.IBinder;
import android.content.ServiceConnection;
import android.content.ComponentName;

class BookDownloaderServiceConnection implements ServiceConnection {

	private BookDownloaderInterface myInterface;

	public synchronized void onServiceConnected(ComponentName className, IBinder service) {
		myInterface = BookDownloaderInterface.Stub.asInterface(service);
	}

	public synchronized void onServiceDisconnected(ComponentName name) {
		myInterface = null;
	}

	public synchronized boolean isBeingDownloaded(String url) {
		if (myInterface != null) {
			try {
				return myInterface.isBeingDownloaded(url);
			} catch (android.os.RemoteException e) {
			}
		}
		return false;
	}
}
",True,45,6,17,0,0,3,0,L6
224,org.geometerplus.android.fbreader.network.BookDownloaderCallback.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;

public class BookDownloaderCallback extends BroadcastReceiver {

	@Override
	public void onReceive(Context context, Intent intent) {
		if (NetworkView.Instance().isInitialized()) {
			NetworkView.Instance().fireModelChangedAsync();
		}
	}
}
",False,378,0,0,9,109,0,1,L7
225,org.geometerplus.android.fbreader.network.ItemsLoadingHandler.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import android.os.Message;
import android.os.Handler;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkLibraryItem;


abstract class ItemsLoadingHandler extends Handler {

	private static final int WHAT_UPDATE_ITEMS = 0;
	private static final int WHAT_FINISHED = 1;

	private final LinkedList<NetworkLibraryItem> myItems = new LinkedList<NetworkLibraryItem>();
	private final HashMap<INetworkLink, LinkedList<NetworkLibraryItem>> myUncommitedItems = new HashMap<INetworkLink, LinkedList<NetworkLibraryItem>>();
	private final Object myItemsMonitor = new Object();

	private volatile boolean myFinishProcessed;
	private final Object myFinishMonitor = new Object();


	public final void addItem(INetworkLink link, NetworkLibraryItem item) {
		synchronized (myItemsMonitor) {
			myItems.add(item);
			LinkedList<NetworkLibraryItem> uncommited = myUncommitedItems.get(link);
			if (uncommited == null) {
				uncommited = new LinkedList<NetworkLibraryItem>();
				myUncommitedItems.put(link, uncommited);
			}
			uncommited.add(item);
		}
	}

	public final void commitItems(INetworkLink link) {
		synchronized (myItemsMonitor) {
			LinkedList<NetworkLibraryItem> uncommited = myUncommitedItems.get(link);
			if (uncommited != null) {
				uncommited.clear();
			}
		}
	}

	public final void ensureItemsProcessed() {
		synchronized (myItemsMonitor) {
			while (myItems.size() > 0) {
				try {
					myItemsMonitor.wait();
				} catch (InterruptedException e) {
				}
			}
		}
	}

	private final void doUpdateItems() {
		synchronized (myItemsMonitor) {
			onUpdateItems(myItems);
			myItems.clear();
			myItemsMonitor.notifyAll(); // wake up process, that waits for finish condition (see ensureFinish() method)
		}
		afterUpdateItems();
	}

	public final void ensureFinishProcessed() {
		synchronized (myFinishMonitor) {
			while (!myFinishProcessed) {
				try {
					myFinishMonitor.wait();
				} catch (InterruptedException e) {
				}
			}
		}
	}

	private final void doProcessFinish(String errorMessage, boolean interrupted) {
		HashSet<NetworkLibraryItem> uncommitedItems = new HashSet<NetworkLibraryItem>();
		synchronized (myUncommitedItems) {
			for (LinkedList<NetworkLibraryItem> items: myUncommitedItems.values()) {
				uncommitedItems.addAll(items);
			}
		}
		synchronized (myFinishMonitor) {
			onFinish(errorMessage, interrupted, uncommitedItems);
			myFinishProcessed = true;
			myFinishMonitor.notifyAll(); // wake up process, that waits for finish condition (see ensureFinish() method)
		}
	}


	// sending messages methods
	public final void sendUpdateItems() {
		sendEmptyMessage(WHAT_UPDATE_ITEMS);
	}

	public final void sendFinish(String errorMessage, boolean interrupted) {
		int arg1 = interrupted ? 1 : 0;
		sendMessage(obtainMessage(WHAT_FINISHED, arg1, 0, errorMessage));
	}


	// callbacks
	public abstract void onUpdateItems(List<NetworkLibraryItem> items);
	public abstract void afterUpdateItems();
	public abstract void onFinish(String errorMessage, boolean interrupted, Set<NetworkLibraryItem> uncommitedItems);


	@Override
	public final void handleMessage(Message message) {
		switch (message.what) {
		case WHAT_UPDATE_ITEMS:
			doUpdateItems();
			break;
		case WHAT_FINISHED:
			doProcessFinish((String) message.obj, message.arg1 != 0);
			break;
		}
	}
}
",False,211,6,17,14,23,3,2,L6
226,org.geometerplus.android.fbreader.network.AuthenticationDialog.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Dialog;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.view.View;
import android.widget.TextView;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

import org.geometerplus.android.util.UIUtil;


class AuthenticationDialog extends NetworkDialog {
	public AuthenticationDialog() {
		super(""AuthenticationDialog"");
	}

	@Override
	protected void clearData() {
	}

	@Override
	public View createLayout() {
		final View layout = myActivity.getLayoutInflater().inflate(R.layout.network_authentication_dialog, null);

		((TextView) layout.findViewById(R.id.network_authentication_login_text)).setText(myResource.getResource(""login"").getValue());
		((TextView) layout.findViewById(R.id.network_authentication_password_text)).setText(myResource.getResource(""password"").getValue());

		final TextView registerText = (TextView) layout.findViewById(R.id.network_authentication_register);
		registerText.setText(myResource.getResource(""register"").getValue());
		registerText.setOnClickListener(new View.OnClickListener() {
			public void onClick(View view) {
				//final NetworkAuthenticationManager mgr = myLink.authenticationManager();
				if (Util.isRegistrationSupported(myActivity, myLink)) {
					myActivity.dismissDialog(NetworkDialog.DIALOG_AUTHENTICATION);
					Util.runRegistrationDialog(myActivity, myLink);
				}
			}
		});
		return layout;
	}

	@Override
	protected void onPositive(DialogInterface dialog) {
		AlertDialog alert = (AlertDialog) dialog;
		final String login = ((TextView) alert.findViewById(R.id.network_authentication_login)).getText().toString().trim();
		final String password = ((TextView) alert.findViewById(R.id.network_authentication_password)).getText().toString();

		if (login.length() == 0) {
			final String err = myResource.getResource(""loginIsEmpty"").getValue();
			sendError(true, false, err);
			return;
		}

		final NetworkAuthenticationManager mgr = myLink.authenticationManager();
		mgr.UserNameOption.setValue(login);
		final Runnable runnable = new Runnable() {
			public void run() {
				try {
					mgr.authorise(password);
					if (mgr.needsInitialization()) {
						mgr.initialize();
					}
				} catch (ZLNetworkException e) {
					mgr.logOut();
					sendError(true, false, e.getMessage());
					return;
				}
				sendSuccess(false);
			}
		};
		UIUtil.wait(""authentication"", runnable, myActivity);
	}

	@Override
	protected void onNegative(DialogInterface dialog) {
		final NetworkAuthenticationManager mgr = myLink.authenticationManager();
		final Runnable runnable = new Runnable() {
			public void run() {
				if (mgr.mayBeAuthorised(false)) {
					mgr.logOut();
					sendCancel(false);
				}
			}
		};
		UIUtil.wait(""signOut"", runnable, myActivity);
	}

	@Override
	public void prepareDialogInternal(Dialog dialog) {
		final NetworkAuthenticationManager mgr = myLink.authenticationManager();

		((TextView) dialog.findViewById(R.id.network_authentication_login)).setText(mgr.UserNameOption.getValue());
		((TextView) dialog.findViewById(R.id.network_authentication_password)).setText("""");

		final TextView error = (TextView) dialog.findViewById(R.id.network_authentication_error);
		if (myErrorMessage == null) {
			error.setVisibility(View.GONE);
			error.setText("""");
		} else {
			error.setVisibility(View.VISIBLE);
			error.setText(myErrorMessage);
		}

		dialog.findViewById(R.id.network_authentication_register).setVisibility(Util.isRegistrationSupported(myActivity, myLink) ? View.VISIBLE : View.GONE);

		View dlgView = dialog.findViewById(R.id.network_authentication_dialog);
		dlgView.invalidate();
		dlgView.requestLayout();
	}
}
",True,377,0,0,10,110,1,8,L6
227,org.geometerplus.android.fbreader.network.NetworkCatalogActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.ArrayList;

import android.os.Bundle;
import android.view.*;
import android.widget.BaseAdapter;
import android.content.Intent;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.NetworkCatalogItem;
import org.geometerplus.fbreader.network.tree.*;

public class NetworkCatalogActivity extends NetworkBaseActivity implements UserRegistrationConstants {
	public static final String CATALOG_LEVEL_KEY = ""org.geometerplus.android.fbreader.network.CatalogLevel"";
	public static final String CATALOG_KEY_KEY = ""org.geometerplus.android.fbreader.network.CatalogKey"";

	private NetworkTree myTree;
	private String myCatalogKey;
	private boolean myInProgress;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);

		final NetworkView networkView = NetworkView.Instance();
		if (!networkView.isInitialized()) {
			finish();
			return;
		}

		final Intent intent = getIntent();
		final int level = intent.getIntExtra(CATALOG_LEVEL_KEY, -1);
		if (level == -1) {
			throw new RuntimeException(""Catalog's Level was not specified!!!"");
		}

		myCatalogKey = intent.getStringExtra(CATALOG_KEY_KEY);
		if (myCatalogKey == null) {
			throw new RuntimeException(""Catalog's Key was not specified!!!"");
		}

		myTree = networkView.getOpenedTree(level);

		networkView.setOpenedActivity(myCatalogKey, this);

		setListAdapter(new CatalogAdapter());
		getListView().invalidateViews();
		setupTitle();
		if (myTree instanceof NetworkCatalogTree &&
			Util.isAccountRefillingSupported(this, ((NetworkCatalogTree)myTree).Item.Link)) {
			setDefaultTree(new RefillAccountTree((NetworkCatalogTree)myTree));
		}
	}

	@Override
	protected void onActivityResult(int requestCode, int resultCode, Intent data) {
		switch (requestCode) {
			case USER_REGISTRATION_REQUEST_CODE:
				if (myTree instanceof NetworkCatalogTree &&
					resultCode == RESULT_OK &&
					data != null) {
					try {
						Util.runAfterRegistration(
							((NetworkCatalogTree)myTree).Item.Link.authenticationManager(),
							data
						);
					} catch (ZLNetworkException e) {
						// TODO: show an error message
					}
				}
				break;
		}
	}

	private final void setupTitle() {
		String title = null;
		final NetworkView networkView = NetworkView.Instance();
		if (networkView.isInitialized()) {
			final NetworkTreeActions actions = networkView.getActions(myTree);
			if (actions != null) {
				title = actions.getTreeTitle(myTree);
			}
		}
		if (title == null) {
			title = myTree.getName();
		}
		setTitle(title);
		setProgressBarIndeterminateVisibility(myInProgress);
	}

	private static String getNetworkTreeKey(NetworkTree tree, boolean recursive) {
		if (tree instanceof NetworkCatalogTree) {
			return ((NetworkCatalogTree) tree).Item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		} else if (tree instanceof SearchItemTree) {
			return NetworkSearchActivity.SEARCH_RUNNABLE_KEY;
		} else if (recursive && tree.Parent instanceof NetworkTree) {
			if (tree instanceof NetworkAuthorTree
					|| tree instanceof NetworkSeriesTree) {
				return getNetworkTreeKey((NetworkTree) tree.Parent, true);
			}
		}
		return null;
	}


	@Override
	public void onDestroy() {
		if (myTree != null && myCatalogKey != null && NetworkView.Instance().isInitialized()) {
			NetworkView.Instance().setOpenedActivity(myCatalogKey, null);
		}
		super.onDestroy();
	}

	@Override
	public void onResume() {
		super.onResume();
	}

	private final class CatalogAdapter extends BaseAdapter {

		private ArrayList<NetworkTree> mySpecialItems;

		public CatalogAdapter() {
			if (myTree instanceof NetworkCatalogRootTree) {
				final NetworkCatalogRootTree rootTree = (NetworkCatalogRootTree)myTree;
				mySpecialItems = new ArrayList<NetworkTree>();
				if (Util.isAccountRefillingSupported(NetworkCatalogActivity.this, rootTree.Item.Link)) {
					mySpecialItems.add(new RefillAccountTree(rootTree));
				}
				if (mySpecialItems.size() > 0) {
					mySpecialItems.trimToSize();
				} else {
					mySpecialItems = null;
				}
			}
		}

		public final int getCount() {
			return myTree.subTrees().size() +
				((mySpecialItems != null && !myInProgress) ? mySpecialItems.size() : 0);
		}

		public final NetworkTree getItem(int position) {
			if (position < 0) {
				return null;
			}
			if (position < myTree.subTrees().size()) {
				return (NetworkTree) myTree.subTrees().get(position);
			}
			if (myInProgress) {
				return null;
			}
			position -= myTree.subTrees().size();
			if (mySpecialItems != null && position < mySpecialItems.size()) {
				return mySpecialItems.get(position);
			}
			return null;
		}

		public final long getItemId(int position) {
			return position;
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final NetworkTree tree = getItem(position);
			return setupNetworkTreeItemView(convertView, parent, tree);
		}

		void onModelChanged() {
			notifyDataSetChanged();
			if (mySpecialItems != null) {
				for (NetworkTree tree: mySpecialItems) {
					tree.invalidateChildren(); // call to update secondString
				}
			}
		}
	}

	@Override
	public void onModelChanged() {
		final NetworkView networkView = NetworkView.Instance();
		final String key = getNetworkTreeKey(myTree, true);
		myInProgress = key != null && networkView.isInitialized() && networkView.containsItemsLoadingRunnable(key);
		getListView().invalidateViews();

		/*
		 * getListAdapter() always returns CatalogAdapter because onModelChanged() 
		 * can be called only after Activity's onStart() method (where NetworkView's 
		 * addEventListener() is called). Therefore CatalogAdapter will be set as 
		 * adapter in onCreate() method before any calls to onModelChanged().
		 */
		((CatalogAdapter) getListAdapter()).onModelChanged();

		setupTitle();
	}

	@Override
	public boolean onKeyDown(int keyCode, KeyEvent event)  {
		if (keyCode == KeyEvent.KEYCODE_BACK && event.getRepeatCount() == 0) {
			doStopLoading();
		}
		return super.onKeyDown(keyCode, event);
	}

	private void doStopLoading() {
		final String key = getNetworkTreeKey(myTree, false);
		if (key != null && NetworkView.Instance().isInitialized()) {
			final ItemsLoadingRunnable runnable = NetworkView.Instance().getItemsLoadingRunnable(key);
			if (runnable != null) {
				runnable.interruptLoading();
			}
		}
	}

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		return NetworkView.Instance().createOptionsMenu(menu, myTree);
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		super.onPrepareOptionsMenu(menu);
		return NetworkView.Instance().prepareOptionsMenu(this, menu, myTree);
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		if (NetworkView.Instance().runOptionsMenu(this, item, myTree)) {
			return true;
		}
		return super.onOptionsItemSelected(item);
	}
}
",True,377,0,0,9,103,3,20,L6
228,org.geometerplus.android.fbreader.network.AddCustomCatalogItemTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.fbreader.network.NetworkLibraryItem;
import org.geometerplus.fbreader.network.NetworkTree;

import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

public class AddCustomCatalogItemTree extends NetworkTree implements ZLAndroidTree {
	public AddCustomCatalogItemTree() {
		super(1);
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""addCustomCatalog"").getValue();
	}

	@Override
	public String getSummary() {
		return ZLResource.resource(""networkView"").getResource(""addCustomCatalogSummary"").getValue();
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}

	public int getCoverResourceId() {
		return R.drawable.ic_list_plus;
	}
}
",False,215,6,17,15,23,2,4,L6
229,org.geometerplus.android.fbreader.network.ItemsLoadingRunnable.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.Message;
import android.os.Handler;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkOperationData;
import org.geometerplus.fbreader.network.NetworkLibraryItem;

abstract class ItemsLoadingRunnable implements Runnable {
	private final ItemsLoadingHandler myHandler;

	private final long myUpdateInterval; // in milliseconds

	private boolean myInterruptRequested;
	private boolean myInterruptConfirmed;
	private Object myInterruptLock = new Object();

	private boolean myFinished;
	private Handler myFinishedHandler;
	private Object myFinishedLock = new Object();


	public void interruptLoading() {
		synchronized (myInterruptLock) {
			myInterruptRequested = true;
		}
	}

	private boolean confirmInterruptLoading() {
		synchronized (myInterruptLock) {
			if (myInterruptRequested) {
				myInterruptConfirmed = true;
			}
			return myInterruptConfirmed;
		}
	}

	public boolean tryResumeLoading() {
		synchronized (myInterruptLock) {
			if (!myInterruptConfirmed) {
				myInterruptRequested = false;
			}
			return !myInterruptRequested;
		}
	}

	private boolean isLoadingInterrupted() {
		synchronized (myInterruptLock) {
			return myInterruptConfirmed;
		}
	}


	public ItemsLoadingRunnable(ItemsLoadingHandler handler) {
		this(handler, 1000);
	}

	public ItemsLoadingRunnable(ItemsLoadingHandler handler, long updateIntervalMillis) {
		myHandler = handler;
		myUpdateInterval = updateIntervalMillis;
	}

	public abstract void doBefore() throws ZLNetworkException;
	public abstract void doLoading(NetworkOperationData.OnNewItemListener doWithListener) throws ZLNetworkException;

	public abstract String getResourceKey();

	public final void run() {
		try {
			doBefore();
		} catch (ZLNetworkException e) {
			myHandler.sendFinish(e.getMessage(), false);
			return;
		}
		String error = null;
		try {
			doLoading(new NetworkOperationData.OnNewItemListener() {
				private long myUpdateTime;
				private int myItemsNumber;
				public void onNewItem(INetworkLink link, NetworkLibraryItem item) {
					myHandler.addItem(link, item);
					++myItemsNumber;
					final long now = System.currentTimeMillis();
					if (now > myUpdateTime) {
						myHandler.sendUpdateItems();
						myUpdateTime = now + myUpdateInterval;
					}
				}
				public boolean confirmInterrupt() {
					return confirmInterruptLoading();
				}
				public void commitItems(INetworkLink link) {
					myHandler.commitItems(link);
				}
			});
		} catch (ZLNetworkException e) {
			error = e.getMessage();
		}

		myHandler.sendUpdateItems();
		myHandler.ensureItemsProcessed();
		myHandler.sendFinish(error, isLoadingInterrupted());
		myHandler.ensureFinishProcessed();
	}

	void runFinishHandler() {
		synchronized (myFinishedLock) {
			if (myFinishedHandler != null) {
				myFinishedHandler.sendEmptyMessage(0);
			}
			myFinished = true;
		}
	}


	public void runOnFinish(final Runnable runnable) {
		if (myFinishedHandler != null) {
			return;
		}
		synchronized (myFinishedLock) {
			if (myFinished) {
				runnable.run();
			} else {
				myFinishedHandler = new Handler() {
					public void handleMessage(Message message) {
						runnable.run();
					}
				};
			}
		}
	}
}
",True,211,6,17,14,24,5,5,L6
230,org.geometerplus.android.fbreader.network.RefillAccountTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkLibraryItem;
import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.tree.NetworkCatalogTree;
import org.geometerplus.fbreader.network.authentication.NetworkAuthenticationManager;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

class RefillAccountTree extends NetworkTree implements ZLAndroidTree {
	public final INetworkLink Link;

	public RefillAccountTree(NetworkCatalogTree parentTree) {
		super(parentTree.Level + 1);
		Link = parentTree.Item.Link;
	}

	public RefillAccountTree(INetworkLink link) {
		super(1);
		Link = link;
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""refillTitle"").getValue();
	}

	@Override
	public String getSummary() {
		final NetworkAuthenticationManager mgr = Link.authenticationManager();
		try {
			if (mgr.isAuthorised(false)) {
				final String account = mgr.currentAccount();
				if (account != null) {
					return ZLResource.resource(""networkView"").getResource(""refillSummary"").getValue().replace(""%s"", account);
				}
			}
		} catch (ZLNetworkException e) {
		}
		return null;
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}

	public int getCoverResourceId() {
		return R.drawable.ic_list_library_wallet;
	}
}
",False,220,7,17,13,24,4,9,L6
231,org.geometerplus.android.fbreader.network.SearchItemActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.SearchResult;


class SearchItemActions extends NetworkTreeActions {

	public static final int RUN_SEARCH_ITEM_ID = 0;


	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof SearchItemTree;
	}

	@Override
	public String getTreeTitle(NetworkTree tree) {
		final SearchResult result = ((SearchItemTree) tree).getSearchResult();
		if (result != null) {
			return result.Summary;
		}
		return tree.getName();
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		menu.setHeaderTitle(tree.getName());

		final boolean isLoading = NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY);

		if (!isLoading) {
			addMenuItem(menu, RUN_SEARCH_ITEM_ID, ""search"");
		} else {
			addMenuItem(menu, TREE_NO_ACTION, ""stoppingNetworkSearch"");
		}
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		final boolean isLoading = NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY);
		if (!isLoading) {
			return RUN_SEARCH_ITEM_ID;
		}
		return TREE_NO_ACTION;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		switch (actionCode) {
			case RUN_SEARCH_ITEM_ID:
				activity.onSearchRequested();
				return true;
		}
		return false;
	}
}
",False,377,0,0,9,108,1,8,L6
232,org.geometerplus.android.fbreader.network.SearchItemTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.Set;
import java.util.LinkedList;
import java.util.ListIterator;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.tree.FBTree;
import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkAuthorTree;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

public class SearchItemTree extends NetworkTree implements ZLAndroidTree {

	private SearchResult myResult;

	public SearchItemTree() {
		super(1);
	}

	@Override
	public String getName() {
		return ZLResource.resource(""networkView"").getResource(""search"").getValue();
	}

	@Override
	public String getSummary() {
		return ZLResource.resource(""networkView"").getResource(""searchSummary"").getValue();
	}

	public int getCoverResourceId() {
		return R.drawable.ic_list_searchresult;
	}

	public void setSearchResult(SearchResult result) {
		myResult = result;
		clear();
	}

	public SearchResult getSearchResult() {
		return myResult;
	}

	public void updateSubTrees() {
		ListIterator<FBTree> nodeIterator = subTrees().listIterator();

		final Set<NetworkBookItem.AuthorData> authorsSet = myResult.BooksMap.keySet();

		for (NetworkBookItem.AuthorData author: authorsSet) {
			if (nodeIterator != null) {
				if (nodeIterator.hasNext()) {
					FBTree currentNode = nodeIterator.next();
					if (!(currentNode instanceof NetworkAuthorTree)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					NetworkAuthorTree child = (NetworkAuthorTree) currentNode;
					if (!child.Author.equals(author)) {
						throw new RuntimeException(""That's impossible!!!"");
					}
					LinkedList<NetworkBookItem> authorBooks = myResult.BooksMap.get(author);
					child.updateSubTrees(authorBooks);
					continue;
				}
				nodeIterator = null;
			}

			LinkedList<NetworkBookItem> authorBooks = myResult.BooksMap.get(author);
			if (authorBooks.size() != 0) {
				NetworkAuthorTree child = new NetworkAuthorTree(this, author);
				child.updateSubTrees(authorBooks);
			}
		}
		if (nodeIterator != null && nodeIterator.hasNext()) {
			throw new RuntimeException(""That's impossible!!!"");
		}
	}

	@Override
	public NetworkLibraryItem getHoldedItem() {
		return null;
	}
}
",False,219,6,17,14,23,4,9,L6
233,org.geometerplus.android.fbreader.network.NetworkNotifications.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

class NetworkNotifications {
	private static NetworkNotifications ourInstance;

	public static NetworkNotifications Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkNotifications();
		}
		return ourInstance;
	}

	//private static final int CATALOG_LOADING = 0;
	//private static final int NETWORK_SEARCH = 1;

	private static final int BOOK_DOWNLOADING_START = 0x10000000;
	private static final int BOOK_DOWNLOADING_END   = 0x1fffffff;

	private volatile int myBookDownloadingId = BOOK_DOWNLOADING_START;

	private NetworkNotifications() {
	}

	/*public int getCatalogLoadingId() {
		return CATALOG_LOADING;
	}*/

	/*public int getNetworkSearchId() {
		return NETWORK_SEARCH;
	}*/

	public synchronized int getBookDownloadingId() {
		final int id = myBookDownloadingId;
		if (myBookDownloadingId == BOOK_DOWNLOADING_END) {
			myBookDownloadingId = BOOK_DOWNLOADING_START;
		} else {
			++myBookDownloadingId;
		}
		return id;
	}
}
",False,45,5,28,0,0,1,0,L6
234,org.geometerplus.android.fbreader.network.NetworkSearchActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.List;
import java.util.Set;

import android.app.AlertDialog;
import android.app.Activity;
import android.app.SearchManager;
import android.os.Bundle;
import android.content.Intent;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;


public class NetworkSearchActivity extends Activity {

	public static final String SEARCH_RUNNABLE_KEY = ""org.geometerplus.android.fbreader.network.NetworkSearchActivity"";

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		if (!NetworkView.Instance().isInitialized()) {
			finish();
		}

		final Intent intent = getIntent();
		if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
			final String pattern = intent.getStringExtra(SearchManager.QUERY);
			runSearch(pattern);
		}
		finish();
	}

	private class SearchHandler extends ItemsLoadingHandler {

		private final SearchItemTree myTree;

		public SearchHandler(SearchItemTree tree) {
			myTree = tree;
		}

		@Override
		public void onUpdateItems(List<NetworkLibraryItem> items) {
			SearchResult result = myTree.getSearchResult();
			for (NetworkLibraryItem item: items) {
				if (item instanceof NetworkBookItem) {
					result.addBook((NetworkBookItem) item);
				}
			}
		}

		@Override
		public void afterUpdateItems() {
			myTree.updateSubTrees();
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		@Override
		public void onFinish(String errorMessage, boolean interrupted,
				Set<NetworkLibraryItem> uncommitedItems) {
			if (interrupted) {
				myTree.setSearchResult(null);
			} else {
				myTree.updateSubTrees();
				afterUpdateCatalog(errorMessage, myTree.getSearchResult().empty());
			}
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
			final ZLResource dialogResource = ZLResource.resource(""dialog"");
			ZLResource boxResource = null;
			String msg = null;
			if (errorMessage != null) {
				boxResource = dialogResource.getResource(""networkError"");
				msg = errorMessage;
			} else if (childrenEmpty) {
				boxResource = dialogResource.getResource(""emptySearchResults"");
				msg = boxResource.getResource(""message"").getValue();
			}
			if (msg != null) {
				if (NetworkView.Instance().isInitialized()) {
					final NetworkCatalogActivity activity = NetworkView.Instance().getOpenedActivity(SEARCH_RUNNABLE_KEY);
					if (activity != null) {
						final ZLResource buttonResource = dialogResource.getResource(""button"");
						new AlertDialog.Builder(activity)
							.setTitle(boxResource.getResource(""title"").getValue())
							.setMessage(msg)
							.setIcon(0)
							.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
							.create().show();
					}
				}
			}
		}
	}

	private static class SearchRunnable extends ItemsLoadingRunnable {
		private final String myPattern;

		public SearchRunnable(ItemsLoadingHandler handler, String pattern) {
			super(handler);
			myPattern = pattern;
		}

		public String getResourceKey() {
			return ""searchingNetwork"";
		}

		public void doBefore() {
		}

		public void doLoading(NetworkOperationData.OnNewItemListener doWithListener) throws ZLNetworkException {
			NetworkLibrary.Instance().simpleSearch(myPattern, doWithListener);
		}
	}

	protected void runSearch(final String pattern) {
		final NetworkLibrary library = NetworkLibrary.Instance();
		library.NetworkSearchPatternOption.setValue(pattern);

		if (NetworkView.Instance().containsItemsLoadingRunnable(SEARCH_RUNNABLE_KEY)) {
			return;
		}

		final String summary = ZLResource.resource(""networkView"").getResource(""searchResults"").getValue().replace(""%s"", pattern);
		final SearchResult result = new SearchResult(summary);

		final SearchItemTree tree = NetworkView.Instance().getSearchItemTree();

		tree.setSearchResult(result);
		NetworkView.Instance().fireModelChangedAsync();

		final SearchHandler handler = new SearchHandler(tree);
		NetworkView.Instance().startItemsLoading(
			this,
			SEARCH_RUNNABLE_KEY,
			new SearchRunnable(handler, pattern)
		);
		NetworkView.Instance().openTree(this, tree, SEARCH_RUNNABLE_KEY);
	}
}
",True,377,0,0,9,93,3,14,L6
235,org.geometerplus.android.fbreader.network.NetworkDialog.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.TreeMap;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.Dialog;
import android.content.DialogInterface;
import android.os.Handler;
import android.os.Message;
import android.view.View;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.INetworkLink;
import org.geometerplus.fbreader.network.NetworkLibrary;


abstract class NetworkDialog {

	// dialog identifiers
	public static final int DIALOG_AUTHENTICATION = 0;
	public static final int DIALOG_CUSTOM_CATALOG = 1;

	private static final TreeMap<Integer, NetworkDialog> ourInstances = new TreeMap<Integer, NetworkDialog>();

	public static NetworkDialog getDialog(int id) {
		NetworkDialog dlg = ourInstances.get(Integer.valueOf(id));
		if (dlg == null) {
			switch (id) {
			case DIALOG_AUTHENTICATION:
				dlg = new AuthenticationDialog();
				break;
			case DIALOG_CUSTOM_CATALOG:
				dlg = new CustomCatalogDialog();
				break;
			}
			if (dlg != null) {
				dlg.myId = id;
				ourInstances.put(Integer.valueOf(id), dlg);
			}
		}
		return dlg;
	}


	private class DialogHandler extends Handler {

		public Message obtainMessage(int code, boolean invalidateLibrary, String message) {
			return obtainMessage(code, invalidateLibrary ? 1 : 0, 0, message);
		}

		@Override
		public void handleMessage(Message message) {
			if (!NetworkView.Instance().isInitialized()) {
				return;
			}
			final NetworkLibrary library = NetworkLibrary.Instance();
			if (message.arg1 != 0) {
				library.invalidateChildren();
			}
			library.invalidateVisibility();
			library.synchronize();
			NetworkView.Instance().fireModelChanged();
			if (message.what < 0) {
				if (message.what == -2) {
					final ZLResource dialogResource = ZLResource.resource(""dialog"");
					final ZLResource boxResource = dialogResource.getResource(""networkError"");
					final ZLResource buttonResource = dialogResource.getResource(""button"");
					new AlertDialog.Builder(myActivity)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage((String) message.obj)
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
				} else {
					myErrorMessage = (String) message.obj;
					myActivity.showDialog(myId);
					return;
				}
			} else if (message.what > 0) {
				if (myOnSuccessRunnable != null) {
					myOnSuccessRunnable.run();
				}
			}
			clearData();
		}
	};


	protected final ZLResource myResource;

	protected int myId; 

	protected INetworkLink myLink;
	protected String myErrorMessage;
	protected Runnable myOnSuccessRunnable;
	protected Activity myActivity;

	protected final DialogHandler myHandler = new DialogHandler();

	public NetworkDialog(String key) {
		myResource = ZLResource.resource(""dialog"").getResource(key);
	}

	public static void show(Activity activity, int id, INetworkLink link, Runnable onSuccessRunnable) {
		getDialog(id).showInternal(activity, link, onSuccessRunnable);
	}

	private void showInternal(Activity activity, INetworkLink link, Runnable onSuccessRunnable) {
		myLink = link;
		myErrorMessage = null;
		myOnSuccessRunnable = onSuccessRunnable;
		activity.showDialog(myId);
	}


	protected void sendSuccess(boolean invalidateLibrary) {
		myHandler.sendMessage(myHandler.obtainMessage(1, invalidateLibrary, null));
	}

	protected void sendCancel(boolean invalidateLibrary) {
		myHandler.sendMessage(myHandler.obtainMessage(0, invalidateLibrary, null));
	}

	protected void sendError(boolean restart, boolean invalidateLibrary, String message) {
		myHandler.sendMessage(myHandler.obtainMessage(restart ? -1 : -2, invalidateLibrary, message));
	}

	protected abstract View createLayout();
	protected abstract void clearData();

	protected abstract void onPositive(DialogInterface dialog);
	protected abstract void onNegative(DialogInterface dialog);

	public final Dialog createDialog(final Activity activity) {
		myActivity = activity;
		final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				if (which == DialogInterface.BUTTON_POSITIVE) {
					onPositive(dialog);
				} else {
					onNegative(dialog);
				}
			}
		};

		final View layout = createLayout();
		final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
		return new AlertDialog.Builder(activity)
			.setView(layout)
			.setTitle(myResource.getResource(""title"").getValue())
			.setPositiveButton(buttonResource.getResource(""ok"").getValue(), listener)
			.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
			.setOnCancelListener(new DialogInterface.OnCancelListener() {
				public void onCancel(DialogInterface dialog) {
					onNegative(dialog);
				}
			})
			.create();
	}

	public final void prepareDialog(final Activity activity, Dialog dialog) {
		myActivity = activity;
		prepareDialogInternal(dialog);
	}

	protected abstract void prepareDialogInternal(Dialog dialog);
}
",False,377,0,0,9,93,8,6,L6
236,org.geometerplus.android.fbreader.network.ItemsLoadingService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.os.IBinder;
import android.os.Handler;
import android.os.Message;
import android.app.Service;
import android.content.Intent;


public class ItemsLoadingService extends Service {

	public static final String ITEMS_LOADING_RUNNABLE_KEY = ""org.geometerplus.android.fbreader.network.ItemsLoadingRunnable"";

	private volatile int myServiceCounter;

	private void doStart() {
		++myServiceCounter;
	}

	private void doStop() {
		if (--myServiceCounter == 0) {
			stopSelf();
		}
	}


	@Override
	public IBinder onBind(Intent intent) {
		return null;
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		doStart();

		final String key = intent.getStringExtra(ITEMS_LOADING_RUNNABLE_KEY);
		if (key == null) {
			doStop();
			return;
		}
		intent.removeExtra(ITEMS_LOADING_RUNNABLE_KEY);

		if (!NetworkView.Instance().isInitialized()) {
			doStop();
			return;
		}
		final ItemsLoadingRunnable runnable = NetworkView.Instance().getItemsLoadingRunnable(key);
		if (runnable == null) {
			doStop();
			return;
		}

		final Handler finishHandler = new Handler() {
			public void handleMessage(Message message) {
				doStop();
				if (NetworkView.Instance().isInitialized()) {
					NetworkView.Instance().removeItemsLoadingRunnable(key);
					NetworkView.Instance().fireModelChangedAsync();
				}
			}
		};

		NetworkView.Instance().fireModelChangedAsync(); // this call is needed to show indeterminate progress bar in title right on downloading start

		final Thread loader = new Thread(new Runnable() {
			public void run() {
				try {
					runnable.run();
				} finally {
					finishHandler.sendEmptyMessage(0);
				}
			}
		});
		loader.setPriority(Thread.MIN_PRIORITY);
		loader.start();
	}
}
",True,377,0,0,9,109,1,2,L6
237,org.geometerplus.android.fbreader.network.NetworkView.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.ArrayList;

import android.content.Context;
import android.content.Intent;
import android.os.Handler;
import android.os.Message;
import android.view.MenuItem;
import android.view.Menu;

import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.fbreader.network.*;

class NetworkView {
	private static NetworkView ourInstance;

	public static NetworkView Instance() {
		if (ourInstance == null) {
			ourInstance = new NetworkView();
		}
		return ourInstance;
	}

	private NetworkView() {
	}


	private volatile boolean myInitialized;

	public boolean isInitialized() {
		return myInitialized;
	}

	public void initialize() throws ZLNetworkException {
		new SQLiteNetworkDatabase();

		final NetworkLibrary library = NetworkLibrary.Instance();
		library.initialize();
		library.synchronize();

		myActions.add(new NetworkBookActions());
		myActions.add(new NetworkCatalogActions());
		myActions.add(new SearchItemActions());
		myActions.add(new RefillAccountActions());
		myActions.add(new AddCustomCatalogItemActions());
		myActions.trimToSize();

		myInitialized = true;
	}

	public void runBackgroundUpdate(boolean clearCache) throws ZLNetworkException {
		NetworkLibrary.Instance().runBackgroundUpdate(clearCache);
	}

	// This method MUST be called from main thread
	// This method has effect only when runBackgroundUpdate method has returned null
	public void finishBackgroundUpdate() {
		NetworkLibrary library = NetworkLibrary.Instance();
		library.finishBackgroundUpdate();
		library.synchronize();
		fireModelChanged();
	}

	/*
	 * NetworkLibraryItem's actions
	 */

	private final ArrayList<NetworkTreeActions> myActions = new ArrayList<NetworkTreeActions>();

	public NetworkTreeActions getActions(NetworkTree tree) {
		for (NetworkTreeActions actions: myActions) {
			if (actions.canHandleTree(tree)) {
				return actions;
			}
		}
		return null;
	}

	/*
	 * OptionsMenu methods
	 */

	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		if (!isInitialized()) {
			return false;
		}
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.createOptionsMenu(menu, tree);
		}
		return false;
	}

	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		if (!isInitialized()) {
			return false;
		}
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.prepareOptionsMenu(activity, menu, tree);
		}
		return false;
	}

	public boolean runOptionsMenu(NetworkBaseActivity activity, MenuItem item, NetworkTree tree) {
		if (!isInitialized()) {
			return false;
		}
		final NetworkTreeActions actions = getActions(tree);
		if (actions != null) {
			return actions.runAction(activity, tree, item.getItemId());
		}
		return false;
	}

	/*
	 * Code for loading network items (running items-loading service and managing items-loading runnables).
	 */

	private final HashMap<String, ItemsLoadingRunnable> myItemsLoadingRunnables = new HashMap<String, ItemsLoadingRunnable>();

	public void startItemsLoading(Context context, String key, ItemsLoadingRunnable runnable) {
		boolean doDownload = false;
		synchronized (myItemsLoadingRunnables) {
			if (!myItemsLoadingRunnables.containsKey(key)) {
				myItemsLoadingRunnables.put(key, runnable);
				doDownload = true;
			}
		}
		if (doDownload) {
			context.startService(
				new Intent(context.getApplicationContext(), ItemsLoadingService.class)
					.putExtra(ItemsLoadingService.ITEMS_LOADING_RUNNABLE_KEY, key)
			);
		}
	}

	ItemsLoadingRunnable getItemsLoadingRunnable(String key) {
		synchronized (myItemsLoadingRunnables) {
			return myItemsLoadingRunnables.get(key);
		}
	}

	void removeItemsLoadingRunnable(String key) {
		synchronized (myItemsLoadingRunnables) {
			ItemsLoadingRunnable runnable = myItemsLoadingRunnables.remove(key);
			if (runnable != null) {
				runnable.runFinishHandler();
			}
		}
	}

	public final boolean containsItemsLoadingRunnable(String key) {
		return getItemsLoadingRunnable(key) != null;
	}

	public void tryResumeLoading(NetworkBaseActivity activity, NetworkTree tree, String key, Runnable expandRunnable) {
		final ItemsLoadingRunnable runnable = getItemsLoadingRunnable(key);
		if (runnable != null && runnable.tryResumeLoading()) {
			openTree(activity, tree, key);
			return;
		}
		if (runnable == null) {
			expandRunnable.run();
		} else {
			runnable.runOnFinish(expandRunnable);
		}
	}


	/*
	 * Notifying view's components from services
	 */

	public interface EventListener {
		void onModelChanged();
	}

	private Handler myEventHandler;
	private LinkedList<EventListener> myEventListeners = new LinkedList<EventListener>();

	/*
	 * This method must be called only from main thread
	 */
	public final void addEventListener(EventListener listener) {
		synchronized (myEventListeners) {
			if (myEventHandler == null) {
				myEventHandler = new Handler() {
					@Override
					public void handleMessage(Message msg) {
						fireModelChanged();
					}
				};
			}
			if (listener != null) {
				myEventListeners.add(listener);
			}
		}
	}

	public final void removeEventListener(EventListener listener) {
		synchronized (myEventListeners) {
			myEventListeners.remove(listener);
		}
	}

	final void fireModelChangedAsync() {
		synchronized (myEventListeners) {
			if (myEventHandler != null) {
				myEventHandler.sendEmptyMessage(0);
			}
		}
	}

	final void fireModelChanged() {
		for (EventListener listener: myEventListeners) {
			listener.onModelChanged();
		}
	}


	/*
	 * Starting BookInfo activity
	 */

	private NetworkBookItem myBookInfoItem;

	public void showBookInfoActivity(Context context, NetworkBookItem book) {
		myBookInfoItem = book;
		context.startActivity(
			new Intent(context.getApplicationContext(), NetworkBookInfoActivity.class)
		);
	}

	NetworkBookItem getBookInfoItem() {
		return myBookInfoItem;
	}


	/*
	 * Opening Catalogs & managing opened catalogs stack
	 */

	private final LinkedList<NetworkTree> myOpenedStack = new LinkedList<NetworkTree>();
	private final HashMap<String, NetworkCatalogActivity> myOpenedActivities = new HashMap<String, NetworkCatalogActivity>();

	public void openTree(Context context, NetworkTree tree, String key) {
		final int level = tree.Level - 1; // tree.Level == 1 for catalog's root element
		if (level > myOpenedStack.size()) {
			throw new RuntimeException(""Unable to open catalog with Level greater than the number of opened catalogs.\n""
				+ ""Catalog: "" + tree.getName() + ""\n""
				+ ""Level: "" + level + ""\n""
				+ ""Opened catalogs: "" + myOpenedStack.size());
		}
		while (level < myOpenedStack.size()) {
			myOpenedStack.removeLast();
		}
		myOpenedStack.add(tree);

		context.startActivity(
			new Intent(context.getApplicationContext(), NetworkCatalogActivity.class)
				.putExtra(NetworkCatalogActivity.CATALOG_LEVEL_KEY, level)
				.putExtra(NetworkCatalogActivity.CATALOG_KEY_KEY, key)
		);
	}

	void setOpenedActivity(String key, NetworkCatalogActivity activity) {
		if (activity == null) {
			myOpenedActivities.remove(key);
		} else {
			myOpenedActivities.put(key, activity);
		}
	}

	public NetworkCatalogActivity getOpenedActivity(String key) {
		return myOpenedActivities.get(key);
	}

	public NetworkTree getOpenedTree(int level) {
		if (level < 0 || level >= myOpenedStack.size()) {
			return null;
		}
		return myOpenedStack.get(level);
	}

	/*
	 * Special view items item
	 */

	private final SearchItemTree mySearchItem = new SearchItemTree();
	private final AddCustomCatalogItemTree myAddCustomCatalogItem = new AddCustomCatalogItemTree();

	public SearchItemTree getSearchItemTree() {
		return mySearchItem;
	}

	public AddCustomCatalogItemTree getAddCustomCatalogItemTree() {
		return myAddCustomCatalogItem;
	}
}
",True,379,1,2,8,109,12,19,L6
238,org.geometerplus.android.fbreader.network.BookDownloaderService.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;
import java.io.*;
import java.net.URLConnection;

import android.os.IBinder;
import android.os.Handler;
import android.os.Message;
import android.app.Service;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.net.Uri;
import android.content.Intent;
import android.widget.RemoteViews;
import android.widget.Toast;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.*;

import org.geometerplus.fbreader.network.BookReference;

import org.geometerplus.android.fbreader.FBReader;

public class BookDownloaderService extends Service {
	public static final String BOOK_FORMAT_KEY = ""org.geometerplus.android.fbreader.network.BookFormat"";
	public static final String REFERENCE_TYPE_KEY = ""org.geometerplus.android.fbreader.network.ReferenceType"";
	public static final String CLEAN_URL_KEY = ""org.geometerplus.android.fbreader.network.CleanURL"";
	public static final String TITLE_KEY = ""org.geometerplus.android.fbreader.network.Title"";
	public static final String SSL_CERTIFICATE_KEY = ""org.geometerplus.android.fbreader.network.SSLCertificate"";

	public static final String SHOW_NOTIFICATIONS_KEY = ""org.geometerplus.android.fbreader.network.ShowNotifications"";

	public interface Notifications {
		int DOWNLOADING_STARTED = 0x0001;
		int ALREADY_DOWNLOADING = 0x0002;

		int ALL = 0x0003;
	}


	private Set<String> myDownloadingURLs = Collections.synchronizedSet(new HashSet<String>());
	private Set<Integer> myOngoingNotifications = new HashSet<Integer>();

	private volatile int myServiceCounter;

	private void doStart() {
		++myServiceCounter;
	}

	private void doStop() {
		if (--myServiceCounter == 0) {
			stopSelf();
		}
	}

	public static ZLResource getResource() {
		return ZLResource.resource(""bookDownloader"");
	}

	@Override
	public IBinder onBind(Intent intent) {
		return new BookDownloaderInterface.Stub() {
			public boolean isBeingDownloaded(String url) {
				return myDownloadingURLs.contains(url);
			}
		};
	}

	@Override
	public void onDestroy() {
		final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		for (int notificationId: myOngoingNotifications) {
			notificationManager.cancel(notificationId);
		}
		myOngoingNotifications.clear();
		super.onDestroy();
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		doStart();

		final Uri uri = intent.getData();
		if (uri == null) {
			doStop();
			return;
		}
		intent.setData(null);

		final int notifications = intent.getIntExtra(SHOW_NOTIFICATIONS_KEY, 0);

		final String url = uri.toString();
		final int bookFormat = intent.getIntExtra(BOOK_FORMAT_KEY, BookReference.Format.NONE);
		final int referenceType = intent.getIntExtra(REFERENCE_TYPE_KEY, BookReference.Type.UNKNOWN);
		String cleanURL = intent.getStringExtra(CLEAN_URL_KEY);
		if (cleanURL == null) {
			cleanURL = url;
		}

		if (myDownloadingURLs.contains(url)) {
			if ((notifications & Notifications.ALREADY_DOWNLOADING) != 0) {
				showMessage(""alreadyDownloading"");
			}
			doStop();
			return;
		}

		String fileName = BookReference.makeBookFileName(cleanURL, bookFormat, referenceType);
		if (fileName == null) {
			doStop();
			return;
		}

		int index = fileName.lastIndexOf(File.separator);
		if (index != -1) {
			final String dir = fileName.substring(0, index);
			final File dirFile = new File(dir);
			if (!dirFile.exists() && !dirFile.mkdirs()) {
				showMessage(""cannotCreateDirectory"", dirFile.getPath());
				doStop();
				return;
			}
			if (!dirFile.exists() || !dirFile.isDirectory()) {
				showMessage(""cannotCreateDirectory"", dirFile.getPath());
				doStop();
				return;
			}
		}

		final File fileFile = new File(fileName);
		if (fileFile.exists()) {
			if (!fileFile.isFile()) {
				showMessage(""cannotCreateFile"", fileFile.getPath());
				doStop();
				return;
			}
			// TODO: question box: redownload?
			doStop();
			startActivity(getFBReaderIntent(fileFile));
			return;
		}
		String title = intent.getStringExtra(TITLE_KEY);
		if (title == null || title.length() == 0) {
			title = fileFile.getName();
		}
		if ((notifications & Notifications.DOWNLOADING_STARTED) != 0) {
			showMessage(""downloadingStarted"");
		}
		final String sslCertificate = intent.getStringExtra(SSL_CERTIFICATE_KEY);
		startFileDownload(url, sslCertificate, fileFile, title);
	}

	private void showMessage(String key) {
		Toast.makeText(
			getApplicationContext(),
			getResource().getResource(key).getValue(),
			Toast.LENGTH_SHORT
		).show();
	}

	private void showMessage(String key, String parameter) {
		Toast.makeText(
			getApplicationContext(),
			getResource().getResource(key).getValue().replace(""%s"", parameter),
			Toast.LENGTH_SHORT
		).show();
	}

	private Intent getFBReaderIntent(final File file) {
		final Intent intent = new Intent(getApplicationContext(), FBReader.class);
		if (file != null) {
			intent.setAction(Intent.ACTION_VIEW).setData(Uri.fromFile(file));
		}
		return intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_NEW_TASK);
	}

	private Notification createDownloadFinishNotification(File file, String title, boolean success) {
		final ZLResource resource = getResource();
		final String tickerText = success ?
			resource.getResource(""tickerSuccess"").getValue() :
			resource.getResource(""tickerError"").getValue();
		final String contentText = success ?
			resource.getResource(""contentSuccess"").getValue() :
			resource.getResource(""contentError"").getValue();
		final Notification notification = new Notification(
			android.R.drawable.stat_sys_download_done,
			tickerText,
			System.currentTimeMillis()
		);
		notification.flags |= Notification.FLAG_AUTO_CANCEL;
		final Intent intent = success ? getFBReaderIntent(file) : new Intent();
		final PendingIntent contentIntent = PendingIntent.getActivity(this, 0, intent, 0);
		notification.setLatestEventInfo(getApplicationContext(), title, contentText, contentIntent);
		return notification;
	}

	private Notification createDownloadProgressNotification(String title) {
		final RemoteViews contentView = new RemoteViews(getPackageName(), R.layout.download_notification);
		contentView.setTextViewText(R.id.download_notification_title, title);
		contentView.setTextViewText(R.id.download_notification_progress_text, """");
		contentView.setProgressBar(R.id.download_notification_progress_bar, 100, 0, true);

		final PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(), 0);

		final Notification notification = new Notification();
		notification.icon = android.R.drawable.stat_sys_download;
		notification.flags |= Notification.FLAG_ONGOING_EVENT;
		notification.contentView = contentView;
		notification.contentIntent = contentIntent;

		return notification;
	}

	private void sendDownloaderCallback() {
		sendBroadcast(
			new Intent(getApplicationContext(), BookDownloaderCallback.class)
		);
	}

	private void startFileDownload(final String urlString, final String sslCertificate, final File file, final String title) {
		myDownloadingURLs.add(urlString);
		sendDownloaderCallback();

		final int notificationId = NetworkNotifications.Instance().getBookDownloadingId();
		final Notification progressNotification = createDownloadProgressNotification(title);

		final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
		myOngoingNotifications.add(Integer.valueOf(notificationId));
		notificationManager.notify(notificationId, progressNotification);

		final Handler progressHandler = new Handler() {
			public void handleMessage(Message message) {
				final int progress = message.what;
				final RemoteViews contentView = (RemoteViews)progressNotification.contentView;

				if (progress < 0) {
					contentView.setTextViewText(R.id.download_notification_progress_text, """");
					contentView.setProgressBar(R.id.download_notification_progress_bar, 100, 0, true);
				} else {
					contentView.setTextViewText(R.id.download_notification_progress_text, """" + progress + ""%"");
					contentView.setProgressBar(R.id.download_notification_progress_bar, 100, progress, false);
				}
				final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
				notificationManager.notify(notificationId, progressNotification);
			}
		};

		final Handler downloadFinishHandler = new Handler() {
			public void handleMessage(Message message) {
				myDownloadingURLs.remove(urlString);
				final NotificationManager notificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);
				notificationManager.cancel(notificationId);
				myOngoingNotifications.remove(Integer.valueOf(notificationId));
				notificationManager.notify(
					notificationId,
					createDownloadFinishNotification(file, title, message.what != 0)
				);
				sendDownloaderCallback();
				doStop();
			}
		};

		final ZLNetworkRequest request = new ZLNetworkRequest(urlString, sslCertificate, null) {
			public void handleStream(URLConnection connection, InputStream inputStream) throws IOException, ZLNetworkException {
				final int updateIntervalMillis = 1000; // FIXME: remove hardcoded time constant

				final int fileLength = connection.getContentLength();
				int downloadedPart = 0;
				long progressTime = System.currentTimeMillis() + updateIntervalMillis;
				if (fileLength <= 0) {
					progressHandler.sendEmptyMessage(-1);
				}
				OutputStream outStream;
				try {
					outStream = new FileOutputStream(file);
				} catch (FileNotFoundException ex) {
					throw new ZLNetworkException(ZLNetworkException.ERROR_CREATE_FILE, file.getPath());
				}
				try {
					final byte[] buffer = new byte[8192];
					while (true) {
						final int size = inputStream.read(buffer);
						if (size <= 0) {
							break;
						}
						downloadedPart += size;
						if (fileLength > 0) {
							final long currentTime = System.currentTimeMillis();
							if (currentTime > progressTime) {
								progressTime = currentTime + updateIntervalMillis;
								progressHandler.sendEmptyMessage(downloadedPart * 100 / fileLength);
							}
							/*if (downloadedPart * 100 / fileLength > 95) {
								throw new IOException(""debug exception"");
							}*/
						}
						outStream.write(buffer, 0, size);
						/*try {
							Thread.currentThread().sleep(200);
						} catch (InterruptedException ex) {
						}*/
					}
				} finally {
					outStream.close();
				}
			}
		};

		final Thread downloader = new Thread(new Runnable() {
			public void run() {
				boolean success = false;
				try {
					ZLNetworkManager.Instance().perform(request);
					success = true;
				} catch (ZLNetworkException e) {
					// TODO: show error message to User
					file.delete();
				} finally {
					downloadFinishHandler.sendEmptyMessage(success ? 1 : 0);
				}
			}
		});
		downloader.setPriority(Thread.MIN_PRIORITY);
		downloader.start();
	}
}
",True,377,0,0,9,94,3,7,L6
239,org.geometerplus.android.fbreader.network.AddCustomCatalogItemActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.fbreader.network.NetworkTree;


class AddCustomCatalogItemActions extends NetworkTreeActions {

	public static final int RUN_ITEM_ID = 0;

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof AddCustomCatalogItemTree;
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		return RUN_ITEM_ID;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		return false;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		switch (actionCode) {
			case RUN_ITEM_ID:
				addCustomCatalog(activity);
				return true;
		}
		return false;
	}

	public static void addCustomCatalog(Activity activity) {
		NetworkDialog.show(activity, NetworkDialog.DIALOG_CUSTOM_CATALOG, null, null);
	}
}
",False,377,0,0,9,113,2,5,L6
240,org.geometerplus.android.fbreader.network.NetworkTreeActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Activity;
import android.view.Menu;
import android.view.ContextMenu;
import android.view.MenuItem;

import org.geometerplus.zlibrary.core.resources.ZLResource;

import org.geometerplus.fbreader.network.NetworkTree;


abstract class NetworkTreeActions {

	// special values to return from getDefaultActionCode(NetworkTree)
	public static final int TREE_NO_ACTION = -1;
	public static final int TREE_SHOW_CONTEXT_MENU = -2;


	protected final ZLResource myResource = ZLResource.resource(""networkView"");

	protected final String getTitleValue(String key) {
		return myResource.getResource(key).getValue();
	}

	protected final String getTitleValue(String key, String arg) {
		return myResource.getResource(key).getValue().replace(""%s"", arg);
	}

	protected final String getConfirmValue(String key) {
		return myResource.getResource(""confirmQuestions"").getResource(key).getValue();
	}

	protected final String getConfirmValue(String key, String arg) {
		return myResource.getResource(""confirmQuestions"").getResource(key).getValue().replace(""%s"", arg);
	}

	protected final String getOptionsValue(String key) {
		return myResource.getResource(""menu"").getResource(key).getValue();
	}

	protected final String getOptionsValue(String key, String arg) {
		return myResource.getResource(""menu"").getResource(key).getValue().replace(""%s"", arg);
	}

	protected final MenuItem addMenuItem(ContextMenu menu, int id, String key) {
		return menu.add(0, id, 0, getTitleValue(key)).setEnabled(id != TREE_NO_ACTION);
	}

	protected final MenuItem addMenuItem(ContextMenu menu, int id, String key, String arg) {
		return menu.add(0, id, 0, getTitleValue(key, arg)).setEnabled(id != TREE_NO_ACTION);
	}

	protected final MenuItem addOptionsItem(Menu menu, int id, String key/*, int iconId*/) {
		final MenuItem item = menu.add(0, id, 0, getOptionsValue(key));
		//item.setIcon(iconId);
		return item;
	}

	protected final MenuItem addOptionsItem(Menu menu, int id, String key, String arg/*, int iconId*/) {
		final MenuItem item = menu.add(0, id, 0, getOptionsValue(key, arg));
		//item.setIcon(iconId);
		return item;
	}

	protected final MenuItem prepareOptionsItem(Menu menu, int id, boolean state) {
		return menu.findItem(id).setVisible(state).setEnabled(state);
	}

	protected final MenuItem prepareOptionsItem(Menu menu, int id, boolean state, String key, String arg) {
		final MenuItem item = prepareOptionsItem(menu, id, state);
		if (state) {
			item.setTitle(getOptionsValue(key, arg));
		}
		return item;
	}


	public abstract boolean canHandleTree(NetworkTree tree);

	public String getTreeTitle(NetworkTree tree) {
		return tree.getName();
	}

	public abstract void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree);

	public abstract int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree);
	public abstract String getConfirmText(NetworkTree tree, int actionCode);

	public abstract boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode);

	public abstract boolean createOptionsMenu(Menu menu, NetworkTree tree);
	public abstract boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree);
}
",False,377,0,0,9,97,9,4,L6
241,org.geometerplus.android.fbreader.network.SQLiteNetworkDatabase.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.HashMap;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteStatement;

import org.geometerplus.zlibrary.ui.android.library.ZLAndroidApplication;

import org.geometerplus.fbreader.network.ICustomNetworkLink;
import org.geometerplus.fbreader.network.NetworkDatabase;

class SQLiteNetworkDatabase extends NetworkDatabase {
	private final SQLiteDatabase myDatabase;

	SQLiteNetworkDatabase() {
		myDatabase = ZLAndroidApplication.Instance().openOrCreateDatabase(""network.db"", Context.MODE_PRIVATE, null);
		migrate();
	}

	private void migrate() {
		final int version = myDatabase.getVersion();
		final int currentCodeVersion = 1;
		if (version >= currentCodeVersion) {
			return;
		}
		myDatabase.beginTransaction();
		switch (version) {
			case 0:
				createTables();
		}
		myDatabase.setTransactionSuccessful();
		myDatabase.endTransaction();

		myDatabase.execSQL(""VACUUM"");
		myDatabase.setVersion(currentCodeVersion);
	}

	protected void executeAsATransaction(Runnable actions) {
		myDatabase.beginTransaction();
		try {
			actions.run();
			myDatabase.setTransactionSuccessful();
		} finally {
			myDatabase.endTransaction();
		}
	}

	private static void bindString(SQLiteStatement statement, int index, String value) {
		if (value != null) {
			statement.bindString(index, value);
		} else {
			statement.bindNull(index);
		}
	}

	@Override
	protected void loadCustomLinks(ICustomLinksHandler handler) {
		final Cursor cursor = myDatabase.rawQuery(""SELECT link_id,title,site_name,summary,icon FROM CustomLinks"", null);
		final HashMap<String,String> linksMap = new HashMap<String,String>();
		while (cursor.moveToNext()) {
			final int id = cursor.getInt(0);
			final String title = cursor.getString(1);
			final String siteName = cursor.getString(2);
			final String summary = cursor.getString(3);
			final String icon = cursor.getString(4);

			linksMap.clear();
			final Cursor linksCursor = myDatabase.rawQuery(""SELECT key,url FROM CustomLinkUrls WHERE link_id = "" + id, null);
			while (linksCursor.moveToNext()) {
				linksMap.put(linksCursor.getString(0), linksCursor.getString(1));
			}
			linksCursor.close();

			handler.handleCustomLinkData(id, siteName, title, summary, icon, linksMap);
		}
		cursor.close();
	}

	private SQLiteStatement myInsertCustomLinkStatement;
	private SQLiteStatement myUpdateCustomLinkStatement;
	private SQLiteStatement myInsertCustomLinkUrlStatement;
	private SQLiteStatement myUpdateCustomLinkUrlStatement;
	private SQLiteStatement myDeleteCustomLinkUrlStatement;
	@Override
	protected void saveCustomLink(final ICustomNetworkLink link) {
		executeAsATransaction(new Runnable() {
			public void run() {
				final SQLiteStatement statement;
				if (link.getId() == ICustomNetworkLink.INVALID_ID) {
					if (myInsertCustomLinkStatement == null) {
						myInsertCustomLinkStatement = myDatabase.compileStatement(
							""INSERT INTO CustomLinks (title,site_name,summary,icon) VALUES (?,?,?,?)""
						);
					}
					statement = myInsertCustomLinkStatement;
				} else {
					if (myUpdateCustomLinkStatement == null) {
						myUpdateCustomLinkStatement = myDatabase.compileStatement(
							""UPDATE CustomLinks SET title = ?, site_name = ?, summary =?, icon = ? ""
								+ ""WHERE link_id = ?""
						);
					}
					statement = myUpdateCustomLinkStatement;
				}

				statement.bindString(1, link.getTitle());
				statement.bindString(2, link.getSiteName());
				bindString(statement, 3, link.getSummary());
				bindString(statement, 4, link.getIcon());

				final long id;
				final HashMap<String,String> linksMap = new HashMap<String,String>();

				if (statement == myInsertCustomLinkStatement) {
					id = statement.executeInsert();
					link.setId((int) id);
				} else {
					id = link.getId();
					statement.bindLong(5, id);
					statement.execute();
					
					final Cursor linksCursor = myDatabase.rawQuery(""SELECT key,url FROM CustomLinkUrls WHERE link_id = "" + link.getId(), null);
					while (linksCursor.moveToNext()) {
						linksMap.put(linksCursor.getString(0), linksCursor.getString(1));
					}
					linksCursor.close();
				}

				for (String key: link.getLinkKeys()) {
					final String value = link.getLink(key);
					final String dbValue = linksMap.remove(key);
					final SQLiteStatement urlStatement;
					if (dbValue == null) {
						if (myInsertCustomLinkUrlStatement == null) {
							myInsertCustomLinkUrlStatement = myDatabase.compileStatement(
									""INSERT INTO CustomLinkUrls(url,link_id,key) VALUES (?,?,?)"");
						}
						urlStatement = myInsertCustomLinkUrlStatement;
					} else if (!value.equals(dbValue)) {
						if (myUpdateCustomLinkUrlStatement == null) {
							myUpdateCustomLinkUrlStatement = myDatabase.compileStatement(
									""UPDATE CustomLinkUrls SET url = ? WHERE link_id = ? AND key = ?"");
						}
						urlStatement = myUpdateCustomLinkUrlStatement;
					} else {
						continue;
					}
					urlStatement.bindString(1, value);
					urlStatement.bindLong(2, id);
					urlStatement.bindString(3, key);
					urlStatement.execute();
				}
				for (String key: linksMap.keySet()) {
					if (myDeleteCustomLinkUrlStatement == null) {
						myDeleteCustomLinkUrlStatement = myDatabase.compileStatement(
								""DELETE FROM CustomLinkUrls WHERE link_id = ? AND key = ?"");
					}
					myDeleteCustomLinkUrlStatement.bindLong(1, id);
					myDeleteCustomLinkUrlStatement.bindString(2, key);
					myDeleteCustomLinkUrlStatement.execute();
				}
			}
		});
	}

	private SQLiteStatement myDeleteAllCustomLinksStatement;
	private SQLiteStatement myDeleteCustomLinkStatement;
	@Override
	protected void deleteCustomLink(final ICustomNetworkLink link) {
		if (link.getId() == ICustomNetworkLink.INVALID_ID) {
			return;
		}
		executeAsATransaction(new Runnable() {
			public void run() {
				final long id = link.getId();
				if (myDeleteAllCustomLinksStatement == null) {
					myDeleteAllCustomLinksStatement = myDatabase.compileStatement(
							""DELETE FROM CustomLinkUrls WHERE link_id = ?"");
				}
				myDeleteAllCustomLinksStatement.bindLong(1, id);
				myDeleteAllCustomLinksStatement.execute();

				if (myDeleteCustomLinkStatement == null) {
					myDeleteCustomLinkStatement = myDatabase.compileStatement(
						""DELETE FROM CustomLinks WHERE link_id = ?""
					);
				}
				myDeleteCustomLinkStatement.bindLong(1, id);
				myDeleteCustomLinkStatement.execute();

				link.setId(ICustomNetworkLink.INVALID_ID);
			}
		});
	}
	
	private void createTables() {
		myDatabase.execSQL(
				""CREATE TABLE CustomLinks("" +
					""link_id INTEGER PRIMARY KEY,"" +
					""title TEXT UNIQUE NOT NULL,"" +
					""site_name TEXT NOT NULL,"" +
					""summary TEXT,"" +
					""icon TEXT)"");
		myDatabase.execSQL(
				""CREATE TABLE CustomLinkUrls("" +
					""key TEXT NOT NULL,"" +
					""link_id INTEGER NOT NULL REFERENCES CustomLinks(link_id),"" +
					""url TEXT NOT NULL,"" +
					""CONSTRAINT CustomLinkUrls_PK PRIMARY KEY (key, link_id))"");
	}
}
",True,241,6,17,14,27,1,4,L6
242,org.geometerplus.android.fbreader.network.BookDownloader.java,"/*
 * Copyright (C) 2009-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.List;

import android.os.Bundle;
import android.app.Activity;
import android.net.Uri;
import android.content.Intent;

import org.geometerplus.fbreader.network.BookReference;


public class BookDownloader extends Activity {

	public static boolean acceptsUri(Uri uri) {
		final List<String> path = uri.getPathSegments();
		if ((path == null) || path.isEmpty()) {
			return false;
		}

		if (""epub"".equals(uri.getScheme())) {
			return true;
		}

		final String fileName = path.get(path.size() - 1).toLowerCase();
		return
			fileName.endsWith("".fb2.zip"") ||
			fileName.endsWith("".fb2"") ||
			fileName.endsWith("".epub"") ||
			fileName.endsWith("".mobi"") ||
			fileName.endsWith("".prc"");
	}

	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		final Intent intent = getIntent();
		Uri uri = intent.getData();
		intent.setData(null);
		if (uri == null || !acceptsUri(uri)) {
			finish();
			return;
		}

		if (!intent.hasExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY)) {
			intent.putExtra(BookDownloaderService.SHOW_NOTIFICATIONS_KEY, 
				BookDownloaderService.Notifications.ALREADY_DOWNLOADING);
		}
		if (""epub"".equals(uri.getScheme())) {
			uri = uri.buildUpon().scheme(""http"").build();
			intent.putExtra(BookDownloaderService.BOOK_FORMAT_KEY,
					BookReference.Format.EPUB);
		}

		startService(
			new Intent(Intent.ACTION_DEFAULT, uri, this, BookDownloaderService.class)
				.putExtras(intent.getExtras())
		);
		finish();
	}
}
",False,377,0,0,10,91,1,3,L6
243,org.geometerplus.android.fbreader.network.NetworkCatalogActions.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.Activity;
import android.app.AlertDialog;
import android.os.Message;
import android.os.Handler;
import android.view.Menu;
import android.view.ContextMenu;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.util.ZLBoolean3;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.android.util.UIUtil;
import org.geometerplus.android.util.PackageUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.tree.NetworkTreeFactory;
import org.geometerplus.fbreader.network.tree.NetworkCatalogTree;
import org.geometerplus.fbreader.network.tree.NetworkCatalogRootTree;
import org.geometerplus.fbreader.network.authentication.*;


class NetworkCatalogActions extends NetworkTreeActions {

	public static final int OPEN_CATALOG_ITEM_ID = 0;
	public static final int OPEN_IN_BROWSER_ITEM_ID = 1;
	public static final int RELOAD_ITEM_ID = 2;
	public static final int SIGNUP_ITEM_ID = 3;
	public static final int SIGNIN_ITEM_ID = 4;
	public static final int SIGNOUT_ITEM_ID = 5;
	public static final int REFILL_ACCOUNT_ITEM_ID = 6;

	public static final int CUSTOM_CATALOG_EDIT = 7;
	public static final int CUSTOM_CATALOG_REMOVE = 8;

	@Override
	public boolean canHandleTree(NetworkTree tree) {
		return tree instanceof NetworkCatalogTree;
	}

	@Override
	public String getTreeTitle(NetworkTree tree) {
		if (tree instanceof NetworkCatalogRootTree) {
			return tree.getName();
		}
		return tree.getName() + "" - "" + ((NetworkCatalogTree) tree).Item.Link.getSiteName();
	}

	@Override
	public void buildContextMenu(Activity activity, ContextMenu menu, NetworkTree tree) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		final NetworkCatalogItem item = catalogTree.Item;
		menu.setHeaderTitle(tree.getName());

		boolean hasItems = false;

		final String catalogUrl = item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		if (catalogUrl != null) {
			addMenuItem(menu, OPEN_CATALOG_ITEM_ID, ""openCatalog"");
			hasItems = true;
		}

		if (tree instanceof NetworkCatalogRootTree) {
			if (item.getVisibility() == ZLBoolean3.B3_TRUE) {
				final NetworkAuthenticationManager mgr = item.Link.authenticationManager();
				if (mgr != null) {
					if (mgr.mayBeAuthorised(false)) {
						addMenuItem(menu, SIGNOUT_ITEM_ID, ""signOut"", mgr.currentUserName());
						if (mgr.refillAccountLink() != null) {
							final String account = mgr.currentAccount();
							if (account != null) {
								addMenuItem(menu, REFILL_ACCOUNT_ITEM_ID, ""refillAccount"", account);
							}
						}
					} else {
						addMenuItem(menu, SIGNIN_ITEM_ID, ""signIn"");
						//if (mgr.passwordRecoverySupported()) {
						//	registerAction(new PasswordRecoveryAction(mgr), true);
						//}
					}
				}
			}
			INetworkLink link = catalogTree.Item.Link; 
			if (link instanceof ICustomNetworkLink) {
				addMenuItem(menu, CUSTOM_CATALOG_EDIT, ""editCustomCatalog"");
				addMenuItem(menu, CUSTOM_CATALOG_REMOVE, ""removeCustomCatalog"");
			}
		} else {
			if (item.URLByType.get(NetworkCatalogItem.URL_HTML_PAGE) != null) {
				addMenuItem(menu, OPEN_IN_BROWSER_ITEM_ID, ""openInBrowser"");
				hasItems = true;
			}
		}

		if (item.getVisibility() == ZLBoolean3.B3_UNDEFINED &&
			!hasItems && item.Link.authenticationManager() != null) {
			addMenuItem(menu, SIGNIN_ITEM_ID, ""signIn"");
		}
	}

	@Override
	public int getDefaultActionCode(NetworkBaseActivity activity, NetworkTree tree) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		final NetworkCatalogItem item = catalogTree.Item;
		if (item.URLByType.get(NetworkCatalogItem.URL_CATALOG) != null) {
			return OPEN_CATALOG_ITEM_ID;
		}
		if (item.URLByType.get(NetworkCatalogItem.URL_HTML_PAGE) != null) {
			return OPEN_IN_BROWSER_ITEM_ID;
		}
		if (item.getVisibility() == ZLBoolean3.B3_UNDEFINED &&
			item.Link.authenticationManager() != null) {
			return SIGNIN_ITEM_ID;
		}
		return TREE_NO_ACTION;
	}

	@Override
	public String getConfirmText(NetworkTree tree, int actionCode) {
		if (actionCode == OPEN_IN_BROWSER_ITEM_ID) {
			return getConfirmValue(""openInBrowser"");
		}
		return null;
	}

	@Override
	public boolean createOptionsMenu(Menu menu, NetworkTree tree) {
		addOptionsItem(menu, RELOAD_ITEM_ID, ""reload"");
		addOptionsItem(menu, SIGNIN_ITEM_ID, ""signIn"");
		addOptionsItem(menu, SIGNUP_ITEM_ID, ""signUp"");
		addOptionsItem(menu, SIGNOUT_ITEM_ID, ""signOut"", """");
		addOptionsItem(menu, REFILL_ACCOUNT_ITEM_ID, ""refillAccount"");
		return true;
	}

	@Override
	public boolean prepareOptionsMenu(NetworkBaseActivity activity, Menu menu, NetworkTree tree) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		final NetworkCatalogItem item = catalogTree.Item;

		final String catalogUrl = item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		final boolean isLoading = (catalogUrl != null) ?
			NetworkView.Instance().containsItemsLoadingRunnable(catalogUrl) : false;

		prepareOptionsItem(menu, RELOAD_ITEM_ID, catalogUrl != null && !isLoading);

		boolean signIn = false;
		boolean signOut = false;
		boolean refill = false;
		String userName = null;
		String account = null;
		NetworkAuthenticationManager mgr = item.Link.authenticationManager();
		if (mgr != null) {
			if (mgr.mayBeAuthorised(false)) {
				userName = mgr.currentUserName();
				signOut = true;
				account = mgr.currentAccount();
				if (mgr.refillAccountLink() != null && account != null) {
					refill = true;
				}
			} else {
				signIn = true;
				//if (mgr.passwordRecoverySupported()) {
				//	registerAction(new PasswordRecoveryAction(mgr), true);
				//}
			}
		}
		prepareOptionsItem(menu, SIGNIN_ITEM_ID, signIn);
		prepareOptionsItem(menu, SIGNUP_ITEM_ID, signIn & Util.isRegistrationSupported(activity, item.Link));
		prepareOptionsItem(menu, SIGNOUT_ITEM_ID, signOut, ""signOut"", userName);
		prepareOptionsItem(menu, REFILL_ACCOUNT_ITEM_ID, refill);
		return true;
	}

	private boolean consumeByVisibility(final NetworkBaseActivity activity, final NetworkTree tree, final int actionCode) {
		final NetworkCatalogTree catalogTree = (NetworkCatalogTree) tree;
		switch (catalogTree.Item.getVisibility()) {
			case B3_TRUE:
				return false;
			case B3_UNDEFINED:
				NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, ((NetworkCatalogTree)tree).Item.Link, new Runnable() {
					public void run() {
						if (catalogTree.Item.getVisibility() != ZLBoolean3.B3_TRUE) {
							return;
						}
						if (actionCode != SIGNIN_ITEM_ID) {
							runAction(activity, tree, actionCode);
						}
					}
				});
				break;
		}
		return true;
	}

	@Override
	public boolean runAction(NetworkBaseActivity activity, NetworkTree tree, int actionCode) {
		if (consumeByVisibility(activity, tree, actionCode)) {
			return true;
		}
		switch (actionCode) {
			case OPEN_CATALOG_ITEM_ID:
				doExpandCatalog(activity, (NetworkCatalogTree)tree);
				return true;
			case OPEN_IN_BROWSER_ITEM_ID:
				Util.openInBrowser(
					activity,
					((NetworkCatalogTree)tree).Item.URLByType.get(NetworkCatalogItem.URL_HTML_PAGE)
				);
				return true;
			case RELOAD_ITEM_ID:
				doReloadCatalog(activity, (NetworkCatalogTree)tree);
				return true;
			case SIGNIN_ITEM_ID:
				NetworkDialog.show(activity, NetworkDialog.DIALOG_AUTHENTICATION, ((NetworkCatalogTree)tree).Item.Link, null);
				return true;
			case SIGNUP_ITEM_ID:
				Util.runRegistrationDialog(activity, ((NetworkCatalogTree)tree).Item.Link);
				return true;
			case SIGNOUT_ITEM_ID:
				doSignOut(activity, (NetworkCatalogTree)tree);
				return true;
			case REFILL_ACCOUNT_ITEM_ID:
				new RefillAccountActions().runStandalone(activity, ((RefillAccountTree)activity.getDefaultTree()).Link);
				return true;
			case CUSTOM_CATALOG_EDIT:
				NetworkDialog.show(activity, NetworkDialog.DIALOG_CUSTOM_CATALOG, ((NetworkCatalogTree)tree).Item.Link, null);
				return true;
			case CUSTOM_CATALOG_REMOVE:
				removeCustomLink((ICustomNetworkLink)((NetworkCatalogTree)tree).Item.Link);
				return true;
		}
		return false;
	}


	private static class ExpandCatalogHandler extends ItemsLoadingHandler {

		private final String myKey;
		private final NetworkCatalogTree myTree;

		ExpandCatalogHandler(NetworkCatalogTree tree, String key) {
			myTree = tree;
			myKey = key;
		}

		@Override
		public void onUpdateItems(List<NetworkLibraryItem> items) {
			for (NetworkLibraryItem item: items) {
				myTree.ChildrenItems.add(item);
				NetworkTreeFactory.createNetworkTree(myTree, item);
			}
		}

		@Override
		public void afterUpdateItems() {
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		@Override
		public void onFinish(String errorMessage, boolean interrupted,
				Set<NetworkLibraryItem> uncommitedItems) {
			if (interrupted &&
					(!myTree.Item.supportsResumeLoading() || errorMessage != null)) {
				myTree.ChildrenItems.clear();
				myTree.clear();
			} else {
				myTree.removeItems(uncommitedItems);
				myTree.updateLoadedTime();
				if (!interrupted) {
					afterUpdateCatalog(errorMessage, myTree.ChildrenItems.size() == 0);
				}
				final NetworkLibrary library = NetworkLibrary.Instance();
				library.invalidateVisibility();
				library.synchronize();
			}
			if (NetworkView.Instance().isInitialized()) {
				NetworkView.Instance().fireModelChangedAsync();
			}
		}

		private void afterUpdateCatalog(String errorMessage, boolean childrenEmpty) {
			final ZLResource dialogResource = ZLResource.resource(""dialog"");
			ZLResource boxResource = null;
			String msg = null;
			if (errorMessage != null) {
				boxResource = dialogResource.getResource(""networkError"");
				msg = errorMessage;
			} else if (childrenEmpty) {
				// TODO: make ListView's empty view instead
				boxResource = dialogResource.getResource(""emptyCatalogBox"");
				msg = boxResource.getResource(""message"").getValue();
			}
			if (msg != null) {
				if (NetworkView.Instance().isInitialized()) {
					final NetworkCatalogActivity activity = NetworkView.Instance().getOpenedActivity(myKey);
					if (activity != null) {
						final ZLResource buttonResource = dialogResource.getResource(""button"");
						new AlertDialog.Builder(activity)
							.setTitle(boxResource.getResource(""title"").getValue())
							.setMessage(msg)
							.setIcon(0)
							.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
							.create().show();
					}
				}
			}
		}
	}

	private static class ExpandCatalogRunnable extends ItemsLoadingRunnable {
		private final NetworkCatalogTree myTree;
		private final boolean myCheckAuthentication;
		private final boolean myResumeNotLoad;

		public ExpandCatalogRunnable(ItemsLoadingHandler handler,
				NetworkCatalogTree tree, boolean checkAuthentication, boolean resumeNotLoad) {
			super(handler);
			myTree = tree;
			myCheckAuthentication = checkAuthentication;
			myResumeNotLoad = resumeNotLoad;
		}

		public String getResourceKey() {
			return ""downloadingCatalogs"";
		}

		@Override
		public void doBefore() throws ZLNetworkException {
			/*if (!NetworkOperationRunnable::tryConnect()) {
				return;
			}*/
			final INetworkLink link = myTree.Item.Link;
			if (myCheckAuthentication && link.authenticationManager() != null) {
				final NetworkAuthenticationManager mgr = link.authenticationManager();
				if (mgr.isAuthorised(true) && mgr.needsInitialization()) {
					try {
						mgr.initialize();
					} catch (ZLNetworkException e) {
						mgr.logOut();
					}
				}
			}
		}

		@Override
		public void doLoading(NetworkOperationData.OnNewItemListener doWithListener) throws ZLNetworkException {
			if (myResumeNotLoad) {
				myTree.Item.resumeLoading(doWithListener);
			} else {
				myTree.Item.loadChildren(doWithListener);
			}
		}
	}

	private void processExtraData(final NetworkBaseActivity activity, Map<String,String> extraData, final Runnable postRunnable) {
		if (extraData != null && !extraData.isEmpty()) {
			PackageUtil.runInstallPluginDialog(activity, extraData, postRunnable);
		} else {
			postRunnable.run();
		}
	}

	public void doExpandCatalog(final NetworkBaseActivity activity, final NetworkCatalogTree tree) {
		final String url = tree.Item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		if (url == null) {
			throw new RuntimeException(""That's impossible!!!"");
		}
		NetworkView.Instance().tryResumeLoading(activity, tree, url, new Runnable() {
			public void run() {
				boolean resumeNotLoad = false;
				if (tree.hasChildren()) {
					if (tree.isContentValid()) {
						if (tree.Item.supportsResumeLoading()) {
							resumeNotLoad = true;
						} else {
							NetworkView.Instance().openTree(activity, tree, url);
							return;
						}
					} else {
						tree.ChildrenItems.clear();
						tree.clear();
						NetworkView.Instance().fireModelChangedAsync();
					}
				}

				final ExpandCatalogHandler handler = new ExpandCatalogHandler(tree, url);
				NetworkView.Instance().startItemsLoading(
					activity,
					url,
					new ExpandCatalogRunnable(handler, tree, true, resumeNotLoad)
				);
				processExtraData(activity, tree.Item.extraData(), new Runnable() {
					public void run() {
						NetworkView.Instance().openTree(activity, tree, url);
					}
				});
			}
		});
	}

	public void doReloadCatalog(NetworkBaseActivity activity, final NetworkCatalogTree tree) {
		final String url = tree.Item.URLByType.get(NetworkCatalogItem.URL_CATALOG);
		if (url == null) {
			throw new RuntimeException(""That's impossible!!!"");
		}
		if (NetworkView.Instance().containsItemsLoadingRunnable(url)) {
			return;
		}
		tree.ChildrenItems.clear();
		tree.clear();
		NetworkView.Instance().fireModelChangedAsync();
		final ExpandCatalogHandler handler = new ExpandCatalogHandler(tree, url);
		NetworkView.Instance().startItemsLoading(
			activity,
			url,
			new ExpandCatalogRunnable(handler, tree, false, false)
		);
	}

	private void doSignOut(NetworkBaseActivity activity, NetworkCatalogTree tree) {
		final Handler handler = new Handler() {
			public void handleMessage(Message message) {
				final NetworkLibrary library = NetworkLibrary.Instance();
				library.invalidateVisibility();
				library.synchronize();
				if (NetworkView.Instance().isInitialized()) {
					NetworkView.Instance().fireModelChanged();
				}
			}
		};
		final NetworkAuthenticationManager mgr = tree.Item.Link.authenticationManager();
		final Runnable runnable = new Runnable() {
			public void run() {
				if (mgr.mayBeAuthorised(false)) {
					mgr.logOut();
					handler.sendEmptyMessage(0);
				}
			}
		};
		UIUtil.wait(""signOut"", runnable, activity);
	}

	private void removeCustomLink(ICustomNetworkLink link) {
		final NetworkLibrary library = NetworkLibrary.Instance();
		library.removeCustomLink(link);
		library.updateChildren();
		library.synchronize();
		NetworkView.Instance().fireModelChangedAsync();
	}
}
",True,377,0,0,9,96,1,28,L6
244,org.geometerplus.android.fbreader.network.NetworkBaseActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.*;
import android.os.Bundle;
import android.view.*;
import android.widget.*;
import android.content.Intent;
import android.content.DialogInterface;
import android.graphics.Bitmap;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.image.ZLImage;
import org.geometerplus.zlibrary.core.image.ZLLoadableImage;

import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageManager;
import org.geometerplus.zlibrary.ui.android.image.ZLAndroidImageData;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.tree.NetworkBookTree;

import org.geometerplus.android.fbreader.tree.ZLAndroidTree;

abstract class NetworkBaseActivity extends ListActivity implements NetworkView.EventListener {

	protected final ZLResource myResource = ZLResource.resource(""networkView"");

	public BookDownloaderServiceConnection Connection;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);
		Thread.setDefaultUncaughtExceptionHandler(new org.geometerplus.zlibrary.ui.android.library.UncaughtExceptionHandler(this));

		Connection = new BookDownloaderServiceConnection();
		bindService(
			new Intent(getApplicationContext(), BookDownloaderService.class),
			Connection,
			BIND_AUTO_CREATE
		);
	}

	@Override
	public void onDestroy() {
		if (Connection != null) {
			unbindService(Connection);
			Connection = null;
		}
		super.onDestroy();
	}

	@Override
	protected void onStart() {
		super.onStart();

		/*
		 * Set listener in onStart() to give descendants initialize itself in
		 * onCreate methods before onModelChanged() will be called.
		 */
		NetworkView.Instance().addEventListener(this);
	}

	@Override
	protected void onStop() {
		NetworkView.Instance().removeEventListener(this);
		super.onStop();
	}

	@Override
	public void onResume() {
		super.onResume();
		getListView().setOnCreateContextMenuListener(this);
		onModelChanged(); // do the same update actions as upon onModelChanged
	}


	// method from NetworkView.EventListener
	public void onModelChanged() {
	}

	private final Runnable myInvalidateViewsRunnable = new Runnable() {
		public void run() {
			getListView().invalidateViews();
		}
	};

	private void setupCover(final ImageView coverView, NetworkTree tree, int width, int height) {
		if (tree instanceof ZLAndroidTree) {
			coverView.setImageResource(((ZLAndroidTree)tree).getCoverResourceId());
			return;
		}

		Bitmap coverBitmap = null;
		ZLImage cover = tree.getCover();
		if (cover != null) {
			ZLAndroidImageData data = null;
			final ZLAndroidImageManager mgr = (ZLAndroidImageManager)ZLAndroidImageManager.Instance();
			if (cover instanceof ZLLoadableImage) {
				final ZLLoadableImage img = (ZLLoadableImage)cover;
				if (img.isSynchronized()) {
					data = mgr.getImageData(img);
				} else {
					img.startSynchronization(myInvalidateViewsRunnable);
				}
			} else {
				data = mgr.getImageData(cover);
			}
			if (data != null) {
				coverBitmap = data.getBitmap(2 * width, 2 * height);
			}
		}
		if (coverBitmap != null) {
			coverView.setImageBitmap(coverBitmap);
		} else if (tree instanceof NetworkBookTree) {
			coverView.setImageResource(R.drawable.ic_list_library_book);
		} else {
			coverView.setImageResource(R.drawable.ic_list_library_books);
		}
	}

	private int myCoverWidth = -1;
	private int myCoverHeight = -1;

	protected View setupNetworkTreeItemView(View convertView, final ViewGroup parent, NetworkTree tree) {
		final View view = (convertView != null) ? convertView :
			LayoutInflater.from(parent.getContext()).inflate(R.layout.network_tree_item, parent, false);

		((TextView)view.findViewById(R.id.network_tree_item_name)).setText(tree.getName());
		((TextView)view.findViewById(R.id.network_tree_item_childrenlist)).setText(tree.getSecondString());

		if (myCoverWidth == -1) {
			view.measure(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT);
			myCoverHeight = view.getMeasuredHeight();
			myCoverWidth = myCoverHeight * 15 / 32;
			view.requestLayout();
		}

		final ImageView coverView = (ImageView)view.findViewById(R.id.network_tree_item_icon);
		coverView.getLayoutParams().width = myCoverWidth;
		coverView.getLayoutParams().height = myCoverHeight;
		coverView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
		coverView.requestLayout();
		setupCover(coverView, tree, myCoverWidth, myCoverWidth);

		final ImageView statusView = (ImageView)view.findViewById(R.id.network_tree_item_status);
		final int status = (tree instanceof NetworkBookTree) ?
				NetworkBookActions.getBookStatus(((NetworkBookTree) tree).Book, Connection) : 0;
		if (status != 0) {
			statusView.setVisibility(View.VISIBLE);
			statusView.setImageResource(status);
		} else {
			statusView.setVisibility(View.GONE);
		}
		statusView.requestLayout();

		return view;
	}

	@Override
	public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
		NetworkTree tree = null;
		if (menuInfo != null) {
			final int position = ((AdapterView.AdapterContextMenuInfo)menuInfo).position;
			tree = (NetworkTree)getListAdapter().getItem(position);
		} else {
			tree = getDefaultTree();
		}
		if (tree != null) {
			final NetworkTreeActions actions = NetworkView.Instance().getActions(tree);
			if (actions != null) {
				actions.buildContextMenu(this, menu, tree);
			}
		}
	}

	private NetworkTree myDefaultTree;
	protected NetworkTree getDefaultTree() {
		return myDefaultTree;
	}
	protected void setDefaultTree(NetworkTree tree) {
		myDefaultTree = tree;
	}

	@Override
	public boolean onContextItemSelected(MenuItem item) {
		NetworkTree tree = null;
		if (item != null && item.getMenuInfo() != null) {
			final int position = ((AdapterView.AdapterContextMenuInfo)item.getMenuInfo()).position;
			tree = (NetworkTree)getListAdapter().getItem(position);
		} else {
			tree = getDefaultTree();
		}
		if (tree != null) {
			final NetworkTreeActions actions = NetworkView.Instance().getActions(tree);
			if (actions != null && actions.runAction(this, tree, item.getItemId())) {
				return true;
			}
		}
		return super.onContextItemSelected(item);
	}

	@Override
	public void onListItemClick(ListView listView, View view, int position, long rowId) {
		final NetworkTree networkTree = (NetworkTree)getListAdapter().getItem(position);
		final NetworkView networkView = NetworkView.Instance();
		final NetworkTreeActions actions = networkView.getActions(networkTree);
		if (actions == null) {
			return;
		}
		final int actionCode = actions.getDefaultActionCode(this, networkTree);
		final String confirm = actions.getConfirmText(networkTree, actionCode);
		if (actionCode == NetworkTreeActions.TREE_SHOW_CONTEXT_MENU) {
			listView.showContextMenuForChild(view);
			return;
		}
		if (actionCode < 0) {
			return;
		}
		if (confirm != null) {
			//final ZLResource resource = myResource.getResource(""confirmQuestions"");
			final ZLResource buttonResource = ZLResource.resource(""dialog"").getResource(""button"");
			new AlertDialog.Builder(this)
				.setTitle(networkTree.getName())
				.setMessage(confirm)
				.setIcon(0)
				.setPositiveButton(buttonResource.getResource(""yes"").getValue(), new DialogInterface.OnClickListener() {
					public void onClick(DialogInterface dialog, int which) {
						actions.runAction(NetworkBaseActivity.this, networkTree, actionCode);
					}
				})
				.setNegativeButton(buttonResource.getResource(""no"").getValue(), null)
				.create().show();
		} else {
			actions.runAction(this, networkTree, actionCode);
		}
	}

	@Override
	protected Dialog onCreateDialog(int id) {
		if (!NetworkView.Instance().isInitialized()) {
			return null;
		}
		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			return dlg.createDialog(this);
		}
		return null;
	}

	@Override
	protected void onPrepareDialog(int id, Dialog dialog) {
		super.onPrepareDialog(id, dialog);

		final NetworkDialog dlg = NetworkDialog.getDialog(id);
		if (dlg != null) {
			dlg.prepareDialog(this, dialog);
		}		
	}

	@Override
	public boolean onSearchRequested() {
		return false;
	}
}
",False,377,0,0,8,100,9,16,L6
245,org.geometerplus.android.fbreader.network.CustomCatalogDialog.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import android.app.Dialog;
import android.app.AlertDialog;
import android.net.Uri;
import android.os.Handler;
import android.os.Message;
import android.view.View;
import android.widget.TextView;
import android.content.DialogInterface;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.util.UIUtil;

import org.geometerplus.fbreader.network.*;
import org.geometerplus.fbreader.network.opds.OPDSLinkReader;


class CustomCatalogDialog extends NetworkDialog {

	private String myTitle;
	private String myUrl;
	private String mySummary;

	private boolean myLinkWithoutInfo;

	public CustomCatalogDialog() {
		super(""CustomCatalogDialog"");
	}

	@Override
	protected void clearData() {
		myTitle = myUrl = mySummary = null;
		myLinkWithoutInfo = false;
	}

	@Override
	protected View createLayout() {
		final View layout = myActivity.getLayoutInflater().inflate(R.layout.network_custom_catalog_dialog, null);

		((TextView) layout.findViewById(R.id.network_catalog_title_text)).setText(myResource.getResource(""catalogTitle"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_url_text)).setText(myResource.getResource(""catalogUrl"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_summary_text)).setText(myResource.getResource(""catalogSummary"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_title_example)).setText(myResource.getResource(""catalogTitleExample"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_url_example)).setText(myResource.getResource(""catalogUrlExample"").getValue());
		((TextView) layout.findViewById(R.id.network_catalog_summary_example)).setText(myResource.getResource(""catalogSummaryExample"").getValue());

		return layout;
	}

	@Override
	protected void onPositive(DialogInterface dialog) {
		AlertDialog alert = (AlertDialog) dialog;
		myTitle = ((TextView) alert.findViewById(R.id.network_catalog_title)).getText().toString().trim();
		myUrl = ((TextView) alert.findViewById(R.id.network_catalog_url)).getText().toString().trim();
		mySummary = ((TextView) alert.findViewById(R.id.network_catalog_summary)).getText().toString().trim();

		if (myTitle.length() == 0) {
			myTitle = null;
			if (myLink != null) {
				final String err = myResource.getResource(""titleIsEmpty"").getValue();
				sendError(true, false, err);
				return;
			}
		}
		if (myUrl.length() == 0) {
			myUrl = null;
			final String err = myResource.getResource(""urlIsEmpty"").getValue();
			sendError(true, false, err);
			return;
		}
		if (mySummary.length() == 0) {
			mySummary = null;
		}

		Uri uri = Uri.parse(myUrl);
		if (uri.getScheme() == null) {
			myUrl = ""http://"" + myUrl;
			uri = Uri.parse(myUrl);
		}

		String siteName = uri.getHost();
		if (siteName == null) {
			final String err = myResource.getResource(""invalidUrl"").getValue();
			sendError(true, false, err);
			return;
		}
		if (siteName.startsWith(""www."")) {
			siteName = siteName.substring(4);
		}

		final NetworkLibrary library = NetworkLibrary.Instance();
		if (myLink != null && library.hasCustomLinkTitle(myTitle, myLink)) {
			final String err = myResource.getResource(""titleAlreadyExists"").getValue();
			sendError(true, false, err);
			return;
		}
		if (library.hasCustomLinkSite(siteName, myLink)) {
			final String err = myResource.getResource(""siteAlreadyExists"").getValue();
			sendError(true, false, err);
			return;
		}

		if (myLink != null) {
			final ICustomNetworkLink link = (ICustomNetworkLink) myLink;
			link.setSiteName(siteName);
			link.setTitle(myTitle);
			link.setSummary(mySummary);
			link.setLink(INetworkLink.URL_MAIN, myUrl);

			if (myLinkWithoutInfo) {
				NetworkLibrary.Instance().addCustomLink(link);
				myLinkWithoutInfo = false;
			} else {
				link.saveLink();
			}
			sendSuccess(true);
			return;
		}

		myLinkWithoutInfo = true;
		myLink = OPDSLinkReader.createCustomLinkWithoutInfo(siteName, myUrl);

		final Handler handler = new Handler() {
			public void handleMessage(Message msg) {
				final String err = (String) msg.obj;
				if (err != null) {
					final DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {
						public void onClick(DialogInterface dialog, int which) {
							if (which == DialogInterface.BUTTON_NEGATIVE) {
								sendSuccess(true);
							} else {
								if (which == DialogInterface.BUTTON_NEUTRAL) {
									myLinkWithoutInfo = false;
									myLink = null;
								}
								sendError(true, false, null);
							}
						}
					};
					final ZLResource dialogResource = ZLResource.resource(""dialog"");
					final ZLResource boxResource = dialogResource.getResource(""networkError"");
					final ZLResource buttonResource = dialogResource.getResource(""button"");
					new AlertDialog.Builder(myActivity)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage(err)
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""continue"").getValue(), listener)
						.setNeutralButton(buttonResource.getResource(""editUrl"").getValue(), listener)
						.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), listener)
						.setOnCancelListener(new DialogInterface.OnCancelListener() {
							public void onCancel(DialogInterface dialog) {
								listener.onClick(dialog, DialogInterface.BUTTON_NEGATIVE);
							}
						})
						.create().show();
				} else {
					sendError(true, false, null);
				}
			}
		};

		final Runnable loadInfoRunnable = new Runnable() {
			public void run() {
				String error = null;
				try {
					((ICustomNetworkLink)myLink).reloadInfo();
				} catch (ZLNetworkException e) {
					error = e.getMessage();
				}
				handler.sendMessage(handler.obtainMessage(0, error));
			}
		}; 
		UIUtil.wait(""loadingCatalogInfo"", loadInfoRunnable, myActivity);
	}

	@Override
	protected void onNegative(DialogInterface dialog) {
		sendCancel(false);
	}

	@Override
	public void prepareDialogInternal(Dialog dialog) {
		if (myLink != null) {
			if (myTitle == null) myTitle = myLink.getTitle();
			if (myUrl == null) myUrl = myLink.getLink(INetworkLink.URL_MAIN);
			if (mySummary == null) mySummary = myLink.getSummary();
		}
		((TextView) dialog.findViewById(R.id.network_catalog_title)).setText(myTitle);
		((TextView) dialog.findViewById(R.id.network_catalog_url)).setText(myUrl);
		((TextView) dialog.findViewById(R.id.network_catalog_summary)).setText(mySummary);

		final int examplesVisibility = (myLink == null || myLinkWithoutInfo) ? View.VISIBLE : View.GONE;
		dialog.findViewById(R.id.network_catalog_title_example).setVisibility(examplesVisibility);
		dialog.findViewById(R.id.network_catalog_url_example).setVisibility(examplesVisibility);
		dialog.findViewById(R.id.network_catalog_summary_example).setVisibility(examplesVisibility);

		final int groupsVisibility = (myLink != null) ? View.VISIBLE : View.GONE;
		dialog.findViewById(R.id.network_catalog_title_group).setVisibility(groupsVisibility);
		dialog.findViewById(R.id.network_catalog_summary_group).setVisibility(groupsVisibility);

		final TextView error = (TextView) dialog.findViewById(R.id.network_catalog_error);
		if (myErrorMessage == null) {
			error.setVisibility(View.GONE);
			error.setText("""");
		} else {
			error.setVisibility(View.VISIBLE);
			error.setText(myErrorMessage);
		}

		View dlgView = dialog.findViewById(R.id.network_custom_catalog_dialog);
		dlgView.invalidate();
		dlgView.requestLayout();
	}
}
",False,377,0,0,10,98,1,8,L6
246,org.geometerplus.android.fbreader.network.NetworkLibraryActivity.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.network;

import java.util.*;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.view.*;
import android.widget.BaseAdapter;

import org.geometerplus.zlibrary.core.resources.ZLResource;
import org.geometerplus.zlibrary.core.network.ZLNetworkException;
import org.geometerplus.zlibrary.core.language.ZLLanguageUtil;

import org.geometerplus.zlibrary.ui.android.R;

import org.geometerplus.android.util.UIUtil;

import org.geometerplus.fbreader.network.NetworkTree;
import org.geometerplus.fbreader.network.NetworkLibrary;

public class NetworkLibraryActivity extends NetworkBaseActivity {
	private NetworkTree myTree;

	@Override
	public void onCreate(Bundle icicle) {
		super.onCreate(icicle);

		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setDefaultKeyMode(DEFAULT_KEYS_SEARCH_LOCAL);
	}

	private void prepareView() {
		if (myTree == null) {
			myTree = NetworkLibrary.Instance().getTree();
			setListAdapter(new LibraryAdapter());
			getListView().invalidateViews();
		}
	}

	private static Initializator myInitializator; 

	@Override
	public void onResume() {
		super.onResume();
		if (!NetworkView.Instance().isInitialized()) {
			if (myInitializator == null) {
				myInitializator = new Initializator(this);
				myInitializator.start();
			} else {
				myInitializator.setActivity(this);
			}
		} else {
			prepareView();
		}
	}

	@Override
	public void onDestroy() {
		if (!NetworkView.Instance().isInitialized()
				&& myInitializator != null) {
			myInitializator.setActivity(null);
		}
		super.onDestroy();
	}

	private static class Initializator extends Handler {
		private NetworkLibraryActivity myActivity;

		public Initializator(NetworkLibraryActivity activity) {
			myActivity = activity;
		}

		public void setActivity(NetworkLibraryActivity activity) {
			myActivity = activity;
		}

		final DialogInterface.OnClickListener myListener = new DialogInterface.OnClickListener() {
			public void onClick(DialogInterface dialog, int which) {
				if (which == DialogInterface.BUTTON_POSITIVE) {
					Initializator.this.start();
				} else if (myActivity != null) {
					myActivity.finish();
				}
			}
		};

		// run this method only if myActivity != null
		private void runInitialization() {
			UIUtil.wait(""loadingNetworkLibrary"", new Runnable() {
				public void run() {
					String error = null;
					try {
						NetworkView.Instance().initialize();
					} catch (ZLNetworkException e) {
						error = e.getMessage();
					}
					Initializator.this.end(error);
				}
			}, myActivity);
		}

		// run this method only if myActivity != null
		private void processResults(String error) {
			final ZLResource dialogResource = ZLResource.resource(""dialog"");
			final ZLResource boxResource = dialogResource.getResource(""networkError"");
			final ZLResource buttonResource = dialogResource.getResource(""button"");
			new AlertDialog.Builder(myActivity)
				.setTitle(boxResource.getResource(""title"").getValue())
				.setMessage(error)
				.setIcon(0)
				.setPositiveButton(buttonResource.getResource(""tryAgain"").getValue(), myListener)
				.setNegativeButton(buttonResource.getResource(""cancel"").getValue(), myListener)
				.setOnCancelListener(new DialogInterface.OnCancelListener() {
					public void onCancel(DialogInterface dialog) {
						myListener.onClick(dialog, DialogInterface.BUTTON_NEGATIVE);
					}
				})
				.create().show();
		}

		@Override
		public void handleMessage(Message message) {
			if (myActivity == null) {
				return;
			} else if (message.what == 0) {
				runInitialization(); // run initialization process
			} else if (message.obj == null) {
				myActivity.startService(new Intent(myActivity.getApplicationContext(), LibraryInitializationService.class));
				myActivity.prepareView(); // initialization is complete successfully
			} else {
				processResults((String) message.obj); // handle initialization error
			}
		}

		public void start() {
			sendEmptyMessage(0);
		}

		private void end(String error) {
			sendMessage(obtainMessage(1, error));
		}
	}


	private final class LibraryAdapter extends BaseAdapter {
		public final int getCount() {
			if (!NetworkView.Instance().isInitialized()) {
				return 0;
			}
			return myTree.subTrees().size() + 2; // subtrees + <search item>
		}

		public final NetworkTree getItem(int position) {
			final int size = myTree.subTrees().size();
			if (position == 0) {
				return NetworkView.Instance().getSearchItemTree();
			} else if (position > 0 && position <= size) {
				return (NetworkTree)myTree.subTrees().get(position - 1);
			} else if (position == size + 1) {
				return NetworkView.Instance().getAddCustomCatalogItemTree();
			}
			return null;
		}

		public final long getItemId(int position) {
			return position;
		}

		public View getView(int position, View convertView, final ViewGroup parent) {
			final NetworkTree tree = getItem(position);
			return setupNetworkTreeItemView(convertView, parent, tree);
		}
	}


	protected MenuItem addMenuItem(Menu menu, int index, String resourceKey, int iconId) {
		final String label = myResource.getResource(""menu"").getResource(resourceKey).getValue();
		return menu.add(0, index, Menu.NONE, label).setIcon(iconId);
	}


	private static final int MENU_SEARCH = 1;
	private static final int MENU_REFRESH = 2;
	private static final int MENU_ADD_CATALOG = 3;
	private static final int MENU_LANGUAGE_FILTER = 4;

	@Override
	public boolean onCreateOptionsMenu(Menu menu) {
		super.onCreateOptionsMenu(menu);
		addMenuItem(menu, MENU_SEARCH, ""networkSearch"", R.drawable.ic_menu_search);
		addMenuItem(menu, MENU_ADD_CATALOG, ""addCustomCatalog"", R.drawable.ic_menu_add);
		addMenuItem(menu, MENU_REFRESH, ""refreshCatalogsList"", R.drawable.ic_menu_refresh);
		addMenuItem(menu, MENU_LANGUAGE_FILTER, ""languages"", R.drawable.ic_menu_languages);
		return true;
	}

	@Override
	public boolean onPrepareOptionsMenu(Menu menu) {
		super.onPrepareOptionsMenu(menu);
		final boolean searchInProgress = NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY);
		menu.findItem(MENU_SEARCH).setEnabled(!searchInProgress);
		return true;
	}

	private void runLanguageFilterDialog() {
		final NetworkLibrary library = NetworkLibrary.Instance();

		final List<String> allLanguageCodes = library.languageCodes();
		Collections.sort(allLanguageCodes, new ZLLanguageUtil.CodeComparator());
		final Collection<String> activeLanguageCodes = library.activeLanguageCodes();
		final CharSequence[] languageNames = new CharSequence[allLanguageCodes.size()];
		final boolean[] checked = new boolean[allLanguageCodes.size()];

		for (int i = 0; i < allLanguageCodes.size(); ++i) {
			final String code = allLanguageCodes.get(i);
			languageNames[i] = ZLLanguageUtil.languageName(code);
			checked[i] = activeLanguageCodes.contains(code);
		}

		final DialogInterface.OnMultiChoiceClickListener listener =
			new DialogInterface.OnMultiChoiceClickListener() {
				public void onClick(DialogInterface dialog, int which, boolean isChecked) {
					checked[which] = isChecked;
				}
			};
		final ZLResource dialogResource = ZLResource.resource(""dialog"");
		final AlertDialog dialog = new AlertDialog.Builder(this)
			.setMultiChoiceItems(languageNames, checked, listener)
			.setTitle(dialogResource.getResource(""languageFilterDialog"").getResource(""title"").getValue())
			.setPositiveButton(dialogResource.getResource(""button"").getResource(""ok"").getValue(), new DialogInterface.OnClickListener() {
				public void onClick(DialogInterface dialog, int which) {
					final TreeSet<String> newActiveCodes = new TreeSet<String>(new ZLLanguageUtil.CodeComparator());
					for (int i = 0; i < checked.length; ++i) {
						if (checked[i]) {
							newActiveCodes.add(allLanguageCodes.get(i));
						}
					}
					library.setActiveLanguageCodes(newActiveCodes);
					library.invalidateChildren();
					library.synchronize();
					NetworkView.Instance().fireModelChanged();
				}
			})
			.create();
		dialog.show();
	}

	@Override
	public boolean onOptionsItemSelected(MenuItem item) {
		switch (item.getItemId()) {
			case MENU_SEARCH:
				return onSearchRequested();
			case MENU_ADD_CATALOG:
				AddCustomCatalogItemActions.addCustomCatalog(this);
				return true;
			case MENU_REFRESH:
				refreshCatalogsList();
				return true;
			case MENU_LANGUAGE_FILTER:
				runLanguageFilterDialog();
				return true;
			default:
				return true;
		}
	}

	@Override
	public boolean onSearchRequested() {
		if (NetworkView.Instance().containsItemsLoadingRunnable(NetworkSearchActivity.SEARCH_RUNNABLE_KEY)) {
			return false;
		}
		final NetworkLibrary library = NetworkLibrary.Instance();
		startSearch(library.NetworkSearchPatternOption.getValue(), true, null, false);
		return true;
	}

	@Override
	public void onModelChanged() {
		getListView().invalidateViews();
	}

	private void refreshCatalogsList() {
		final NetworkView view = NetworkView.Instance();

		final Handler handler = new Handler() {
			@Override
			public void handleMessage(Message msg) {
				if (msg.obj == null) {
					view.finishBackgroundUpdate();
				} else {
					final ZLResource dialogResource = ZLResource.resource(""dialog"");
					final ZLResource boxResource = dialogResource.getResource(""networkError"");
					final ZLResource buttonResource = dialogResource.getResource(""button"");
					new AlertDialog.Builder(NetworkLibraryActivity.this)
						.setTitle(boxResource.getResource(""title"").getValue())
						.setMessage((String) msg.obj)
						.setIcon(0)
						.setPositiveButton(buttonResource.getResource(""ok"").getValue(), null)
						.create().show();
				}
			}
		};

		UIUtil.wait(""updatingCatalogsList"", new Runnable() {
			public void run() {
				String error = null;
				try {
					view.runBackgroundUpdate(true);
				} catch (ZLNetworkException e) {
					error = e.getMessage();
				}
				handler.sendMessage(handler.obtainMessage(0, error));
			}
		}, this);
	}
}
",False,377,0,0,9,101,1,12,L6
247,org.geometerplus.android.fbreader.tree.ZLAndroidTree.java,"/*
 * Copyright (C) 2010-2011 Geometer Plus <contact@geometerplus.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */

package org.geometerplus.android.fbreader.tree;

public interface ZLAndroidTree {
	int getCoverResourceId();
}
",False,48,5,18,0,0,6,0,L6
